{"sha": "59fb88d061544a035f3043b47594b34789204cee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZmI4OGQwNjE1NDRhMDM1ZjMwNDNiNDc1OTRiMzQ3ODkyMDRjZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T16:13:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T16:13:26Z"}, "message": "Auto merge of #76327 - lzutao:split-core-num, r=SimonSapin\n\nSplit `core/num/mod.rs` to smaller mods\n\nNote for reviewer:\n* I split to multiple commits for easier reviewing, but I could git squash them all to one if requested.\n* Recommend pulling this change locally and using advanced git diff viewer or this command:\n  ```\n  git show --reverse --color-moved=dimmed-zebra master..\n  ```\n\n---\n\nI split `core/num/mod.rs` to these modules:\n\n* `error`: For error structs like `ParseIntError`.\n* blanket `shells` dir: For dummy number type modules: std::i32, std::f32, and the likes. Why? See below.\n* `int_macros` and `uint_macros`: Real implementation of all integer types via `int_impl` and `uint_impl`\n* `nonzero`: For `NonZero*` types and their implementations.\n* `wrapping`: For `Wrapping<T>` types.", "tree": {"sha": "0b8de56e6e2719b155a9bc9f70065e7200b2a370", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b8de56e6e2719b155a9bc9f70065e7200b2a370"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59fb88d061544a035f3043b47594b34789204cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59fb88d061544a035f3043b47594b34789204cee", "html_url": "https://github.com/rust-lang/rust/commit/59fb88d061544a035f3043b47594b34789204cee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59fb88d061544a035f3043b47594b34789204cee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f", "html_url": "https://github.com/rust-lang/rust/commit/b3aae050cd7e0c9a9eb6085bd49b02f67dc1396f"}, {"sha": "a50ec5f144b414d3c14fe04fc07f935c2ea0ab0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a50ec5f144b414d3c14fe04fc07f935c2ea0ab0f", "html_url": "https://github.com/rust-lang/rust/commit/a50ec5f144b414d3c14fe04fc07f935c2ea0ab0f"}], "stats": {"total": 9455, "additions": 4748, "deletions": 4707}, "files": [{"sha": "4cb81fb2a45ec2fbe65978d1d63a26f12d8bd41e", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -169,34 +169,34 @@ mod macros;\n #[macro_use]\n mod internal_macros;\n \n-#[path = \"num/int_macros.rs\"]\n+#[path = \"num/shells/int_macros.rs\"]\n #[macro_use]\n mod int_macros;\n \n-#[path = \"num/i128.rs\"]\n+#[path = \"num/shells/i128.rs\"]\n pub mod i128;\n-#[path = \"num/i16.rs\"]\n+#[path = \"num/shells/i16.rs\"]\n pub mod i16;\n-#[path = \"num/i32.rs\"]\n+#[path = \"num/shells/i32.rs\"]\n pub mod i32;\n-#[path = \"num/i64.rs\"]\n+#[path = \"num/shells/i64.rs\"]\n pub mod i64;\n-#[path = \"num/i8.rs\"]\n+#[path = \"num/shells/i8.rs\"]\n pub mod i8;\n-#[path = \"num/isize.rs\"]\n+#[path = \"num/shells/isize.rs\"]\n pub mod isize;\n \n-#[path = \"num/u128.rs\"]\n+#[path = \"num/shells/u128.rs\"]\n pub mod u128;\n-#[path = \"num/u16.rs\"]\n+#[path = \"num/shells/u16.rs\"]\n pub mod u16;\n-#[path = \"num/u32.rs\"]\n+#[path = \"num/shells/u32.rs\"]\n pub mod u32;\n-#[path = \"num/u64.rs\"]\n+#[path = \"num/shells/u64.rs\"]\n pub mod u64;\n-#[path = \"num/u8.rs\"]\n+#[path = \"num/shells/u8.rs\"]\n pub mod u8;\n-#[path = \"num/usize.rs\"]\n+#[path = \"num/shells/usize.rs\"]\n pub mod usize;\n \n #[path = \"num/f32.rs\"]"}, {"sha": "aab171551861178ca6f0e65bf569d583156bc13d", "filename": "library/core/src/num/error.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -0,0 +1,151 @@\n+//! Error types for conversion to integral types.\n+\n+use crate::convert::Infallible;\n+use crate::fmt;\n+\n+/// The error type returned when a checked integral type conversion fails.\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromIntError(pub(crate) ());\n+\n+impl TryFromIntError {\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        \"out of range integral type conversion attempted\"\n+    }\n+}\n+\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl fmt::Display for TryFromIntError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.__description().fmt(fmt)\n+    }\n+}\n+\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(x: Infallible) -> TryFromIntError {\n+        match x {}\n+    }\n+}\n+\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n+impl From<!> for TryFromIntError {\n+    fn from(never: !) -> TryFromIntError {\n+        // Match rather than coerce to make sure that code like\n+        // `From<Infallible> for TryFromIntError` above will keep working\n+        // when `Infallible` becomes an alias to `!`.\n+        match never {}\n+    }\n+}\n+\n+/// An error which can be returned when parsing an integer.\n+///\n+/// This error is used as the error type for the `from_str_radix()` functions\n+/// on the primitive integer types, such as [`i8::from_str_radix`].\n+///\n+/// # Potential causes\n+///\n+/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n+/// in the string e.g., when it is obtained from the standard input.\n+/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n+///\n+/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n+/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n+///\n+/// # Example\n+///\n+/// ```\n+/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n+///     println!(\"Failed conversion to i32: {}\", e);\n+/// }\n+/// ```\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseIntError {\n+    pub(super) kind: IntErrorKind,\n+}\n+\n+/// Enum to store the various types of errors that can cause parsing an integer to fail.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(int_error_matching)]\n+///\n+/// # fn main() {\n+/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n+///     println!(\"Failed conversion to i32: {:?}\", e.kind());\n+/// }\n+/// # }\n+/// ```\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[non_exhaustive]\n+pub enum IntErrorKind {\n+    /// Value being parsed is empty.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing an empty string.\n+    Empty,\n+    /// Contains an invalid digit.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing a string that\n+    /// contains a letter.\n+    InvalidDigit,\n+    /// Integer is too large to store in target integer type.\n+    Overflow,\n+    /// Integer is too small to store in target integer type.\n+    Underflow,\n+    /// Value was Zero\n+    ///\n+    /// This variant will be emitted when the parsing string has a value of zero, which\n+    /// would be illegal for non-zero types.\n+    Zero,\n+}\n+\n+impl ParseIntError {\n+    /// Outputs the detailed cause of parsing an integer failing.\n+    #[unstable(\n+        feature = \"int_error_matching\",\n+        reason = \"it can be useful to match errors when making error messages \\\n+                  for integer parsing\",\n+        issue = \"22639\"\n+    )]\n+    pub fn kind(&self) -> &IntErrorKind {\n+        &self.kind\n+    }\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            IntErrorKind::Overflow => \"number too large to fit in target type\",\n+            IntErrorKind::Underflow => \"number too small to fit in target type\",\n+            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}"}, {"sha": "369175fb6ab1eca8a6cb51e9016249a882e76e80", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 2182, "deletions": 30, "changes": 2212, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -1,49 +1,2201 @@\n-#![doc(hidden)]\n-\n-macro_rules! doc_comment {\n-    ($x:expr, $($tt:tt)*) => {\n-        #[doc = $x]\n-        $($tt)*\n-    };\n-}\n-\n-macro_rules! int_module {\n-    ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n-    ($T:ident, #[$attr:meta]) => (\n+macro_rules! int_impl {\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n+     $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n+     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n+     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n         doc_comment! {\n             concat!(\"The smallest value that can be represented by this integer type.\n-Use [`\", stringify!($T), \"::MIN\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MIN) instead.\n \n # Examples\n \n-```rust\n-// deprecated way\n-let min = std::\", stringify!($T), \"::MIN;\n+Basic usage:\n \n-// intended way\n-let min = \", stringify!($T), \"::MIN;\n ```\n-\"),\n-            #[$attr]\n-            pub const MIN: $T = $T::MIN;\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n+            pub const MIN: Self = !0 ^ ((!0 as $UnsignedT) >> 1) as Self;\n         }\n \n         doc_comment! {\n             concat!(\"The largest value that can be represented by this integer type.\n-Use [`\", stringify!($T), \"::MAX\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MAX) instead.\n \n # Examples\n \n-```rust\n-// deprecated way\n-let max = std::\", stringify!($T), \"::MAX;\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n+            pub const MAX: Self = !Self::MIN;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"The size of this integer type in bits.\n+\n+# Examples\n+\n+```\n+\", $Feature, \"#![feature(int_bits_const)]\n+assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+            pub const BITS: u32 = $BITS;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts a string slice in a given base to an integer.\n+\n+The string is expected to be an optional `+` or `-` sign followed by digits.\n+Leading and trailing whitespace represent an error. Digits are a subset of these characters,\n+depending on `radix`:\n+\n+ * `0-9`\n+ * `a-z`\n+ * `A-Z`\n+\n+# Panics\n+\n+This function panics if `radix` is not in the range from 2 to 36.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n+                from_str_radix(src, radix)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0b100_0000\", stringify!($SelfT), \";\n \n-// intended way\n-let max = \", stringify!($T), \"::MAX;\n+assert_eq!(n.count_ones(), 1);\",\n+$EndFeature, \"\n ```\n \"),\n-            #[$attr]\n-            pub const MAX: $T = $T::MAX;\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = -1\", stringify!($SelfT), \";\n+\n+assert_eq!(n.leading_zeros(), 0);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                (self as $UnsignedT).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = -4\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_zeros(), 2);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                (self as $UnsignedT).trailing_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = -1\", stringify!($SelfT), \";\n+\n+assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[inline]\n+            pub const fn leading_ones(self) -> u32 {\n+                (self as $UnsignedT).leading_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 3\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_ones(), 2);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[inline]\n+            pub const fn trailing_ones(self) -> u32 {\n+                (self as $UnsignedT).trailing_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the left by a specified amount, `n`,\n+wrapping the truncated bits to the end of the resulting integer.\n+\n+Please note this isn't the same operation as the `<<` shifting operator!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_op, stringify!($SelfT), \";\n+let m = \", $rot_result, \";\n+\n+assert_eq!(n.rotate_left(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n+                (self as $UnsignedT).rotate_left(n) as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the right by a specified amount, `n`,\n+wrapping the truncated bits to the beginning of the resulting\n+integer.\n+\n+Please note this isn't the same operation as the `>>` shifting operator!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_result, stringify!($SelfT), \";\n+let m = \", $rot_op, \";\n+\n+assert_eq!(n.rotate_right(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n+                (self as $UnsignedT).rotate_right(n) as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Reverses the byte order of the integer.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $swap_op, stringify!($SelfT), \";\n+\n+let m = n.swap_bytes();\n+\n+assert_eq!(m, \", $swapped, \");\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn swap_bytes(self) -> Self {\n+                (self as $UnsignedT).swap_bytes() as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Reverses the bit pattern of the integer.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $swap_op, stringify!($SelfT), \";\n+let m = n.reverse_bits();\n+\n+assert_eq!(m, \", $reversed, \");\n+```\"),\n+            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            #[must_use]\n+            pub const fn reverse_bits(self) -> Self {\n+                (self as $UnsignedT).reverse_bits() as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts an integer from big endian to the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n+}\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts an integer from little endian to the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n+}\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts `self` to big endian from the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(n.to_be(), n)\n+} else {\n+    assert_eq!(n.to_be(), n.swap_bytes())\n+}\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts `self` to little endian from the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(n.to_le(), n)\n+} else {\n+    assert_eq!(n.to_le(), n.swap_bytes())\n+}\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n+if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\n+assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_add(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\n+assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_sub(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT),\n+\"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_mul(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n+or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n+                    None\n+                } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n+                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n+returning `None` if `rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!((\", stringify!($SelfT),\n+\"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n+                    None\n+                } else {\n+                    Some(self.div_euclid(rhs))\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None` if\n+`rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n+                    None\n+                } else {\n+                    // SAFETY: div by zero and by INT_MIN have been checked above\n+                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n+if `rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n+                    None\n+                } else {\n+                    Some(self.rem_euclid(rhs))\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn checked_neg(self) -> Option<Self> {\n+                let (a, b) = self.overflowing_neg();\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n+than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n+assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shl(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n+larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shr(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked absolute value. Computes `self.abs()`, returning `None` if\n+`self == MIN`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn checked_abs(self) -> Option<Self> {\n+                if self.is_negative() {\n+                    self.checked_neg()\n+                } else {\n+                    Some(self)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = try_opt!(acc.checked_mul(base));\n+                    }\n+                    exp /= 2;\n+                    base = try_opt!(base.checked_mul(base));\n+                }\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                Some(try_opt!(acc.checked_mul(base)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n+bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT),\n+\"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT),\n+\"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT),\n+\"::MIN);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT),\n+\"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n+instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\n+assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT),\n+\"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT),\n+\"::MIN + 1);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn saturating_neg(self) -> Self {\n+                intrinsics::saturating_sub(0, self)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n+MIN` instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\n+assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT),\n+\"::MAX);\n+assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT),\n+\"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn saturating_abs(self) -> Self {\n+                if self.is_negative() {\n+                    self.saturating_neg()\n+                } else {\n+                    self\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer multiplication. Computes `self * rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => if (self < 0) == (rhs < 0) {\n+                        Self::MAX\n+                    } else {\n+                        Self::MIN\n+                    }\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None if self < 0 && exp % 2 == 1 => Self::MIN,\n+                    None => Self::MAX,\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n+boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT),\n+\"::MIN + 1);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_add(self, rhs: Self) -> Self {\n+                intrinsics::wrapping_add(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n+boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\n+assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \",\n+stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n+                intrinsics::wrapping_sub(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n+the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\n+assert_eq!(11i8.wrapping_mul(12), -124);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_mul(self, rhs: Self) -> Self {\n+                intrinsics::wrapping_mul(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n+boundary of the type.\n+\n+The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n+`MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n+that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\n+assert_eq!((-128i8).wrapping_div(-1), -128);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n+                self.overflowing_div(rhs).0\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n+wrapping around at the boundary of the type.\n+\n+Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n+for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n+type. In this case, this method returns `MIN` itself.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n+assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_div_euclid(rhs).0\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n+boundary of the type.\n+\n+Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n+invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n+this function returns `0`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\n+assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n+                self.overflowing_rem(rhs).0\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n+at the boundary of the type.\n+\n+Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n+for the type). In this case, this method returns 0.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n+assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_rem_euclid(rhs).0\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n+of the type.\n+\n+The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n+is the negative minimal value for the type); this is a positive value that is too large to represent\n+in the type. In such a case, this function returns `MIN` itself.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT),\n+\"::MIN);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn wrapping_neg(self) -> Self {\n+                self.overflowing_neg().0\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n+any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n+the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n+The primitive integer types all implement a `[`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\n+assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n+                unsafe {\n+                    intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n+removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n+to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n+end. The primitive integer types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\n+assert_eq!((-128i16).wrapping_shr(64), -128);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n+                unsafe {\n+                    intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n+the boundary of the type.\n+\n+The only case where such wrapping can occur is when one takes the absolute value of the negative\n+minimal value for the type; this is a positive value that is too large to represent in the type. In\n+such a case, this function returns `MIN` itself.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\n+assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT),\n+\"::MIN);\n+assert_eq!((-128i8).wrapping_abs() as u8, 128);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[allow(unused_attributes)]\n+            #[inline]\n+            pub const fn wrapping_abs(self) -> Self {\n+                 if self.is_negative() {\n+                     self.wrapping_neg()\n+                 } else {\n+                     self\n+                 }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self` without any wrapping\n+or panicking.\n+\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(unsigned_abs)]\n+assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\n+assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\n+assert_eq!((-128i8).unsigned_abs(), 128u8);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"unsigned_abs\", issue = \"74913\")]\n+            #[inline]\n+            pub const fn unsigned_abs(self) -> $UnsignedT {\n+                 self.wrapping_abs() as $UnsignedT\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\n+assert_eq!(3i8.wrapping_pow(5), -13);\n+assert_eq!(3i8.wrapping_pow(6), -39);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                acc.wrapping_mul(base)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates `self` + `rhs`\n+\n+Returns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT),\n+\"::MIN, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates `self` - `rhs`\n+\n+Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n+would occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT),\n+\"::MAX, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the multiplication of `self` and `rhs`.\n+\n+Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n+would occur. If an overflow would have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\n+assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n+\n+Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would occur then self is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n+                    (self, true)\n+                } else {\n+                    (self / rhs, false)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would occur then `self` is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n+                    (self, true)\n+                } else {\n+                    (self.div_euclid(rhs), false)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n+arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n+                    (0, true)\n+                } else {\n+                    (self % rhs, false)\n+                }\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n+arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n+                    (0, true)\n+                } else {\n+                    (self.rem_euclid(rhs), false)\n+                }\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Negates self, overflowing if this is equal to the minimum value.\n+\n+Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n+happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n+minimum value will be returned again and `true` will be returned for an overflow happening.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT),\n+\"::MIN, true));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[allow(unused_attributes)]\n+            pub const fn overflowing_neg(self) -> (Self, bool) {\n+                if unlikely!(self == Self::MIN) {\n+                    (Self::MIN, true)\n+                } else {\n+                    (-self, false)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts self left by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n+value was larger than or equal to the number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\n+assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts self right by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n+value was larger than or equal to the number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self`.\n+\n+Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n+happened. If self is the minimum value (e.g., \", stringify!($SelfT), \"::MIN for values of type\n+ \", stringify!($SelfT), \"), then the minimum value will be returned again and true will be returned\n+for an overflow happening.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\n+assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\n+assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT),\n+\"::MIN, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn overflowing_abs(self) -> (Self, bool) {\n+                (self.wrapping_abs(), self == Self::MIN)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\n+assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0 {\n+                    return (1,false);\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n+                r\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n+\n+assert_eq!(x.pow(5), 32);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n+                let mut base = self;\n+                let mut acc = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc * base;\n+                    }\n+                    exp /= 2;\n+                    base = base * base;\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                acc * base\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n+\n+This computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`,\n+with `0 <= self.rem_euclid(rhs) < rhs`.\n+\n+In other words, the result is `self / rhs` rounded to the integer `n`\n+such that `self >= n * rhs`.\n+If `self > 0`, this is equal to round towards zero (the default in Rust);\n+if `self < 0`, this is equal to round towards +/- infinity.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0 or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n+assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n+assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n+assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n+                let q = self / rhs;\n+                if self % rhs < 0 {\n+                    return if rhs > 0 { q - 1 } else { q + 1 }\n+                }\n+                q\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the least nonnegative remainder of `self (mod rhs)`.\n+\n+This is done as if by the Euclidean division algorithm -- given\n+`r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and\n+`0 <= r < abs(rhs)`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0 or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.rem_euclid(b), 3);\n+assert_eq!((-a).rem_euclid(b), 1);\n+assert_eq!(a.rem_euclid(-b), 3);\n+assert_eq!((-a).rem_euclid(-b), 1);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n+                let r = self % rhs;\n+                if r < 0 {\n+                    if rhs < 0 {\n+                        r - rhs\n+                    } else {\n+                        r + rhs\n+                    }\n+                } else {\n+                    r\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Computes the absolute value of `self`.\n+\n+# Overflow behavior\n+\n+The absolute value of `\", stringify!($SelfT), \"::MIN` cannot be represented as an\n+`\", stringify!($SelfT), \"`, and attempting to calculate it will cause an overflow. This means that\n+code in debug mode will trigger a panic on this case and optimized code will return `\",\n+stringify!($SelfT), \"::MIN` without a panic.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\n+assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[allow(unused_attributes)]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn abs(self) -> Self {\n+                // Note that the #[inline] above means that the overflow\n+                // semantics of the subtraction depend on the crate we're being\n+                // inlined into.\n+                if self.is_negative() {\n+                    -self\n+                } else {\n+                    self\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns a number representing sign of `self`.\n+\n+ - `0` if the number is zero\n+ - `1` if the number is positive\n+ - `-1` if the number is negative\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\n+assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\n+assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn signum(self) -> Self {\n+                match self {\n+                    n if n > 0 =>  1,\n+                    0          =>  0,\n+                    _          => -1,\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\n+negative.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert!(10\", stringify!($SelfT), \".is_positive());\n+assert!(!(-10\", stringify!($SelfT), \").is_positive());\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn is_positive(self) -> bool { self > 0 }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\n+positive.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert!((-10\", stringify!($SelfT), \").is_negative());\n+assert!(!10\", stringify!($SelfT), \".is_negative());\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn is_negative(self) -> bool { self < 0 }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+big-endian (network) byte order.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n+assert_eq!(bytes, \", $be_bytes, \");\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_be().to_ne_bytes()\n+            }\n+        }\n+\n+doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+little-endian byte order.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n+assert_eq!(bytes, \", $le_bytes, \");\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_le().to_ne_bytes()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+As the target platform's native endianness is used, portable code\n+should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+instead.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+[`to_be_bytes`]: #method.to_be_bytes\n+[`to_le_bytes`]: #method.to_le_bytes\n+\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    }\n+);\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            // SAFETY: const sound because integers are plain old datatypes so we can always\n+            // transmute them to arrays of bytes\n+            #[allow_internal_unstable(const_fn_transmute)]\n+            #[inline]\n+            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n+                unsafe { mem::transmute(self) }\n+            }\n+        }\n+\n+doc_comment! {\n+            concat!(\"Create an integer value from its representation as a byte array in\n+big endian.\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_be(Self::from_ne_bytes(bytes))\n+            }\n+        }\n+\n+doc_comment! {\n+            concat!(\"\n+Create an integer value from its representation as a byte array in\n+little endian.\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_le(Self::from_ne_bytes(bytes))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Create an integer value from its memory representation as a byte\n+array in native endianness.\n+\n+As the target platform's native endianness is used, portable code\n+likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+appropriate instead.\n+\n+[`from_be_bytes`]: #method.from_be_bytes\n+[`from_le_bytes`]: #method.from_le_bytes\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            // SAFETY: const sound because integers are plain old datatypes so we can always\n+            // transmute to them\n+            #[allow_internal_unstable(const_fn_transmute)]\n+            #[inline]\n+            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n+                unsafe { mem::transmute(bytes) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"**This method is soft-deprecated.**\n+\n+Although using it won\u2019t cause a compilation warning,\n+new code should use [`\", stringify!($SelfT), \"::MIN\", \"`](#associatedconstant.MIN) instead.\n+\n+Returns the smallest value that can be represented by this integer type.\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline(always)]\n+            #[rustc_promotable]\n+            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n+            pub const fn min_value() -> Self {\n+                Self::MIN\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"**This method is soft-deprecated.**\n+\n+Although using it won\u2019t cause a compilation warning,\n+new code should use [`\", stringify!($SelfT), \"::MAX\", \"`](#associatedconstant.MAX) instead.\n+\n+Returns the largest value that can be represented by this integer type.\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline(always)]\n+            #[rustc_promotable]\n+            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n+            pub const fn max_value() -> Self {\n+                Self::MAX\n+            }\n         }\n-    )\n+    }\n }"}, {"sha": "4f64e30ccf84a0d43552651631b271eab3d3ff4e", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 129, "deletions": 4662, "changes": 4791, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=59fb88d061544a035f3043b47594b34789204cee"}, {"sha": "382f799bfe5f9fc9459662b17e2b4228803f34be", "filename": "library/core/src/num/nonzero.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -0,0 +1,190 @@\n+//! Definitions of integer that is known not to equal zero.\n+\n+use crate::fmt;\n+use crate::ops::{BitOr, BitOrAssign};\n+use crate::str::FromStr;\n+\n+use super::from_str_radix;\n+use super::{IntErrorKind, ParseIntError};\n+\n+macro_rules! doc_comment {\n+    ($x:expr, $($tt:tt)*) => {\n+        #[doc = $x]\n+        $($tt)*\n+    };\n+}\n+\n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+        $(\n+            #[$stability]\n+            impl fmt::$Trait for $Ty {\n+                #[inline]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    self.get().fmt(f)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! nonzero_integers {\n+    ( $( #[$stability: meta] $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            doc_comment! {\n+                concat!(\"An integer that is known not to equal zero.\n+\n+This enables some memory layout optimization.\n+For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\n+\n+```rust\n+use std::mem::size_of;\n+assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int),\n+\">());\n+```\"),\n+                #[$stability]\n+                #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+                #[repr(transparent)]\n+                #[rustc_layout_scalar_valid_range_start(1)]\n+                #[rustc_nonnull_optimization_guaranteed]\n+                pub struct $Ty($Int);\n+            }\n+\n+            impl $Ty {\n+                /// Creates a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[$stability]\n+                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    // SAFETY: this is guaranteed to be safe by the caller.\n+                    unsafe { Self(n) }\n+                }\n+\n+                /// Creates a non-zero if the given value is not zero.\n+                #[$stability]\n+                #[rustc_const_stable(feature = \"const_nonzero_int_methods\", since = \"1.47.0\")]\n+                #[inline]\n+                pub const fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        // SAFETY: we just checked that there's no `0`\n+                        Some(unsafe { Self(n) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[$stability]\n+                #[inline]\n+                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n+                pub const fn get(self) -> $Int {\n+                    self.0\n+                }\n+\n+            }\n+\n+            #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n+            impl From<$Ty> for $Int {\n+                doc_comment! {\n+                    concat!(\n+\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n+                    fn from(nonzero: $Ty) -> Self {\n+                        nonzero.0\n+                    }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: Self) -> Self::Output {\n+                    // SAFETY: since `self` and `rhs` are both nonzero, the\n+                    // result of the bitwise-or will be nonzero.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr<$Int> for $Ty {\n+                type Output = Self;\n+                #[inline]\n+                fn bitor(self, rhs: $Int) -> Self::Output {\n+                    // SAFETY: since `self` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `rhs`.\n+                    unsafe { $Ty::new_unchecked(self.get() | rhs) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOr<$Ty> for $Int {\n+                type Output = $Ty;\n+                #[inline]\n+                fn bitor(self, rhs: $Ty) -> Self::Output {\n+                    // SAFETY: since `rhs` is nonzero, the result of the\n+                    // bitwise-or will be nonzero regardless of the value of\n+                    // `self`.\n+                    unsafe { $Ty::new_unchecked(self | rhs.get()) }\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOrAssign for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: Self) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n+            #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n+            impl BitOrAssign<$Int> for $Ty {\n+                #[inline]\n+                fn bitor_assign(&mut self, rhs: $Int) {\n+                    *self = *self | rhs;\n+                }\n+            }\n+\n+            impl_nonzero_fmt! {\n+                #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU8(u8);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n+}\n+\n+macro_rules! from_str_radix_nzint_impl {\n+    ($($t:ty)*) => {$(\n+        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n+        impl FromStr for $t {\n+            type Err = ParseIntError;\n+            fn from_str(src: &str) -> Result<Self, Self::Err> {\n+                Self::new(from_str_radix(src, 10)?)\n+                    .ok_or(ParseIntError {\n+                        kind: IntErrorKind::Zero\n+                    })\n+            }\n+        }\n+    )*}\n+}\n+\n+from_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\n+NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }"}, {"sha": "08cb7959468689ceb44d7a633e2a9b6d26ebaf50", "filename": "library/core/src/num/shells/i128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi128.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/i128.rs"}, {"sha": "288eaceba59d6babd5f53187e2e73909eb195eb3", "filename": "library/core/src/num/shells/i16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi16.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/i16.rs"}, {"sha": "0e1a2ec56ccb2419b003425d87c94c815b4f24e7", "filename": "library/core/src/num/shells/i32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi32.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/i32.rs"}, {"sha": "27f7092710b347872842c2016b556cd122e42f27", "filename": "library/core/src/num/shells/i64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi64.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/i64.rs"}, {"sha": "e84b421e1a4447c9785f3b751b8d0bbe7e993831", "filename": "library/core/src/num/shells/i8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fi8.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/i8.rs"}, {"sha": "ffd30b03f2109c677692713e06c203351aa89b09", "filename": "library/core/src/num/shells/int_macros.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -0,0 +1,49 @@\n+#![doc(hidden)]\n+\n+macro_rules! doc_comment {\n+    ($x:expr, $($tt:tt)*) => {\n+        #[doc = $x]\n+        $($tt)*\n+    };\n+}\n+\n+macro_rules! int_module {\n+    ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n+    ($T:ident, #[$attr:meta]) => (\n+        doc_comment! {\n+            concat!(\"The smallest value that can be represented by this integer type.\n+Use [`\", stringify!($T), \"::MIN\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MIN) instead.\n+\n+# Examples\n+\n+```rust\n+// deprecated way\n+let min = std::\", stringify!($T), \"::MIN;\n+\n+// intended way\n+let min = \", stringify!($T), \"::MIN;\n+```\n+\"),\n+            #[$attr]\n+            pub const MIN: $T = $T::MIN;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"The largest value that can be represented by this integer type.\n+Use [`\", stringify!($T), \"::MAX\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MAX) instead.\n+\n+# Examples\n+\n+```rust\n+// deprecated way\n+let max = std::\", stringify!($T), \"::MAX;\n+\n+// intended way\n+let max = \", stringify!($T), \"::MAX;\n+```\n+\"),\n+            #[$attr]\n+            pub const MAX: $T = $T::MAX;\n+        }\n+    )\n+}"}, {"sha": "0dcfa4a2bd134509a29179cf6b001725c14c5a80", "filename": "library/core/src/num/shells/isize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fisize.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/isize.rs"}, {"sha": "dd45ff141539fcd4c7d8b58e51bc3eddbf3b64c5", "filename": "library/core/src/num/shells/u128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu128.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/u128.rs"}, {"sha": "738071643b63963d1884914c1ed833c5c314d93c", "filename": "library/core/src/num/shells/u16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu16.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/u16.rs"}, {"sha": "9800c9099748fece634361a65ec82b83b0587e72", "filename": "library/core/src/num/shells/u32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu32.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/u32.rs"}, {"sha": "fb686c396f033e4075b02816f870624a3fa88a36", "filename": "library/core/src/num/shells/u64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu64.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/u64.rs"}, {"sha": "c03cbdda25dbbbcd41b34595d4ba980c7ba894b7", "filename": "library/core/src/num/shells/u8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fu8.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/u8.rs"}, {"sha": "a89304161524463aeb55f15b97784fc4d69fa45e", "filename": "library/core/src/num/shells/usize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fusize.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "previous_filename": "library/core/src/num/usize.rs"}, {"sha": "234c309961c9c6e45aa2741085ba57d5e045a0ff", "filename": "library/core/src/num/uint_macros.rs", "status": "added", "additions": 1955, "deletions": 0, "changes": 1955, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -0,0 +1,1955 @@\n+macro_rules! uint_impl {\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n+        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n+        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n+        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n+        doc_comment! {\n+            concat!(\"The smallest value that can be represented by this integer type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n+            pub const MIN: Self = 0;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"The largest value that can be represented by this integer type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n+            pub const MAX: Self = !0;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"The size of this integer type in bits.\n+\n+# Examples\n+\n+```\n+\", $Feature, \"#![feature(int_bits_const)]\n+assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+            pub const BITS: u32 = $BITS;\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts a string slice in a given base to an integer.\n+\n+The string is expected to be an optional `+` sign\n+followed by digits.\n+Leading and trailing whitespace represent an error.\n+Digits are a subset of these characters, depending on `radix`:\n+\n+* `0-9`\n+* `a-z`\n+* `A-Z`\n+\n+# Panics\n+\n+This function panics if `radix` is not in the range from 2 to 36.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n+                from_str_radix(src, radix)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0b01001100\", stringify!($SelfT), \";\n+\n+assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn count_ones(self) -> u32 {\n+                intrinsics::ctpop(self as $ActualT) as u32\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = \", stringify!($SelfT), \"::MAX >> 2;\n+\n+assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn leading_zeros(self) -> u32 {\n+                intrinsics::ctlz(self as $ActualT) as u32\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing zeros in the binary representation\n+of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0b0101000\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                intrinsics::cttz(self) as u32\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\n+\n+assert_eq!(n.leading_ones(), 2);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[inline]\n+            pub const fn leading_ones(self) -> u32 {\n+                (!self).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing ones in the binary representation\n+of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0b1010111\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_ones(), 3);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n+            #[inline]\n+            pub const fn trailing_ones(self) -> u32 {\n+                (!self).trailing_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the left by a specified amount, `n`,\n+wrapping the truncated bits to the end of the resulting integer.\n+\n+Please note this isn't the same operation as the `<<` shifting operator!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_op, stringify!($SelfT), \";\n+let m = \", $rot_result, \";\n+\n+assert_eq!(n.rotate_left(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n+                intrinsics::rotate_left(self, n as $SelfT)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts the bits to the right by a specified amount, `n`,\n+wrapping the truncated bits to the beginning of the resulting\n+integer.\n+\n+Please note this isn't the same operation as the `>>` shifting operator!\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $rot_result, stringify!($SelfT), \";\n+let m = \", $rot_op, \";\n+\n+assert_eq!(n.rotate_right(\", $rot, \"), m);\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n+                intrinsics::rotate_right(self, n as $SelfT)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"\n+Reverses the byte order of the integer.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $swap_op, stringify!($SelfT), \";\n+let m = n.swap_bytes();\n+\n+assert_eq!(m, \", $swapped, \");\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn swap_bytes(self) -> Self {\n+                intrinsics::bswap(self as $ActualT) as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Reverses the bit pattern of the integer.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+let n = \", $swap_op, stringify!($SelfT), \";\n+let m = n.reverse_bits();\n+\n+assert_eq!(m, \", $reversed, \");\n+```\"),\n+            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            #[must_use]\n+            pub const fn reverse_bits(self) -> Self {\n+                intrinsics::bitreverse(self as $ActualT) as Self\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts an integer from big endian to the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n+}\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts an integer from little endian to the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n+} else {\n+    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n+}\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts `self` to big endian from the target's endianness.\n+\n+On big endian this is a no-op. On little endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"big\\\") {\n+    assert_eq!(n.to_be(), n)\n+} else {\n+    assert_eq!(n.to_be(), n.swap_bytes())\n+}\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Converts `self` to little endian from the target's endianness.\n+\n+On little endian this is a no-op. On big endian the bytes are\n+swapped.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n+\n+if cfg!(target_endian = \\\"little\\\") {\n+    assert_eq!(n.to_le(), n)\n+} else {\n+    assert_eq!(n.to_le(), n.swap_bytes())\n+}\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\n+if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n+\"Some(\", stringify!($SelfT), \"::MAX - 1));\n+assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_add(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning\n+`None` if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\n+assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_sub(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning\n+`None` if overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n+                let (a, b) = self.overflowing_mul(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked integer division. Computes `self / rhs`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0) {\n+                    None\n+                } else {\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n+                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0) {\n+                    None\n+                } else {\n+                    Some(self.div_euclid(rhs))\n+                }\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0) {\n+                    None\n+                } else {\n+                    // SAFETY: div by zero has been checked above and unsigned types have no other\n+                    // failure modes for division\n+                    Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+                if unlikely!(rhs == 0) {\n+                    None\n+                } else {\n+                    Some(self.rem_euclid(rhs))\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked negation. Computes `-self`, returning `None` unless `self ==\n+0`.\n+\n+Note that negating any positive integer will overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\n+assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn checked_neg(self) -> Option<Self> {\n+                let (a, b) = self.overflowing_neg();\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked shift left. Computes `self << rhs`, returning `None`\n+if `rhs` is larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shl(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None`\n+if `rhs` is larger than or equal to the number of bits in `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\n+assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n+                let (a, b) = self.overflowing_shr(rhs);\n+                if unlikely!(b) {None} else {Some(a)}\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n+overflow occurred.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = try_opt!(acc.checked_mul(base));\n+                    }\n+                    exp /= 2;\n+                    base = try_opt!(base.checked_mul(base));\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+\n+                Some(try_opt!(acc.checked_mul(base)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n+the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\n+at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n+assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[inline]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer multiplication. Computes `self * rhs`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\n+assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\n+\"::MAX);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => Self::MAX,\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\n+saturating at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"\n+assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n+                match self.checked_pow(exp) {\n+                    Some(x) => x,\n+                    None => Self::MAX,\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\n+assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_add(self, rhs: Self) -> Self {\n+                intrinsics::wrapping_add(self, rhs)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n+                intrinsics::wrapping_sub(self, rhs)\n+            }\n+        }\n+\n+        /// Wrapping (modular) multiplication. Computes `self *\n+        /// rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u8` is used here.\n+        ///\n+        /// ```\n+        /// assert_eq!(10u8.wrapping_mul(12), 120);\n+        /// assert_eq!(25u8.wrapping_mul(12), 44);\n+        /// ```\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+        #[inline]\n+        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n+            intrinsics::wrapping_mul(self, rhs)\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) division. Computes `self / rhs`.\n+Wrapped division on unsigned types is just normal division.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n+Wrapped division on unsigned types is just normal division.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_div(rhs)`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`.\n+Wrapped remainder calculation on unsigned types is\n+just the regular remainder calculation.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n+Wrapped modulo calculation on unsigned types is\n+just the regular remainder calculation.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_rem(rhs)`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Since unsigned types do not have negative equivalents\n+        /// all applications of this function will wrap (except for `-0`).\n+        /// For values smaller than the corresponding signed type's maximum\n+        /// the result is the same as casting the corresponding signed value.\n+        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n+        /// `MAX` is the corresponding signed type's maximum.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `i8` is used here.\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_neg(), -100);\n+        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        /// ```\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+        #[inline]\n+        pub const fn wrapping_neg(self) -> Self {\n+            self.overflowing_neg().0\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+where `mask` removes any high-order bits of `rhs` that\n+would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-left; the\n+RHS of a wrapping shift-left is restricted to the range\n+of the type, rather than the bits shifted out of the LHS\n+being returned to the other end. The primitive integer\n+types all implement a [`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\n+assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n+                unsafe {\n+                    intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n+where `mask` removes any high-order bits of `rhs` that\n+would cause the shift to exceed the bitwidth of the type.\n+\n+Note that this is *not* the same as a rotate-right; the\n+RHS of a wrapping shift-right is restricted to the range\n+of the type, rather than the bits shifted out of the LHS\n+being returned to the other end. The primitive integer\n+types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\n+assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n+                // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n+                // out of bounds\n+                unsafe {\n+                    intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n+wrapping around at the boundary of the type.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\n+assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        acc = acc.wrapping_mul(base);\n+                    }\n+                    exp /= 2;\n+                    base = base.wrapping_mul(base);\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                acc.wrapping_mul(base)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates `self` + `rhs`\n+\n+Returns a tuple of the addition along with a boolean indicating\n+whether an arithmetic overflow would occur. If an overflow would\n+have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates `self` - `rhs`\n+\n+Returns a tuple of the subtraction along with a boolean indicating\n+whether an arithmetic overflow would occur. If an overflow would\n+have occurred then the wrapped value is returned.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n+assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n+                (a as Self, b)\n+            }\n+        }\n+\n+        /// Calculates the multiplication of `self` and `rhs`.\n+        ///\n+        /// Returns a tuple of the multiplication along with a boolean\n+        /// indicating whether an arithmetic overflow would occur. If an\n+        /// overflow would have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n+        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n+        /// ```\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n+            (a as Self, b)\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n+\n+Returns a tuple of the divisor along with a boolean indicating\n+whether an arithmetic overflow would occur. Note that for unsigned\n+integers overflow never occurs, so the second value is always\n+`false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+                (self / rhs, false)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating\n+whether an arithmetic overflow would occur. Note that for unsigned\n+integers overflow never occurs, so the second value is always\n+`false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.overflowing_div(rhs)`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+                (self / rhs, false)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean\n+indicating whether an arithmetic overflow would occur. Note that for\n+unsigned integers overflow never occurs, so the second value is\n+always `false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+                (self % rhs, false)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n+\n+Returns a tuple of the modulo after dividing along with a boolean\n+indicating whether an arithmetic overflow would occur. Note that for\n+unsigned integers overflow never occurs, so the second value is\n+always `false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this operation\n+is exactly equal to `self.overflowing_rem(rhs)`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+                (self % rhs, false)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Negates self in an overflowing fashion.\n+\n+Returns `!self + 1` using wrapping operations to return the value\n+that represents the negation of this unsigned value. Note that for\n+positive unsigned values overflow always occurs, but negating 0 does\n+not overflow.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\n+assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT),\n+\", true));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            pub const fn overflowing_neg(self) -> (Self, bool) {\n+                ((!self).wrapping_add(1), self != 0)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts self left by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean\n+indicating whether the shift value was larger than or equal to the\n+number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then\n+used to perform the shift.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\n+assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Shifts self right by `rhs` bits.\n+\n+Returns a tuple of the shifted version of self along with a boolean\n+indicating whether the shift value was larger than or equal to the\n+number of bits. If the shift value is too large, then value is\n+masked (N-1) where N is the number of bits, and this value is then\n+used to perform the shift.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n+assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+                (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+Returns a tuple of the exponentiation along with a bool indicating\n+whether an overflow happened.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\n+assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0{\n+                    return (1,false);\n+                }\n+                let mut base = self;\n+                let mut acc: Self = 1;\n+                let mut overflown = false;\n+                // Scratch space for storing results of overflowing_mul.\n+                let mut r;\n+\n+                while exp > 1 {\n+                    if (exp & 1) == 1 {\n+                        r = acc.overflowing_mul(base);\n+                        acc = r.0;\n+                        overflown |= r.1;\n+                    }\n+                    exp /= 2;\n+                    r = base.overflowing_mul(base);\n+                    base = r.0;\n+                    overflown |= r.1;\n+                }\n+\n+                // since exp!=0, finally the exp must be 1.\n+                // Deal with the final bit of the exponent separately, since\n+                // squaring the base afterwards is not necessary and may cause a\n+                // needless overflow.\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n+\n+                r\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n+```\"),\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn pow(self, mut exp: u32) -> Self {\n+            if exp == 0 {\n+                return 1;\n+            }\n+            let mut base = self;\n+            let mut acc = 1;\n+\n+            while exp > 1 {\n+                if (exp & 1) == 1 {\n+                    acc = acc * base;\n+                }\n+                exp /= 2;\n+                base = base * base;\n+            }\n+\n+            // since exp!=0, finally the exp must be 1.\n+            // Deal with the final bit of the exponent separately, since\n+            // squaring the base afterwards is not necessary and may cause a\n+            // needless overflow.\n+            acc * base\n+        }\n+    }\n+\n+        doc_comment! {\n+            concat!(\"Performs Euclidean division.\n+\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self / rhs`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the least remainder of `self (mod rhs)`.\n+\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self % rhs`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n+```\"),\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert!(16\", stringify!($SelfT), \".is_power_of_two());\n+assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n+            #[inline]\n+            pub const fn is_power_of_two(self) -> bool {\n+                self.count_ones() == 1\n+            }\n+        }\n+\n+        // Returns one less than next power of two.\n+        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n+        //\n+        // 8u8.one_less_than_next_power_of_two() == 7\n+        // 6u8.one_less_than_next_power_of_two() == 7\n+        //\n+        // This method cannot overflow, as in the `next_power_of_two`\n+        // overflow cases it instead ends up returning the maximum value\n+        // of the type, and can return 0 for 0.\n+        #[inline]\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+        const fn one_less_than_next_power_of_two(self) -> Self {\n+            if self <= 1 { return 0; }\n+\n+            let p = self - 1;\n+            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n+            // That means the shift is always in-bounds, and some processors\n+            // (such as intel pre-haswell) have more efficient ctlz\n+            // intrinsics when the argument is non-zero.\n+            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n+            <$SelfT>::MAX >> z\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the smallest power of two greater than or equal to `self`.\n+\n+When return value overflows (i.e., `self > (1 << (N-1))` for type\n+`uN`), it panics in debug mode and return value is wrapped to 0 in\n+release mode (the only situation in which method can return 0).\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\n+assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn next_power_of_two(self) -> Self {\n+                self.one_less_than_next_power_of_two() + 1\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the smallest power of two greater than or equal to `n`. If\n+the next power of two is greater than the type's maximum value,\n+`None` is returned, otherwise the power of two is wrapped in `Some`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(2\", stringify!($SelfT),\n+\".checked_next_power_of_two(), Some(2));\n+assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\n+assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn checked_next_power_of_two(self) -> Option<Self> {\n+                self.one_less_than_next_power_of_two().checked_add(1)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the smallest power of two greater than or equal to `n`. If\n+the next power of two is greater than the type's maximum value,\n+the return value is wrapped to `0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+#![feature(wrapping_next_power_of_two)]\n+\", $Feature, \"\n+assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\n+assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\n+assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n+                       reason = \"needs decision on wrapping behaviour\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn wrapping_next_power_of_two(self) -> Self {\n+                self.one_less_than_next_power_of_two().wrapping_add(1)\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+big-endian (network) byte order.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n+assert_eq!(bytes, \", $be_bytes, \");\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_be().to_ne_bytes()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Return the memory representation of this integer as a byte array in\n+little-endian byte order.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n+assert_eq!(bytes, \", $le_bytes, \");\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                self.to_le().to_ne_bytes()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"\n+Return the memory representation of this integer as a byte array in\n+native byte order.\n+\n+As the target platform's native endianness is used, portable code\n+should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+instead.\n+\",\n+$to_xe_bytes_doc,\n+\"\n+[`to_be_bytes`]: #method.to_be_bytes\n+[`to_le_bytes`]: #method.to_le_bytes\n+\n+# Examples\n+\n+```\n+let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n+        \", $be_bytes, \"\n+    } else {\n+        \", $le_bytes, \"\n+    }\n+);\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            // SAFETY: const sound because integers are plain old datatypes so we can always\n+            // transmute them to arrays of bytes\n+            #[allow_internal_unstable(const_fn_transmute)]\n+            #[inline]\n+            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+                // SAFETY: integers are plain old datatypes so we can always transmute them to\n+                // arrays of bytes\n+                unsafe { mem::transmute(self) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Create a native endian integer value from its representation\n+as a byte array in big endian.\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_be(Self::from_ne_bytes(bytes))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"\n+Create a native endian integer value from its representation\n+as a byte array in little endian.\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            #[inline]\n+            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                Self::from_le(Self::from_ne_bytes(bytes))\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Create a native endian integer value from its memory representation\n+as a byte array in native endianness.\n+\n+As the target platform's native endianness is used, portable code\n+likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+appropriate instead.\n+\n+[`from_be_bytes`]: #method.from_be_bytes\n+[`from_le_bytes`]: #method.from_le_bytes\n+\",\n+$from_xe_bytes_doc,\n+\"\n+# Examples\n+\n+```\n+let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n+assert_eq!(value, \", $swap_op, \");\n+```\n+\n+When starting from a slice rather than an array, fallible conversion APIs can be used:\n+\n+```\n+use std::convert::TryInto;\n+\n+fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n+    let (int_bytes, rest) = input.split_at(std::mem::size_of::<\", stringify!($SelfT), \">());\n+    *input = rest;\n+    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\n+}\n+```\"),\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n+            #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n+            // SAFETY: const sound because integers are plain old datatypes so we can always\n+            // transmute to them\n+            #[allow_internal_unstable(const_fn_transmute)]\n+            #[inline]\n+            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+                // SAFETY: integers are plain old datatypes so we can always transmute to them\n+                unsafe { mem::transmute(bytes) }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"**This method is soft-deprecated.**\n+\n+Although using it won\u2019t cause compilation warning,\n+new code should use [`\", stringify!($SelfT), \"::MIN\", \"`](#associatedconstant.MIN) instead.\n+\n+Returns the smallest value that can be represented by this integer type.\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n+            #[inline(always)]\n+            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n+            pub const fn min_value() -> Self { Self::MIN }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"**This method is soft-deprecated.**\n+\n+Although using it won\u2019t cause compilation warning,\n+new code should use [`\", stringify!($SelfT), \"::MAX\", \"`](#associatedconstant.MAX) instead.\n+\n+Returns the largest value that can be represented by this integer type.\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n+            #[inline(always)]\n+            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n+            pub const fn max_value() -> Self { Self::MAX }\n+        }\n+    }\n+}"}, {"sha": "5324dfdeddde281ce17470651429f5f01f47f644", "filename": "library/core/src/num/wrapping.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -1,6 +1,83 @@\n-use super::Wrapping;\n+//! Definitions of `Wrapping<T>`.\n+\n+use crate::fmt;\n+use crate::ops::{Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign};\n+use crate::ops::{BitXor, BitXorAssign, Div, DivAssign};\n+use crate::ops::{Mul, MulAssign, Neg, Not, Rem, RemAssign};\n+use crate::ops::{Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign};\n+\n+/// Provides intentionally-wrapped arithmetic on `T`.\n+///\n+/// Operations like `+` on `u32` values are intended to never overflow,\n+/// and in some debug configurations overflow is detected and results\n+/// in a panic. While most arithmetic falls into this category, some\n+/// code explicitly expects and relies upon modular arithmetic (e.g.,\n+/// hashing).\n+///\n+/// Wrapping arithmetic can be achieved either through methods like\n+/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n+/// all standard arithmetic operations on the underlying value are\n+/// intended to have wrapping semantics.\n+///\n+/// The underlying value can be retrieved through the `.0` index of the\n+/// `Wrapping` tuple.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::num::Wrapping;\n+///\n+/// let zero = Wrapping(0u32);\n+/// let one = Wrapping(1u32);\n+///\n+/// assert_eq!(u32::MAX, (zero - one).0);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n+#[repr(transparent)]\n+pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\n+impl<T: fmt::Display> fmt::Display for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::Binary> fmt::Binary for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n \n-use crate::ops::*;\n+#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::Octal> fmt::Octal for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::LowerHex> fmt::LowerHex for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n \n #[allow(unused_macros)]\n macro_rules! sh_impl_signed {"}]}