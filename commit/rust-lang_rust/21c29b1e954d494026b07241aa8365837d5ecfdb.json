{"sha": "21c29b1e954d494026b07241aa8365837d5ecfdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYzI5YjFlOTU0ZDQ5NDAyNmIwNzI0MWFhODM2NTgzN2Q1ZWNmZGI=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-10-20T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-10-20T00:00:00Z"}, "message": "Check that pthread mutex initialization succeeded\n\nIf pthread mutex initialization fails, the failure will go unnoticed unless\ndebug assertions are enabled. Any subsequent use of mutex will also silently\nfail, since return values from lock & unlock operations are similarly checked\nonly through debug assertions.\n\nIn some implementations the mutex initialization requires a memory\nallocation and so it does fail in practice.\n\nCheck that initialization succeeds to ensure that mutex guarantees\nmutual exclusion.", "tree": {"sha": "ae5bc05e490ce1527af198a8678ea32680bfe417", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5bc05e490ce1527af198a8678ea32680bfe417"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21c29b1e954d494026b07241aa8365837d5ecfdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21c29b1e954d494026b07241aa8365837d5ecfdb", "html_url": "https://github.com/rust-lang/rust/commit/21c29b1e954d494026b07241aa8365837d5ecfdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21c29b1e954d494026b07241aa8365837d5ecfdb/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85e94927622665a9e9022de0d33a890a2e32d43", "url": "https://api.github.com/repos/rust-lang/rust/commits/a85e94927622665a9e9022de0d33a890a2e32d43", "html_url": "https://github.com/rust-lang/rust/commit/a85e94927622665a9e9022de0d33a890a2e32d43"}], "stats": {"total": 49, "additions": 27, "deletions": 22}, "files": [{"sha": "b28c6d85b7c725b7b6667378248d00aa77f426c9", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=21c29b1e954d494026b07241aa8365837d5ecfdb", "patch": "@@ -220,6 +220,10 @@ where\n     }\n }\n \n+pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n+    if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n+}\n+\n // On Unix-like platforms, libc::abort will unregister signal handlers\n // including the SIGABRT handler, preventing the abort from being blocked, and\n // fclose streams, with the side effect of flushing them so libc buffered"}, {"sha": "89c55eb859d0944daec0d28263bc2d72d48f4702", "filename": "library/std/src/sys/unix/mutex.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs?ref=21c29b1e954d494026b07241aa8365837d5ecfdb", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::mem::MaybeUninit;\n+use crate::sys::cvt_nz;\n \n pub struct Mutex {\n     inner: UnsafeCell<libc::pthread_mutex_t>,\n@@ -51,14 +52,11 @@ impl Mutex {\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n+        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+        let attr = PthreadMutexAttr(&mut attr);\n+        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n+            .unwrap();\n+        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {\n@@ -106,15 +104,11 @@ impl ReentrantMutex {\n \n     pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result =\n-            libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE);\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n+        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+        let attr = PthreadMutexAttr(&mut attr);\n+        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))\n+            .unwrap();\n+        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n     }\n \n     pub unsafe fn lock(&self) {\n@@ -137,3 +131,14 @@ impl ReentrantMutex {\n         debug_assert_eq!(result, 0);\n     }\n }\n+\n+struct PthreadMutexAttr<'a>(&'a mut MaybeUninit<libc::pthread_mutexattr_t>);\n+\n+impl Drop for PthreadMutexAttr<'_> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let result = libc::pthread_mutexattr_destroy(self.0.as_mut_ptr());\n+            debug_assert_eq!(result, 0);\n+        }\n+    }\n+}"}, {"sha": "a590c74435639cc87658216711321afba545ee5a", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c29b1e954d494026b07241aa8365837d5ecfdb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=21c29b1e954d494026b07241aa8365837d5ecfdb", "patch": "@@ -281,7 +281,7 @@ impl Command {\n         envp: Option<&CStringArray>,\n     ) -> io::Result<Option<Process>> {\n         use crate::mem::MaybeUninit;\n-        use crate::sys;\n+        use crate::sys::{self, cvt_nz};\n \n         if self.get_gid().is_some()\n             || self.get_uid().is_some()\n@@ -343,10 +343,6 @@ impl Command {\n             }\n         }\n \n-        fn cvt_nz(error: libc::c_int) -> io::Result<()> {\n-            if error == 0 { Ok(()) } else { Err(io::Error::from_raw_os_error(error)) }\n-        }\n-\n         unsafe {\n             let mut attrs = MaybeUninit::uninit();\n             cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;"}]}