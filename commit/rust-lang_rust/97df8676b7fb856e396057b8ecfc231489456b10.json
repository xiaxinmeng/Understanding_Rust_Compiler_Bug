{"sha": "97df8676b7fb856e396057b8ecfc231489456b10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZGY4Njc2YjdmYjg1NmUzOTYwNTdiOGVjZmMyMzE0ODk0NTZiMTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-10T11:14:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-10T11:14:26Z"}, "message": "Rollup merge of #59600 - tobia:master, r=pnkfelix\n\nReplaced linear token counting macros with optimized implementation\n\nThere are currently two distinct token-counting macros in the source. Both implement the trivial algorithm, with linear complexity. They may or may not be adequate for their use case, but considering that other people are probably going to copy and paste them whenever they need a token-counting macro, I replaced them with an optimized implementation with logarithmic complexity.", "tree": {"sha": "7a775d0f30b4e613deca7f01a977ba8781c6c01e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a775d0f30b4e613deca7f01a977ba8781c6c01e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97df8676b7fb856e396057b8ecfc231489456b10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc/juSCRBK7hj4Ov3rIwAAdHIIAHhuKGQKZX/Btw+EXSAQf4jv\nj7XaktdA70fMsVaFweBSa9OfS17Zh1ag4rosdQaQQF+6oaxuMuTc/1F7YyWy1xFg\nmffSbmrrCcrUJvJaSKvp+VbuAyRvWuNRaeh65M6gBuQWTN2ILtYnODrcCt8CxKBp\n+B2YcvgyGE4SGkafX/MBbDdBHYb1R9rqcquUH3u8ZcfQjxwJIY1HZ3kXmMqMcYA+\nrXKcPg585F5HNnxDVpzXCDFO4RcCscohJENa5YmkrxTxUwyZ2CBEJ0joyomwhWYk\n/XB9l/4L89zpg8YML9H4cISCi4b+gmG/KT+uCAD4B3NMGTCtdo2SL98MrzKi4Cs=\n=9V88\n-----END PGP SIGNATURE-----\n", "payload": "tree 7a775d0f30b4e613deca7f01a977ba8781c6c01e\nparent 1cbd8a4d686d1411105f26cddf876c5994e69593\nparent a4a07e00ced90e076dbadd8b350db527bcc588bd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560165266 +0200\ncommitter GitHub <noreply@github.com> 1560165266 +0200\n\nRollup merge of #59600 - tobia:master, r=pnkfelix\n\nReplaced linear token counting macros with optimized implementation\n\nThere are currently two distinct token-counting macros in the source. Both implement the trivial algorithm, with linear complexity. They may or may not be adequate for their use case, but considering that other people are probably going to copy and paste them whenever they need a token-counting macro, I replaced them with an optimized implementation with logarithmic complexity.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97df8676b7fb856e396057b8ecfc231489456b10", "html_url": "https://github.com/rust-lang/rust/commit/97df8676b7fb856e396057b8ecfc231489456b10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97df8676b7fb856e396057b8ecfc231489456b10/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cbd8a4d686d1411105f26cddf876c5994e69593", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbd8a4d686d1411105f26cddf876c5994e69593", "html_url": "https://github.com/rust-lang/rust/commit/1cbd8a4d686d1411105f26cddf876c5994e69593"}, {"sha": "a4a07e00ced90e076dbadd8b350db527bcc588bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4a07e00ced90e076dbadd8b350db527bcc588bd", "html_url": "https://github.com/rust-lang/rust/commit/a4a07e00ced90e076dbadd8b350db527bcc588bd"}], "stats": {"total": 29, "additions": 22, "deletions": 7}, "files": [{"sha": "6a561f0c63a2afa556eb4563bbd33f7c414e7a7c", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97df8676b7fb856e396057b8ecfc231489456b10/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97df8676b7fb856e396057b8ecfc231489456b10/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=97df8676b7fb856e396057b8ecfc231489456b10", "patch": "@@ -582,9 +582,17 @@ impl DefPathData {\n     }\n }\n \n+/// Evaluates to the number of tokens passed to it.\n+///\n+/// Logarithmic counting: every one or two recursive expansions, the number of\n+/// tokens to count is divided by two, instead of being reduced by one.\n+/// Therefore, the recursion depth is the binary logarithm of the number of\n+/// tokens to count, and the expanded tree is likewise very small.\n macro_rules! count {\n-    () => (0usize);\n-    ( $x:tt $($xs:tt)* ) => (1usize + count!($($xs)*));\n+    ()                     => (0usize);\n+    ($one:tt)              => (1usize);\n+    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n+    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n }\n \n // We define the GlobalMetaDataKind enum with this macro because we want to"}, {"sha": "95095c712d2c58631b8e381ac4052f85d96f75c7", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97df8676b7fb856e396057b8ecfc231489456b10/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97df8676b7fb856e396057b8ecfc231489456b10/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=97df8676b7fb856e396057b8ecfc231489456b10", "patch": "@@ -723,10 +723,17 @@ macro_rules! peel {\n     ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n }\n \n-/// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n-macro_rules! count_idents {\n-    () => { 0 };\n-    ($_i:ident, $($rest:ident,)*) => { 1 + count_idents!($($rest,)*) }\n+/// Evaluates to the number of tokens passed to it.\n+///\n+/// Logarithmic counting: every one or two recursive expansions, the number of\n+/// tokens to count is divided by two, instead of being reduced by one.\n+/// Therefore, the recursion depth is the binary logarithm of the number of\n+/// tokens to count, and the expanded tree is likewise very small.\n+macro_rules! count {\n+    ()                     => (0usize);\n+    ($one:tt)              => (1usize);\n+    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n+    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n }\n \n macro_rules! tuple {\n@@ -735,7 +742,7 @@ macro_rules! tuple {\n         impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n             fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n-                let len: usize = count_idents!($($name,)*);\n+                let len: usize = count!($($name)*);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n                     let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name, D::Error> {"}]}