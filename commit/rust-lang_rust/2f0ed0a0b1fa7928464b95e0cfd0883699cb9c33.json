{"sha": "2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "node_id": "C_kwDOAAsO6NoAKDJmMGVkMGEwYjFmYTc5Mjg0NjRiOTVlMGNmZDA4ODM2OTljYjljMzM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-05T19:59:24Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:32:15Z"}, "message": "Move `MapErrIgnore` into `Methods` lint pass", "tree": {"sha": "2ed207772077d5df969d7d48595670cec540df70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ed207772077d5df969d7d48595670cec540df70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "html_url": "https://github.com/rust-lang/rust/commit/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "452395485b113b06c1a47313eeab75d374d97e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/452395485b113b06c1a47313eeab75d374d97e9f", "html_url": "https://github.com/rust-lang/rust/commit/452395485b113b06c1a47313eeab75d374d97e9f"}], "stats": {"total": 298, "additions": 140, "deletions": 158}, "files": [{"sha": "67fb0d50931ac6ae13793d1a669ab5ad1c5c680d", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "patch": "@@ -246,7 +246,6 @@ store.register_lints(&[\n     manual_rem_euclid::MANUAL_REM_EUCLID,\n     manual_retain::MANUAL_RETAIN,\n     manual_strip::MANUAL_STRIP,\n-    map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n     match_result_ok::MATCH_RESULT_OK,\n@@ -326,6 +325,7 @@ store.register_lints(&[\n     methods::MANUAL_STR_REPEAT,\n     methods::MAP_CLONE,\n     methods::MAP_COLLECT_RESULT_UNIT,\n+    methods::MAP_ERR_IGNORE,\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,"}, {"sha": "7fc5eef5f8a6485ad0aa59e16d1655e52805b540", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "patch": "@@ -30,7 +30,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n-    LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n     LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n     LintId::of(matches::TRY_ERR),\n     LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n@@ -39,6 +38,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::EXPECT_USED),\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n+    LintId::of(methods::MAP_ERR_IGNORE),\n     LintId::of(methods::UNWRAP_USED),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),"}, {"sha": "179d630089fdcd52431df1a745612182be289470", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "patch": "@@ -273,7 +273,6 @@ mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n mod manual_strip;\n-mod map_err_ignore;\n mod map_unit_fn;\n mod match_result_ok;\n mod matches;\n@@ -636,7 +635,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             msrv,\n         ))\n     });\n-    store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n     store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n     store.register_late_pass(|| Box::new(loops::Loops));"}, {"sha": "1e542447c96eca92b3668e723c5bef92393abb68", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -1,154 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for instances of `map_err(|_| Some::Enum)`\n-    ///\n-    /// ### Why is this bad?\n-    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n-    ///\n-    /// ### Example\n-    /// Before:\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible,\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {}\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(|_| Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    ///  ```\n-    ///\n-    ///  After:\n-    ///  ```rust\n-    /// use std::{fmt, num::ParseIntError};\n-    ///\n-    /// #[derive(Debug)]\n-    /// enum Error {\n-    ///     Indivisible(ParseIntError),\n-    ///     Remainder(u8),\n-    /// }\n-    ///\n-    /// impl fmt::Display for Error {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         match self {\n-    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n-    ///             Error::Remainder(remainder) => write!(\n-    ///                 f,\n-    ///                 \"input is not divisible by three, remainder = {}\",\n-    ///                 remainder\n-    ///             ),\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for Error {\n-    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n-    ///         match self {\n-    ///             Error::Indivisible(source) => Some(source),\n-    ///             _ => None,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n-    ///     input\n-    ///         .parse::<i32>()\n-    ///         .map_err(Error::Indivisible)\n-    ///         .map(|v| v % 3)\n-    ///         .and_then(|remainder| {\n-    ///             if remainder == 0 {\n-    ///                 Ok(())\n-    ///             } else {\n-    ///                 Err(Error::Remainder(remainder as u8))\n-    ///             }\n-    ///         })\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub MAP_ERR_IGNORE,\n-    restriction,\n-    \"`map_err` should not ignore the original error\"\n-}\n-\n-declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n-    // do not try to lint if this is from a macro or desugaring\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(method, [_, arg], _) = e.kind {\n-            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n-            // Enum::Variant[2]))\n-            if method.ident.name == sym!(map_err) {\n-                // make sure the first argument is a closure, and grab the CaptureRef, BodyId, and fn_decl_span\n-                // fields\n-                if let ExprKind::Closure(&Closure {\n-                    capture_clause,\n-                    body,\n-                    fn_decl_span,\n-                    ..\n-                }) = arg.kind\n-                {\n-                    // check if this is by Reference (meaning there's no move statement)\n-                    if capture_clause == CaptureBy::Ref {\n-                        // Get the closure body to check the parameters and values\n-                        let closure_body = cx.tcx.hir().body(body);\n-                        // make sure there's only one parameter (`|_|`)\n-                        if closure_body.params.len() == 1 {\n-                            // make sure that parameter is the wild token (`_`)\n-                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n-                                // span the area of the closure capture and warn that the\n-                                // original error will be thrown away\n-                                span_lint_and_help(\n-                                    cx,\n-                                    MAP_ERR_IGNORE,\n-                                    fn_decl_span,\n-                                    \"`map_err(|_|...` wildcard pattern discards the original error\",\n-                                    None,\n-                                    \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "1fb6617145e718bb0a9f116f955a3c5a73a30f09", "filename": "clippy_lints/src/methods/map_err_ignore.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs?ref=2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_hir::{CaptureBy, Closure, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MAP_ERR_IGNORE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'_>, e: &Expr<'_>, arg: &'tcx Expr<'_>) {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+        && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n+        && is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Result)\n+        && let ExprKind::Closure(&Closure {\n+            capture_clause: CaptureBy::Ref,\n+            body,\n+            fn_decl_span,\n+            ..\n+        }) = arg.kind\n+        && let closure_body = cx.tcx.hir().body(body)\n+        && let [param] = closure_body.params\n+        && let PatKind::Wild = param.pat.kind\n+    {\n+        // span the area of the closure capture and warn that the\n+        // original error will be thrown away\n+        span_lint_and_help(\n+            cx,\n+            MAP_ERR_IGNORE,\n+            fn_decl_span,\n+            \"`map_err(|_|...` wildcard pattern discards the original error\",\n+            None,\n+            \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n+        );\n+    }\n+}"}, {"sha": "e327bdcf578a19fd2321bc6e62d291ce9da4d3df", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2f0ed0a0b1fa7928464b95e0cfd0883699cb9c33", "patch": "@@ -47,6 +47,7 @@ mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n mod map_clone;\n mod map_collect_result_unit;\n+mod map_err_ignore;\n mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n@@ -2541,6 +2542,106 @@ declare_clippy_lint! {\n     \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// ### Why is this bad?\n+    /// This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    ///\n+    /// ### Example\n+    /// Before:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible,\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {}\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(|_| Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    ///  ```\n+    ///\n+    ///  After:\n+    ///  ```rust\n+    /// use std::{fmt, num::ParseIntError};\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible(ParseIntError),\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+    ///         match self {\n+    ///             Error::Indivisible(source) => Some(source),\n+    ///             _ => None,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub MAP_ERR_IGNORE,\n+    restriction,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2651,6 +2752,7 @@ impl_lint_pass!(Methods => [\n     GET_FIRST,\n     MANUAL_OK_OR,\n     MAP_CLONE,\n+    MAP_ERR_IGNORE,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2982,6 +3084,8 @@ impl Methods {\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n                     if name == \"map\" {\n                         map_clone::check(cx, expr, recv, m_arg, self.msrv);\n+                    } else {\n+                        map_err_ignore::check(cx, expr, m_arg);\n                     }\n                     if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                         match (name, args) {"}]}