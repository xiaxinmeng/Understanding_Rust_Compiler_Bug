{"sha": "732c39c183bf6a2633095557aa9a3c3c48b84b1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMmMzOWMxODNiZjZhMjYzMzA5NTU1N2FhOWEzYzNjNDhiODRiMWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-14T00:13:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-14T00:14:54Z"}, "message": "librustc: Have coherence check Copy kind bounds when determining whether parameter substitutions could possibly unify. r=nmatsakis", "tree": {"sha": "d14fed9675f1c4ec8e8c43974b843a53ded2ba72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d14fed9675f1c4ec8e8c43974b843a53ded2ba72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/732c39c183bf6a2633095557aa9a3c3c48b84b1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/732c39c183bf6a2633095557aa9a3c3c48b84b1b", "html_url": "https://github.com/rust-lang/rust/commit/732c39c183bf6a2633095557aa9a3c3c48b84b1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/732c39c183bf6a2633095557aa9a3c3c48b84b1b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "url": "https://api.github.com/repos/rust-lang/rust/commits/d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "html_url": "https://github.com/rust-lang/rust/commit/d809e89c2682c3bb0ec0b58d7a8beb71060ae619"}], "stats": {"total": 142, "additions": 120, "deletions": 22}, "files": [{"sha": "be9e328f681e47064e9cdc4787e41067bc56afe9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=732c39c183bf6a2633095557aa9a3c3c48b84b1b", "patch": "@@ -141,7 +141,7 @@ export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n export type_implicitly_moves;\n export kind_is_safe_for_default_mode;\n export kind_is_durable;\n-export meta_kind, kind_lteq, type_kind;\n+export meta_kind, kind_lteq, type_kind, type_kind_ext;\n export operators;\n export type_err, terr_vstore_kind;\n export terr_mismatch, terr_onceness_mismatch;\n@@ -2101,6 +2101,12 @@ fn mutable_type_kind(cx: ctxt, ty: mt) -> Kind {\n }\n \n fn type_kind(cx: ctxt, ty: t) -> Kind {\n+    type_kind_ext(cx, ty, false)\n+}\n+\n+// If `allow_ty_var` is true, then this is a conservative assumption; we\n+// assume that type variables *do* have all kinds.\n+fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     match cx.kind_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n@@ -2135,7 +2141,12 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n       }\n \n       // Trait instances are (for now) like shared boxes, basically\n+<<<<<<< HEAD\n       ty_trait(_, _, _) => kind_safe_for_default_mode() | kind_durable(),\n+=======\n+      // XXX: This is wrong for ~Trait and &Trait!\n+      ty_trait(_, _, _) => kind_safe_for_default_mode() | kind_owned(),\n+>>>>>>> librustc: Have coherence check Copy kind bounds when determining whether parameter substitutions could possibly unify. r=nmatsakis\n \n       // Static region pointers are copyable and sendable, but not owned\n       ty_rptr(re_static, mt) =>\n@@ -2249,8 +2260,13 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n       ty_self => kind_noncopyable(),\n \n       ty_infer(_) => {\n-        cx.sess.bug(~\"Asked to compute kind of a type variable\");\n+        if allow_ty_var {\n+            kind_top()\n+        } else {\n+            cx.sess.bug(~\"Asked to compute kind of a type variable\")\n+        }\n       }\n+\n       ty_type | ty_opaque_closure_ptr(_)\n       | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n         cx.sess.bug(~\"Asked to compute kind of fictitious type\");"}, {"sha": "15edea5213934296ae24dc878c0d4db68ee0742e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 89, "deletions": 20, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=732c39c183bf6a2633095557aa9a3c3c48b84b1b", "patch": "@@ -19,16 +19,17 @@ use metadata::csearch::{get_impls_for_mod};\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{ProvidedMethodSource,\n-                 ProvidedMethodInfo, get};\n-use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_struct};\n-use middle::ty::{ty_bool, ty_enum, ty_int, ty_nil, ty_ptr, ty_rptr, ty_uint};\n-use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec, ty_uniq};\n-use middle::ty::{ty_err, ty_fn, ty_trait, ty_tup, ty_infer};\n-use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n-use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n+use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n+use middle::ty::{kind_can_be_copied, lookup_item_type, param_bounds, subst};\n+use middle::ty::{t, ty_bool, ty_bot, ty_box, ty_enum, ty_err, ty_estr};\n+use middle::ty::{ty_evec, ty_float, ty_fn, ty_infer, ty_int, ty_nil, ty_ptr};\n+use middle::ty::{ty_rec, ty_rptr, ty_struct, ty_trait, ty_tup, ty_uint};\n+use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box, ty_uniq};\n+use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n+use middle::ty::{type_is_ty_var};\n use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n-use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n+use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n+use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n use syntax::ast::{crate, def_id, def_mod, def_ty};\n use syntax::ast::{item, item_struct, item_const, item_enum, item_fn};\n use syntax::ast::{item_foreign_mod, item_impl, item_mac, item_mod};\n@@ -49,6 +50,12 @@ use std::map::HashMap;\n use core::uint::range;\n use core::vec::{len, push};\n \n+struct UniversalQuantificationResult {\n+    monotype: t,\n+    type_variables: ~[ty::t],\n+    bounds: @~[param_bounds]\n+}\n+\n fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n               -> Option<t> {\n \n@@ -465,19 +472,21 @@ impl CoherenceChecker {\n     fn polytypes_unify(polytype_a: ty_param_bounds_and_ty,\n                        polytype_b: ty_param_bounds_and_ty)\n                     -> bool {\n-\n-        let monotype_a = self.universally_quantify_polytype(polytype_a);\n-        let monotype_b = self.universally_quantify_polytype(polytype_b);\n-        return can_mk_subty(self.inference_context,\n-                            monotype_a, monotype_b).is_ok()\n-            || can_mk_subty(self.inference_context,\n-                            monotype_b, monotype_a).is_ok();\n+        let universally_quantified_a =\n+            self.universally_quantify_polytype(polytype_a);\n+        let universally_quantified_b =\n+            self.universally_quantify_polytype(polytype_b);\n+\n+        return self.can_unify_universally_quantified(\n+            &universally_quantified_a, &universally_quantified_b) ||\n+            self.can_unify_universally_quantified(\n+            &universally_quantified_b, &universally_quantified_a);\n     }\n \n     // Converts a polytype to a monotype by replacing all parameters with\n-    // type variables.\n-\n-    fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n+    // type variables. Returns the monotype and the type variables created.\n+    fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty)\n+                                  -> UniversalQuantificationResult {\n         // NDM--this span is bogus.\n         let self_region =\n             polytype.region_param.map(\n@@ -493,7 +502,67 @@ impl CoherenceChecker {\n             tps: type_parameters\n         };\n \n-        return subst(self.crate_context.tcx, &substitutions, polytype.ty);\n+        let monotype = subst(self.crate_context.tcx,\n+                             &substitutions,\n+                             polytype.ty);\n+        UniversalQuantificationResult {\n+            monotype: monotype,\n+            type_variables: move type_parameters,\n+            bounds: polytype.bounds\n+        }\n+    }\n+\n+    fn can_unify_universally_quantified(a: &a/UniversalQuantificationResult,\n+                                        b: &a/UniversalQuantificationResult)\n+                                     -> bool {\n+        let mut might_unify = true;\n+        let _ = do self.inference_context.probe {\n+            let result = self.inference_context.sub(true, dummy_sp())\n+                                               .tys(a.monotype, b.monotype);\n+            if result.is_ok() {\n+                // Check to ensure that each parameter binding respected its\n+                // kind bounds.\n+                for [ a, b ].each |result| {\n+                    for vec::each2(result.type_variables, *result.bounds)\n+                            |ty_var, bounds| {\n+                        match resolve_type(self.inference_context,\n+                                           *ty_var,\n+                                           resolve_nested_tvar) {\n+                            Ok(resolved_ty) => {\n+                                for bounds.each |bound| {\n+                                    match *bound {\n+                                        bound_copy => {\n+                                            let kind = type_kind_ext(\n+                                                self.inference_context.tcx,\n+                                                resolved_ty,\n+                                                true);\n+                                            if !kind_can_be_copied(kind) {\n+                                                might_unify = false;\n+                                                break;\n+                                            }\n+                                        }\n+\n+                                        // XXX: We could be smarter here.\n+                                        // Check to see whether owned, send,\n+                                        // const, trait param bounds could\n+                                        // possibly unify.\n+                                        _ => {}\n+                                    }\n+                                }\n+                            }\n+                            Err(*) => {\n+                                // Conservatively assume it might unify.\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                might_unify = false;\n+            }\n+\n+            result\n+        };\n+        might_unify\n     }\n \n     fn get_self_type_for_implementation(implementation: @Impl)"}, {"sha": "fc6c15921197864f5aa54ec723e52e6c8167f62a", "filename": "src/test/run-pass/coherence-copy-bound.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732c39c183bf6a2633095557aa9a3c3c48b84b1b/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs?ref=732c39c183bf6a2633095557aa9a3c3c48b84b1b", "patch": "@@ -0,0 +1,13 @@\n+trait X {}\n+\n+impl<A:Copy> A : X {}\n+\n+struct S {\n+    x: int,\n+    drop {}\n+}\n+\n+impl S : X {}\n+\n+fn main(){}\n+"}]}