{"sha": "79358aa52329ed6dc67f0b2c0afa2a2692d404af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MzU4YWE1MjMyOWVkNmRjNjdmMGIyYzBhZmEyYTI2OTJkNDA0YWY=", "commit": {"author": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-07-19T10:57:49Z"}, "committer": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-07-19T10:57:49Z"}, "message": "Merge branch 'master' into issue-30961", "tree": {"sha": "a0203c8831737e3619fe0427c84e94785961facc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0203c8831737e3619fe0427c84e94785961facc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79358aa52329ed6dc67f0b2c0afa2a2692d404af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79358aa52329ed6dc67f0b2c0afa2a2692d404af", "html_url": "https://github.com/rust-lang/rust/commit/79358aa52329ed6dc67f0b2c0afa2a2692d404af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79358aa52329ed6dc67f0b2c0afa2a2692d404af/comments", "author": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c4d621a9622bbc444479c34e46d2e0f86606c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c4d621a9622bbc444479c34e46d2e0f86606c44", "html_url": "https://github.com/rust-lang/rust/commit/5c4d621a9622bbc444479c34e46d2e0f86606c44"}, {"sha": "8052f73d7b53d55781e49fc36e109312293a31d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8052f73d7b53d55781e49fc36e109312293a31d5", "html_url": "https://github.com/rust-lang/rust/commit/8052f73d7b53d55781e49fc36e109312293a31d5"}], "stats": {"total": 4708, "additions": 2158, "deletions": 2550}, "files": [{"sha": "d2ec457a1c8bccd43e60fe13f0f0b3ae9236ff71", "filename": "configure", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/configure", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -600,7 +600,7 @@ opt debug-assertions 0 \"build with debugging assertions\"\n opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt local-rebuild 0 \"use an installed rustc matching the current version, for rebuilds\"\n+opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n opt rpath 1 \"build rpaths into rustc itself\"\n opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n@@ -612,6 +612,7 @@ opt rustbuild 0 \"use the rust and cargo based build system\"\n opt orbit 0 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n+opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\"\n@@ -785,6 +786,17 @@ probe CFG_BISON            bison\n probe CFG_GDB              gdb\n probe CFG_LLDB             lldb\n \n+if [ -n \"$CFG_ENABLE_NINJA\" ]\n+then\n+  probe CFG_NINJA            ninja\n+  if [ -z \"$CFG_NINJA\" ]\n+  then\n+    # On Debian and Fedora, the `ninja` binary is an IRC bot, so the build tool was\n+    # renamed. Handle this case.\n+    probe CFG_NINJA            ninja-build\n+  fi\n+fi\n+\n # For building LLVM\n probe_need CFG_CMAKE cmake\n \n@@ -1534,7 +1546,10 @@ do\n     fi\n \n     # We need the generator later on for compiler-rt even if LLVM's not built\n-    if [ ${is_msvc} -ne 0 ]\n+    if [ -n \"$CFG_NINJA\" ]\n+    then\n+        generator=\"Ninja\"\n+    elif [ ${is_msvc} -ne 0 ]\n     then\n         case \"$CFG_MSVC_ROOT\" in\n             *14.0*)"}, {"sha": "0783a4c17a4f2153393e5f17171e78793c2e6f94", "filename": "mk/cfg/mips-unknown-linux-gnu.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -7,10 +7,10 @@ CFG_LIB_NAME_mips-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_mips-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_mips-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_mips-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n-CFG_JEMALLOC_CFLAGS_mips-unknown-linux-gnu := -mips32r2 -msoft-float -mabi=32 $(CFLAGS)\n-CFG_GCCISH_CFLAGS_mips-unknown-linux-gnu := -Wall -g -fPIC -mips32r2 -msoft-float -mabi=32 $(CFLAGS)\n+CFG_JEMALLOC_CFLAGS_mips-unknown-linux-gnu := -mips32r2 -mabi=32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_mips-unknown-linux-gnu := -Wall -g -fPIC -mips32r2 -mabi=32 $(CFLAGS)\n CFG_GCCISH_CXXFLAGS_mips-unknown-linux-gnu := -fno-rtti $(CXXFLAGS)\n-CFG_GCCISH_LINK_FLAGS_mips-unknown-linux-gnu := -shared -fPIC -g -mips32r2 -msoft-float -mabi=32\n+CFG_GCCISH_LINK_FLAGS_mips-unknown-linux-gnu := -shared -fPIC -g -mips32r2 -mabi=32\n CFG_GCCISH_DEF_FLAG_mips-unknown-linux-gnu := -Wl,--export-dynamic,--dynamic-list=\n CFG_LLC_FLAGS_mips-unknown-linux-gnu :=\n CFG_INSTALL_NAME_mips-unknown-linux-gnu ="}, {"sha": "d6f812049e03cad1b0892f5f44153e28685a457e", "filename": "mk/llvm.mk", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -43,16 +43,26 @@ $$(LLVM_CONFIG_$(1)): $$(LLVM_DONE_$(1))\n \n $$(LLVM_DONE_$(1)): $$(LLVM_DEPS_TARGET_$(1)) $$(LLVM_STAMP_$(1))\n \t@$$(call E, cmake: llvm)\n-ifeq ($$(findstring msvc,$(1)),msvc)\n+ifneq ($$(CFG_NINJA),)\n+\t$$(Q)$$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n+else ifeq ($$(findstring msvc,$(1)),msvc)\n \t$$(Q)$$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n \t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n else\n \t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n endif\n \t$$(Q)touch $$@\n \n-ifeq ($$(findstring msvc,$(1)),msvc)\n+ifneq ($$(CFG_NINJA),)\n clean-llvm$(1):\n+\t@$$(call E, clean: llvm)\n+\t$$(Q)$$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1)) -t clean\n+else ifeq ($$(findstring msvc,$(1)),msvc)\n+clean-llvm$(1):\n+\t@$$(call E, clean: llvm)\n+\t$$(Q)$$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n+\t\t--config $$(LLVM_BUILD_CONFIG_MODE) \\\n+\t\t--target clean\n else\n clean-llvm$(1):\n \t@$$(call E, clean: llvm)"}, {"sha": "fd12bf26dfc72fdca793e5efa4ae459c24320819", "filename": "mk/main.mk", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -20,29 +20,6 @@ CFG_RELEASE_NUM=1.12.0\n # versions (section 9)\n CFG_PRERELEASE_VERSION=.1\n \n-# Append a version-dependent hash to each library, so we can install different\n-# versions in the same place\n-CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE)$(CFG_EXTRA_FILENAME) | $(CFG_HASH_COMMAND))\n-\n-# A magic value that allows the compiler to use unstable features during the\n-# bootstrap even when doing so would normally be an error because of feature\n-# staging or because the build turns on warnings-as-errors and unstable features\n-# default to warnings. The build has to match this key in an env var.\n-#\n-# This value is keyed off the release to ensure that all compilers for one\n-# particular release have the same bootstrap key. Note that this is\n-# intentionally not \"secure\" by any definition, this is largely just a deterrent\n-# from users enabling unstable features on the stable compiler.\n-CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)\n-\n-# The stage0 compiler needs to use the previous key recorded in src/stage0.txt,\n-# except for local-rebuild when it just uses the same current key.\n-ifdef CFG_ENABLE_LOCAL_REBUILD\n-CFG_BOOTSTRAP_KEY_STAGE0=$(CFG_BOOTSTRAP_KEY)\n-else\n-CFG_BOOTSTRAP_KEY_STAGE0=$(shell grep 'rustc_key' $(S)src/stage0.txt | sed 's/rustc_key: '//)\n-endif\n-\n ifeq ($(CFG_RELEASE_CHANNEL),stable)\n # This is the normal semver version string, e.g. \"0.12.0\", \"0.12.0-nightly\"\n CFG_RELEASE=$(CFG_RELEASE_NUM)\n@@ -72,6 +49,38 @@ CFG_RELEASE=$(CFG_RELEASE_NUM)-dev\n CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-dev\n endif\n \n+# Append a version-dependent hash to each library, so we can install different\n+# versions in the same place\n+CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE)$(CFG_EXTRA_FILENAME) | $(CFG_HASH_COMMAND))\n+\n+# A magic value that allows the compiler to use unstable features during the\n+# bootstrap even when doing so would normally be an error because of feature\n+# staging or because the build turns on warnings-as-errors and unstable features\n+# default to warnings. The build has to match this key in an env var.\n+#\n+# This value is keyed off the release to ensure that all compilers for one\n+# particular release have the same bootstrap key. Note that this is\n+# intentionally not \"secure\" by any definition, this is largely just a deterrent\n+# from users enabling unstable features on the stable compiler.\n+CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)\n+\n+# If local-rust is the same as the current version, then force a local-rebuild\n+ifdef CFG_ENABLE_LOCAL_RUST\n+ifeq ($(CFG_RELEASE),\\\n+      $(shell $(S)src/etc/local_stage0.sh --print-rustc-release $(CFG_LOCAL_RUST_ROOT)))\n+    CFG_INFO := $(info cfg: auto-detected local-rebuild $(CFG_RELEASE))\n+    CFG_ENABLE_LOCAL_REBUILD = 1\n+endif\n+endif\n+\n+# The stage0 compiler needs to use the previous key recorded in src/stage0.txt,\n+# except for local-rebuild when it just uses the same current key.\n+ifdef CFG_ENABLE_LOCAL_REBUILD\n+CFG_BOOTSTRAP_KEY_STAGE0=$(CFG_BOOTSTRAP_KEY)\n+else\n+CFG_BOOTSTRAP_KEY_STAGE0=$(shell sed -ne 's/^rustc_key: //p' $(S)src/stage0.txt)\n+endif\n+\n # The name of the package to use for creating tarballs, installers etc.\n CFG_PACKAGE_NAME=rustc-$(CFG_PACKAGE_VERS)\n "}, {"sha": "8113b68380744dcc837ad9ae920c434840a98c1c", "filename": "mk/rt.mk", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -350,10 +350,17 @@ $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS) $$(LLVM_CONFIG_$$(CFG_BUILD\n \t\t$$(COMPRT_DEFINES_$(1)) \\\n \t\t$$(COMPRT_BUILD_CC_$(1)) \\\n \t\t-G\"$$(CFG_CMAKE_GENERATOR)\"\n+ifneq ($$(CFG_NINJA),)\n+\t$$(CFG_CMAKE) --build \"$$(COMPRT_BUILD_DIR_$(1))\" \\\n+\t\t--target $$(COMPRT_BUILD_TARGET_$(1)) \\\n+\t\t--config $$(LLVM_BUILD_CONFIG_MODE) \\\n+\t\t-- $$(COMPRT_BUILD_ARGS_$(1))\n+else\n \t$$(Q)$$(CFG_CMAKE) --build \"$$(COMPRT_BUILD_DIR_$(1))\" \\\n \t\t--target $$(COMPRT_BUILD_TARGET_$(1)) \\\n \t\t--config $$(LLVM_BUILD_CONFIG_MODE) \\\n \t\t-- $$(COMPRT_BUILD_ARGS_$(1)) $$(MFLAGS)\n+endif\n \t$$(Q)cp \"$$(COMPRT_OUTPUT_$(1))\" $$@\n \n endif"}, {"sha": "8a2bf2ebbde649817af12b2eb753fa2559939a3a", "filename": "mk/stage0.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -11,6 +11,7 @@ endif\n \n $(SNAPSHOT_RUSTC_POST_CLEANUP): \\\n \t\t$(S)src/stage0.txt \\\n+\t\t$(S)src/etc/local_stage0.sh \\\n \t\t$(S)src/etc/get-stage0.py $(MKFILE_DEPS) \\\n \t\t| $(HBIN0_H_$(CFG_BUILD))/\n \t@$(call E, fetch: $@)"}, {"sha": "e64d7e5a437e6103b13f7b5a471c90fa1f9b7c5b", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -317,6 +317,7 @@ impl Config {\n                 (\"OPTIMIZE_TESTS\", self.rust_optimize_tests),\n                 (\"DEBUGINFO_TESTS\", self.rust_debuginfo_tests),\n                 (\"LOCAL_REBUILD\", self.local_rebuild),\n+                (\"NINJA\", self.ninja),\n             }\n \n             match key {"}, {"sha": "caa6ea17ea0544d6f6a5c263239e4548ad469db4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -118,6 +118,7 @@ pub struct Build {\n     ver_date: Option<String>,\n     version: String,\n     package_vers: String,\n+    local_rebuild: bool,\n     bootstrap_key: String,\n     bootstrap_key_stage0: String,\n \n@@ -174,6 +175,7 @@ impl Build {\n             Some(ref s) => PathBuf::from(s),\n             None => stage0_root.join(exe(\"cargo\", &config.build)),\n         };\n+        let local_rebuild = config.local_rebuild;\n \n         Build {\n             flags: flags,\n@@ -189,6 +191,7 @@ impl Build {\n             short_ver_hash: None,\n             ver_date: None,\n             version: String::new(),\n+            local_rebuild: local_rebuild,\n             bootstrap_key: String::new(),\n             bootstrap_key_stage0: String::new(),\n             package_vers: String::new(),\n@@ -219,6 +222,16 @@ impl Build {\n         sanity::check(self);\n         self.verbose(\"collecting channel variables\");\n         channel::collect(self);\n+        // If local-rust is the same as the current version, then force a local-rebuild\n+        let local_version_verbose = output(\n+            Command::new(&self.rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_release = local_version_verbose\n+            .lines().filter(|x| x.starts_with(\"release:\"))\n+            .next().unwrap().trim_left_matches(\"release:\").trim();\n+        if local_release == self.release {\n+            self.verbose(&format!(\"auto-detected local-rebuild {}\", self.release));\n+            self.local_rebuild = true;\n+        }\n         self.verbose(\"updating submodules\");\n         self.update_submodules();\n \n@@ -525,7 +538,7 @@ impl Build {\n              .arg(\"--target\").arg(target);\n \n         let stage;\n-        if compiler.stage == 0 && self.config.local_rebuild {\n+        if compiler.stage == 0 && self.local_rebuild {\n             // Assume the local-rebuild rustc already has stage1 features.\n             stage = 1;\n         } else {\n@@ -766,7 +779,7 @@ impl Build {\n         // In stage0 we're using a previously released stable compiler, so we\n         // use the stage0 bootstrap key. Otherwise we use our own build's\n         // bootstrap key.\n-        let bootstrap_key = if compiler.is_snapshot(self) && !self.config.local_rebuild {\n+        let bootstrap_key = if compiler.is_snapshot(self) && !self.local_rebuild {\n             &self.bootstrap_key_stage0\n         } else {\n             &self.bootstrap_key"}, {"sha": "6fd7cf66920d48875e03c0a6581e08b7de72101b", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -21,7 +21,7 @@ this using our `Cargo.toml` file:\n \n ```toml\n [dependencies]\n-libc = { version = \"0.2.11\", default-features = false }\n+libc = { version = \"0.2.14\", default-features = false }\n ```\n \n Note that the default features have been disabled. This is a critical step -\n@@ -36,8 +36,7 @@ or overriding the default shim for the C `main` function with your own.\n The function marked `#[start]` is passed the command line parameters\n in the same format as C:\n \n-```rust\n-# #![feature(libc)]\n+```rust,ignore\n #![feature(lang_items)]\n #![feature(start)]\n #![no_std]\n@@ -51,53 +50,77 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n }\n \n-// These functions and traits are used by the compiler, but not\n+// These functions are used by the compiler, but not\n // for a bare-bones hello world. These are normally\n // provided by libstd.\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] extern fn panic_fmt() -> ! { loop {} }\n-# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n-# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n-# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n-# // fn main() {} tricked you, rustdoc!\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+pub extern fn eh_personality() {\n+}\n+\n+#[lang = \"panic_fmt\"]\n+#[no_mangle]\n+pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n+                               _file: &'static str,\n+                               _line: u32) -> ! {\n+    loop {}\n+}\n ```\n \n To override the compiler-inserted `main` shim, one has to disable it\n with `#![no_main]` and then create the appropriate symbol with the\n correct ABI and the correct name, which requires overriding the\n compiler's name mangling too:\n \n-```rust\n-# #![feature(libc)]\n+```rust,ignore\n #![feature(lang_items)]\n #![feature(start)]\n #![no_std]\n #![no_main]\n \n+// Pull in the system libc library for what crt0.o likely requires\n extern crate libc;\n \n+// Entry point for this program\n #[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n+pub extern fn main(_argc: i32, _argv: *const *const u8) -> i32 {\n     0\n }\n \n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] extern fn panic_fmt() -> ! { loop {} }\n-# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n-# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n-# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n-# // fn main() {} tricked you, rustdoc!\n+// These functions and traits are used by the compiler, but not\n+// for a bare-bones hello world. These are normally\n+// provided by libstd.\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+pub extern fn eh_personality() {\n+}\n+\n+#[lang = \"panic_fmt\"]\n+#[no_mangle]\n+pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n+                               _file: &'static str,\n+                               _line: u32) -> ! {\n+    loop {}\n+}\n ```\n \n-The compiler currently makes a few assumptions about symbols which are available\n-in the executable to call. Normally these functions are provided by the standard\n-library, but without it you must define your own.\n+## More about the langauge items\n+\n+The compiler currently makes a few assumptions about symbols which are\n+available in the executable to call. Normally these functions are provided by\n+the standard library, but without it you must define your own. These symbols\n+are called \"language items\", and they each have an internal name, and then a\n+signature that an implementation must conform to.\n \n The first of these two functions, `eh_personality`, is used by the failure\n mechanisms of the compiler. This is often mapped to GCC's personality function\n (see the [libstd implementation][unwind] for more information), but crates\n which do not trigger a panic can be assured that this function is never\n-called. The second function, `panic_fmt`, is also used by the failure\n-mechanisms of the compiler.\n-\n+called. Both the language item and the symbol name are `eh_personality`.\n+ \n [unwind]: https://github.com/rust-lang/rust/blob/master/src/libpanic_unwind/gcc.rs\n+\n+The second function, `panic_fmt`, is also used by the failure mechanisms of the\n+compiler. When a panic happens, this controls the message that's displayed on\n+the screen. While the language item's name is `panic_fmt`, the symbol name is\n+`rust_begin_panic`."}, {"sha": "d565532017a65982d518e2453b780743e609a266", "filename": "src/doc/nomicon/phantom-data.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fphantom-data.md?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -51,12 +51,12 @@ struct Vec<T> {\n ```\n \n Unlike the previous example it *appears* that everything is exactly as we\n-want. Every generic argument to Vec shows up in the at least one field.\n+want. Every generic argument to Vec shows up in at least one field.\n Good to go!\n \n Nope.\n \n-The drop checker will generously determine that Vec<T> does not own any values\n+The drop checker will generously determine that `Vec<T>` does not own any values\n of type T. This will in turn make it conclude that it doesn't need to worry\n about Vec dropping any T's in its destructor for determining drop check\n soundness. This will in turn allow people to create unsoundness using\n@@ -81,7 +81,7 @@ Raw pointers that own an allocation is such a pervasive pattern that the\n standard library made a utility for itself called `Unique<T>` which:\n \n * wraps a `*const T` for variance\n-* includes a `PhantomData<T>`,\n+* includes a `PhantomData<T>`\n * auto-derives Send/Sync as if T was contained\n * marks the pointer as NonZero for the null-pointer optimization\n "}, {"sha": "b8509321e3d19b0679ba7a29aea280336229dab2", "filename": "src/doc/reference.md", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -853,6 +853,20 @@ extern crate std; // equivalent to: extern crate std as std;\n extern crate std as ruststd; // linking to 'std' under another name\n ```\n \n+When naming Rust crates, hyphens are disallowed. However, Cargo packages may\n+make use of them. In such case, when `Cargo.toml` doesn't specify a crate name,\n+Cargo will transparently replace `-` with `_` (Refer to [RFC 940] for more\n+details).\n+\n+Here is an example:\n+\n+```{.ignore}\n+// Importing the Cargo package hello-world\n+extern crate hello_world; // hyphen replaced with an underscore\n+```\n+\n+[RFC 940]: https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md\n+\n #### Use declarations\n \n A _use declaration_ creates one or more local name bindings synonymous with\n@@ -3744,9 +3758,9 @@ Since `'static` \"lives longer\" than `'a`, `&'static str` is a subtype of\n \n ## Type coercions\n \n-Coercions are defined in [RFC401]. A coercion is implicit and has no syntax.\n+Coercions are defined in [RFC 401]. A coercion is implicit and has no syntax.\n \n-[RFC401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n+[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n \n ### Coercion sites\n \n@@ -3886,7 +3900,7 @@ Coercion is allowed between the following types:\n \n     In the future, coerce_inner will be recursively extended to tuples and\n     structs. In addition, coercions from sub-traits to super-traits will be\n-    added. See [RFC401] for more details.\n+    added. See [RFC 401] for more details.\n \n # Special traits\n "}, {"sha": "354be34b6a2950efe920bd2e44e57efe77e2bf74", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -49,6 +49,13 @@ if [ -z $TARG_DIR ]; then\n     exit 1\n fi\n \n+case \"$TARG_DIR\" in\n+--print-rustc-release)\n+  # not actually copying to TARG_DIR, just print the local rustc version and exit\n+  ${PREFIX}/bin/rustc${BIN_SUF} --version --verbose | sed -ne 's/^release: //p'\n+;;\n+*)\n+\n cp ${PREFIX}/bin/rustc${BIN_SUF} ${TARG_DIR}/stage0/bin/\n cp ${PREFIX}/${LIB_DIR}/${RUSTLIBDIR}/${TARG_DIR}/${LIB_DIR}/* ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}extra*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n@@ -66,3 +73,5 @@ cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}term*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DI\n \n # do not fail if one of the above fails, as all we need is a working rustc!\n exit 0\n+\n+esac"}, {"sha": "7a3c9bc3bb2180c5851fdbffaaf70bede03e5d5b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -520,7 +520,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        &mut self[..]\n+        self\n     }\n \n     /// Sets the length of a vector."}, {"sha": "4a806a3c98602aa224b963e8a862526d3b1b48ef", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -18,7 +18,7 @@ use ptr;\n /// An implementation of SipHash 1-3.\n ///\n /// See: https://131002.net/siphash/\n-#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n@@ -27,7 +27,7 @@ pub struct SipHasher13 {\n /// An implementation of SipHash 2-4.\n ///\n /// See: https://131002.net/siphash/\n-#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -154,14 +154,14 @@ impl SipHasher {\n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -172,14 +172,14 @@ impl SipHasher13 {\n impl SipHasher24 {\n     /// Creates a new `SipHasher24` with the two initial keys set to 0.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n     pub fn new() -> SipHasher24 {\n         SipHasher24::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher24` that is keyed off the provided keys.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n         SipHasher24 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -232,7 +232,7 @@ impl super::Hasher for SipHasher {\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n impl super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n@@ -245,7 +245,7 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n impl super::Hasher for SipHasher24 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {"}, {"sha": "896d1c6f30bf2cfe0509eb8103e05e89e7927a98", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -491,8 +491,6 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Returns the exact number of times the iterator will iterate.\n     ///\n     /// This method has a default implementation, so you usually should not\n@@ -516,6 +514,8 @@ pub trait ExactSizeIterator: Iterator {\n     ///\n     /// assert_eq!(5, five.len());\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();\n         // Note: This assertion is overly defensive, but it checks the invariant\n@@ -525,6 +525,32 @@ pub trait ExactSizeIterator: Iterator {\n         assert_eq!(upper, Some(lower));\n         lower\n     }\n+\n+    /// Returns whether the iterator is empty.\n+    ///\n+    /// This method has a default implementation using `self.len()`, so you\n+    /// don't need to implement it yourself.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(exact_size_is_empty)]\n+    ///\n+    /// let mut one_element = 0..1;\n+    /// assert!(!one_element.is_empty());\n+    ///\n+    /// assert_eq!(one_element.next(), Some(0));\n+    /// assert!(one_element.is_empty());\n+    ///\n+    /// assert_eq!(one_element.next(), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"exact_size_is_empty\", issue = \"0\")]\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0ad1f671f155b8182c038ce0ec8e8ae9483308b7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -25,6 +25,8 @@\n //!\n //! # How to use the core library\n //!\n+//! Please note that all of these details are currently not considered stable.\n+//!\n // FIXME: Fill me in with more detail when the interface settles\n //! This library is built on the assumption of a few existing symbols:\n //!\n@@ -34,11 +36,12 @@\n //!   These functions are often provided by the system libc, but can also be\n //!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n //!\n-//! * `rust_begin_unwind` - This function takes three arguments, a\n-//!   `fmt::Arguments`, a `&str`, and a `u32`. These three arguments dictate\n-//!   the panic message, the file at which panic was invoked, and the line.\n-//!   It is up to consumers of this core library to define this panic\n-//!   function; it is only required to never return.\n+//! * `rust_begin_panic` - This function takes three arguments, a\n+//!   `fmt::Arguments`, a `&'static str`, and a `u32`. These three arguments\n+//!   dictate the panic message, the file at which panic was invoked, and the\n+//!   line. It is up to consumers of this core library to define this panic\n+//!   function; it is only required to never return. This requires a `lang`\n+//!   attribute named `panic_fmt`.\n \n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues."}, {"sha": "97648cc34699a9dc6baaf133fa8a28893b2fe74a", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -2318,7 +2318,7 @@ impl usize {\n /// let num = 12.4_f32;\n /// let inf = f32::INFINITY;\n /// let zero = 0f32;\n-/// let sub: f32 = 0.000000000000000000000000000000000000011754942;\n+/// let sub: f32 = 1.1754942e-38;\n /// let nan = f32::NAN;\n ///\n /// assert_eq!(num.classify(), FpCategory::Normal);"}, {"sha": "925cdfec900dbd6da769a2f4a24eeee6be972ee0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -571,12 +571,21 @@ macro_rules! fnptr_impls_safety_abi {\n }\n \n macro_rules! fnptr_impls_args {\n-    ($($Arg: ident),*) => {\n+    ($($Arg: ident),+) => {\n         fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n         fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n+        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n         fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),*) -> Ret, $($Arg),* }\n         fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),*) -> Ret, $($Arg),* }\n-    }\n+        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),* , ...) -> Ret, $($Arg),* }\n+    };\n+    () => {\n+        // No variadic functions with 0 parameters\n+        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n+        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n+        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -> Ret, }\n+        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n+    };\n }\n \n fnptr_impls_args! { }"}, {"sha": "e0a9f4e5d422c19f2c617b65132f645e5301c97f", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -171,3 +171,17 @@ fn test_unsized_unique() {\n     let zs: &mut [i32] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }\n+\n+#[test]\n+fn test_variadic_fnptr() {\n+    use core::hash::{Hash, SipHasher};\n+    extern \"C\" {\n+        fn printf(_: *const u8, ...);\n+    }\n+    let p: unsafe extern \"C\" fn(*const u8, ...) = printf;\n+    let q = p.clone();\n+    assert_eq!(p, q);\n+    assert!(!(p < q));\n+    let mut s = SipHasher::new();\n+    assert_eq!(p.hash(&mut s), q.hash(&mut s));\n+}"}, {"sha": "96ecad629f543f24d7a7e586a351e7163375b4c1", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -94,7 +94,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{self, Pos, Span};\n-use errors::{DiagnosticBuilder, check_old_skool};\n+use errors::{DiagnosticBuilder, check_old_school};\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -485,7 +485,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        \"{}\",\n                                        trace.origin);\n \n-        if !is_simple_error || check_old_skool() {\n+        if !is_simple_error || check_old_school() {\n             err.note_expected_found(&\"type\", &expected, &found);\n         }\n "}, {"sha": "2e511e345084638c0b13d4057f5f4d5f4c064d1b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -739,8 +739,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"for every macro invocation, print its name and arguments\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool,\n           \"force nonzeroing move optimization on\"),\n-    keep_mtwt_tables: bool = (false, parse_bool,\n-          \"don't clear the resolution tables after analysis\"),\n+    keep_hygiene_data: bool = (false, parse_bool,\n+          \"don't clear the hygiene data after analysis\"),\n     keep_ast: bool = (false, parse_bool,\n           \"keep the AST after lowering it to HIR\"),\n     show_span: Option<String> = (None, parse_opt_string,"}, {"sha": "fa9bc7c83680c45009f1bf09f72685b38d7e1f09", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -22,7 +22,8 @@ use mir::transform as mir_pass;\n \n use syntax::ast::{NodeId, Name};\n use errors::{self, DiagnosticBuilder};\n-use errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n+use errors::emitter::{Emitter, EmitterWriter};\n+use errors::snippet::FormatMode;\n use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -439,7 +440,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n                                            Some(registry),\n-                                           codemap.clone(),\n+                                           Some(codemap.clone()),\n                                            errors::snippet::FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => {\n@@ -575,24 +576,32 @@ unsafe fn configure_llvm(sess: &Session) {\n }\n \n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(BasicEmitter::stderr(color_config))\n+            Box::new(EmitterWriter::stderr(color_config,\n+                                           None,\n+                                           None,\n+                                           FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Fatal);\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n     panic!(errors::FatalError);\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(BasicEmitter::stderr(color_config))\n+            Box::new(EmitterWriter::stderr(color_config,\n+                                           None,\n+                                           None,\n+                                           FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Warning);\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n }\n \n // Err(0) means compilation was stopped, but no errors were found."}, {"sha": "ab3b20e08c8099130c1b5c3a874a519f9b29fddb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -236,8 +236,8 @@ pub fn compile_input(sess: &Session,\n     Ok(())\n }\n \n-fn keep_mtwt_tables(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.keep_mtwt_tables\n+fn keep_hygiene_data(sess: &Session) -> bool {\n+    sess.opts.debugging_opts.keep_hygiene_data\n }\n \n fn keep_ast(sess: &Session) -> bool {\n@@ -479,9 +479,8 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n-    // `clear_tables` and `clear_ident_interner` can be used to free\n-    // memory, but they do not restore the initial state.\n-    syntax::ext::mtwt::reset_tables();\n+    syntax::ext::hygiene::reset_hygiene_data();\n+    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n     token::reset_ident_interner();\n     let continue_after_error = sess.opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n@@ -761,9 +760,9 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         hir_map::Forest::new(lower_crate(sess, &krate, &mut resolver), &sess.dep_graph)\n     });\n \n-    // Discard MTWT tables that aren't required past lowering to HIR.\n-    if !keep_mtwt_tables(sess) {\n-        syntax::ext::mtwt::clear_tables();\n+    // Discard hygiene data, which isn't required past lowering to HIR.\n+    if !keep_hygiene_data(sess) {\n+        syntax::ext::hygiene::reset_hygiene_data();\n     }\n \n     Ok(ExpansionResult {"}, {"sha": "e539a732b116690f893852ddef2066840b06d08d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -101,6 +101,7 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n+use errors::snippet::FormatMode;\n \n #[cfg(test)]\n pub mod test;\n@@ -139,10 +140,15 @@ pub fn run(args: Vec<String>) -> isize {\n                 match session {\n                     Some(sess) => sess.fatal(&abort_msg(err_count)),\n                     None => {\n-                        let mut emitter =\n-                            errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n-                        emitter.emit(&MultiSpan::new(), &abort_msg(err_count), None,\n-                            errors::Level::Fatal);\n+                        let emitter =\n+                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                                   None,\n+                                                                   None,\n+                                                                   FormatMode::EnvironmentSelected);\n+                        let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n+                        handler.emit(&MultiSpan::new(),\n+                                     &abort_msg(err_count),\n+                                     errors::Level::Fatal);\n                         exit_on_err();\n                     }\n                 }\n@@ -374,23 +380,26 @@ fn handle_explain(code: &str,\n \n fn check_cfg(sopts: &config::Options,\n              output: ErrorOutputType) {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::BasicEmitter::stderr(color_config))\n+            Box::new(errors::emitter::EmitterWriter::stderr(color_config,\n+                                                            None,\n+                                                            None,\n+                                                            FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n     };\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let mut saw_invalid_predicate = false;\n     for item in sopts.cfg.iter() {\n         match item.node {\n             ast::MetaItemKind::List(ref pred, _) => {\n                 saw_invalid_predicate = true;\n-                emitter.emit(&MultiSpan::new(),\n+                handler.emit(&MultiSpan::new(),\n                              &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n                                       pred),\n-                             None,\n-                             errors::Level::Fatal);\n+                                errors::Level::Fatal);\n             }\n             _ => {},\n         }\n@@ -1070,26 +1079,34 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n      if let Err(value) = thread.unwrap().join() {\n         // Thread panicked without emitting a fatal diagnostic\n         if !value.is::<errors::FatalError>() {\n-            let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n+            let emitter =\n+                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                       None,\n+                                                       None,\n+                                                       FormatMode::EnvironmentSelected));\n+            let handler = errors::Handler::with_emitter(true, false, emitter);\n \n             // a .span_bug or .bug call has already printed what\n             // it wants to print.\n             if !value.is::<errors::ExplicitBug>() {\n-                emitter.emit(&MultiSpan::new(), \"unexpected panic\", None, errors::Level::Bug);\n+                handler.emit(&MultiSpan::new(),\n+                             \"unexpected panic\",\n+                             errors::Level::Bug);\n             }\n \n             let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                       format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n             for note in &xs {\n-                emitter.emit(&MultiSpan::new(), &note[..], None, errors::Level::Note)\n+                handler.emit(&MultiSpan::new(),\n+                             &note[..],\n+                             errors::Level::Note);\n             }\n             if match env::var_os(\"RUST_BACKTRACE\") {\n                 Some(val) => &val != \"0\",\n                 None => false,\n             } {\n-                emitter.emit(&MultiSpan::new(),\n+                handler.emit(&MultiSpan::new(),\n                              \"run with `RUST_BACKTRACE=1` for a backtrace\",\n-                             None,\n                              errors::Level::Note);\n             }\n "}, {"sha": "14476cc997ff3eb35968e2540a7a99902d81205c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -456,7 +456,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n+                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n                 pp::space(&mut s.s)?;"}, {"sha": "39763bfa0eb61c6d279054166cf57eaeab03de87", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -33,8 +33,8 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::CodeMap;\n use errors;\n-use errors::emitter::{CoreEmitter, Emitter};\n-use errors::{Level, RenderSpan};\n+use errors::emitter::Emitter;\n+use errors::{Level, DiagnosticBuilder};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::DUMMY_SP;\n@@ -76,15 +76,12 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     }\n }\n \n-impl CoreEmitter for ExpectErrorEmitter {\n-    fn emit_message(&mut self,\n-                    _sp: &RenderSpan,\n-                    msg: &str,\n-                    _: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n-        remove_message(self, msg, lvl);\n+impl Emitter for ExpectErrorEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        remove_message(self, &db.message, db.level);\n+        for child in &db.children {\n+            remove_message(self, &child.message, child.level);\n+        }\n     }\n }\n "}, {"sha": "893f8a6e4ddb01b4a09963ec5afe445964d81cc1", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 819, "deletions": 377, "changes": 1196, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -10,89 +10,40 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, Span, MultiSpan, LineInfo};\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n use registry;\n \n-use check_old_skool;\n-use {Level, RenderSpan, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n+use check_old_school;\n+use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n-use Level::*;\n-use snippet::{RenderedLineKind, SnippetData, Style, FormatMode};\n+use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n+use styled_buffer::StyledBuffer;\n \n-use std::{cmp, fmt};\n+use std::cmp;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use term;\n \n-/// Emitter trait for emitting errors. Do not implement this directly:\n-/// implement `CoreEmitter` instead.\n+/// Emitter trait for emitting errors.\n pub trait Emitter {\n-    /// Emit a standalone diagnostic message.\n-    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, lvl: Level);\n-\n     /// Emit a structured diagnostic.\n-    fn emit_struct(&mut self, db: &DiagnosticBuilder);\n-}\n-\n-pub trait CoreEmitter {\n-    fn emit_message(&mut self,\n-                    rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    is_header: bool,\n-                    show_snippet: bool);\n+    fn emit(&mut self, db: &DiagnosticBuilder);\n }\n \n-impl<T: CoreEmitter> Emitter for T {\n-    fn emit(&mut self,\n-            msp: &MultiSpan,\n-            msg: &str,\n-            code: Option<&str>,\n-            lvl: Level) {\n-        self.emit_message(&FullSpan(msp.clone()),\n-                          msg,\n-                          code,\n-                          lvl,\n-                          true,\n-                          true);\n-    }\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        // Pick old school mode either from env or let the test dictate the format\n+        let old_school = match self.format_mode {\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::EnvironmentSelected => check_old_school()\n+        };\n \n-    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n-        let old_school = check_old_skool();\n-        let db_span = FullSpan(db.span.clone());\n-        self.emit_message(&FullSpan(db.span.clone()),\n-                          &db.message,\n-                          db.code.as_ref().map(|s| &**s),\n-                          db.level,\n-                          true,\n-                          true);\n-        for child in &db.children {\n-            let render_span = child.render_span\n-                                   .clone()\n-                                   .unwrap_or_else(\n-                                       || FullSpan(child.span.clone()));\n-\n-            if !old_school {\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    true);\n-            } else {\n-                let (render_span, show_snippet) = match render_span.span().primary_span() {\n-                    None => (db_span.clone(), false),\n-                    _ => (render_span, true)\n-                };\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    show_snippet);\n-            }\n+        if old_school {\n+            self.emit_messages_old_school(db);\n+        } else {\n+            self.emit_messages_default(db);\n         }\n     }\n }\n@@ -117,66 +68,21 @@ impl ColorConfig {\n     }\n }\n \n-/// A basic emitter for when we don't have access to a codemap or registry. Used\n-/// for reporting very early errors, etc.\n-pub struct BasicEmitter {\n-    dst: Destination,\n-}\n-\n-impl CoreEmitter for BasicEmitter {\n-    fn emit_message(&mut self,\n-                    _rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n-        // we ignore the span as we have no access to a codemap at this point\n-        if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-}\n-\n-impl BasicEmitter {\n-    pub fn stderr(color_config: ColorConfig) -> BasicEmitter {\n-        if color_config.use_color() {\n-            let dst = Destination::from_stderr();\n-            BasicEmitter { dst: dst }\n-        } else {\n-            BasicEmitter { dst: Raw(Box::new(io::stderr())) }\n-        }\n-    }\n-}\n-\n pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<registry::Registry>,\n-    cm: Rc<CodeMapper>,\n-\n-    /// Is this the first error emitted thus far? If not, we emit a\n-    /// `\\n` before the top-level errors.\n-    first: bool,\n+    cm: Option<Rc<CodeMapper>>,\n \n     // For now, allow an old-school mode while we transition\n     format_mode: FormatMode\n }\n \n-impl CoreEmitter for EmitterWriter {\n-    fn emit_message(&mut self,\n-                    rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    is_header: bool,\n-                    show_snippet: bool) {\n-        match self.emit_message_(rsp, msg, code, lvl, is_header, show_snippet) {\n-            Ok(()) => { }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n-        }\n-    }\n+struct FileWithAnnotatedLines {\n+    file: Rc<FileMap>,\n+    lines: Vec<Line>,\n }\n \n+\n /// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n /// `EmitterWriter::print_maybe_styled` for details.\n macro_rules! print_maybe_styled {\n@@ -194,256 +100,862 @@ macro_rules! println_maybe_styled {\n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n                   registry: Option<registry::Registry>,\n-                  code_map: Rc<CodeMapper>,\n+                  code_map: Option<Rc<CodeMapper>>,\n                   format_mode: FormatMode)\n                   -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter { dst: dst,\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<registry::Registry>,\n-               code_map: Rc<CodeMapper>,\n+               code_map: Option<Rc<CodeMapper>>,\n                format_mode: FormatMode)\n                -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst),\n                         registry: registry,\n                         cm: code_map,\n-                        first: true,\n                         format_mode: format_mode.clone() }\n     }\n \n-    fn emit_message_(&mut self,\n-                     rsp: &RenderSpan,\n-                     msg: &str,\n-                     code: Option<&str>,\n-                     lvl: Level,\n-                     is_header: bool,\n-                     show_snippet: bool)\n-                     -> io::Result<()> {\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n+    fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                    file: Rc<FileMap>,\n+                                    line_index: usize,\n+                                    ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index: line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file: file,\n+                lines: vec![Line {\n+                                line_index: line_index,\n+                                annotations: vec![ann],\n+                            }],\n+            });\n+        }\n+\n+        let mut output = vec![];\n+\n+        if let Some(ref cm) = self.cm {\n+            for span_label in msp.span_labels() {\n+                if span_label.span == DUMMY_SP || span_label.span == COMMAND_LINE_SP {\n+                    continue;\n+                }\n+                let lo = cm.lookup_char_pos(span_label.span.lo);\n+                let mut hi = cm.lookup_char_pos(span_label.span.hi);\n+                let mut is_minimized = false;\n+\n+                // If the span is multi-line, simplify down to the span of one character\n+                if lo.line != hi.line {\n+                    hi.line = lo.line;\n+                    hi.col = CharPos(lo.col.0 + 1);\n+                    is_minimized = true;\n+                }\n \n-        if is_header {\n-            if self.first {\n-                self.first = false;\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+                if lo.col == hi.col {\n+                    hi.col = CharPos(lo.col.0 + 1);\n+                }\n+\n+                add_annotation_to_file(&mut output,\n+                                        lo.file,\n+                                        lo.line,\n+                                        Annotation {\n+                                            start_col: lo.col.0,\n+                                            end_col: hi.col.0,\n+                                            is_primary: span_label.is_primary,\n+                                            is_minimized: is_minimized,\n+                                            label: span_label.label.clone(),\n+                                        });\n+            }\n+        }\n+        output\n+    }\n+\n+    fn render_source_line(&self,\n+                          buffer: &mut StyledBuffer,\n+                          file: Rc<FileMap>,\n+                          line: &Line,\n+                          width_offset: usize) {\n+        let source_string = file.get_line(line.line_index - 1)\n+            .unwrap_or(\"\");\n+\n+        let line_offset = buffer.num_lines();\n+\n+        // First create the source line we will highlight.\n+        buffer.puts(line_offset, width_offset, &source_string, Style::Quotation);\n+        buffer.puts(line_offset,\n+                    0,\n+                    &(line.line_index.to_string()),\n+                    Style::LineNumber);\n+\n+        draw_col_separator(buffer, line_offset, width_offset - 2);\n+\n+        if line.annotations.is_empty() {\n+            return;\n+        }\n+\n+        // We want to display like this:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ^^^               _ previous borrow ends here\n+        //      |        |\n+        //      |        error occurs here\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // But there are some weird edge cases to be aware of:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here\n+        //      ||\n+        //      |this makes no sense\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // For this reason, we group the lines into \"highlight lines\"\n+        // and \"annotations lines\", where the highlight lines have the `~`.\n+\n+        // Sort the annotations by (start, end col)\n+        let mut annotations = line.annotations.clone();\n+        annotations.sort();\n+\n+        // Next, create the highlight line.\n+        for annotation in &annotations {\n+            for p in annotation.start_col..annotation.end_col {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '^',\n+                                Style::UnderlinePrimary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlinePrimary);\n+                    }\n+                } else {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '-',\n+                                Style::UnderlineSecondary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlineSecondary);\n+                    }\n+                }\n+            }\n+        }\n+        draw_col_separator(buffer, line_offset + 1, width_offset - 2);\n+\n+        // Now we are going to write labels in. To start, we'll exclude\n+        // the annotations with no labels.\n+        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) = annotations.into_iter()\n+            .partition(|a| a.label.is_some());\n+\n+        // If there are no annotations that need text, we're done.\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+        // Now add the text labels. We try, when possible, to stick the rightmost\n+        // annotation at the end of the highlight line:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ---               - previous borrow ends here\n+        //\n+        // But sometimes that's not possible because one of the other\n+        // annotations overlaps it. For example, from the test\n+        // `span_overlap_label`, we have the following annotations\n+        // (written on distinct lines for clarity):\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             -\n+        //\n+        // In this case, we can't stick the rightmost-most label on\n+        // the highlight line, or we would get:\n+        //\n+        //      fn foo(x: u32) {\n+        //      -------- x_span\n+        //      |\n+        //      fn_span\n+        //\n+        // which is totally weird. Instead we want:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      fn_span\n+        //\n+        // which is...less weird, at least. In fact, in general, if\n+        // the rightmost span overlaps with any other span, we should\n+        // use the \"hang below\" version, so we can at least make it\n+        // clear where the span *starts*.\n+        let mut labeled_annotations = &labeled_annotations[..];\n+        match labeled_annotations.split_last().unwrap() {\n+            (last, previous) => {\n+                if previous.iter()\n+                    .chain(&unlabeled_annotations)\n+                    .all(|a| !overlaps(a, last)) {\n+                    // append the label afterwards; we keep it in a separate\n+                    // string\n+                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n+                    if last.is_primary {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelPrimary);\n+                    } else {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelSecondary);\n+                    }\n+                    labeled_annotations = previous;\n+                }\n+            }\n+        }\n+\n+        // If that's the last annotation, we're done\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+\n+        for (index, annotation) in labeled_annotations.iter().enumerate() {\n+            // Leave:\n+            // - 1 extra line\n+            // - One line for each thing that comes after\n+            let comes_after = labeled_annotations.len() - index - 1;\n+            let blank_lines = 3 + comes_after;\n+\n+            // For each blank line, draw a `|` at our column. The\n+            // text ought to be long enough for this.\n+            for index in 2..blank_lines {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlinePrimary);\n+                } else {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlineSecondary);\n+                }\n+                draw_col_separator(buffer, line_offset + index, width_offset - 2);\n+            }\n+\n+            if annotation.is_primary {\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelPrimary);\n             } else {\n-                if !old_school {\n-                    write!(self.dst, \"\\n\")?;\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelSecondary);\n+            }\n+            draw_col_separator(buffer, line_offset + blank_lines, width_offset - 2);\n+        }\n+    }\n+\n+    fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n+        let mut max = 0;\n+        if let Some(ref cm) = self.cm {\n+            for primary_span in msp.primary_spans() {\n+                if primary_span != &DUMMY_SP && primary_span != &COMMAND_LINE_SP {\n+                    let hi = cm.lookup_char_pos(primary_span.hi);\n+                    if hi.line > max {\n+                        max = hi.line;\n+                    }\n+                }\n+            }\n+            for span_label in msp.span_labels() {\n+                if span_label.span != DUMMY_SP && span_label.span != COMMAND_LINE_SP {\n+                    let hi = cm.lookup_char_pos(span_label.span.hi);\n+                    if hi.line > max {\n+                        max = hi.line;\n+                    }\n+                }\n+            }\n+        }\n+        max\n+    }\n+\n+    fn get_max_line_num(&mut self, db: &DiagnosticBuilder) -> usize {\n+        let mut max = 0;\n+\n+        let primary = self.get_multispan_max_line_num(&db.span);\n+        max = if primary > max { primary } else { max };\n+\n+        for sub in &db.children {\n+            let sub_result = self.get_multispan_max_line_num(&sub.span);\n+            max = if sub_result > max { primary } else { max };\n+        }\n+        max\n+    }\n+\n+    fn emit_message_default(&mut self,\n+                            msp: &MultiSpan,\n+                            msg: &str,\n+                            code: &Option<String>,\n+                            level: &Level,\n+                            max_line_num_len: usize,\n+                            is_secondary: bool)\n+                            -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary {\n+            // This is a secondary message with no span info\n+            for _ in 0..max_line_num_len {\n+                buffer.prepend(0, \" \", Style::NoStyle);\n+            }\n+            draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n+            buffer.append(0, &level.to_string(), Style::HeaderMsg);\n+            buffer.append(0, \": \", Style::NoStyle);\n+            buffer.append(0, msg, Style::NoStyle);\n+        }\n+        else {\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            match code {\n+                &Some(ref code) => {\n+                    buffer.append(0, \"[\", Style::Level(level.clone()));\n+                    buffer.append(0, &code, Style::Level(level.clone()));\n+                    buffer.append(0, \"]\", Style::Level(level.clone()));\n                 }\n+                _ => {}\n             }\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n         }\n \n-        match code {\n-            Some(code) if self.registry.as_ref()\n-                                       .and_then(|registry| registry.find_description(code))\n-                                       .is_some() => {\n-                let code_with_explain = String::from(\"--explain \") + code;\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, Some(code))?\n+        // Preprocess all the annotations so that they are grouped by file and by line number\n+        // This helps us quickly iterate over the whole message (including secondary file spans)\n+        let mut annotated_files = self.preprocess_annotations(msp);\n+\n+        // Make sure our primary file comes first\n+        let primary_lo =\n+            if let (Some(ref cm), Some(ref primary_span)) = (self.cm.as_ref(),\n+                                                             msp.primary_span().as_ref()) {\n+                if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+                    cm.lookup_char_pos(primary_span.lo)\n                 }\n                 else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+                    emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+                    return Ok(());\n+                }\n+            } else {\n+                // If we don't have span information, emit and exit\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+                return Ok(());\n+            };\n+        if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.swap(0, pos);\n+        }\n+\n+        // Print out the annotate source lines that correspond with the error\n+        for annotated_file in annotated_files {\n+            // print out the span location and spacer before we print the annotated source\n+            // to do this, we need to know if this span will be primary\n+            let is_primary = primary_lo.file.name == annotated_file.file.name;\n+            if is_primary {\n+                // remember where we are in the output buffer for easy reference\n+                let buffer_msg_line_offset = buffer.num_lines();\n+\n+                buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n+                let loc = primary_lo.clone();\n+                buffer.append(buffer_msg_line_offset,\n+                                &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                                Style::LineAndColumn);\n+                for _ in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n+                }\n+            } else {\n+                // remember where we are in the output buffer for easy reference\n+                let buffer_msg_line_offset = buffer.num_lines();\n+\n+                // Add spacing line\n+                draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+                // Then, the secondary file indicator\n+                buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n+                buffer.append(buffer_msg_line_offset + 1,\n+                                &annotated_file.file.name,\n+                                Style::LineAndColumn);\n+                for _ in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n             }\n-            _ => {\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, code)?\n+\n+            // Put in the spacer between the location and annotated source\n+            let buffer_msg_line_offset = buffer.num_lines();\n+            draw_col_separator_no_space(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+            // Next, output the annotate source for this file\n+            for line_idx in 0..annotated_file.lines.len() {\n+                self.render_source_line(&mut buffer,\n+                                        annotated_file.file.clone(),\n+                                        &annotated_file.lines[line_idx],\n+                                        3 + max_line_num_len);\n+\n+                // check to see if we need to print out or elide lines that come between\n+                // this annotated line and the next one\n+                if line_idx < (annotated_file.lines.len() - 1) {\n+                    let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n+                                            annotated_file.lines[line_idx].line_index;\n+                    if line_idx_delta > 2 {\n+                        let last_buffer_line_num = buffer.num_lines();\n+                        buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n+                    } else if line_idx_delta == 2 {\n+                        let unannotated_line = annotated_file.file\n+                            .get_line(annotated_file.lines[line_idx].line_index)\n+                            .unwrap_or(\"\");\n+\n+                        let last_buffer_line_num = buffer.num_lines();\n+\n+                        buffer.puts(last_buffer_line_num,\n+                                    0,\n+                                    &(annotated_file.lines[line_idx + 1].line_index - 1)\n+                                        .to_string(),\n+                                    Style::LineNumber);\n+                        draw_col_separator(&mut buffer, last_buffer_line_num, 1 + max_line_num_len);\n+                        buffer.puts(last_buffer_line_num,\n+                                    3 + max_line_num_len,\n+                                    &unannotated_line,\n+                                    Style::Quotation);\n+                    }\n                 }\n-                else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n+            }\n+        }\n+\n+        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n+        }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+\n+        Ok(())\n+    }\n+    fn emit_suggestion_default(&mut self,\n+                               suggestion: &CodeSuggestion,\n+                               level: &Level,\n+                               msg: &str,\n+                               max_line_num_len: usize)\n+                               -> io::Result<()> {\n+        use std::borrow::Borrow;\n+\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n+\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n+\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let complete = suggestion.splice_lines(cm.borrow());\n+\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n+            }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+        }\n+        Ok(())\n+    }\n+    fn emit_messages_default(&mut self, db: &DiagnosticBuilder) {\n+        let max_line_num = self.get_max_line_num(db);\n+        let max_line_num_len = max_line_num.to_string().len();\n+\n+        match self.emit_message_default(&db.span,\n+                                        &db.message,\n+                                        &db.code,\n+                                        &db.level,\n+                                        max_line_num_len,\n+                                        false) {\n+            Ok(()) => {\n+                if !db.children.is_empty() {\n+                    let mut buffer = StyledBuffer::new();\n+                    draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n+                    match emit_to_destination(&buffer.render(), &db.level, &mut self.dst) {\n+                        Ok(()) => (),\n+                        Err(e) => panic!(\"failed to emit error: {}\", e)\n+                    }\n+                }\n+                for child in &db.children {\n+                    match child.render_span {\n+                        Some(FullSpan(ref msp)) => {\n+                            match self.emit_message_default(msp,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_default(cs,\n+                                                               &child.level,\n+                                                               &child.message,\n+                                                               max_line_num_len) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_default(&child.span,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n                 }\n             }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n+        }\n+        match write!(&mut self.dst, \"\\n\") {\n+            Err(e) => panic!(\"failed to emit error: {}\", e),\n+            _ => ()\n+        }\n+    }\n+    fn emit_message_old_school(&mut self,\n+                               msp: &MultiSpan,\n+                               msg: &str,\n+                               code: &Option<String>,\n+                               level: &Level,\n+                               show_snippet: bool)\n+                               -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        let loc = match msp.primary_span() {\n+            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+            Some(ps) => if let Some(ref cm) = self.cm {\n+                cm.span_to_string(ps)\n+            } else {\n+                \"\".to_string()\n+            },\n+            None => {\n+                \"\".to_string()\n+            }\n+        };\n+        if loc != \"\" {\n+            buffer.append(0, &loc, Style::NoStyle);\n+            buffer.append(0, \" \", Style::NoStyle);\n+        }\n+        buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+        buffer.append(0, \": \", Style::HeaderMsg);\n+        buffer.append(0, msg, Style::HeaderMsg);\n+        buffer.append(0, \" \", Style::NoStyle);\n+        match code {\n+            &Some(ref code) => {\n+                buffer.append(0, \"[\", Style::ErrorCode);\n+                buffer.append(0, &code, Style::ErrorCode);\n+                buffer.append(0, \"]\", Style::ErrorCode);\n+            }\n+            _ => {}\n         }\n \n         if !show_snippet {\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n             return Ok(());\n         }\n \n         // Watch out for various nasty special spans; don't try to\n         // print any filename or anything for those.\n-        match rsp.span().primary_span() {\n+        match msp.primary_span() {\n             Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n             }\n             _ => { }\n         }\n \n-        // Otherwise, print out the snippet etc as needed.\n-        match *rsp {\n-            FullSpan(ref msp) => {\n-                self.highlight_lines(msp, lvl)?;\n-                if let Some(primary_span) = msp.primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n-                }\n-            }\n-            Suggestion(ref suggestion) => {\n-                self.highlight_suggestion(suggestion)?;\n-                if let Some(primary_span) = rsp.span().primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n+        let annotated_files = self.preprocess_annotations(msp);\n+\n+        if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n+            (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n+\n+            // Next, print the source line and its squiggle\n+            // for old school mode, we will render them to the buffer, then insert the file loc\n+            // (or space the same amount) in front of the line and the squiggle\n+            let source_string = ann_file.file.get_line(ann_file.lines[0].line_index - 1)\n+                .unwrap_or(\"\");\n+\n+            let line_offset = buffer.num_lines();\n+\n+            let lo = cm.lookup_char_pos(primary_span.lo);\n+            //Before each secondary line in old skool-mode, print the label\n+            //as an old-style note\n+            let file_pos = format!(\"{}:{} \", lo.file.name.clone(), lo.line);\n+            let file_pos_len = file_pos.len();\n+\n+            // First create the source line we will highlight.\n+            buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n+            buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n+            // Sort the annotations by (start, end col)\n+            let annotations = ann_file.lines[0].annotations.clone();\n+\n+            // Next, create the highlight line.\n+            for annotation in &annotations {\n+                for p in annotation.start_col..annotation.end_col {\n+                    if p == annotation.start_col {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '^',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    } else {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '~',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    }\n                 }\n             }\n         }\n-        if old_school {\n-            match code {\n-                Some(code) if self.registry.as_ref()\n-                                        .and_then(|registry| registry.find_description(code))\n-                                        .is_some() => {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n-                        \"` to see a detailed explanation\";\n-                    print_diagnostic(&mut self.dst, &loc, Level::Help, &msg,\n-                        None)?\n-                }\n-                _ => ()\n+        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n+        }\n+\n+        match code {\n+            &Some(ref code) if self.registry.as_ref()\n+                                           .and_then(|registry| registry.find_description(code))\n+                                           .is_some() => {\n+                let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n+                    \"` to see a detailed explanation\";\n+\n+                let line_offset = buffer.num_lines();\n+                buffer.append(line_offset, &loc, Style::NoStyle);\n+                buffer.append(line_offset, \" \", Style::NoStyle);\n+                buffer.append(line_offset, &Level::Help.to_string(), Style::Level(Level::Help));\n+                buffer.append(line_offset, \": \", Style::HeaderMsg);\n+                buffer.append(line_offset, &msg, Style::HeaderMsg);\n             }\n+            _ => ()\n         }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         Ok(())\n     }\n-\n-    fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n-    {\n+    fn emit_suggestion_old_school(&mut self,\n+                                  suggestion: &CodeSuggestion,\n+                                  level: &Level,\n+                                  msg: &str)\n+                                  -> io::Result<()> {\n         use std::borrow::Borrow;\n \n         let primary_span = suggestion.msp.primary_span().unwrap();\n-        let lines = self.cm.span_to_lines(primary_span).unwrap();\n-        assert!(!lines.lines.is_empty());\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n \n-        let complete = suggestion.splice_lines(self.cm.borrow());\n-        let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-        let display_lines = &lines.lines[..line_count];\n+            let loc = cm.span_to_string(primary_span);\n \n-        let fm = &*lines.file;\n-        // Calculate the widest number to format evenly\n-        let max_digits = line_num_max_digits(display_lines.last().unwrap());\n+            if loc != \"\" {\n+                buffer.append(0, &loc, Style::NoStyle);\n+                buffer.append(0, \" \", Style::NoStyle);\n+            }\n \n-        // print the suggestion without any line numbers, but leave\n-        // space for them. This helps with lining up with previous\n-        // snippets from the actual error being reported.\n-        let mut lines = complete.lines();\n-        for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-            write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                   fm.name, \"\", max_digits, line)?;\n-        }\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n \n-        // if we elided some lines, add an ellipsis\n-        if let Some(_) = lines.next() {\n-            write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                   \"\", fm.name.len(), max_digits)?;\n-        }\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n \n-        Ok(())\n-    }\n+            assert!(!lines.lines.is_empty());\n \n-    pub fn highlight_lines(&mut self,\n-                       msp: &MultiSpan,\n-                       lvl: Level)\n-                       -> io::Result<()>\n-    {\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n+            let complete = suggestion.splice_lines(cm.borrow());\n+            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n+            let display_lines = &lines.lines[..line_count];\n \n-        let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                msp.primary_span(),\n-                                                self.format_mode.clone());\n-        if old_school {\n-            let mut output_vec = vec![];\n+            let fm = &*lines.file;\n+            // Calculate the widest number to format evenly\n+            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n \n-            for span_label in msp.span_labels() {\n-                let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                        Some(span_label.span),\n-                                                        self.format_mode.clone());\n-\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-                if span_label.is_primary {\n-                    output_vec.insert(0, snippet_data);\n-                }\n-                else {\n-                    output_vec.push(snippet_data);\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                buffer.append(row_num, &fm.name, Style::FileNameStyle);\n+                for _ in 0..max_digits+2 {\n+                    buffer.append(row_num, &\" \", Style::NoStyle);\n                 }\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n             }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+        }\n+        Ok(())\n+    }\n \n-            for snippet_data in output_vec.iter() {\n-                let rendered_lines = snippet_data.render_lines();\n-                for rendered_line in &rendered_lines {\n-                    for styled_string in &rendered_line.text {\n-                        self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                        write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                        self.dst.reset_attrs()?;\n+    fn emit_messages_old_school(&mut self, db: &DiagnosticBuilder) {\n+        match self.emit_message_old_school(&db.span,\n+                                           &db.message,\n+                                           &db.code,\n+                                           &db.level,\n+                                           true) {\n+            Ok(()) => {\n+                for child in &db.children {\n+                    let (span, show_snippet) = if child.span.primary_spans().is_empty() {\n+                        (db.span.clone(), false)\n+                    } else {\n+                        (child.span.clone(), true)\n+                    };\n+\n+                    match child.render_span {\n+                        Some(FullSpan(_)) => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_old_school(cs,\n+                                                                  &child.level,\n+                                                                  &child.message) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n                     }\n-                    write!(&mut self.dst, \"\\n\")?;\n                 }\n             }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n         }\n-        else {\n-            for span_label in msp.span_labels() {\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-            }\n-            let rendered_lines = snippet_data.render_lines();\n-            for rendered_line in &rendered_lines {\n-                for styled_string in &rendered_line.text {\n-                    self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                    write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                    self.dst.reset_attrs()?;\n+    }\n+\n+    fn render_macro_backtrace_old_school(&mut self,\n+                                         sp: &Span,\n+                                         buffer: &mut StyledBuffer) -> io::Result<()> {\n+        if let Some(ref cm) = self.cm {\n+            for trace in cm.macro_backtrace(sp.clone()) {\n+                let line_offset = buffer.num_lines();\n+\n+                let mut diag_string =\n+                    format!(\"in this expansion of {}\", trace.macro_decl_name);\n+                if let Some(def_site_span) = trace.def_site_span {\n+                    diag_string.push_str(\n+                        &format!(\" (defined in {})\",\n+                            cm.span_to_filename(def_site_span)));\n                 }\n-                write!(&mut self.dst, \"\\n\")?;\n+                let snippet = cm.span_to_string(trace.call_site);\n+                buffer.append(line_offset, &format!(\"{} \", snippet), Style::NoStyle);\n+                buffer.append(line_offset, \"note\", Style::Level(Level::Note));\n+                buffer.append(line_offset, \": \", Style::NoStyle);\n+                buffer.append(line_offset, &diag_string, Style::OldSchoolNoteText);\n             }\n         }\n         Ok(())\n     }\n+}\n \n-    fn print_macro_backtrace(&mut self,\n-                             sp: Span)\n-                             -> io::Result<()> {\n-        for trace in self.cm.macro_backtrace(sp) {\n-            let mut diag_string =\n-                format!(\"in this expansion of {}\", trace.macro_decl_name);\n-            if let Some(def_site_span) = trace.def_site_span {\n-                diag_string.push_str(\n-                    &format!(\" (defined in {})\",\n-                        self.cm.span_to_filename(def_site_span)));\n-            }\n-            let snippet = self.cm.span_to_string(trace.call_site);\n-            print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n+fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"| \", Style::LineNumber);\n+}\n+\n+fn draw_col_separator_no_space(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"|\", Style::LineNumber);\n+}\n+\n+fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"= \", Style::LineNumber);\n+}\n+\n+fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n+    (a2.start_col..a2.end_col).contains(a1.start_col) ||\n+    (a1.start_col..a1.end_col).contains(a2.start_col)\n+}\n+\n+fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n+        lvl: &Level,\n+        dst: &mut Destination) -> io::Result<()> {\n+    for line in rendered_buffer {\n+        for part in line {\n+            dst.apply_style(lvl.clone(), part.style)?;\n+            write!(dst, \"{}\", part.text)?;\n+            dst.reset_attrs()?;\n         }\n-        Ok(())\n+        write!(dst, \"\\n\")?;\n     }\n+    Ok(())\n }\n \n fn line_num_max_digits(line: &LineInfo) -> usize {\n@@ -456,40 +968,6 @@ fn line_num_max_digits(line: &LineInfo) -> usize {\n     digits\n }\n \n-fn print_diagnostic(dst: &mut Destination,\n-                    topic: &str,\n-                    lvl: Level,\n-                    msg: &str,\n-                    code: Option<&str>)\n-                    -> io::Result<()> {\n-    if !topic.is_empty() {\n-        let old_school = check_old_skool();\n-        if !old_school {\n-            write!(dst, \"{}: \", topic)?;\n-        }\n-        else {\n-            write!(dst, \"{} \", topic)?;\n-        }\n-        dst.reset_attrs()?;\n-    }\n-    dst.start_attr(term::Attr::Bold)?;\n-    dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n-    write!(dst, \"{}\", lvl.to_string())?;\n-    dst.reset_attrs()?;\n-    write!(dst, \": \")?;\n-    dst.start_attr(term::Attr::Bold)?;\n-    write!(dst, \"{}\", msg)?;\n-\n-    if let Some(code) = code {\n-        let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-        print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n-    }\n-\n-    dst.reset_attrs()?;\n-    write!(dst, \"\\n\")?;\n-    Ok(())\n-}\n-\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;\n@@ -513,7 +991,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-enum Destination {\n+pub enum Destination {\n     Terminal(Box<term::StderrTerminal>),\n     Raw(Box<Write + Send>),\n }\n@@ -528,35 +1006,39 @@ impl Destination {\n \n     fn apply_style(&mut self,\n                    lvl: Level,\n-                   _kind: &RenderedLineKind,\n                    style: Style)\n                    -> io::Result<()> {\n         match style {\n-            Style::FileNameStyle |\n-            Style::LineAndColumn => {\n-            }\n+            Style::FileNameStyle | Style::LineAndColumn => {}\n             Style::LineNumber => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::Quotation => {\n+            Style::ErrorCode => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA)));\n             }\n-            Style::OldSkoolNote => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN))?;\n+            Style::Quotation => {}\n+            Style::OldSchoolNote => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN)));\n             }\n-            Style::OldSkoolNoteText => {\n-                self.start_attr(term::Attr::Bold)?;\n+            Style::OldSchoolNoteText | Style::HeaderMsg => {\n+                try!(self.start_attr(term::Attr::Bold));\n             }\n             Style::UnderlinePrimary | Style::LabelPrimary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(lvl.color())));\n             }\n-            Style::UnderlineSecondary | Style::LabelSecondary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            Style::UnderlineSecondary |\n+            Style::LabelSecondary => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::NoStyle => {\n+            Style::NoStyle => {}\n+            Style::Level(l) => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(l.color())));\n             }\n         }\n         Ok(())\n@@ -577,46 +1059,6 @@ impl Destination {\n         }\n         Ok(())\n     }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool)\n-                          -> io::Result<()> {\n-        match *self {\n-            Terminal(ref mut t) => {\n-                t.attr(color)?;\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                t.write_fmt(args)?;\n-                t.reset()?;\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                w.write_fmt(args)?;\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n }\n \n impl Write for Destination {\n@@ -632,4 +1074,4 @@ impl Write for Destination {\n             Raw(ref mut w) => w.flush(),\n         }\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "6a48f65714cc50d95e6463d337ec64af32233dd1", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -49,6 +49,7 @@ use std::thread::panicking;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n+pub mod styled_buffer;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n use syntax_pos::{MacroBacktrace};\n@@ -81,16 +82,6 @@ pub trait CodeMapper {\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n }\n \n-impl RenderSpan {\n-    fn span(&self) -> &MultiSpan {\n-        match *self {\n-            FullSpan(ref msp) |\n-            Suggestion(CodeSuggestion { ref msp, .. }) =>\n-                msp\n-        }\n-    }\n-}\n-\n impl CodeSuggestion {\n     /// Returns the assembled code suggestion.\n     pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n@@ -238,7 +229,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             return;\n         }\n \n-        self.handler.emit.borrow_mut().emit_struct(&self);\n+        self.handler.emitter.borrow_mut().emit(&self);\n         self.cancel();\n         self.handler.panic_if_treat_err_as_bug();\n \n@@ -359,11 +350,20 @@ impl<'a> DiagnosticBuilder<'a> {\n     fn new(handler: &'a Handler,\n            level: Level,\n            message: &str) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new_with_code(handler, level, None, message)\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    fn new_with_code(handler: &'a Handler,\n+           level: Level,\n+           code: Option<String>,\n+           message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n             handler: handler,\n             level: level,\n             message: message.to_owned(),\n-            code: None,\n+            code: code,\n             span: MultiSpan::new(),\n             children: vec![],\n         }\n@@ -397,10 +397,10 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n-            self.handler.emit.borrow_mut().emit(&MultiSpan::new(),\n-                                                \"Error constructed but not emitted\",\n-                                                None,\n-                                                Bug);\n+            let mut db = DiagnosticBuilder::new(self.handler,\n+                                                Bug,\n+                                                \"Error constructed but not emitted\");\n+            db.emit();\n             panic!();\n         }\n     }\n@@ -411,7 +411,7 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n /// others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<usize>,\n-    emit: RefCell<Box<Emitter>>,\n+    emitter: RefCell<Box<Emitter>>,\n     pub can_emit_warnings: bool,\n     treat_err_as_bug: bool,\n     continue_after_error: Cell<bool>,\n@@ -423,7 +423,7 @@ impl Handler {\n                             registry: Option<registry::Registry>,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Rc<CodeMapper>)\n+                            cm: Option<Rc<CodeMapper>>)\n                             -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm,\n                                snippet::FormatMode::EnvironmentSelected));\n@@ -435,7 +435,7 @@ impl Handler {\n                         e: Box<Emitter>) -> Handler {\n         Handler {\n             err_count: Cell::new(0),\n-            emit: RefCell::new(e),\n+            emitter: RefCell::new(e),\n             can_emit_warnings: can_emit_warnings,\n             treat_err_as_bug: treat_err_as_bug,\n             continue_after_error: Cell::new(true),\n@@ -588,7 +588,7 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit.borrow_mut().emit(&sp.into(), msg, None, Note);\n+        self.emit(&sp.into(), msg, Note);\n     }\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n@@ -597,25 +597,40 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Fatal);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Fatal,\n+                                            msg);\n+        db.emit();\n         self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Error);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Error,\n+                                            msg);\n+        db.emit();\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Warning);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Warning,\n+                                            msg);\n+        db.emit();\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Note);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Note,\n+                                            msg);\n+        db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Bug);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Bug,\n+                                            msg);\n+        db.emit();\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -661,7 +676,9 @@ impl Handler {\n                 msg: &str,\n                 lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(&msp, msg, None, lvl);\n+        let mut db = DiagnosticBuilder::new(self, lvl, msg);\n+        db.set_span(msp.clone());\n+        db.emit();\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n     pub fn emit_with_code(&self,\n@@ -670,7 +687,12 @@ impl Handler {\n                           code: &str,\n                           lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(&msp, msg, Some(code), lvl);\n+        let mut db = DiagnosticBuilder::new_with_code(self,\n+                                                      lvl,\n+                                                      Some(code.to_owned()),\n+                                                      msg);\n+        db.set_span(msp.clone());\n+        db.emit();\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n }\n@@ -734,13 +756,13 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n ///\n /// FIXME(#33240)\n #[cfg(not(test))]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     use std::env;\n     env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n }\n \n /// For unit tests, use the new format.\n #[cfg(test)]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     false\n }"}, {"sha": "2f94a7f6832fe34401b3a52b6d54cb7d610023ef", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 18, "deletions": 835, "changes": 853, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -10,12 +10,10 @@\n \n // Code for annotating snippets.\n \n-use syntax_pos::{Span, FileMap, CharPos, LineInfo};\n-use check_old_skool;\n+use syntax_pos::{Span, FileMap};\n use CodeMapper;\n-use std::cmp;\n use std::rc::Rc;\n-use std::mem;\n+use {Level};\n \n #[derive(Clone)]\n pub enum FormatMode {\n@@ -49,37 +47,31 @@ pub struct FileInfo {\n     format_mode: FormatMode,\n }\n \n-#[derive(Clone, Debug)]\n-struct Line {\n-    line_index: usize,\n-    annotations: Vec<Annotation>,\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct Line {\n+    pub line_index: usize,\n+    pub annotations: Vec<Annotation>,\n }\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n-struct Annotation {\n+pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n     /// utf-8 bytes. Note that it is important that this field goes\n     /// first, so that when we sort, we sort orderings by start\n     /// column.\n-    start_col: usize,\n+    pub start_col: usize,\n \n     /// End column within the line (exclusive)\n-    end_col: usize,\n+    pub end_col: usize,\n \n     /// Is this annotation derived from primary span\n-    is_primary: bool,\n+    pub is_primary: bool,\n \n     /// Is this a large span minimized down to a smaller span\n-    is_minimized: bool,\n+    pub is_minimized: bool,\n \n     /// Optional label to display adjacent to the annotation.\n-    label: Option<String>,\n-}\n-\n-#[derive(Debug)]\n-pub struct RenderedLine {\n-    pub text: Vec<StyledString>,\n-    pub kind: RenderedLineKind,\n+    pub label: Option<String>,\n }\n \n #[derive(Debug)]\n@@ -88,14 +80,9 @@ pub struct StyledString {\n     pub style: Style,\n }\n \n-#[derive(Debug)]\n-pub struct StyledBuffer {\n-    text: Vec<Vec<char>>,\n-    styles: Vec<Vec<Style>>\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Style {\n+    HeaderMsg,\n     FileNameStyle,\n     LineAndColumn,\n     LineNumber,\n@@ -104,813 +91,9 @@ pub enum Style {\n     UnderlineSecondary,\n     LabelPrimary,\n     LabelSecondary,\n-    OldSkoolNoteText,\n-    OldSkoolNote,\n+    OldSchoolNoteText,\n+    OldSchoolNote,\n     NoStyle,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub enum RenderedLineKind {\n-    PrimaryFileName,\n-    OtherFileName,\n-    SourceText {\n-        file: Rc<FileMap>,\n-        line_index: usize,\n-    },\n-    Annotations,\n-    Elision,\n-}\n-\n-impl SnippetData {\n-    pub fn new(codemap: Rc<CodeMapper>,\n-               primary_span: Option<Span>,\n-               format_mode: FormatMode) // (*)\n-               -> Self {\n-        // (*) The primary span indicates the file that must appear\n-        // first, and which will have a line number etc in its\n-        // name. Outside of tests, this is always `Some`, but for many\n-        // tests it's not relevant to test this portion of the logic,\n-        // and it's tedious to pick a primary span (read: tedious to\n-        // port older tests that predate the existence of a primary\n-        // span).\n-\n-        debug!(\"SnippetData::new(primary_span={:?})\", primary_span);\n-\n-        let mut data = SnippetData {\n-            codemap: codemap.clone(),\n-            files: vec![],\n-            format_mode: format_mode.clone()\n-        };\n-        if let Some(primary_span) = primary_span {\n-            let lo = codemap.lookup_char_pos(primary_span.lo);\n-            data.files.push(\n-                FileInfo {\n-                    file: lo.file,\n-                    primary_span: Some(primary_span),\n-                    lines: vec![],\n-                    format_mode: format_mode.clone(),\n-                });\n-        }\n-        data\n-    }\n-\n-    pub fn push(&mut self, span: Span, is_primary: bool, label: Option<String>) {\n-        debug!(\"SnippetData::push(span={:?}, is_primary={}, label={:?})\",\n-               span, is_primary, label);\n-\n-        let file_lines = match self.codemap.span_to_lines(span) {\n-            Ok(file_lines) => file_lines,\n-            Err(_) => {\n-                // ignore unprintable spans completely.\n-                return;\n-            }\n-        };\n-\n-        self.file(&file_lines.file)\n-            .push_lines(&file_lines.lines, is_primary, label);\n-    }\n-\n-    fn file(&mut self, file_map: &Rc<FileMap>) -> &mut FileInfo {\n-        let index = self.files.iter().position(|f| f.file.name == file_map.name);\n-        if let Some(index) = index {\n-            return &mut self.files[index];\n-        }\n-\n-        self.files.push(\n-            FileInfo {\n-                file: file_map.clone(),\n-                lines: vec![],\n-                primary_span: None,\n-                format_mode: self.format_mode.clone()\n-            });\n-        self.files.last_mut().unwrap()\n-    }\n-\n-    pub fn render_lines(&self) -> Vec<RenderedLine> {\n-        debug!(\"SnippetData::render_lines()\");\n-\n-        let mut rendered_lines: Vec<_> =\n-            self.files.iter()\n-                      .flat_map(|f| f.render_file_lines(&self.codemap))\n-                      .collect();\n-        prepend_prefixes(&mut rendered_lines, &self.format_mode);\n-        trim_lines(&mut rendered_lines);\n-        rendered_lines\n-    }\n-}\n-\n-pub trait StringSource {\n-    fn make_string(self) -> String;\n-}\n-\n-impl StringSource for String {\n-    fn make_string(self) -> String {\n-        self\n-    }\n-}\n-\n-impl StringSource for Vec<char> {\n-    fn make_string(self) -> String {\n-        self.into_iter().collect()\n-    }\n-}\n-\n-impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n-    where S: StringSource\n-{\n-    fn from((text, style, kind): (S, Style, RenderedLineKind)) -> Self {\n-        RenderedLine {\n-            text: vec![StyledString {\n-                text: text.make_string(),\n-                style: style,\n-            }],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl<S1,S2> From<(S1, Style, S2, Style, RenderedLineKind)> for RenderedLine\n-    where S1: StringSource, S2: StringSource\n-{\n-    fn from(tuple: (S1, Style, S2, Style, RenderedLineKind)) -> Self {\n-        let (text1, style1, text2, style2, kind) = tuple;\n-        RenderedLine {\n-            text: vec![\n-                StyledString {\n-                    text: text1.make_string(),\n-                    style: style1,\n-                },\n-                StyledString {\n-                    text: text2.make_string(),\n-                    style: style2,\n-                }\n-            ],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl RenderedLine {\n-    fn trim_last(&mut self) {\n-        if let Some(last_text) = self.text.last_mut() {\n-            let len = last_text.text.trim_right().len();\n-            last_text.text.truncate(len);\n-        }\n-    }\n-}\n-\n-impl RenderedLineKind {\n-    fn prefix(&self) -> StyledString {\n-        match *self {\n-            RenderedLineKind::SourceText { file: _, line_index } =>\n-                StyledString {\n-                    text: format!(\"{}\", line_index + 1),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::Elision =>\n-                StyledString {\n-                    text: String::from(\"...\"),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::PrimaryFileName |\n-            RenderedLineKind::OtherFileName |\n-            RenderedLineKind::Annotations =>\n-                StyledString {\n-                    text: String::from(\"\"),\n-                    style: Style::LineNumber,\n-                },\n-        }\n-    }\n-}\n-\n-impl StyledBuffer {\n-    fn new() -> StyledBuffer {\n-        StyledBuffer { text: vec![], styles: vec![] }\n-    }\n-\n-    fn render(&self, source_kind: RenderedLineKind) -> Vec<RenderedLine> {\n-        let mut output: Vec<RenderedLine> = vec![];\n-        let mut styled_vec: Vec<StyledString> = vec![];\n-\n-        for (row, row_style) in self.text.iter().zip(&self.styles) {\n-            let mut current_style = Style::NoStyle;\n-            let mut current_text = String::new();\n-\n-            for (&c, &s) in row.iter().zip(row_style) {\n-                if s != current_style {\n-                    if !current_text.is_empty() {\n-                        styled_vec.push(StyledString { text: current_text, style: current_style });\n-                    }\n-                    current_style = s;\n-                    current_text = String::new();\n-                }\n-                current_text.push(c);\n-            }\n-            if !current_text.is_empty() {\n-                styled_vec.push(StyledString { text: current_text, style: current_style });\n-            }\n-\n-            if output.is_empty() {\n-                //We know our first output line is source and the rest are highlights and labels\n-                output.push(RenderedLine { text: styled_vec, kind: source_kind.clone() });\n-            } else {\n-                output.push(RenderedLine { text: styled_vec, kind: RenderedLineKind::Annotations });\n-            }\n-            styled_vec = vec![];\n-        }\n-\n-        output\n-    }\n-\n-    fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n-        while line >= self.text.len() {\n-            self.text.push(vec![]);\n-            self.styles.push(vec![]);\n-        }\n-\n-        if col < self.text[line].len() {\n-            self.text[line][col] = chr;\n-            self.styles[line][col] = style;\n-        } else {\n-            let mut i = self.text[line].len();\n-            while i < col {\n-                let s = match self.text[0].get(i) {\n-                    Some(&'\\t') => '\\t',\n-                    _ => ' '\n-                };\n-                self.text[line].push(s);\n-                self.styles[line].push(Style::NoStyle);\n-                i += 1;\n-            }\n-            self.text[line].push(chr);\n-            self.styles[line].push(style);\n-        }\n-    }\n-\n-    fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n-        let mut n = col;\n-        for c in string.chars() {\n-            self.putc(line, n, c, style);\n-            n += 1;\n-        }\n-    }\n-\n-    fn set_style(&mut self, line: usize, col: usize, style: Style) {\n-        if self.styles.len() > line && self.styles[line].len() > col {\n-            self.styles[line][col] = style;\n-        }\n-    }\n-\n-    fn append(&mut self, line: usize, string: &str, style: Style) {\n-        if line >= self.text.len() {\n-            self.puts(line, 0, string, style);\n-        } else {\n-            let col = self.text[line].len();\n-            self.puts(line, col, string, style);\n-        }\n-    }\n-}\n-\n-impl FileInfo {\n-    fn push_lines(&mut self,\n-                  lines: &[LineInfo],\n-                  is_primary: bool,\n-                  label: Option<String>) {\n-        assert!(lines.len() > 0);\n-\n-        // If a span covers multiple lines, we reduce it to a single\n-        // point at the start of the span. This means that instead\n-        // of producing output like this:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // 3   |>                               -> Set<LR0Item<'grammar>>\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // (and so on)\n-        // ```\n-        //\n-        // we produce:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //        ^\n-        // ```\n-        //\n-        // Basically, although this loses information, multi-line spans just\n-        // never look good.\n-\n-        let (line, start_col, mut end_col, is_minimized) = if lines.len() == 1 {\n-            (lines[0].line_index, lines[0].start_col, lines[0].end_col, false)\n-        } else {\n-            (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1), true)\n-        };\n-\n-        // Watch out for \"empty spans\". If we get a span like 6..6, we\n-        // want to just display a `^` at 6, so convert that to\n-        // 6..7. This is degenerate input, but it's best to degrade\n-        // gracefully -- and the parser likes to suply a span like\n-        // that for EOF, in particular.\n-        if start_col == end_col {\n-            end_col.0 += 1;\n-        }\n-\n-        let index = self.ensure_source_line(line);\n-        self.lines[index].push_annotation(start_col,\n-                                          end_col,\n-                                          is_primary,\n-                                          is_minimized,\n-                                          label);\n-    }\n-\n-    /// Ensure that we have a `Line` struct corresponding to\n-    /// `line_index` in the file. If we already have some other lines,\n-    /// then this will add the intervening lines to ensure that we\n-    /// have a complete snippet. (Note that when we finally display,\n-    /// some of those lines may be elided.)\n-    fn ensure_source_line(&mut self, line_index: usize) -> usize {\n-        if self.lines.is_empty() {\n-            self.lines.push(Line::new(line_index));\n-            return 0;\n-        }\n-\n-        // Find the range of lines we have thus far.\n-        let first_line_index = self.lines.first().unwrap().line_index;\n-        let last_line_index = self.lines.last().unwrap().line_index;\n-        assert!(first_line_index <= last_line_index);\n-\n-        // If the new line is lower than all the lines we have thus\n-        // far, then insert the new line and any intervening lines at\n-        // the front. In a silly attempt at micro-optimization, we\n-        // don't just call `insert` repeatedly, but instead make a new\n-        // (empty) vector, pushing the new lines onto it, and then\n-        // appending the old vector.\n-        if line_index < first_line_index {\n-            let lines = mem::replace(&mut self.lines, vec![]);\n-            self.lines.extend(\n-                (line_index .. first_line_index)\n-                    .map(|line| Line::new(line))\n-                    .chain(lines));\n-            return 0;\n-        }\n-\n-        // If the new line comes after the ones we have so far, insert\n-        // lines for it.\n-        if line_index > last_line_index {\n-            self.lines.extend(\n-                (last_line_index+1 .. line_index+1)\n-                    .map(|line| Line::new(line)));\n-            return self.lines.len() - 1;\n-        }\n-\n-        // Otherwise it should already exist.\n-        return line_index - first_line_index;\n-    }\n-\n-    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<RenderedLine> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        // As a first step, we elide any instance of more than one\n-        // continuous unannotated line.\n-\n-        let mut lines_iter = self.lines.iter();\n-        let mut output = vec![];\n-\n-        // First insert the name of the file.\n-        if !old_school {\n-            match self.primary_span {\n-                Some(span) => {\n-                    let lo = codemap.lookup_char_pos(span.lo);\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: lo.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }, StyledString {\n-                            text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n-                            style: Style::LineAndColumn,\n-                        }],\n-                        kind: RenderedLineKind::PrimaryFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n-                }\n-                None => {\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: self.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::OtherFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n-                }\n-            }\n-        }\n-\n-        let mut next_line = lines_iter.next();\n-        while next_line.is_some() {\n-            // Consume lines with annotations.\n-            while let Some(line) = next_line {\n-                if line.annotations.is_empty() { break; }\n-\n-                let mut rendered_lines = self.render_line(line);\n-                assert!(!rendered_lines.is_empty());\n-                if old_school {\n-                    match self.primary_span {\n-                        Some(span) => {\n-                            let lo = codemap.lookup_char_pos(span.lo);\n-                            let hi = codemap.lookup_char_pos(span.hi);\n-                            //Before each secondary line in old skool-mode, print the label\n-                            //as an old-style note\n-                            if !line.annotations[0].is_primary {\n-                                if let Some(ann) = line.annotations[0].label.clone() {\n-                                    output.push(RenderedLine {\n-                                        text: vec![StyledString {\n-                                            text: lo.file.name.clone(),\n-                                            style: Style::FileNameStyle,\n-                                        }, StyledString {\n-                                            text: format!(\":{}:{}: {}:{} \", lo.line, lo.col.0 + 1,\n-                                                hi.line, hi.col.0+1),\n-                                            style: Style::LineAndColumn,\n-                                        }, StyledString {\n-                                            text: format!(\"note: \"),\n-                                            style: Style::OldSkoolNote,\n-                                        }, StyledString {\n-                                            text: format!(\"{}\", ann),\n-                                            style: Style::OldSkoolNoteText,\n-                                        }],\n-                                        kind: RenderedLineKind::Annotations,\n-                                    });\n-                                }\n-                            }\n-                            rendered_lines[0].text.insert(0, StyledString {\n-                                text: format!(\":{} \", lo.line),\n-                                style: Style::LineAndColumn,\n-                            });\n-                            rendered_lines[0].text.insert(0, StyledString {\n-                                text: lo.file.name.clone(),\n-                                style: Style::FileNameStyle,\n-                            });\n-                            let gap_amount =\n-                                rendered_lines[0].text[0].text.len() +\n-                                rendered_lines[0].text[1].text.len();\n-                            assert!(rendered_lines.len() >= 2,\n-                                    \"no annotations resulted from: {:?}\",\n-                                    line);\n-                            for i in 1..rendered_lines.len() {\n-                                rendered_lines[i].text.insert(0, StyledString {\n-                                    text: vec![\" \"; gap_amount].join(\"\"),\n-                                    style: Style::NoStyle\n-                                });\n-                            }\n-                        }\n-                        _ =>()\n-                    }\n-                }\n-                output.append(&mut rendered_lines);\n-                next_line = lines_iter.next();\n-            }\n-\n-            // Emit lines without annotations, but only if they are\n-            // followed by a line with an annotation.\n-            let unannotated_line = next_line;\n-            let mut unannotated_lines = 0;\n-            while let Some(line) = next_line {\n-                if !line.annotations.is_empty() { break; }\n-                unannotated_lines += 1;\n-                next_line = lines_iter.next();\n-            }\n-            if unannotated_lines > 1 {\n-                output.push(RenderedLine::from((String::new(),\n-                                                Style::NoStyle,\n-                                                RenderedLineKind::Elision)));\n-            } else if let Some(line) = unannotated_line {\n-                output.append(&mut self.render_line(line));\n-            }\n-        }\n-\n-        output\n-    }\n-\n-    fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        let source_string = self.file.get_line(line.line_index)\n-                                     .unwrap_or(\"\");\n-        let source_kind = RenderedLineKind::SourceText {\n-            file: self.file.clone(),\n-            line_index: line.line_index,\n-        };\n-\n-        let mut styled_buffer = StyledBuffer::new();\n-\n-        // First create the source line we will highlight.\n-        styled_buffer.append(0, &source_string, Style::Quotation);\n-\n-        if line.annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        // We want to display like this:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ^^^               _ previous borrow ends here\n-        //      |        |\n-        //      |        error occurs here\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // But there are some weird edge cases to be aware of:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      --------                    - previous borrow ends here\n-        //      ||\n-        //      |this makes no sense\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // For this reason, we group the lines into \"highlight lines\"\n-        // and \"annotations lines\", where the highlight lines have the `~`.\n-\n-        //let mut highlight_line = Self::whitespace(&source_string);\n-\n-        // Sort the annotations by (start, end col)\n-        let mut annotations = line.annotations.clone();\n-        annotations.sort();\n-\n-        // Next, create the highlight line.\n-        for annotation in &annotations {\n-            if old_school {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if p == annotation.start_col {\n-                        styled_buffer.putc(1, p, '^',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSkoolNote\n-                            });\n-                    }\n-                    else {\n-                        styled_buffer.putc(1, p, '~',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSkoolNote\n-                            });\n-                    }\n-                }\n-            }\n-            else {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if annotation.is_primary {\n-                        styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n-                        }\n-                    } else {\n-                        styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlineSecondary);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Now we are going to write labels in. To start, we'll exclude\n-        // the annotations with no labels.\n-        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) =\n-            annotations.into_iter()\n-                       .partition(|a| a.label.is_some());\n-\n-        // If there are no annotations that need text, we're done.\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-        if old_school {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        // Now add the text labels. We try, when possible, to stick the rightmost\n-        // annotation at the end of the highlight line:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ---               - previous borrow ends here\n-        //\n-        // But sometimes that's not possible because one of the other\n-        // annotations overlaps it. For example, from the test\n-        // `span_overlap_label`, we have the following annotations\n-        // (written on distinct lines for clarity):\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //             -\n-        //\n-        // In this case, we can't stick the rightmost-most label on\n-        // the highlight line, or we would get:\n-        //\n-        //      fn foo(x: u32) {\n-        //      -------- x_span\n-        //      |\n-        //      fn_span\n-        //\n-        // which is totally weird. Instead we want:\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //      |      |\n-        //      |      x_span\n-        //      fn_span\n-        //\n-        // which is...less weird, at least. In fact, in general, if\n-        // the rightmost span overlaps with any other span, we should\n-        // use the \"hang below\" version, so we can at least make it\n-        // clear where the span *starts*.\n-        let mut labeled_annotations = &labeled_annotations[..];\n-        match labeled_annotations.split_last().unwrap() {\n-            (last, previous) => {\n-                if previous.iter()\n-                           .chain(&unlabeled_annotations)\n-                           .all(|a| !overlaps(a, last))\n-                {\n-                    // append the label afterwards; we keep it in a separate\n-                    // string\n-                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n-                    if last.is_primary {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelPrimary);\n-                    } else {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelSecondary);\n-                    }\n-                    labeled_annotations = previous;\n-                }\n-            }\n-        }\n-\n-        // If that's the last annotation, we're done\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        for (index, annotation) in labeled_annotations.iter().enumerate() {\n-            // Leave:\n-            // - 1 extra line\n-            // - One line for each thing that comes after\n-            let comes_after = labeled_annotations.len() - index - 1;\n-            let blank_lines = 3 + comes_after;\n-\n-            // For each blank line, draw a `|` at our column. The\n-            // text ought to be long enough for this.\n-            for index in 2..blank_lines {\n-                if annotation.is_primary {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlinePrimary);\n-                } else {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlineSecondary);\n-                }\n-            }\n-\n-            if annotation.is_primary {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelPrimary);\n-            } else {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelSecondary);\n-            }\n-        }\n-\n-        styled_buffer.render(source_kind)\n-    }\n-}\n-\n-fn prepend_prefixes(rendered_lines: &mut [RenderedLine], format_mode: &FormatMode) {\n-    let old_school = match *format_mode {\n-        FormatMode::OriginalErrorFormat => true,\n-        FormatMode::NewErrorFormat => false,\n-        FormatMode::EnvironmentSelected => check_old_skool()\n-    };\n-    if old_school {\n-        return;\n-    }\n-\n-    let prefixes: Vec<_> =\n-        rendered_lines.iter()\n-                      .map(|rl| rl.kind.prefix())\n-                      .collect();\n-\n-    // find the max amount of spacing we need; add 1 to\n-    // p.text.len() to leave space between the prefix and the\n-    // source text\n-    let padding_len =\n-        prefixes.iter()\n-                .map(|p| if p.text.len() == 0 { 0 } else { p.text.len() + 1 })\n-                .max()\n-                .unwrap_or(0);\n-\n-    // Ensure we insert at least one character of padding, so that the\n-    // `-->` arrows can fit etc.\n-    let padding_len = cmp::max(padding_len, 1);\n-\n-    for (mut prefix, line) in prefixes.into_iter().zip(rendered_lines) {\n-        let extra_spaces = (prefix.text.len() .. padding_len).map(|_| ' ');\n-        prefix.text.extend(extra_spaces);\n-        match line.kind {\n-            RenderedLineKind::Elision => {\n-                line.text.insert(0, prefix);\n-            }\n-            RenderedLineKind::PrimaryFileName => {\n-                //   --> filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('>'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            RenderedLineKind::OtherFileName => {\n-                //   ::: filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            _ => {\n-                line.text.insert(0, prefix);\n-                line.text.insert(1, StyledString {text: String::from(\"|> \"),\n-                                                  style: Style::LineNumber})\n-            }\n-        }\n-    }\n-}\n-\n-fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n-    for line in rendered_lines {\n-        while !line.text.is_empty() {\n-            line.trim_last();\n-            if line.text.last().unwrap().text.is_empty() {\n-                line.text.pop();\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-impl Line {\n-    fn new(line_index: usize) -> Line {\n-        Line {\n-            line_index: line_index,\n-            annotations: vec![]\n-        }\n-    }\n-\n-    fn push_annotation(&mut self,\n-                       start: CharPos,\n-                       end: CharPos,\n-                       is_primary: bool,\n-                       is_minimized: bool,\n-                       label: Option<String>) {\n-        self.annotations.push(Annotation {\n-            start_col: start.0,\n-            end_col: end.0,\n-            is_primary: is_primary,\n-            is_minimized: is_minimized,\n-            label: label,\n-        });\n-    }\n-}\n-\n-fn overlaps(a1: &Annotation,\n-            a2: &Annotation)\n-            -> bool\n-{\n-    (a2.start_col .. a2.end_col).contains(a1.start_col) ||\n-        (a1.start_col .. a1.end_col).contains(a2.start_col)\n-}\n+    ErrorCode,\n+    Level(Level),\n+}\n\\ No newline at end of file"}, {"sha": "9768b68619e7945ec38648300874f9507d4cf12f", "filename": "src/librustc_errors/styled_buffer.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for creating styled buffers\n+\n+use snippet::{Style, StyledString};\n+\n+#[derive(Debug)]\n+pub struct StyledBuffer {\n+    text: Vec<Vec<char>>,\n+    styles: Vec<Vec<Style>>,\n+}\n+\n+impl StyledBuffer {\n+    pub fn new() -> StyledBuffer {\n+        StyledBuffer {\n+            text: vec![],\n+            styles: vec![],\n+        }\n+    }\n+\n+    pub fn copy_tabs(&mut self, row: usize) {\n+        if row < self.text.len() {\n+            for i in row+1..self.text.len() {\n+                for j in 0..self.text[i].len() {\n+                    if self.text[row].len() > j &&\n+                       self.text[row][j] == '\\t' &&\n+                       self.text[i][j] == ' ' {\n+                        self.text[i][j] = '\\t';\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn render(&mut self) -> Vec<Vec<StyledString>> {\n+        let mut output: Vec<Vec<StyledString>> = vec![];\n+        let mut styled_vec: Vec<StyledString> = vec![];\n+\n+        //before we render, do a little patch-up work to support tabs\n+        self.copy_tabs(3);\n+\n+        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+            let mut current_style = Style::NoStyle;\n+            let mut current_text = String::new();\n+\n+            for (&c, &s) in row.iter().zip(row_style) {\n+                if s != current_style {\n+                    if !current_text.is_empty() {\n+                        styled_vec.push(StyledString {\n+                            text: current_text,\n+                            style: current_style,\n+                        });\n+                    }\n+                    current_style = s;\n+                    current_text = String::new();\n+                }\n+                current_text.push(c);\n+            }\n+            if !current_text.is_empty() {\n+                styled_vec.push(StyledString {\n+                    text: current_text,\n+                    style: current_style,\n+                });\n+            }\n+\n+            // We're done with the row, push and keep going\n+            output.push(styled_vec);\n+\n+            styled_vec = vec![];\n+        }\n+\n+        output\n+    }\n+\n+    fn ensure_lines(&mut self, line: usize) {\n+        while line >= self.text.len() {\n+            self.text.push(vec![]);\n+            self.styles.push(vec![]);\n+        }\n+    }\n+\n+    pub fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n+        self.ensure_lines(line);\n+        if col < self.text[line].len() {\n+            self.text[line][col] = chr;\n+            self.styles[line][col] = style;\n+        } else {\n+            let mut i = self.text[line].len();\n+            while i < col {\n+                self.text[line].push(' ');\n+                self.styles[line].push(Style::NoStyle);\n+                i += 1;\n+            }\n+            self.text[line].push(chr);\n+            self.styles[line].push(style);\n+        }\n+    }\n+\n+    pub fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n+        let mut n = col;\n+        for c in string.chars() {\n+            self.putc(line, n, c, style);\n+            n += 1;\n+        }\n+    }\n+\n+    pub fn set_style(&mut self, line: usize, col: usize, style: Style) {\n+        if self.styles.len() > line && self.styles[line].len() > col {\n+            self.styles[line][col] = style;\n+        }\n+    }\n+\n+    pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n+        self.ensure_lines(line);\n+        let string_len = string.len();\n+\n+        // Push the old content over to make room for new content\n+        for _ in 0..string_len {\n+            self.styles[line].insert(0, Style::NoStyle);\n+            self.text[line].insert(0, ' ');\n+        }\n+\n+        self.puts(line, 0, string, style);\n+    }\n+\n+    pub fn append(&mut self, line: usize, string: &str, style: Style) {\n+        if line >= self.text.len() {\n+            self.puts(line, 0, string, style);\n+        } else {\n+            let col = self.text[line].len();\n+            self.puts(line, col, string, style);\n+        }\n+    }\n+\n+    pub fn num_lines(&self) -> usize {\n+        self.text.len()\n+    }\n+}"}, {"sha": "f688bd80ee9dabe95701d425a5a851f09ad65cb8", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -698,7 +698,8 @@ impl LateLintPass for VariantSizeDifferences {\n             if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n                 let t = cx.tcx.node_id_to_type(it.id);\n                 let layout = cx.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-                    t.layout(&infcx).unwrap_or_else(|e| {\n+                    let ty = cx.tcx.erase_regions(&t);\n+                    ty.layout(&infcx).unwrap_or_else(|e| {\n                         bug!(\"failed to get layout for `{}`: {}\", t, e)\n                     })\n                 });"}, {"sha": "409cec282bce93de82457834f12ad5e479c33d57", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -687,32 +687,6 @@ fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n         }\n     }\n \n-    // As a special case, iterate over all static methods of\n-    // associated implementations too. This is a bit of a botch.\n-    // --pcwalton\n-    for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n-                                                             tag_items_data_item_inherent_impl) {\n-        let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n-        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.index) {\n-            for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n-                                                                 tag_item_impl_item) {\n-                let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n-                                                   cdata);\n-                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n-                    if let StaticMethod = item_family(impl_method_doc) {\n-                        // Hand off the static method to the callback.\n-                        let static_method_name = item_name(impl_method_doc);\n-                        let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n-                                                                      impl_item_def_id);\n-                        callback(static_method_def_like,\n-                                 static_method_name,\n-                                 item_visibility(impl_method_doc));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     for reexport_doc in reexports(item_doc) {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);"}, {"sha": "70e566de8a7be5ab9a53900cd82678e7268329fe", "filename": "src/librustc_resolve/assign_ids.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -11,7 +11,7 @@\n use Resolver;\n use rustc::session::Session;\n use syntax::ast;\n-use syntax::ext::mtwt;\n+use syntax::ext::hygiene::Mark;\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n@@ -31,7 +31,7 @@ impl<'a> Resolver<'a> {\n \n struct NodeIdAssigner<'a> {\n     sess: &'a Session,\n-    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<Mark>>,\n }\n \n impl<'a> Folder for NodeIdAssigner<'a> {\n@@ -49,7 +49,7 @@ impl<'a> Folder for NodeIdAssigner<'a> {\n             block.stmts = block.stmts.move_flat_map(|stmt| {\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n                     if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n                         return None;\n                     }\n                 }"}, {"sha": "aa8c706ea1e27b9cb73978f7248864c3627ee7e8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -53,7 +53,7 @@ use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::mtwt;\n+use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n@@ -654,7 +654,7 @@ enum RibKind<'a> {\n     ModuleRibKind(Module<'a>),\n \n     // We passed through a `macro_rules!` statement with the given expansion\n-    MacroDefinition(ast::Mrk),\n+    MacroDefinition(Mark),\n }\n \n #[derive(Copy, Clone)]\n@@ -933,7 +933,7 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+    macros_at_scope: HashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n@@ -1434,10 +1434,9 @@ impl<'a> Resolver<'a> {\n             if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n-                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                    if mac == source_macro {\n-                        ident = source_ident;\n-                    }\n+                let (source_ctxt, source_macro) = ident.ctxt.source();\n+                if source_macro == mac {\n+                    ident.ctxt = source_ctxt;\n                 }\n             }\n         }\n@@ -1585,10 +1584,9 @@ impl<'a> Resolver<'a> {\n                 MacroDefinition(mac) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n-                        if mac == source_macro {\n-                            ident = source_ident;\n-                        }\n+                    let (source_ctxt, source_macro) = ident.ctxt.source();\n+                    if source_macro == mac {\n+                        ident.ctxt = source_ctxt;\n                     }\n                 }\n                 _ => {"}, {"sha": "33cffa8a480137a17a36dffef93a12422ae64065", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -19,8 +19,8 @@ use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n-use errors::{self, Handler, Level, RenderSpan};\n-use errors::emitter::CoreEmitter;\n+use errors::{self, Handler, Level, DiagnosticBuilder};\n+use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n \n use std::collections::HashMap;\n@@ -100,23 +100,23 @@ impl SharedEmitter {\n     }\n }\n \n-impl CoreEmitter for SharedEmitter {\n-    fn emit_message(&mut self,\n-                    _rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n         self.buffer.lock().unwrap().push(Diagnostic {\n-            msg: msg.to_string(),\n-            code: code.map(|s| s.to_string()),\n-            lvl: lvl,\n+            msg: db.message.to_string(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n         });\n+        for child in &db.children {\n+            self.buffer.lock().unwrap().push(Diagnostic {\n+                msg: child.message.to_string(),\n+                code: None,\n+                lvl: child.level,\n+            });\n+        }\n     }\n }\n \n-\n // On android, we by default compile for armv7 processors. This enables\n // things like double word CAS instructions (rather than emulating them)\n // which are *far* more efficient. This is obviously undesirable in some"}, {"sha": "c8b9fea15ba8b0e12cb4c3557411deddb8f3b056", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -2270,12 +2270,9 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n \n                 if is_decl || is_available_externally {\n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                        .to_bytes()\n-                        .to_vec();\n+                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                     declared.insert(name);\n                 }\n-\n             }\n         }\n \n@@ -2286,21 +2283,21 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n-                let is_external = linkage == llvm::ExternalLinkage as c_uint;\n-                let is_weak_odr = linkage == llvm::WeakODRLinkage as c_uint;\n-                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n-\n-                // We only care about external definitions.\n-                if (is_external || is_weak_odr) && !is_decl {\n+                let is_externally_visible = (linkage == llvm::ExternalLinkage as c_uint) ||\n+                                            (linkage == llvm::LinkOnceODRLinkage as c_uint) ||\n+                                            (linkage == llvm::WeakODRLinkage as c_uint);\n+                let is_definition = llvm::LLVMIsDeclaration(val) != 0;\n \n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n-                                .to_bytes()\n-                                .to_vec();\n+                // If this is a definition (as opposed to just a declaration)\n+                // and externally visible, check if we can internalize it\n+                if is_definition && is_externally_visible {\n+                    let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                    let name_str = name_cstr.to_str().unwrap();\n \n-                    let is_declared = declared.contains(&name);\n-                    let reachable = reachable.contains(str::from_utf8(&name).unwrap());\n+                    let is_referenced_somewhere = declared.contains(&name_cstr);\n+                    let is_reachable = reachable.contains(name_str);\n \n-                    if !is_declared && !reachable {\n+                    if !is_referenced_somewhere && !is_reachable {\n                         llvm::SetLinkage(val, llvm::InternalLinkage);\n                         llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n                         llvm::UnsetComdat(val);\n@@ -2488,7 +2485,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n-    let codegen_unit_count = codegen_units.len();\n \n     let symbol_map = Rc::new(symbol_map);\n \n@@ -2620,10 +2616,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    if codegen_unit_count > 1 {\n-        internalize_symbols(&crate_context_list,\n-                            &reachable_symbols.iter().map(|x| &x[..]).collect());\n-    }\n+    internalize_symbols(&crate_context_list,\n+                        &reachable_symbols.iter().map(|x| &x[..]).collect());\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {"}, {"sha": "fc9ae73f5ce7e2ec96a4c584c4e8f652c9b38746", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -131,7 +131,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                                None,\n                                                                true,\n                                                                false,\n-                                                               codemap.clone());\n+                                                               Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();"}, {"sha": "f9d0df9981a1d73bc9e796746aaca850cda0736d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -77,7 +77,7 @@ pub fn run(input: &str,\n                                                                None,\n                                                                true,\n                                                                false,\n-                                                               codemap.clone());\n+                                                               Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n@@ -229,7 +229,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let codemap = Rc::new(CodeMap::new());\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n                                                 None,\n-                                                codemap.clone(),\n+                                                Some(codemap.clone()),\n                                                 errors::snippet::FormatMode::EnvironmentSelected);\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));"}, {"sha": "a8bb255fba4a4d4b099c936239dee1abdc7fee7c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -19,6 +19,7 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n+use ext::hygiene::SyntaxContext;\n use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n@@ -33,15 +34,6 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Name(pub u32);\n \n-/// A SyntaxContext represents a chain of macro-expandings\n-/// and renamings. Each macro expansion corresponds to\n-/// a fresh u32. This u32 is a reference to a table stored\n-/// in thread-local storage.\n-/// The special value EMPTY_CTXT is used to indicate an empty\n-/// syntax context.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct SyntaxContext(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -81,20 +73,15 @@ impl Decodable for Name {\n     }\n }\n \n-pub const EMPTY_CTXT : SyntaxContext = SyntaxContext(0);\n-\n impl Ident {\n-    pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n-        Ident {name: name, ctxt: ctxt}\n-    }\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n-        Ident {name: name, ctxt: EMPTY_CTXT}\n+        Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n }\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}#{}\", self.name, self.ctxt.0)\n+        write!(f, \"{}{:?}\", self.name, self.ctxt)\n     }\n }\n \n@@ -116,9 +103,6 @@ impl Decodable for Ident {\n     }\n }\n \n-/// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = u32;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "a8aca90e6238daf18f6503aa6f7b7664dd35366e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 781, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -827,12 +827,6 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use errors::{Level, CodeSuggestion};\n-    use errors::emitter::EmitterWriter;\n-    use errors::snippet::{SnippetData, RenderedLine, FormatMode};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1122,24 +1116,6 @@ mod tests {\n         }\n     }\n \n-    fn splice(start: Span, end: Span) -> Span {\n-        Span {\n-            lo: start.lo,\n-            hi: end.hi,\n-            expn_id: NO_EXPANSION,\n-        }\n-    }\n-\n-    fn make_string(lines: &[RenderedLine]) -> String {\n-        lines.iter()\n-            .flat_map(|rl| {\n-                rl.text.iter()\n-                        .map(|s| &s.text[..])\n-                        .chain(Some(\"\\n\"))\n-            })\n-            .collect()\n-    }\n-\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n@@ -1219,761 +1195,4 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n-\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                        None,\n-                                        cm.clone(),\n-                                        FormatMode::NewErrorFormat);\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n-        let start = file.lines.borrow()[10];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&sp.into(), lvl).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"r#\\\"\\n{}\\\"#\", str);\n-        assert_eq!(str, &r#\"\n-  --> dummy.txt:11:1\n-   |>\n-11 |>         e-l\u00e4-v\u00e4n\n-   |> ^\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn test_single_span_splice() {\n-        // Test that a `MultiSpan` containing a single span splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp = span_from_selection(inputtext, selection);\n-        let msp: MultiSpan = sp.into();\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        let substitute = \"ZZZZZZ\".to_owned();\n-        let expected = \"bbbbZZZZZZddddd\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![substitute],\n-        };\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multi_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n-        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp1 = span_from_selection(inputtext, selection1);\n-        let sp2 = span_from_selection(inputtext, selection2);\n-        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n-\n-        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![\"ZZZZZZ\".to_owned(),\n-                              \"XYZ\".to_owned()]\n-        };\n-\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          cm.clone(),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ~~~~~~                    \";\n-        let sp2 =       \"               ~~~~~~          \";\n-        let sp3 =       \"                       ~~~~~   \";\n-        let sp4 =       \"                          ~~~~ \";\n-        let sp34 =      \"                       ~~~~~~~ \";\n-\n-        let expect_start = &r#\"\n- --> dummy.txt:1:6\n-  |>\n-1 |> _____aaaaaa____bbbbbb__cccccdd_\n-  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n-\"#[1..];\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-        let sp1 = span(sp1, \"aaaaaa\");\n-        let sp2 = span(sp2, \"bbbbbb\");\n-        let sp3 = span(sp3, \"ccccc\");\n-        let sp4 = span(sp4, \"ccdd\");\n-        let sp34 = span(sp34, \"cccccdd\");\n-\n-        let spans = vec![sp1, sp2, sp3, sp4];\n-\n-        let test = |expected, highlight: &mut FnMut()| {\n-            data.lock().unwrap().clear();\n-            highlight();\n-            let vec = data.lock().unwrap().clone();\n-            let actual = from_utf8(&vec[..]).unwrap();\n-            println!(\"actual=\\n{}\", actual);\n-            assert_eq!(actual, expected);\n-        };\n-\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n-        test(expect_start, &mut || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test(expect_start, &mut || {\n-            let msp = MultiSpan::from_spans(spans.clone());\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn test_huge_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          cm.clone(),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp = \"aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   bbbbb\\n\\\n-                   ccccc\\n\\\n-                   xxxxx\\n\\\n-                   yyyyy\\n\\\n-                   _____\\n\\\n-                   ddd__eee_\\n\\\n-                   elided\\n\\\n-                   __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-\n-        let span = |lo, hi, (off_lo, off_hi)| {\n-            let lines = file.lines.borrow();\n-            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n-            lo.0 += off_lo;\n-            hi.0 += off_hi;\n-            mk_sp(lo, hi)\n-        };\n-        let sp0 = span(4, 6, (0, 5));\n-        let sp1 = span(0, 6, (0, 5));\n-        let sp2 = span(8, 8, (0, 3));\n-        let sp3 = span(8, 8, (5, 8));\n-        let sp4 = span(10, 10, (2, 3));\n-        let sp5 = span(10, 10, (4, 6));\n-\n-        let expect0 = &r#\"\n-   --> dummy.txt:5:1\n-    |>\n-5   |> ccccc\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        let expect = &r#\"\n-   --> dummy.txt:1:1\n-    |>\n-1   |> aaaaa\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        macro_rules! test {\n-            ($expected: expr, $highlight: expr) => ({\n-                data.lock().unwrap().clear();\n-                $highlight();\n-                let vec = data.lock().unwrap().clone();\n-                let actual = from_utf8(&vec[..]).unwrap();\n-                println!(\"actual:\");\n-                println!(\"{}\", actual);\n-                println!(\"expected:\");\n-                println!(\"{}\", $expected);\n-                assert_eq!(&actual[..], &$expected[..]);\n-            });\n-        }\n-\n-        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n-\n-        test!(expect0, || {\n-            diag.highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n-        test!(expect, || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn tab() {\n-        let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_bar), FormatMode::NewErrorFormat);\n-        snippet.push(span_bar, true, None);\n-\n-        let lines = snippet.render_lines();\n-        let text = make_string(&lines);\n-        assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n-\"[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn two_files() {\n-        let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-        let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-        let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-        let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-        let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-        let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-        let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-        let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_foo_vec1), FormatMode::NewErrorFormat);\n-        snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-        snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-        snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-        snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-        snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-        snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-\n-        // Note that the `|>` remain aligned across both files:\n-        assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n-   ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n-...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn multi_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-        let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-        let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-        snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-        snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n-...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n-...\n-11  |> }\n-    |> - immutable borrow ends here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn overlapping() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-        let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-        let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span0, false, Some(format!(\"A\")));\n-        snippet.push(span1, false, Some(format!(\"B\")));\n-        snippet.push(span2, false, Some(format!(\"C\")));\n-        snippet.push(span3, false, Some(format!(\"D\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line_out_of_order() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        // intentionally don't push the snippets left to right\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn elide_unnecessary_lines() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-            has type `collections::vec::Vec<i32>`\")));\n-        snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn spans_without_labels() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        for i in 0..4 {\n-            let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-            snippet.push(span_veci, false, None);\n-        }\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_long_selection() {\n-        let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-        let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        snippet.push(splice(fn_span, rbrace_span), false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label2() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label3() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-\n-        let closure_span = {\n-            let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-            let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-            splice(closure_start_span, closure_end_span)\n-        };\n-\n-        let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-        snippet.push(closure_span, false, Some(format!(\"foo\")));\n-        snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_empty() {\n-        // In one of the unit tests, we found that the parser sometimes\n-        // gives empty spans, and in particular it supplied an EOF span\n-        // like this one, which points at the very end. We want to\n-        // fallback gracefully in this case.\n-\n-        let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-        rbrace_span.lo = rbrace_span.hi;\n-\n-        let mut snippet = SnippetData::new(cm.clone(),\n-                                           Some(rbrace_span),\n-                                           FormatMode::NewErrorFormat);\n-        snippet.push(rbrace_span, false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n-\"#[1..]);\n-    }\n }"}, {"sha": "ca2be89def0f17c4176967c0d728de5556ee7e9d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -816,6 +816,12 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n                       -> Option<(InternedString, ast::StrStyle)> {\n+    // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n+    let expr = expr.map(|mut expr| {\n+        expr.span.expn_id = cx.backtrace;\n+        expr\n+    });\n+\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {"}, {"sha": "18342f2e38c1be8c51be9d662fed96c24ef83e7a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -9,20 +9,19 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n-use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n+use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n use ast;\n-use attr::HasAttrs;\n-use ext::mtwt;\n-use attr;\n+use ext::hygiene::Mark;\n+use attr::{self, HasAttrs};\n use attr::AttrMetaMethods;\n-use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::token::{fresh_mark, intern, keywords};\n+use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -130,9 +129,9 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     // It would almost certainly be cleaner to pass the whole macro invocation in,\n     // rather than pulling it apart and marking the tts and the ctxt separately.\n     let Mac_ { path, tts, .. } = mac.node;\n-    let mark = fresh_mark();\n+    let mark = Mark::fresh();\n \n-    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mrk,\n+    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mark,\n                       attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n                       -> Option<Box<MacResult + 'a>> {\n         // Detect use of feature-gated or invalid attributes on macro invoations\n@@ -708,30 +707,17 @@ pub fn expand_crate(mut cx: ExtCtxt,\n     return (ret, cx.syntax_env.names);\n }\n \n-// HYGIENIC CONTEXT EXTENSION:\n-// all of these functions are for walking over\n-// ASTs and making some change to the context of every\n-// element that has one. a CtxtFn is a trait-ified\n-// version of a closure in (SyntaxContext -> SyntaxContext).\n-// the ones defined here include:\n-// Marker - add a mark to a context\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n-struct Marker { mark: Mrk, expn_id: Option<ExpnId> }\n+struct Marker { mark: Mark, expn_id: Option<ExpnId> }\n \n impl Folder for Marker {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(self.mark, id.ctxt))\n-    }\n-    fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n-        Spanned {\n-            node: Mac_ {\n-                path: self.fold_path(node.path),\n-                tts: self.fold_tts(&node.tts),\n-            },\n-            span: self.new_span(span),\n-        }\n+    fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n+        ident.ctxt = ident.ctxt.apply_mark(self.mark);\n+        ident\n+    }\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        noop_fold_mac(mac, self)\n     }\n \n     fn new_span(&mut self, mut span: Span) -> Span {\n@@ -743,7 +729,7 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n+fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n "}, {"sha": "ade165e0ef9c896b9ab607e523d1d11cfc23324b", "filename": "src/libsyntax/ext/hygiene.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Machinery for hygienic macros, inspired by the MTWT[1] paper.\n+//!\n+//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n+//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n+//! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n+//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n+\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::fmt;\n+\n+/// A SyntaxContext represents a chain of macro expansions (represented by marks).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Default)]\n+pub struct SyntaxContext(u32);\n+\n+#[derive(Copy, Clone)]\n+pub struct SyntaxContextData {\n+    pub outer_mark: Mark,\n+    pub prev_ctxt: SyntaxContext,\n+}\n+\n+/// A mark represents a unique id associated with a macro expansion.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n+pub struct Mark(u32);\n+\n+impl Mark {\n+    pub fn fresh() -> Self {\n+        HygieneData::with(|data| {\n+            let next_mark = Mark(data.next_mark.0 + 1);\n+            ::std::mem::replace(&mut data.next_mark, next_mark)\n+        })\n+    }\n+}\n+\n+struct HygieneData {\n+    syntax_contexts: Vec<SyntaxContextData>,\n+    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    next_mark: Mark,\n+}\n+\n+impl HygieneData {\n+    fn new() -> Self {\n+        HygieneData {\n+            syntax_contexts: vec![SyntaxContextData {\n+                outer_mark: Mark(0), // the null mark\n+                prev_ctxt: SyntaxContext(0), // the empty context\n+            }],\n+            markings: HashMap::new(),\n+            next_mark: Mark(1),\n+        }\n+    }\n+\n+    fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n+        thread_local! {\n+            static HYGIENE_DATA: RefCell<HygieneData> = RefCell::new(HygieneData::new());\n+        }\n+        HYGIENE_DATA.with(|data| f(&mut *data.borrow_mut()))\n+    }\n+}\n+\n+pub fn reset_hygiene_data() {\n+    HygieneData::with(|data| *data = HygieneData::new())\n+}\n+\n+impl SyntaxContext {\n+    pub const fn empty() -> Self {\n+        SyntaxContext(0)\n+    }\n+\n+    pub fn data(self) -> SyntaxContextData {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize])\n+    }\n+\n+    /// Extend a syntax context with a given mark\n+    pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n+        // Applying the same mark twice is a no-op\n+        let ctxt_data = self.data();\n+        if mark == ctxt_data.outer_mark {\n+            return ctxt_data.prev_ctxt;\n+        }\n+\n+        HygieneData::with(|data| {\n+            let syntax_contexts = &mut data.syntax_contexts;\n+            *data.markings.entry((self, mark)).or_insert_with(|| {\n+                syntax_contexts.push(SyntaxContextData {\n+                    outer_mark: mark,\n+                    prev_ctxt: self,\n+                });\n+                SyntaxContext(syntax_contexts.len() as u32 - 1)\n+            })\n+        })\n+    }\n+\n+   /// If `ident` is macro expanded, return the source ident from the macro definition\n+   /// and the mark of the expansion that created the macro definition.\n+   pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n+        let macro_def_ctxt = self.data().prev_ctxt.data();\n+        (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n+   }\n+}\n+\n+impl fmt::Debug for SyntaxContext {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"#{}\", self.0)\n+    }\n+}"}, {"sha": "d2f6df9d5dbd3f1936609ee2b613a257c70fe5eb", "filename": "src/libsyntax/ext/mtwt.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Machinery for hygienic macros, as described in the MTWT[1] paper.\n-//!\n-//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n-//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n-//! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n-//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n-\n-pub use self::SyntaxContext_::*;\n-\n-use ast::{Ident, Mrk, SyntaxContext};\n-\n-use std::cell::RefCell;\n-use std::collections::HashMap;\n-\n-/// The SCTable contains a table of SyntaxContext_'s. It\n-/// represents a flattened tree structure, to avoid having\n-/// managed pointers everywhere (that caused an ICE).\n-/// The `marks` ensures that adding the same mark to the\n-/// same context gives you back the same context as before.\n-pub struct SCTable {\n-    table: RefCell<Vec<SyntaxContext_>>,\n-    marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-}\n-\n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n-pub enum SyntaxContext_ {\n-    EmptyCtxt,\n-    Mark (Mrk,SyntaxContext),\n-}\n-\n-/// Extend a syntax context with a given mark\n-pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| apply_mark_internal(m, ctxt, table))\n-}\n-\n-/// Extend a syntax context with a given mark and sctable (explicit memoization)\n-fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let ctxts = &mut *table.table.borrow_mut();\n-    match ctxts[ctxt.0 as usize] {\n-        // Applying the same mark twice is a no-op.\n-        Mark(outer_mark, prev_ctxt) if outer_mark == m => return prev_ctxt,\n-        _ => *table.marks.borrow_mut().entry((ctxt, m)).or_insert_with(|| {\n-            SyntaxContext(idx_push(ctxts, Mark(m, ctxt)))\n-        }),\n-    }\n-}\n-\n-/// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn with_sctable<T, F>(op: F) -> T where\n-    F: FnOnce(&SCTable) -> T,\n-{\n-    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal());\n-    SCTABLE_KEY.with(move |slot| op(slot))\n-}\n-\n-// Make a fresh syntax context table with EmptyCtxt in slot zero.\n-fn new_sctable_internal() -> SCTable {\n-    SCTable {\n-        table: RefCell::new(vec![EmptyCtxt]),\n-        marks: RefCell::new(HashMap::new()),\n-    }\n-}\n-\n-/// Clear the tables from TLD to reclaim memory.\n-pub fn clear_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = Vec::new();\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n-}\n-\n-/// Reset the tables to their initial state\n-pub fn reset_tables() {\n-    with_sctable(|table| {\n-        *table.table.borrow_mut() = vec![EmptyCtxt];\n-        *table.marks.borrow_mut() = HashMap::new();\n-    });\n-}\n-\n-/// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n-    vec.push(val);\n-    (vec.len() - 1) as u32\n-}\n-\n-/// Return the outer mark for a context with a mark at the outside.\n-/// FAILS when outside is not a mark.\n-pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n-    with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt.0 as usize] {\n-            Mark(mrk, _) => mrk,\n-            _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n-        }\n-    })\n-}\n-\n-/// If `ident` is macro expanded, return the source ident from the macro definition\n-/// and the mark of the expansion that created the macro definition.\n-pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n-    with_sctable(|sctable| {\n-        let ctxts = sctable.table.borrow();\n-        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n-            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n-                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n-            }\n-        }\n-        None\n-    })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ast::{EMPTY_CTXT, Mrk, SyntaxContext};\n-    use super::{apply_mark_internal, new_sctable_internal, Mark, SCTable};\n-\n-    // extend a syntax context with a sequence of marks given\n-    // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n-                    -> SyntaxContext {\n-        mrks.iter().rev().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n-                   {apply_mark_internal(*mrk,tail,table)})\n-    }\n-\n-    #[test] fn unfold_marks_test() {\n-        let mut t = new_sctable_internal();\n-\n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        {\n-            let table = t.table.borrow();\n-            assert!((*table)[1] == Mark(7,EMPTY_CTXT));\n-            assert!((*table)[2] == Mark(3,SyntaxContext(1)));\n-        }\n-    }\n-\n-    #[test]\n-    fn hashing_tests () {\n-        let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n-        // I'm assuming that the rename table will behave the same....\n-    }\n-}"}, {"sha": "a40c30b3e3397fe61d6175a21e5ab9f56bd8bbad", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -22,7 +22,7 @@\n use codemap::CodeMap;\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n use errors::emitter::Emitter;\n \n use std::rc::Rc;\n@@ -53,14 +53,7 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, level: Level) {\n-        let data = Diagnostic::new(span, msg, code, level, self);\n-        if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-\n-    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n         let data = Diagnostic::from_diagnostic_builder(db, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n@@ -146,22 +139,6 @@ struct DiagnosticCode {\n }\n \n impl<'a> Diagnostic<'a> {\n-    fn new(msp: &MultiSpan,\n-           msg: &'a str,\n-           code: Option<&str>,\n-           level: Level,\n-           je: &JsonEmitter)\n-           -> Diagnostic<'a> {\n-        Diagnostic {\n-            message: msg,\n-            code: DiagnosticCode::map_opt_string(code.map(|c| c.to_owned()), je),\n-            level: level.to_str(),\n-            spans: DiagnosticSpan::from_multispan(msp, je),\n-            children: vec![],\n-            rendered: None,\n-        }\n-    }\n-\n     fn from_diagnostic_builder<'c>(db: &'c DiagnosticBuilder,\n                                    je: &JsonEmitter)\n                                    -> Diagnostic<'c> {"}, {"sha": "5ad1744418890b21f46e0b68139f04bf5386ce51", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -127,7 +127,7 @@ pub mod ext {\n     pub mod base;\n     pub mod build;\n     pub mod expand;\n-    pub mod mtwt;\n+    pub mod hygiene;\n     pub mod quote;\n     pub mod source_util;\n "}, {"sha": "2ae3236cd5aa72f818d353cf3e6aa75c722cc255", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -18,23 +18,43 @@ use parse::token;\n use parse::parser::{Parser, TokenType};\n use ptr::P;\n \n+#[derive(PartialEq, Eq, Debug)]\n+enum InnerAttributeParsePolicy<'a> {\n+    Permitted,\n+    NotPermitted { reason: &'a str },\n+}\n+\n+const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &'static str = \"an inner attribute is not \\\n+                                                             permitted in this context\";\n+\n impl<'a> Parser<'a> {\n     /// Parse attributes that appear before an item\n     pub fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n+        let mut just_parsed_doc_comment = false;\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n             match self.token {\n                 token::Pound => {\n-                    attrs.push(self.parse_attribute(false)?);\n+                    let inner_error_reason = if just_parsed_doc_comment {\n+                        \"an inner attribute is not permitted following an outer doc comment\"\n+                    } else if !attrs.is_empty() {\n+                        \"an inner attribute is not permitted following an outer attribute\"\n+                    } else {\n+                        DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n+                    };\n+                    let inner_parse_policy =\n+                        InnerAttributeParsePolicy::NotPermitted { reason: inner_error_reason };\n+                    attrs.push(self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?);\n+                    just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n                     let attr = ::attr::mk_sugared_doc_attr(\n-                    attr::mk_attr_id(),\n-                    self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n-                    self.span.lo,\n-                    self.span.hi\n-                );\n+                        attr::mk_attr_id(),\n+                        self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n+                        self.span.lo,\n+                        self.span.hi\n+                    );\n                     if attr.node.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -43,6 +63,7 @@ impl<'a> Parser<'a> {\n                     }\n                     attrs.push(attr);\n                     self.bump();\n+                    just_parsed_doc_comment = true;\n                 }\n                 _ => break,\n             }\n@@ -55,26 +76,46 @@ impl<'a> Parser<'a> {\n     /// If permit_inner is true, then a leading `!` indicates an inner\n     /// attribute\n     pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n-        debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n+        debug!(\"parse_attribute: permit_inner={:?} self.token={:?}\",\n                permit_inner,\n                self.token);\n+        let inner_parse_policy = if permit_inner {\n+            InnerAttributeParsePolicy::Permitted\n+        } else {\n+            InnerAttributeParsePolicy::NotPermitted\n+                { reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG }\n+        };\n+        self.parse_attribute_with_inner_parse_policy(inner_parse_policy)\n+    }\n+\n+    /// The same as `parse_attribute`, except it takes in an `InnerAttributeParsePolicy`\n+    /// that prescribes how to handle inner attributes.\n+    fn parse_attribute_with_inner_parse_policy(&mut self,\n+                                               inner_parse_policy: InnerAttributeParsePolicy)\n+                                               -> PResult<'a, ast::Attribute> {\n+        debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n+               inner_parse_policy,\n+               self.token);\n         let (span, value, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n                 self.bump();\n \n-                if permit_inner {\n+                if inner_parse_policy == InnerAttributeParsePolicy::Permitted {\n                     self.expected_tokens.push(TokenType::Token(token::Not));\n                 }\n                 let style = if self.token == token::Not {\n                     self.bump();\n-                    if !permit_inner {\n+                    if let InnerAttributeParsePolicy::NotPermitted { reason } = inner_parse_policy\n+                    {\n                         let span = self.span;\n                         self.diagnostic()\n-                            .struct_span_err(span,\n-                                             \"an inner attribute is not permitted in this context\")\n-                            .help(\"place inner attribute at the top of the module or \\\n-                                   block\")\n+                            .struct_span_err(span, reason)\n+                            .note(\"inner attributes and doc comments, like `#![no_std]` or \\\n+                                   `//! My crate`, annotate the item enclosing them, and are \\\n+                                   usually found at the beginning of source files. Outer \\\n+                                   attributes and doc comments, like `#[test]` and\n+                                   `/// My function`, annotate the item following them.\")\n                             .emit()\n                     }\n                     ast::AttrStyle::Inner\n@@ -95,7 +136,8 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        if permit_inner && self.token == token::Semi {\n+        if inner_parse_policy == InnerAttributeParsePolicy::Permitted &&\n+           self.token == token::Semi {\n             self.bump();\n             self.span_warn(span,\n                            \"this inner attribute syntax is deprecated. The new syntax is \\"}, {"sha": "5ea1d6be9fec9903b3155b7faf60cafe2efe240d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -1686,7 +1686,7 @@ mod tests {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                 None,\n-                                                cm,\n+                                                Some(cm),\n                                                 errors::snippet::FormatMode::EnvironmentSelected);\n         errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }"}, {"sha": "2147e8ec2eb1f4054ecef0715b4f0ab571786e6f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -50,7 +50,11 @@ pub struct ParseSess {\n impl ParseSess {\n     pub fn new() -> ParseSess {\n         let cm = Rc::new(CodeMap::new());\n-        let handler = Handler::with_tty_emitter(ColorConfig::Auto, None, true, false, cm.clone());\n+        let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                Some(cm.clone()));\n         ParseSess::with_span_handler(handler, cm)\n     }\n \n@@ -224,10 +228,18 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n // compiler expands into it\n pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n                                cfg: ast::CrateConfig,\n-                               tts: Vec<tokenstream::TokenTree>) -> Parser<'a> {\n+                               tts: Vec<tokenstream::TokenTree>)\n+                               -> Parser<'a> {\n     tts_to_parser(sess, tts, cfg)\n }\n \n+pub fn new_parser_from_ts<'a>(sess: &'a ParseSess,\n+                              cfg: ast::CrateConfig,\n+                              ts: tokenstream::TokenStream)\n+                              -> Parser<'a> {\n+    tts_to_parser(sess, ts.tts, cfg)\n+}\n+\n \n // base abstractions\n "}, {"sha": "125f1abb062bf2966b17a31cb428edd4a8fe6620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 49, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -3789,13 +3789,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    ///\n-    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n-    /// ```rust\n-    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n-    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_())\n+        Ok(self.parse_stmt_(true))\n     }\n \n     // Eat tokens until we can be relatively sure we reached the end of the\n@@ -3859,15 +3854,15 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_stmt_(&mut self) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+    fn parse_stmt_(&mut self, macro_expanded: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_expanded).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break);\n             None\n         })\n     }\n \n-    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = self.parse_outer_attributes()?;\n@@ -3930,10 +3925,34 @@ impl<'a> Parser<'a> {\n \n             if id.name == keywords::Invalid.name() {\n                 let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                let node = if delim == token::Brace ||\n+                              self.token == token::Semi || self.token == token::Eof {\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                }\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                else if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                } else {\n+                    let e = self.mk_mac_expr(lo, hi, mac.node, ThinVec::new());\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    StmtKind::Expr(e)\n+                };\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Mac(P((mac, style, attrs.into()))),\n                     span: mk_sp(lo, hi),\n+                    node: node,\n                 }\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -4061,49 +4080,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n-    /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n     pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n-        let mut stmt = match self.parse_stmt_() {\n+        let mut stmt = match self.parse_stmt_(macro_expanded) {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };\n \n-        if let StmtKind::Mac(mac) = stmt.node {\n-            if mac.1 != MacStmtStyle::NoBraces ||\n-               self.token == token::Semi || self.token == token::Eof {\n-                stmt.node = StmtKind::Mac(mac);\n-            } else {\n-                // We used to incorrectly stop parsing macro-expanded statements here.\n-                // If the next token will be an error anyway but could have parsed with the\n-                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                if macro_expanded && self.token.can_begin_expr() && match self.token {\n-                    // These tokens can continue an expression, so we can't stop parsing and warn.\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                    token::BinOp(token::And) | token::BinOp(token::Or) |\n-                    token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot => false,\n-                    _ => true,\n-                } {\n-                    self.warn_missing_semicolon();\n-                    stmt.node = StmtKind::Mac(mac);\n-                    return Ok(Some(stmt));\n-                }\n-\n-                let (mac, _style, attrs) = mac.unwrap();\n-                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n-                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                stmt.node = StmtKind::Expr(e);\n-            }\n-        }\n-\n-        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n-        Ok(Some(stmt))\n-    }\n-\n-    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n-                                 -> PResult<'a, Stmt> {\n         match stmt.node {\n             StmtKind::Expr(ref expr) if self.token != token::Eof => {\n                 // expression without semicolon\n@@ -4133,7 +4115,7 @@ impl<'a> Parser<'a> {\n         }\n \n         stmt.span.hi = self.last_span.hi;\n-        Ok(stmt)\n+        Ok(Some(stmt))\n     }\n \n     fn warn_missing_semicolon(&self) {"}, {"sha": "f0a6f8edeec73a241622a50a937b604c5896c6bd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -633,8 +633,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n     /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n     gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n-\n-// create a fresh mark.\n-pub fn fresh_mark() -> ast::Mrk {\n-    gensym(\"mark\").0\n-}"}, {"sha": "faf6a17a150459fb62cd380b952340d5b90b12d5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -26,7 +26,7 @@ use std::rc::Rc;\n \n use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n use errors;\n-use errors::snippet::{RenderedLine, SnippetData};\n+use errors::snippet::{SnippetData};\n use config;\n use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, DummyMacroLoader};"}, {"sha": "7dfe19452a2a933a64cdd849e2a21ce535880f50", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -568,7 +568,7 @@ impl Sub for CharPos {\n //\n \n /// A source code location used for error reporting\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n     pub file: Rc<FileMap>,"}, {"sha": "be7e78200204842cb37388a1c84ecf0f9eeb19d5", "filename": "src/test/compile-fail/issue-34839.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fissue-34839.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fissue-34839.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34839.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait RegularExpression: Sized {\n+    type Text;\n+}\n+\n+struct ExecNoSyncStr<'a>(&'a u8);\n+\n+impl<'c> RegularExpression for ExecNoSyncStr<'c> {\n+    type Text = u8;\n+}\n+\n+struct FindCaptures<'t, R>(&'t R::Text) where R: RegularExpression, R::Text: 't;\n+\n+enum FindCapturesInner<'r, 't> {\n+    Dynamic(FindCaptures<'t, ExecNoSyncStr<'r>>),\n+}\n+\n+#[rustc_error]\n+fn main() {}    //~ ERROR compilation successful"}, {"sha": "888bdf5179a23fe26637ba0c4a2c7ecc451b36a8", "filename": "src/test/compile-fail/macro-expanded-include/foo/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ffoo%2Fmod.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -13,3 +13,7 @@\n macro_rules! m {\n     () => { include!(\"file.txt\"); }\n }\n+\n+macro_rules! n {\n+    () => { unsafe { asm!(include_str!(\"file.txt\")); } }\n+}"}, {"sha": "e1e85ddb2c1b18a145f6852ddd34e6e0b1a0f8f9", "filename": "src/test/compile-fail/macro-expanded-include/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expanded-include%2Ftest.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n+#![feature(asm, rustc_attrs)]\n+#![allow(unused)]\n \n #[macro_use]\n mod foo;\n \n m!();\n+fn f() { n!(); }\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful"}, {"sha": "8f46d3301eb370a411d94ec078340841a89e3eb1", "filename": "src/test/compile-fail/macro-stmt-matchers.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    macro_rules! m { ($s:stmt;) => { $s } }\n+    m!(vec![].push(0););\n+}"}, {"sha": "390b8f07b2fbd97436e3ea304c5adb5ede0c4f21", "filename": "src/test/compile-fail/method-suggestion-no-duplication.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -18,7 +18,8 @@ fn foo<F>(f: F) where F: FnMut(Foo) {}\n fn main() {\n     foo(|s| s.is_empty());\n     //~^ ERROR no method named `is_empty` found\n-    //~^^ HELP #1: `core::slice::SliceExt`\n-    //~^^^ HELP #2: `core::str::StrExt`\n-    //~^^^^ HELP items from traits can only be used if the trait is implemented and in scope; the following traits define an item `is_empty`, perhaps you need to implement one of them:\n+    //~^^ HELP #1: `std::iter::ExactSizeIterator`\n+    //~^^^ HELP #2: `core::slice::SliceExt`\n+    //~^^^^ HELP #3: `core::str::StrExt`\n+    //~^^^^^ HELP items from traits can only be used if the trait is implemented and in scope; the following traits define an item `is_empty`, perhaps you need to implement one of them:\n }"}, {"sha": "687cdba1542bdce4c9be2889ac2bd453bb5f7da9", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -31,6 +31,6 @@ use use_from_trait_xc::Bar::new as bnew;\n //~^ ERROR unresolved import `use_from_trait_xc::Bar::new`\n \n use use_from_trait_xc::Baz::new as baznew;\n-//~^ ERROR `baznew` is not directly importable\n+//~^ ERROR unresolved import `use_from_trait_xc::Baz::new`\n \n fn main() {}"}, {"sha": "ed8342d9f5aaf80857eff924305ecac02769c589", "filename": "src/test/parse-fail/inner-attr-after-doc-comment.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fparse-fail%2Finner-attr-after-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fparse-fail%2Finner-attr-after-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Finner-attr-after-doc-comment.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#![feature(lang_items)]\n+/**\n+ * My module\n+ */\n+\n+#![recursion_limit=\"100\"]\n+//~^ ERROR an inner attribute is not permitted following an outer doc comment\n+fn main() {}"}, {"sha": "8cebda6644565c8b0d79f879d77d464a8aa05729", "filename": "src/test/parse-fail/inner-attr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fparse-fail%2Finner-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fparse-fail%2Finner-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Finner-attr.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#[feature(lang_items)]\n+\n+#![recursion_limit=\"100\"] //~ ERROR an inner attribute is not permitted following an outer attribute\n+fn main() {}"}, {"sha": "c78a586763429ebc12e5e5417edc859015036ef5", "filename": "src/test/ui/codemap_tests/empty_span.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#![feature(optin_builtin_traits)]\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo { }\n+}"}, {"sha": "f3e04ef02409b86af8f99f942db21804f974d864", "filename": "src/test/ui/codemap_tests/empty_span.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,8 @@\n+error[E0321]: cross-crate traits with a default impl, like `std::marker::Send`, can only be implemented for a struct/enum type, not `&'static main::Foo`\n+  --> $DIR/empty_span.rs:18:5\n+   |\n+18 |     unsafe impl Send for &'static Foo { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b06832c7628ed9f4df3c92aa4d5256020683c394", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let x = \"foo\";\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    let y = &mut x;\n+}\n+\n+\n+"}, {"sha": "6a898a434778e2af416723401227d83f02bc805e", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,11 @@\n+error: cannot borrow immutable local variable `x` as mutable\n+   --> $DIR/huge_multispan_highlight.rs:100:18\n+    |\n+14  |     let x = \"foo\";\n+    |         - use `mut x` here to make mutable\n+...\n+100 |     let y = &mut x;\n+    |                  ^ cannot borrow mutably\n+\n+error: aborting due to previous error\n+"}, {"sha": "7ea497a25c8321f81aac9ecf610a8e036d306ae7", "filename": "src/test/ui/codemap_tests/issue-11715.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+fn main() {\n+    let mut x = \"foo\";\n+    let y = &mut x;\n+    let z = &mut x;\n+}\n+\n+\n+"}, {"sha": "4947cbedd200e45ec424e508881480505c313b57", "filename": "src/test/ui/codemap_tests/issue-11715.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,12 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+   --> $DIR/issue-11715.rs:100:18\n+    |\n+99  |     let y = &mut x;\n+    |                  - first mutable borrow occurs here\n+100 |     let z = &mut x;\n+    |                  ^ second mutable borrow occurs here\n+101 | }\n+    | - first borrow ends here\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a5ee6f8711ef92846a867bce0cb20fbabbcb94a", "filename": "src/test/ui/codemap_tests/one_line.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let mut v = vec![Some(\"foo\"), Some(\"bar\")];\n+    v.push(v.pop().unwrap());\n+}"}, {"sha": "8f80489ea1aeb02539dc589d40bc4c4dc1b1a630", "filename": "src/test/ui/codemap_tests/one_line.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,11 @@\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/one_line.rs:15:12\n+   |\n+15 |     v.push(v.pop().unwrap());\n+   |     -      ^               - first borrow ends here\n+   |     |      |\n+   |     |      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a90852392c081263c56f81c48c3b368e9e6bc24", "filename": "src/test/ui/codemap_tests/overlapping_spans.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#[derive(Debug)]\n+struct Foo { }\n+\n+struct S {f:String}\n+impl Drop for S {\n+    fn drop(&mut self) { println!(\"{}\", self.f); }\n+}\n+\n+fn main() {\n+    match (S {f:\"foo\".to_string()}) {\n+        S {f:_s} => {}\n+    }\n+}"}, {"sha": "cbcf154eaba50d79473f4a103ab3feb145e52614", "filename": "src/test/ui/codemap_tests/overlapping_spans.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,11 @@\n+error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n+  --> $DIR/overlapping_spans.rs:22:9\n+   |\n+22 |         S {f:_s} => {}\n+   |         ^^^^^--^\n+   |         |    |\n+   |         |    hint: to prevent move, use `ref _s` or `ref mut _s`\n+   |         cannot move out of here\n+\n+error: aborting due to previous error\n+"}, {"sha": "aaaee8c5577fe02700876f1d659f324215c55e19", "filename": "src/test/ui/codemap_tests/tab.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-tidy-tab\n+fn main() {\n+\tbar;\n+}\n+"}, {"sha": "543c02fb701f35507034ad505ca50eac76cd3fa0", "filename": "src/test/ui/codemap_tests/tab.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,8 @@\n+error[E0425]: unresolved name `bar`\n+  --> $DIR/tab.rs:14:2\n+   |\n+14 | \\tbar;\n+   | \\t^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "53e240e8c4738ca494e26fffa9d31891955e3f5e", "filename": "src/test/ui/codemap_tests/two_files.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+include!(\"two_files_data.rs\");\n+\n+struct Baz { }\n+\n+impl Bar for Baz { }\n+\n+fn main() { }"}, {"sha": "6c388cd69395b272b7dc7d224e8a1b9ac708d09d", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,13 @@\n+error[E0404]: `Bar` is not a trait\n+  --> $DIR/two_files.rs:16:6\n+   |\n+16 | impl Bar for Baz { }\n+   |      ^^^ `Bar` is not a trait\n+   | \n+  ::: $DIR/two_files_data.rs\n+   |\n+15 | type Bar = Foo;\n+   | --------------- type aliases cannot be used for traits\n+\n+error: cannot continue compilation due to previous error\n+"}, {"sha": "412c40f8e811b9e52d54a41f35c4af45371cc213", "filename": "src/test/ui/codemap_tests/two_files_data.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-test\n+trait Foo { }\n+\n+type Bar = Foo;\n+"}, {"sha": "19660133d62228b861c0ba3a6acc0c01bf26f00e", "filename": "src/test/ui/codemap_tests/unicode.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n+\n+fn main() { }"}, {"sha": "178bee7b7f3ab62b388532eecadba7ae57bd0bb9", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -0,0 +1,8 @@\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+  --> $DIR/unicode.rs:12:8\n+   |\n+12 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n+   |        ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ff6920d28ccf90a3647df517a6d4dae074feecdd", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -1,15 +1,16 @@\n-error: mismatched types [--explain E0308]\n+error[E0308]: mismatched types\n   --> $DIR/issue-26480.rs:27:19\n-   |>\n-27 |>                   $arr.len() * size_of($arr[0]));\n-   |>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n-$DIR/issue-26480.rs:38:5: 38:19: note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n+   |\n+27 |                   $arr.len() * size_of($arr[0]));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n+$DIR/issue-26480.rs:38:5: 38:19 note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n \n error: non-scalar cast: `_` as `()`\n   --> $DIR/issue-26480.rs:33:19\n-   |>\n-33 |>     ($x:expr) => ($x as ())\n-   |>                   ^^^^^^^^\n-$DIR/issue-26480.rs:39:5: 39:14: note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n+   |\n+33 |     ($x:expr) => ($x as ())\n+   |                   ^^^^^^^^\n+$DIR/issue-26480.rs:39:5: 39:14 note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n \n error: aborting due to 2 previous errors\n+"}, {"sha": "2903aa08c0a91e744d5ff55bb56028104121df10", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79358aa52329ed6dc67f0b2c0afa2a2692d404af/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=79358aa52329ed6dc67f0b2c0afa2a2692d404af", "patch": "@@ -1,9 +1,11 @@\n-error: mismatched types [--explain E0308]\n+error[E0308]: mismatched types\n   --> $DIR/main.rs:14:18\n-   |>\n-14 |>     let x: u32 = (\n-   |>                  ^ expected u32, found ()\n-note: expected type `u32`\n-note:    found type `()`\n+   |\n+14 |     let x: u32 = (\n+   |                  ^ expected u32, found ()\n+   |\n+   = note: expected type `u32`\n+   = note:    found type `()`\n \n error: aborting due to previous error\n+"}]}