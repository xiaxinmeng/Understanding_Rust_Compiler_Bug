{"sha": "b4ed6f969592595cf821bf9f72b015185a56b4f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZWQ2Zjk2OTU5MjU5NWNmODIxYmY5ZjcyYjAxNTE4NWE1NmI0ZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T02:41:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T02:41:35Z"}, "message": "auto merge of #10927 : g3xzh/rust/sum_bugfix, r=huonw\n\n`[1e20, 1.0, -1e20].sum()` returns `0.0`. This happens because during\r\nthe summation, `1.0` is too small relative to `1e20`, making it\r\nnegligible.\r\n\r\nI have tried Kahan summation but it hasn't fixed the problem.\r\nTherefore, I've used Python's `fsum()` implementation.\r\nFor more details, read:\r\nwww.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\r\nhttps://github.com/mozilla/rust/issues/10851\r\n\r\nPython's fsum (msum)\r\nhttp://code.activestate.com/recipes/393090/\r\n\r\n@huonw, your feedback is more than welcome.\r\nIt looks unpolished; Do you have suggestions how to make it more beautiful and elegant?\r\n\r\nThanks in advance,", "tree": {"sha": "2fc477e92708e68fca4d3555c70bb1c5efcfbc38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc477e92708e68fca4d3555c70bb1c5efcfbc38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4ed6f969592595cf821bf9f72b015185a56b4f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ed6f969592595cf821bf9f72b015185a56b4f0", "html_url": "https://github.com/rust-lang/rust/commit/b4ed6f969592595cf821bf9f72b015185a56b4f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4ed6f969592595cf821bf9f72b015185a56b4f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c2c13bae4783c808f6640286d41cba6d9394dd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c2c13bae4783c808f6640286d41cba6d9394dd9", "html_url": "https://github.com/rust-lang/rust/commit/3c2c13bae4783c808f6640286d41cba6d9394dd9"}, {"sha": "05395cba88580db10455952706cd8ae292fdbbe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/05395cba88580db10455952706cd8ae292fdbbe7", "html_url": "https://github.com/rust-lang/rust/commit/05395cba88580db10455952706cd8ae292fdbbe7"}], "stats": {"total": 67, "additions": 66, "deletions": 1}, "files": [{"sha": "07fb7ae96c7466a6eddbc3d8504b5ca98a7a316d", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b4ed6f969592595cf821bf9f72b015185a56b4f0/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ed6f969592595cf821bf9f72b015185a56b4f0/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=b4ed6f969592595cf821bf9f72b015185a56b4f0", "patch": "@@ -15,6 +15,7 @@ use std::cmp;\n use std::hashmap;\n use std::io;\n use std::num;\n+use std::util;\n \n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n@@ -23,6 +24,12 @@ use std::num;\n pub trait Stats {\n \n     /// Sum of the samples.\n+    ///\n+    /// Note: this method sacrifices performance at the altar of accuracy\n+    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n+    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n+    /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n+    /// *Discrete & Computational Geometry 18*, 3 (Oct 1997), 305-363, Shewchuk J.R.\n     fn sum(self) -> f64;\n \n     /// Minimum value of the samples.\n@@ -142,8 +149,37 @@ impl Summary {\n \n impl<'a> Stats for &'a [f64] {\n \n+    // FIXME #11059 handle NaN, inf and overflow\n     fn sum(self) -> f64 {\n-        self.iter().fold(0.0, |p,q| p + *q)\n+        let mut partials : ~[f64] = ~[];\n+\n+        for &mut x in self.iter() {\n+            let mut j = 0;\n+            // This inner loop applies `hi`/`lo` summation to each\n+            // partial so that the list of partial sums remains exact.\n+            for i in range(0, partials.len()) {\n+                let mut y = partials[i];\n+                if num::abs(x) < num::abs(y) {\n+                    util::swap(&mut x, &mut y);\n+                }\n+                // Rounded `x+y` is stored in `hi` with round-off stored in\n+                // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n+                let hi = x + y;\n+                let lo = y - (hi - x);\n+                if lo != 0f64 {\n+                    partials[j] = lo;\n+                    j += 1;\n+                }\n+                x = hi;\n+            }\n+            if j >= partials.len() {\n+                partials.push(x);\n+            } else {\n+                partials[j] = x;\n+                partials.truncate(j+1);\n+            }\n+        }\n+        partials.iter().fold(0.0, |p, q| p + *q)\n     }\n \n     fn min(self) -> f64 {\n@@ -950,5 +986,34 @@ mod tests {\n         t(&Summary::new([-2.0, 0.0]), ~\"-2 |[------******#******---]| 0\");\n \n     }\n+    #[test]\n+    fn test_sum_f64s() {\n+        assert_eq!([0.5, 3.2321, 1.5678].sum(), 5.2999);\n+    }\n+    #[test]\n+    fn test_sum_f64_between_ints_that_sum_to_0() {\n+        assert_eq!([1e30, 1.2, -1e30].sum(), 1.2);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use std::vec;\n+\n+    #[bench]\n+    fn sum_three_items(bh: &mut BenchHarness) {\n+        bh.iter(|| {\n+            [1e20, 1.5, -1e20].sum();\n+        })\n+    }\n+    #[bench]\n+    fn sum_many_f64(bh: &mut BenchHarness) {\n+        let nums = [-1e30, 1e60, 1e30, 1.0, -1e60];\n+        let v = vec::from_fn(500, |i| nums[i%5]);\n \n+        bh.iter(|| {\n+            v.sum();\n+        })\n+    }\n }"}]}