{"sha": "d3872964f88a0d751c428c150bb40d8b4f4c89a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzODcyOTY0Zjg4YTBkNzUxYzQyOGMxNTBiYjQwZDhiNGY0Yzg5YTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-05T14:54:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-05T14:54:25Z"}, "message": "Merge #1960\n\n1960: Replace AST visitors with macro r=viorina a=viorina\n\nFixes #1672.\n\nCo-authored-by: Ekaterina Babshukova <ekaterina.babshukova@yandex.ru>", "tree": {"sha": "14b7045119a1918118c18857cc094c914284705c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14b7045119a1918118c18857cc094c914284705c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3872964f88a0d751c428c150bb40d8b4f4c89a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdmK6hCRBK7hj4Ov3rIwAAdHIIAIT/Dbe3RvBYyLd/yxzuwBCc\nlXEhD6TM38YVSBSPYcTbyoxc/uMdnqxSD+YdfsIu1lcdPJIFsh8b4iFEnDE7VWqH\nQ7DqM3qLDjvpDU09R5v8H3PnOlIxMnCHIDhjO82Lm6vl/3Mu0I0KCabb6PqqFqJ8\nlINulkJWqGdE3vXJdZZFhKrp2nS9OYi0hRDRvHv128g6ujIjqSBYtjpA123emSlu\nMj0/qFsxGzMbvqdW1xXTFHJq7xJ9U6Lv+awInKQkQu5DI991k29skJqdwLAuLQb9\nepiMHWQZvLzXCR0xn61TmnBpqc2SDPkJ+B5q65CYiUiAYZlopp43gclTG6zIBg8=\n=1ddO\n-----END PGP SIGNATURE-----\n", "payload": "tree 14b7045119a1918118c18857cc094c914284705c\nparent ae6305b90c80eb919cfde985cba66975b6222ed2\nparent 311dbb854536dd526cdbcadc6d270f9a37e4b816\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1570287265 +0000\ncommitter GitHub <noreply@github.com> 1570287265 +0000\n\nMerge #1960\n\n1960: Replace AST visitors with macro r=viorina a=viorina\n\nFixes #1672.\n\nCo-authored-by: Ekaterina Babshukova <ekaterina.babshukova@yandex.ru>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3872964f88a0d751c428c150bb40d8b4f4c89a9", "html_url": "https://github.com/rust-lang/rust/commit/d3872964f88a0d751c428c150bb40d8b4f4c89a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3872964f88a0d751c428c150bb40d8b4f4c89a9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae6305b90c80eb919cfde985cba66975b6222ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6305b90c80eb919cfde985cba66975b6222ed2", "html_url": "https://github.com/rust-lang/rust/commit/ae6305b90c80eb919cfde985cba66975b6222ed2"}, {"sha": "311dbb854536dd526cdbcadc6d270f9a37e4b816", "url": "https://api.github.com/repos/rust-lang/rust/commits/311dbb854536dd526cdbcadc6d270f9a37e4b816", "html_url": "https://github.com/rust-lang/rust/commit/311dbb854536dd526cdbcadc6d270f9a37e4b816"}], "stats": {"total": 778, "additions": 349, "deletions": 429}, "files": [{"sha": "fe3e64af50e060d747e4e7f190510ad064497556", "filename": "crates/ra_assists/src/assists/split_import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -51,13 +51,13 @@ mod tests {\n     fn split_import_works_with_trees() {\n         check_assist(\n             split_import,\n-            \"use algo:<|>:visitor::{Visitor, visit}\",\n-            \"use algo::{<|>visitor::{Visitor, visit}}\",\n+            \"use crate:<|>:db::{RootDatabase, FileSymbol}\",\n+            \"use crate::{<|>db::{RootDatabase, FileSymbol}}\",\n         )\n     }\n \n     #[test]\n     fn split_import_target() {\n-        check_assist_target(split_import, \"use algo::<|>visitor::{Visitor, visit}\", \"::\");\n+        check_assist_target(split_import, \"use crate::<|>db::{RootDatabase, FileSymbol}\", \"::\");\n     }\n }"}, {"sha": "3e936e3ecbde65ed9894a3452c5f2552f701d00b", "filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -1,9 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast, AstNode,\n-};\n+use ra_syntax::{ast, match_ast, AstNode};\n use rustc_hash::FxHashMap;\n \n use crate::completion::{CompletionContext, CompletionItem, CompletionKind, Completions};\n@@ -19,10 +16,13 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n \n     let mut params = FxHashMap::default();\n     for node in ctx.token.parent().ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::SourceFile, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(&node);\n+        match_ast! {\n+            match node {\n+                ast::SourceFile(it) => { process(it, &mut params) },\n+                ast::ItemList(it) => { process(it, &mut params) },\n+                _ => (),\n+            }\n+        }\n     }\n     params\n         .into_iter()"}, {"sha": "48c688a08a4cd25e53400275cfa33f860743a17e", "filename": "crates/ra_ide_api/src/completion/complete_keyword.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -1,9 +1,8 @@\n //! FIXME: write short doc here\n \n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     ast::{self, LoopBodyOwner},\n-    AstNode,\n+    match_ast, AstNode,\n     SyntaxKind::*,\n     SyntaxToken,\n };\n@@ -84,12 +83,15 @@ fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n         if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n             break;\n         }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(|it| it.loop_body())\n-            .visit::<ast::WhileExpr, _>(|it| it.loop_body())\n-            .visit::<ast::LoopExpr, _>(|it| it.loop_body())\n-            .accept(&node);\n-        if let Some(Some(body)) = loop_body {\n+        let loop_body = match_ast! {\n+            match node {\n+                ast::ForExpr(it) => { it.loop_body() },\n+                ast::WhileExpr(it) => { it.loop_body() },\n+                ast::LoopExpr(it) => { it.loop_body() },\n+                _ => None,\n+            }\n+        };\n+        if let Some(body) = loop_body {\n             if leaf.text_range().is_subrange(&body.syntax().text_range()) {\n                 return true;\n             }"}, {"sha": "d0b1a8a2a7fd38d1cf69ff415bbb65f1db23a90c", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -3,9 +3,8 @@\n use hir::{AssocItem, FieldSource, HasSource, ModuleSource};\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     ast::{self, DocCommentsOwner},\n-    AstNode, AstPtr, SmolStr,\n+    match_ast, AstNode, AstPtr, SmolStr,\n     SyntaxKind::{self, NAME},\n     SyntaxNode, TextRange,\n };\n@@ -308,19 +307,22 @@ pub(crate) fn docs_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax());\n \n-    visitor()\n-        .visit(|it: ast::FnDef| it.doc_comment_text())\n-        .visit(|it: ast::StructDef| it.doc_comment_text())\n-        .visit(|it: ast::EnumDef| it.doc_comment_text())\n-        .visit(|it: ast::TraitDef| it.doc_comment_text())\n-        .visit(|it: ast::Module| it.doc_comment_text())\n-        .visit(|it: ast::TypeAliasDef| it.doc_comment_text())\n-        .visit(|it: ast::ConstDef| it.doc_comment_text())\n-        .visit(|it: ast::StaticDef| it.doc_comment_text())\n-        .visit(|it: ast::RecordFieldDef| it.doc_comment_text())\n-        .visit(|it: ast::EnumVariant| it.doc_comment_text())\n-        .visit(|it: ast::MacroCall| it.doc_comment_text())\n-        .accept(&node)?\n+    match_ast! {\n+        match node {\n+            ast::FnDef(it) => { it.doc_comment_text() },\n+            ast::StructDef(it) => { it.doc_comment_text() },\n+            ast::EnumDef(it) => { it.doc_comment_text() },\n+            ast::TraitDef(it) => { it.doc_comment_text() },\n+            ast::Module(it) => { it.doc_comment_text() },\n+            ast::TypeAliasDef(it) => { it.doc_comment_text() },\n+            ast::ConstDef(it) => { it.doc_comment_text() },\n+            ast::StaticDef(it) => { it.doc_comment_text() },\n+            ast::RecordFieldDef(it) => { it.doc_comment_text() },\n+            ast::EnumVariant(it) => { it.doc_comment_text() },\n+            ast::MacroCall(it) => { it.doc_comment_text() },\n+            _ => None,\n+        }\n+    }\n }\n \n /// Get a description of a symbol.\n@@ -330,16 +332,19 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax());\n \n-    visitor()\n-        .visit(|node: ast::FnDef| node.short_label())\n-        .visit(|node: ast::StructDef| node.short_label())\n-        .visit(|node: ast::EnumDef| node.short_label())\n-        .visit(|node: ast::TraitDef| node.short_label())\n-        .visit(|node: ast::Module| node.short_label())\n-        .visit(|node: ast::TypeAliasDef| node.short_label())\n-        .visit(|node: ast::ConstDef| node.short_label())\n-        .visit(|node: ast::StaticDef| node.short_label())\n-        .visit(|node: ast::RecordFieldDef| node.short_label())\n-        .visit(|node: ast::EnumVariant| node.short_label())\n-        .accept(&node)?\n+    match_ast! {\n+        match node {\n+            ast::FnDef(it) => { it.short_label() },\n+            ast::StructDef(it) => { it.short_label() },\n+            ast::EnumDef(it) => { it.short_label() },\n+            ast::TraitDef(it) => { it.short_label() },\n+            ast::Module(it) => { it.short_label() },\n+            ast::TypeAliasDef(it) => { it.short_label() },\n+            ast::ConstDef(it) => { it.short_label() },\n+            ast::StaticDef(it) => { it.short_label() },\n+            ast::RecordFieldDef(it) => { it.short_label() },\n+            ast::EnumVariant(it) => { it.short_label() },\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "ddd8b7b203d43bf8fcf31a19321896cda7f821cc", "filename": "crates/ra_ide_api/src/display/structure.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -3,9 +3,8 @@\n use crate::TextRange;\n \n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     ast::{self, AttrsOwner, NameOwner, TypeAscriptionOwner, TypeParamsOwner},\n-    AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n+    match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n };\n \n #[derive(Debug, Clone)]\n@@ -101,63 +100,66 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n         })\n     }\n \n-    visitor()\n-        .visit(|fn_def: ast::FnDef| {\n-            let mut detail = String::from(\"fn\");\n-            if let Some(type_param_list) = fn_def.type_param_list() {\n-                collapse_ws(type_param_list.syntax(), &mut detail);\n-            }\n-            if let Some(param_list) = fn_def.param_list() {\n-                collapse_ws(param_list.syntax(), &mut detail);\n-            }\n-            if let Some(ret_type) = fn_def.ret_type() {\n-                detail.push_str(\" \");\n-                collapse_ws(ret_type.syntax(), &mut detail);\n-            }\n-\n-            decl_with_detail(fn_def, Some(detail))\n-        })\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::EnumVariant>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(|td: ast::TypeAliasDef| {\n-            let ty = td.type_ref();\n-            decl_with_type_ref(td, ty)\n-        })\n-        .visit(decl_with_ascription::<ast::RecordFieldDef>)\n-        .visit(decl_with_ascription::<ast::ConstDef>)\n-        .visit(decl_with_ascription::<ast::StaticDef>)\n-        .visit(|im: ast::ImplBlock| {\n-            let target_type = im.target_type()?;\n-            let target_trait = im.target_trait();\n-            let label = match target_trait {\n-                None => format!(\"impl {}\", target_type.syntax().text()),\n-                Some(t) => {\n-                    format!(\"impl {} for {}\", t.syntax().text(), target_type.syntax().text(),)\n+    match_ast! {\n+        match node {\n+            ast::FnDef(it) => {\n+                let mut detail = String::from(\"fn\");\n+                if let Some(type_param_list) = it.type_param_list() {\n+                    collapse_ws(type_param_list.syntax(), &mut detail);\n+                }\n+                if let Some(param_list) = it.param_list() {\n+                    collapse_ws(param_list.syntax(), &mut detail);\n+                }\n+                if let Some(ret_type) = it.ret_type() {\n+                    detail.push_str(\" \");\n+                    collapse_ws(ret_type.syntax(), &mut detail);\n                 }\n-            };\n \n-            let node = StructureNode {\n-                parent: None,\n-                label,\n-                navigation_range: target_type.syntax().text_range(),\n-                node_range: im.syntax().text_range(),\n-                kind: im.syntax().kind(),\n-                detail: None,\n-                deprecated: false,\n-            };\n-            Some(node)\n-        })\n-        .visit(|mc: ast::MacroCall| {\n-            let first_token = mc.syntax().first_token().unwrap();\n-            if first_token.text().as_str() != \"macro_rules\" {\n-                return None;\n-            }\n-            decl(mc)\n-        })\n-        .accept(&node)?\n+                decl_with_detail(it, Some(detail))\n+            },\n+            ast::StructDef(it) => { decl(it) },\n+            ast::EnumDef(it) => { decl(it) },\n+            ast::EnumVariant(it) => { decl(it) },\n+            ast::TraitDef(it) => { decl(it) },\n+            ast::Module(it) => { decl(it) },\n+            ast::TypeAliasDef(it) => {\n+                let ty = it.type_ref();\n+                decl_with_type_ref(it, ty)\n+            },\n+            ast::RecordFieldDef(it) => { decl_with_ascription(it) },\n+            ast::ConstDef(it) => { decl_with_ascription(it) },\n+            ast::StaticDef(it) => { decl_with_ascription(it) },\n+            ast::ImplBlock(it) => {\n+                let target_type = it.target_type()?;\n+                let target_trait = it.target_trait();\n+                let label = match target_trait {\n+                    None => format!(\"impl {}\", target_type.syntax().text()),\n+                    Some(t) => {\n+                        format!(\"impl {} for {}\", t.syntax().text(), target_type.syntax().text(),)\n+                    }\n+                };\n+\n+                let node = StructureNode {\n+                    parent: None,\n+                    label,\n+                    navigation_range: target_type.syntax().text_range(),\n+                    node_range: it.syntax().text_range(),\n+                    kind: it.syntax().kind(),\n+                    detail: None,\n+                    deprecated: false,\n+                };\n+                Some(node)\n+            },\n+            ast::MacroCall(it) => {\n+                let first_token = it.syntax().first_token().unwrap();\n+                if first_token.text().as_str() != \"macro_rules\" {\n+                    return None;\n+                }\n+                decl(it)\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "41a88314fb287e38ae560c325a26c0d2948d82d7", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 95, "deletions": 90, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -2,12 +2,9 @@\n \n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    algo::{\n-        find_node_at_offset,\n-        visit::{visitor, Visitor},\n-    },\n+    algo::find_node_at_offset,\n     ast::{self, DocCommentsOwner},\n-    AstNode, SyntaxNode,\n+    match_ast, AstNode, SyntaxNode,\n };\n \n use crate::{\n@@ -114,91 +111,99 @@ pub(crate) fn name_definition(\n }\n \n fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n-    visitor()\n-        .visit(|node: ast::StructDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::EnumDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::EnumVariant| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::FnDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::TypeAliasDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::ConstDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::StaticDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::TraitDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::RecordFieldDef| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::Module| {\n-            NavigationTarget::from_named(\n-                file_id,\n-                &node,\n-                node.doc_comment_text(),\n-                node.short_label(),\n-            )\n-        })\n-        .visit(|node: ast::MacroCall| {\n-            NavigationTarget::from_named(file_id, &node, node.doc_comment_text(), None)\n-        })\n-        .accept(node)\n+    match_ast! {\n+        match node {\n+            ast::StructDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::EnumDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::EnumVariant(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::FnDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::TypeAliasDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::ConstDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::StaticDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::TraitDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::RecordFieldDef(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::Module(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    it.short_label(),\n+                ))\n+            },\n+            ast::MacroCall(it) => {\n+                Some(NavigationTarget::from_named(\n+                    file_id,\n+                    &it,\n+                    it.doc_comment_text(),\n+                    None,\n+                ))\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "24b161c5c114b04bcbae07ce7349ee3cd7e32019", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -3,12 +3,9 @@\n use hir::{Adt, HasSource, HirDisplay};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    algo::{\n-        ancestors_at_offset, find_covering_element, find_node_at_offset,\n-        visit::{visitor, Visitor},\n-    },\n+    algo::{ancestors_at_offset, find_covering_element, find_node_at_offset},\n     ast::{self, DocCommentsOwner},\n-    AstNode,\n+    match_ast, AstNode,\n };\n \n use crate::{\n@@ -178,37 +175,45 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n     } else if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if let Some(parent) = name.syntax().parent() {\n-            let text = visitor()\n-                .visit(|node: ast::StructDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::EnumDef| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: ast::EnumVariant| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::FnDef| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: ast::TypeAliasDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::ConstDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::StaticDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::TraitDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::RecordFieldDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: ast::Module| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: ast::MacroCall| hover_text(node.doc_comment_text(), None))\n-                .accept(&parent);\n-\n-            if let Some(text) = text {\n-                res.extend(text);\n-            }\n+            let text = match_ast! {\n+                match parent {\n+                    ast::StructDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::EnumDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::EnumVariant(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::FnDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::TypeAliasDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::ConstDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::StaticDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::TraitDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::RecordFieldDef(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::Module(it) => {\n+                        hover_text(it.doc_comment_text(), it.short_label())\n+                    },\n+                    ast::MacroCall(it) => {\n+                        hover_text(it.doc_comment_text(), None)\n+                    },\n+                    _ => None,\n+                }\n+            };\n+            res.extend(text);\n         }\n \n         if !res.is_empty() && range.is_none() {"}, {"sha": "f1c0dc16423cb85a8caf124895c20904da482daf", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -3,9 +3,8 @@\n use crate::{db::RootDatabase, FileId};\n use hir::{HirDisplay, SourceAnalyzer, Ty};\n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     ast::{self, AstNode, TypeAscriptionOwner},\n-    SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n+    match_ast, SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -33,55 +32,58 @@ fn get_inlay_hints(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Vec<InlayHint>> {\n-    visitor()\n-        .visit(|let_statement: ast::LetStmt| {\n-            if let_statement.ascribed_type().is_some() {\n-                return None;\n-            }\n-            let pat = let_statement.pat()?;\n-            let analyzer = SourceAnalyzer::new(db, file_id, let_statement.syntax(), None);\n-            Some(get_pat_type_hints(db, &analyzer, pat, false))\n-        })\n-        .visit(|closure_parameter: ast::LambdaExpr| {\n-            let analyzer = SourceAnalyzer::new(db, file_id, closure_parameter.syntax(), None);\n-            closure_parameter.param_list().map(|param_list| {\n-                param_list\n-                    .params()\n-                    .filter(|closure_param| closure_param.ascribed_type().is_none())\n-                    .filter_map(|closure_param| closure_param.pat())\n-                    .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false))\n-                    .flatten()\n-                    .collect()\n-            })\n-        })\n-        .visit(|for_expression: ast::ForExpr| {\n-            let pat = for_expression.pat()?;\n-            let analyzer = SourceAnalyzer::new(db, file_id, for_expression.syntax(), None);\n-            Some(get_pat_type_hints(db, &analyzer, pat, false))\n-        })\n-        .visit(|if_expr: ast::IfExpr| {\n-            let pat = if_expr.condition()?.pat()?;\n-            let analyzer = SourceAnalyzer::new(db, file_id, if_expr.syntax(), None);\n-            Some(get_pat_type_hints(db, &analyzer, pat, true))\n-        })\n-        .visit(|while_expr: ast::WhileExpr| {\n-            let pat = while_expr.condition()?.pat()?;\n-            let analyzer = SourceAnalyzer::new(db, file_id, while_expr.syntax(), None);\n-            Some(get_pat_type_hints(db, &analyzer, pat, true))\n-        })\n-        .visit(|match_arm_list: ast::MatchArmList| {\n-            let analyzer = SourceAnalyzer::new(db, file_id, match_arm_list.syntax(), None);\n-            Some(\n-                match_arm_list\n-                    .arms()\n-                    .map(|match_arm| match_arm.pats())\n-                    .flatten()\n-                    .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true))\n-                    .flatten()\n-                    .collect(),\n-            )\n-        })\n-        .accept(&node)?\n+    match_ast! {\n+        match node {\n+            ast::LetStmt(it) => {\n+                if it.ascribed_type().is_some() {\n+                    return None;\n+                }\n+                let pat = it.pat()?;\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                Some(get_pat_type_hints(db, &analyzer, pat, false))\n+            },\n+            ast::LambdaExpr(it) => {\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                it.param_list().map(|param_list| {\n+                    param_list\n+                        .params()\n+                        .filter(|closure_param| closure_param.ascribed_type().is_none())\n+                        .filter_map(|closure_param| closure_param.pat())\n+                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, false))\n+                        .flatten()\n+                        .collect()\n+                })\n+            },\n+            ast::ForExpr(it) => {\n+                let pat = it.pat()?;\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                Some(get_pat_type_hints(db, &analyzer, pat, false))\n+            },\n+            ast::IfExpr(it) => {\n+                let pat = it.condition()?.pat()?;\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                Some(get_pat_type_hints(db, &analyzer, pat, true))\n+            },\n+            ast::WhileExpr(it) => {\n+                let pat = it.condition()?.pat()?;\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                Some(get_pat_type_hints(db, &analyzer, pat, true))\n+            },\n+            ast::MatchArmList(it) => {\n+                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n+                Some(\n+                    it\n+                        .arms()\n+                        .map(|match_arm| match_arm.pats())\n+                        .flatten()\n+                        .map(|root_pat| get_pat_type_hints(db, &analyzer, root_pat, true))\n+                        .flatten()\n+                        .collect(),\n+                )\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n fn get_pat_type_hints("}, {"sha": "797e9926f0f0df0de9a0a7144e97c0c8bae2ba20", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -32,9 +32,8 @@ use ra_db::{\n     SourceDatabase, SourceRootId,\n };\n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     ast::{self, NameOwner},\n-    AstNode, Parse, SmolStr, SourceFile,\n+    match_ast, AstNode, Parse, SmolStr, SourceFile,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxNodePtr, TextRange, WalkEvent,\n };\n@@ -306,16 +305,19 @@ fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n \n         Some((name, ptr, name_range))\n     }\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeAliasDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .accept(node)?\n+    match_ast! {\n+        match node {\n+            ast::FnDef(it) => { decl(it) },\n+            ast::StructDef(it) => { decl(it) },\n+            ast::EnumDef(it) => { decl(it) },\n+            ast::TraitDef(it) => { decl(it) },\n+            ast::Module(it) => { decl(it) },\n+            ast::TypeAliasDef(it) => { decl(it) },\n+            ast::ConstDef(it) => { decl(it) },\n+            ast::StaticDef(it) => { decl(it) },\n+            _ => None,\n+        }\n+    }\n }\n \n fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {"}, {"sha": "7cfea70f9791d1a528b06af03fcd3ede4d23aea6", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -1,7 +1,5 @@\n //! FIXME: write short doc here\n \n-pub mod visit;\n-\n use std::ops::RangeInclusive;\n \n use itertools::Itertools;"}, {"sha": "4df275ba4ffc4e127ea88883d4987f8ecf2f715a", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6305b90c80eb919cfde985cba66975b6222ed2/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=ae6305b90c80eb919cfde985cba66975b6222ed2", "patch": "@@ -1,112 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use crate::{AstNode, SyntaxNode};\n-\n-use std::marker::PhantomData;\n-\n-pub fn visitor<'a, T>() -> impl Visitor<'a, Output = T> {\n-    EmptyVisitor { ph: PhantomData }\n-}\n-\n-pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output = T, Ctx = C> {\n-    EmptyVisitorCtx { ph: PhantomData, ctx }\n-}\n-\n-pub trait Visitor<'a>: Sized {\n-    type Output;\n-    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output>;\n-    fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n-    where\n-        N: AstNode + 'a,\n-        F: FnOnce(N) -> Self::Output,\n-    {\n-        Vis { inner: self, f, ph: PhantomData }\n-    }\n-}\n-\n-pub trait VisitorCtx<'a>: Sized {\n-    type Output;\n-    type Ctx;\n-    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx>;\n-    fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n-    where\n-        N: AstNode + 'a,\n-        F: FnOnce(N, Self::Ctx) -> Self::Output,\n-    {\n-        VisCtx { inner: self, f, ph: PhantomData }\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct EmptyVisitor<T> {\n-    ph: PhantomData<fn() -> T>,\n-}\n-\n-impl<'a, T> Visitor<'a> for EmptyVisitor<T> {\n-    type Output = T;\n-\n-    fn accept(self, _node: &'a SyntaxNode) -> Option<T> {\n-        None\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct EmptyVisitorCtx<T, C> {\n-    ctx: C,\n-    ph: PhantomData<fn() -> T>,\n-}\n-\n-impl<'a, T, C> VisitorCtx<'a> for EmptyVisitorCtx<T, C> {\n-    type Output = T;\n-    type Ctx = C;\n-\n-    fn accept(self, _node: &'a SyntaxNode) -> Result<T, C> {\n-        Err(self.ctx)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct Vis<V, N, F> {\n-    inner: V,\n-    f: F,\n-    ph: PhantomData<fn(N)>,\n-}\n-\n-impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n-where\n-    V: Visitor<'a>,\n-    N: AstNode + 'a,\n-    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n-{\n-    type Output = <V as Visitor<'a>>::Output;\n-\n-    fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output> {\n-        let Vis { inner, f, .. } = self;\n-        inner.accept(node).or_else(|| N::cast(node.clone()).map(f))\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct VisCtx<V, N, F> {\n-    inner: V,\n-    f: F,\n-    ph: PhantomData<fn(N)>,\n-}\n-\n-impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n-where\n-    V: VisitorCtx<'a>,\n-    N: AstNode + 'a,\n-    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n-{\n-    type Output = <V as VisitorCtx<'a>>::Output;\n-    type Ctx = <V as VisitorCtx<'a>>::Ctx;\n-\n-    fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx> {\n-        let VisCtx { inner, f, .. } = self;\n-        inner.accept(node).or_else(|ctx| match N::cast(node.clone()) {\n-            None => Err(ctx),\n-            Some(node) => Ok(f(node, ctx)),\n-        })\n-    }\n-}"}, {"sha": "c315ba552814aaa7e03f554fb143991fe84ed26e", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -160,6 +160,17 @@ impl SourceFile {\n     }\n }\n \n+#[macro_export]\n+macro_rules! match_ast {\n+    (match $node:ident {\n+        $( ast::$ast:ident($it:ident) => $res:block, )*\n+        _ => $catch_all:expr,\n+    }) => {{\n+        $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n+        { $catch_all }\n+    }};\n+}\n+\n /// This test does not assert anything and instead just shows off the crate's\n /// API.\n #[test]\n@@ -294,7 +305,7 @@ fn api_walkthrough() {\n     // To recursively process the tree, there are three approaches:\n     // 1. explicitly call getter methods on AST nodes.\n     // 2. use descendants and `AstNode::cast`.\n-    // 3. use descendants and the visitor.\n+    // 3. use descendants and `match_ast!`.\n     //\n     // Here's how the first one looks like:\n     let exprs_cast: Vec<String> = file\n@@ -304,17 +315,17 @@ fn api_walkthrough() {\n         .map(|expr| expr.syntax().text().to_string())\n         .collect();\n \n-    // An alternative is to use a visitor. The visitor does not do traversal\n-    // automatically (so it's more akin to a generic lambda) and is constructed\n-    // from closures. This seems more flexible than a single generated visitor\n-    // trait.\n-    use algo::visit::{visitor, Visitor};\n+    // An alternative is to use a macro.\n     let mut exprs_visit = Vec::new();\n     for node in file.syntax().descendants() {\n-        if let Some(result) =\n-            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(&node)\n-        {\n-            exprs_visit.push(result);\n+        match_ast! {\n+            match node {\n+                ast::Expr(it) => {\n+                    let res = it.syntax().text().to_string();\n+                    exprs_visit.push(res);\n+                },\n+                _ => (),\n+            }\n         }\n     }\n     assert_eq!(exprs_cast, exprs_visit);"}, {"sha": "ab4f15908c32635c9e2537d0fd763fd430d6d867", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -5,8 +5,7 @@ mod block;\n use rustc_lexer::unescape;\n \n use crate::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast, AstNode, SyntaxError, SyntaxErrorKind,\n+    ast, match_ast, AstNode, SyntaxError, SyntaxErrorKind,\n     SyntaxKind::{BYTE, BYTE_STRING, CHAR, INT_NUMBER, STRING},\n     SyntaxNode, SyntaxToken, TextUnit, T,\n };\n@@ -97,12 +96,15 @@ impl From<rustc_lexer::unescape::EscapeError> for SyntaxErrorKind {\n pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in root.descendants() {\n-        let _ = visitor_ctx(&mut errors)\n-            .visit::<ast::Literal, _>(validate_literal)\n-            .visit::<ast::BlockExpr, _>(block::validate_block_expr)\n-            .visit::<ast::FieldExpr, _>(|it, errors| validate_numeric_name(it.name_ref(), errors))\n-            .visit::<ast::RecordField, _>(|it, errors| validate_numeric_name(it.name_ref(), errors))\n-            .accept(&node);\n+        match_ast! {\n+            match node {\n+                ast::Literal(it) => { validate_literal(it, &mut errors) },\n+                ast::BlockExpr(it) => { block::validate_block_expr(it, &mut errors) },\n+                ast::FieldExpr(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n+                ast::RecordField(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n+                _ => (),\n+            }\n+        }\n     }\n     errors\n }"}, {"sha": "1ffabc6efb6401c55ddb460bb909c4b5555e1961", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -79,9 +79,7 @@ Rust syntax tree structure and parser. See\n - `grammar.ron` RON description of the grammar, which is used to\n   generate `syntax_kinds` and `ast` modules, using `cargo gen-syntax` command.\n - `algo`: generic tree algorithms, including `walk` for O(1) stack\n-  space tree traversal (this is cool) and `visit` for type-driven\n-  visiting the nodes (this is double plus cool, if you understand how\n-  `Visitor` works, you understand the design of syntax trees).\n+  space tree traversal (this is cool).\n \n Tests for ra_syntax are mostly data-driven: `test_data/parser` contains subdirectories with a bunch of `.rs`\n (test vectors) and `.txt` files with corresponding syntax trees. During testing, we check"}, {"sha": "757a02838ebbf513f858591e1619018250acb78a", "filename": "docs/user/features.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3872964f88a0d751c428c150bb40d8b4f4c89a9/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3872964f88a0d751c428c150bb40d8b4f4c89a9/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=d3872964f88a0d751c428c150bb40d8b4f4c89a9", "patch": "@@ -367,9 +367,9 @@ impl VariantData {\n \n ```rust\n // before:\n-use algo:<|>:visitor::{Visitor, visit};\n+use crate:<|>:db::{RootDatabase, FileSymbol};\n // after:\n-use algo::{<|>visitor::{Visitor, visit}};\n+use crate::{<|>db::{RootDatabase, FileSymbol}};\n ```\n \n - Flip binary expression"}]}