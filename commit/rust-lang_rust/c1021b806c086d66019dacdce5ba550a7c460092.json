{"sha": "c1021b806c086d66019dacdce5ba550a7c460092", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMDIxYjgwNmMwODZkNjYwMTlkYWNkY2U1YmE1NTBhN2M0NjAwOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T15:59:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T15:59:55Z"}, "message": "Auto merge of #6706 - Y-Nak:excessive-for-each, r=camsteffen\n\nNew Lint: needless_for_each\n\nresolves: #6543\n\nchangelog: Added pedantic lint: `needless_for_each`", "tree": {"sha": "0045c71d66dce5c998de3c90da771a63fb7a70b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0045c71d66dce5c998de3c90da771a63fb7a70b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1021b806c086d66019dacdce5ba550a7c460092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1021b806c086d66019dacdce5ba550a7c460092", "html_url": "https://github.com/rust-lang/rust/commit/c1021b806c086d66019dacdce5ba550a7c460092", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1021b806c086d66019dacdce5ba550a7c460092/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e42c35b72d4b164cdbce147e2629353504282a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e42c35b72d4b164cdbce147e2629353504282a5", "html_url": "https://github.com/rust-lang/rust/commit/3e42c35b72d4b164cdbce147e2629353504282a5"}, {"sha": "e61f9782c805f246394f870902140bf32c897b7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e61f9782c805f246394f870902140bf32c897b7e", "html_url": "https://github.com/rust-lang/rust/commit/e61f9782c805f246394f870902140bf32c897b7e"}], "stats": {"total": 572, "additions": 568, "deletions": 4}, "files": [{"sha": "a2193f0eab9890e2ecc4278c6b7985199dae313d", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -2369,6 +2369,7 @@ Released 2018-09-13\n [`needless_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect\n [`needless_continue`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_continue\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n+[`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark"}, {"sha": "11716afe11cdc2c3b219e6923efd288816ba2d3e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -291,6 +291,7 @@ mod needless_bool;\n mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n+mod needless_for_each;\n mod needless_pass_by_value;\n mod needless_question_mark;\n mod needless_update;\n@@ -867,6 +868,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrow::NEEDLESS_BORROW,\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n+        &needless_for_each::NEEDLESS_FOR_EACH,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n         &needless_question_mark::NEEDLESS_QUESTION_MARK,\n         &needless_update::NEEDLESS_UPDATE,\n@@ -1045,6 +1047,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box ptr_eq::PtrEq);\n     store.register_late_pass(|| box needless_bool::NeedlessBool);\n     store.register_late_pass(|| box needless_bool::BoolComparison);\n+    store.register_late_pass(|| box needless_for_each::NeedlessForEach);\n     store.register_late_pass(|| box approx_const::ApproxConstant);\n     store.register_late_pass(|| box misc::MiscLints);\n     store.register_late_pass(|| box eta_reduction::EtaReduction);\n@@ -1405,6 +1408,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::UNSEPARATED_LITERAL_SUFFIX),\n         LintId::of(&mut_mut::MUT_MUT),\n         LintId::of(&needless_continue::NEEDLESS_CONTINUE),\n+        LintId::of(&needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n         LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),"}, {"sha": "8c6c30a18814c24cb088f6bd0ca2fadd7b3a91c5", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -924,7 +924,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                     let mut ident_bind_name = String::from(\"_\");\n                     if !matching_wild {\n                         // Looking for unused bindings (i.e.: `_e`)\n-                        inner.iter().for_each(|pat| {\n+                        for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n                                 if ident.as_str().starts_with('_')\n                                     && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n@@ -933,7 +933,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                                     matching_wild = true;\n                                 }\n                             }\n-                        });\n+                        }\n                     }\n                     if_chain! {\n                         if matching_wild;"}, {"sha": "2ea871990f14a8ab6d317886fc37553bca7ada87", "filename": "clippy_lints/src/needless_for_each.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,167 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{source_map::Span, sym, Symbol};\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::has_iter_method;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `for_each` that would be more simply written as a\n+    /// `for` loop.\n+    ///\n+    /// **Why is this bad?** `for_each` may be used after applying iterator transformers like\n+    /// `filter` for better readability and performance. It may also be used to fit a simple\n+    /// operation on one line.\n+    /// But when none of these apply, a simple `for` loop is more idiomatic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// v.iter().for_each(|elem| {\n+    ///     println!(\"{}\", elem);\n+    /// })\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// for elem in v.iter() {\n+    ///     println!(\"{}\", elem);\n+    /// }\n+    /// ```\n+    pub NEEDLESS_FOR_EACH,\n+    pedantic,\n+    \"using `for_each` where a `for` loop would be simpler\"\n+}\n+\n+declare_lint_pass!(NeedlessForEach => [NEEDLESS_FOR_EACH]);\n+\n+impl LateLintPass<'_> for NeedlessForEach {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        let expr = match stmt.kind {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n+            _ => return,\n+        };\n+\n+        if_chain! {\n+            // Check the method name is `for_each`.\n+            if let ExprKind::MethodCall(method_name, _, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if method_name.ident.name == Symbol::intern(\"for_each\");\n+            // Check `for_each` is an associated function of `Iterator`.\n+            if is_trait_method(cx, expr, sym::Iterator);\n+            // Checks the receiver of `for_each` is also a method call.\n+            if let ExprKind::MethodCall(_, _, [iter_recv], _) = for_each_recv.kind;\n+            // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n+            // `v.foo().iter().for_each()` must be skipped.\n+            if matches!(\n+                iter_recv.kind,\n+                ExprKind::Array(..) | ExprKind::Call(..) | ExprKind::Path(..)\n+            );\n+            // Checks the type of the `iter` method receiver is NOT a user defined type.\n+            if has_iter_method(cx, cx.typeck_results().expr_ty(&iter_recv)).is_some();\n+            // Skip the lint if the body is not block because this is simpler than `for` loop.\n+            // e.g. `v.iter().for_each(f)` is simpler and clearer than using `for` loop.\n+            if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            if let ExprKind::Block(..) = body.value.kind;\n+            then {\n+                let mut ret_collector = RetCollector::default();\n+                ret_collector.visit_expr(&body.value);\n+\n+                // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n+                if ret_collector.ret_in_loop {\n+                    return;\n+                }\n+\n+                let (mut applicability, ret_suggs) = if ret_collector.spans.is_empty() {\n+                    (Applicability::MachineApplicable, None)\n+                } else {\n+                    (\n+                        Applicability::MaybeIncorrect,\n+                        Some(\n+                            ret_collector\n+                                .spans\n+                                .into_iter()\n+                                .map(|span| (span, \"continue\".to_string()))\n+                                .collect(),\n+                        ),\n+                    )\n+                };\n+\n+                let sugg = format!(\n+                    \"for {} in {} {}\",\n+                    snippet_with_applicability(cx, body.params[0].pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, for_each_recv.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, body.value.span, \"..\", &mut applicability),\n+                );\n+\n+                span_lint_and_then(cx, NEEDLESS_FOR_EACH, stmt.span, \"needless use of `for_each`\", |diag| {\n+                    diag.span_suggestion(stmt.span, \"try\", sugg, applicability);\n+                    if let Some(ret_suggs) = ret_suggs {\n+                        diag.multipart_suggestion(\"...and replace `return` with `continue`\", ret_suggs, applicability);\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// This type plays two roles.\n+/// 1. Collect spans of `return` in the closure body.\n+/// 2. Detect use of `return` in `Loop` in the closure body.\n+///\n+/// NOTE: The functionality of this type is similar to\n+/// [`crate::utilts::visitors::find_all_ret_expressions`], but we can't use\n+/// `find_all_ret_expressions` instead of this type. The reasons are:\n+/// 1. `find_all_ret_expressions` passes the argument of `ExprKind::Ret` to a callback, but what we\n+///    need here is `ExprKind::Ret` itself.\n+/// 2. We can't trace current loop depth with `find_all_ret_expressions`.\n+#[derive(Default)]\n+struct RetCollector {\n+    spans: Vec<Span>,\n+    ret_in_loop: bool,\n+    loop_depth: u16,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RetCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        match expr.kind {\n+            ExprKind::Ret(..) => {\n+                if self.loop_depth > 0 && !self.ret_in_loop {\n+                    self.ret_in_loop = true\n+                }\n+\n+                self.spans.push(expr.span)\n+            },\n+\n+            ExprKind::Loop(..) => {\n+                self.loop_depth += 1;\n+                walk_expr(self, expr);\n+                self.loop_depth -= 1;\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "2f8989c8e114082eabd4957b8431f0a090d879a8", "filename": "tests/lint_message_convention.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flint_message_convention.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -89,14 +89,14 @@ fn lint_message_convention() {\n         .filter(|message| !message.bad_lines.is_empty())\n         .collect();\n \n-    bad_tests.iter().for_each(|message| {\n+    for message in &bad_tests {\n         eprintln!(\n             \"error: the test '{}' contained the following nonconforming lines :\",\n             message.path.display()\n         );\n         message.bad_lines.iter().for_each(|line| eprintln!(\"{}\", line));\n         eprintln!(\"\\n\\n\");\n-    });\n+    }\n \n     eprintln!(\n         \"\\n\\n\\nLint message should not start with a capital letter and should not have punctuation at the end of the message unless multiple sentences are needed.\""}, {"sha": "f00f9ee4c331b716bd32ad7049f09968ebee88fa", "filename": "tests/ui/needless_for_each_fixable.fixed", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.fixed?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,113 @@\n+// run-rustfix\n+#![warn(clippy::needless_for_each)]\n+#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+\n+use std::collections::HashMap;\n+\n+fn should_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+    for elem in v.iter() {\n+        acc += elem;\n+    }\n+    for elem in v.into_iter() {\n+        acc += elem;\n+    }\n+\n+    for elem in [1, 2, 3].iter() {\n+        acc += elem;\n+    }\n+\n+    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n+    for (k, v) in hash_map.iter() {\n+        acc += k + v;\n+    }\n+    for (k, v) in hash_map.iter_mut() {\n+        acc += *k + *v;\n+    }\n+    for k in hash_map.keys() {\n+        acc += k;\n+    }\n+    for v in hash_map.values() {\n+        acc += v;\n+    }\n+\n+    fn my_vec() -> Vec<i32> {\n+        Vec::new()\n+    }\n+    for elem in my_vec().iter() {\n+        acc += elem;\n+    }\n+}\n+\n+fn should_not_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+\n+    // `for_each` argument is not closure.\n+    fn print(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+    v.iter().for_each(print);\n+\n+    // User defined type.\n+    struct MyStruct {\n+        v: Vec<i32>,\n+    }\n+    impl MyStruct {\n+        fn iter(&self) -> impl Iterator<Item = &i32> {\n+            self.v.iter()\n+        }\n+    }\n+    let s = MyStruct { v: Vec::new() };\n+    s.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` follows long iterator chain.\n+    v.iter().chain(v.iter()).for_each(|v| {\n+        acc += v;\n+    });\n+    v.as_slice().iter().for_each(|v| {\n+        acc += v;\n+    });\n+    s.v.iter().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    // `return` is used in `Loop` of the closure.\n+    v.iter().for_each(|v| {\n+        for i in 0..*v {\n+            if i == 10 {\n+                return;\n+            } else {\n+                println!(\"{}\", v);\n+            }\n+        }\n+        if *v == 20 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // Previously transformed iterator variable.\n+    let it = v.iter();\n+    it.chain(v.iter()).for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` is not directly in a statement.\n+    match 1 {\n+        _ => v.iter().for_each(|elem| {\n+            acc += elem;\n+        }),\n+    }\n+\n+    // `for_each` is in a let bingind.\n+    let _ = v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "1bd400d348ba92ce635f45d8b2dea743cbf6918d", "filename": "tests/ui/needless_for_each_fixable.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,113 @@\n+// run-rustfix\n+#![warn(clippy::needless_for_each)]\n+#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+\n+use std::collections::HashMap;\n+\n+fn should_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+    v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+    v.into_iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    [1, 2, 3].iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n+    hash_map.iter().for_each(|(k, v)| {\n+        acc += k + v;\n+    });\n+    hash_map.iter_mut().for_each(|(k, v)| {\n+        acc += *k + *v;\n+    });\n+    hash_map.keys().for_each(|k| {\n+        acc += k;\n+    });\n+    hash_map.values().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    fn my_vec() -> Vec<i32> {\n+        Vec::new()\n+    }\n+    my_vec().iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+}\n+\n+fn should_not_lint() {\n+    let v: Vec<i32> = Vec::new();\n+    let mut acc = 0;\n+\n+    // `for_each` argument is not closure.\n+    fn print(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+    v.iter().for_each(print);\n+\n+    // User defined type.\n+    struct MyStruct {\n+        v: Vec<i32>,\n+    }\n+    impl MyStruct {\n+        fn iter(&self) -> impl Iterator<Item = &i32> {\n+            self.v.iter()\n+        }\n+    }\n+    let s = MyStruct { v: Vec::new() };\n+    s.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` follows long iterator chain.\n+    v.iter().chain(v.iter()).for_each(|v| {\n+        acc += v;\n+    });\n+    v.as_slice().iter().for_each(|v| {\n+        acc += v;\n+    });\n+    s.v.iter().for_each(|v| {\n+        acc += v;\n+    });\n+\n+    // `return` is used in `Loop` of the closure.\n+    v.iter().for_each(|v| {\n+        for i in 0..*v {\n+            if i == 10 {\n+                return;\n+            } else {\n+                println!(\"{}\", v);\n+            }\n+        }\n+        if *v == 20 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // Previously transformed iterator variable.\n+    let it = v.iter();\n+    it.chain(v.iter()).for_each(|elem| {\n+        acc += elem;\n+    });\n+\n+    // `for_each` is not directly in a statement.\n+    match 1 {\n+        _ => v.iter().for_each(|elem| {\n+            acc += elem;\n+        }),\n+    }\n+\n+    // `for_each` is in a let bingind.\n+    let _ = v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "483a5e6d61d7291cb4a7d6f637bf5b1dfa42beb6", "filename": "tests/ui/needless_for_each_fixable.stderr", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.stderr?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,123 @@\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:10:5\n+   |\n+LL | /     v.iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+   = note: `-D clippy::needless-for-each` implied by `-D warnings`\n+help: try\n+   |\n+LL |     for elem in v.iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:13:5\n+   |\n+LL | /     v.into_iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for elem in v.into_iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:17:5\n+   |\n+LL | /     [1, 2, 3].iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for elem in [1, 2, 3].iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:22:5\n+   |\n+LL | /     hash_map.iter().for_each(|(k, v)| {\n+LL | |         acc += k + v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for (k, v) in hash_map.iter() {\n+LL |         acc += k + v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:25:5\n+   |\n+LL | /     hash_map.iter_mut().for_each(|(k, v)| {\n+LL | |         acc += *k + *v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for (k, v) in hash_map.iter_mut() {\n+LL |         acc += *k + *v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:28:5\n+   |\n+LL | /     hash_map.keys().for_each(|k| {\n+LL | |         acc += k;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for k in hash_map.keys() {\n+LL |         acc += k;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:31:5\n+   |\n+LL | /     hash_map.values().for_each(|v| {\n+LL | |         acc += v;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for v in hash_map.values() {\n+LL |         acc += v;\n+LL |     }\n+   |\n+\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_fixable.rs:38:5\n+   |\n+LL | /     my_vec().iter().for_each(|elem| {\n+LL | |         acc += elem;\n+LL | |     });\n+   | |_______^\n+   |\n+help: try\n+   |\n+LL |     for elem in my_vec().iter() {\n+LL |         acc += elem;\n+LL |     }\n+   |\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "d765d7dab65c90c26571df73ef9fac4743c1cbdf", "filename": "tests/ui/needless_for_each_unfixable.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_unfixable.rs?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,14 @@\n+#![warn(clippy::needless_for_each)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let v: Vec<i32> = Vec::new();\n+    // This is unfixable because the closure includes `return`.\n+    v.iter().for_each(|v| {\n+        if *v == 10 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+}"}, {"sha": "8c4507d23283ce2b0c9785e1734626c8357e8ae2", "filename": "tests/ui/needless_for_each_unfixable.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1021b806c086d66019dacdce5ba550a7c460092/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_unfixable.stderr?ref=c1021b806c086d66019dacdce5ba550a7c460092", "patch": "@@ -0,0 +1,29 @@\n+error: needless use of `for_each`\n+  --> $DIR/needless_for_each_unfixable.rs:7:5\n+   |\n+LL | /     v.iter().for_each(|v| {\n+LL | |         if *v == 10 {\n+LL | |             return;\n+LL | |         } else {\n+LL | |             println!(\"{}\", v);\n+LL | |         }\n+LL | |     });\n+   | |_______^\n+   |\n+   = note: `-D clippy::needless-for-each` implied by `-D warnings`\n+help: try\n+   |\n+LL |     for v in v.iter() {\n+LL |         if *v == 10 {\n+LL |             return;\n+LL |         } else {\n+LL |             println!(\"{}\", v);\n+LL |         }\n+ ...\n+help: ...and replace `return` with `continue`\n+   |\n+LL |             continue;\n+   |             ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}