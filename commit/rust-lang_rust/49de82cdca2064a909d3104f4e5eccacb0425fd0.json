{"sha": "49de82cdca2064a909d3104f4e5eccacb0425fd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZGU4MmNkY2EyMDY0YTkwOWQzMTA0ZjRlNWVjY2FjYjA0MjVmZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-10T20:11:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-11T00:32:02Z"}, "message": "Issue #5656: Make &self not mean \"&'self self\"\n\nFixes #5656.\nFixes #5541.", "tree": {"sha": "476daee1450ae400b436dcfa8c764310ecd6eb34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476daee1450ae400b436dcfa8c764310ecd6eb34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49de82cdca2064a909d3104f4e5eccacb0425fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49de82cdca2064a909d3104f4e5eccacb0425fd0", "html_url": "https://github.com/rust-lang/rust/commit/49de82cdca2064a909d3104f4e5eccacb0425fd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49de82cdca2064a909d3104f4e5eccacb0425fd0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3322595e896e95c3e19ca33c854ad529f2ef3c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/3322595e896e95c3e19ca33c854ad529f2ef3c19", "html_url": "https://github.com/rust-lang/rust/commit/3322595e896e95c3e19ca33c854ad529f2ef3c19"}], "stats": {"total": 631, "additions": 336, "deletions": 295}, "files": [{"sha": "e5fc9f2d60391ec7aab71c3b9e9528f424c4db58", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -16,7 +16,7 @@ use middle::liveness;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{Repr, ty_to_str, tys_to_str};\n+use util::ppaux::{Repr, ty_to_str};\n \n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;"}, {"sha": "ecb9fc2cd08b8309888889541693ab91dec99f4b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -544,10 +544,6 @@ pub struct DetermineRpCtxt {\n     // see long discussion on region_is_relevant().\n     anon_implies_rp: bool,\n \n-    // true when we are not within an &self method.\n-    // see long discussion on region_is_relevant().\n-    self_implies_rp: bool,\n-\n     // encodes the context of the current type; invariant if\n     // mutable, covariant otherwise\n     ambient_variance: region_variance,\n@@ -689,7 +685,7 @@ pub impl DetermineRpCtxt {\n                 false\n             }\n             Some(ref l) if l.ident == special_idents::self_ => {\n-                self.self_implies_rp\n+                true\n             }\n             Some(_) => {\n                 false\n@@ -700,23 +696,18 @@ pub impl DetermineRpCtxt {\n     fn with(@mut self,\n             item_id: ast::node_id,\n             anon_implies_rp: bool,\n-            self_implies_rp: bool,\n             f: &fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n-        let old_self_implies_rp = self.self_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        self.self_implies_rp = self_implies_rp;\n-        debug!(\"with_item_id(%d, %b, %b)\",\n+        debug!(\"with_item_id(%d, %b)\",\n                item_id,\n-               anon_implies_rp,\n-               self_implies_rp);\n+               anon_implies_rp);\n         let _i = ::util::common::indenter();\n         f();\n         self.item_id = old_item_id;\n         self.anon_implies_rp = old_anon_implies_rp;\n-        self.self_implies_rp = old_self_implies_rp;\n     }\n \n     fn with_ambient_variance(@mut self, variance: region_variance, f: &fn()) {\n@@ -730,7 +721,7 @@ pub impl DetermineRpCtxt {\n pub fn determine_rp_in_item(item: @ast::item,\n                             &&cx: @mut DetermineRpCtxt,\n                             visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(item.id, true, true) {\n+    do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n     }\n }\n@@ -742,12 +733,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           _: ast::node_id,\n                           &&cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    let self_implies_rp = match fk {\n-        &visit::fk_method(_, _, m) => !m.self_ty.node.is_borrowed(),\n-        _ => true\n-    };\n-\n-    do cx.with(cx.item_id, false, self_implies_rp) {\n+    do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n                 (visitor.visit_ty)(a.ty, cx, visitor);\n@@ -763,7 +749,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n                                  &&cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(cx.item_id, false, !ty_m.self_ty.node.is_borrowed()) {\n+    do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n@@ -868,7 +854,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n       ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n-        do cx.with(cx.item_id, false, true) {\n+        do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.each |a| {\n@@ -929,7 +915,6 @@ pub fn determine_rp_in_crate(sess: Session,\n         worklist: ~[],\n         item_id: 0,\n         anon_implies_rp: false,\n-        self_implies_rp: true,\n         ambient_variance: rv_covariant\n     };\n "}, {"sha": "35257f9574c366a33815214613a8f8492d92262d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -62,22 +62,7 @@ impl EffectfulSubst for ty::t {\n             _ => {\n                 ty::fold_regions_and_ty(\n                     tcx, *self,\n-                    |r| match r {\n-                        ty::re_bound(ty::br_self) => {\n-                            match substs.self_r {\n-                                None => {\n-                                    tcx.sess.bug(\n-                                        fmt!(\"ty::subst: \\\n-                                              Reference to self region when \\\n-                                              given substs with no self region, \\\n-                                              ty = %s\",\n-                                             self.repr(tcx)));\n-                                }\n-                                Some(self_r) => self_r\n-                            }\n-                        }\n-                        _ => r\n-                    },\n+                    |r| r.subst(tcx, substs),\n                     |t| t.effectfulSubst(tcx, substs),\n                     |t| t.effectfulSubst(tcx, substs))\n             }\n@@ -118,7 +103,7 @@ impl Subst for ty::TraitRef {\n impl Subst for ty::substs {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::substs {\n         ty::substs {\n-            self_r: self.self_r,\n+            self_r: self.self_r.subst(tcx, substs),\n             self_ty: self.self_ty.map(|typ| typ.subst(tcx, substs)),\n             tps: self.tps.map(|typ| typ.subst(tcx, substs))\n         }\n@@ -166,6 +151,34 @@ impl Subst for ty::Generics {\n     }\n }\n \n+impl Subst for ty::Region {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n+        // Note: This routine only handles the self region, because it\n+        // is only concerned with substitutions of regions that appear\n+        // in types. Region substitution of the bound regions that\n+        // appear in a function signature is done using the\n+        // specialized routine\n+        // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n+        // As we transition to the new region syntax this distinction\n+        // will most likely disappear.\n+        match self {\n+            &ty::re_bound(ty::br_self) => {\n+                match substs.self_r {\n+                    None => {\n+                        tcx.sess.bug(\n+                            fmt!(\"ty::Region#subst(): \\\n+                                  Reference to self region when \\\n+                                  given substs with no self region: %s\",\n+                                 substs.repr(tcx)));\n+                    }\n+                    Some(self_r) => self_r\n+                }\n+            }\n+            _ => *self\n+        }\n+    }\n+}\n+\n impl Subst for ty::ty_param_bounds_and_ty {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ty_param_bounds_and_ty {\n         ty::ty_param_bounds_and_ty {"}, {"sha": "2b4a4235950c882e8f9f9dfee7852724c74addec", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -24,8 +24,7 @@ use middle::subst::Subst;\n use middle::typeck;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n-use util::ppaux::{region_to_str, vstore_to_str};\n-use util::ppaux::{trait_store_to_str, ty_to_str, tys_to_str};\n+use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::Repr;\n use util::common::{indenter};\n "}, {"sha": "6b09133e73a11d04f902cd7561c8f21e11f747d2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 133, "deletions": 150, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -178,15 +178,6 @@ pub struct Candidate {\n     origin: method_origin,\n }\n \n-/**\n- * How the self type should be transformed according to the form of explicit\n- * self provided by the method.\n- */\n-pub enum TransformTypeFlag {\n-    TransformTypeNormally,\n-    TransformTypeForObject,\n-}\n-\n pub impl<'self> LookupContext<'self> {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = structurally_resolved_type(self.fcx,\n@@ -285,13 +276,13 @@ pub impl<'self> LookupContext<'self> {\n \n     fn push_inherent_candidates(&self, self_ty: ty::t) {\n         /*!\n-         *\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n          * the file.  To find the inherent candidates, we repeatedly\n          * deref the self-ty to find the \"base-type\".  So, for\n          * example, if the receiver is @@C where `C` is a struct type,\n-         * we'll want to find the inherent impls for `C`. */\n+         * we'll want to find the inherent impls for `C`.\n+         */\n \n         let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n@@ -407,16 +398,9 @@ pub impl<'self> LookupContext<'self> {\n             };\n             let method = trait_methods[pos];\n \n-            let (rcvr_ty, rcvr_substs) =\n-                self.create_rcvr_ty_and_substs_for_method(\n-                    method.self_ty,\n-                    rcvr_ty,\n-                    copy bound_trait_ref.substs,\n-                    TransformTypeNormally);\n-\n             let cand = Candidate {\n                 rcvr_ty: rcvr_ty,\n-                rcvr_substs: rcvr_substs,\n+                rcvr_substs: copy bound_trait_ref.substs,\n                 method_ty: method,\n                 origin: method_param(\n                     method_param {\n@@ -476,14 +460,8 @@ pub impl<'self> LookupContext<'self> {\n             ../*bad*/copy *substs\n         };\n \n-        let (rcvr_ty, rcvr_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n-                                                      self_ty,\n-                                                      rcvr_substs,\n-                                                      TransformTypeForObject);\n-\n         self.inherent_candidates.push(Candidate {\n-            rcvr_ty: rcvr_ty,\n+            rcvr_ty: self_ty,\n             rcvr_substs: rcvr_substs,\n             method_ty: method,\n             origin: method_trait(did, index, store)\n@@ -538,19 +516,13 @@ pub impl<'self> LookupContext<'self> {\n                 // We've found a method -- return it\n                 let rcvr_substs = substs {self_ty: Some(self_ty),\n                                           ..copy *substs };\n-                let (rcvr_ty, rcvr_substs) =\n-                    self.create_rcvr_ty_and_substs_for_method(\n-                        info.method_ty.self_ty,\n-                        self_ty,\n-                        rcvr_substs,\n-                        TransformTypeNormally);\n                 let origin = if did == info.trait_def_id {\n                     method_self(info.trait_def_id, info.index)\n                 } else {\n                     method_super(info.trait_def_id, info.index)\n                 };\n                 self.inherent_candidates.push(Candidate {\n-                    rcvr_ty: rcvr_ty,\n+                    rcvr_ty: self_ty,\n                     rcvr_substs: rcvr_substs,\n                     method_ty: info.method_ty,\n                     origin: origin\n@@ -598,13 +570,6 @@ pub impl<'self> LookupContext<'self> {\n             ty: impl_ty\n         } = impl_self_ty(&vcx, location_info, impl_info.did);\n \n-        let (impl_ty, impl_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(\n-                method.self_ty,\n-                impl_ty,\n-                impl_substs,\n-                TransformTypeNormally);\n-\n         candidates.push(Candidate {\n             rcvr_ty: impl_ty,\n             rcvr_substs: impl_substs,\n@@ -639,69 +604,16 @@ pub impl<'self> LookupContext<'self> {\n                 self_ty: None,\n                 tps: ~[]\n             };\n-            let (impl_ty, impl_substs) =\n-                self.create_rcvr_ty_and_substs_for_method(\n-                    method.self_ty,\n-                    self_ty,\n-                    dummy_substs,\n-                    TransformTypeNormally);\n \n             candidates.push(Candidate {\n-                rcvr_ty: impl_ty,\n-                rcvr_substs: impl_substs,\n+                rcvr_ty: self_ty,\n+                rcvr_substs: dummy_substs,\n                 method_ty: method,\n                 origin: method_static(provided_method_info.method_info.did)\n             });\n         }\n     }\n \n-    fn create_rcvr_ty_and_substs_for_method(&self,\n-                                            self_decl: ast::self_ty_,\n-                                            self_ty: ty::t,\n-                                            +self_substs: ty::substs,\n-                                            transform_type: TransformTypeFlag)\n-                                         -> (ty::t, ty::substs) {\n-        // If the self type includes a region (like &self), we need to\n-        // ensure that the receiver substitutions have a self region.\n-        // If the receiver type does not itself contain borrowed\n-        // pointers, there may not be one yet.\n-        //\n-        // FIXME(#3446)--this awkward situation comes about because\n-        // the regions in the receiver are substituted before (and\n-        // differently from) those in the argument types.  This\n-        // shouldn't really have to be.\n-        let rcvr_substs = {\n-            match self_decl {\n-                sty_static | sty_value |\n-                sty_box(_) | sty_uniq(_) => {\n-                    self_substs\n-                }\n-                sty_region(*) if self_substs.self_r.is_some() => {\n-                    // FIXME(#4846) ignoring expl lifetime here\n-                    self_substs\n-                }\n-                sty_region(*) => {\n-                    // FIXME(#4846) ignoring expl lifetime here\n-                    substs {\n-                        self_r:\n-                             Some(self.infcx().next_region_var(\n-                                 self.expr.span,\n-                                 self.expr.id)),\n-                        ..self_substs\n-                    }\n-                }\n-            }\n-        };\n-\n-        let rcvr_ty = transform_self_type_for_method(self.tcx(),\n-                                                     rcvr_substs.self_r,\n-                                                     self_ty,\n-                                                     self_decl,\n-                                                     transform_type);\n-\n-        (rcvr_ty, rcvr_substs)\n-    }\n-\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n \n@@ -1036,20 +948,34 @@ pub impl<'self> LookupContext<'self> {\n         self.enforce_trait_instance_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n-        // before we only checked whether self_ty could be a subtype\n-        // of rcvr_ty; now we actually make it so (this may cause\n-        // variables to unify etc).  Since we checked beforehand, and\n-        // nothing has changed in the meantime, this unification\n-        // should never fail.\n-        match self.fcx.mk_subty(false, self.self_expr.span,\n-                                self_ty, candidate.rcvr_ty) {\n-            result::Ok(_) => (),\n-            result::Err(_) => {\n-                self.bug(fmt!(\"%s was assignable to %s but now is not?\",\n-                              self.ty_to_str(self_ty),\n-                              self.ty_to_str(candidate.rcvr_ty)));\n+        // static methods should never have gotten this far:\n+        assert!(candidate.method_ty.self_ty != sty_static);\n+\n+        let transformed_self_ty = match candidate.origin {\n+            method_trait(*) => {\n+                match candidate.method_ty.self_ty {\n+                    sty_region(*) => {\n+                        // FIXME(#5762) again, preserving existing\n+                        // behavior here which (for &self) desires\n+                        // &@Trait where @Trait is the type of the\n+                        // receiver.  Here we fetch the method's\n+                        // transformed_self_ty which will be something\n+                        // like &'a Self.  We then perform a\n+                        // substitution which will replace Self with\n+                        // @Trait.\n+                        let t = candidate.method_ty.transformed_self_ty.get();\n+                        ty::subst(tcx, &candidate.rcvr_substs, t)\n+                    }\n+                    _ => {\n+                        candidate.rcvr_ty\n+                    }\n+                }\n             }\n-        }\n+            _ => {\n+                let t = candidate.method_ty.transformed_self_ty.get();\n+                ty::subst(tcx, &candidate.rcvr_substs, t)\n+            }\n+        };\n \n         // Determine the values for the type parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -1100,16 +1026,32 @@ pub impl<'self> LookupContext<'self> {\n                     fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n             }\n         };\n-        let (_, _, fn_sig) =\n+        let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, @Nil, None, &bare_fn_ty.sig,\n+                tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |_br| self.fcx.infcx().next_region_var(\n                     self.expr.span, self.expr.id));\n+        let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_self_type(candidate.method_ty.self_ty);\n \n+        // before we only checked whether self_ty could be a subtype\n+        // of rcvr_ty; now we actually make it so (this may cause\n+        // variables to unify etc).  Since we checked beforehand, and\n+        // nothing has changed in the meantime, this unification\n+        // should never fail.\n+        match self.fcx.mk_subty(false, self.self_expr.span,\n+                                self_ty, transformed_self_ty) {\n+            result::Ok(_) => (),\n+            result::Err(_) => {\n+                self.bug(fmt!(\"%s was a subtype of %s but now is not?\",\n+                              self.ty_to_str(self_ty),\n+                              self.ty_to_str(transformed_self_ty)));\n+            }\n+        }\n+\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n@@ -1180,7 +1122,87 @@ pub impl<'self> LookupContext<'self> {\n         debug!(\"is_relevant(self_ty=%s, candidate=%s)\",\n                self.ty_to_str(self_ty), self.cand_to_str(candidate));\n \n-        self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+        // Check for calls to object methods.  We resolve these differently.\n+        //\n+        // FIXME(#5762)---we don't check that an @self method is only called\n+        // on an @Trait object here and so forth\n+        match candidate.origin {\n+            method_trait(*) => {\n+                match candidate.method_ty.self_ty {\n+                    sty_static | sty_value => {\n+                        return false;\n+                    }\n+                    sty_region(*) => {\n+                        // just echoing current behavior here, which treats\n+                        // an &self method on an @Trait object as requiring\n+                        // an &@Trait receiver (wacky)\n+                    }\n+                    sty_box(*) | sty_uniq(*) => {\n+                        return self.fcx.can_mk_subty(self_ty,\n+                                                     candidate.rcvr_ty).is_ok();\n+                    }\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        return match candidate.method_ty.self_ty {\n+            sty_static => {\n+                false\n+            }\n+\n+            sty_value => {\n+                self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+            }\n+\n+            sty_region(_, m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_rptr(_, mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+\n+            sty_box(m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_box(mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+\n+            sty_uniq(m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_uniq(mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+        };\n+\n+        fn mutability_matches(self_mutbl: ast::mutability,\n+                              candidate_mutbl: ast::mutability) -> bool {\n+            //! True if `self_mutbl <: candidate_mutbl`\n+\n+            match (self_mutbl, candidate_mutbl) {\n+                (_, m_const) => true,\n+                (m_mutbl, m_mutbl) => true,\n+                (m_imm, m_imm) => true,\n+                (m_mutbl, m_imm) => false,\n+                (m_imm, m_mutbl) => false,\n+                (m_const, m_imm) => false,\n+                (m_const, m_mutbl) => false,\n+            }\n+        }\n     }\n \n     fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n@@ -1281,45 +1303,6 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn transform_self_type_for_method(tcx: ty::ctxt,\n-                                      self_region: Option<ty::Region>,\n-                                      impl_ty: ty::t,\n-                                      self_type: ast::self_ty_,\n-                                      flag: TransformTypeFlag)\n-                                   -> ty::t {\n-    match self_type {\n-      sty_static => {\n-        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n-                       static method\");\n-      }\n-      sty_value => {\n-        impl_ty\n-      }\n-      sty_region(_, mutability) => {\n-        // FIXME(#4846) ignoring expl lifetime here\n-        mk_rptr(tcx,\n-                self_region.expect(~\"self region missing for &self param\"),\n-                ty::mt { ty: impl_ty, mutbl: mutability })\n-      }\n-      sty_box(mutability) => {\n-        match flag {\n-            TransformTypeNormally => {\n-                mk_box(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n-            }\n-            TransformTypeForObject => impl_ty\n-        }\n-      }\n-      sty_uniq(mutability) => {\n-        match flag {\n-            TransformTypeNormally => {\n-                mk_uniq(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n-            }\n-            TransformTypeForObject => impl_ty\n-        }\n-      }\n-    }\n-}\n-\n pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n     match self_type { sty_value => by_copy, _ => by_ref }\n }"}, {"sha": "5c7a6d9f52aa67484f9afc34ca19d7ae6d189341", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -93,17 +93,15 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{CheckTraitsOnly, DontAutoderefReceiver};\n-use middle::typeck::check::method::{TransformTypeNormally};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::bound_self_region;\n-use middle::typeck::rscope::{RegionError, RegionParameterization};\n+use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::region_scope;\n-use middle::typeck::rscope;\n use middle::typeck::{isr_alist, lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n@@ -280,7 +278,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n }\n \n pub fn check_fn(ccx: @mut CrateCtxt,\n-                +self_info: Option<SelfInfo>,\n+                opt_self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n@@ -307,23 +305,28 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // First, we have to replace any bound regions in the fn and self\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n-\n-    let (isr, self_info, fn_sig) = {\n-        replace_bound_regions_in_fn_sig(\n-            tcx, inherited_isr, self_info, fn_sig,\n-            |br| ty::re_free(ty::FreeRegion {scope_id: body.node.id,\n-                                             bound_region: br}))\n+    let (isr, opt_self_info, fn_sig) = {\n+        let opt_self_ty = opt_self_info.map(|i| i.self_ty);\n+        let (isr, opt_self_ty, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                tcx, inherited_isr, opt_self_ty, fn_sig,\n+                |br| ty::re_free(ty::FreeRegion {scope_id: body.node.id,\n+                                                 bound_region: br}));\n+        let opt_self_info =\n+            opt_self_info.map(\n+                |si| SelfInfo {self_ty: opt_self_ty.get(), ..*si});\n+        (isr, opt_self_info, fn_sig)\n     };\n \n-    relate_free_regions(tcx, self_info.map(|s| s.self_ty), &fn_sig);\n+    relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n \n     let arg_tys = fn_sig.inputs.map(|a| a.ty);\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n-           arg_tys.map(|a| ppaux::ty_to_str(tcx, *a)),\n+    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, opt_self_ty=%?)\",\n+           arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n-           self_info.map(|s| ppaux::ty_to_str(tcx, s.self_ty)));\n+           opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -348,7 +351,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         }\n     };\n \n-    gather_locals(fcx, decl, body, arg_tys, self_info);\n+    gather_locals(fcx, decl, body, arg_tys, opt_self_info);\n     check_block_with_expected(fcx, body, Some(ret_ty));\n \n     // We unify the tail expr's type with the\n@@ -366,7 +369,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n       None => ()\n     }\n \n-    for self_info.each |self_info| {\n+    for opt_self_info.each |self_info| {\n         fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n     for vec::each2(decl.inputs, arg_tys) |input, arg| {\n@@ -379,7 +382,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      arg_tys: &[ty::t],\n-                     self_info: Option<SelfInfo>) {\n+                     opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n         let assign: @fn(ast::node_id, Option<ty::t>) = |nid, ty_opt| {\n@@ -398,7 +401,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add the self parameter\n-        for self_info.each |self_info| {\n+        for opt_self_info.each |self_info| {\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n@@ -484,26 +487,22 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n }\n \n pub fn check_method(ccx: @mut CrateCtxt,\n-                    method: @ast::method,\n-                    self_ty: ty::t)\n+                    method: @ast::method)\n {\n-    let self_info = if method.self_ty.node == ast::sty_static {None} else {\n-        let ty = method::transform_self_type_for_method(\n-            ccx.tcx,\n-            Some(ty::re_bound(ty::br_self)),\n-            self_ty,\n-            method.self_ty.node,\n-            TransformTypeNormally);\n-        Some(SelfInfo {self_ty: ty, self_id: method.self_id,\n-                       span: method.self_ty.span})\n-    };\n+    let method_def_id = local_def(method.id);\n+    let method_ty = ty::method(ccx.tcx, method_def_id);\n+    let opt_self_info = method_ty.transformed_self_ty.map(|&ty| {\n+        SelfInfo {self_ty: ty,\n+                  self_id: method.self_id,\n+                  span: method.self_ty.span}\n+    });\n \n     check_bare_fn(\n         ccx,\n         &method.decl,\n         &method.body,\n         method.id,\n-        self_info\n+        opt_self_info\n     );\n }\n \n@@ -575,15 +574,12 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_fn(ref decl, _, _, _, ref body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(ref generics, _, ty, ref ms) => {\n+      ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        let rp = RegionParameterization::from_variance_and_generics(\n-            rp, generics);\n-        let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n-            check_method(ccx, *m, self_ty);\n+            check_method(ccx, *m);\n         }\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n@@ -594,8 +590,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                 // bodies to check.\n               }\n               provided(m) => {\n-                let self_ty = ty::mk_self(ccx.tcx, local_def(it.id));\n-                check_method(ccx, m, self_ty);\n+                check_method(ccx, m);\n               }\n             }\n         }"}, {"sha": "1abcefeefac8cdd462848b21ceebbac419e0621c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::typeck::check::SelfInfo;\n+\n use middle::typeck::isr_alist;\n use util::common::indenter;\n use util::ppaux::region_to_str;\n@@ -26,29 +26,24 @@ use std::list::Cons;\n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n-    self_info: Option<SelfInfo>,\n+    opt_self_ty: Option<ty::t>,\n     fn_sig: &ty::FnSig,\n     mapf: &fn(ty::bound_region) -> ty::Region)\n-    -> (isr_alist, Option<SelfInfo>, ty::FnSig)\n+    -> (isr_alist, Option<ty::t>, ty::FnSig)\n {\n-    // Take self_info apart; the self_ty part is the only one we want\n-    // to update here.\n-    let self_ty = self_info.map(|s| s.self_ty);\n-    let rebuild_self_info = |t| self_info.map(|s| SelfInfo{self_ty: t, ..*s});\n-\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    for self_info.each |self_info| {\n-        all_tys.push(self_info.self_ty);\n+    for opt_self_ty.each |&self_ty| {\n+        all_tys.push(self_ty);\n     }\n \n-    for self_ty.each |t| { all_tys.push(*t) }\n+    for opt_self_ty.each |&t| { all_tys.push(t) }\n \n-    debug!(\"replace_bound_regions_in_fn_sig(self_info.self_ty=%?, fn_sig=%s, \\\n+    debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n-           self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n+           opt_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n-           all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n+           all_tys.map(|&t| ppaux::ty_to_str(tcx, t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n@@ -58,20 +53,15 @@ pub fn replace_bound_regions_in_fn_sig(\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n+    let new_self_ty = opt_self_ty.map(|&t| replace_bound_regions(tcx, isr, t));\n \n-    debug!(\"result of replace_bound_regions_in_fn_sig: self_info.self_ty=%?, \\\n-                fn_sig=%s\",\n-           t_self.map(|t| ppaux::ty_to_str(tcx, *t)),\n+    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n+            new_self_ty=%?, \\\n+            fn_sig=%s\",\n+           new_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n-    // Glue updated self_ty back together with its original def_id.\n-    let new_self_info: Option<SelfInfo> = match t_self {\n-      None    => None,\n-      Some(t) => rebuild_self_info(t)\n-    };\n-\n-    return (isr, new_self_info, new_fn_sig);\n+    return (isr, new_self_ty, new_fn_sig);\n \n     // Takes `isr`, a (possibly empty) mapping from in-scope region\n     // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n@@ -288,4 +278,4 @@ pub fn relate_free_regions(\n     }\n \n     debug!(\"<< relate_free_regions\");\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8245dc88114c8aca24cfd007fde7935dd13110a6", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use middle::resolve::Impl;\n-use middle::ty::{param_ty, substs};\n+use middle::ty::{param_ty};\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n@@ -489,6 +489,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     match ex.node {\n       ast::expr_path(*) => {\n         for fcx.opt_node_ty_substs(ex.id) |substs| {\n+            debug!(\"vtable resolution on parameter bounds for expr %s\",\n+                   ex.repr(fcx.tcx()));\n             let def = *cx.tcx.def_map.get(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n@@ -518,6 +520,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       ast::expr_index(*) | ast::expr_method_call(*) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n+            debug!(\"vtable resolution on parameter bounds for method call %s\",\n+                   ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let callee_id = match ex.node {\n                   ast::expr_field(_, _, _) => ex.id,\n@@ -537,6 +541,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         }\n       }\n       ast::expr_cast(src, _) => {\n+          debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               ty::ty_trait(target_def_id, ref target_substs, store) => {"}, {"sha": "247b8eae2a8db67d5238814c04318baa0f83b2b0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -24,7 +24,7 @@ use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n-use middle::ty::{lookup_item_type, param_bounds, subst};\n+use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};"}, {"sha": "59ea8ea039e1f1c474f9eda323c4f7ac05337cc4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 72, "deletions": 25, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -55,7 +55,7 @@ use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::path_to_str;\n+use syntax::print::pprust::{path_to_str, self_ty_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -453,31 +453,35 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n \n     let impl_m = &cm.mty;\n \n-    // FIXME(#2687)---this check is too strict.  For example, a trait\n-    // method with self type `&self` or `&mut self` should be\n-    // implementable by an `&const self` method (the impl assumes less\n-    // than the trait provides).\n-    if impl_m.self_ty != trait_m.self_ty {\n-        if impl_m.self_ty == ast::sty_static {\n-            // Needs to be a fatal error because otherwise,\n-            // method::transform_self_type_for_method ICEs\n-            tcx.sess.span_fatal(cm.span,\n-                 fmt!(\"method `%s` is declared as \\\n-                       static in its impl, but not in \\\n-                       its trait\", *tcx.sess.str_of(impl_m.ident)));\n-        }\n-        else if trait_m.self_ty == ast::sty_static {\n-            tcx.sess.span_fatal(cm.span,\n-                 fmt!(\"method `%s` is declared as \\\n-                       static in its trait, but not in \\\n-                       its impl\", *tcx.sess.str_of(impl_m.ident)));\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.self_ty, &impl_m.self_ty) {\n+        (&ast::sty_static, &ast::sty_static) => {}\n+        (&ast::sty_static, _) => {\n+            tcx.sess.span_err(\n+                cm.span,\n+                fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n+                      but not in the trait\",\n+                     *tcx.sess.str_of(trait_m.ident),\n+                     self_ty_to_str(impl_m.self_ty, tcx.sess.intr())));\n+            return;\n         }\n-        else {\n+        (_, &ast::sty_static) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s`'s self type does \\\n-                      not match the trait method's \\\n-                      self type\", *tcx.sess.str_of(impl_m.ident)));\n+                fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n+                      but not in the impl\",\n+                     *tcx.sess.str_of(trait_m.ident),\n+                     self_ty_to_str(trait_m.self_ty, tcx.sess.intr())));\n+            return;\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n         }\n     }\n \n@@ -539,6 +543,51 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                                                    bound_region: ty::br_self});\n     let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n \n+    // We are going to create a synthetic fn type that includes\n+    // both the method's self argument and its normal arguments.\n+    // So a method like `fn(&self, a: uint)` would be converted\n+    // into a function `fn(self: &T, a: uint)`.\n+    let mut trait_fn_args = ~[];\n+    let mut impl_fn_args = ~[];\n+\n+    // For both the trait and the impl, create an argument to\n+    // represent the self argument (unless this is a static method).\n+    // This argument will have the *transformed* self type.\n+    for trait_m.transformed_self_ty.each |&t| {\n+        trait_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+    }\n+    for impl_m.transformed_self_ty.each |&t| {\n+        impl_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+    }\n+\n+    // Add in the normal arguments.\n+    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n+    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n+\n+    // Create a bare fn type for trait/impl that includes self argument\n+    let trait_fty =\n+        ty::mk_bare_fn(\n+            tcx,\n+            ty::BareFnTy {purity: trait_m.fty.purity,\n+                          abis: trait_m.fty.abis,\n+                          sig: ty::FnSig {\n+                              bound_lifetime_names:\n+                                  copy trait_m.fty.sig.bound_lifetime_names,\n+                              inputs: trait_fn_args,\n+                              output: trait_m.fty.sig.output\n+                          }});\n+    let impl_fty =\n+        ty::mk_bare_fn(\n+            tcx,\n+            ty::BareFnTy {purity: impl_m.fty.purity,\n+                          abis: impl_m.fty.abis,\n+                          sig: ty::FnSig {\n+                              bound_lifetime_names:\n+                                  copy impl_m.fty.sig.bound_lifetime_names,\n+                              inputs: impl_fn_args,\n+                              output: impl_m.fty.sig.output\n+                          }});\n+\n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n     // - replace trait type parameters with those from `trait_substs`,\n@@ -547,7 +596,6 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        let impl_fty = ty::mk_bare_fn(tcx, copy impl_m.fty);\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n@@ -565,7 +613,6 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        let trait_fty = ty::mk_bare_fn(tcx, copy trait_m.fty);\n         debug!(\"trait_fty (pre-subst): %s substs=%s\",\n                trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)"}, {"sha": "3ff36a409a71f4ea8ee9fcf71c3479432e0ab2a9", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -180,12 +180,11 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        assert!(self.variance.is_some() || self.self_ty.is_borrowed());\n+        assert!(self.variance.is_some());\n         match self.variance {\n             None => {}  // must be borrowed self, so this is OK\n             Some(_) => {\n-                if !self.self_ty.is_borrowed() &&\n-                        !self.region_param_names.has_self() {\n+                if !self.region_param_names.has_self() {\n                     return Err(RegionError {\n                         msg: ~\"the `self` lifetime must be declared\",\n                         replacement: ty::re_bound(ty::br_self)"}, {"sha": "9b9e0e81b434684554c454ba130f483992ca3b6e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -750,6 +750,12 @@ impl Repr for ty::TraitStore {\n     }\n }\n \n+impl Repr for ty::vstore {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        vstore_to_str(tcx, *self)\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "3b2df24e7d9b8221315f306a78011e86d04dc41f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -1002,15 +1002,6 @@ pub enum self_ty_ {\n     sty_uniq(mutability)                       // `~self`\n }\n \n-impl self_ty_ {\n-    fn is_borrowed(&self) -> bool {\n-        match *self {\n-            sty_region(*) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]"}, {"sha": "886af694920f73bd05709b9324e96269f36e53f6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -454,13 +454,26 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n+    #[cfg(stage0)]\n     fn get_map(&self) -> &'self HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map\n         }\n     }\n \n+    // ugh: can't get this to compile with mut because of the\n+    // lack of flow sensitivity.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n+        match *self {\n+            BaseMapChain (~ref map) => map,\n+            ConsMapChain (~ref map,_) => map\n+        }\n+    }\n+\n // traits just don't work anywhere...?\n //pub impl Map<Name,SyntaxExtension> for MapChain {\n "}, {"sha": "1604c40f917635396868537979f561048f269d95", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -61,13 +61,24 @@ impl<T> OptVec<T> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get(&self, i: uint) -> &'self T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, i: uint) -> &'a T {\n+        match *self {\n+            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n+            Vec(ref v) => &v[i]\n+        }\n+    }\n+\n     fn is_empty(&self) -> bool {\n         self.len() == 0\n     }"}, {"sha": "36cd7c06842ae97ca8188ab0f3e6f7fe5f124455", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49de82cdca2064a909d3104f4e5eccacb0425fd0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=49de82cdca2064a909d3104f4e5eccacb0425fd0", "patch": "@@ -1633,6 +1633,10 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n+pub fn self_ty_to_str(self_ty: ast::self_ty_, intr: @ident_interner) -> ~str {\n+    to_str(self_ty, |a, b| { print_self_ty(a, b); () }, intr)\n+}\n+\n // Returns whether it printed anything\n pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n     match self_ty {"}]}