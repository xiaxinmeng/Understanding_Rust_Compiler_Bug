{"sha": "5449f5d29e175230a1285ebe92394f50c76e1df6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NDlmNWQyOWUxNzUyMzBhMTI4NWViZTkyMzk0ZjUwYzc2ZTFkZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-30T00:07:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-30T00:07:10Z"}, "message": "Auto merge of #24967 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "c89deb8cc68b46e6fc768e862c32bd3e830a31c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c89deb8cc68b46e6fc768e862c32bd3e830a31c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5449f5d29e175230a1285ebe92394f50c76e1df6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5449f5d29e175230a1285ebe92394f50c76e1df6", "html_url": "https://github.com/rust-lang/rust/commit/5449f5d29e175230a1285ebe92394f50c76e1df6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5449f5d29e175230a1285ebe92394f50c76e1df6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "551a74dddd84cf01440ee84148ebd18bc68bd7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/551a74dddd84cf01440ee84148ebd18bc68bd7c8", "html_url": "https://github.com/rust-lang/rust/commit/551a74dddd84cf01440ee84148ebd18bc68bd7c8"}, {"sha": "1b34c099a6a624947877315875018093587a8834", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b34c099a6a624947877315875018093587a8834", "html_url": "https://github.com/rust-lang/rust/commit/1b34c099a6a624947877315875018093587a8834"}], "stats": {"total": 11638, "additions": 6856, "deletions": 4782}, "files": [{"sha": "dbca73415fec62d11ef151ff41d2592d19d981a8", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -551,6 +551,7 @@ opt valgrind-rpass 1 \"run rpass-valgrind tests with valgrind\"\n opt docs     1 \"build standard library documentation\"\n opt compiler-docs     0 \"build compiler documentation\"\n opt optimize-tests 1 \"build tests with optimizations\"\n+opt debuginfo-tests 0 \"build tests with debugger metadata\"\n opt libcpp 1 \"build with llvm with libc++ instead of libstdc++ when using clang\"\n opt llvm-assertions 0 \"build LLVM with assertions\"\n opt debug-assertions 0 \"build with debugging assertions\""}, {"sha": "f391d8555fc2bff578a2a6c329b79cf71aa84542", "filename": "mk/tests.mk", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -632,6 +632,13 @@ ifndef CFG_DISABLE_OPTIMIZE_TESTS\n CTEST_RUSTC_FLAGS += -O\n endif\n \n+# Analogously to the above, whether to pass `-g` when compiling tests\n+# is a separate choice from whether to pass `-g` when building the\n+# compiler and standard library themselves.\n+CTEST_RUSTC_FLAGS := $$(subst -g,,$$(CTEST_RUSTC_FLAGS))\n+ifdef CFG_ENABLE_DEBUGINFO_TESTS\n+CTEST_RUSTC_FLAGS += -g\n+endif\n \n CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) := \\\n \t\t--compile-lib-path $$(HLIB$(1)_H_$(3)) \\"}, {"sha": "e740bf3c223aef1a34278be7c5811df77d63ff78", "filename": "src/doc/not_found.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -57,8 +57,12 @@ function populate_rust_search() {\n \n     // #18540, use a single token\n \n+    var a = document.createElement(\"a\");\n+    a.href = \"http://doc.rust-lang.org/core/?search=\" + encodeURIComponent(lt);\n+    a.textContent = lt;\n     var search = document.getElementById('core-search');\n-    search.innerHTML = \"<a href=\\\"http://doc.rust-lang.org/core/?search=\" + lt + \"\\\">\" + lt + \"</a>\";\n+    search.innerHTML = \"\";\n+    search.appendChild(a);\n }\n populate_site_search();\n populate_rust_search();"}, {"sha": "19cbd6f90a58146402abf38283d285cac38cae85", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -103,7 +103,7 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-Whitespace is any non-empty string containing any the following characters:\n+Whitespace is any non-empty string containing only the following characters:\n \n - `U+0020` (space, `' '`)\n - `U+0009` (tab, `'\\t'`)\n@@ -1897,8 +1897,8 @@ release builds.\n \n There are two kinds of configuration options, one that is either defined or not\n (`#[cfg(foo)]`), and the other that contains a string that can be checked\n-against (`#[cfg(bar = \"baz\")]` (currently only compiler-defined configuration\n-options can have the latter form).\n+against (`#[cfg(bar = \"baz\")]`). Currently, only compiler-defined configuration\n+options can have the latter form.\n \n ```\n // The function is only included in the build when compiling for OSX"}, {"sha": "280665af787423b67abbce2ffddc9e4962e63742", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -127,7 +127,7 @@ vector. When we try to compile this program, we get an error:\n \n ```text\n error: cannot borrow `x` as mutable because it is also borrowed as immutable\n-    x.push(4);\n+    x.push(\"foo\");\n     ^\n note: previous borrow of `x` occurs here; the immutable borrow prevents\n subsequent moves or mutable borrows of `x` until the borrow ends"}, {"sha": "887965375932b3fe4953179a96d4dd54ec23c32e", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -13,7 +13,7 @@ pub fn add_two(a: i32) -> i32 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::*;\n     use test::Bencher;\n "}, {"sha": "d504fab206ddfd185d65c4b6362e5395eb8b7e9b", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -765,7 +765,7 @@ as `unimplemented!` until you\u2019re ready to write them.\n # Procedural macros\n \n If Rust\u2019s macro system can\u2019t do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n+[compiler plugin](compiler-plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax"}, {"sha": "ac43055a7c4a5ff65e3110ad4b5765fb19a0756c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -139,6 +139,21 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_fence_rel();\n     pub fn atomic_fence_acqrel();\n \n+    /// A compiler-only memory barrier.\n+    ///\n+    /// Memory accesses will never be reordered across this barrier by the compiler,\n+    /// but no instructions will be emitted for it. This is appropriate for operations\n+    /// on the same thread that may be preempted, such as when interacting with signal\n+    /// handlers.\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_acq();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_rel();\n+    #[cfg(not(stage0))]     // SNAP 857ef6e\n+    pub fn atomic_singlethreadfence_acqrel();\n+\n     /// Aborts the execution of the process.\n     pub fn abort() -> !;\n \n@@ -255,12 +270,17 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn owns_managed<T>() -> bool;\n \n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n-    /// undefined behaviour.\n+    /// Calculates the offset from a pointer.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Both the starting and resulting pointer must be either in bounds or one\n+    /// byte past the end of an allocated object. If either pointer is out of\n+    /// bounds or arithmetic overflow occurs then any further use of the\n+    /// returned value will result in undefined behavior.\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -562,3 +582,20 @@ extern \"rust-intrinsic\" {\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     pub fn discriminant_value<T>(v: &T) -> u64;\n }\n+\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    /// Performs an unchecked signed division, which results in undefined behavior,\n+    /// in cases where y == 0, or x == int::MIN and y == -1\n+    pub fn unchecked_sdiv<T>(x: T, y: T) -> T;\n+    /// Performs an unchecked unsigned division, which results in undefined behavior,\n+    /// in cases where y == 0\n+    pub fn unchecked_udiv<T>(x: T, y: T) -> T;\n+\n+    /// Returns the remainder of an unchecked signed division, which results in\n+    /// undefined behavior, in cases where y == 0, or x == int::MIN and y == -1\n+    pub fn unchecked_urem<T>(x: T, y: T) -> T;\n+    /// Returns the remainder of an unchecked signed division, which results in\n+    /// undefined behavior, in cases where y == 0\n+    pub fn unchecked_srem<T>(x: T, y: T) -> T;\n+}"}, {"sha": "b8638c5b09be257ea87e9c7db993ea0c930328d5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -745,7 +745,20 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn trailing_zeros(self) -> u32 {\n-            unsafe { $cttz(self as $ActualT) as u32 }\n+            // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+            // emits two conditional moves on x86_64. By promoting the value to\n+            // u16 and setting bit 8, we get better code without any conditional\n+            // operations.\n+            // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+            // pending, remove this workaround once LLVM generates better code\n+            // for cttz8.\n+            unsafe {\n+                if $BITS == 8 {\n+                    intrinsics::cttz16(self as u16 | 0x100) as u32\n+                } else {\n+                    $cttz(self as $ActualT) as u32\n+                }\n+            }\n         }\n \n         /// Shifts the bits to the left by a specified amount, `n`,"}, {"sha": "47c029f11b38fad65971f9822d532aae935a161b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -284,9 +284,10 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n-    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n-    /// the pointer is used.\n+    /// Both the starting and resulting pointer must be either in bounds or one\n+    /// byte past the end of an allocated object. If either pointer is out of\n+    /// bounds or arithmetic overflow occurs then\n+    /// any further use of the returned value will result in undefined behavior.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {"}, {"sha": "66945ad251f1ed3dc9a68912aa699a0e2e44dcbe", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -219,7 +219,6 @@ fn test_ord() {\n     assert!(big > None);\n }\n \n-/* FIXME(#20575)\n #[test]\n fn test_collect() {\n     let v: Option<Vec<isize>> = (0..0).map(|_| Some(0)).collect();\n@@ -241,28 +240,26 @@ fn test_collect() {\n \n     assert!(v == None);\n }\n-*/\n+\n \n #[test]\n fn test_cloned() {\n-    let val1 = 1u32;\n-    let mut val2 = 2u32;\n-    let val1_ref = &val1;\n+    let val = 1u32;\n+    let val_ref = &val;\n     let opt_none: Option<&'static u32> = None;\n-    let opt_ref = Some(&val1);\n-    let opt_ref_ref = Some(&val1_ref);\n-    let opt_mut_ref = Some(&mut val2);\n+    let opt_ref = Some(&val);\n+    let opt_ref_ref = Some(&val_ref);\n \n     // None works\n     assert_eq!(opt_none.clone(), None);\n     assert_eq!(opt_none.cloned(), None);\n \n     // Immutable ref works\n-    assert_eq!(opt_ref.clone(), Some(&val1));\n+    assert_eq!(opt_ref.clone(), Some(&val));\n     assert_eq!(opt_ref.cloned(), Some(1u32));\n \n     // Double Immutable ref works\n-    assert_eq!(opt_ref_ref.clone(), Some(&val1_ref));\n-    assert_eq!(opt_ref_ref.clone().cloned(), Some(&val1));\n+    assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n+    assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1u32));\n }"}, {"sha": "3fdb102875332f7aa4b26db6993abfb9ab5c6151", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn op1() -> Result<isize, &'static str> { Ok(666) }\n-pub fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n+fn op1() -> Result<isize, &'static str> { Ok(666) }\n+fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n #[test]\n-pub fn test_and() {\n+fn test_and() {\n     assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n     assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n@@ -23,7 +23,7 @@ pub fn test_and() {\n }\n \n #[test]\n-pub fn test_and_then() {\n+fn test_and_then() {\n     assert_eq!(op1().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap(), 667);\n     assert_eq!(op1().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n@@ -35,7 +35,7 @@ pub fn test_and_then() {\n }\n \n #[test]\n-pub fn test_or() {\n+fn test_or() {\n     assert_eq!(op1().or(Ok::<_, &'static str>(667)).unwrap(), 666);\n     assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n \n@@ -44,7 +44,7 @@ pub fn test_or() {\n }\n \n #[test]\n-pub fn test_or_else() {\n+fn test_or_else() {\n     assert_eq!(op1().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 666);\n     assert_eq!(op1().or_else(|e| Err::<isize, &'static str>(e)).unwrap(), 666);\n \n@@ -54,18 +54,17 @@ pub fn test_or_else() {\n }\n \n #[test]\n-pub fn test_impl_map() {\n+fn test_impl_map() {\n     assert!(Ok::<isize, isize>(1).map(|x| x + 1) == Ok(2));\n     assert!(Err::<isize, isize>(1).map(|x| x + 1) == Err(1));\n }\n \n #[test]\n-pub fn test_impl_map_err() {\n+fn test_impl_map_err() {\n     assert!(Ok::<isize, isize>(1).map_err(|x| x + 1) == Ok(1));\n     assert!(Err::<isize, isize>(1).map_err(|x| x + 1) == Err(2));\n }\n \n-/* FIXME(#20575)\n #[test]\n fn test_collect() {\n     let v: Result<Vec<isize>, ()> = (0..0).map(|_| Ok::<isize, ()>(0)).collect();\n@@ -86,10 +85,9 @@ fn test_collect() {\n     let v: Result<Vec<()>, isize> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n-*/\n \n #[test]\n-pub fn test_fmt_default() {\n+fn test_fmt_default() {\n     let ok: Result<isize, &'static str> = Ok(100);\n     let err: Result<isize, &'static str> = Err(\"Err\");\n \n@@ -100,7 +98,7 @@ pub fn test_fmt_default() {\n }\n \n #[test]\n-pub fn test_unwrap_or() {\n+fn test_unwrap_or() {\n     let ok: Result<isize, &'static str> = Ok(100);\n     let ok_err: Result<isize, &'static str> = Err(\"Err\");\n \n@@ -109,7 +107,7 @@ pub fn test_unwrap_or() {\n }\n \n #[test]\n-pub fn test_unwrap_or_else() {\n+fn test_unwrap_or_else() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50"}, {"sha": "2ef9dfd4da8dae56fff54612e90165a321bb0c27", "filename": "src/librustc/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -71,7 +71,7 @@ The rustc crate itself consists of the following submodules\n - util: ubiquitous types and helper functions\n - lib: bindings to LLVM\n \n-The entry-point for the compiler is main() in the librustc_trans\n+The entry-point for the compiler is main() in the librustc_driver\n crate.\n \n The 3 central data structures:"}, {"sha": "92be6ac6be54fe707d8a5fa745945b0e73d6730d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -355,6 +355,22 @@ enum Method { GET, POST }\n ```\n \"##,\n \n+E0265: r##\"\n+This error indicates that a static or constant references itself.\n+All statics and constants need to resolve to a value in an acyclic manner.\n+\n+For example, neither of the following can be sensibly compiled:\n+\n+```\n+const X: u32 = X;\n+```\n+\n+```\n+const X: u32 = Y;\n+const Y: u32 = X;\n+```\n+\"##,\n+\n E0267: r##\"\n This error indicates the use of loop keyword (break or continue) inside a\n closure but outside of any loop. Break and continue can be used as normal\n@@ -500,7 +516,6 @@ register_diagnostics! {\n     E0262, // illegal lifetime parameter name\n     E0263, // lifetime name declared twice in same scope\n     E0264, // unknown external lang item\n-    E0265, // recursive constant\n     E0266, // expected item\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging"}, {"sha": "aeb08464ff566554d9a0b6cf21615c1c59a8063c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -25,21 +25,23 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(fs_canonicalize)]\n #![feature(hash)]\n+#![feature(into_cow)]\n #![feature(libc)]\n+#![feature(path_ext)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]\n@@ -138,7 +140,6 @@ pub mod plugin;\n pub mod lint;\n \n pub mod util {\n-    pub use rustc_back::fs;\n     pub use rustc_back::sha2;\n \n     pub mod common;"}, {"sha": "12112fd45ebe9b2d0911992f79cc1e7bd4c0b38e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -21,8 +21,10 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n \n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::rc::Rc;\n+use std::fs;\n+\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -32,7 +34,6 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n-use util::fs;\n use log;\n \n pub struct CrateReader<'a> {\n@@ -322,7 +323,7 @@ impl<'a> CrateReader<'a> {\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(&l[..])).ok();\n+                    let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n                 });"}, {"sha": "7d8cf5b22a9016c6b9dec3ff8a61b147a6ee6ca5", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -18,7 +18,6 @@ use std::fs;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n \n-use util::fs as myfs;\n use session::search_paths::{SearchPaths, PathKind};\n \n #[derive(Copy, Clone)]\n@@ -191,7 +190,7 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n         path.and_then(|path| {\n-            match myfs::realpath(&path) {\n+            match fs::canonicalize(&path) {\n                 Ok(canon) => Some(canon),\n                 Err(e) => panic!(\"failed to get realpath: {}\", e),\n             }"}, {"sha": "062a156637a358d1af5b286c08aad6791f02281f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -225,12 +225,12 @@ use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use util::fs;\n use util::common;\n use rustc_back::target::Target;\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::fs;\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -430,9 +430,9 @@ impl<'a> Context<'a> {\n                                  .or_insert_with(|| (HashMap::new(), HashMap::new()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n-                rlibs.insert(fs::realpath(path).unwrap(), kind);\n+                rlibs.insert(fs::canonicalize(path).unwrap(), kind);\n             } else {\n-                dylibs.insert(fs::realpath(path).unwrap(), kind);\n+                dylibs.insert(fs::canonicalize(path).unwrap(), kind);\n             }\n \n             FileMatches\n@@ -660,10 +660,10 @@ impl<'a> Context<'a> {\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::realpath(&loc).unwrap(),\n+                    rlibs.insert(fs::canonicalize(&loc).unwrap(),\n                                  PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::realpath(&loc).unwrap(),\n+                    dylibs.insert(fs::canonicalize(&loc).unwrap(),\n                                   PathKind::ExternFlag);\n                 }\n             }"}, {"sha": "5b0eea6bcc51678466a24364db67707f4ef8b08b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -46,33 +46,35 @@ bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     flags ConstQualif: u8 {\n         // Const rvalue which can be placed behind a reference.\n-        const PURE_CONST          = 0b000000,\n+        const PURE_CONST         = 0,\n         // Inner mutability (can not be placed behind a reference) or behind\n         // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM         = 0b000001,\n+        const MUTABLE_MEM        = 1 << 0,\n         // Constant value with a type that implements Drop. Can be copied\n         // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP          = 0b000010,\n+        const NEEDS_DROP         = 1 << 1,\n         // Even if the value can be placed in static memory, copying it from\n         // there is more expensive than in-place instantiation, and/or it may\n         // be too large. This applies to [T; N] and everything containing it.\n         // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE     = 0b000100,\n+        const PREFER_IN_PLACE    = 1 << 2,\n         // May use more than 0 bytes of memory, doesn't impact the constness\n         // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED      = 0b001000,\n+        const NON_ZERO_SIZED     = 1 << 3,\n         // Actually borrowed, has to always be in static memory. Does not\n         // propagate, and requires the expression to behave like a 'static\n         // lvalue. The set of expressions with this flag is the minimum\n         // that have to be promoted.\n-        const HAS_STATIC_BORROWS  = 0b010000,\n+        const HAS_STATIC_BORROWS = 1 << 4,\n         // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST           = 0b100000,\n+        const NOT_CONST          = 1 << 5,\n \n         // Borrowing the expression won't produce &'static T if any of these\n         // bits are set, though the value could be copied from static memory\n         // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = MUTABLE_MEM.bits | NEEDS_DROP.bits | NOT_CONST.bits\n+        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n+                                   ConstQualif::NEEDS_DROP.bits |\n+                                   ConstQualif::NOT_CONST.bits\n     }\n }\n \n@@ -102,7 +104,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n         let r = f(self);\n         self.mode = old_mode;\n         self.qualif = old_qualif;\n@@ -126,7 +128,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Entry::Occupied(entry) => return *entry.get(),\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n-                entry.insert(PURE_CONST);\n+                entry.insert(ConstQualif::PURE_CONST);\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -271,7 +273,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n \n         let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n         check_expr(self, ex, node_ty);\n@@ -287,7 +289,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.visit_expr(&**callee);\n                 // The callee's size doesn't count in the call.\n                 let added = self.qualif - inner;\n-                self.qualif = inner | (added - NON_ZERO_SIZED);\n+                self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n             ast::ExprRepeat(ref element, _) => {\n                 self.visit_expr(&**element);\n@@ -298,7 +300,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n-                    self.qualif = self.qualif - (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+                    self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n                 }\n             }\n             ast::ExprMatch(ref discr, ref arms, _) => {\n@@ -325,7 +327,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n                 match node_ty.sty {\n                     ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n-                        if !self.qualif.intersects(NOT_CONST) {\n+                        if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n@@ -348,11 +350,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // Constants cannot be borrowed if they contain interior mutability as\n                 // it means that our \"silent insertion of statics\" could change\n                 // initializer values (very bad).\n-                // If the type doesn't have interior mutability, then `MUTABLE_MEM` has\n+                // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n                 let tc = ty::type_contents(self.tcx, node_ty);\n-                if self.qualif.intersects(MUTABLE_MEM) && tc.interior_unsafe() {\n-                    outer = outer | NOT_CONST;\n+                if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n+                    outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n                         self.tcx.sess.span_err(ex.span,\n                             \"cannot borrow a constant which contains \\\n@@ -361,32 +363,32 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n                 // as that will end up pointing to the stack instead.\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.qualif = self.qualif - PREFER_IN_PLACE;\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.qualif = self.qualif - ConstQualif::PREFER_IN_PLACE;\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             Some(ast::MutMutable) => {\n                 // `&mut expr` means expr could be mutated, unless it's zero-sized.\n-                if self.qualif.intersects(NON_ZERO_SIZED) {\n+                if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n                     if self.mode == Mode::Var {\n-                        outer = outer | NOT_CONST;\n-                        self.add_qualif(MUTABLE_MEM);\n+                        outer = outer | ConstQualif::NOT_CONST;\n+                        self.add_qualif(ConstQualif::MUTABLE_MEM);\n                     } else {\n                         span_err!(self.tcx.sess, ex.span, E0017,\n                             \"references in {}s may only refer \\\n                              to immutable values\", self.msg())\n                     }\n                 }\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             None => {}\n         }\n         self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n         // Don't propagate certain flags.\n-        self.qualif = outer | (self.qualif - HAS_STATIC_BORROWS);\n+        self.qualif = outer | (self.qualif - ConstQualif::HAS_STATIC_BORROWS);\n     }\n }\n \n@@ -401,7 +403,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match node_ty.sty {\n         ty::ty_struct(did, _) |\n         ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n-            v.add_qualif(NEEDS_DROP);\n+            v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n                                     &format!(\"{}s are not allowed to have destructors\",\n@@ -416,15 +418,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n         ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                             \"user-defined operators are not allowed in {}s\", v.msg());\n             }\n         }\n         ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0010,\n                           \"allocations are not allowed in {}s\", v.msg());\n@@ -434,7 +436,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match ty::node_id_to_type(v.tcx, ptr.id).sty {\n                 ty::ty_ptr(_) => {\n                     // This shouldn't be allowed in constants at all.\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                 }\n                 _ => {}\n             }\n@@ -447,15 +449,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 ty::type_is_unsafe_ptr(toty) ||\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0012,\n                               \"can not cast to `{}` in {}s\",\n                               ppaux::ty_to_string(v.tcx, toty), v.msg());\n                 }\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0018,\n                               \"can not cast a pointer to an integer in {}s\", v.msg());\n@@ -467,17 +469,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n                     // Count the discriminator or function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStruct(_)) => {\n                     if let ty::ty_bare_fn(..) = node_ty.sty {\n                         // Count the function pointer.\n-                        v.add_qualif(NON_ZERO_SIZED);\n+                        v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n                 Some(def::DefFn(..)) | Some(def::DefMethod(..)) => {\n                     // Count the function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStatic(..)) => {\n                     match v.mode {\n@@ -487,7 +489,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                 \"constants cannot refer to other statics, \\\n                                  insert an intermediate constant instead\");\n                         }\n-                        Mode::Var => v.add_qualif(NOT_CONST)\n+                        Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n                 Some(def::DefConst(did)) |\n@@ -503,7 +505,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     }\n                 }\n                 def => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         debug!(\"(checking const) found bad def: {:?}\", def);\n                         span_err!(v.tcx.sess, e.span, E0014,\n@@ -530,10 +532,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefStruct(..)) => {}\n                 Some(def::DefVariant(..)) => {\n                     // Count the discriminator.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 _ => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         span_err!(v.tcx.sess, e.span, E0015,\n                                   \"function calls in {}s are limited to \\\n@@ -545,7 +547,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             let mut block_span_err = |span| {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in {}s are limited to items and \\\n@@ -574,17 +576,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprStruct(..) => {\n             let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n             if did == v.tcx.lang_items.unsafe_cell_type() {\n-                v.add_qualif(MUTABLE_MEM);\n+                v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }\n \n         ast::ExprLit(_) |\n         ast::ExprAddrOf(..) => {\n-            v.add_qualif(NON_ZERO_SIZED);\n+            v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n         }\n \n         ast::ExprRepeat(..) => {\n-            v.add_qualif(PREFER_IN_PLACE);\n+            v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n         }\n \n         ast::ExprClosure(..) => {\n@@ -593,7 +595,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }\n \n@@ -631,7 +633,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |\n         ast::ExprMac(_) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0019,\n                           \"{} contains unimplemented expression type\", v.msg());\n@@ -644,7 +646,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n-        qualif: NOT_CONST,\n+        qualif: ConstQualif::NOT_CONST,\n         rvalue_borrows: NodeMap()\n     }, tcx.map.krate());\n "}, {"sha": "c4ab89e3b4da07ef0de3663309127aeda946a7b9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -838,20 +838,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n         let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(check_const::NOT_CONST);\n+                               .unwrap_or(check_const::ConstQualif::NOT_CONST);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n         let qualif = match expr_ty.sty {\n             ty::ty_vec(_, Some(0)) => qualif,\n-            _ => check_const::NOT_CONST\n+            _ => check_const::ConstQualif::NOT_CONST\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = match qualif & check_const::NON_STATIC_BORROWS {\n-            check_const::PURE_CONST => ty::ReStatic,\n+        let re = match qualif & check_const::ConstQualif::NON_STATIC_BORROWS {\n+            check_const::ConstQualif::PURE_CONST => ty::ReStatic,\n             _ => self.temporary_scope(id),\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);"}, {"sha": "33ba21bc7b15445c16a860328e2ca10e8f2f8b01", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -848,16 +848,18 @@ impl<'tcx> ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS       = 0b0,\n-        const HAS_PARAMS          = 0b1,\n-        const HAS_SELF            = 0b10,\n-        const HAS_TY_INFER        = 0b100,\n-        const HAS_RE_INFER        = 0b1000,\n-        const HAS_RE_LATE_BOUND   = 0b10000,\n-        const HAS_REGIONS         = 0b100000,\n-        const HAS_TY_ERR          = 0b1000000,\n-        const HAS_PROJECTION      = 0b10000000,\n-        const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n+        const NO_TYPE_FLAGS     = 0,\n+        const HAS_PARAMS        = 1 << 0,\n+        const HAS_SELF          = 1 << 1,\n+        const HAS_TY_INFER      = 1 << 2,\n+        const HAS_RE_INFER      = 1 << 3,\n+        const HAS_RE_LATE_BOUND = 1 << 4,\n+        const HAS_REGIONS       = 1 << 5,\n+        const HAS_TY_ERR        = 1 << 6,\n+        const HAS_PROJECTION    = 1 << 7,\n+        const NEEDS_SUBST       = TypeFlags::HAS_PARAMS.bits |\n+                                  TypeFlags::HAS_SELF.bits |\n+                                  TypeFlags::HAS_REGIONS.bits,\n     }\n }\n \n@@ -890,8 +892,8 @@ macro_rules! sty_debug_print {\n                         ty::ty_err => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::HAS_RE_INFER);\n-                    let ty = t.flags.intersects(ty::HAS_TY_INFER);\n+                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -993,23 +995,23 @@ impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n }\n \n pub fn type_has_params(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PARAMS)\n+    ty.flags.intersects(TypeFlags::HAS_PARAMS)\n }\n pub fn type_has_self(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_SELF)\n+    ty.flags.intersects(TypeFlags::HAS_SELF)\n }\n pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER)\n }\n pub fn type_needs_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n pub fn type_has_projection(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PROJECTION)\n+    ty.flags.intersects(TypeFlags::HAS_PROJECTION)\n }\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_RE_LATE_BOUND)\n+    ty.flags.intersects(TypeFlags::HAS_RE_LATE_BOUND)\n }\n \n /// An \"escaping region\" is a bound region whose binder is not part of `t`.\n@@ -2810,7 +2812,7 @@ struct FlagComputation {\n \n impl FlagComputation {\n     fn new() -> FlagComputation {\n-        FlagComputation { flags: NO_TYPE_FLAGS, depth: 0 }\n+        FlagComputation { flags: TypeFlags::NO_TYPE_FLAGS, depth: 0 }\n     }\n \n     fn for_sty(st: &sty) -> FlagComputation {\n@@ -2855,20 +2857,20 @@ impl FlagComputation {\n \n             // You might think that we could just return ty_err for\n             // any type containing ty_err as a component, and get\n-            // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n             &ty_err => {\n-                self.add_flags(HAS_TY_ERR)\n+                self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n             &ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n-                    self.add_flags(HAS_SELF);\n+                    self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n-                    self.add_flags(HAS_PARAMS);\n+                    self.add_flags(TypeFlags::HAS_PARAMS);\n                 }\n             }\n \n@@ -2877,15 +2879,15 @@ impl FlagComputation {\n             }\n \n             &ty_infer(_) => {\n-                self.add_flags(HAS_TY_INFER)\n+                self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n             &ty_enum(_, substs) | &ty_struct(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n             &ty_projection(ref data) => {\n-                self.add_flags(HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n@@ -2949,11 +2951,11 @@ impl FlagComputation {\n     }\n \n     fn add_region(&mut self, r: Region) {\n-        self.add_flags(HAS_REGIONS);\n+        self.add_flags(TypeFlags::HAS_REGIONS);\n         match r {\n-            ty::ReInfer(_) => { self.add_flags(HAS_RE_INFER); }\n+            ty::ReInfer(_) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n             ty::ReLateBound(debruijn, _) => {\n-                self.add_flags(HAS_RE_LATE_BOUND);\n+                self.add_flags(TypeFlags::HAS_RE_LATE_BOUND);\n                 self.add_depth(debruijn.depth);\n             }\n             _ => { }\n@@ -3307,11 +3309,11 @@ pub fn type_is_nil(ty: Ty) -> bool {\n }\n \n pub fn type_is_error(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_ERR)\n+    ty.flags.intersects(TypeFlags::HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: Ty) -> bool {\n-    ty.flags.intersects(NEEDS_SUBST)\n+    ty.flags.intersects(TypeFlags::NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {"}, {"sha": "b999929c4af9e4a5a24d75e4c15042865f9aa1ae", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -755,11 +755,14 @@ mod opt {\n     pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n     pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n     pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n+    pub fn flagmulti(a: S, b: S, c: S)     -> R { stable(getopts::optflagmulti(a, b, c)) }\n+\n \n     pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n     pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n     pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n     pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n+    pub fn flagmulti_u(a: S, b: S, c: S)     -> R { unstable(getopts::optflagmulti(a, b, c)) }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n@@ -786,8 +789,8 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|file-names|sysroot]\"),\n-        opt::flag(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n-        opt::flag(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::flagmulti(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flagmulti(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n         opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),"}, {"sha": "37e3efb4d83fe112a39c11be151adffb76fdb93a", "filename": "src/librustc_back/fs.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=551a74dddd84cf01440ee84148ebd18bc68bd7c8", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use std::path::{Path, PathBuf};\n-\n-#[cfg(windows)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    Ok(original.to_path_buf())\n-}\n-\n-#[cfg(unix)]\n-pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    use libc;\n-    use std::ffi::{OsString, CString};\n-    use std::os::unix::prelude::*;\n-\n-    extern {\n-        fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n-                    -> *mut libc::c_char;\n-    }\n-\n-    let path = try!(CString::new(original.as_os_str().as_bytes()));\n-    let mut buf = vec![0u8; 16 * 1024];\n-    unsafe {\n-        let r = realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error())\n-        }\n-    }\n-    let p = buf.iter().position(|i| *i == 0).unwrap();\n-    buf.truncate(p);\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n-}\n-\n-#[cfg(all(not(windows), test))]\n-mod tests {\n-    use tempdir::TempDir;\n-    use std::fs::{self, File};\n-    use super::realpath;\n-\n-    #[test]\n-    fn realpath_works() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-        let file = tmpdir.join(\"test\");\n-        let dir = tmpdir.join(\"test2\");\n-        let link = dir.join(\"link\");\n-        let linkdir = tmpdir.join(\"test3\");\n-\n-        File::create(&file).unwrap();\n-        fs::create_dir(&dir).unwrap();\n-        fs::soft_link(&file, &link).unwrap();\n-        fs::soft_link(&dir, &linkdir).unwrap();\n-\n-        assert_eq!(realpath(&tmpdir).unwrap(), tmpdir);\n-        assert_eq!(realpath(&file).unwrap(), file);\n-        assert_eq!(realpath(&link).unwrap(), file);\n-        assert_eq!(realpath(&linkdir).unwrap(), dir);\n-        assert_eq!(realpath(&linkdir.join(\"link\")).unwrap(), file);\n-    }\n-\n-    #[test]\n-    fn realpath_works_tricky() {\n-        let tmpdir = TempDir::new(\"rustc-fs\").unwrap();\n-        let tmpdir = realpath(tmpdir.path()).unwrap();\n-\n-        let a = tmpdir.join(\"a\");\n-        let b = a.join(\"b\");\n-        let c = b.join(\"c\");\n-        let d = a.join(\"d\");\n-        let e = d.join(\"e\");\n-        let f = a.join(\"f\");\n-\n-        fs::create_dir_all(&b).unwrap();\n-        fs::create_dir_all(&d).unwrap();\n-        File::create(&f).unwrap();\n-        fs::soft_link(\"../d/e\", &c).unwrap();\n-        fs::soft_link(\"../f\", &e).unwrap();\n-\n-        assert_eq!(realpath(&c).unwrap(), f);\n-        assert_eq!(realpath(&e).unwrap(), f);\n-    }\n-}"}, {"sha": "3e55f7f8045b59b60ee38723f34655e43f987924", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -41,6 +41,7 @@\n #![feature(path_ext)]\n #![feature(step_by)]\n #![feature(libc)]\n+#![feature(fs_canonicalize)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n@@ -53,7 +54,6 @@ pub mod abi;\n pub mod archive;\n pub mod tempdir;\n pub mod arm;\n-pub mod fs;\n pub mod mips;\n pub mod mipsel;\n pub mod rpath;"}, {"sha": "6674d3135a0bdb671dbd621a1979dd97df196fca", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,8 +10,8 @@\n \n use std::collections::HashSet;\n use std::env;\n-use std::io;\n use std::path::{Path, PathBuf};\n+use std::fs;\n use syntax::ast;\n \n pub struct RPathConfig<'a> {\n@@ -20,7 +20,6 @@ pub struct RPathConfig<'a> {\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n     pub get_install_prefix_lib_path: &'a mut FnMut() -> PathBuf,\n-    pub realpath: &'a mut FnMut(&Path) -> io::Result<PathBuf>,\n }\n \n pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n@@ -95,11 +94,11 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     };\n \n     let cwd = env::current_dir().unwrap();\n-    let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n+    let mut lib = fs::canonicalize(&cwd.join(lib)).unwrap_or(cwd.join(lib));\n     lib.pop();\n     let mut output = cwd.join(&config.out_filename);\n     output.pop();\n-    let output = (config.realpath)(&output).unwrap();\n+    let output = fs::canonicalize(&output).unwrap_or(output);\n     let relative = path_relative_from(&lib, &output)\n         .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -231,7 +230,6 @@ mod tests {\n                 is_like_osx: true,\n                 out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));\n@@ -243,7 +241,6 @@ mod tests {\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 has_rpath: true,\n                 is_like_osx: false,\n-                realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n             let res = get_rpath_relative_to_output(config,\n                                                    Path::new(\"lib/libstd.so\"));"}, {"sha": "67194e7ac5c7c8c43832803f755df8aae57081a5", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -11,10 +11,6 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n-    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n-    base.is_like_android = true;\n-    base.position_independent_executables = true;\n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n                       f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n@@ -25,6 +21,6 @@ pub fn target() -> Target {\n         arch: \"aarch64\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"\".to_string(),\n-        options: base,\n+        options: super::android_base::opts(),\n     }\n }"}, {"sha": "2883ffd6e9f2244ccd24b24dea153eeac6422792", "filename": "src/librustc_back/target/android_base.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fandroid_base.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut base = super::linux_base::opts();\n+    // Many of the symbols defined in compiler-rt are also defined in libgcc.\n+    // Android's linker doesn't like that by default.\n+    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n+    base.is_like_android = true;\n+    base.position_independent_executables = true;\n+    base\n+}"}, {"sha": "cbaa2b205b05512c36f660e5d10ec2a989653b86", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -11,21 +11,13 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::android_base::opts();\n     base.features = \"+v7\".to_string();\n-    // Many of the symbols defined in compiler-rt are also defined in libgcc.  Android\n-    // linker doesn't like that by default.\n-    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n-    base.is_like_android = true;\n-    // FIXME #17437 (and #17448): Android doesn't support position dependent executables anymore.\n-    base.position_independent_executables = false;\n \n     Target {\n-        data_layout: \"e-p:32:32:32\\\n-                      -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n-                      -f32:32:32-f64:64:64\\\n-                      -v64:64:64-v128:64:128\\\n-                      -a:0:64-n32\".to_string(),\n+        data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:64:128-a:0:64-\\\n+                      n32\".to_string(),\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),"}, {"sha": "c5f1882fa1dd7d33409db8a850b246e2bbc20efb", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -46,18 +46,19 @@\n //! specified by the target, rather than replace.\n \n use serialize::json::Json;\n-use syntax::{diagnostic, abi};\n use std::default::Default;\n use std::io::prelude::*;\n+use syntax::{diagnostic, abi};\n \n-mod windows_base;\n-mod linux_base;\n+mod android_base;\n mod apple_base;\n mod apple_ios_base;\n-mod freebsd_base;\n-mod dragonfly_base;\n mod bitrig_base;\n+mod dragonfly_base;\n+mod freebsd_base;\n+mod linux_base;\n mod openbsd_base;\n+mod windows_base;\n \n /// Everything `rustc` knows about how to compile for a specific target.\n ///"}, {"sha": "6d23cad26cb37e76d07362fbe3f31b5e1893b1af", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -12,6 +12,7 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"rustc_bitflags\"]\n+#![feature(associated_consts)]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -34,26 +35,27 @@\n ///\n /// ```{.rust}\n /// # #![feature(rustc_private)]\n+/// # #![feature(associated_consts)]\n /// #[macro_use] extern crate rustc_bitflags;\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         const FLAG_A       = 0b00000001,\n ///         const FLAG_B       = 0b00000010,\n ///         const FLAG_C       = 0b00000100,\n-///         const FLAG_ABC     = FLAG_A.bits\n-///                            | FLAG_B.bits\n-///                            | FLAG_C.bits,\n+///         const FLAG_ABC     = Flags::FLAG_A.bits\n+///                            | Flags::FLAG_B.bits\n+///                            | Flags::FLAG_C.bits,\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FLAG_A | FLAG_C;\n-///     let e2 = FLAG_B | FLAG_C;\n-///     assert!((e1 | e2) == FLAG_ABC);   // union\n-///     assert!((e1 & e2) == FLAG_C);     // intersection\n-///     assert!((e1 - e2) == FLAG_A);     // set difference\n-///     assert!(!e2 == FLAG_A);           // set complement\n+///     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+///     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+///     assert!((e1 | e2) == Flags::FLAG_ABC); // union\n+///     assert!((e1 & e2) == Flags::FLAG_C);   // intersection\n+///     assert!((e1 - e2) == Flags::FLAG_A);   // set difference\n+///     assert!(!e2 == Flags::FLAG_A);         // set complement\n /// }\n /// ```\n ///\n@@ -86,7 +88,7 @@\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FLAG_A | FLAG_B;\n+///     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{:?}\", flags), \"hi!\");\n@@ -144,9 +146,9 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n-\n         impl $BitFlags {\n+            $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n             /// Returns an empty set of flags.\n             #[inline]\n             pub fn empty() -> $BitFlags {\n@@ -314,9 +316,9 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const FlagABC     = FlagA.bits\n-                               | FlagB.bits\n-                               | FlagC.bits,\n+            const FlagABC     = Flags::FlagA.bits\n+                               | Flags::FlagB.bits\n+                               | Flags::FlagC.bits,\n         }\n     }\n \n@@ -329,52 +331,52 @@ mod tests {\n     #[test]\n     fn test_bits(){\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(FlagA.bits(), 0b00000001);\n-        assert_eq!(FlagABC.bits(), 0b00000111);\n+        assert_eq!(Flags::FlagA.bits(), 0b00000001);\n+        assert_eq!(Flags::FlagABC.bits(), 0b00000111);\n \n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherFlag.bits(), !0);\n+        assert_eq!(AnotherSetOfFlags::AnotherFlag.bits(), !0);\n     }\n \n     #[test]\n     fn test_from_bits() {\n         assert!(Flags::from_bits(0) == Some(Flags::empty()));\n-        assert!(Flags::from_bits(0b1) == Some(FlagA));\n-        assert!(Flags::from_bits(0b10) == Some(FlagB));\n-        assert!(Flags::from_bits(0b11) == Some(FlagA | FlagB));\n+        assert!(Flags::from_bits(0b1) == Some(Flags::FlagA));\n+        assert!(Flags::from_bits(0b10) == Some(Flags::FlagB));\n+        assert!(Flags::from_bits(0b11) == Some(Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits(0b1000) == None);\n \n-        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherFlag));\n+        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_from_bits_truncate() {\n         assert!(Flags::from_bits_truncate(0) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1) == FlagA);\n-        assert!(Flags::from_bits_truncate(0b10) == FlagB);\n-        assert!(Flags::from_bits_truncate(0b11) == (FlagA | FlagB));\n+        assert!(Flags::from_bits_truncate(0b1) == Flags::FlagA);\n+        assert!(Flags::from_bits_truncate(0b10) == Flags::FlagB);\n+        assert!(Flags::from_bits_truncate(0b11) == (Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits_truncate(0b1000) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1001) == FlagA);\n+        assert!(Flags::from_bits_truncate(0b1001) == Flags::FlagA);\n \n         assert!(AnotherSetOfFlags::from_bits_truncate(0) == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());\n-        assert!(!FlagA.is_empty());\n-        assert!(!FlagABC.is_empty());\n+        assert!(!Flags::FlagA.is_empty());\n+        assert!(!Flags::FlagABC.is_empty());\n \n-        assert!(!AnotherFlag.is_empty());\n+        assert!(!AnotherSetOfFlags::AnotherFlag.is_empty());\n     }\n \n     #[test]\n     fn test_is_all() {\n         assert!(Flags::all().is_all());\n-        assert!(!FlagA.is_all());\n-        assert!(FlagABC.is_all());\n+        assert!(!Flags::FlagA.is_all());\n+        assert!(Flags::FlagABC.is_all());\n \n-        assert!(AnotherFlag.is_all());\n+        assert!(AnotherSetOfFlags::AnotherFlag.is_all());\n     }\n \n     #[test]\n@@ -383,77 +385,77 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n-        assert!(AnotherFlag.intersects(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.intersects(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n         let e1 = Flags::empty();\n-        let e2 = FlagABC;\n+        let e2 = Flags::FlagABC;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagB;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_contains() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(!e1.contains(e2));\n         assert!(e2.contains(e1));\n-        assert!(FlagABC.contains(e2));\n+        assert!(Flags::FlagABC.contains(e2));\n \n-        assert!(AnotherFlag.contains(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.contains(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_insert(){\n-        let mut e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let mut e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         e1.insert(e2);\n         assert!(e1 == e2);\n \n         let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherFlag);\n-        assert!(e3 == AnotherFlag);\n+        e3.insert(AnotherSetOfFlags::AnotherFlag);\n+        assert!(e3 == AnotherSetOfFlags::AnotherFlag);\n     }\n \n     #[test]\n     fn test_remove(){\n-        let mut e1 = FlagA | FlagB;\n-        let e2 = FlagA | FlagC;\n+        let mut e1 = Flags::FlagA | Flags::FlagB;\n+        let e2 = Flags::FlagA | Flags::FlagC;\n         e1.remove(e2);\n-        assert!(e1 == FlagB);\n+        assert!(e1 == Flags::FlagB);\n \n-        let mut e3 = AnotherFlag;\n-        e3.remove(AnotherFlag);\n+        let mut e3 = AnotherSetOfFlags::AnotherFlag;\n+        e3.remove(AnotherSetOfFlags::AnotherFlag);\n         assert!(e3 == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_operators() {\n-        let e1 = FlagA | FlagC;\n-        let e2 = FlagB | FlagC;\n-        assert!((e1 | e2) == FlagABC);     // union\n-        assert!((e1 & e2) == FlagC);       // intersection\n-        assert!((e1 - e2) == FlagA);       // set difference\n-        assert!(!e2 == FlagA);             // set complement\n-        assert!(e1 ^ e2 == FlagA | FlagB); // toggle\n+        let e1 = Flags::FlagA | Flags::FlagC;\n+        let e2 = Flags::FlagB | Flags::FlagC;\n+        assert!((e1 | e2) == Flags::FlagABC);     // union\n+        assert!((e1 & e2) == Flags::FlagC);       // intersection\n+        assert!((e1 - e2) == Flags::FlagA);       // set difference\n+        assert!(!e2 == Flags::FlagA);             // set complement\n+        assert!(e1 ^ e2 == Flags::FlagA | Flags::FlagB); // toggle\n         let mut e3 = e1;\n         e3.toggle(e2);\n-        assert!(e3 == FlagA | FlagB);\n+        assert!(e3 == Flags::FlagA | Flags::FlagB);\n \n         let mut m4 = AnotherSetOfFlags::empty();\n         m4.toggle(AnotherSetOfFlags::empty());\n@@ -466,11 +468,11 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(!(a < b) && !(b < a));\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(a < b);\n-        a = FlagC;\n+        a = Flags::FlagC;\n         assert!(!(a < b) && b < a);\n-        b = FlagC | FlagB;\n+        b = Flags::FlagC | Flags::FlagB;\n         assert!(a < b);\n     }\n \n@@ -480,10 +482,10 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(a <= b && a >= b);\n-        a = FlagA;\n+        a = Flags::FlagA;\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -494,7 +496,7 @@ mod tests {\n       let mut y = Flags::empty();\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n       x = Flags::all();\n-      y = FlagABC;\n+      y = Flags::FlagABC;\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n     }\n }"}, {"sha": "cc2c9b735ea44b881aa9d763af3ea37919eb13b7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -2142,3 +2142,57 @@ impl LintPass for UnstableFeatures {\n         }\n     }\n }\n+\n+/// Lints for attempts to impl Drop on types that have `#[repr(C)]`\n+/// attribute (see issue #24585).\n+#[derive(Copy, Clone)]\n+pub struct DropWithReprExtern;\n+\n+declare_lint! {\n+    DROP_WITH_REPR_EXTERN,\n+    Warn,\n+    \"use of #[repr(C)] on a type that implements Drop\"\n+}\n+\n+impl LintPass for DropWithReprExtern {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DROP_WITH_REPR_EXTERN)\n+    }\n+    fn check_crate(&mut self, ctx: &Context, _: &ast::Crate) {\n+        for dtor_did in ctx.tcx.destructors.borrow().iter() {\n+            let (drop_impl_did, dtor_self_type) =\n+                if dtor_did.krate == ast::LOCAL_CRATE {\n+                    let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);\n+                    let ty = ty::lookup_item_type(ctx.tcx, impl_did).ty;\n+                    (impl_did, ty)\n+                } else {\n+                    continue;\n+                };\n+\n+            match dtor_self_type.sty {\n+                ty::ty_enum(self_type_did, _) |\n+                ty::ty_struct(self_type_did, _) |\n+                ty::ty_closure(self_type_did, _) => {\n+                    let hints = ty::lookup_repr_hints(ctx.tcx, self_type_did);\n+                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n+                        ty::ty_dtor(ctx.tcx, self_type_did).has_drop_flag() {\n+                        let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n+                                                                     codemap::DUMMY_SP);\n+                        let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,\n+                                                                     codemap::DUMMY_SP);\n+                        ctx.span_lint(DROP_WITH_REPR_EXTERN,\n+                                      drop_impl_span,\n+                                      \"implementing Drop adds hidden state to types, \\\n+                                       possibly conflicting with `#[repr(C)]`\");\n+                        // FIXME #19668: could be span_lint_note instead of manual guard.\n+                        if ctx.current_level(DROP_WITH_REPR_EXTERN) != Level::Allow {\n+                            ctx.sess().span_note(self_defn_span,\n+                                               \"the `#[repr(C)]` attribute is attached here\");\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}"}, {"sha": "970f9c634a2caad2c4cbe4abb402786486e03c5f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -108,6 +108,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n+                 DropWithReprExtern,\n                  );\n \n     add_builtin_with_new!(sess,"}, {"sha": "db88072150a603f2ef49f5847f51065e7abbd4dc", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -25,6 +25,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(libc)]\n@@ -42,6 +43,7 @@ pub use self::RealPredicate::*;\n pub use self::TypeKind::*;\n pub use self::AtomicBinOp::*;\n pub use self::AtomicOrdering::*;\n+pub use self::SynchronizationScope::*;\n pub use self::FileType::*;\n pub use self::MetadataType::*;\n pub use self::AsmDialect::*;\n@@ -123,32 +125,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        const ZExtAttribute = 1 << 0,\n-        const SExtAttribute = 1 << 1,\n-        const NoReturnAttribute = 1 << 2,\n-        const InRegAttribute = 1 << 3,\n-        const StructRetAttribute = 1 << 4,\n-        const NoUnwindAttribute = 1 << 5,\n-        const NoAliasAttribute = 1 << 6,\n-        const ByValAttribute = 1 << 7,\n-        const NestAttribute = 1 << 8,\n-        const ReadNoneAttribute = 1 << 9,\n-        const ReadOnlyAttribute = 1 << 10,\n-        const NoInlineAttribute = 1 << 11,\n-        const AlwaysInlineAttribute = 1 << 12,\n+        const ZExtAttribute            = 1 << 0,\n+        const SExtAttribute            = 1 << 1,\n+        const NoReturnAttribute        = 1 << 2,\n+        const InRegAttribute           = 1 << 3,\n+        const StructRetAttribute       = 1 << 4,\n+        const NoUnwindAttribute        = 1 << 5,\n+        const NoAliasAttribute         = 1 << 6,\n+        const ByValAttribute           = 1 << 7,\n+        const NestAttribute            = 1 << 8,\n+        const ReadNoneAttribute        = 1 << 9,\n+        const ReadOnlyAttribute        = 1 << 10,\n+        const NoInlineAttribute        = 1 << 11,\n+        const AlwaysInlineAttribute    = 1 << 12,\n         const OptimizeForSizeAttribute = 1 << 13,\n-        const StackProtectAttribute = 1 << 14,\n+        const StackProtectAttribute    = 1 << 14,\n         const StackProtectReqAttribute = 1 << 15,\n-        const AlignmentAttribute = 31 << 16,\n-        const NoCaptureAttribute = 1 << 21,\n-        const NoRedZoneAttribute = 1 << 22,\n+        const AlignmentAttribute       = 1 << 16,\n+        const NoCaptureAttribute       = 1 << 21,\n+        const NoRedZoneAttribute       = 1 << 22,\n         const NoImplicitFloatAttribute = 1 << 23,\n-        const NakedAttribute = 1 << 24,\n-        const InlineHintAttribute = 1 << 25,\n-        const StackAttribute = 7 << 26,\n-        const ReturnsTwiceAttribute = 1 << 29,\n-        const UWTableAttribute = 1 << 30,\n-        const NonLazyBindAttribute = 1 << 31,\n+        const NakedAttribute           = 1 << 24,\n+        const InlineHintAttribute      = 1 << 25,\n+        const StackAttribute           = 7 << 26,\n+        const ReturnsTwiceAttribute    = 1 << 29,\n+        const UWTableAttribute         = 1 << 30,\n+        const NonLazyBindAttribute     = 1 << 31,\n     }\n }\n \n@@ -360,6 +362,13 @@ pub enum AtomicOrdering {\n     SequentiallyConsistent = 7\n }\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum SynchronizationScope {\n+    SingleThread = 0,\n+    CrossThread = 1\n+}\n+\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n #[derive(Copy, Clone)]\n@@ -1533,7 +1542,9 @@ extern {\n                               SingleThreaded: Bool)\n                               -> ValueRef;\n \n-    pub fn LLVMBuildAtomicFence(B: BuilderRef, Order: AtomicOrdering);\n+    pub fn LLVMBuildAtomicFence(B: BuilderRef,\n+                                Order: AtomicOrdering,\n+                                Scope: SynchronizationScope);\n \n \n     /* Selected entries from the downcasts. */"}, {"sha": "4ea18968d43ac218df9fbc3dda33aee3c716ad1e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use {DefModifiers, PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use resolve_imports::ImportResolution;\n@@ -262,7 +262,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let name = item.ident.name;\n         let sp = item.span;\n         let is_public = item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n \n         match item.node {\n             ItemUse(ref view_path) => {\n@@ -533,20 +537,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         ast::ConstTraitItem(..) => {\n                             let def = DefAssociatedConst(local_def(trait_item.id),\n                                                          FromTrait(local_def(item.id)));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(local_def(item.id),\n                                                       local_def(trait_item.id));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_type(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n@@ -584,10 +588,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // used\n         child.define_value(DefVariant(item_id,\n                                       local_def(variant.node.id), is_exported),\n-                           variant.span, PUBLIC | IMPORTABLE);\n+                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n                                      local_def(variant.node.id), is_exported),\n-                          variant.span, PUBLIC | IMPORTABLE);\n+                          variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -596,7 +600,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n@@ -644,7 +652,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 external crate) building external def {}, priv {:?}\",\n                final_ident, vis);\n         let is_public = vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n             None => true,\n             Some(did) => self.external_exports.contains(&did)\n@@ -695,7 +707,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                       final_ident);\n               // variants are always treated as importable to allow them to be\n               // glob used\n-              let modifiers = PUBLIC | IMPORTABLE;\n+              let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n               if is_struct {\n                   child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                   // Not adding fields for variants as they are not accessed with a self receiver\n@@ -715,11 +727,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier\n             let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n+                             (def.modifiers &  DefModifiers::IMPORTABLE),\n                 None => modifiers\n             };\n             if new_parent.kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !IMPORTABLE;\n+                modifiers = modifiers & !DefModifiers::IMPORTABLE;\n             }\n             child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }"}, {"sha": "d8495fb989bfe1f292f06ec11f078b8257a546b6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -20,6 +20,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(alloc)]\n+#![feature(associated_consts)]\n #![feature(collections)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -477,8 +478,8 @@ impl fmt::Debug for Module {\n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n-        const PUBLIC            = 0b0000_0001,\n-        const IMPORTABLE        = 0b0000_0010,\n+        const PUBLIC     = 1 << 0,\n+        const IMPORTABLE = 1 << 1,\n     }\n }\n \n@@ -524,7 +525,11 @@ impl NameBindings {\n                      is_public: bool,\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let module_ = Rc::new(Module::new(parent_link,\n                                           def_id,\n                                           kind,\n@@ -559,7 +564,11 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n@@ -659,7 +668,7 @@ impl NameBindings {\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n-        self.defined_in_namespace_with(namespace, PUBLIC)\n+        self.defined_in_namespace_with(namespace, DefModifiers::PUBLIC)\n     }\n \n     fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n@@ -730,11 +739,11 @@ impl NameBindings {\n         match namespace {\n             TypeNS  => {\n                 let type_def = self.type_def.borrow();\n-                type_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                type_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n             ValueNS => {\n                 let value_def = self.value_def.borrow();\n-                value_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                value_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n         }\n     }\n@@ -921,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n-                modifiers: IMPORTABLE,\n+                modifiers: DefModifiers::IMPORTABLE,\n                 module_def: Some(module),\n                 type_def: None,\n                 type_span: None"}, {"sha": "350f69d30c4e452d8c0779e6798162aa7e257ae9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use NameBindings;\n@@ -848,7 +848,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Merge the child item into the import resolution.\n         {\n             let mut merge_child_item = |namespace| {\n-                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n+\n+                if name_bindings.defined_in_namespace_with(namespace, modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\",\n                         ValueNS => \"value\",\n@@ -914,7 +916,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        import_span: Span,\n                                        name: Name,\n                                        namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+        if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);"}, {"sha": "92c9549b37727adbd9263cc95d52120776ef3efd", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -32,7 +32,7 @@ use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::{self, Path, PathBuf};\n use std::process::Command;\n use std::str;\n use flate;\n@@ -872,7 +872,7 @@ fn link_args(cmd: &mut Command,\n     // target descriptor\n     let t = &sess.target.target;\n \n-    cmd.arg(\"-L\").arg(&lib_path);\n+    cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(&lib_path));\n \n     cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n \n@@ -924,8 +924,9 @@ fn link_args(cmd: &mut Command,\n         // stripped away as much as it could. This has not been seen to impact\n         // link times negatively.\n         //\n-        // -dead_strip can't be part of the pre_link_args because it's also used for partial\n-        // linking when using multiple codegen units (-r). So we insert it here.\n+        // -dead_strip can't be part of the pre_link_args because it's also used\n+        // for partial linking when using multiple codegen units (-r). So we\n+        // insert it here.\n         cmd.arg(\"-Wl,-dead_strip\");\n     }\n \n@@ -1051,7 +1052,6 @@ fn link_args(cmd: &mut Command,\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n             get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-            realpath: &mut ::util::fs::realpath\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n@@ -1266,7 +1266,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 }\n             });\n         } else {\n-            cmd.arg(cratepath);\n+            cmd.arg(&fix_windows_verbatim_for_gcc(cratepath));\n         }\n     }\n \n@@ -1279,7 +1279,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         if let Some(dir) = cratepath.parent() {\n-            cmd.arg(\"-L\").arg(dir);\n+            cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n         cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n@@ -1333,3 +1333,29 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         }\n     }\n }\n+\n+// Unfortunately, on windows, gcc cannot accept paths of the form `\\\\?\\C:\\...`\n+// (a verbatim path). This form of path is generally pretty rare, but the\n+// implementation of `fs::canonicalize` currently generates paths of this form,\n+// meaning that we're going to be passing quite a few of these down to gcc.\n+//\n+// For now we just strip the \"verbatim prefix\" of `\\\\?\\` from the path. This\n+// will probably lose information in some cases, but there's not a whole lot\n+// more we can do with a buggy gcc...\n+fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n+    if !cfg!(windows) {\n+        return p.to_path_buf()\n+    }\n+    let mut components = p.components();\n+    let prefix = match components.next() {\n+        Some(path::Component::Prefix(p)) => p,\n+        _ => return p.to_path_buf(),\n+    };\n+    let disk = match prefix.kind() {\n+        path::Prefix::VerbatimDisk(disk) => disk,\n+        _ => return p.to_path_buf(),\n+    };\n+    let mut base = OsString::from(format!(\"{}:\", disk as char));\n+    base.push(components.as_path());\n+    PathBuf::from(base)\n+}"}, {"sha": "d80086da20315af17357c4ee927f8a7d469875d6", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -295,6 +295,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n \n+        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n+\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n@@ -704,7 +706,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            visit::walk_impl_item(self, impl_item);\n+            self.visit_impl_item(impl_item);\n         }\n     }\n \n@@ -1258,7 +1260,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         match impl_item.node {\n             ast::ConstImplItem(ref ty, ref expr) => {\n                 self.process_const(impl_item.id, &impl_item.ident,\n-                                   impl_item.span, &*ty, &*expr);\n+                                   impl_item.span, &ty, &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,"}, {"sha": "001de615fb1eb3c5fea7ad8fb776cf12752d2adf", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -440,6 +440,22 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n             None\n         },\n \n+        // Perhaps one of the upvars of this struct is non-zero\n+        // Let's recurse and find out!\n+        ty::ty_closure(def_id, substs) => {\n+            let typer = NormalizingClosureTyper::new(tcx);\n+            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n+\n+            for (j, &ty) in upvar_types.iter().enumerate() {\n+                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n+                    fpath.push(j);\n+                    return Some(fpath);\n+                }\n+            }\n+            None\n+        },\n+\n         // Can we use one of the fields in this tuple?\n         ty::ty_tup(ref tys) => {\n             for (j, &ty) in tys.iter().enumerate() {"}, {"sha": "b44ccec0127bd7f864b387e6d24ae216667a933b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -39,13 +39,13 @@ pub fn split_stack(val: ValueRef, set: bool) {\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n-        Always => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHintAttribute),\n+        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInlineAttribute),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInlineAttribute),\n         None   => {\n-            let attr = llvm::InlineHintAttribute |\n-                       llvm::AlwaysInlineAttribute |\n-                       llvm::NoInlineAttribute;\n+            let attr = llvm::Attribute::InlineHintAttribute |\n+                       llvm::Attribute::AlwaysInlineAttribute |\n+                       llvm::Attribute::NoInlineAttribute;\n             unsafe {\n                 llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n             }\n@@ -57,10 +57,13 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n     if emit {\n-        llvm::SetFunctionAttribute(val, llvm::UWTableAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTableAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::UWTableAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::UWTableAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -71,10 +74,13 @@ pub fn emit_uwtable(val: ValueRef, emit: bool) {\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n     if can_unwind {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::NoUnwindAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::NoUnwindAttribute.bits() as c_ulonglong,\n+            );\n         }\n     } else {\n-        llvm::SetFunctionAttribute(val, llvm::NoUnwindAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwindAttribute);\n     }\n }\n \n@@ -83,10 +89,13 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n     if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::OptimizeForSizeAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSizeAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::OptimizeForSizeAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::OptimizeForSizeAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -107,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n                                                llvm::ColdAttribute as u64)\n             }\n         } else if attr.check_name(\"allocator\") {\n-            llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attribute::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n         }\n     }\n }\n@@ -176,9 +185,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::StructRetAttribute)\n-                 .arg(1, llvm::NoAliasAttribute)\n-                 .arg(1, llvm::NoCaptureAttribute)\n+            attrs.arg(1, llvm::Attribute::StructRetAttribute)\n+                 .arg(1, llvm::Attribute::NoAliasAttribute)\n+                 .arg(1, llvm::Attribute::NoCaptureAttribute)\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n@@ -190,7 +199,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::NoAliasAttribute);\n+                    attrs.ret(llvm::Attribute::NoAliasAttribute);\n                 }\n                 _ => {}\n             }\n@@ -207,7 +216,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             }\n \n             if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::ZExtAttribute);\n+                attrs.ret(llvm::Attribute::ZExtAttribute);\n             }\n         }\n     }\n@@ -221,20 +230,20 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                     .arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n             ty::ty_bool => {\n-                attrs.arg(idx, llvm::ZExtAttribute);\n+                attrs.arg(idx, llvm::Attribute::ZExtAttribute);\n             }\n \n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n@@ -247,23 +256,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n \n                 if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n+                    attrs.arg(idx, llvm::Attribute::ReadOnlyAttribute);\n                 }\n \n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::NoCaptureAttribute);\n+                    attrs.arg(idx, llvm::Attribute::NoCaptureAttribute);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n "}, {"sha": "4879975dde695c265bd7505b3e1127a0bccebf5c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -2182,7 +2182,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n \n-            debuginfo::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n+            debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx);\n \n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {"}, {"sha": "d6ac412a4faead9678cc7711671e87e40a1e78df", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -12,7 +12,7 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use trans::common::*;\n@@ -965,9 +965,9 @@ pub fn CallWithConv(cx: Block,\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n \n-pub fn AtomicFence(cx: Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {\n     if cx.unreachable.get() { return; }\n-    B(cx).atomic_fence(order)\n+    B(cx).atomic_fence(order, scope)\n }\n \n pub fn Select(cx: Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {"}, {"sha": "497e0ae422c1fa3659c17eadb3e0140b518f5956", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect, AttrBuilder};\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n use llvm::{Opcode, IntPredicate, RealPredicate, False};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n@@ -989,9 +989,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_fence(&self, order: AtomicOrdering) {\n+    pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n         unsafe {\n-            llvm::LLVMBuildAtomicFence(self.llbuilder, order);\n+            llvm::LLVMBuildAtomicFence(self.llbuilder, order, scope);\n         }\n     }\n }"}, {"sha": "2eef678673987dc8ee28cbfdfa57fe469e776f9b", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -164,7 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n@@ -186,12 +185,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {"}, {"sha": "689b3b3ad37eef5695cc2f02a75c04b40b1327ba", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -132,7 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty, align_fn);\n@@ -146,12 +145,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = align_fn(ty);"}, {"sha": "2e899f72979d7e491233dbff117ea88e163e624a", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -13,8 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -89,10 +88,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -106,7 +105,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "eae2378a2c518e0fd970a7495ea975bec4d1d4c2", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,8 +10,7 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -85,10 +84,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -102,7 +101,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "d9c265d94a793e8f92c534e6d334ee2035e8f4e9", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -52,11 +52,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(StructRetAttribute));\n+                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRetAttribute));\n             }\n         }\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -67,11 +67,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 if size == 0 {\n                     ArgType::ignore(t)\n                 } else {\n-                    ArgType::indirect(t, Some(ByValAttribute))\n+                    ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "d954a861a7267390256e87685d1abef932e22074", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -16,7 +16,6 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -407,19 +406,19 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut arg_tys = Vec::new();\n     for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByValAttribute);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRetAttribute)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "7808b9d27feead1a39005e8bc6e3a2b120719768", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -31,10 +31,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n             4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n             8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(StructRetAttribute))\n+            _ => ArgType::indirect(rty, Some(Attribute::StructRetAttribute))\n         };\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -46,11 +46,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n                     4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n                     8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, Some(ByValAttribute))\n+                    _ => ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "637325881436dd8e2e1b1c6ad2b076b017f2773c", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -438,10 +438,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    fn schedule_drop_enum_contents(&self,\n-                                   cleanup_scope: ScopeId,\n-                                   val: ValueRef,\n-                                   ty: Ty<'tcx>) {\n+    fn schedule_drop_adt_contents(&self,\n+                                  cleanup_scope: ScopeId,\n+                                  val: ValueRef,\n+                                  ty: Ty<'tcx>) {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.type_needs_drop(ty) { return; }\n@@ -455,7 +455,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_enum_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n@@ -1240,10 +1240,10 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>);\n-    fn schedule_drop_enum_contents(&self,\n-                                   cleanup_scope: ScopeId,\n-                                   val: ValueRef,\n-                                   ty: Ty<'tcx>);\n+    fn schedule_drop_adt_contents(&self,\n+                                  cleanup_scope: ScopeId,\n+                                  val: ValueRef,\n+                                  ty: Ty<'tcx>);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,"}, {"sha": "3aaf4addd89626fc8d99540832099e0198fef317", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -186,7 +186,7 @@ fn get_const_val(ccx: &CrateContext,\n                  ref_expr: &ast::Expr) -> ValueRef {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    get_const_expr_as_global(ccx, expr, check_const::PURE_CONST, empty_substs)\n+    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::PURE_CONST, empty_substs)\n }\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -215,7 +215,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(&val) => return val,\n         None => {}\n     }\n-    let val = if qualif.intersects(check_const::NON_STATIC_BORROWS) {\n+    let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,"}, {"sha": "41ef566f2fd7f8e916c7af0039a62e28d91dc9c4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -735,6 +735,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n }\n \n+/// Declare any llvm intrinsics that you might need\n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => ("}, {"sha": "9af22b788b77beaf0160dfa8cabe2f5e82762937", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,514 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::metadata::file_metadata;\n+use super::utils::DIB;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n+use trans::common::CrateContext;\n+use middle::pat_util;\n+use util::nodemap::NodeMap;\n+\n+use libc::c_uint;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util};\n+\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n+pub fn create_scope_map(cx: &CrateContext,\n+                        args: &[ast::Arg],\n+                        fn_entry_block: &ast::Block,\n+                        fn_metadata: DISubprogram,\n+                        fn_ast_id: ast::NodeId)\n+                        -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap();\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n+    for arg in args {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               name: Some(path1.node.name) });\n+            scope_map.insert(node_id, fn_metadata);\n+        })\n+    }\n+\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   &mut scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n+\n+    return scope_map;\n+}\n+\n+// local helper functions for walking the AST.\n+fn with_new_scope<F>(cx: &CrateContext,\n+                     scope_span: Span,\n+                     scope_stack: &mut Vec<ScopeStackEntry> ,\n+                     scope_map: &mut NodeMap<DIScope>,\n+                     inner_walk: F) where\n+    F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+{\n+    // Create a new lexical scope and push it onto the stack\n+    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+    let scope_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n+    };\n+\n+    scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n+\n+    inner_walk(cx, scope_stack, scope_map);\n+\n+    // pop artificial scopes\n+    while scope_stack.last().unwrap().name.is_some() {\n+        scope_stack.pop();\n+    }\n+\n+    if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n+        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+    }\n+\n+    scope_stack.pop();\n+}\n+\n+struct ScopeStackEntry {\n+    scope_metadata: DIScope,\n+    name: Option<ast::Name>\n+}\n+\n+fn walk_block(cx: &CrateContext,\n+              block: &ast::Block,\n+              scope_stack: &mut Vec<ScopeStackEntry> ,\n+              scope_map: &mut NodeMap<DIScope>) {\n+    scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    // The interesting things here are statements and the concluding expression.\n+    for statement in &block.stmts {\n+        scope_map.insert(ast_util::stmt_id(&**statement),\n+                         scope_stack.last().unwrap().scope_metadata);\n+\n+        match statement.node {\n+            ast::StmtDecl(ref decl, _) =>\n+                walk_decl(cx, &**decl, scope_stack, scope_map),\n+            ast::StmtExpr(ref exp, _) |\n+            ast::StmtSemi(ref exp, _) =>\n+                walk_expr(cx, &**exp, scope_stack, scope_map),\n+            ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n+        }\n+    }\n+\n+    if let Some(ref exp) = block.expr {\n+        walk_expr(cx, &**exp, scope_stack, scope_map);\n+    }\n+}\n+\n+fn walk_decl(cx: &CrateContext,\n+             decl: &ast::Decl,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+    match *decl {\n+        codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n+            scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+\n+            if let Some(ref exp) = local.init {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+fn walk_pattern(cx: &CrateContext,\n+                pat: &ast::Pat,\n+                scope_stack: &mut Vec<ScopeStackEntry> ,\n+                scope_map: &mut NodeMap<DIScope>) {\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+    // ast_util::walk_pat() here because we have to visit *all* nodes in\n+    // order to put them into the scope map. The above functions don't do that.\n+    match pat.node {\n+        ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+\n+            // Check if this is a binding. If so we need to put it on the\n+            // scope stack and maybe introduce an artificial scope\n+            if pat_util::pat_is_binding(def_map, &*pat) {\n+\n+                let name = path1.node.name;\n+\n+                // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                // for variable DIEs. For this reason we have to introduce\n+                // an artificial scope at bindings whenever a variable with\n+                // the same name is declared in *any* parent scope.\n+                //\n+                // Otherwise the following error occurs:\n+                //\n+                // let x = 10;\n+                //\n+                // do_something(); // 'gdb print x' correctly prints 10\n+                //\n+                // {\n+                //     do_something(); // 'gdb print x' prints 0, because it\n+                //                     // already reads the uninitialized 'x'\n+                //                     // from the next line...\n+                //     let x = 100;\n+                //     do_something(); // 'gdb print x' correctly prints 100\n+                // }\n+\n+                // Is there already a binding with that name?\n+                // N.B.: this comparison must be UNhygienic... because\n+                // gdb knows nothing about the context, so any two\n+                // variables with the same name will cause the problem.\n+                let need_new_scope = scope_stack\n+                    .iter()\n+                    .any(|entry| entry.name == Some(name));\n+\n+                if need_new_scope {\n+                    // Create a new lexical scope and push it onto the stack\n+                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let file_metadata = file_metadata(cx, &loc.file.name);\n+                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                    let scope_metadata = unsafe {\n+                        llvm::LLVMDIBuilderCreateLexicalBlock(\n+                            DIB(cx),\n+                            parent_scope,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            loc.col.to_usize() as c_uint)\n+                    };\n+\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: scope_metadata,\n+                        name: Some(name)\n+                    });\n+\n+                } else {\n+                    // Push a new entry anyway so the name can be found\n+                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: prev_metadata,\n+                        name: Some(name)\n+                    });\n+                }\n+            }\n+\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pat) = *sub_pat_opt {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatWild(_) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatEnum(_, ref sub_pats_opt) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pats) = *sub_pats_opt {\n+                for p in sub_pats {\n+                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+\n+        ast::PatQPath(..) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatStruct(_, ref field_pats, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for &codemap::Spanned {\n+                node: ast::FieldPat { pat: ref sub_pat, .. },\n+                ..\n+            } in field_pats.iter() {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatTup(ref sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+        }\n+\n+        ast::PatLit(ref exp) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n+        }\n+\n+        ast::PatRange(ref exp1, ref exp2) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in front_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            if let Some(ref sub_pat) = *middle_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            for sub_pat in back_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatMac(_) => {\n+            cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+    }\n+}\n+\n+fn walk_expr(cx: &CrateContext,\n+             exp: &ast::Expr,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+\n+    scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    match exp.node {\n+        ast::ExprLit(_)   |\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprPath(..) => {}\n+\n+        ast::ExprCast(ref sub_exp, _)     |\n+        ast::ExprAddrOf(_, ref sub_exp)  |\n+        ast::ExprField(ref sub_exp, _) |\n+        ast::ExprTupField(ref sub_exp, _) |\n+        ast::ExprParen(ref sub_exp) =>\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+\n+        ast::ExprBox(ref place, ref sub_expr) => {\n+            place.as_ref().map(\n+                |e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRet(ref exp_opt) => match *exp_opt {\n+            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            None => ()\n+        },\n+\n+        ast::ExprUnary(_, ref sub_exp) => {\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+            walk_expr(cx, &**lhs, scope_stack, scope_map);\n+            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRange(ref start, ref end) => {\n+            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+        }\n+\n+        ast::ExprVec(ref init_expressions) |\n+        ast::ExprTup(ref init_expressions) => {\n+            for ie in init_expressions {\n+                walk_expr(cx, &**ie, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+        ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           then_block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**then_block, scope_stack, scope_map);\n+            });\n+\n+            match *opt_else_exp {\n+                Some(ref else_exp) =>\n+                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                _ => ()\n+            }\n+        }\n+\n+        ast::ExprIfLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded if-let.\");\n+        }\n+\n+        ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           loop_body.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprWhileLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded while-let.\");\n+        }\n+\n+        ast::ExprForLoop(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded for loop.\");\n+        }\n+\n+        ast::ExprMac(_) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+\n+        ast::ExprLoop(ref block, _) |\n+        ast::ExprBlock(ref block)   => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprClosure(_, ref decl, ref block) => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n+                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                }\n+\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprCall(ref fn_exp, ref args) => {\n+            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n+            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+\n+            // For each arm we have to first walk the pattern as these might\n+            // introduce new artificial scopes. It should be sufficient to\n+            // walk only one pattern per arm, as they all must contain the\n+            // same binding names.\n+\n+            for arm_ref in arms {\n+                let arm_span = arm_ref.pats[0].span;\n+\n+                with_new_scope(cx,\n+                               arm_span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    for pat in &arm_ref.pats {\n+                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                    }\n+\n+                    if let Some(ref guard_exp) = arm_ref.guard {\n+                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                    }\n+\n+                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                })\n+            }\n+        }\n+\n+        ast::ExprStruct(_, ref fields, ref base_exp) => {\n+            for &ast::Field { expr: ref exp, .. } in fields {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            match *base_exp {\n+                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                None => ()\n+            }\n+        }\n+\n+        ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n+                                            ref outputs,\n+                                            .. }) => {\n+            // inputs, outputs: Vec<(String, P<Expr>)>\n+            for &(_, ref exp) in inputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            for &(_, ref exp, _) in outputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a91619b2f845a437732a2d2e8dc3c4b5363d9d6f", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Debug Info Module\n+//!\n+//! This module serves the purpose of generating debug symbols. We use LLVM's\n+//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! features for generating the debug information. The general principle is\n+//! this:\n+//!\n+//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+//! create DWARF debug symbols for the given code. The\n+//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! much like DWARF *debugging information entries* (DIE), representing type\n+//! information such as datatype layout, function signatures, block layout,\n+//! variable location and scope information, etc. It is the purpose of this\n+//! module to generate correct metadata and insert it into the LLVM IR.\n+//!\n+//! As the exact format of metadata trees may change between different LLVM\n+//! versions, we now use LLVM\n+//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! to create metadata where possible. This will hopefully ease the adaption of\n+//! this module to future LLVM versions.\n+//!\n+//! The public API of the module is a set of functions that will insert the\n+//! correct metadata into the LLVM IR when called with the right parameters.\n+//! The module is thus driven from an outside client with functions like\n+//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+//!\n+//! Internally the module will try to reuse already created metadata by\n+//! utilizing a cache. The way to get a shared metadata node when needed is\n+//! thus to just call the corresponding function in this module:\n+//!\n+//!     let file_metadata = file_metadata(crate_context, path);\n+//!\n+//! The function will take care of probing the cache for an existing node for\n+//! that exact file path.\n+//!\n+//! All private state used by the module is stored within either the\n+//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! FunctionDebugContext (owned by the FunctionContext).\n+//!\n+//! This file consists of three conceptual sections:\n+//! 1. The public interface of the module\n+//! 2. Module-internal metadata creation functions\n+//! 3. Minor utility functions\n+//!\n+//!\n+//! ## Recursive Types\n+//!\n+//! Some kinds of types, such as structs and enums can be recursive. That means\n+//! that the type definition of some type X refers to some other type which in\n+//! turn (transitively) refers to X. This introduces cycles into the type\n+//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+//! of this graph when describing types, can get trapped in an endless loop\n+//! when it reaches such a cycle.\n+//!\n+//! For example, the following simple type for a singly-linked list...\n+//!\n+//! ```\n+//! struct List {\n+//!     value: int,\n+//!     tail: Option<Box<List>>,\n+//! }\n+//! ```\n+//!\n+//! will generate the following callstack with a naive DFS algorithm:\n+//!\n+//! ```\n+//! describe(t = List)\n+//!   describe(t = int)\n+//!   describe(t = Option<Box<List>>)\n+//!     describe(t = Box<List>)\n+//!       describe(t = List) // at the beginning again...\n+//!       ...\n+//! ```\n+//!\n+//! To break cycles like these, we use \"forward declarations\". That is, when\n+//! the algorithm encounters a possibly recursive type (any struct or enum), it\n+//! immediately creates a type description node and inserts it into the cache\n+//! *before* describing the members of the type. This type description is just\n+//! a stub (as type members are not described and added to it yet) but it\n+//! allows the algorithm to already refer to the type. After the stub is\n+//! inserted into the cache, the algorithm continues as before. If it now\n+//! encounters a recursive reference, it will hit the cache and does not try to\n+//! describe the type anew.\n+//!\n+//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n+//! which represents a kind of continuation, storing all state needed to\n+//! continue traversal at the type members after the type has been registered\n+//! with the cache. (This implementation approach might be a tad over-\n+//! engineered and may change in the future)\n+//!\n+//!\n+//! ## Source Locations and Line Information\n+//!\n+//! In addition to data type descriptions the debugging information must also\n+//! allow to map machine code locations back to source code locations in order\n+//! to be useful. This functionality is also handled in this module. The\n+//! following functions allow to control source mappings:\n+//!\n+//! + set_source_location()\n+//! + clear_source_location()\n+//! + start_emitting_source_locations()\n+//!\n+//! `set_source_location()` allows to set the current source location. All IR\n+//! instructions created after a call to this function will be linked to the\n+//! given source location, until another location is specified with\n+//! `set_source_location()` or the source location is cleared with\n+//! `clear_source_location()`. In the later case, subsequent IR instruction\n+//! will not be linked to any source location. As you can see, this is a\n+//! stateful API (mimicking the one in LLVM), so be careful with source\n+//! locations set by previous calls. It's probably best to not rely on any\n+//! specific state being present at a given point in code.\n+//!\n+//! One topic that deserves some extra attention is *function prologues*. At\n+//! the beginning of a function's machine code there are typically a few\n+//! instructions for loading argument values into allocas and checking if\n+//! there's enough stack space for the function to execute. This *prologue* is\n+//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n+//! into the line table at the first non-prologue instruction of the function.\n+//! In order to find out where the prologue ends, LLVM looks for the first\n+//! instruction in the function body that is linked to a source location. So,\n+//! when generating prologue instructions we have to make sure that we don't\n+//! emit source location information until the 'real' function body begins. For\n+//! this reason, source location emission is disabled by default for any new\n+//! function being translated and is only activated after a call to the third\n+//! function from the list above, `start_emitting_source_locations()`. This\n+//! function should be called right before regularly starting to translate the\n+//! top-level block of the given function.\n+//!\n+//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n+//! must be linked to the source location of the variable being declared. For\n+//! function parameters these `llvm.dbg.declare` instructions typically occur\n+//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n+//! detection. The `create_argument_metadata()` and related functions take care\n+//! of linking the `llvm.dbg.declare` instructions to the correct source\n+//! locations even while source location emission is still disabled, so there\n+//! is no need to do anything special with source location handling here.\n+//!\n+//! ## Unique Type Identification\n+//!\n+//! In order for link-time optimization to work properly, LLVM needs a unique\n+//! type identifier that tells it across compilation units which types are the\n+//! same as others. This type identifier is created by\n+//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+//!\n+//! (1) Primitive types have their name as ID\n+//! (2) Structs, enums and traits have a multipart identifier\n+//!\n+//!     (1) The first part is the SVH (strict version hash) of the crate they\n+//!          wereoriginally defined in\n+//!\n+//!     (2) The second part is the ast::NodeId of the definition in their\n+//!          originalcrate\n+//!\n+//!     (3) The final part is a concatenation of the type IDs of their concrete\n+//!          typearguments if they are generic types.\n+//!\n+//! (3) Tuple-, pointer and function types are structurally identified, which\n+//!     means that they are equivalent if their component types are equivalent\n+//!     (i.e. (int, int) is the same regardless in which crate it is used).\n+//!\n+//! This algorithm also provides a stable ID for types that are defined in one\n+//! crate but instantiated from metadata within another crate. We just have to\n+//! take care to always map crate and node IDs back to the original crate\n+//! context.\n+//!\n+//! As a side-effect these unique type IDs also help to solve a problem arising\n+//! from lifetime parameters. Since lifetime parameters are completely omitted\n+//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+//! with different concrete substitutions for `'a`, and thus there will be N\n+//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n+//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+//! cheap identifier for type metadata---we have done this in the past, but it\n+//! led to unnecessary metadata duplication in the best case and LLVM\n+//! assertions in the worst. However, the unique type ID as described above\n+//! *can* be used as identifier. Since it is comparatively expensive to\n+//! construct, though, `ty::type_id()` is still used additionally as an\n+//! optimization for cases where the exact same type has been seen before\n+//! (which is most of the time)."}, {"sha": "a6f1199d0ffe7354997e18371da1e768a47626fc", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// .debug_gdb_scripts binary section.\n+\n+use llvm;\n+use llvm::ValueRef;\n+\n+use trans::common::{C_bytes, CrateContext};\n+use trans::declare;\n+use trans::type_::Type;\n+use middle::ty::ClosureTyper;\n+use session::config::NoDebugInfo;\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use syntax::attr;\n+\n+\n+/// Inserts a side-effect free instruction sequence that makes sure that the\n+/// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n+    if needs_gdb_debug_scripts_section(ccx) {\n+        let empty = CString::new(\"\").unwrap();\n+        let gdb_debug_scripts_section_global =\n+            get_or_insert_gdb_debug_scripts_section_global(ccx);\n+        unsafe {\n+            let volative_load_instruction =\n+                llvm::LLVMBuildLoad(ccx.raw_builder(),\n+                                    gdb_debug_scripts_section_global,\n+                                    empty.as_ptr());\n+            llvm::LLVMSetVolatile(volative_load_instruction, llvm::True);\n+        }\n+    }\n+}\n+\n+/// Allocates the global variable responsible for the .debug_gdb_scripts binary\n+/// section.\n+pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+                                                  -> llvm::ValueRef {\n+    let section_var_name = \"__rustc_debug_gdb_scripts_section__\";\n+\n+    let section_var = unsafe {\n+        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+                                 section_var_name.as_ptr() as *const _)\n+    };\n+\n+    if section_var == ptr::null_mut() {\n+        let section_name = b\".debug_gdb_scripts\\0\";\n+        let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n+\n+        unsafe {\n+            let llvm_type = Type::array(&Type::i8(ccx),\n+                                        section_contents.len() as u64);\n+\n+            let section_var = declare::define_global(ccx, section_var_name,\n+                                                     llvm_type).unwrap_or_else(||{\n+                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+            });\n+            llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n+            llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n+            llvm::SetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n+            // This should make sure that the whole section is not larger than\n+            // the string it contains. Otherwise we get a warning from GDB.\n+            llvm::LLVMSetAlignment(section_var, 1);\n+            section_var\n+        }\n+    } else {\n+        section_var\n+    }\n+}\n+\n+pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+    let omit_gdb_pretty_printer_section =\n+        attr::contains_name(&ccx.tcx()\n+                                .map\n+                                .krate()\n+                                .attrs,\n+                            \"omit_gdb_pretty_printer_section\");\n+\n+    !omit_gdb_pretty_printer_section &&\n+    !ccx.sess().target.target.options.is_like_osx &&\n+    !ccx.sess().target.target.options.is_like_windows &&\n+    ccx.sess().opts.debuginfo != NoDebugInfo\n+}"}, {"sha": "9ff69e7f9dd294c2f43ba57f0dd28130e4fee0c5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "renamed", "additions": 1272, "deletions": 3233, "changes": 4505, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "previous_filename": "src/librustc_trans/trans/debuginfo.rs"}, {"sha": "e4312b669ad98d2cce97fbb5b57944cddb729033", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,651 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See doc.rs for documentation.\n+mod doc;\n+\n+use self::VariableAccess::*;\n+use self::VariableKind::*;\n+\n+use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n+                  create_DIArray, is_node_local_to_unit};\n+use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::type_names::compute_debuginfo_type_name;\n+use self::metadata::{type_metadata, file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n+use self::source_loc::InternalDebugLocation;\n+\n+use llvm;\n+use llvm::{ModuleRef, ContextRef, ValueRef};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n+                      DIDescriptor, FlagPrototyped};\n+use middle::subst::{self, Substs};\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n+use trans;\n+use trans::monomorphize;\n+use middle::ty::{self, Ty, ClosureTyper};\n+use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n+\n+use libc::c_uint;\n+use std::cell::{Cell, RefCell};\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::Rc;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::parse::token::{self, special_idents};\n+\n+pub mod gdb;\n+mod utils;\n+mod namespace;\n+mod type_names;\n+mod metadata;\n+mod create_scope_map;\n+mod source_loc;\n+\n+pub use self::source_loc::set_source_location;\n+pub use self::source_loc::clear_source_location;\n+pub use self::source_loc::start_emitting_source_locations;\n+pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n+pub use self::source_loc::with_source_location_override;\n+pub use self::metadata::create_match_binding_metadata;\n+pub use self::metadata::create_argument_metadata;\n+pub use self::metadata::create_captured_var_metadata;\n+pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::create_local_var_metadata;\n+\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_auto_variable: c_uint = 0x100;\n+#[allow(non_upper_case_globals)]\n+const DW_TAG_arg_variable: c_uint = 0x101;\n+\n+/// A context object for maintaining all state needed by the debuginfo module.\n+pub struct CrateDebugContext<'tcx> {\n+    llcontext: ContextRef,\n+    builder: DIBuilderRef,\n+    current_debug_location: Cell<InternalDebugLocation>,\n+    created_files: RefCell<FnvHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n+\n+    type_map: RefCell<TypeMap<'tcx>>,\n+    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+\n+    // This collection is used to assert that composite types (structs, enums,\n+    // ...) have their members only set once:\n+    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+}\n+\n+impl<'tcx> CrateDebugContext<'tcx> {\n+    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n+        debug!(\"CrateDebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return CrateDebugContext {\n+            llcontext: llcontext,\n+            builder: builder,\n+            current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n+            created_files: RefCell::new(FnvHashMap()),\n+            created_enum_disr_types: RefCell::new(DefIdMap()),\n+            type_map: RefCell::new(TypeMap::new()),\n+            namespace_map: RefCell::new(FnvHashMap()),\n+            composite_types_completed: RefCell::new(FnvHashSet()),\n+        };\n+    }\n+}\n+\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n+}\n+\n+impl FunctionDebugContext {\n+    fn get_ref<'a>(&'a self,\n+                   cx: &CrateContext,\n+                   span: Span)\n+                   -> &'a FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::debuginfo_disabled_message());\n+            }\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::should_be_ignored_message());\n+            }\n+        }\n+    }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n+}\n+\n+struct FunctionDebugContextData {\n+    scope_map: RefCell<NodeMap<DIScope>>,\n+    fn_metadata: DISubprogram,\n+    argument_counter: Cell<usize>,\n+    source_locations_enabled: Cell<bool>,\n+    source_location_override: Cell<bool>,\n+}\n+\n+pub enum VariableAccess<'a> {\n+    // The llptr given is an alloca containing the variable's value\n+    DirectVariable { alloca: ValueRef },\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n+    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n+}\n+\n+pub enum VariableKind {\n+    ArgumentVariable(usize /*index*/),\n+    LocalVariable,\n+    CapturedVariable,\n+}\n+\n+/// Create any deferred debug metadata nodes\n+pub fn finalize(cx: &CrateContext) {\n+    if cx.dbg_cx().is_none() {\n+        return;\n+    }\n+\n+    debug!(\"finalize\");\n+    let _ = compile_unit_metadata(cx);\n+\n+    if gdb::needs_gdb_debug_scripts_section(cx) {\n+        // Add a .debug_gdb_scripts section to this compile-unit. This will\n+        // cause GDB to try and load the gdb_load_rust_pretty_printers.py file,\n+        // which activates the Rust pretty printers for binary this section is\n+        // contained in.\n+        gdb::get_or_insert_gdb_debug_scripts_section_global(cx);\n+    }\n+\n+    unsafe {\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n+        // Debuginfo generation in LLVM by default uses a higher\n+        // version of dwarf than OS X currently understands. We can\n+        // instruct LLVM to emit an older version of dwarf, however,\n+        // for OS X to understand. For more info see #11352\n+        // This can be overridden using --llvm-opts -dwarf-version,N.\n+        // Android has the same issue (#22398)\n+        if cx.sess().target.target.options.is_like_osx ||\n+           cx.sess().target.target.options.is_like_android {\n+            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+                                        \"Dwarf Version\\0\".as_ptr() as *const _,\n+                                        2)\n+        }\n+\n+        // Prevent bitcode readers from deleting the debug info.\n+        let ptr = \"Debug Info Version\\0\".as_ptr();\n+        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+                                    llvm::LLVMRustDebugMetadataVersion);\n+    };\n+}\n+\n+/// Creates the function-specific debug context.\n+///\n+/// Returns the FunctionDebugContext for the function which holds state needed\n+/// for debug info creation. The function may also return another variant of the\n+/// FunctionDebugContext enum which indicates why no debuginfo should be created\n+/// for the function.\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                               fn_ast_id: ast::NodeId,\n+                                               param_substs: &Substs<'tcx>,\n+                                               llfn: ValueRef) -> FunctionDebugContext {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n+        return FunctionDebugContext::DebugInfoDisabled;\n+    }\n+\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    // Do this here already, in case we do an early exit from this function.\n+    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+\n+    if fn_ast_id == ast::DUMMY_NODE_ID {\n+        // This is a function not linked to any source location, so don't\n+        // generate debuginfo for it.\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let empty_generics = ast_util::empty_generics();\n+\n+    let fnitem = cx.tcx().map.get(fn_ast_id);\n+\n+    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n+        ast_map::NodeItem(ref item) => {\n+            if contains_nodebug_attribute(&item.attrs) {\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            }\n+\n+            match item.node {\n+                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(item.span,\n+                        \"create_function_debug_context: item bound to non-function\");\n+                }\n+            }\n+        }\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    if contains_nodebug_attribute(&impl_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (impl_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     impl_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess().span_bug(impl_item.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on non-method impl item?!\")\n+                }\n+            }\n+        }\n+        ast_map::NodeExpr(ref expr) => {\n+            match expr.node {\n+                ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n+                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n+                    let name = token::intern(&name[..]);\n+                    (name, fn_decl,\n+                        // This is not quite right. It should actually inherit\n+                        // the generics of the enclosing function.\n+                        &empty_generics,\n+                        top_level_block,\n+                        expr.span,\n+                        // Don't try to lookup the item path:\n+                        false)\n+                }\n+                _ => cx.sess().span_bug(expr.span,\n+                        \"create_function_debug_context: expected an expr_fn_block here\")\n+            }\n+        }\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    if contains_nodebug_attribute(&trait_item.attrs) {\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+                    }\n+\n+                    (trait_item.ident.name,\n+                     &sig.decl,\n+                     &sig.generics,\n+                     body,\n+                     trait_item.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess()\n+                      .bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                    fnitem))\n+                }\n+            }\n+        }\n+        ast_map::NodeForeignItem(..) |\n+        ast_map::NodeVariant(..) |\n+        ast_map::NodeStructCtor(..) => {\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n+        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                   fnitem))\n+    };\n+\n+    // This can be the case for functions inlined from another crate\n+    if span == codemap::DUMMY_SP {\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n+    }\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let function_type_metadata = unsafe {\n+        let fn_signature = get_function_signature(cx,\n+                                                  fn_ast_id,\n+                                                  &*fn_decl,\n+                                                  param_substs,\n+                                                  span);\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n+    };\n+\n+    // Get_template_parameters() will append a `<...>` clause to the function\n+    // name if necessary.\n+    let mut function_name = String::from_str(&token::get_name(name));\n+    let template_parameters = get_template_parameters(cx,\n+                                                      generics,\n+                                                      param_substs,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n+\n+    // There is no ast_map::Path for ast::ExprClosure-type functions. For now,\n+    // just don't put them into a namespace. In the future this could be improved\n+    // somehow (storing a path in the ast_map, or construct a path using the\n+    // enclosing function).\n+    let (linkage_name, containing_scope) = if has_path {\n+        let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n+        let linkage_name = namespace_node.mangled_name_of_contained_item(\n+            &function_name[..]);\n+        let containing_scope = namespace_node.scope;\n+        (linkage_name, containing_scope)\n+    } else {\n+        (function_name.clone(), file_metadata)\n+    };\n+\n+    // Clang sets this parameter to the opening brace of the function's block,\n+    // so let's do this too.\n+    let scope_line = span_start(cx, top_level_block.span).line;\n+\n+    let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n+\n+    let function_name = CString::new(function_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n+    let fn_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateFunction(\n+            DIB(cx),\n+            containing_scope,\n+            function_name.as_ptr(),\n+            linkage_name.as_ptr(),\n+            file_metadata,\n+            loc.line as c_uint,\n+            function_type_metadata,\n+            is_local_to_unit,\n+            true,\n+            scope_line as c_uint,\n+            FlagPrototyped as c_uint,\n+            cx.sess().opts.optimize != config::No,\n+            llfn,\n+            template_parameters,\n+            ptr::null_mut())\n+    };\n+\n+    let scope_map = create_scope_map::create_scope_map(cx,\n+                                                       &fn_decl.inputs,\n+                                                       &*top_level_block,\n+                                                       fn_metadata,\n+                                                       fn_ast_id);\n+\n+    // Initialize fn debug context (including scope map and namespace map)\n+    let fn_debug_context = box FunctionDebugContextData {\n+        scope_map: RefCell::new(scope_map),\n+        fn_metadata: fn_metadata,\n+        argument_counter: Cell::new(1),\n+        source_locations_enabled: Cell::new(false),\n+        source_location_override: Cell::new(false),\n+    };\n+\n+\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n+\n+    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        fn_ast_id: ast::NodeId,\n+                                        fn_decl: &ast::FnDecl,\n+                                        param_substs: &Substs<'tcx>,\n+                                        error_reporting_span: Span) -> DIArray {\n+        if cx.sess().opts.debuginfo == LimitedDebugInfo {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n+\n+        // Return type -- llvm::DIBuilder wants this at index 0\n+        assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n+        let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n+        let return_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                           param_substs,\n+                                                           &return_type);\n+        if ty::type_is_nil(return_type) {\n+            signature.push(ptr::null_mut())\n+        } else {\n+            signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n+        }\n+\n+        // Arguments types\n+        for arg in &fn_decl.inputs {\n+            assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n+            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n+            let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                            param_substs,\n+                                                            &arg_type);\n+            signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n+        }\n+\n+        return create_DIArray(DIB(cx), &signature[..]);\n+    }\n+\n+    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         generics: &ast::Generics,\n+                                         param_substs: &Substs<'tcx>,\n+                                         file_metadata: DIFile,\n+                                         name_to_append_suffix_to: &mut String)\n+                                         -> DIArray\n+    {\n+        let self_type = param_substs.self_ty();\n+        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n+\n+        // Only true for static default methods:\n+        let has_self_type = self_type.is_some();\n+\n+        if !generics.is_type_parameterized() && !has_self_type {\n+            return create_DIArray(DIB(cx), &[]);\n+        }\n+\n+        name_to_append_suffix_to.push('<');\n+\n+        // The list to be filled with template parameters:\n+        let mut template_params: Vec<DIDescriptor> =\n+            Vec::with_capacity(generics.ty_params.len() + 1);\n+\n+        // Handle self type\n+        if has_self_type {\n+            let actual_self_type = self_type.unwrap();\n+            // Add self type name to <...> clause of function name\n+            let actual_self_type_name = compute_debuginfo_type_name(\n+                cx,\n+                actual_self_type,\n+                true);\n+\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n+\n+            if generics.is_type_parameterized() {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_self_type_metadata = type_metadata(cx,\n+                                                              actual_self_type,\n+                                                              codemap::DUMMY_SP);\n+\n+                let name = token::get_name(special_idents::type_self.name);\n+\n+                let name = CString::new(name.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_self_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        // Handle other generic parameters\n+        let actual_types = param_substs.types.get_slice(subst::FnSpace);\n+        for (index, &ast::TyParam{ ident, .. }) in generics.ty_params.iter().enumerate() {\n+            let actual_type = actual_types[index];\n+            // Add actual type name to <...> clause of function name\n+            let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                               actual_type,\n+                                                               true);\n+            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n+\n+            if index != generics.ty_params.len() - 1 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            // Again, only create type information if full debuginfo is enabled\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n+                let ident = token::get_ident(ident);\n+                let name = CString::new(ident.as_bytes()).unwrap();\n+                let param_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name.as_ptr(),\n+                        actual_type_metadata,\n+                        ptr::null_mut(),\n+                        0,\n+                        0)\n+                };\n+                template_params.push(param_metadata);\n+            }\n+        }\n+\n+        name_to_append_suffix_to.push('>');\n+\n+        return create_DIArray(DIB(cx), &template_params[..]);\n+    }\n+}\n+\n+fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             variable_name: ast::Name,\n+                             variable_type: Ty<'tcx>,\n+                             scope_metadata: DIScope,\n+                             variable_access: VariableAccess,\n+                             variable_kind: VariableKind,\n+                             span: Span) {\n+    let cx: &CrateContext = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..]);\n+\n+    let name = token::get_name(variable_name);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+        LocalVariable    |\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n+\n+    let name = CString::new(name.as_bytes()).unwrap();\n+    match (variable_access, &[][..]) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            };\n+            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                                          loc.line,\n+                                                                          loc.col.to_usize()));\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n+\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+            }\n+        }\n+    }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n+            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                source_loc::set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                source_loc::clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}"}, {"sha": "0aa0408c0ef33c31a89fd1566901207dfa7b56cb", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Namespace Handling.\n+\n+use super::utils::{DIB, debug_context};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::CrateContext;\n+use middle::ty::{self, ClosureTyper};\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::{Rc, Weak};\n+use syntax::{ast, ast_map};\n+use syntax::parse::token;\n+\n+pub struct NamespaceTreeNode {\n+    pub name: ast::Name,\n+    pub scope: DIScope,\n+    pub parent: Option<Weak<NamespaceTreeNode>>,\n+}\n+\n+impl NamespaceTreeNode {\n+    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n+            match node.parent {\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                None => {}\n+            }\n+            let string = token::get_name(node.name);\n+            output.push_str(&format!(\"{}\", string.len()));\n+            output.push_str(&string);\n+        }\n+\n+        let mut name = String::from_str(\"_ZN\");\n+        fill_nested(self, &mut name);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n+        name.push_str(item_name);\n+        name.push('E');\n+        name\n+    }\n+}\n+\n+pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n+    &cx.link_meta().crate_name\n+}\n+\n+pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n+        // prepend crate name if not already present\n+        let krate = if def_id.krate == ast::LOCAL_CRATE {\n+            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n+            Some(ast_map::PathMod(crate_namespace_name))\n+        } else {\n+            None\n+        };\n+        let mut path = krate.into_iter().chain(path).peekable();\n+\n+        let mut current_key = Vec::new();\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n+\n+        // Create/Lookup namespace for each element of the path.\n+        loop {\n+            // Emulate a for loop so we can use peek below.\n+            let path_element = match path.next() {\n+                Some(e) => e,\n+                None => break\n+            };\n+            // Ignore the name of the item (the last path element).\n+            if path.peek().is_none() {\n+                break;\n+            }\n+\n+            let name = path_element.name();\n+            current_key.push(name);\n+\n+            let existing_node = debug_context(cx).namespace_map.borrow()\n+                                                 .get(&current_key).cloned();\n+            let current_node = match existing_node {\n+                Some(existing_node) => existing_node,\n+                None => {\n+                    // create and insert\n+                    let parent_scope = match parent_node {\n+                        Some(ref node) => node.scope,\n+                        None => ptr::null_mut()\n+                    };\n+                    let namespace_name = token::get_name(name);\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n+\n+                    let node = Rc::new(NamespaceTreeNode {\n+                        name: name,\n+                        scope: scope,\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n+\n+                    debug_context(cx).namespace_map.borrow_mut()\n+                                     .insert(current_key.clone(), node.clone());\n+\n+                    node\n+                }\n+            };\n+\n+            parent_node = Some(current_node);\n+        }\n+\n+        match parent_node {\n+            Some(node) => node,\n+            None => {\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n+                                       path too short for {:?}\",\n+                                      def_id));\n+            }\n+        }\n+    })\n+}"}, {"sha": "981a23fd664a91380c3376c9b3c55738d9d9caf0", "filename": "src/librustc_trans/trans/debuginfo/source_loc.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::InternalDebugLocation::*;\n+\n+use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::{FunctionDebugContext, DebugLoc};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext};\n+\n+use libc::c_uint;\n+use std::ptr;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap};\n+\n+pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                                    node_id: ast::NodeId,\n+                                                    node_span: Span,\n+                                                    is_block: bool)\n+                                                 -> NodeIdAndSpan {\n+    // A debug location needs two things:\n+    // (1) A span (of which only the beginning will actually be used)\n+    // (2) An AST node-id which will be used to look up the lexical scope\n+    //     for the location in the functions scope-map\n+    //\n+    // This function will calculate the debug location for compiler-generated\n+    // cleanup calls that are executed when control-flow leaves the\n+    // scope identified by `node_id`.\n+    //\n+    // For everything but block-like things we can simply take id and span of\n+    // the given expression, meaning that from a debugger's view cleanup code is\n+    // executed at the same source location as the statement/expr itself.\n+    //\n+    // Blocks are a special case. Here we want the cleanup to be linked to the\n+    // closing curly brace of the block. The *scope* the cleanup is executed in\n+    // is up to debate: It could either still be *within* the block being\n+    // cleaned up, meaning that locals from the block are still visible in the\n+    // debugger.\n+    // Or it could be in the scope that the block is contained in, so any locals\n+    // from within the block are already considered out-of-scope and thus not\n+    // accessible in the debugger anymore.\n+    //\n+    // The current implementation opts for the second option: cleanup of a block\n+    // already happens in the parent scope of the block. The main reason for\n+    // this decision is that scoping becomes controlflow dependent when variable\n+    // shadowing is involved and it's impossible to decide statically which\n+    // scope is actually left when the cleanup code is executed.\n+    // In practice it shouldn't make much of a difference.\n+\n+    let mut cleanup_span = node_span;\n+\n+    if is_block {\n+        // Not all blocks actually have curly braces (e.g. simple closure\n+        // bodies), in which case we also just want to return the span of the\n+        // whole expression.\n+        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n+        if let Ok(code_snippet) = code_snippet {\n+            let bytes = code_snippet.as_bytes();\n+\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n+                cleanup_span = Span {\n+                    lo: node_span.hi - codemap::BytePos(1),\n+                    hi: node_span.hi,\n+                    expn_id: node_span.expn_id\n+                };\n+            }\n+        }\n+    }\n+\n+    NodeIdAndSpan {\n+        id: node_id,\n+        span: cleanup_span\n+    }\n+}\n+\n+\n+/// Sets the current debug location at the beginning of the span.\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n+/// parameter is used to reliably find the correct visibility scope for the code\n+/// position.\n+pub fn set_source_location(fcx: &FunctionContext,\n+                           node_id: ast::NodeId,\n+                           span: Span) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            return;\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                // Just ignore any attempts to set a new debug location while\n+                // the override is active.\n+                return;\n+            }\n+\n+            let cx = fcx.ccx;\n+\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+\n+            if function_debug_context.source_locations_enabled.get() {\n+                let loc = span_start(cx, span);\n+                let scope = scope_metadata(fcx, node_id, span);\n+\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n+            } else {\n+                set_debug_location(cx, UnknownLocation);\n+            }\n+        }\n+    }\n+}\n+\n+/// This function makes sure that all debug locations emitted while executing\n+/// `wrapped_function` are set to the given `debug_loc`.\n+pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n+                                           debug_loc: DebugLoc,\n+                                           wrapped_function: F) -> R\n+    where F: FnOnce() -> R\n+{\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => {\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                wrapped_function()\n+            } else {\n+                debug_loc.apply(fcx);\n+                function_debug_context.source_location_override.set(true);\n+                let result = wrapped_function();\n+                function_debug_context.source_location_override.set(false);\n+                result\n+            }\n+        }\n+    }\n+}\n+\n+/// Clears the current debug location.\n+///\n+/// Instructions generated hereafter won't be assigned a source location.\n+pub fn clear_source_location(fcx: &FunctionContext) {\n+    if fn_should_be_ignored(fcx) {\n+        return;\n+    }\n+\n+    set_debug_location(fcx.ccx, UnknownLocation);\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to translate a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is translated.\n+pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum InternalDebugLocation {\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n+    UnknownLocation\n+}\n+\n+impl InternalDebugLocation {\n+    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+        KnownLocation {\n+            scope: scope,\n+            line: line,\n+            col: col,\n+        }\n+    }\n+}\n+\n+pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n+    if debug_location == debug_context(cx).current_debug_location.get() {\n+        return;\n+    }\n+\n+    let metadata_node;\n+\n+    match debug_location {\n+        KnownLocation { scope, line, .. } => {\n+            // Always set the column to zero like Clang and GCC\n+            let col = UNKNOWN_COLUMN_NUMBER;\n+            debug!(\"setting debug location to {} {}\", line, col);\n+\n+            unsafe {\n+                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                    debug_context(cx).llcontext,\n+                    line as c_uint,\n+                    col as c_uint,\n+                    scope,\n+                    ptr::null_mut());\n+            }\n+        }\n+        UnknownLocation => {\n+            debug!(\"clearing debug location \");\n+            metadata_node = ptr::null_mut();\n+        }\n+    };\n+\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    }\n+\n+    debug_context(cx).current_debug_location.set(debug_location);\n+}"}, {"sha": "2d0003d93a5d25a8a63e332fc42418331e8973a8", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type Names for Debug Info.\n+\n+use super::namespace::crate_root_namespace;\n+\n+use trans::common::CrateContext;\n+use middle::subst::{self, Substs};\n+use middle::ty::{self, Ty, ClosureTyper};\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::ppaux;\n+\n+\n+// Compute the name of the type as it should be stored in debuginfo. Does not do\n+// any caching, i.e. calling the function twice with the same type will also do\n+// the work twice. The `qualified` parameter only affects the first level of the\n+// type name, further levels (i.e. type parameters) are always fully qualified.\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                             t: Ty<'tcx>,\n+                                             qualified: bool)\n+                                             -> String {\n+    let mut result = String::with_capacity(64);\n+    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    result\n+}\n+\n+// Pushes the name of the type as it should be stored in debuginfo on the\n+// `output` String. See also compute_debuginfo_type_name().\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          t: Ty<'tcx>,\n+                                          qualified: bool,\n+                                          output: &mut String) {\n+    match t.sty {\n+        ty::ty_bool              => output.push_str(\"bool\"),\n+        ty::ty_char              => output.push_str(\"char\"),\n+        ty::ty_str               => output.push_str(\"str\"),\n+        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::ty_struct(def_id, substs) |\n+        ty::ty_enum(def_id, substs) => {\n+            push_item_name(cx, def_id, qualified, output);\n+            push_type_params(cx, substs, output);\n+        },\n+        ty::ty_tup(ref component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_debuginfo_type_name(cx, component_type, true, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::ty_uniq(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+            output.push('>');\n+        },\n+        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                ast::MutImmutable => output.push_str(\"const \"),\n+                ast::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == ast::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_vec(inner_type, optional_length) => {\n+            output.push('[');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+\n+            match optional_length {\n+                Some(len) => {\n+                    output.push_str(&format!(\"; {}\", len));\n+                }\n+                None => { /* nothing to do */ }\n+            };\n+\n+            output.push(']');\n+        },\n+        ty::ty_trait(ref trait_data) => {\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n+        },\n+        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == ast::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::ty_closure(..) => {\n+            output.push_str(\"closure\");\n+        }\n+        ty::ty_err |\n+        ty::ty_infer(_) |\n+        ty::ty_projection(..) |\n+        ty::ty_param(_) => {\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n+        }\n+    }\n+\n+    fn push_item_name(cx: &CrateContext,\n+                      def_id: ast::DefId,\n+                      qualified: bool,\n+                      output: &mut String) {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n+            if qualified {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    output.push_str(crate_root_namespace(cx));\n+                    output.push_str(\"::\");\n+                }\n+\n+                let mut path_element_count = 0;\n+                for path_element in path {\n+                    let name = token::get_name(path_element.name());\n+                    output.push_str(&name);\n+                    output.push_str(\"::\");\n+                    path_element_count += 1;\n+                }\n+\n+                if path_element_count == 0 {\n+                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                }\n+\n+                output.pop();\n+                output.pop();\n+            } else {\n+                let name = token::get_name(path.last()\n+                                               .expect(\"debuginfo: Empty item path?\")\n+                                               .name());\n+                output.push_str(&name);\n+            }\n+        });\n+    }\n+\n+    // Pushes the type parameters in the given `Substs` to the output string.\n+    // This ignores region parameters, since they can't reliably be\n+    // reconstructed for items from non-local crates. For local crates, this\n+    // would be possible but with inlining and LTO we have to use the least\n+    // common denominator - otherwise we would run into conflicts.\n+    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                  substs: &subst::Substs<'tcx>,\n+                                  output: &mut String) {\n+        if substs.types.is_empty() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for &type_parameter in substs.types.iter() {\n+            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+}\n+"}, {"sha": "0c12f6ed095f1b9a36b648053a8dae0fa7e1363b", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility Functions.\n+\n+use super::{FunctionDebugContext, CrateDebugContext};\n+use super::namespace::namespace_for_item;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n+use trans::machine;\n+use trans::common::{CrateContext, FunctionContext};\n+use trans::type_::Type;\n+\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+\n+pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+{\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n+    !cx.reachable().contains(&node_id)\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+    };\n+}\n+\n+pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n+    attributes.iter().any(|attr| {\n+        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        match meta_item.node {\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            _ => false\n+        }\n+    })\n+}\n+\n+/// Return codemap::Loc corresponding to the beginning of the span\n+pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n+}\n+\n+pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n+}\n+\n+pub fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n+}\n+\n+#[inline]\n+pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+                           -> &'a CrateDebugContext<'tcx> {\n+    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n+    debug_context\n+}\n+\n+#[inline]\n+#[allow(non_snake_case)]\n+pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx().as_ref().unwrap().builder\n+}\n+\n+pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n+pub fn assert_type_for_node_id(cx: &CrateContext,\n+                           node_id: ast::NodeId,\n+                           error_reporting_span: Span) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n+        cx.sess().span_bug(error_reporting_span,\n+                           \"debuginfo: Could not find type for node id!\");\n+    }\n+}\n+\n+pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+                                   -> (DIScope, Span) {\n+    let containing_scope = namespace_for_item(cx, def_id).scope;\n+    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n+        cx.tcx().map.span(def_id.node)\n+    } else {\n+        // For external items there is no span information\n+        codemap::DUMMY_SP\n+    };\n+\n+    (containing_scope, definition_span)\n+}"}, {"sha": "35946491ba17693f99d66b4d1aca6d87b6c78c10", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -71,12 +71,12 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturnAttribute);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZoneAttribute)\n     }\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {"}, {"sha": "f5ee44d69cc6353b1cf8e66d29eb89d59f289dc3", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -126,8 +126,11 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n-        if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n+    if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n+        if !qualif.intersects(check_const::ConstQualif::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n                 let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                             bcx.fcx.param_substs);\n@@ -209,12 +212,15 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n-    let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+    let adjusted_global = !qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                       bcx.fcx.param_substs);\n \n-        if qualif.intersects(check_const::HAS_STATIC_BORROWS) {\n+        if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n             // Is borrowed as 'static, must return lvalue.\n \n             // Cast pointer to global, because constants have different types."}, {"sha": "d760b2c52ca1b0217d14137f00ace8b5488fc193", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -349,8 +349,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n         // as how many bytes we can dereference\n-        attrs.arg(1, llvm::NoAliasAttribute)\n-             .arg(1, llvm::NoCaptureAttribute)\n+        attrs.arg(1, llvm::Attribute::NoAliasAttribute)\n+             .arg(1, llvm::Attribute::NoCaptureAttribute)\n              .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n "}, {"sha": "a2a9e89ff6351cd5a0d8fd05d72ad7f65693c965", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -383,7 +383,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    bcx.fcx.schedule_drop_enum_contents(cleanup::CustomScope(contents_scope), v0, t);\n+    bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n     let glue_type = get_drop_glue_type(bcx.ccx(), t);\n     let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));"}, {"sha": "7188fdebeecf4c170ddb47f2a67f6a4ebb3f654a", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -144,6 +144,9 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n     ccx.sess().abort_if_errors();\n }\n \n+/// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n+/// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n+/// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             node: ast::NodeId,\n                                             callee_ty: Ty<'tcx>,\n@@ -676,6 +679,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     llargs[1],\n                                     call_debug_location),\n \n+        (_, \"unchecked_udiv\") => UDiv(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_sdiv\") => SDiv(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_urem\") => URem(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"unchecked_srem\") => SRem(bcx, llargs[0], llargs[1], call_debug_location),\n+\n         (_, \"overflowing_add\") => Add(bcx, llargs[0], llargs[1], call_debug_location),\n         (_, \"overflowing_sub\") => Sub(bcx, llargs[0], llargs[1], call_debug_location),\n         (_, \"overflowing_mul\") => Mul(bcx, llargs[0], llargs[1], call_debug_location),\n@@ -763,7 +771,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"fence\" => {\n-                    AtomicFence(bcx, order);\n+                    AtomicFence(bcx, order, llvm::CrossThread);\n+                    C_nil(ccx)\n+                }\n+\n+                \"singlethreadfence\" => {\n+                    AtomicFence(bcx, order, llvm::SingleThread);\n                     C_nil(ccx)\n                 }\n "}, {"sha": "cb5b569fd79cb284a4ccce936aa6cecfed8ecd32", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -4882,6 +4882,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n+/// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n@@ -4910,7 +4912,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n-            \"fence\" => {\n+            \"fence\" | \"singlethreadfence\" => {\n                 (0, Vec::new(), ty::mk_nil(tcx))\n             }\n             op => {\n@@ -5119,6 +5121,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, vec!(tcx.types.u64, tcx.types.u64),\n                 ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n \n+            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n "}, {"sha": "2b15a4ff83ed13a94939240b68d5c45a44f6e056", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 275, "deletions": 19, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -20,6 +20,7 @@\n use core::prelude::*;\n \n use fmt;\n+use ffi::OsString;\n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs2 as fs_imp;\n@@ -146,6 +147,20 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n \n+/// An structure representing a type of file with accessors for each file type.\n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FileType(fs_imp::FileType);\n+\n+/// A builder used to create directories in various manners.\n+///\n+/// This builder also supports platform-specific options.\n+#[unstable(feature = \"dir_builder\", reason = \"recently added API\")]\n+pub struct DirBuilder {\n+    inner: fs_imp::DirBuilder,\n+    recursive: bool,\n+}\n+\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n@@ -485,6 +500,12 @@ impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n }\n \n impl Metadata {\n+    /// Returns the file type for this metadata.\n+    #[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> FileType {\n+        FileType(self.0.file_type())\n+    }\n+\n     /// Returns whether this metadata is for a directory.\n     ///\n     /// # Examples\n@@ -500,7 +521,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n \n     /// Returns whether this metadata is for a regular file.\n     ///\n@@ -517,7 +538,7 @@ impl Metadata {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_file(&self) -> bool { self.0.is_file() }\n+    pub fn is_file(&self) -> bool { self.file_type().is_file() }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n     ///\n@@ -562,7 +583,11 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn accessed(&self) -> u64 { self.0.accessed() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn accessed(&self) -> u64 {\n+        self.adjust_time(self.0.accessed())\n+    }\n \n     /// Returns the most recent modification time for a file.\n     ///\n@@ -571,7 +596,21 @@ impl Metadata {\n                reason = \"the return type of u64 is not quite appropriate for \\\n                          this method and may change if the standard library \\\n                          gains a type to represent a moment in time\")]\n-    pub fn modified(&self) -> u64 { self.0.modified() }\n+    #[deprecated(since = \"1.1.0\",\n+                 reason = \"use os::platform::fs::MetadataExt extension traits\")]\n+    pub fn modified(&self) -> u64 {\n+        self.adjust_time(self.0.modified())\n+    }\n+\n+    fn adjust_time(&self, val: u64) -> u64 {\n+        // FILETIME (what `val` represents) is in 100ns intervals and there are\n+        // 10000 intervals in a millisecond.\n+        if cfg!(windows) {val / 10000} else {val}\n+    }\n+}\n+\n+impl AsInner<fs_imp::FileAttr> for Metadata {\n+    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n }\n \n impl Permissions {\n@@ -624,6 +663,18 @@ impl Permissions {\n     }\n }\n \n+#[unstable(feature = \"file_type\", reason = \"recently added API\")]\n+impl FileType {\n+    /// Test whether this file type represents a directory.\n+    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+\n+    /// Test whether this file type represents a regular file.\n+    pub fn is_file(&self) -> bool { self.0.is_file() }\n+\n+    /// Test whether this file type represents a symbolic link.\n+    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n+}\n+\n impl FromInner<fs_imp::FilePermissions> for Permissions {\n     fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n         Permissions(f)\n@@ -674,6 +725,47 @@ impl DirEntry {\n     /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n+\n+    /// Return the metadata for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows this function is cheap to call (no extra system calls\n+    /// needed), but on Unix platforms this function is the equivalent of\n+    /// calling `symlink_metadata` on the path.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn metadata(&self) -> io::Result<Metadata> {\n+        self.0.metadata().map(Metadata)\n+    }\n+\n+    /// Return the file type for the file that this entry points at.\n+    ///\n+    /// This function will not traverse symlinks if this entry points at a\n+    /// symlink.\n+    ///\n+    /// # Platform behavior\n+    ///\n+    /// On Windows and most Unix platforms this function is free (no extra\n+    /// system calls needed), but some Unix platforms may require the equivalent\n+    /// call to `symlink_metadata` to learn about the target file type.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        self.0.file_type().map(FileType)\n+    }\n+\n+    /// Returns the bare file name of this directory entry without any other\n+    /// leading path component.\n+    #[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+    pub fn file_name(&self) -> OsString {\n+        self.0.file_name()\n+    }\n+}\n+\n+impl AsInner<fs_imp::DirEntry> for DirEntry {\n+    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }\n }\n \n /// Removes a file from the underlying filesystem.\n@@ -731,6 +823,25 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n     fs_imp::stat(path.as_ref()).map(Metadata)\n }\n \n+/// Query the metadata about a file without following symlinks.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(symlink_metadata)]\n+/// # fn foo() -> std::io::Result<()> {\n+/// use std::fs;\n+///\n+/// let attr = try!(fs::symlink_metadata(\"/some/file/path.txt\"));\n+/// // inspect attr ...\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[unstable(feature = \"symlink_metadata\", reason = \"recently added API\")]\n+pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n+    fs_imp::lstat(path.as_ref()).map(Metadata)\n+}\n+\n /// Rename a file or directory to a new name.\n ///\n /// # Errors\n@@ -869,6 +980,13 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_ref())\n }\n \n+/// Returns the canonical form of a path with all intermediate components\n+/// normalized and symbolic links resolved.\n+#[unstable(feature = \"fs_canonicalize\", reason = \"recently added API\")]\n+pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs_imp::canonicalize(path.as_ref())\n+}\n+\n /// Creates a new, empty directory at the provided path\n ///\n /// # Errors\n@@ -888,7 +1006,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    fs_imp::mkdir(path.as_ref())\n+    DirBuilder::new().create(path.as_ref())\n }\n \n /// Recursively create a directory and all of its parent components if they\n@@ -913,10 +1031,7 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    let path = path.as_ref();\n-    if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n-    if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n-    create_dir(path)\n+    DirBuilder::new().recursive(true).create(path.as_ref())\n }\n \n /// Removes an existing, empty directory.\n@@ -966,19 +1081,14 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     let path = path.as_ref();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n-        let stat = try!(lstat(&*child));\n+        let stat = try!(symlink_metadata(&*child));\n         if stat.is_dir() {\n             try!(remove_dir_all(&*child));\n         } else {\n             try!(remove_file(&*child));\n         }\n     }\n-    return remove_dir(path);\n-\n-    #[cfg(unix)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::lstat(path) }\n-    #[cfg(windows)]\n-    fn lstat(path: &Path) -> io::Result<fs_imp::FileAttr> { fs_imp::stat(path) }\n+    remove_dir(path)\n }\n \n /// Returns an iterator over the entries within a directory.\n@@ -1073,11 +1183,37 @@ impl Iterator for WalkDir {\n pub trait PathExt {\n     /// Gets information on the file, directory, etc at this path.\n     ///\n-    /// Consult the `fs::stat` documentation for more info.\n+    /// Consult the `fs::metadata` documentation for more info.\n     ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::metadata`.\n     fn metadata(&self) -> io::Result<Metadata>;\n \n+    /// Gets information on the file, directory, etc at this path.\n+    ///\n+    /// Consult the `fs::symlink_metadata` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::symlink_metadata`.\n+    fn symlink_metadata(&self) -> io::Result<Metadata>;\n+\n+    /// Returns the canonical form of a path, normalizing all components and\n+    /// eliminate all symlinks.\n+    ///\n+    /// This call preserves identical runtime/error semantics with\n+    /// `fs::canonicalize`.\n+    fn canonicalize(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the symlink at this path.\n+    ///\n+    /// For more information see `fs::read_link`.\n+    fn read_link(&self) -> io::Result<PathBuf>;\n+\n+    /// Reads the directory at this path.\n+    ///\n+    /// For more information see `fs::read_dir`.\n+    fn read_dir(&self) -> io::Result<ReadDir>;\n+\n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n     fn exists(&self) -> bool;\n@@ -1098,12 +1234,16 @@ pub trait PathExt {\n \n impl PathExt for Path {\n     fn metadata(&self) -> io::Result<Metadata> { metadata(self) }\n-\n+    fn symlink_metadata(&self) -> io::Result<Metadata> { symlink_metadata(self) }\n+    fn canonicalize(&self) -> io::Result<PathBuf> { canonicalize(self) }\n+    fn read_link(&self) -> io::Result<PathBuf> { read_link(self) }\n+    fn read_dir(&self) -> io::Result<ReadDir> { read_dir(self) }\n     fn exists(&self) -> bool { metadata(self).is_ok() }\n \n     fn is_file(&self) -> bool {\n         metadata(self).map(|s| s.is_file()).unwrap_or(false)\n     }\n+\n     fn is_dir(&self) -> bool {\n         metadata(self).map(|s| s.is_dir()).unwrap_or(false)\n     }\n@@ -1152,6 +1292,52 @@ pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result\n     fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n+impl DirBuilder {\n+    /// Creates a new set of options with default mode/security settings for all\n+    /// platforms and also non-recursive.\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {\n+            inner: fs_imp::DirBuilder::new(),\n+            recursive: false,\n+        }\n+    }\n+\n+    /// Indicate that directories create should be created recursively, creating\n+    /// all parent directories if they do not exist with the same security and\n+    /// permissions settings.\n+    ///\n+    /// This option defaults to `false`\n+    pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n+        self.recursive = recursive;\n+        self\n+    }\n+\n+    /// Create the specified directory with the options configured in this\n+    /// builder.\n+    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        let path = path.as_ref();\n+        if self.recursive {\n+            self.create_dir_all(path)\n+        } else {\n+            self.inner.mkdir(path)\n+        }\n+    }\n+\n+    fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n+        if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n+        if let Some(p) = path.parent() {\n+            try!(self.create_dir_all(p))\n+        }\n+        self.inner.mkdir(path)\n+    }\n+}\n+\n+impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder {\n+        &mut self.inner\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     #![allow(deprecated)] //rand\n@@ -1924,4 +2110,74 @@ mod tests {\n         let path = tmpdir.join(\"file\");\n         check!(fs::create_dir_all(&path.join(\"a/\")));\n     }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+        let file = tmpdir.join(\"test\");\n+        let dir = tmpdir.join(\"test2\");\n+        let link = dir.join(\"link\");\n+        let linkdir = tmpdir.join(\"test3\");\n+\n+        File::create(&file).unwrap();\n+        fs::create_dir(&dir).unwrap();\n+        fs::soft_link(&file, &link).unwrap();\n+        fs::soft_link(&dir, &linkdir).unwrap();\n+\n+        assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n+\n+        assert_eq!(fs::canonicalize(&tmpdir).unwrap(), tmpdir);\n+        assert_eq!(fs::canonicalize(&file).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&link).unwrap(), file);\n+        assert_eq!(fs::canonicalize(&linkdir).unwrap(), dir);\n+        assert_eq!(fs::canonicalize(&linkdir.join(\"link\")).unwrap(), file);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn realpath_works_tricky() {\n+        let tmpdir = tmpdir();\n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+\n+        let a = tmpdir.join(\"a\");\n+        let b = a.join(\"b\");\n+        let c = b.join(\"c\");\n+        let d = a.join(\"d\");\n+        let e = d.join(\"e\");\n+        let f = a.join(\"f\");\n+\n+        fs::create_dir_all(&b).unwrap();\n+        fs::create_dir_all(&d).unwrap();\n+        File::create(&f).unwrap();\n+        fs::soft_link(\"../d/e\", &c).unwrap();\n+        fs::soft_link(\"../f\", &e).unwrap();\n+\n+        assert_eq!(fs::canonicalize(&c).unwrap(), f);\n+        assert_eq!(fs::canonicalize(&e).unwrap(), f);\n+    }\n+\n+    #[test]\n+    fn dir_entry_methods() {\n+        let tmpdir = tmpdir();\n+\n+        fs::create_dir_all(&tmpdir.join(\"a\")).unwrap();\n+        File::create(&tmpdir.join(\"b\")).unwrap();\n+\n+        for file in tmpdir.path().read_dir().unwrap().map(|f| f.unwrap()) {\n+            let fname = file.file_name();\n+            match fname.to_str() {\n+                Some(\"a\") => {\n+                    assert!(file.file_type().unwrap().is_dir());\n+                    assert!(file.metadata().unwrap().is_dir());\n+                }\n+                Some(\"b\") => {\n+                    assert!(file.file_type().unwrap().is_file());\n+                    assert!(file.metadata().unwrap().is_file());\n+                }\n+                f => panic!(\"unknown file name: {:?}\", f),\n+            }\n+        }\n+    }\n }"}, {"sha": "6a84c6ace47b4d397875b8deab57a042e1196950", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -107,26 +107,27 @@\n #![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n+#![feature(allow_internal_unstable)]\n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(debug_builders)]\n+#![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n+#![feature(macro_reexport)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(std_misc)]\n+#![feature(str_char)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(macro_reexport)]\n #![feature(unique)]\n-#![feature(allow_internal_unstable)]\n-#![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(std_misc)]\n-#![feature(slice_patterns)]\n-#![feature(debug_builders)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(zero_one)]\n #![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n@@ -307,13 +308,12 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    pub use option; // used for bitflags!{}\n+    pub use option; // used for thread_local!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n     pub use cell; // used for tls!\n     pub use thread; // used for thread_local!\n     pub use marker;  // used for tls!\n-    pub use ops; // used for bitflags!\n \n     // The test runner calls ::std::env::args() but really wants realstd\n     #[cfg(test)] pub use realstd::env as env;"}, {"sha": "b0bf9d0f8062674785c21a37fdb27c82ca530cfe", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -41,7 +41,7 @@ pub enum SocketAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV4 { inner: libc::sockaddr_in }\n \n-/// An IPv6 socket address\n+/// An IPv6 socket address.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV6 { inner: libc::sockaddr_in6 }\n@@ -56,7 +56,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[unstable(feature = \"ip_addr\", reason = \"recent addition\")]\n     pub fn ip(&self) -> IpAddr {\n         match *self {\n@@ -65,7 +65,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n         match *self {\n@@ -89,15 +89,15 @@ impl SocketAddrV4 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n         unsafe {\n             &*(&self.inner.sin_addr as *const libc::in_addr as *const Ipv4Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }\n }\n@@ -120,24 +120,24 @@ impl SocketAddrV6 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n         unsafe {\n             &*(&self.inner.sin6_addr as *const libc::in6_addr as *const Ipv6Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_flowinfo` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flowinfo(&self) -> u32 { ntoh(self.inner.sin6_flowinfo) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_scope_id` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }"}, {"sha": "9fd69840f7f054ee93927945b2211297bec44463", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -60,7 +60,7 @@ pub enum Ipv6MulticastScope {\n impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n-    /// The result will represent the IP address a.b.c.d\n+    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n@@ -73,19 +73,19 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns the four eight-bit integers that make up this address\n+    /// Returns the four eight-bit integers that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n     }\n \n-    /// Returns true for the special 'unspecified' address 0.0.0.0\n+    /// Returns true for the special 'unspecified' address 0.0.0.0.\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n     }\n \n-    /// Returns true if this is a loopback address (127.0.0.0/8)\n+    /// Returns true if this is a loopback address (127.0.0.0/8).\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n@@ -106,7 +106,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns true if the address is link-local (169.254.0.0/16)\n+    /// Returns true if the address is link-local (169.254.0.0/16).\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n@@ -116,7 +116,7 @@ impl Ipv4Addr {\n     /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n     /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n     /// the link-local network (169.254.0.0/16), the broadcast address (255.255.255.255/32) and\n-    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n+    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24).\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation()\n@@ -131,13 +131,13 @@ impl Ipv4Addr {\n \n     /// Returns true if this is a broadcast address.\n     ///\n-    /// A broadcast address has all octets set to 255 as defined in RFC 919\n+    /// A broadcast address has all octets set to 255 as defined in RFC 919.\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n         self.octets()[2] == 255 && self.octets()[3] == 255\n     }\n \n-    /// Returns true if this address is in a range designated for documentation\n+    /// Returns true if this address is in a range designated for documentation.\n     ///\n     /// This is defined in RFC 5737\n     /// - 192.0.2.0/24 (TEST-NET-1)\n@@ -152,7 +152,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Converts this address to an IPv4-compatible IPv6 address\n+    /// Converts this address to an IPv4-compatible IPv6 address.\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -162,7 +162,7 @@ impl Ipv4Addr {\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n \n-    /// Converts this address to an IPv4-mapped IPv6 address\n+    /// Converts this address to an IPv4-mapped IPv6 address.\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -247,7 +247,7 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n-    /// The result will represent the IP address a:b:c:d:e:f:g:h\n+    /// The result will represent the IP address a:b:c:d:e:f:g:h.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n@@ -259,7 +259,7 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns the eight 16-bit segments that make up this address\n+    /// Returns the eight 16-bit segments that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         [ntoh(self.inner.s6_addr[0]),\n@@ -272,12 +272,12 @@ impl Ipv6Addr {\n          ntoh(self.inner.s6_addr[7])]\n     }\n \n-    /// Returns true for the special 'unspecified' address ::\n+    /// Returns true for the special 'unspecified' address ::.\n     pub fn is_unspecified(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n     }\n \n-    /// Returns true if this is a loopback address (::1)\n+    /// Returns true if this is a loopback address (::1).\n     pub fn is_loopback(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n     }\n@@ -295,25 +295,25 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns true if this is a unique local address (IPv6)\n+    /// Returns true if this is a unique local address (IPv6).\n     ///\n-    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7\n+    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7.\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n-    /// Returns true if the address is unicast and link-local (fe80::/10)\n+    /// Returns true if the address is unicast and link-local (fe80::/10).\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n     /// Returns true if this is a deprecated unicast site-local address (IPv6\n-    /// fec0::/10)\n+    /// fec0::/10).\n     pub fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n \n-    /// Returns true if the address is a globally routable unicast address\n+    /// Returns true if the address is a globally routable unicast address.\n     ///\n     /// Non-globally-routable unicast addresses include the loopback address,\n     /// the link-local addresses, the deprecated site-local addresses and the"}, {"sha": "2e7c0a2c80e59bac54a00eeaf686df2bbe70a169", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Networking primitives for TCP/UDP communication\n-//!\n-//! > **NOTE**: This module is very much a work in progress and is under active\n-//! > development.\n+//! Networking primitives for TCP/UDP communication.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "130e1eee8f924e1a456f93e923da329d186663bd", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -125,7 +125,7 @@ impl TcpStream {\n         self.0.duplicate().map(TcpStream)\n     }\n \n-    /// Sets the nodelay flag on this connection to the boolean specified\n+    /// Sets the nodelay flag on this connection to the boolean specified.\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         self.0.set_nodelay(nodelay)\n     }"}, {"sha": "0b04ecb1b7228565577b5a958348922a5e596db6", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -50,8 +50,8 @@ pub struct UdpSocket(net_imp::UdpSocket);\n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n-    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n+    /// The address type can be any implementor of `ToSocketAddr` trait. See\n+    /// its documentation for concrete examples.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n@@ -64,8 +64,8 @@ impl UdpSocket {\n         self.0.recv_from(buf)\n     }\n \n-    /// Sends data on the socket to the given address. Returns nothing on\n-    /// success.\n+    /// Sends data on the socket to the given address. On success, returns the\n+    /// number of bytes written.\n     ///\n     /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n     /// documentation for concrete examples.\n@@ -95,34 +95,34 @@ impl UdpSocket {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n-    /// Sets the broadcast flag on or off\n+    /// Sets the broadcast flag on or off.\n     pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n         self.0.set_broadcast(on)\n     }\n \n-    /// Sets the multicast loop flag to the specified value\n+    /// Sets the multicast loop flag to the specified value.\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n         self.0.set_multicast_loop(on)\n     }\n \n-    /// Joins a multicast IP address (becomes a member of it)\n+    /// Joins a multicast IP address (becomes a member of it).\n     pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.join_multicast(multi)\n     }\n \n-    /// Leaves a multicast IP address (drops membership from it)\n+    /// Leaves a multicast IP address (drops membership from it).\n     pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.leave_multicast(multi)\n     }\n \n-    /// Sets the multicast TTL\n+    /// Sets the multicast TTL.\n     pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.multicast_time_to_live(ttl)\n     }\n \n-    /// Sets this socket's TTL\n+    /// Sets this socket's TTL.\n     pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.time_to_live(ttl)\n     }"}, {"sha": "346a903c4d9a9b7f99581553a769ed64a7805fb7", "filename": "src/libstd/os/android/mod.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! OS-specific functionality\n+//! Android-specific definitions\n \n-#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n \n-#[cfg(unix)] pub use sys::ext as unix;\n-#[cfg(windows)] pub use sys::ext as windows;\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}", "previous_filename": "src/libstd/os.rs"}, {"sha": "538ed7c4688c77f12a58ce6b85a9002fd9b14399", "filename": "src/libstd/os/android/raw.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Android-specific raw type definitions\n+\n+use os::raw::{c_uint, c_uchar, c_ulonglong, c_longlong, c_ulong};\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = u32;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i32;\n+pub type time_t = i32;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: c_ulonglong,\n+    pub __pad0: [c_uchar; 4],\n+    pub __st_ino: ino_t,\n+    pub st_mode: c_uint,\n+    pub st_nlink: c_uint,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: c_ulonglong,\n+    pub __pad3: [c_uchar; 4],\n+    pub st_size: c_longlong,\n+    pub st_blksize: blksize_t,\n+    pub st_blocks: c_ulonglong,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_ulong,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_ulong,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_ulong,\n+    pub st_ino: c_ulonglong,\n+}"}, {"sha": "01ea542b3b71379dea8691638c32c7e1c960b793", "filename": "src/libstd/os/bitrig/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bitrig-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "aebc21aa71856c701a04fa38f4a4ead6cd30a05c", "filename": "src/libstd/os/bitrig/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bitrig-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "677f8b706cdbddd120c6542115f463802fb0d690", "filename": "src/libstd/os/dragonfly/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "22c811ead43351518600ed9942d919c2a055b66e", "filename": "src/libstd/os/dragonfly/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Dragonfly-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{pid_t, uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_padding1: u16,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: uint32_t,\n+    pub st_lspare: int32_t,\n+    pub st_qspare1: int64_t,\n+    pub st_qspare2: int64_t,\n+}"}, {"sha": "73b6fd211371cb21415f42c57f7c4e24f233c7d8", "filename": "src/libstd/os/freebsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "a810eff45d32e27fb47d8e6496a7b604625c1e68", "filename": "src/libstd/os/freebsd/raw.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! FreeBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i64;\n+pub type dev_t = u32;\n+pub type fflags_t = u32;\n+pub type ino_t = u32;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub __unused: [u8; 2],\n+}"}, {"sha": "d471cf12fe63e7d60b5c8b1739a8ec401d1fe9e0", "filename": "src/libstd/os/ios/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "3266b3846d899aa3d957c75aa684f789cf3d3190", "filename": "src/libstd/os/ios/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! iOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "43376a1baeb928c214051ea21ec2ead98b90d308", "filename": "src/libstd/os/linux/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "adce5f22ebc10b919e9c87b297f191c20a98ebb4", "filename": "src/libstd/os/linux/raw.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Linux-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+#[doc(inline)]\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "bc5ff5b25d2fa1d77bfa16d1090e674971e6feea", "filename": "src/libstd/os/macos/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "03fcb768c119aabafc1ad0c6da5c596666ac8478", "filename": "src/libstd/os/macos/raw.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MacOS-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type off_t = i64;\n+pub type time_t = c_long;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_dev: dev_t,\n+    pub st_mode: mode_t,\n+    pub st_nlink: nlink_t,\n+    pub st_ino: ino_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: u32,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_qspare: [i64; 2],\n+}"}, {"sha": "cc4b1c944e7861124462ef7c53e4239fe1c2b302", "filename": "src/libstd/os/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OS-specific functionality\n+\n+#![stable(feature = \"os\", since = \"1.0.0\")]\n+#![allow(missing_docs, bad_style)]\n+\n+#[cfg(unix)]    pub use sys::ext as unix;\n+#[cfg(windows)] pub use sys::ext as windows;\n+\n+#[cfg(target_os = \"android\")]   pub mod android;\n+#[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n+#[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n+#[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n+#[cfg(target_os = \"ios\")]       pub mod ios;\n+#[cfg(target_os = \"linux\")]     pub mod linux;\n+#[cfg(target_os = \"macos\")]     pub mod macos;\n+#[cfg(target_os = \"nacl\")]      pub mod nacl;\n+#[cfg(target_os = \"openbsd\")]   pub mod openbsd;\n+\n+pub mod raw;"}, {"sha": "6baed03951467ac4e447b6089e74c82314bb364b", "filename": "src/libstd/os/nacl/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "9defa8301ea3428fba09198597482b0403563eff", "filename": "src/libstd/os/nacl/raw.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Nacl-specific raw type definitions\n+\n+pub type dev_t = u64;\n+pub type mode_t = u32;\n+\n+pub use self::arch::{off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};\n+\n+#[cfg(any(target_arch = \"x86\",\n+          target_arch = \"le32\",\n+          target_arch = \"powerpc\",\n+          target_arch = \"arm\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_short};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub __pad1: c_short,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad2: c_short,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused4: c_long,\n+        pub __unused5: c_long,\n+    }\n+}\n+\n+#[cfg(any(target_arch = \"mips\",\n+          target_arch = \"mipsel\"))]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::c_long;\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i32;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u32;\n+    pub type nlink_t = u32;\n+    pub type off_t = i32;\n+    pub type time_t = i32;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: c_ulong,\n+        pub st_pad1: [c_long; 3],\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: c_ulong,\n+        pub st_pad2: [c_long; 2],\n+        pub st_size: off_t,\n+        pub st_pad3: c_long,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_pad5: [c_long; 14],\n+    }\n+}\n+\n+#[cfg(target_arch = \"aarch64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i32;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u32;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub st_rdev: dev_t,\n+        pub __pad1: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub __pad2: c_int,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_int; 2],\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod arch {\n+    use super::{dev_t, mode_t};\n+    use os::raw::{c_long, c_int};\n+    use os::unix::raw::{gid_t, uid_t};\n+\n+    pub type blkcnt_t = i64;\n+    pub type blksize_t = i64;\n+    pub type ino_t = u64;\n+    pub type nlink_t = u64;\n+    pub type off_t = i64;\n+    pub type time_t = i64;\n+\n+    #[repr(C)]\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_nlink: nlink_t,\n+        pub st_mode: mode_t,\n+        pub st_uid: uid_t,\n+        pub st_gid: gid_t,\n+        pub __pad0: c_int,\n+        pub st_rdev: dev_t,\n+        pub st_size: off_t,\n+        pub st_blksize: blksize_t,\n+        pub st_blocks: blkcnt_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub __unused: [c_long; 3],\n+    }\n+}"}, {"sha": "1b1a10055902bce06fbfde23b94ae3636a91b03e", "filename": "src/libstd/os/openbsd/mod.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific definitions\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub mod raw;\n+\n+pub mod fs {\n+    pub use sys::fs2::MetadataExt;\n+}"}, {"sha": "632a8c336b78dc869d952437c0beab67bf083272", "filename": "src/libstd/os/openbsd/raw.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OpenBSD-specific raw type definitions\n+\n+use os::raw::c_long;\n+use os::unix::raw::{uid_t, gid_t, pid_t};\n+\n+pub type blkcnt_t = i64;\n+pub type blksize_t = u32;\n+pub type dev_t = i32;\n+pub type fflags_t = u32; // type not declared, but struct stat have u_int32_t\n+pub type ino_t = u64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type off_t = i64;\n+pub type time_t = i64;\n+\n+#[repr(C)]\n+pub struct stat {\n+    pub st_mode: mode_t,\n+    pub st_dev: dev_t,\n+    pub st_ino: ino_t,\n+    pub st_nlink: nlink_t,\n+    pub st_uid: uid_t,\n+    pub st_gid: gid_t,\n+    pub st_rdev: dev_t,\n+    pub st_atime: time_t,\n+    pub st_atime_nsec: c_long,\n+    pub st_mtime: time_t,\n+    pub st_mtime_nsec: c_long,\n+    pub st_ctime: time_t,\n+    pub st_ctime_nsec: c_long,\n+    pub st_size: off_t,\n+    pub st_blocks: blkcnt_t,\n+    pub st_blksize: blksize_t,\n+    pub st_flags: fflags_t,\n+    pub st_gen: u32,\n+    pub st_birthtime: time_t,\n+    pub st_birthtime_nsec: c_long,\n+}"}, {"sha": "44f4a1c828b54e864189b292a0bef2a6508757f6", "filename": "src/libstd/os/raw.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Raw OS-specific types for the current platform/architecture\n+\n+#![unstable(feature = \"raw_os\", reason = \"recently added API\")]\n+\n+#[cfg(target_arch = \"aarch64\")]      pub type c_char = u8;\n+#[cfg(not(target_arch = \"aarch64\"))] pub type c_char = i8;\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_long = i32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] pub type c_ulong = u32;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_long = i64;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] pub type c_ulong = u64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+\n+/// Type used to construct void pointers for use with C.\n+///\n+/// This type is only useful as a pointer target. Do not use it as a\n+/// return type for FFI functions which have the `void` return type in\n+/// C. Use the unit type `()` or omit the return type instead.\n+// NB: For LLVM to recognize the void pointer type and by extension\n+//     functions like malloc(), we need to have it represented as i8* in\n+//     LLVM bitcode. The enum used here ensures this and prevents misuse\n+//     of the \"raw\" type by only having private variants.. We need two\n+//     variants, because the compiler complains about the repr attribute\n+//     otherwise.\n+#[repr(u8)]\n+pub enum c_void {\n+    #[doc(hidden)] __variant1,\n+    #[doc(hidden)] __variant2,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use any::TypeId;\n+    use libc;\n+    use mem;\n+\n+    macro_rules! ok {\n+        ($($t:ident)*) => {$(\n+            assert!(TypeId::of::<libc::$t>() == TypeId::of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    macro_rules! ok_size {\n+        ($($t:ident)*) => {$(\n+            assert!(mem::size_of::<libc::$t>() == mem::size_of::<raw::$t>(),\n+                    \"{} is wrong\", stringify!($t));\n+        )*}\n+    }\n+\n+    #[test]\n+    fn same() {\n+        use os::raw;\n+        ok!(c_char c_schar c_uchar c_short c_ushort c_int c_uint c_long c_ulong\n+            c_longlong c_ulonglong c_float c_double);\n+    }\n+\n+    #[cfg(unix)]\n+    fn unix() {\n+        {\n+            use os::unix::raw;\n+            ok!(uid_t gid_t dev_t ino_t mode_t nlink_t off_t blksize_t blkcnt_t);\n+        }\n+        {\n+            use sys::platform::raw;\n+            ok_size!(stat);\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn windows() {\n+        use os::windows::raw;\n+    }\n+}"}, {"sha": "2d7123692289d32e17f71c777096fcdd8cac30ad", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -59,7 +59,11 @@ impl Once {\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n-    /// has run and completed (it may not be the closure specified).\n+    /// has run and completed (it may not be the closure specified). It is also\n+    /// guaranteed that any memory writes performed by the executed closure can\n+    /// be reliably observed by other tasks at this point (there is a\n+    /// happens-before relation between the closure and code executing after the\n+    /// return).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add."}, {"sha": "1e68eac5a67354b880b5a7e678a7ae8e67fda3ea", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -161,6 +161,8 @@ extern {\n     pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n     pub fn setgroups(ngroups: libc::c_int,\n                      ptr: *const libc::c_void) -> libc::c_int;\n+    pub fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n+                    -> *mut libc::c_char;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "66aaf26b09b72e1ff58b82002e463b7110732160", "filename": "src/libstd/sys/unix/ext.rs", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=551a74dddd84cf01440ee84148ebd18bc68bd7c8", "patch": "@@ -1,337 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Experimental extensions to `std` for Unix platforms.\n-//!\n-//! For now, this module is limited to extracting file descriptors,\n-//! but its functionality will grow over time.\n-//!\n-//! # Example\n-//!\n-//! ```no_run\n-//! use std::fs::File;\n-//! use std::os::unix::prelude::*;\n-//!\n-//! fn main() {\n-//!     let f = File::create(\"foo.txt\").unwrap();\n-//!     let fd = f.as_raw_fd();\n-//!\n-//!     // use fd with native unix bindings\n-//! }\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-/// Unix-specific extensions to general I/O primitives\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod io {\n-    use fs;\n-    use libc;\n-    use net;\n-    use sys_common::{net2, AsInner, FromInner};\n-    use sys;\n-\n-    /// Raw file descriptors.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawFd = libc::c_int;\n-\n-    /// A trait to extract the raw unix file descriptor from an underlying\n-    /// object.\n-    ///\n-    /// This is only available on unix platforms and must be imported in order\n-    /// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-    /// and `AsRawSocket` set of traits.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawFd {\n-        /// Extracts the raw file descriptor.\n-        ///\n-        /// This method does **not** pass ownership of the raw file descriptor\n-        /// to the caller. The descriptor is only guarantee to be valid while\n-        /// the original object has not yet been destroyed.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_fd(&self) -> RawFd;\n-    }\n-\n-    /// A trait to express the ability to construct an object from a raw file\n-    /// descriptor.\n-    #[unstable(feature = \"from_raw_os\",\n-               reason = \"recent addition to std::os::unix::io\")]\n-    pub trait FromRawFd {\n-        /// Constructs a new instances of `Self` from the given raw file\n-        /// descriptor.\n-        ///\n-        /// This function **consumes ownership** of the specified file\n-        /// descriptor. The returned object will take responsibility for closing\n-        /// it when the object goes out of scope.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for fs::File {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd().raw()\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for fs::File {\n-        unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-            fs::File::from_inner(sys::fs2::File::from_inner(fd))\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::TcpStream {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::TcpListener {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for net::UdpSocket {\n-        fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::TcpStream {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::TcpListener {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawFd for net::UdpSocket {\n-        unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-            let socket = sys::net::Socket::from_inner(fd);\n-            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// OsString and OsStr\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix-specific extension to the primitives in the `std::ffi` module\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod ffi {\n-    use ffi::{OsStr, OsString};\n-    use mem;\n-    use prelude::v1::*;\n-    use sys::os_str::Buf;\n-    use sys_common::{FromInner, IntoInner, AsInner};\n-\n-    /// Unix-specific extensions to `OsString`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStringExt {\n-        /// Creates an `OsString` from a byte vector.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_vec(vec: Vec<u8>) -> Self;\n-\n-        /// Yields the underlying byte vector of this `OsString`.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn into_vec(self) -> Vec<u8>;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStringExt for OsString {\n-        fn from_vec(vec: Vec<u8>) -> OsString {\n-            FromInner::from_inner(Buf { inner: vec })\n-        }\n-        fn into_vec(self) -> Vec<u8> {\n-            self.into_inner().inner\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `OsStr`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStrExt {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_bytes(slice: &[u8]) -> &Self;\n-\n-        /// Gets the underlying byte view of the `OsStr` slice.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_bytes(&self) -> &[u8];\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStrExt for OsStr {\n-        fn from_bytes(slice: &[u8]) -> &OsStr {\n-            unsafe { mem::transmute(slice) }\n-        }\n-        fn as_bytes(&self) -> &[u8] {\n-            &self.as_inner().inner\n-        }\n-    }\n-}\n-\n-/// Unix-specific extensions to primitives in the `std::fs` module.\n-#[unstable(feature = \"fs_ext\",\n-           reason = \"may want a more useful mode abstraction\")]\n-pub mod fs {\n-    use sys;\n-    use sys_common::{FromInner, AsInner, AsInnerMut};\n-    use fs::{Permissions, OpenOptions};\n-    use path::Path;\n-    use convert::AsRef;\n-    use io;\n-\n-    /// Unix-specific extensions to `Permissions`\n-    pub trait PermissionsExt {\n-        fn mode(&self) -> i32;\n-        fn set_mode(&mut self, mode: i32);\n-    }\n-\n-    impl PermissionsExt for Permissions {\n-        fn mode(&self) -> i32 { self.as_inner().mode() }\n-\n-        fn set_mode(&mut self, mode: i32) {\n-            *self = FromInner::from_inner(FromInner::from_inner(mode));\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `OpenOptions`\n-    pub trait OpenOptionsExt {\n-        /// Sets the mode bits that a new file will be created with.\n-        ///\n-        /// If a new file is created as part of a `File::open_opts` call then this\n-        /// specified `mode` will be used as the permission bits for the new file.\n-        fn mode(&mut self, mode: i32) -> &mut Self;\n-    }\n-\n-    impl OpenOptionsExt for OpenOptions {\n-        fn mode(&mut self, mode: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().mode(mode); self\n-        }\n-    }\n-\n-    /// Creates a new symbolic link on the filesystem.\n-    ///\n-    /// The `dst` path will be a symbolic link pointing to the `src` path.\n-    ///\n-    /// # Note\n-    ///\n-    /// On Windows, you must specify whether a symbolic link points to a file\n-    /// or directory.  Use `os::windows::fs::symlink_file` to create a\n-    /// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n-    /// symbolic link to a directory.  Additionally, the process must have\n-    /// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n-    /// symbolic link.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(fs_ext)]\n-    /// use std::os::unix::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n-    {\n-        sys::fs2::symlink(src.as_ref(), dst.as_ref())\n-    }\n-\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Process and Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Unix-specific extensions to primitives in the `std::process` module.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod process {\n-    use prelude::v1::*;\n-    use libc::{uid_t, gid_t};\n-    use process;\n-    use sys;\n-    use sys_common::{AsInnerMut, AsInner};\n-\n-    /// Unix-specific extensions to the `std::process::Command` builder\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait CommandExt {\n-        /// Sets the child process's user id. This translates to a\n-        /// `setuid` call in the child process. Failure in the `setuid`\n-        /// call will cause the spawn to fail.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn uid(&mut self, id: uid_t) -> &mut process::Command;\n-\n-        /// Similar to `uid`, but sets the group id of the child process. This has\n-        /// the same semantics as the `uid` field.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn gid(&mut self, id: gid_t) -> &mut process::Command;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl CommandExt for process::Command {\n-        fn uid(&mut self, id: uid_t) -> &mut process::Command {\n-            self.as_inner_mut().uid = Some(id);\n-            self\n-        }\n-\n-        fn gid(&mut self, id: gid_t) -> &mut process::Command {\n-            self.as_inner_mut().gid = Some(id);\n-            self\n-        }\n-    }\n-\n-    /// Unix-specific extensions to `std::process::ExitStatus`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait ExitStatusExt {\n-        /// If the process was terminated by a signal, returns that signal.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn signal(&self) -> Option<i32>;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ExitStatusExt for process::ExitStatus {\n-        fn signal(&self) -> Option<i32> {\n-            match *self.as_inner() {\n-                sys::process2::ExitStatus::Signal(s) => Some(s),\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Prelude\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// A prelude for conveniently writing platform-specific code.\n-///\n-/// Includes all extension traits, and some important type definitions.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    pub use super::io::{RawFd, AsRawFd};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    pub use super::fs::{PermissionsExt, OpenOptionsExt};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::process::{CommandExt, ExitStatusExt};\n-}"}, {"sha": "825e74cabdebb6b3c4264ad247ed90741fcf8c9a", "filename": "src/libstd/sys/unix/ext/ffi.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fffi.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extension to the primitives in the `std::ffi` module\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsStr, OsString};\n+use mem;\n+use prelude::v1::*;\n+use sys::os_str::Buf;\n+use sys_common::{FromInner, IntoInner, AsInner};\n+\n+/// Unix-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a byte vector.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yields the underlying byte vector of this `OsString`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+/// Unix-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+\n+    /// Gets the underlying byte view of the `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}"}, {"sha": "2e4ed38e50fe7c10935e04ffa759f5ef340bcb9d", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::fs` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use prelude::v1::*;\n+\n+use fs::{self, Permissions, OpenOptions};\n+use io;\n+use mem;\n+use os::raw::c_long;\n+use os::unix::raw;\n+use path::Path;\n+use sys::platform;\n+use sys;\n+use sys_common::{FromInner, AsInner, AsInnerMut};\n+\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_READ: raw::mode_t = 0o400;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_WRITE: raw::mode_t = 0o200;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_EXECUTE: raw::mode_t = 0o100;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const USER_RWX: raw::mode_t = 0o700;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_READ: raw::mode_t = 0o040;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_WRITE: raw::mode_t = 0o020;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_EXECUTE: raw::mode_t = 0o010;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const GROUP_RWX: raw::mode_t = 0o070;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_READ: raw::mode_t = 0o004;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_WRITE: raw::mode_t = 0o002;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_EXECUTE: raw::mode_t = 0o001;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const OTHER_RWX: raw::mode_t = 0o007;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_READ: raw::mode_t = 0o444;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_WRITE: raw::mode_t = 0o222;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_EXECUTE: raw::mode_t = 0o111;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const ALL_RWX: raw::mode_t = 0o777;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const SETUID: raw::mode_t = 0o4000;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const SETGID: raw::mode_t = 0o2000;\n+#[unstable(feature = \"fs_mode\", reason = \"recently added API\")]\n+pub const STICKY_BIT: raw::mode_t = 0o1000;\n+\n+/// Unix-specific extensions to `Permissions`\n+#[unstable(feature = \"fs_ext\",\n+           reason = \"may want a more useful mode abstraction\")]\n+pub trait PermissionsExt {\n+    fn mode(&self) -> raw::mode_t;\n+    fn set_mode(&mut self, mode: raw::mode_t);\n+    fn from_mode(mode: raw::mode_t) -> Self;\n+}\n+\n+impl PermissionsExt for Permissions {\n+    fn mode(&self) -> raw::mode_t { self.as_inner().mode() }\n+\n+    fn set_mode(&mut self, mode: raw::mode_t) {\n+        *self = FromInner::from_inner(FromInner::from_inner(mode));\n+    }\n+\n+    fn from_mode(mode: raw::mode_t) -> Permissions {\n+        FromInner::from_inner(FromInner::from_inner(mode))\n+    }\n+}\n+\n+/// Unix-specific extensions to `OpenOptions`\n+#[unstable(feature = \"fs_ext\",\n+           reason = \"may want a more useful mode abstraction\")]\n+pub trait OpenOptionsExt {\n+    /// Sets the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+}\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub struct Metadata(sys::fs2::FileAttr);\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    fn as_raw(&self) -> &Metadata;\n+}\n+\n+impl MetadataExt for fs::Metadata {\n+    fn as_raw(&self) -> &Metadata {\n+        let inner: &sys::fs2::FileAttr = self.as_inner();\n+        unsafe { mem::transmute(inner) }\n+    }\n+}\n+\n+impl AsInner<platform::raw::stat> for Metadata {\n+    fn as_inner(&self) -> &platform::raw::stat { self.0.as_inner() }\n+}\n+\n+// Hm, why are there casts here to the returned type, shouldn't the types always\n+// be the same? Right you are! Turns out, however, on android at least the types\n+// in the raw `stat` structure are not the same as the types being returned. Who\n+// knew!\n+//\n+// As a result to make sure this compiles for all platforms we do the manual\n+// casts and rely on manual lowering to `stat` if the raw type is desired.\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+impl Metadata {\n+    pub fn dev(&self) -> raw::dev_t { self.0.raw().st_dev as raw::dev_t }\n+    pub fn ino(&self) -> raw::ino_t { self.0.raw().st_ino as raw::ino_t }\n+    pub fn mode(&self) -> raw::mode_t { self.0.raw().st_mode as raw::mode_t }\n+    pub fn nlink(&self) -> raw::nlink_t { self.0.raw().st_nlink as raw::nlink_t }\n+    pub fn uid(&self) -> raw::uid_t { self.0.raw().st_uid as raw::uid_t }\n+    pub fn gid(&self) -> raw::gid_t { self.0.raw().st_gid as raw::gid_t }\n+    pub fn rdev(&self) -> raw::dev_t { self.0.raw().st_rdev as raw::dev_t }\n+    pub fn size(&self) -> raw::off_t { self.0.raw().st_size as raw::off_t }\n+    pub fn atime(&self) -> raw::time_t { self.0.raw().st_atime }\n+    pub fn atime_nsec(&self) -> c_long { self.0.raw().st_atime }\n+    pub fn mtime(&self) -> raw::time_t { self.0.raw().st_mtime }\n+    pub fn mtime_nsec(&self) -> c_long { self.0.raw().st_mtime }\n+    pub fn ctime(&self) -> raw::time_t { self.0.raw().st_ctime }\n+    pub fn ctime_nsec(&self) -> c_long { self.0.raw().st_ctime }\n+\n+    pub fn blksize(&self) -> raw::blksize_t {\n+        self.0.raw().st_blksize as raw::blksize_t\n+    }\n+    pub fn blocks(&self) -> raw::blkcnt_t {\n+        self.0.raw().st_blocks as raw::blkcnt_t\n+    }\n+}\n+\n+#[unstable(feature = \"dir_entry_ext\", reason = \"recently added API\")]\n+pub trait DirEntryExt {\n+    fn ino(&self) -> raw::ino_t;\n+}\n+\n+impl DirEntryExt for fs::DirEntry {\n+    fn ino(&self) -> raw::ino_t { self.as_inner().ino() }\n+}\n+\n+/// Creates a new symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+///\n+/// # Note\n+///\n+/// On Windows, you must specify whether a symbolic link points to a file\n+/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+/// symbolic link to a directory.  Additionally, the process must have\n+/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+/// symbolic link.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+{\n+    sys::fs2::symlink(src.as_ref(), dst.as_ref())\n+}\n+\n+#[unstable(feature = \"dir_builder\", reason = \"recently added API\")]\n+/// An extension trait for `fs::DirBuilder` for unix-specific options.\n+pub trait DirBuilderExt {\n+    /// Sets the mode to create new directories with. This option defaults to\n+    /// 0o777.\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut Self;\n+}\n+\n+impl DirBuilderExt for fs::DirBuilder {\n+    fn mode(&mut self, mode: raw::mode_t) -> &mut fs::DirBuilder {\n+        self.as_inner_mut().set_mode(mode);\n+        self\n+    }\n+}\n+"}, {"sha": "8cb4b4907f6dcf49db2656d6c233c36b139ec9ea", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to general I/O primitives\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use net;\n+use os::raw;\n+use sys;\n+use sys_common::{net2, AsInner, FromInner};\n+\n+/// Raw file descriptors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = raw::c_int;\n+\n+/// A trait to extract the raw unix file descriptor from an underlying\n+/// object.\n+///\n+/// This is only available on unix platforms and must be imported in order\n+/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+/// and `AsRawSocket` set of traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guarantee to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[unstable(feature = \"from_raw_os\",\n+           reason = \"recent addition to std::os::unix::io\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instances of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs2::File::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n+    }\n+}"}, {"sha": "6fde45a7301f91bbaa141d1a216e60098cae52f1", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Unix platforms.\n+//!\n+//! For now, this module is limited to extracting file descriptors,\n+//! but its functionality will grow over time.\n+//!\n+//! # Example\n+//!\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::os::unix::prelude::*;\n+//!\n+//! fn main() {\n+//!     let f = File::create(\"foo.txt\").unwrap();\n+//!     let fd = f.as_raw_fd();\n+//!\n+//!     // use fd with native unix bindings\n+//! }\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod io;\n+pub mod ffi;\n+pub mod fs;\n+pub mod process;\n+pub mod raw;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)]\n+    pub use super::io::{RawFd, AsRawFd};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{DirEntryExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::process::{CommandExt, ExitStatusExt};\n+}"}, {"sha": "8c9d0a86583fb9bd44da512af2ebad68723c5407", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::process` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use os::unix::raw::{uid_t, gid_t};\n+use prelude::v1::*;\n+use process;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner};\n+\n+/// Unix-specific extensions to the `std::process::Command` builder\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CommandExt {\n+    /// Sets the child process's user id. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command {\n+        self.as_inner_mut().uid = Some(id);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command {\n+        self.as_inner_mut().gid = Some(id);\n+        self\n+    }\n+}\n+\n+/// Unix-specific extensions to `std::process::ExitStatus`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExitStatusExt {\n+    /// If the process was terminated by a signal, returns that signal.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExitStatusExt for process::ExitStatus {\n+    fn signal(&self) -> Option<i32> {\n+        match *self.as_inner() {\n+            sys::process2::ExitStatus::Signal(s) => Some(s),\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "8fe4b90456a4c177b24e1a3a42eca35a9577c578", "filename": "src/libstd/sys/unix/ext/raw.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific primitives available on all unix platforms\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+pub type uid_t = u32;\n+pub type gid_t = u32;\n+pub type pid_t = i32;\n+\n+#[doc(inline)]\n+pub use sys::platform::raw::{dev_t, ino_t, mode_t, nlink_t, off_t, blksize_t};\n+#[doc(inline)]\n+pub use sys::platform::raw::{blkcnt_t, time_t};"}, {"sha": "350161c751cb89fa6af78ad8a88cd1f19c880ed9", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 112, "deletions": 24, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -21,14 +21,15 @@ use path::{Path, PathBuf};\n use ptr;\n use sync::Arc;\n use sys::fd::FileDesc;\n+use sys::platform::raw;\n use sys::{c, cvt, cvt_r};\n-use sys_common::FromInner;\n+use sys_common::{AsInner, FromInner};\n use vec::Vec;\n \n pub struct File(FileDesc);\n \n pub struct FileAttr {\n-    stat: libc::stat,\n+    stat: raw::stat,\n }\n \n pub struct ReadDir {\n@@ -57,13 +58,12 @@ pub struct OpenOptions {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions { mode: mode_t }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct FileType { mode: mode_t }\n+\n+pub struct DirBuilder { mode: mode_t }\n+\n impl FileAttr {\n-    pub fn is_dir(&self) -> bool {\n-        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFDIR\n-    }\n-    pub fn is_file(&self) -> bool {\n-        (self.stat.st_mode as mode_t) & libc::S_IFMT == libc::S_IFREG\n-    }\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n@@ -76,12 +76,35 @@ impl FileAttr {\n         self.mktime(self.stat.st_mtime as u64, self.stat.st_mtime_nsec as u64)\n     }\n \n+    pub fn file_type(&self) -> FileType {\n+        FileType { mode: self.stat.st_mode as mode_t }\n+    }\n+\n+    pub fn raw(&self) -> &raw::stat { &self.stat }\n+\n     // times are in milliseconds (currently)\n     fn mktime(&self, secs: u64, nsecs: u64) -> u64 {\n         secs * 1000 + nsecs / 1000000\n     }\n }\n \n+impl AsInner<raw::stat> for FileAttr {\n+    fn as_inner(&self) -> &raw::stat { &self.stat }\n+}\n+\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    fn as_raw_stat(&self) -> &raw::stat;\n+}\n+\n+impl MetadataExt for ::fs::Metadata {\n+    fn as_raw_stat(&self) -> &raw::stat { &self.as_inner().stat }\n+}\n+\n+impl MetadataExt for ::os::unix::fs::Metadata {\n+    fn as_raw_stat(&self) -> &raw::stat { self.as_inner() }\n+}\n+\n impl FilePermissions {\n     pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n     pub fn set_readonly(&mut self, readonly: bool) {\n@@ -91,11 +114,19 @@ impl FilePermissions {\n             self.mode |= 0o222;\n         }\n     }\n-    pub fn mode(&self) -> i32 { self.mode as i32 }\n+    pub fn mode(&self) -> raw::mode_t { self.mode }\n }\n \n-impl FromInner<i32> for FilePermissions {\n-    fn from_inner(mode: i32) -> FilePermissions {\n+impl FileType {\n+    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }\n+    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }\n+    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }\n+\n+    fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }\n+}\n+\n+impl FromInner<raw::mode_t> for FilePermissions {\n+    fn from_inner(mode: raw::mode_t) -> FilePermissions {\n         FilePermissions { mode: mode as mode_t }\n     }\n }\n@@ -147,6 +178,33 @@ impl DirEntry {\n         self.root.join(<OsStr as OsStrExt>::from_bytes(self.name_bytes()))\n     }\n \n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        extern {\n+            fn rust_dir_get_mode(ptr: *mut libc::dirent_t) -> c_int;\n+        }\n+        unsafe {\n+            match rust_dir_get_mode(self.dirent()) {\n+                -1 => lstat(&self.path()).map(|m| m.file_type()),\n+                n => Ok(FileType { mode: n as mode_t }),\n+            }\n+        }\n+    }\n+\n+    pub fn ino(&self) -> raw::ino_t {\n+        extern {\n+            fn rust_dir_get_ino(ptr: *mut libc::dirent_t) -> raw::ino_t;\n+        }\n+        unsafe { rust_dir_get_ino(self.dirent()) }\n+    }\n+\n     fn name_bytes(&self) -> &[u8] {\n         extern {\n             fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n@@ -191,7 +249,7 @@ impl OpenOptions {\n         self.flag(libc::O_CREAT, create);\n     }\n \n-    pub fn mode(&mut self, mode: i32) {\n+    pub fn mode(&mut self, mode: raw::mode_t) {\n         self.mode = mode as mode_t;\n     }\n \n@@ -228,8 +286,10 @@ impl File {\n     pub fn into_fd(self) -> FileDesc { self.0 }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: libc::stat = unsafe { mem::zeroed() };\n-        try!(cvt(unsafe { libc::fstat(self.0.raw(), &mut stat) }));\n+        let mut stat: raw::stat = unsafe { mem::zeroed() };\n+        try!(cvt(unsafe {\n+            libc::fstat(self.0.raw(), &mut stat as *mut _ as *mut _)\n+        }));\n         Ok(FileAttr { stat: stat })\n     }\n \n@@ -284,6 +344,22 @@ impl File {\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n }\n \n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { mode: 0o777 }\n+    }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let p = try!(cstr(p));\n+        try!(cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) }));\n+        Ok(())\n+    }\n+\n+    pub fn set_mode(&mut self, mode: mode_t) {\n+        self.mode = mode;\n+    }\n+}\n+\n fn cstr(path: &Path) -> io::Result<CString> {\n     path.as_os_str().to_cstring().ok_or(\n         io::Error::new(io::ErrorKind::InvalidInput, \"path contained a null\"))\n@@ -343,12 +419,6 @@ impl fmt::Debug for File {\n     }\n }\n \n-pub fn mkdir(p: &Path) -> io::Result<()> {\n-    let p = try!(cstr(p));\n-    try!(cvt(unsafe { libc::mkdir(p.as_ptr(), 0o777) }));\n-    Ok(())\n-}\n-\n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = Arc::new(p.to_path_buf());\n     let p = try!(cstr(p));\n@@ -420,15 +490,19 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe { libc::stat(p.as_ptr(), &mut stat) }));\n+    let mut stat: raw::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe {\n+        libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    }));\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe { libc::lstat(p.as_ptr(), &mut stat) }));\n+    let mut stat: raw::stat = unsafe { mem::zeroed() };\n+    try!(cvt(unsafe {\n+        libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    }));\n     Ok(FileAttr { stat: stat })\n }\n \n@@ -438,3 +512,17 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n     try!(cvt(unsafe { c::utimes(p.as_ptr(), buf.as_ptr()) }));\n     Ok(())\n }\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    let path = try!(CString::new(p.as_os_str().as_bytes()));\n+    let mut buf = vec![0u8; 16 * 1024];\n+    unsafe {\n+        let r = c::realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n+        if r.is_null() {\n+            return Err(io::Error::last_os_error())\n+        }\n+    }\n+    let p = buf.iter().position(|i| *i == 0).unwrap();\n+    buf.truncate(p);\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n+}"}, {"sha": "78b798d3bffff06f849f2f53b22b71512edc623c", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -18,6 +18,16 @@ use libc;\n use num::One;\n use ops::Neg;\n \n+#[cfg(target_os = \"android\")]   pub use os::android as platform;\n+#[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n+#[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n+#[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n+#[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n+#[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n+#[cfg(target_os = \"macos\")]     pub use os::macos as platform;\n+#[cfg(target_os = \"nacl\")]      pub use os::nacl as platform;\n+#[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n+\n pub mod backtrace;\n pub mod c;\n pub mod condvar;"}, {"sha": "d94dfdeeea494fe1d315e441562b7c5c74576989", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -283,7 +283,6 @@ mod arch {\n     }\n }\n \n-#[repr(C)]\n struct Cleanup {\n     handle: libc::HANDLE,\n     SymCleanup: SymCleanupFn,"}, {"sha": "dd747d202a04b7195692ee03112419e4a95def47", "filename": "src/libstd/sys/windows/ext.rs", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551a74dddd84cf01440ee84148ebd18bc68bd7c8/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=551a74dddd84cf01440ee84148ebd18bc68bd7c8", "patch": "@@ -1,301 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Experimental extensions to `std` for Windows.\n-//!\n-//! For now, this module is limited to extracting handles, file\n-//! descriptors, and sockets, but its functionality will grow over\n-//! time.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod io {\n-    use fs;\n-    use libc;\n-    use net;\n-    use sys_common::{net2, AsInner, FromInner};\n-    use sys;\n-\n-    /// Raw HANDLEs.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawHandle = libc::HANDLE;\n-\n-    /// Raw SOCKETs.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub type RawSocket = libc::SOCKET;\n-\n-    /// Extract raw handles.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawHandle {\n-        /// Extracts the raw handle, without taking any ownership.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_handle(&self) -> RawHandle;\n-    }\n-\n-    /// Construct I/O objects from raw handles.\n-    #[unstable(feature = \"from_raw_os\",\n-               reason = \"recent addition to the std::os::windows::io module\")]\n-    pub trait FromRawHandle {\n-        /// Constructs a new I/O object from the specified raw handle.\n-        ///\n-        /// This function will **consume ownership** of the handle given,\n-        /// passing responsibility for closing the handle to the returned\n-        /// object.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawHandle for fs::File {\n-        fn as_raw_handle(&self) -> RawHandle {\n-            self.as_inner().handle().raw()\n-        }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawHandle for fs::File {\n-        unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n-            fs::File::from_inner(sys::fs2::File::from_inner(handle))\n-        }\n-    }\n-\n-    /// Extract raw sockets.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait AsRawSocket {\n-        /// Extracts the underlying raw socket from this object.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn as_raw_socket(&self) -> RawSocket;\n-    }\n-\n-    /// Create I/O objects from raw sockets.\n-    #[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n-    pub trait FromRawSocket {\n-        /// Creates a new I/O object from the given raw socket.\n-        ///\n-        /// This function will **consume ownership** of the socket provided and\n-        /// it will be closed when the returned object goes out of scope.\n-        ///\n-        /// This function is also unsafe as the primitives currently returned\n-        /// have the contract that they are the sole owner of the file\n-        /// descriptor they are wrapping. Usage of this function could\n-        /// accidentally allow violating this contract which can cause memory\n-        /// unsafety in code that relies on it being true.\n-        unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::TcpStream {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::TcpListener {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawSocket for net::UdpSocket {\n-        fn as_raw_socket(&self) -> RawSocket {\n-            *self.as_inner().socket().as_inner()\n-        }\n-    }\n-\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::TcpStream {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::TcpListener {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n-        }\n-    }\n-    #[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n-    impl FromRawSocket for net::UdpSocket {\n-        unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n-            let sock = sys::net::Socket::from_inner(sock);\n-            net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n-        }\n-    }\n-}\n-\n-/// Windows-specific extensions to the primitives in the `std::ffi` module.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod ffi {\n-    use ffi::{OsString, OsStr};\n-    use sys::os_str::Buf;\n-    use sys_common::wtf8::Wtf8Buf;\n-    use sys_common::{FromInner, AsInner};\n-\n-    pub use sys_common::wtf8::EncodeWide;\n-\n-    /// Windows-specific extensions to `OsString`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStringExt {\n-        /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n-        /// 16-bit code units.\n-        ///\n-        /// This is lossless: calling `.encode_wide()` on the resulting string\n-        /// will always return the original code units.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn from_wide(wide: &[u16]) -> Self;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStringExt for OsString {\n-        fn from_wide(wide: &[u16]) -> OsString {\n-            FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n-        }\n-    }\n-\n-    /// Windows-specific extensions to `OsStr`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub trait OsStrExt {\n-        /// Re-encodes an `OsStr` as a wide character sequence,\n-        /// i.e. potentially ill-formed UTF-16.\n-        ///\n-        /// This is lossless. Note that the encoding does not include a final\n-        /// null.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        fn encode_wide(&self) -> EncodeWide;\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl OsStrExt for OsStr {\n-        fn encode_wide(&self) -> EncodeWide {\n-            self.as_inner().inner.encode_wide()\n-        }\n-    }\n-}\n-\n-/// Windows-specific extensions for the primitives in `std::fs`\n-#[unstable(feature = \"fs_ext\", reason = \"may require more thought/methods\")]\n-pub mod fs {\n-    use fs::OpenOptions;\n-    use sys;\n-    use sys_common::AsInnerMut;\n-    use path::Path;\n-    use convert::AsRef;\n-    use io;\n-\n-    /// Windows-specific extensions to `OpenOptions`\n-    pub trait OpenOptionsExt {\n-        /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n-        /// with the specified value.\n-        fn desired_access(&mut self, access: i32) -> &mut Self;\n-\n-        /// Overrides the `dwCreationDisposition` argument to the call to\n-        /// `CreateFile` with the specified value.\n-        ///\n-        /// This will override any values of the standard `create` flags, for\n-        /// example.\n-        fn creation_disposition(&mut self, val: i32) -> &mut Self;\n-\n-        /// Overrides the `dwFlagsAndAttributes` argument to the call to\n-        /// `CreateFile` with the specified value.\n-        ///\n-        /// This will override any values of the standard flags on the\n-        /// `OpenOptions` structure.\n-        fn flags_and_attributes(&mut self, val: i32) -> &mut Self;\n-\n-        /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n-        /// the specified value.\n-        ///\n-        /// This will override any values of the standard flags on the\n-        /// `OpenOptions` structure.\n-        fn share_mode(&mut self, val: i32) -> &mut Self;\n-    }\n-\n-    impl OpenOptionsExt for OpenOptions {\n-        fn desired_access(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().desired_access(access); self\n-        }\n-        fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().creation_disposition(access); self\n-        }\n-        fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().flags_and_attributes(access); self\n-        }\n-        fn share_mode(&mut self, access: i32) -> &mut OpenOptions {\n-            self.as_inner_mut().share_mode(access); self\n-        }\n-    }\n-\n-    /// Creates a new file symbolic link on the filesystem.\n-    ///\n-    /// The `dst` path will be a file symbolic link pointing to the `src`\n-    /// path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// #![feature(fs_ext)]\n-    /// use std::os::windows::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink_file(\"a.txt\", \"b.txt\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n-                                                        -> io::Result<()>\n-    {\n-        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n-    }\n-\n-    /// Creates a new directory symlink on the filesystem.\n-    ///\n-    /// The `dst` path will be a directory symbolic link pointing to the `src`\n-    /// path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// #![feature(fs_ext)]\n-    /// use std::os::windows::fs;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// try!(fs::symlink_file(\"a\", \"b\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>> (src: P, dst: Q)\n-                                                        -> io::Result<()>\n-    {\n-        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n-    }\n-}\n-\n-/// A prelude for conveniently writing platform-specific code.\n-///\n-/// Includes all extension traits, and some important type definitions.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n-    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    pub use super::fs::OpenOptionsExt;\n-}"}, {"sha": "3fa96f4dd13e96decb436cecb58aca5d7c06d825", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific extensions to the primitives in the `std::ffi` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsString, OsStr};\n+use sys::os_str::Buf;\n+use sys_common::wtf8::Wtf8Buf;\n+use sys_common::{FromInner, AsInner};\n+\n+pub use sys_common::wtf8::EncodeWide;\n+\n+/// Windows-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n+    /// 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_wide(wide: &[u16]) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_wide(wide: &[u16]) -> OsString {\n+        FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n+    }\n+}\n+\n+/// Windows-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    /// Re-encodes an `OsStr` as a wide character sequence,\n+    /// i.e. potentially ill-formed UTF-16.\n+    ///\n+    /// This is lossless. Note that the encoding does not include a final\n+    /// null.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn encode_wide(&self) -> EncodeWide;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn encode_wide(&self) -> EncodeWide {\n+        self.as_inner().inner.encode_wide()\n+    }\n+}"}, {"sha": "23c1fcf4b3c6e1d2850a1d6bc3a730777fe5d467", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific extensions for the primitives in `std::fs`\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use prelude::v1::*;\n+\n+use fs::{OpenOptions, Metadata};\n+use io;\n+use path::Path;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner};\n+\n+/// Windows-specific extensions to `OpenOptions`\n+#[unstable(feature = \"fs_ext\", reason = \"may require more thought/methods\")]\n+pub trait OpenOptionsExt {\n+    /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n+    /// with the specified value.\n+    fn desired_access(&mut self, access: i32) -> &mut Self;\n+\n+    /// Overrides the `dwCreationDisposition` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard `create` flags, for\n+    /// example.\n+    fn creation_disposition(&mut self, val: i32) -> &mut Self;\n+\n+    /// Overrides the `dwFlagsAndAttributes` argument to the call to\n+    /// `CreateFile` with the specified value.\n+    ///\n+    /// This will override any values of the standard flags on the\n+    /// `OpenOptions` structure.\n+    fn flags_and_attributes(&mut self, val: i32) -> &mut Self;\n+\n+    /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n+    /// the specified value.\n+    ///\n+    /// This will override any values of the standard flags on the\n+    /// `OpenOptions` structure.\n+    fn share_mode(&mut self, val: i32) -> &mut Self;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn desired_access(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().desired_access(access); self\n+    }\n+    fn creation_disposition(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().creation_disposition(access); self\n+    }\n+    fn flags_and_attributes(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().flags_and_attributes(access); self\n+    }\n+    fn share_mode(&mut self, access: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().share_mode(access); self\n+    }\n+}\n+\n+/// Extension methods for `fs::Metadata` to access the raw fields contained\n+/// within.\n+#[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n+pub trait MetadataExt {\n+    /// Returns the value of the `dwFileAttributes` field of this metadata.\n+    ///\n+    /// This field contains the file system attribute information for a file\n+    /// or directory.\n+    fn file_attributes(&self) -> u32;\n+\n+    /// Returns the value of the `ftCreationTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn creation_time(&self) -> u64;\n+\n+    /// Returns the value of the `ftLastAccessTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn last_access_time(&self) -> u64;\n+\n+    /// Returns the value of the `ftLastWriteTime` field of this metadata.\n+    ///\n+    /// The returned 64-bit value represents the number of 100-nanosecond\n+    /// intervals since January 1, 1601 (UTC).\n+    fn last_write_time(&self) -> u64;\n+\n+    /// Returns the value of the `nFileSize{High,Low}` fields of this\n+    /// metadata.\n+    ///\n+    /// The returned value does not have meaning for directories.\n+    fn file_size(&self) -> u64;\n+}\n+\n+impl MetadataExt for Metadata {\n+    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }\n+    fn creation_time(&self) -> u64 { self.as_inner().created() }\n+    fn last_access_time(&self) -> u64 { self.as_inner().accessed() }\n+    fn last_write_time(&self) -> u64 { self.as_inner().modified() }\n+    fn file_size(&self) -> u64 { self.as_inner().size() }\n+}\n+\n+/// Creates a new file symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a file symbolic link pointing to the `src`\n+/// path.\n+///\n+/// # Examples\n+///\n+/// ```ignore\n+/// use std::os::windows::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink_file(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n+                                                    -> io::Result<()> {\n+    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n+}\n+\n+/// Creates a new directory symlink on the filesystem.\n+///\n+/// The `dst` path will be a directory symbolic link pointing to the `src`\n+/// path.\n+///\n+/// # Examples\n+///\n+/// ```ignore\n+/// use std::os::windows::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink_file(\"a\", \"b\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n+                                                   -> io::Result<()> {\n+    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n+}"}, {"sha": "b88a6316eee8b9aa7691aa6a25d7f2819231b034", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use os::windows::raw;\n+use net;\n+use sys_common::{net2, AsInner, FromInner};\n+use sys;\n+\n+/// Raw HANDLEs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawHandle = raw::HANDLE;\n+\n+/// Raw SOCKETs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawSocket = raw::SOCKET;\n+\n+/// Extract raw handles.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawHandle {\n+    /// Extracts the raw handle, without taking any ownership.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_handle(&self) -> RawHandle;\n+}\n+\n+/// Construct I/O objects from raw handles.\n+#[unstable(feature = \"from_raw_os\",\n+           reason = \"recent addition to the std::os::windows::io module\")]\n+pub trait FromRawHandle {\n+    /// Constructs a new I/O object from the specified raw handle.\n+    ///\n+    /// This function will **consume ownership** of the handle given,\n+    /// passing responsibility for closing the handle to the returned\n+    /// object.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawHandle for fs::File {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as RawHandle\n+    }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawHandle for fs::File {\n+    unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n+        let handle = handle as ::libc::HANDLE;\n+        fs::File::from_inner(sys::fs2::File::from_inner(handle))\n+    }\n+}\n+\n+/// Extract raw sockets.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawSocket {\n+    /// Extracts the underlying raw socket from this object.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_socket(&self) -> RawSocket;\n+}\n+\n+/// Create I/O objects from raw sockets.\n+#[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n+pub trait FromRawSocket {\n+    /// Creates a new I/O object from the given raw socket.\n+    ///\n+    /// This function will **consume ownership** of the socket provided and\n+    /// it will be closed when the returned object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::TcpStream {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::TcpListener {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawSocket for net::UdpSocket {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::TcpStream {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::TcpListener {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n+    }\n+}\n+#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+impl FromRawSocket for net::UdpSocket {\n+    unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n+        let sock = sys::net::Socket::from_inner(sock);\n+        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n+    }\n+}"}, {"sha": "08dfa4cc8775307c39d48a70afdd1dd76803ea5e", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Windows.\n+//!\n+//! For now, this module is limited to extracting handles, file\n+//! descriptors, and sockets, but its functionality will grow over\n+//! time.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod ffi;\n+pub mod fs;\n+pub mod io;\n+pub mod raw;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)]\n+    pub use super::io::{RawSocket, RawHandle, AsRawSocket, AsRawHandle};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)]\n+    pub use super::fs::{OpenOptionsExt, MetadataExt};\n+}"}, {"sha": "656e480ad0963df1778e9bb09816367d047f0d59", "filename": "src/libstd/sys/windows/ext/raw.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fraw.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows-specific primitives\n+\n+#![unstable(feature = \"raw_ext\", reason = \"recently added API\")]\n+\n+use os::raw;\n+\n+pub type HANDLE = *mut raw::c_void;\n+#[cfg(target_pointer_width = \"32\")]\n+pub type SOCKET = u32;\n+#[cfg(target_pointer_width = \"64\")]\n+pub type SOCKET = u64;"}, {"sha": "03a56e2958a6e9f485b050323ac42274b744b9eb", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 173, "deletions": 61, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -27,7 +27,16 @@ use sys_common::FromInner;\n use vec::Vec;\n \n pub struct File { handle: Handle }\n-pub struct FileAttr { data: c::WIN32_FILE_ATTRIBUTE_DATA }\n+\n+pub struct FileAttr {\n+    data: c::WIN32_FILE_ATTRIBUTE_DATA,\n+    is_symlink: bool,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum FileType {\n+    Dir, File, Symlink, ReparsePoint\n+}\n \n pub struct ReadDir {\n     handle: FindNextFileHandle,\n@@ -56,11 +65,14 @@ pub struct OpenOptions {\n     share_mode: Option<libc::DWORD>,\n     creation_disposition: Option<libc::DWORD>,\n     flags_and_attributes: Option<libc::DWORD>,\n+    security_attributes: usize, // *mut T doesn't have a Default impl\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions { attrs: libc::DWORD }\n \n+pub struct DirBuilder;\n+\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n@@ -111,8 +123,31 @@ impl DirEntry {\n     }\n \n     pub fn path(&self) -> PathBuf {\n+        self.root.join(&self.file_name())\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n         let filename = super::truncate_utf16_at_nul(&self.data.cFileName);\n-        self.root.join(&<OsString as OsStringExt>::from_wide(filename))\n+        OsString::from_wide(filename)\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        Ok(FileType::new(self.data.dwFileAttributes,\n+                         self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK))\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        Ok(FileAttr {\n+            data: c::WIN32_FILE_ATTRIBUTE_DATA {\n+                dwFileAttributes: self.data.dwFileAttributes,\n+                ftCreationTime: self.data.ftCreationTime,\n+                ftLastAccessTime: self.data.ftLastAccessTime,\n+                ftLastWriteTime: self.data.ftLastWriteTime,\n+                nFileSizeHigh: self.data.nFileSizeHigh,\n+                nFileSizeLow: self.data.nFileSizeLow,\n+            },\n+            is_symlink: self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK,\n+        })\n     }\n }\n \n@@ -135,6 +170,9 @@ impl OpenOptions {\n     pub fn share_mode(&mut self, val: i32) {\n         self.share_mode = Some(val as libc::DWORD);\n     }\n+    pub fn security_attributes(&mut self, attrs: libc::LPSECURITY_ATTRIBUTES) {\n+        self.security_attributes = attrs as usize;\n+    }\n \n     fn get_desired_access(&self) -> libc::DWORD {\n         self.desired_access.unwrap_or({\n@@ -180,13 +218,20 @@ impl OpenOptions {\n }\n \n impl File {\n+    fn open_reparse_point(path: &Path) -> io::Result<File> {\n+        let mut opts = OpenOptions::new();\n+        opts.read(true);\n+        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT as i32);\n+        File::open(path, &opts)\n+    }\n+\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = to_utf16(path);\n         let handle = unsafe {\n             libc::CreateFileW(path.as_ptr(),\n                               opts.get_desired_access(),\n                               opts.get_share_mode(),\n-                              ptr::null_mut(),\n+                              opts.security_attributes as *mut _,\n                               opts.get_creation_disposition(),\n                               opts.get_flags_and_attributes(),\n                               ptr::null_mut())\n@@ -224,16 +269,21 @@ impl File {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n             try!(cvt(c::GetFileInformationByHandle(self.handle.raw(),\n                                                    &mut info)));\n-            Ok(FileAttr {\n+            let mut attr = FileAttr {\n                 data: c::WIN32_FILE_ATTRIBUTE_DATA {\n                     dwFileAttributes: info.dwFileAttributes,\n                     ftCreationTime: info.ftCreationTime,\n                     ftLastAccessTime: info.ftLastAccessTime,\n                     ftLastWriteTime: info.ftLastWriteTime,\n                     nFileSizeHigh: info.nFileSizeHigh,\n                     nFileSizeLow: info.nFileSizeLow,\n-                }\n-            })\n+                },\n+                is_symlink: false,\n+            };\n+            if attr.is_reparse_point() {\n+                attr.is_symlink = self.is_symlink();\n+            }\n+            Ok(attr)\n         }\n     }\n \n@@ -263,6 +313,43 @@ impl File {\n     }\n \n     pub fn handle(&self) -> &Handle { &self.handle }\n+\n+    fn is_symlink(&self) -> bool {\n+        self.readlink().is_ok()\n+    }\n+\n+    fn readlink(&self) -> io::Result<PathBuf> {\n+        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut bytes = 0;\n+\n+        unsafe {\n+            try!(cvt({\n+                c::DeviceIoControl(self.handle.raw(),\n+                                   c::FSCTL_GET_REPARSE_POINT,\n+                                   0 as *mut _,\n+                                   0,\n+                                   space.as_mut_ptr() as *mut _,\n+                                   space.len() as libc::DWORD,\n+                                   &mut bytes,\n+                                   0 as *mut _)\n+            }));\n+            let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n+            if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n+            }\n+            let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n+                    &(*buf).rest as *const _ as *const _;\n+            let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n+            let subst_off = (*info).SubstituteNameOffset / 2;\n+            let subst_ptr = path_buffer.offset(subst_off as isize);\n+            let subst_len = (*info).SubstituteNameLength / 2;\n+            let subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n+\n+            Ok(PathBuf::from(OsString::from_wide(subst)))\n+        }\n+    }\n+\n+    pub fn into_handle(self) -> Handle { self.handle }\n }\n \n impl FromInner<libc::HANDLE> for File {\n@@ -285,27 +372,30 @@ pub fn to_utf16(s: &Path) -> Vec<u16> {\n }\n \n impl FileAttr {\n-    pub fn is_dir(&self) -> bool {\n-        self.data.dwFileAttributes & c::FILE_ATTRIBUTE_DIRECTORY != 0\n-    }\n-    pub fn is_file(&self) -> bool {\n-        !self.is_dir()\n-    }\n     pub fn size(&self) -> u64 {\n         ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64)\n     }\n+\n     pub fn perm(&self) -> FilePermissions {\n         FilePermissions { attrs: self.data.dwFileAttributes }\n     }\n \n-    pub fn accessed(&self) -> u64 { self.to_ms(&self.data.ftLastAccessTime) }\n-    pub fn modified(&self) -> u64 { self.to_ms(&self.data.ftLastWriteTime) }\n+    pub fn attrs(&self) -> u32 { self.data.dwFileAttributes as u32 }\n \n-    fn to_ms(&self, ft: &libc::FILETIME) -> u64 {\n-        // FILETIME is in 100ns intervals and there are 10000 intervals in a\n-        // millisecond.\n-        let bits = (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32);\n-        bits / 10000\n+    pub fn file_type(&self) -> FileType {\n+        FileType::new(self.data.dwFileAttributes, self.is_symlink)\n+    }\n+\n+    pub fn created(&self) -> u64 { self.to_u64(&self.data.ftCreationTime) }\n+    pub fn accessed(&self) -> u64 { self.to_u64(&self.data.ftLastAccessTime) }\n+    pub fn modified(&self) -> u64 { self.to_u64(&self.data.ftLastWriteTime) }\n+\n+    fn to_u64(&self, ft: &libc::FILETIME) -> u64 {\n+        (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n+    }\n+\n+    fn is_reparse_point(&self) -> bool {\n+        self.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0\n     }\n }\n \n@@ -323,12 +413,36 @@ impl FilePermissions {\n     }\n }\n \n-pub fn mkdir(p: &Path) -> io::Result<()> {\n-    let p = to_utf16(p);\n-    try!(cvt(unsafe {\n-        libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n-    }));\n-    Ok(())\n+impl FileType {\n+    fn new(attrs: libc::DWORD, is_symlink: bool) -> FileType {\n+        if attrs & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+            if is_symlink {\n+                FileType::Symlink\n+            } else {\n+                FileType::ReparsePoint\n+            }\n+        } else if attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n+            FileType::Dir\n+        } else {\n+            FileType::File\n+        }\n+    }\n+\n+    pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n+    pub fn is_file(&self) -> bool { *self == FileType::File }\n+    pub fn is_symlink(&self) -> bool { *self == FileType::Symlink }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder { DirBuilder }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let p = to_utf16(p);\n+        try!(cvt(unsafe {\n+            libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n+        }));\n+        Ok(())\n+    }\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n@@ -374,40 +488,8 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let mut opts = OpenOptions::new();\n-    opts.read(true);\n-    opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT as i32);\n-    let file = try!(File::open(p, &opts));\n-\n-    let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-    let mut bytes = 0;\n-\n-    unsafe {\n-        try!(cvt({\n-            c::DeviceIoControl(file.handle.raw(),\n-                               c::FSCTL_GET_REPARSE_POINT,\n-                               0 as *mut _,\n-                               0,\n-                               space.as_mut_ptr() as *mut _,\n-                               space.len() as libc::DWORD,\n-                               &mut bytes,\n-                               0 as *mut _)\n-        }));\n-        let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n-        if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n-            return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n-        }\n-        let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                &(*buf).rest as *const _ as *const _;\n-        let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n-        let subst_off = (*info).SubstituteNameOffset / 2;\n-        let subst_ptr = path_buffer.offset(subst_off as isize);\n-        let subst_len = (*info).SubstituteNameLength / 2;\n-        let subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n-\n-        Ok(PathBuf::from(OsString::from_wide(subst)))\n-    }\n-\n+    let file = try!(File::open_reparse_point(p));\n+    file.readlink()\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n@@ -435,12 +517,28 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = to_utf16(p);\n+    let attr = try!(lstat(p));\n+    if attr.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+        let opts = OpenOptions::new();\n+        let file = try!(File::open(p, &opts));\n+        file.file_attr()\n+    } else {\n+        Ok(attr)\n+    }\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let utf16 = to_utf16(p);\n     unsafe {\n         let mut attr: FileAttr = mem::zeroed();\n-        try!(cvt(c::GetFileAttributesExW(p.as_ptr(),\n+        try!(cvt(c::GetFileAttributesExW(utf16.as_ptr(),\n                                          c::GetFileExInfoStandard,\n                                          &mut attr.data as *mut _ as *mut _)));\n+        if attr.is_reparse_point() {\n+            attr.is_symlink = File::open_reparse_point(p).map(|f| {\n+                f.is_symlink()\n+            }).unwrap_or(false);\n+        }\n         Ok(attr)\n     }\n }\n@@ -465,3 +563,17 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n     }));\n     Ok(())\n }\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n+\n+    let mut opts = OpenOptions::new();\n+    opts.read(true);\n+    let f = try!(File::open(p, &opts));\n+    super::fill_utf16_buf(|buf, sz| unsafe {\n+        GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n+                                  libc::VOLUME_NAME_DOS)\n+    }, |buf| {\n+        PathBuf::from(OsString::from_wide(buf))\n+    })\n+}"}, {"sha": "9481e180ce5781a42219c79cd2b79b93ed574c4c", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use io::ErrorKind;\n use io;\n+use libc::funcs::extra::kernel32::{GetCurrentProcess, DuplicateHandle};\n use libc::{self, HANDLE};\n use mem;\n use ptr;\n@@ -65,6 +66,18 @@ impl Handle {\n         }));\n         Ok(amt as usize)\n     }\n+\n+    pub fn duplicate(&self, access: libc::DWORD, inherit: bool,\n+                     options: libc::DWORD) -> io::Result<Handle> {\n+        let mut ret = 0 as libc::HANDLE;\n+        try!(cvt(unsafe {\n+            let cur_proc = GetCurrentProcess();\n+            DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n+                            access, inherit as libc::BOOL,\n+                            options)\n+        }));\n+        Ok(Handle::new(ret))\n+    }\n }\n \n impl Drop for Handle {"}, {"sha": "5aad5f668dd418279642d6f5afd83fc935fabfbf", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 105, "deletions": 173, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -13,17 +13,23 @@ use prelude::v1::*;\n use ascii::*;\n use collections::HashMap;\n use collections;\n+use env::split_paths;\n use env;\n use ffi::{OsString, OsStr};\n use fmt;\n use fs;\n use io::{self, Error};\n use libc::{self, c_void};\n+use mem;\n use os::windows::ffi::OsStrExt;\n+use path::Path;\n use ptr;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::c;\n+use sys::fs2::{OpenOptions, File};\n use sys::handle::Handle;\n use sys::pipe2::AnonPipe;\n+use sys::stdio;\n use sys::{self, cvt};\n use sys_common::{AsInner, FromInner};\n \n@@ -90,18 +96,12 @@ impl Command {\n // Processes\n ////////////////////////////////////////////////////////////////////////////////\n \n-// `CreateProcess` is racy!\n-// http://support.microsoft.com/kb/315939\n-static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n-\n /// A value representing a child process.\n ///\n /// The lifetime of this value is linked to the lifetime of the actual\n /// process - the Process destructor calls self.finish() which waits\n /// for the process to terminate.\n pub struct Process {\n-    /// A HANDLE to the process, which will prevent the pid being\n-    /// re-used until the handle is closed.\n     handle: Handle,\n }\n \n@@ -112,32 +112,17 @@ pub enum Stdio {\n }\n \n impl Process {\n-    #[allow(deprecated)]\n     pub fn spawn(cfg: &Command,\n-                 in_fd: Stdio,\n-                 out_fd: Stdio,\n-                 err_fd: Stdio) -> io::Result<Process>\n+                 in_handle: Stdio,\n+                 out_handle: Stdio,\n+                 err_handle: Stdio) -> io::Result<Process>\n     {\n-        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-        use libc::consts::os::extra::{\n-            TRUE, FALSE,\n-            STARTF_USESTDHANDLES,\n-            INVALID_HANDLE_VALUE,\n-            DUPLICATE_SAME_ACCESS\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetCurrentProcess,\n-            DuplicateHandle,\n-            CloseHandle,\n-            CreateProcessW\n-        };\n-\n-        use env::split_paths;\n-        use mem;\n-        use iter::Iterator;\n-\n-        // To have the spawning semantics of unix/windows stay the same, we need to\n-        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        use libc::{TRUE, STARTF_USESTDHANDLES};\n+        use libc::{DWORD, STARTUPINFO, CreateProcessW};\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need\n+        // to read the *child's* PATH if one is provided. See #15149 for more\n+        // details.\n         let program = cfg.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n                 if OsStr::new(\"PATH\") != &**key { continue }\n@@ -156,118 +141,51 @@ impl Process {\n             None\n         });\n \n-        unsafe {\n-            let mut si = zeroed_startupinfo();\n-            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-            si.dwFlags = STARTF_USESTDHANDLES;\n-\n-            let cur_proc = GetCurrentProcess();\n-\n-            let set_fd = |fd: &Stdio, slot: &mut HANDLE,\n-                          is_stdin: bool| {\n-                match *fd {\n-                    Stdio::Inherit => {}\n-\n-                    // Similarly to unix, we don't actually leave holes for the\n-                    // stdio file descriptors, but rather open up /dev/null\n-                    // equivalents. These equivalents are drawn from libuv's\n-                    // windows process spawning.\n-                    Stdio::None => {\n-                        let access = if is_stdin {\n-                            libc::FILE_GENERIC_READ\n-                        } else {\n-                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                        };\n-                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                        let mut sa = libc::SECURITY_ATTRIBUTES {\n-                            nLength: size as libc::DWORD,\n-                            lpSecurityDescriptor: ptr::null_mut(),\n-                            bInheritHandle: 1,\n-                        };\n-                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                        filename.push(0);\n-                        *slot = libc::CreateFileW(filename.as_ptr(),\n-                                                  access,\n-                                                  libc::FILE_SHARE_READ |\n-                                                      libc::FILE_SHARE_WRITE,\n-                                                  &mut sa,\n-                                                  libc::OPEN_EXISTING,\n-                                                  0,\n-                                                  ptr::null_mut());\n-                        if *slot == INVALID_HANDLE_VALUE {\n-                            return Err(Error::last_os_error())\n-                        }\n-                    }\n-                    Stdio::Piped(ref pipe) => {\n-                        let orig = pipe.handle().raw();\n-                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                            return Err(Error::last_os_error())\n-                        }\n-                    }\n-                }\n-                Ok(())\n-            };\n-\n-            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n-            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n-            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+        let mut si = zeroed_startupinfo();\n+        si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n \n-            let mut cmd_str = make_command_line(program.as_ref().unwrap_or(&cfg.program),\n-                                            &cfg.args);\n-            cmd_str.push(0); // add null terminator\n+        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n+        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n+        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n \n-            let mut pi = zeroed_process_information();\n-            let mut create_err = None;\n-\n-            // stolen from the libuv code.\n-            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-            if cfg.detach {\n-                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n-            }\n+        si.hStdInput = stdin.raw();\n+        si.hStdOutput = stdout.raw();\n+        si.hStdError = stderr.raw();\n \n-            with_envp(cfg.env.as_ref(), |envp| {\n-                with_dirp(cfg.cwd.as_ref(), |dirp| {\n-                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmd_str.as_mut_ptr(),\n-                                                 ptr::null_mut(),\n-                                                 ptr::null_mut(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(Error::last_os_error());\n-                    }\n-                })\n-            });\n+        let program = program.as_ref().unwrap_or(&cfg.program);\n+        let mut cmd_str = make_command_line(program, &cfg.args);\n+        cmd_str.push(0); // add null terminator\n \n-            if !in_fd.inherited() {\n-                assert!(CloseHandle(si.hStdInput) != 0);\n-            }\n-            if !out_fd.inherited() {\n-                assert!(CloseHandle(si.hStdOutput) != 0);\n-            }\n-            if !err_fd.inherited() {\n-                assert!(CloseHandle(si.hStdError) != 0);\n-            }\n+        // stolen from the libuv code.\n+        let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+        if cfg.detach {\n+            flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+        }\n \n-            match create_err {\n-                Some(err) => return Err(err),\n-                None => {}\n-            }\n+        let (envp, _data) = make_envp(cfg.env.as_ref());\n+        let (dirp, _data) = make_dirp(cfg.cwd.as_ref());\n+        let mut pi = zeroed_process_information();\n+        try!(unsafe {\n+            // `CreateProcess` is racy!\n+            // http://support.microsoft.com/kb/315939\n+            static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n+            let _lock = CREATE_PROCESS_LOCK.lock();\n+\n+            cvt(CreateProcessW(ptr::null(),\n+                               cmd_str.as_mut_ptr(),\n+                               ptr::null_mut(),\n+                               ptr::null_mut(),\n+                               TRUE, flags, envp, dirp,\n+                               &mut si, &mut pi))\n+        });\n \n-            // We close the thread handle because we don't care about keeping the\n-            // thread id valid, and we aren't keeping the thread handle around to be\n-            // able to close it later. We don't close the process handle however\n-            // because std::we want the process id to stay valid at least until the\n-            // calling code closes the process handle.\n-            assert!(CloseHandle(pi.hThread) != 0);\n+        // We close the thread handle because we don't care about keeping\n+        // the thread id valid, and we aren't keeping the thread handle\n+        // around to be able to close it later.\n+        drop(Handle::new(pi.hThread));\n \n-            Ok(Process {\n-                handle: Handle::new(pi.hProcess)\n-            })\n-        }\n+        Ok(Process { handle: Handle::new(pi.hProcess) })\n     }\n \n     pub unsafe fn kill(&self) -> io::Result<()> {\n@@ -276,45 +194,25 @@ impl Process {\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n-        use libc::consts::os::extra::{\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_OBJECT_0,\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetExitCodeProcess,\n-            WaitForSingleObject,\n-        };\n+        use libc::{STILL_ACTIVE, INFINITE, WAIT_OBJECT_0};\n+        use libc::{GetExitCodeProcess, WaitForSingleObject};\n \n         unsafe {\n             loop {\n                 let mut status = 0;\n-                if GetExitCodeProcess(self.handle.raw(), &mut status) == FALSE {\n-                    let err = Err(Error::last_os_error());\n-                    return err;\n-                }\n+                try!(cvt(GetExitCodeProcess(self.handle.raw(), &mut status)));\n                 if status != STILL_ACTIVE {\n                     return Ok(ExitStatus(status as i32));\n                 }\n                 match WaitForSingleObject(self.handle.raw(), INFINITE) {\n                     WAIT_OBJECT_0 => {}\n-                    _ => {\n-                        let err = Err(Error::last_os_error());\n-                        return err\n-                    }\n+                    _ => return Err(Error::last_os_error()),\n                 }\n             }\n         }\n     }\n }\n \n-impl Stdio {\n-    fn inherited(&self) -> bool {\n-        match *self { Stdio::Inherit => true, _ => false }\n-    }\n-}\n-\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitStatus(i32);\n \n@@ -415,9 +313,8 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n     }\n }\n \n-fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F) -> T\n-    where F: FnOnce(*mut c_void) -> T,\n-{\n+fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n+             -> (*mut c_void, Vec<u16>) {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -432,22 +329,57 @@ fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F\n                 blk.push(0);\n             }\n             blk.push(0);\n-            cb(blk.as_mut_ptr() as *mut c_void)\n+            (blk.as_mut_ptr() as *mut c_void, blk)\n         }\n-        _ => cb(ptr::null_mut())\n+        _ => (ptr::null_mut(), Vec::new())\n     }\n }\n \n-fn with_dirp<T, F>(d: Option<&OsString>, cb: F) -> T where\n-    F: FnOnce(*const u16) -> T,\n-{\n+fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n     match d {\n-      Some(dir) => {\n-          let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n-          dir_str.push(0);\n-          cb(dir_str.as_ptr())\n-      },\n-      None => cb(ptr::null())\n+        Some(dir) => {\n+            let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n+            dir_str.push(0);\n+            (dir_str.as_ptr(), dir_str)\n+        },\n+        None => (ptr::null(), Vec::new())\n+    }\n+}\n+\n+impl Stdio {\n+    fn to_handle(&self, stdio_id: libc::DWORD) -> io::Result<Handle> {\n+        use libc::DUPLICATE_SAME_ACCESS;\n+\n+        match *self {\n+            Stdio::Inherit => {\n+                stdio::get(stdio_id).and_then(|io| {\n+                    io.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+                })\n+            }\n+            Stdio::Piped(ref pipe) => {\n+                pipe.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+            }\n+\n+            // Similarly to unix, we don't actually leave holes for the\n+            // stdio file descriptors, but rather open up /dev/null\n+            // equivalents. These equivalents are drawn from libuv's\n+            // windows process spawning.\n+            Stdio::None => {\n+                let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                let mut sa = libc::SECURITY_ATTRIBUTES {\n+                    nLength: size as libc::DWORD,\n+                    lpSecurityDescriptor: ptr::null_mut(),\n+                    bInheritHandle: 1,\n+                };\n+                let mut opts = OpenOptions::new();\n+                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n+                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n+                opts.security_attributes(&mut sa);\n+                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n+                    file.into_handle()\n+                })\n+            }\n+        }\n     }\n }\n "}, {"sha": "03547165f5d8700aa3f3939b8511db9cb237724e", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -21,9 +21,9 @@ use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n \n-struct NoClose(Option<Handle>);\n+pub struct NoClose(Option<Handle>);\n \n-enum Output {\n+pub enum Output {\n     Console(NoClose),\n     Pipe(NoClose),\n }\n@@ -35,7 +35,7 @@ pub struct Stdin {\n pub struct Stdout(Output);\n pub struct Stderr(Output);\n \n-fn get(handle: libc::DWORD) -> io::Result<Output> {\n+pub fn get(handle: libc::DWORD) -> io::Result<Output> {\n     let handle = unsafe { c::GetStdHandle(handle) };\n     if handle == libc::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n@@ -159,6 +159,16 @@ impl Drop for NoClose {\n     }\n }\n \n+impl Output {\n+    pub fn handle(&self) -> &Handle {\n+        let nc = match *self {\n+            Output::Console(ref c) => c,\n+            Output::Pipe(ref c) => c,\n+        };\n+        nc.0.as_ref().unwrap()\n+    }\n+}\n+\n fn invalid_encoding() -> io::Error {\n     io::Error::new(io::ErrorKind::InvalidInput, \"text was not valid unicode\")\n }"}, {"sha": "bcc70c2b8163e25479853ae89a2f06e714a0f211", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -263,7 +263,7 @@ impl Builder {\n     ///\n     /// The child thread may outlive the parent (unless the parent thread\n     /// is the main thread; the whole process is terminated when the main\n-    /// thread finishes.) The join handle can be used to block on\n+    /// thread finishes). The join handle can be used to block on\n     /// termination of the child thread, including recovering its panics.\n     ///\n     /// # Errors"}, {"sha": "c22fba658373a7d64abce8d017c2d5cb90806bab", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -25,13 +25,14 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(unicode)]\n #![feature(str_char)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "5f76c21492707c30c985fb28bb6160702f4726f4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -88,9 +88,9 @@ use std::slice;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        const UNRESTRICTED                  = 0b0000,\n-        const RESTRICTION_STMT_EXPR         = 0b0001,\n-        const RESTRICTION_NO_STRUCT_LITERAL = 0b0010,\n+        const UNRESTRICTED                  = 0,\n+        const RESTRICTION_STMT_EXPR         = 1 << 0,\n+        const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n }\n \n@@ -339,7 +339,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restrictions: UNRESTRICTED,\n+            restrictions: Restrictions::UNRESTRICTED,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2198,7 +2198,10 @@ impl<'a> Parser<'a> {\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n+                        let prohibited = self.restrictions.contains(\n+                            Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                        );\n+                        if !prohibited {\n                             // It's a struct literal.\n                             try!(self.bump());\n                             let mut fields = Vec::new();\n@@ -2759,7 +2762,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> PResult<P<Expr>> {\n-        let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n+        let restrictions = self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL;\n         let op_span = self.span;\n         match self.token {\n           token::Eq => {\n@@ -2814,7 +2817,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -2828,7 +2831,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr();\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let thn = try!(self.parse_block());\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2846,7 +2849,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let thn = try!(self.parse_block());\n         let (hi, els) = if try!(self.eat_keyword(keywords::Else) ){\n             let expr = try!(self.parse_else_expr());\n@@ -2905,7 +2908,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect_keyword(keywords::In));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let loop_block = try!(self.parse_block());\n         let hi = self.last_span.hi;\n \n@@ -2918,7 +2921,7 @@ impl<'a> Parser<'a> {\n             return self.parse_while_let_expr(opt_ident);\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident)));\n@@ -2930,7 +2933,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n@@ -2945,7 +2948,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         try!(self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace)));\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n@@ -2966,7 +2969,7 @@ impl<'a> Parser<'a> {\n             guard = Some(try!(self.parse_expr_nopanic()));\n         }\n         try!(self.expect(&token::FatArrow));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_STMT_EXPR));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2988,7 +2991,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr_nopanic(&mut self) -> PResult<P<Expr>> {\n-        return self.parse_expr_res(UNRESTRICTED);\n+        return self.parse_expr_res(Restrictions::UNRESTRICTED);\n     }\n \n     /// Parse an expression, subject to the given restrictions\n@@ -3564,7 +3567,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = try!(self.parse_expr_res(RESTRICTION_STMT_EXPR));\n+                    let e = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n                     spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID))\n                 }\n             }\n@@ -3573,7 +3576,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(Restrictions::RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}, {"sha": "362439c146912dae5f05ebcd51de749e8d90e22d", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 23, "deletions": 70, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -15,12 +15,13 @@\n #include <stdlib.h>\n \n #if !defined(__WIN32__)\n-#include <sys/time.h>\n-#include <sys/types.h>\n #include <dirent.h>\n+#include <pthread.h>\n #include <signal.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n #include <unistd.h>\n-#include <pthread.h>\n #else\n #include <windows.h>\n #include <wincrypt.h>\n@@ -41,44 +42,31 @@\n //include valgrind.h after stdint.h so that uintptr_t is defined for msys2 w64\n #include \"valgrind/valgrind.h\"\n \n-#ifdef __APPLE__\n-#if (TARGET_OS_IPHONE)\n-extern char **environ;\n-#endif\n-#endif\n-\n-#if defined(__FreeBSD__) || defined(__linux__) || defined(__ANDROID__) || \\\n-    defined(__DragonFly__) || defined(__Bitrig__) || defined(__OpenBSD__)\n-extern char **environ;\n-#endif\n-\n-#if defined(__WIN32__)\n-char**\n-rust_env_pairs() {\n-    return 0;\n-}\n-#else\n-char**\n-rust_env_pairs() {\n-#if defined(__APPLE__) && !(TARGET_OS_IPHONE)\n-    char **environ = *_NSGetEnviron();\n-#endif\n-    return environ;\n-}\n-#endif\n-\n+#ifndef _WIN32\n char*\n-#if defined(__WIN32__)\n-rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n-    return entry_ptr->cFileName;\n-}\n-#else\n rust_list_dir_val(struct dirent* entry_ptr) {\n     return entry_ptr->d_name;\n }\n+\n+int\n+rust_dir_get_mode(struct dirent* entry_ptr) {\n+#if defined(_DIRENT_HAVE_D_TYPE)\n+    switch (entry_ptr->d_type) {\n+        case DT_BLK: return S_IFBLK;\n+        case DT_CHR: return S_IFCHR;\n+        case DT_FIFO: return S_IFIFO;\n+        case DT_LNK: return S_IFLNK;\n+        case DT_REG: return S_IFREG;\n+        case DT_SOCK: return S_IFSOCK;\n+    }\n #endif\n+    return -1;\n+}\n \n-#ifndef _WIN32\n+ino_t\n+rust_dir_get_ino(struct dirent* entry_ptr) {\n+    return entry_ptr->d_ino;\n+}\n \n DIR*\n rust_opendir(char *dirname) {\n@@ -94,21 +82,6 @@ int\n rust_dirent_t_size() {\n     return sizeof(struct dirent);\n }\n-\n-#else\n-\n-void\n-rust_opendir() {\n-}\n-\n-void\n-rust_readdir() {\n-}\n-\n-void\n-rust_dirent_t_size() {\n-}\n-\n #endif\n \n uintptr_t\n@@ -173,26 +146,6 @@ rust_valgrind_stack_deregister(unsigned int id) {\n   VALGRIND_STACK_DEREGISTER(id);\n }\n \n-#if defined(__WIN32__)\n-\n-void\n-rust_unset_sigprocmask() {\n-    // empty stub for windows to keep linker happy\n-}\n-\n-#else\n-\n-void\n-rust_unset_sigprocmask() {\n-    // this can't be safely converted to rust code because the\n-    // representation of sigset_t is platform-dependent\n-    sigset_t sset;\n-    sigemptyset(&sset);\n-    sigprocmask(SIG_SETMASK, &sset, NULL);\n-}\n-\n-#endif\n-\n #if defined(__DragonFly__)\n #include <errno.h>\n // In DragonFly __error() is an inline function and as such"}, {"sha": "375c5fc746c5b80843b0d03ccb7c2c9aac447264", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -189,8 +189,10 @@ extern \"C\" LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B,\n                                                failure_order\n                                                ));\n }\n-extern \"C\" LLVMValueRef LLVMBuildAtomicFence(LLVMBuilderRef B, AtomicOrdering order) {\n-    return wrap(unwrap(B)->CreateFence(order));\n+extern \"C\" LLVMValueRef LLVMBuildAtomicFence(LLVMBuilderRef B,\n+                                             AtomicOrdering order,\n+                                             SynchronizationScope scope) {\n+    return wrap(unwrap(B)->CreateFence(order, scope));\n }\n \n extern \"C\" void LLVMSetDebug(int Enabled) {"}, {"sha": "2df57b08f283c3f3dd9350ba7b8cacb7682f1fd0", "filename": "src/test/compile-fail/lint-no-drop-on-repr-extern.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check we reject structs that mix a `Drop` impl with `#[repr(C)]`.\n+//\n+// As a special case, also check that we do not warn on such structs\n+// if they also are declared with `#[unsafe_no_drop_flag]`\n+\n+#![feature(unsafe_no_drop_flag)]\n+#![deny(drop_with_repr_extern)]\n+\n+#[repr(C)] struct As { x: Box<i8> }\n+#[repr(C)] enum Ae { Ae(Box<i8>), _None }\n+\n+struct Bs { x: Box<i8> }\n+enum Be { Be(Box<i8>), _None }\n+\n+#[repr(C)] struct Cs { x: Box<i8> }\n+//~^ NOTE the `#[repr(C)]` attribute is attached here\n+\n+impl Drop for Cs { fn drop(&mut self) { } }\n+//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n+\n+#[repr(C)] enum Ce { Ce(Box<i8>), _None }\n+//~^ NOTE the `#[repr(C)]` attribute is attached here\n+\n+impl Drop for Ce { fn drop(&mut self) { } }\n+//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n+\n+#[unsafe_no_drop_flag]\n+#[repr(C)] struct Ds { x: Box<i8> }\n+\n+impl Drop for Ds { fn drop(&mut self) { } }\n+\n+#[unsafe_no_drop_flag]\n+#[repr(C)] enum De { De(Box<i8>), _None }\n+\n+impl Drop for De { fn drop(&mut self) { } }\n+\n+fn main() {\n+    let a = As { x: Box::new(3) };\n+    let b = Bs { x: Box::new(3) };\n+    let c = Cs { x: Box::new(3) };\n+    let d = Ds { x: Box::new(3) };\n+\n+    println!(\"{:?}\", (*a.x, *b.x, *c.x, *d.x));\n+\n+    let _a = Ae::Ae(Box::new(3));\n+    let _b = Be::Be(Box::new(3));\n+    let _c = Ce::Ce(Box::new(3));\n+    let _d = De::De(Box::new(3));\n+}"}, {"sha": "5fc580755043d426185fd02a7b656132184e325b", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-android: FIXME(#10381)\n // min-lldb-version: 310\n \n // compile-flags:-g"}, {"sha": "785778e62f6eadafbe94c2e77142691450faadc3", "filename": "src/test/debuginfo/constant-in-match-pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-android: FIXME(#10381)\n // min-lldb-version: 310\n \n // compile-flags:-g"}, {"sha": "ce6ef080c1f11955850346b3daf8a960cabca0b5", "filename": "src/test/debuginfo/cross-crate-spans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,7 +10,6 @@\n \n #![omit_gdb_pretty_printer_section]\n \n-// ignore-android: FIXME(#10381)\n // min-lldb-version: 310\n \n // aux-build:cross_crate_spans.rs"}, {"sha": "4eae074120233fd5e121f8e9c972e031edb6f59e", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n // ignore-lldb\n-// ignore-android: FIXME(#10381)\n+// ignore-android: FIXME(#24958)\n \n // compile-flags:-g\n "}, {"sha": "87fd2e9a65d031b3401b5626c15c73274d2bc603", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-android: FIXME(#10381)\n // ignore-windows\n // min-lldb-version: 310\n "}, {"sha": "3f4849dbcb2b17d083b435bbe3abd9055b6bb5fe", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -10,6 +10,7 @@\n \n // no-pretty-expanded FIXME #15189\n // ignore-windows FIXME #13259\n+// ignore-android FIXME #17520\n \n use std::env;\n use std::process::{Command, Stdio};"}, {"sha": "8dbe927f06bf14257e7ef7b07f4ae235a13d0dce", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -109,11 +109,6 @@ pub fn main() {\n         assert_eq!(cttz32(100), 2);\n         assert_eq!(cttz64(100), 2);\n \n-        assert_eq!(cttz8(-1), 0);\n-        assert_eq!(cttz16(-1), 0);\n-        assert_eq!(cttz32(-1), 0);\n-        assert_eq!(cttz64(-1), 0);\n-\n         assert_eq!(bswap16(0x0A0B), 0x0B0A);\n         assert_eq!(bswap32(0x0ABBCC0D), 0x0DCCBB0A);\n         assert_eq!(bswap64(0x0122334455667708), 0x0877665544332201);"}, {"sha": "33ac519a584f99bbd941524418f9a2d670fb0561", "filename": "src/test/run-pass/issue-24945-repeat-dash-opts.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fissue-24945-repeat-dash-opts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fissue-24945-repeat-dash-opts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24945-repeat-dash-opts.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is just checking that we continue to accept `-g -g -O -O`\n+// as options to the compiler.\n+\n+// compile-flags:-g -g -O -O\n+\n+fn main() {\n+    assert_eq!(1, 1);\n+}"}, {"sha": "7754e9c3ad73593ff38d5f93d72c7253de148daf", "filename": "src/test/run-pass/issue24687-embed-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue24687-embed-debuginfo.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:issue24687_lib.rs\n+// compile-flags:-g\n \n extern crate issue24687_lib as d;\n "}, {"sha": "ac5634e6cdd16a26a4b92a1a9665425695930c1d", "filename": "src/test/run-pass/nullable-pointer-opt-closures.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fnullable-pointer-opt-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fnullable-pointer-opt-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-opt-closures.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::mem;\n+\n+pub fn main() {\n+    // By Ref Capture\n+    let a = 10i32;\n+    let b = Some(|| println!(\"{}\", a));\n+    // When we capture by reference we can use any of the\n+    // captures as the discriminant since they're all\n+    // behind a pointer.\n+    assert_eq!(mem::size_of_val(&b), mem::size_of::<usize>());\n+\n+    // By Value Capture\n+    let a = Box::new(12i32);\n+    let b = Some(move || println!(\"{}\", a));\n+    // We captured `a` by value and since it's a `Box` we can use it\n+    // as the discriminant.\n+    assert_eq!(mem::size_of_val(&b), mem::size_of::<Box<i32>>());\n+\n+    // By Value Capture - Transitive case\n+    let a = \"Hello\".to_string(); // String -> Vec -> Unique -> NonZero\n+    let b = Some(move || println!(\"{}\", a));\n+    // We captured `a` by value and since down the chain it contains\n+    // a `NonZero` field, we can use it as the discriminant.\n+    assert_eq!(mem::size_of_val(&b), mem::size_of::<String>());\n+\n+    // By Value - No Optimization\n+    let a = 14i32;\n+    let b = Some(move || println!(\"{}\", a));\n+    // We captured `a` by value but we can't use it as the discriminant\n+    // thus we end up with an extra field for the discriminant\n+    assert_eq!(mem::size_of_val(&b), mem::size_of::<(i32, i32)>());\n+}"}, {"sha": "4b32b881be73868eed9442a63fb2805c5ac5fa32", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5449f5d29e175230a1285ebe92394f50c76e1df6/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=5449f5d29e175230a1285ebe92394f50c76e1df6", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-android: FIXME(#9116) Bus error\n-\n use std::mem;\n \n #[repr(packed)]"}]}