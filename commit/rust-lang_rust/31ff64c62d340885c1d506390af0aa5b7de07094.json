{"sha": "31ff64c62d340885c1d506390af0aa5b7de07094", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZmY2NGM2MmQzNDA4ODVjMWQ1MDYzOTBhZjBhYTViN2RlMDcwOTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-20T02:17:59Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-20T02:17:59Z"}, "message": "Annotate FIXMEs in parser\n\nAlso, get rid of two FIXMEs by refactoring some code, and moving the\ncall_expr check for be expressions into typeck, where it seems to\nmake more sense.", "tree": {"sha": "2b93b409a13f4654c54436c447f38973735c5cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b93b409a13f4654c54436c447f38973735c5cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ff64c62d340885c1d506390af0aa5b7de07094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ff64c62d340885c1d506390af0aa5b7de07094", "html_url": "https://github.com/rust-lang/rust/commit/31ff64c62d340885c1d506390af0aa5b7de07094", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ff64c62d340885c1d506390af0aa5b7de07094/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdc8722f9503efdac0c619cfed1958192fe59eb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc8722f9503efdac0c619cfed1958192fe59eb9", "html_url": "https://github.com/rust-lang/rust/commit/cdc8722f9503efdac0c619cfed1958192fe59eb9"}], "stats": {"total": 61, "additions": 30, "deletions": 31}, "files": [{"sha": "ae2e2e9a1842d9c604b71cbbf536b5a30139af02", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/31ff64c62d340885c1d506390af0aa5b7de07094/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ff64c62d340885c1d506390af0aa5b7de07094/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=31ff64c62d340885c1d506390af0aa5b7de07094", "patch": "@@ -26,6 +26,9 @@ export parse_stmt;\n export parse_ty;\n \n // FIXME: #ast expects to find this here but it's actually defined in `parse`\n+// Fixing this will be easier when we have export decls on individual items --\n+// then parse can export this publicly, and everything else crate-visibly.\n+// (See #1893)\n import parse_from_source_str;\n export parse_from_source_str;\n \n@@ -224,8 +227,10 @@ fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     let inputs =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   parse_fn_input_ty, p);\n-    // FIXME: there's no syntax for this right now anyway\n-    //  auto constrs = parse_constrs(~[], p);\n+    // FIXME: constrs is empty because right now, higher-order functions\n+    // can't have constrained types.\n+    // Not sure whether that would be desirable anyway. See #34 for the\n+    // story on constrained types.\n     let constrs: [@ast::constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n     ret {inputs: inputs.node, output: ret_ty,\n@@ -400,9 +405,9 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n fn region_from_name(p: parser, s: option<str>) -> ast::region {\n     let r = alt s {\n       some (string) {\n-        // FIXME: To be consistent with our type resolution the\n+        // FIXME: To be consistent with our type resolution, the\n         // static region should probably be resolved during type\n-        // checking, not in the parser.\n+        // checking, not in the parser. (Issue #2256)\n         if string == \"static\" {\n             ast::re_static\n         } else {\n@@ -973,12 +978,8 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         hi = p.span.hi;\n     } else if eat_word(p, \"be\") {\n         let e = parse_expr(p);\n-\n-        // FIXME: Is this the right place for this check?\n-        if /*check*/ast_util::is_call_expr(e) {\n-            hi = e.span.hi;\n-            ex = ast::expr_be(e);\n-        } else { p.fatal(\"non-call expression in tail call\"); }\n+        hi = e.span.hi;\n+        ex = ast::expr_be(e);\n     } else if eat_word(p, \"copy\") {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n@@ -2070,6 +2071,19 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     }\n }\n \n+fn parse_single_class_item(p: parser, privcy: ast::privacy)\n+    -> @ast::class_member {\n+   if eat_word(p, \"let\") {\n+      let a_var = parse_instance_var(p, privcy);\n+      expect(p, token::SEMI);\n+      ret a_var;\n+   }\n+   else {\n+       let m = parse_method(p, privcy);\n+       ret @{node: ast::class_method(m), span: m.span};\n+   }\n+}\n+\n // lets us identify the constructor declaration at\n // parse time\n enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n@@ -2089,35 +2103,18 @@ fn parse_class_item(p:parser, class_name_with_tps:@ast::path)\n         let body = parse_block(p);\n         ret ctor_decl(decl, body, ast_util::mk_sp(lo, p.last_span.hi));\n     }\n-    // FIXME: refactor\n     else if eat_word(p, \"priv\") {\n             expect(p, token::LBRACE);\n             let mut results = [];\n             while p.token != token::RBRACE {\n-               if eat_word(p, \"let\") {\n-                  let a_var = parse_instance_var(p, ast::priv);\n-                  expect(p, token::SEMI);\n-                  results += [a_var];\n-               }\n-               else {\n-                   let m = parse_method(p, ast::priv);\n-                   results += [@{node: ast::class_method(m), span: m.span}];\n-               }\n+                    results += [parse_single_class_item(p, ast::priv)];\n             }\n             p.bump();\n             ret members(results);\n     }\n     else {\n         // Probably need to parse attrs\n-        ret if eat_word(p, \"let\") {\n-             let ivar = parse_instance_var(p, ast::pub);\n-             expect(p, token::SEMI);\n-             members([ivar])\n-        }\n-        else {\n-            let m = parse_method(p, ast::pub);\n-            members([@{node: ast::class_method(m), span: m.span}])\n-        }\n+        ret members([parse_single_class_item(p, ast::pub)]);\n     }\n }\n "}, {"sha": "4e41129dd3c3876c21fbd22ccfbed54311629e88", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ff64c62d340885c1d506390af0aa5b7de07094/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ff64c62d340885c1d506390af0aa5b7de07094/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=31ff64c62d340885c1d506390af0aa5b7de07094", "patch": "@@ -3160,8 +3160,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_bot(id);\n       }\n       ast::expr_be(e) {\n-        // FIXME: prove instead of assert\n-        assert (ast_util::is_call_expr(e));\n+        if !ast_util::is_call_expr(e) {\n+           tcx.sess.span_err(expr.span,\n+              \"non-call expression in tail call\");\n+        }\n         check_expr_with(fcx, e, fcx.ret_ty);\n         bot = true;\n         fcx.write_nil(id);"}]}