{"sha": "ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNzQ3ZjY0NWZmZGZjZWE0ZjM5YWQ0Y2NjNGQ4Mzc0MmE0ZWEzYWE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-14T01:19:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T15:23:51Z"}, "message": "rustc_metadata: replace Entry table with one table for each of its fields (AoS -> SoA).", "tree": {"sha": "3677e1377160da74f3bb0c6f4e05a64250b1b1f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3677e1377160da74f3bb0c6f4e05a64250b1b1f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "html_url": "https://github.com/rust-lang/rust/commit/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "972b93b20e2d21307622eacb812d8a552ecf0f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/972b93b20e2d21307622eacb812d8a552ecf0f81", "html_url": "https://github.com/rust-lang/rust/commit/972b93b20e2d21307622eacb812d8a552ecf0f81"}], "stats": {"total": 1066, "additions": 469, "deletions": 597}, "files": [{"sha": "962846b0475330c075b9402d20eb513caf258ff8", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "patch": "@@ -473,27 +473,20 @@ impl<'a, 'tcx> CrateMetadata {\n             self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n-    fn entry_unless_proc_macro(&self, id: DefIndex) -> Option<Entry<'tcx>> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => Some(self.entry(id)),\n-        }\n-    }\n-\n-    fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        self.root.per_def.entry.get(self, item_id)\n-    }\n-\n-    fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n-        match self.maybe_entry(item_id) {\n-            None => {\n-                bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n-                     item_id,\n-                     self.root.name,\n-                     self.cnum)\n-            }\n-            Some(d) => d.decode(self),\n-        }\n+    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind<'tcx>> {\n+        self.root.per_def.kind.get(self, item_id).map(|k| k.decode(self))\n+    }\n+\n+    fn kind(&self, item_id: DefIndex) -> EntryKind<'tcx> {\n+        assert!(!self.is_proc_macro(item_id));\n+        self.maybe_kind(item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn local_def_id(&self, index: DefIndex) -> DefId {\n@@ -529,7 +522,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n-            self.entry(index).kind.def_kind()\n+            self.kind(index).def_kind()\n         } else {\n             Some(DefKind::Macro(\n                 macro_kind(self.raw_proc_macro(index))\n@@ -538,7 +531,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.entry(index).span.decode((self, sess))\n+        self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n     crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -567,12 +560,12 @@ impl<'a, 'tcx> CrateMetadata {\n             helper_attrs,\n             self.root.edition,\n             Symbol::intern(name),\n-            &self.get_attributes(&self.entry(id), sess),\n+            &self.get_item_attrs(id, sess),\n         )\n     }\n \n     crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n-        match self.entry(item_id).kind {\n+        match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n                 ty::TraitDef::new(self.local_def_id(item_id),\n@@ -597,18 +590,24 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_variant(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        item: &Entry<'_>,\n+        kind: &EntryKind<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n-        adt_kind: ty::AdtKind,\n     ) -> ty::VariantDef {\n-        let data = match item.kind {\n+        let data = match kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n+        let adt_kind = match kind {\n+            EntryKind::Variant(_) => ty::AdtKind::Enum,\n+            EntryKind::Struct(..) => ty::AdtKind::Struct,\n+            EntryKind::Union(..) => ty::AdtKind::Union,\n+            _ => bug!(),\n+        };\n+\n         let variant_did = if adt_kind == ty::AdtKind::Enum {\n             Some(self.local_def_id(index))\n         } else {\n@@ -622,14 +621,12 @@ impl<'a, 'tcx> CrateMetadata {\n             variant_did,\n             ctor_did,\n             data.discr,\n-            item.children.decode(self).map(|index| {\n-                let f = self.entry(index);\n-                ty::FieldDef {\n+            self.root.per_def.children.get(self, index).unwrap_or(Lazy::empty())\n+                .decode(self).map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n                     ident: Ident::with_dummy_span(self.item_name(index)),\n-                    vis: f.visibility.decode(self)\n-                }\n-            }).collect(),\n+                    vis: self.get_visibility(index),\n+                }).collect(),\n             data.ctor_kind,\n             adt_kind,\n             parent_did,\n@@ -638,52 +635,52 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n-        let item = self.entry(item_id);\n+        let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n-        let (kind, repr) = match item.kind {\n+        let (adt_kind, repr) = match kind {\n             EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let variants = if let ty::AdtKind::Enum = kind {\n-            item.children\n+        let variants = if let ty::AdtKind::Enum = adt_kind {\n+            self.root.per_def.children.get(self, item_id).unwrap_or(Lazy::empty())\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(tcx, &self.entry(index), index, did, kind)\n+                    self.get_variant(tcx, &self.kind(index), index, did)\n                 })\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &item, item_id, did, kind)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n         };\n \n-        tcx.alloc_adt_def(did, kind, variants, repr)\n+        tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n     crate fn get_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n }\n \n     crate fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.entry(item_id).kind {\n+        let super_predicates = match self.kind(item_id) {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n             EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),\n@@ -693,34 +690,35 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.entry(item_id).generics.unwrap().decode((self, sess))\n+        self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.entry(id).ty.unwrap().decode((self, tcx))\n+        self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n-            false => self.entry(id).stability.map(|stab| stab.decode(self)),\n+            false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n     crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n+        self.root.per_def.deprecation.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n+            .map(|depr| depr.decode(self))\n     }\n \n     crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.entry(id).visibility.decode(self),\n+            false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n         }\n     }\n \n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n         }\n@@ -816,38 +814,42 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n \n         // Find the item.\n-        let item = match self.maybe_entry(id) {\n+        let kind = match self.maybe_kind(id) {\n             None => return,\n-            Some(item) => item.decode((self, sess)),\n+            Some(kind) => kind,\n         };\n \n         // Iterate over all children.\n         let macros_only = self.dep_kind.lock().macros_only();\n-        for child_index in item.children.decode((self, sess)) {\n+        let children = self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty());\n+        for child_index in children.decode((self, sess)) {\n             if macros_only {\n                 continue\n             }\n \n             // Get the item.\n-            if let Some(child) = self.maybe_entry(child_index) {\n-                let child = child.decode((self, sess));\n-                match child.kind {\n+            if let Some(child_kind) = self.maybe_kind(child_index) {\n+                match child_kind {\n                     EntryKind::MacroDef(..) => {}\n                     _ if macros_only => continue,\n                     _ => {}\n                 }\n \n                 // Hand off the item to the callback.\n-                match child.kind {\n+                match child_kind {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n-                        for child_index in child.children.decode((self, sess)) {\n+                        let child_children =\n+                            self.root.per_def.children.get(self, child_index)\n+                                .unwrap_or(Lazy::empty());\n+                        for child_index in child_children.decode((self, sess)) {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n                                     ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n-                                    span: self.entry(child_index).span.decode((self, sess)),\n+                                    span: self.root.per_def.span.get(self, child_index).unwrap()\n+                                        .decode((self, sess)),\n                                 });\n                             }\n                         }\n@@ -859,7 +861,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 }\n \n                 let def_key = self.def_key(child_index);\n-                let span = child.span.decode((self, sess));\n+                let span = self.get_span(child_index, sess);\n                 if let (Some(kind), Some(name)) =\n                     (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n@@ -912,7 +914,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }\n         }\n \n-        if let EntryKind::Mod(data) = item.kind {\n+        if let EntryKind::Mod(data) = kind {\n             for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n                 match exp.res {\n                     Res::Def(DefKind::Macro(..), _) => {}\n@@ -926,31 +928,33 @@ impl<'a, 'tcx> CrateMetadata {\n \n     crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n-        self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n+            self.root.per_def.mir.get(self, id).is_some()\n     }\n \n     crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n+        self.root.per_def.mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n     crate fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.promoted_mir.map(|promoted| promoted.decode((self, tcx))))\n+        self.root.per_def.promoted_mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n     crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplFinal, qualif, _) => {\n@@ -961,12 +965,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n-        let item = self.entry(id);\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n-        let (kind, container, has_self) = match item.kind {\n+        let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => {\n                 (ty::AssocKind::Const, container, false)\n             }\n@@ -986,7 +989,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::AssocItem {\n             ident: Ident::from_interned_str(name),\n             kind,\n-            vis: item.visibility.decode(self),\n+            vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n             container: container.with_def_id(parent),\n@@ -995,11 +998,12 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.entry(id).variances.decode(self).collect()\n+        self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n+            .decode(self).collect()\n     }\n \n     crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n-        match self.entry(node_id).kind {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n             EntryKind::Variant(data) => data.decode(self).ctor_kind,\n@@ -1008,7 +1012,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n-        match self.entry(node_id).kind {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n             }\n@@ -1030,26 +1034,22 @@ impl<'a, 'tcx> CrateMetadata {\n             node_id\n         };\n \n-        let item = self.entry(item_id);\n-        Lrc::from(self.get_attributes(&item, sess))\n+        Lrc::from(self.root.per_def.attributes.get(self, item_id).unwrap_or(Lazy::empty())\n+            .decode((self, sess))\n+            .collect::<Vec<_>>())\n     }\n \n     crate fn get_struct_field_names(\n         &self,\n         id: DefIndex,\n         sess: &Session,\n     ) -> Vec<Spanned<ast::Name>> {\n-        self.entry(id)\n-            .children\n+        self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self)\n             .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n             .collect()\n     }\n \n-    fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n-        item.attributes.decode((self, sess)).collect()\n-    }\n-\n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n@@ -1070,10 +1070,11 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n-        tcx.arena.alloc_from_iter(self.entry(id)\n-                                      .inherent_impls\n-                                      .decode(self)\n-                                      .map(|index| self.local_def_id(index)))\n+        tcx.arena.alloc_from_iter(\n+            self.root.per_def.inherent_impls.get(self, id).unwrap_or(Lazy::empty())\n+                .decode(self)\n+                .map(|index| self.local_def_id(index))\n+        )\n     }\n \n     crate fn get_implementations_for_trait(\n@@ -1115,7 +1116,7 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => return None,\n         }\n         def_key.parent.and_then(|parent_index| {\n-            match self.entry(parent_index).kind {\n+            match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n                 EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1168,7 +1169,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let param_names = match self.entry(id).kind {\n+        let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n@@ -1191,23 +1192,22 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_rendered_const(&self, id: DefIndex) -> String {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n     crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n-        let entry = self.entry(id);\n-        match entry.kind {\n+        match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n     crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n-        let constness = match self.entry(id).kind {\n+        let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n@@ -1217,16 +1217,16 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n-         match self.entry(id).kind {\n+         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n             EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n-            _ => bug!(\"asyncness: expect functions entry.\"),\n+            _ => bug!(\"asyncness: expected function kind\"),\n         }\n     }\n \n     crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n             EntryKind::ForeignFn(_) => true,\n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n             EntryKind::MutStatic |\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.entry(id).kind {\n+        let sig = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,\n             EntryKind::Method(data) => data.decode(self).fn_data.sig,"}, {"sha": "3bc3fee4164f2d890d4719e87830c9e4c5aed255", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 355, "deletions": 478, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n+use rustc::ty::{self, Ty, TyCtxt, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n \n@@ -61,7 +61,23 @@ struct EncodeContext<'tcx> {\n }\n \n struct PerDefTables<'tcx> {\n-    entry: PerDefTable<Lazy<Entry<'tcx>>>,\n+    kind: PerDefTable<Lazy<EntryKind<'tcx>>>,\n+    visibility: PerDefTable<Lazy<ty::Visibility>>,\n+    span: PerDefTable<Lazy<Span>>,\n+    attributes: PerDefTable<Lazy<[ast::Attribute]>>,\n+    children: PerDefTable<Lazy<[DefIndex]>>,\n+    stability: PerDefTable<Lazy<attr::Stability>>,\n+    deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n+\n+    ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n+    variances: PerDefTable<Lazy<[ty::Variance]>>,\n+    generics: PerDefTable<Lazy<ty::Generics>>,\n+    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n+    promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n }\n \n macro_rules! encoder_methods {\n@@ -482,7 +498,23 @@ impl<'tcx> EncodeContext<'tcx> {\n \n         i = self.position();\n         let per_def = LazyPerDefTables {\n-            entry: self.per_def.entry.encode(&mut self.opaque),\n+            kind: self.per_def.kind.encode(&mut self.opaque),\n+            visibility: self.per_def.visibility.encode(&mut self.opaque),\n+            span: self.per_def.span.encode(&mut self.opaque),\n+            attributes: self.per_def.attributes.encode(&mut self.opaque),\n+            children: self.per_def.children.encode(&mut self.opaque),\n+            stability: self.per_def.stability.encode(&mut self.opaque),\n+            deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n+\n+            ty: self.per_def.ty.encode(&mut self.opaque),\n+            inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n+            variances: self.per_def.variances.encode(&mut self.opaque),\n+            generics: self.per_def.generics.encode(&mut self.opaque),\n+            predicates: self.per_def.predicates.encode(&mut self.opaque),\n+            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+\n+            mir: self.per_def.mir.encode(&mut self.opaque),\n+            promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n         };\n         let per_def_bytes = self.position() - i;\n \n@@ -578,17 +610,14 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n+    fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.variances_of(def_id)[..])\n+        record!(self.per_def.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n     }\n \n-    fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let ty = tcx.type_of(def_id);\n-        debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(ty)\n+    fn encode_item_type(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n+        record!(self.per_def.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(\n@@ -617,32 +646,25 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy(variant.fields.iter().map(|f| {\n-                assert!(f.did.is_local());\n-                f.did.index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.per_def.children[def_id] <- variant.fields.iter().map(|f| {\n+            assert!(f.did.is_local());\n+            f.did.index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_enum_variant_ctor(\n@@ -676,29 +698,19 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_info_for_mod(\n@@ -719,27 +731,15 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Mod(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(attrs),\n-            children: self.lazy(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- attrs);\n+        record!(self.per_def.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+            tcx.hir().local_def_id(item_id.id).index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_field(\n@@ -758,25 +758,15 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Field,\n-            visibility: self.lazy(field.vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::Field);\n+        record!(self.per_def.visibility[def_id] <- field.vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &variant_data.fields()[field_index].attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n \n     fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n@@ -813,49 +803,35 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        let repr_options = get_repr_options(tcx, adt_def_id);\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Struct(self.lazy(data), repr_options),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n+    fn encode_generics(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(tcx.generics_of(def_id))\n+        record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_of(def_id))\n+        record!(self.per_def.predicates[def_id] <- &*self.tcx.predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_defined_on(def_id))\n+        record!(self.per_def.predicates_defined_on[def_id] <-\n+            &*self.tcx.predicates_defined_on(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n@@ -875,7 +851,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        let kind = match trait_item.kind {\n+        record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n@@ -884,7 +860,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n+                let fn_data = if let hir::TraitItemKind::Method(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n@@ -894,10 +870,10 @@ impl EncodeContext<'tcx> {\n                         }\n                     };\n                     FnData {\n-                        asyncness: method_sig.header.asyncness,\n+                        asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -910,44 +886,31 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n-        };\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind,\n-            visibility: self.lazy(trait_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match trait_item.kind {\n-                ty::AssocKind::Const |\n-                ty::AssocKind::Method => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n-                ty::AssocKind::Type => {\n-                    if trait_item.defaultness.has_value() {\n-                        Some(self.encode_item_type(def_id))\n-                    } else {\n-                        None\n-                    }\n+        });\n+        record!(self.per_def.visibility[def_id] <- trait_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match trait_item.kind {\n+            ty::AssocKind::Const |\n+            ty::AssocKind::Method => {\n+                self.encode_item_type(def_id);\n+            }\n+            ty::AssocKind::Type => {\n+                if trait_item.defaultness.has_value() {\n+                    self.encode_item_type(def_id);\n                 }\n-                ty::AssocKind::OpaqueTy => unreachable!(),\n-            },\n-            inherent_impls: Lazy::empty(),\n-            variances: if trait_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n+            }\n+            ty::AssocKind::OpaqueTy => unreachable!(),\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn metadata_output_only(&self) -> bool {\n@@ -970,7 +933,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"impl items always have values (currently)\"),\n         };\n \n-        let kind = match impl_item.kind {\n+        record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n@@ -988,7 +951,7 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -1001,8 +964,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n-        };\n-\n+        });\n+        record!(self.per_def.visibility[def_id] <- impl_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if impl_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1017,30 +990,10 @@ impl EncodeContext<'tcx> {\n             hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::TyAlias(..) => false,\n         };\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind,\n-            visibility: self.lazy(impl_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if impl_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n-        })\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n+        }\n     }\n \n     fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId)\n@@ -1060,51 +1013,44 @@ impl EncodeContext<'tcx> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n-    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(mir))\n-        } else {\n-            None\n+            record!(self.per_def.mir[def_id] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n-    fn encode_promoted_mir(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>> {\n+    fn encode_promoted_mir(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let promoted = self.tcx.promoted_mir(def_id);\n-            Some(self.lazy(promoted))\n-        } else {\n-            None\n+            record!(self.per_def.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n-        if implementations.is_empty() {\n-            Lazy::empty()\n-        } else {\n-            self.lazy(implementations.iter().map(|&def_id| {\n+        if !implementations.is_empty() {\n+            record!(self.per_def.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n-            }))\n+            }));\n         }\n     }\n \n-    fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n+    fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n-        self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n+        if let Some(stab) = self.tcx.lookup_stability(def_id) {\n+            record!(self.per_def.stability[def_id] <- stab)\n+        }\n     }\n \n-    fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n+    fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n+        if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n+            record!(self.per_def.deprecation[def_id] <- depr);\n+        }\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1119,11 +1065,11 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let kind = match item.kind {\n+        record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n@@ -1146,42 +1092,42 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemKind::TyAlias(..) => EntryKind::Type,\n             hir::ItemKind::OpaqueTy(..) => EntryKind::OpaqueTy,\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(tcx, def_id)),\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let ctor = struct_def.ctor_hir_id()\n-                    .map(|ctor_hir_id| tcx.hir().local_def_id(ctor_hir_id).index);\n-\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n+                    self.tcx.hir().local_def_id(ctor_hir_id).index\n+                });\n \n                 EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n-                let trait_ref = tcx.impl_trait_ref(def_id);\n-                let polarity = tcx.impl_polarity(def_id);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n-                    let trait_def = tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(tcx, def_id).nth(1).and_then(|node| {\n+                    let trait_def = self.tcx.trait_def(trait_ref.def_id);\n+                    trait_def.ancestors(self.tcx, def_id).nth(1).and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n                             _ => None,\n@@ -1195,8 +1141,8 @@ impl EncodeContext<'tcx> {\n                 // \"unsized info\", else just store None\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == tcx.lang_items().coerce_unsized_trait() {\n-                            Some(tcx.at(item.span).coerce_unsized_info(def_id))\n+                        if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                            Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n                         }\n@@ -1213,11 +1159,11 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = tcx.trait_def(def_id);\n+                let trait_def = self.tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n-                    has_auto_impl: tcx.trait_is_auto(def_id),\n+                    has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n                     super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n@@ -1233,7 +1179,95 @@ impl EncodeContext<'tcx> {\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n-        };\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n+        record!(self.per_def.span[def_id] <- item.span);\n+        record!(self.per_def.attributes[def_id] <- &item.attrs);\n+        // FIXME(eddyb) there should be a nicer way to do this.\n+        match item.kind {\n+            hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n+                fm.items\n+                    .iter()\n+                    .map(|foreign_item| tcx.hir().local_def_id(\n+                        foreign_item.hir_id).index)\n+            ),\n+            hir::ItemKind::Enum(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).variants.iter().map(|v| {\n+                    assert!(v.def_id.is_local());\n+                    v.def_id.index\n+                })\n+            ),\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n+                    assert!(f.did.is_local());\n+                    f.did.index\n+                })\n+            ),\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Trait(..) => {\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record!(self.per_def.children[def_id] <-\n+                    associated_item_def_ids.iter().map(|&def_id| {\n+                        assert!(def_id.is_local());\n+                        def_id.index\n+                    })\n+                );\n+            }\n+            _ => {}\n+        }\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n+            _ => {}\n+        }\n+        self.encode_inherent_implementations(def_id);\n+        match item.kind {\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n+            _ => {}\n+        }\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_generics(def_id);\n+                self.encode_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n+        // The only time that `predicates_defined_on` is used (on\n+        // an external item) is for traits, during chalk lowering,\n+        // so only encode it in that case as an efficiency\n+        // hack. (No reason not to expand it in the future if\n+        // necessary.)\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_predicates_defined_on(def_id);\n+            }\n+            _ => {} // not *wrong* for other kinds of items, but not needed\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1248,174 +1282,48 @@ impl EncodeContext<'tcx> {\n             }\n             _ => false,\n         };\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(item.span),\n-            attributes: self.encode_attributes(&item.attrs),\n-            children: match item.kind {\n-                hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy(fm.items\n-                        .iter()\n-                        .map(|foreign_item| tcx.hir().local_def_id(\n-                            foreign_item.hir_id).index))\n-                }\n-                hir::ItemKind::Enum(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.variants.iter().map(|v| {\n-                        assert!(v.def_id.is_local());\n-                        v.def_id.index\n-                    }))\n-                }\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    }))\n-                }\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::Trait(..) => {\n-                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    }))\n-                }\n-                _ => Lazy::empty(),\n-            },\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) => Some(self.encode_item_type(def_id)),\n-                _ => None,\n-            },\n-            inherent_impls: self.encode_inherent_implementations(def_id),\n-            variances: match item.kind {\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n-                _ => None,\n-            },\n-            predicates: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates(def_id)),\n-                _ => None,\n-            },\n-\n-            // The only time that `predicates_defined_on` is used (on\n-            // an external item) is for traits, during chalk lowering,\n-            // so only encode it in that case as an efficiency\n-            // hack. (No reason not to expand it in the future if\n-            // necessary.)\n-            predicates_defined_on: match item.kind {\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => {\n-                    Some(self.encode_predicates_defined_on(def_id))\n-                }\n-                _ => None, // not *wrong* for other kinds of items, but not needed\n-            },\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n-        })\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n+        }\n     }\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n-                body: pprust::tts_to_string(macro_def.body.clone()),\n-                legacy: macro_def.legacy,\n-            })),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(macro_def.span),\n-            attributes: self.encode_attributes(&macro_def.attrs),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            children: Lazy::empty(),\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-            mir: None,\n-            promoted_mir: None,\n-        })\n+        record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(MacroDef {\n+            body: pprust::tts_to_string(macro_def.body.clone()),\n+            legacy: macro_def.legacy,\n+        })));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- macro_def.span);\n+        record!(self.per_def.attributes[def_id] <- &macro_def.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(\n         &mut self,\n         def_id: DefId,\n-        entry_kind: EntryKind<'tcx>,\n+        kind: EntryKind<'tcx>,\n         encode_type: bool,\n     ) {\n-        let tcx = self.tcx;\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: entry_kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-            ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        })\n+        record!(self.per_def.kind[def_id] <- kind);\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        if encode_type {\n+            self.encode_item_type(def_id);\n+        }\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n-        let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let kind = match tables.node_type(hir_id).kind {\n+\n+        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1430,61 +1338,32 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Closure(self.lazy(data))\n             }\n \n-            _ => bug!(\"closure that is neither generator nor closure\")\n-        };\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n+            _ => bug!(\"closure that is neither generator nor closure\"),\n+        });\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let tcx = self.tcx;\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let body_id = tcx.hir().body_owned_by(id);\n+        let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = tcx.mir_const_qualif(def_id).0;\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind: EntryKind::Const(ConstQualif { mir }, const_data),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        })\n-    }\n+        let mir = self.tcx.mir_const_qualif(def_id).0;\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n-        self.lazy(attrs)\n+        record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n@@ -1667,7 +1546,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        let kind = match nitem.kind {\n+        record!(self.per_def.kind[def_id] <- match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1680,30 +1559,19 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n-        };\n-\n-        record!(self.per_def.entry[def_id] <- Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(nitem.span),\n-            attributes: self.encode_attributes(&nitem.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: match nitem.kind {\n-                hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        })\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- nitem.span);\n+        record!(self.per_def.attributes[def_id] <- &nitem.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n }\n \n@@ -1906,11 +1774,28 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     // Since encoding metadata is not in a query, and nothing is cached,\n     // there's no need to do dep-graph tracking for any of it.\n     let (root, mut result) = tcx.dep_graph.with_ignore(move || {\n+        let def_count = tcx.hir().definitions().def_index_count();\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n             per_def: PerDefTables {\n-                entry: PerDefTable::new(tcx.hir().definitions().def_index_count()),\n+                kind: PerDefTable::new(def_count),\n+                visibility: PerDefTable::new(def_count),\n+                span: PerDefTable::new(def_count),\n+                attributes: PerDefTable::new(def_count),\n+                children: PerDefTable::new(def_count),\n+                stability: PerDefTable::new(def_count),\n+                deprecation: PerDefTable::new(def_count),\n+\n+                ty: PerDefTable::new(def_count),\n+                inherent_impls: PerDefTable::new(def_count),\n+                variances: PerDefTable::new(def_count),\n+                generics: PerDefTable::new(def_count),\n+                predicates: PerDefTable::new(def_count),\n+                predicates_defined_on: PerDefTable::new(def_count),\n+\n+                mir: PerDefTable::new(def_count),\n+                promoted_mir: PerDefTable::new(def_count),\n             },\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n@@ -1939,11 +1824,3 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n     EncodedMetadata { raw_data: result }\n }\n-\n-fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n-    let ty = tcx.type_of(did);\n-    match ty.kind {\n-        ty::Adt(ref def, _) => return def.repr,\n-        _ => bug!(\"{} is not an ADT\", ty),\n-    }\n-}"}, {"sha": "96f35783278fa5784d21821ce3b949944cabb262", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=ee747f645ffdfcea4f39ad4ccc4d83742a4ea3aa", "patch": "@@ -229,28 +229,23 @@ crate struct TraitImpls {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct LazyPerDefTables<'tcx> {\n-    pub entry: Lazy!(PerDefTable<Lazy<Entry<'tcx>>>),\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct Entry<'tcx> {\n-    pub kind: EntryKind<'tcx>,\n-    pub visibility: Lazy<ty::Visibility>,\n-    pub span: Lazy<Span>,\n-    pub attributes: Lazy<[ast::Attribute]>,\n-    pub children: Lazy<[DefIndex]>,\n-    pub stability: Option<Lazy<attr::Stability>>,\n-    pub deprecation: Option<Lazy<attr::Deprecation>>,\n-\n-    pub ty: Option<Lazy!(Ty<'tcx>)>,\n-    pub inherent_impls: Lazy<[DefIndex]>,\n-    pub variances: Lazy<[ty::Variance]>,\n-    pub generics: Option<Lazy<ty::Generics>>,\n-    pub predicates: Option<Lazy!(ty::GenericPredicates<'tcx>)>,\n-    pub predicates_defined_on: Option<Lazy!(ty::GenericPredicates<'tcx>)>,\n-\n-    pub mir: Option<Lazy!(mir::Body<'tcx>)>,\n-    pub promoted_mir: Option<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n+    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+\n+    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+\n+    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}]}