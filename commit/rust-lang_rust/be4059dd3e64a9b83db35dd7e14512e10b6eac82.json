{"sha": "be4059dd3e64a9b83db35dd7e14512e10b6eac82", "node_id": "C_kwDOAAsO6NoAKGJlNDA1OWRkM2U2NGE5YjgzZGIzNWRkN2UxNDUxMmUxMGI2ZWFjODI", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-03T03:22:46Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate stability.rs to translateable diagnostics", "tree": {"sha": "df001b4274dd749b6d12d565390ad42e816bd93c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df001b4274dd749b6d12d565390ad42e816bd93c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be4059dd3e64a9b83db35dd7e14512e10b6eac82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be4059dd3e64a9b83db35dd7e14512e10b6eac82", "html_url": "https://github.com/rust-lang/rust/commit/be4059dd3e64a9b83db35dd7e14512e10b6eac82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be4059dd3e64a9b83db35dd7e14512e10b6eac82/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "html_url": "https://github.com/rust-lang/rust/commit/3fe8e004e99b4b2dd616210d5c7e4d211ab25043"}], "stats": {"total": 293, "additions": 209, "deletions": 84}, "files": [{"sha": "a10ed0f83ea0e903c579cbb13b2776e9c5bb2b43", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=be4059dd3e64a9b83db35dd7e14512e10b6eac82", "patch": "@@ -600,3 +600,53 @@ passes_attribute_should_be_applied_to =\n \n passes_transparent_incompatible =\n     transparent {$target} cannot have other repr hints\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n+\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n+\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n+\n+passes_trait_impl_const_stable =\n+    trait implementations cannot be const stable yet\n+    .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n+\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n+\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n+\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here"}, {"sha": "e1261d29f57ac282b3b964625bc9ce6e0c48ad8f", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=be4059dd3e64a9b83db35dd7e14512e10b6eac82", "patch": "@@ -1313,3 +1313,116 @@ pub struct TransparentIncompatible {\n     pub hint_spans: Vec<Span>,\n     pub target: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::deprecated_attribute, code = \"E0549\")]\n+pub struct DeprecatedAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::useless_stability)]\n+pub struct UselessStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_stability)]\n+pub struct InvalidStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_stabilize_deprecated)]\n+pub struct CannotStabilizeDeprecated {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_deprecation_version)]\n+pub struct InvalidDeprecationVersion {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_stability_attr)]\n+pub struct MissingStabilityAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_stab_attr)]\n+pub struct MissingConstStabAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::trait_impl_const_stable)]\n+#[note]\n+pub struct TraitImplConstStable {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_only_on_nightly, code = \"E0554\")]\n+pub struct FeatureOnlyOnNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub release_channel: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_feature, code = \"E0635\")]\n+pub struct UnknownFeature {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::implied_feature_not_exist)]\n+pub struct ImpliedFeatureNotExist {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub implied_by: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_feature_err, code = \"E0636\")]\n+pub struct DuplicateFeatureErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_err)]\n+pub struct MissingConstErr {\n+    #[primary_span]\n+    #[help]\n+    pub fn_sig_span: Span,\n+    #[label]\n+    pub const_span: Span,\n+}"}, {"sha": "cfd6acd8d7cd0b404310d043e6838cc3768f2ffa", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 46, "deletions": 84, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4059dd3e64a9b83db35dd7e14512e10b6eac82/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=be4059dd3e64a9b83db35dd7e14512e10b6eac82", "patch": "@@ -1,13 +1,18 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors;\n+use crate::errors::{\n+    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n+    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n+    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n+    UnknownFeature, UselessStability,\n+};\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -20,7 +25,6 @@ use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{query::Providers, TyCtxt};\n use rustc_session::lint;\n use rustc_session::lint::builtin::{INEFFECTIVE_UNSTABLE_TRAIT_IMPL, USELESS_DEPRECATED};\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -179,7 +183,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 if !self.in_trait_impl\n                     || (self.in_trait_impl && !self.tcx.is_const_fn_raw(def_id.to_def_id()))\n                 {\n-                    missing_const_err(&self.tcx.sess, fn_sig.span, const_span);\n+                    self.tcx\n+                        .sess\n+                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -197,14 +203,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *span,\n-                    E0549,\n-                    \"deprecated attribute must be paired with \\\n-                    either stable or unstable attribute\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -220,10 +219,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.struct_span_err(span,\"this stability annotation is useless\")\n-                    .span_label(span, \"useless stability annotation\")\n-                    .span_label(item_sp, \"the stability attribute annotates this item\")\n-                    .emit();\n+                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -239,30 +235,25 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.struct_span_err(span, \"invalid stability version found\")\n-                                .span_label(span, \"invalid stability version\")\n-                                .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx.sess.struct_span_err(span, \"an API can't be stabilized after it is deprecated\")\n-                                        .span_label(span, \"invalid version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx.sess.struct_span_err(span, \"invalid deprecation version found\")\n-                                        .span_label(span, \"invalid deprecation version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n                                 }\n                                 break;\n                             }\n@@ -271,7 +262,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 }\n             }\n \n-            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } = stab {\n+            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } =\n+                stab\n+            {\n                 self.index.implications.insert(implied_by, feature);\n             }\n \n@@ -531,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n         let stab = self.tcx.stability().local_stability(def_id);\n         if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", descr));\n+            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -551,7 +544,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{descr} has missing const stability attribute\"));\n+            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -764,11 +757,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(item.span, \"trait implementations cannot be const stable yet\")\n-                            .note(\"see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\")\n-                            .emit();\n+                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -929,26 +918,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            duplicate_feature_err(tcx.sess, span, feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            struct_span_err!(\n-                tcx.sess,\n-                *span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                env!(\"CFG_RELEASE_CHANNEL\")\n-            )\n-            .emit();\n+            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+                span: *span,\n+                release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n+            });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            duplicate_feature_err(tcx.sess, *span, *feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1049,23 +1034,18 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n+        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n         let local_defined_features = tcx.lib_features(());\n-        let span = local_defined_features\n+        let span = *local_defined_features\n             .stable\n             .get(&feature)\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess\n-            .struct_span_err(\n-                *span,\n-                format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n-            )\n-            .emit();\n+        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we\n@@ -1088,21 +1068,20 @@ fn unnecessary_partially_stable_feature_lint(\n              by the feature `{implies}`\"\n         ),\n         |lint| {\n-            lint\n-        .span_suggestion(\n-            span,\n-            &format!(\n+            lint.span_suggestion(\n+                span,\n+                &format!(\n                 \"if you are using features which are still unstable, change to using `{implies}`\"\n             ),\n-            implies,\n-            Applicability::MaybeIncorrect,\n-        )\n-        .span_suggestion(\n-            tcx.sess.source_map().span_extend_to_line(span),\n-            \"if you are using features which are now stable, remove this line\",\n-            \"\",\n-            Applicability::MaybeIncorrect,\n-        )\n+                implies,\n+                Applicability::MaybeIncorrect,\n+            )\n+            .span_suggestion(\n+                tcx.sess.source_map().span_extend_to_line(span),\n+                \"if you are using features which are now stable, remove this line\",\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            )\n         },\n     );\n }\n@@ -1120,20 +1099,3 @@ fn unnecessary_stable_feature_lint(\n         lint\n     });\n }\n-\n-fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {\n-    struct_span_err!(sess, span, E0636, \"the feature `{}` has already been declared\", feature)\n-        .emit();\n-}\n-\n-fn missing_const_err(session: &Session, fn_sig_span: Span, const_span: Span) {\n-    const ERROR_MSG: &'static str = \"attributes `#[rustc_const_unstable]` \\\n-         and `#[rustc_const_stable]` require \\\n-         the function or method to be `const`\";\n-\n-    session\n-        .struct_span_err(fn_sig_span, ERROR_MSG)\n-        .span_help(fn_sig_span, \"make the function or method const\")\n-        .span_label(const_span, \"attribute specified here\")\n-        .emit();\n-}"}]}