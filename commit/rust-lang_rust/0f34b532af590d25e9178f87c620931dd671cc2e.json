{"sha": "0f34b532af590d25e9178f87c620931dd671cc2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMzRiNTMyYWY1OTBkMjVlOTE3OGY4N2M2MjA5MzFkZDY3MWNjMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-21T21:08:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-21T21:08:11Z"}, "message": "Auto merge of #39765 - GuillaumeGomez:file-not-found-for-module-error, r=jseyfried\n\nFile not found for module error\n\nFixes #39542.\n\nr? @jonathandturner\n\nMaybe you want to take a look @pnkfelix?", "tree": {"sha": "4647a38de83272a9442727839769987359c22b90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4647a38de83272a9442727839769987359c22b90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f34b532af590d25e9178f87c620931dd671cc2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f34b532af590d25e9178f87c620931dd671cc2e", "html_url": "https://github.com/rust-lang/rust/commit/0f34b532af590d25e9178f87c620931dd671cc2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f34b532af590d25e9178f87c620931dd671cc2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1ce4020c480e455ec902e3616843a3dd5fe489", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1ce4020c480e455ec902e3616843a3dd5fe489", "html_url": "https://github.com/rust-lang/rust/commit/8a1ce4020c480e455ec902e3616843a3dd5fe489"}, {"sha": "b6818be41dea90e53344f84770f5e0faaacee4a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6818be41dea90e53344f84770f5e0faaacee4a8", "html_url": "https://github.com/rust-lang/rust/commit/b6818be41dea90e53344f84770f5e0faaacee4a8"}], "stats": {"total": 233, "additions": 193, "deletions": 40}, "files": [{"sha": "2d59051ec4a537465b80ae6d9448054b4142a696", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=0f34b532af590d25e9178f87c620931dd671cc2e", "patch": "@@ -201,6 +201,74 @@ where appropriate is ongoing. Try using an unquoted name instead:\n pub fn something() {}\n ```\n \"##,\n+\n+E0583: r##\"\n+A file wasn't found for an out-of-line module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0583\n+mod file_that_doesnt_exist; // error: file not found for module\n+\n+fn main() {}\n+```\n+\n+Please be sure that a file corresponding to the module exists. If you\n+want to use a module named `file_that_doesnt_exist`, you need to have a file\n+named `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\n+same directory.\n+\"##,\n+\n+E0585: r##\"\n+A documentation comment that doesn't document anything was found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0585\n+fn main() {\n+    // The following doc comment will fail:\n+    /// This is a useless doc comment!\n+}\n+```\n+\n+Documentation comments need to be followed by items, including functions,\n+types, modules, etc. Examples:\n+\n+```\n+/// I'm documenting the following struct:\n+struct Foo;\n+\n+/// I'm documenting the following function:\n+fn foo() {}\n+```\n+\"##,\n+\n+E0586: r##\"\n+An inclusive range was used with no end.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0586\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1...]; // error: inclusive range was used with no end\n+```\n+\n+An inclusive range needs an end in order to *include* it. If you just need a\n+start and no end, use a non-inclusive range (with `..`):\n+\n+```\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1..]; // ok!\n+```\n+\n+Or put an end to your inclusive range:\n+\n+```\n+let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+let x = &tmp[1...3]; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -224,4 +292,5 @@ register_diagnostics! {\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0557, // feature has been removed\n+    E0584, // file for module `..` found at both .. and ..\n }"}, {"sha": "b5b8a6bc0ef64c80f08a32ed04739606146392a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0f34b532af590d25e9178f87c620931dd671cc2e", "patch": "@@ -219,7 +219,7 @@ fn is_ident_or_underscore(t: &token::Token) -> bool {\n pub struct ModulePath {\n     pub name: String,\n     pub path_exists: bool,\n-    pub result: Result<ModulePathSuccess, ModulePathError>,\n+    pub result: Result<ModulePathSuccess, Error>,\n }\n \n pub struct ModulePathSuccess {\n@@ -233,6 +233,63 @@ pub struct ModulePathError {\n     pub help_msg: String,\n }\n \n+pub enum Error {\n+    FileNotFoundForModule {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+        dir_path: String,\n+    },\n+    DuplicatePaths {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+    },\n+    UselessDocComment,\n+    InclusiveRangeWithNoEnd,\n+}\n+\n+impl Error {\n+    pub fn span_err<'a>(self, sp: Span, handler: &'a errors::Handler) -> DiagnosticBuilder<'a> {\n+        match self {\n+            Error::FileNotFoundForModule { ref mod_name,\n+                                           ref default_path,\n+                                           ref secondary_path,\n+                                           ref dir_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0583,\n+                                               \"file not found for module `{}`\", mod_name);\n+                err.help(&format!(\"name the file either {} or {} inside the directory {:?}\",\n+                                  default_path,\n+                                  secondary_path,\n+                                  dir_path));\n+                err\n+            }\n+            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n+                let mut err = struct_span_err!(handler, sp, E0584,\n+                                               \"file for module `{}` found at both {} and {}\",\n+                                               mod_name,\n+                                               default_path,\n+                                               secondary_path);\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            Error::UselessDocComment => {\n+                let mut err = struct_span_err!(handler, sp, E0585,\n+                                  \"found a documentation comment that doesn't document anything\");\n+                err.help(\"doc comments must come before what they document, maybe a comment was \\\n+                          intended with `//`?\");\n+                err\n+            }\n+            Error::InclusiveRangeWithNoEnd => {\n+                let mut err = struct_span_err!(handler, sp, E0586,\n+                                               \"inclusive range with no end\");\n+                err.help(\"inclusive ranges must be bounded at the end (`...b` or `a...b`)\");\n+                err\n+            }\n+        }\n+    }\n+}\n+\n pub enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(ThinVec<Attribute>),\n@@ -461,10 +518,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n-                    self.span_fatal_help(self.prev_span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")\n+                        self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n                     } else {\n                         let mut err = self.fatal(&format!(\"expected identifier, found `{}`\",\n                                                           self.this_token_to_string()));\n@@ -955,6 +1009,9 @@ impl<'a> Parser<'a> {\n     pub fn span_fatal(&self, sp: Span, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(sp, m)\n     }\n+    pub fn span_fatal_err(&self, sp: Span, err: Error) -> DiagnosticBuilder<'a> {\n+        err.span_err(sp, self.diagnostic())\n+    }\n     pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n         err.help(help);\n@@ -1944,10 +2001,7 @@ impl<'a> Parser<'a> {\n                     limits: RangeLimits)\n                     -> PResult<'a, ast::ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_help(self.span,\n-                                     \"inclusive range with no end\",\n-                                     \"inclusive ranges must be bounded at the end \\\n-                                      (`...b` or `a...b`)\"))\n+            Err(self.span_fatal_err(self.span, Error::InclusiveRangeWithNoEnd))\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n         }\n@@ -3862,10 +3916,7 @@ impl<'a> Parser<'a> {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n                             if s.prev_token_kind == PrevTokenKind::DocComment {\n-                                s.span_err_help(s.prev_span,\n-                                    \"found a documentation comment that doesn't document anything\",\n-                                    \"doc comments must come before what they document, maybe a \\\n-                                    comment was intended with `//`?\");\n+                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n                             } else {\n                                 s.span_err(s.span, \"expected statement after outer attribute\");\n                             }\n@@ -4998,10 +5049,8 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n             token::CloseDelim(token::Brace) => {}\n-            token::DocComment(_) => return Err(self.span_fatal_help(self.span,\n-                        \"found a documentation comment that doesn't document anything\",\n-                        \"doc comments must come before what they document, maybe a comment was \\\n-                        intended with `//`?\")),\n+            token::DocComment(_) => return Err(self.span_fatal_err(self.span,\n+                                                                   Error::UselessDocComment)),\n             _ => return Err(self.span_fatal_help(self.span,\n                     &format!(\"expected `,`, or `}}`, found `{}`\", self.this_token_to_string()),\n                     \"struct fields should be separated by commas\")),\n@@ -5162,8 +5211,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns either a path to a module, or .\n-    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath\n-    {\n+    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath {\n         let mod_name = id.to_string();\n         let default_path_str = format!(\"{}.rs\", mod_name);\n         let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n@@ -5183,19 +5231,16 @@ impl<'a> Parser<'a> {\n                 directory_ownership: DirectoryOwnership::Owned,\n                 warn: false,\n             }),\n-            (false, false) => Err(ModulePathError {\n-                err_msg: format!(\"file not found for module `{}`\", mod_name),\n-                help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n-                                  default_path_str,\n-                                  secondary_path_str,\n-                                  dir_path.display()),\n+            (false, false) => Err(Error::FileNotFoundForModule {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+                dir_path: format!(\"{}\", dir_path.display()),\n             }),\n-            (true, true) => Err(ModulePathError {\n-                err_msg: format!(\"file for module `{}` found at both {} and {}\",\n-                                 mod_name,\n-                                 default_path_str,\n-                                 secondary_path_str),\n-                help_msg: \"delete or rename one of them to remove the ambiguity\".to_owned(),\n+            (true, true) => Err(Error::DuplicatePaths {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n             }),\n         };\n \n@@ -5232,7 +5277,7 @@ impl<'a> Parser<'a> {\n                                   paths.name);\n                 err.span_note(id_sp, &msg);\n             }\n-            return Err(err);\n+            Err(err)\n         } else if let DirectoryOwnership::UnownedViaMod(warn) = self.directory.ownership {\n             if warn {\n                 if let Ok(result) = paths.result {\n@@ -5254,15 +5299,12 @@ impl<'a> Parser<'a> {\n                               &format!(\"... or maybe `use` the module `{}` instead \\\n                                         of possibly redeclaring it\",\n                                        paths.name));\n-                return Err(err);\n+                Err(err)\n             } else {\n-                return Err(err);\n-            };\n-        }\n-\n-        match paths.result {\n-            Ok(succ) => Ok(succ),\n-            Err(err) => Err(self.span_fatal_help(id_sp, &err.err_msg, &err.help_msg)),\n+                Err(err)\n+            }\n+        } else {\n+            paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n         }\n     }\n "}, {"sha": "3a5255d0f5fe318409b7ed41d93c2f231c942991", "filename": "src/test/compile-fail/E0583.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0583.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0583.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0583.rs?ref=0f34b532af590d25e9178f87c620931dd671cc2e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod module_that_doesnt_exist; //~ ERROR E0583\n+\n+fn main() {\n+}"}, {"sha": "1acaf8c0b78b6075862d0294fd34c1bb3b629cfe", "filename": "src/test/compile-fail/E0585.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0585.rs?ref=0f34b532af590d25e9178f87c620931dd671cc2e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    /// Hello! I'm useless...\n+    //~^ ERROR E0585\n+}"}, {"sha": "0b063569abc1783b07a91a62a1214c2e2b7fc5a6", "filename": "src/test/compile-fail/E0586.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f34b532af590d25e9178f87c620931dd671cc2e/src%2Ftest%2Fcompile-fail%2FE0586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0586.rs?ref=0f34b532af590d25e9178f87c620931dd671cc2e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1...]; //~ ERROR E0586\n+}"}]}