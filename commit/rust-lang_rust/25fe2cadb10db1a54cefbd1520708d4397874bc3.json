{"sha": "25fe2cadb10db1a54cefbd1520708d4397874bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZmUyY2FkYjEwZGIxYTU0Y2VmYmQxNTIwNzA4ZDQzOTc4NzRiYzM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-02-02T07:56:55Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-02-02T08:08:56Z"}, "message": "Remove rustpkg.\n\nI'm sorry :'(\n\nCloses #11859", "tree": {"sha": "28deddc8ce51ef66f428be8f123f7b53d1119b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28deddc8ce51ef66f428be8f123f7b53d1119b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25fe2cadb10db1a54cefbd1520708d4397874bc3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25fe2cadb10db1a54cefbd1520708d4397874bc3", "html_url": "https://github.com/rust-lang/rust/commit/25fe2cadb10db1a54cefbd1520708d4397874bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25fe2cadb10db1a54cefbd1520708d4397874bc3/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "html_url": "https://github.com/rust-lang/rust/commit/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b"}], "stats": {"total": 8494, "additions": 14, "deletions": 8480}, "files": [{"sha": "af21ab4fac27c2871a221db83f16ec43047e5ef7", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -370,7 +370,6 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n # libraries\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t$$(foreach dep,$$(CRATES),$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n \t$$(foreach dep,$$(HOST_CRATES),$$(HLIB$(1)_H_$(3))/stamp.$$(dep))"}, {"sha": "1d098571bae4ea8b429eb7dc40d55eef82be9ded", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -52,8 +52,8 @@ documentation.\n     > options are also supported, pass `--help` for more information on them.\n \n     When complete, `make install` will place several programs into\n-    `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-    API-documentation tool, and `rustpkg`, the Rust package manager and build\n+    `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+    API-documentation tool.\n     system.\n 3. Read the [tutorial].\n 4. Enjoy!"}, {"sha": "eccdf249156a93c6142b5c4121baf7e9ee623c6b", "filename": "doc/guide-rustpkg.md", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Fguide-rustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Fguide-rustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-rustpkg.md?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,270 +0,0 @@\n-% The Rust Packaging Guide\n-\n-# Introduction\n-\n-Sharing is caring. Rust comes with a tool, `rustpkg`, which allows you to\n-package up your Rust code and share it with other people. This guide will\n-get you started on all of the concepts and commands you need to give the gift\n-of Rust code to someone else.\n-\n-# Installing External Packages\n-\n-First, let's try to use an external package somehow. I've made a sample package\n-called `hello` to demonstrate how to do so.  Here's how `hello` is used:\n-\n-~~~~\n-extern mod hello;\n-\n-fn main() {\n-    hello::world();\n-}\n-~~~~\n-\n-Easy! But if you try to compile this, you'll get an error:\n-\n-~~~~ {.notrust}\n-$ rustc main.rs \n-main.rs:1:0: 1:17 error: can't find crate for `hello`\n-main.rs:1 extern mod hello;\n-          ^~~~~~~~~~~~~~~~~\n-~~~~\n-\n-This makes sense, as we haven't gotten it from anywhere yet!  Luckily for us,\n-`rustpkg` has an easy way to fetch others' code: the `install` command. It's\n-used like this:\n-\n-~~~ {.notrust}\n-$ rustpkg install PKG_ID\n-~~~\n-\n-This will install a package named `PKG_ID` into your current Rust environment.\n-I called it `PKG_ID` in this example because `rustpkg` calls this a 'package\n-identifier.' When using it with an external package like this, it's often a\n-URI fragment.  You see, Rust has no central authority for packages. You can\n-build your own `hello` library if you want, and that's fine. We'd both host\n-them in different places and different projects would rely on whichever version\n-they preferred.\n-\n-To install the `hello` library, simply run this in your terminal:\n-\n-~~~ {.notrust}\n-$ rustpkg install github.com/steveklabnik/hello\n-~~~\n-\n-You should see a message that looks like this:\n-\n-~~~ {.notrust}\n-note: Installed package github.com/steveklabnik/hello-0.1 to /some/path/.rust\n-~~~\n-\n-Now, compiling our example should work:\n-\n-~~~ {.notrust}\n-$ rustc main.rs\n-$ ./main \n-Hello, world.\n-~~~\n-\n-Simple! That's all it takes.\n-\n-# Workspaces\n-\n-Before we can talk about how to make packages of your own, you have to\n-understand the big concept with `rustpkg`: workspaces. A 'workspace' is simply\n-a directory that has certain sub-directories that `rustpkg` expects. Different\n-Rust projects will go into different workspaces.\n-\n-A workspace consists of any directory that has the following\n-directories:\n-\n-* `src`: The directory where all the source code goes.\n-* `build`: This directory contains all of the build output.\n-* `lib`: The directory where any libraries distributed with the package go.\n-* `bin`: This directory holds any binaries distributed with the package.\n-\n-There are also default file names you'll want to follow as well:\n-\n-* `main.rs`: A file that's going to become an executable.\n-* `lib.rs`: A file that's going to become a library.\n-\n-# Building your own Package\n-\n-Now that you've got workspaces down, let's build your own copy of `hello`. Go\n-to wherever you keep your personal projects, and let's make all of the\n-directories we'll need. I'll refer to this personal project directory as\n-`~/src` for the rest of this guide.\n-\n-## Creating our workspace\n-\n-~~~ {.notrust}\n-$ cd ~/src\n-$ mkdir -p hello/src/hello\n-$ cd hello\n-~~~\n-\n-Easy enough! Let's do one or two more things that are nice to do:\n-\n-~~~ {.notrust}\n-$ git init .\n-$ cat > README.md\n-# hello\n-\n-A simple package for Rust.\n-\n-## Installation\n-\n-```\n-$ rustpkg install github.com/YOUR_USERNAME/hello\n-```\n-^D\n-$ cat > .gitignore\n-.rust\n-build\n-^D\n-$ git commit -am \"Initial commit.\"\n-~~~\n-\n-If you're not familliar with the `cat >` idiom, it will make files with the\n-text you type inside. Control-D (`^D`) ends the text for the file.\n-\n-Anyway, we've got a README and a `.gitignore`. Let's talk about that\n-`.gitignore` for a minute: we are ignoring two directories, `build` and\n-`.rust`. `build`, as we discussed earlier, is for build artifacts, and we don't\n-want to check those into a repository. `.rust` is a directory that `rustpkg`\n-uses to keep track of its own settings, as well as the source code of any other\n-external packages that this workspace uses. This is where that `rustpkg\n-install` puts all of its files. Those are also not to go into our repository,\n-so we ignore it all as well.\n-\n-Next, let's add a source file:\n-\n-~~~\n-#[desc = \"A hello world Rust package.\"];\n-#[license = \"MIT\"];\n-\n-pub fn world() {\n-    println!(\"Hello, world.\");\n-}\n-~~~\n-\n-Put this into `src/hello/lib.rs`. Let's talk about each of these attributes:\n-\n-## Crate attributes for packages\n-\n-`license` is equally simple: the license we want this code to have. I chose MIT\n-here, but you should pick whatever license makes the most sense for you.\n-\n-`desc` is a description of the package and what it does. This should just be a\n-sentence or two.\n-\n-## Building your package\n-\n-Building your package is simple:\n-\n-~~~ {.notrust}\n-$ rustpkg build hello\n-~~~\n-\n-This will compile `src/hello/lib.rs` into a library. After this process\n-completes, you'll want to check out `build`:\n-\n-~~~ {.notrust}\n-$ ls build/x86_64-unknown-linux-gnu/hello/\n-libhello-ed8619dad9ce7d58-0.1.0.so\n-~~~\n-\n-This directory naming structure is called a 'build triple,' and is because I'm\n-on 64 bit Linux. Yours may differ based on platform.\n-\n-You'll also notice that `src/hello/lib.rs` turned into\n-`libhello-ed8619dad9ce7d58-0.1.0.so`. This is a simple combination of the\n-library name, a hash of its content, and the version.\n-\n-Now that your library builds, you'll want to commit:\n-\n-~~~ {.notrust}\n-$ git add src\n-$ git commit -m \"Adding source code.\"\n-~~~\n-\n-If you're using GitHub, after creating the project, do this:\n-\n-~~~ {.notrust}\n-$ git remote add origin git@github.com:YOUR_USERNAME/hello.git\n-$ git push origin -u master\n-~~~\n-\n-Now you can install and use it! Go anywhere else in your filesystem:\n-\n-~~~ {.notrust}\n-$ cd ~/src/foo\n-$ rustpkg install github.com/YOUR_USERNAME/hello\n-WARNING: The Rust package manager is experimental and may be unstable\n-note: Installed package github.com/YOUR_USERNAME/hello-0.1 to /home/yourusername/src/hello/.rust\n-~~~\n-\n-That's it!\n-\n-# Testing your Package\n-\n-Testing your package is simple as well. First, let's change `src/hello/lib.rs` to contain\n-a function that can be sensibly tested:\n-\n-~~~\n-#[desc = \"A Rust package for determining whether unsigned integers are even.\"];\n-#[license = \"MIT\"];\n-\n-pub fn is_even(i: uint) -> bool {\n-    i % 2 == 0\n-}\n-~~~\n-\n-Once you've edited `lib.rs`, you can create a second crate file, `src/hello/test.rs`,\n-to put tests in:\n-\n-~~~\n-#[license = \"MIT\"];\n-extern mod hello;\n-use hello::is_even;\n-\n-#[test]\n-fn test_is_even() {\n-    assert!(is_even(0));\n-    assert!(!is_even(1));\n-    assert!(is_even(2));\n-}\n-~~~\n-\n-Note that you have to import the crate you just created in `lib.rs` with the\n-`extern mod hello` directive. That's because you're putting the tests in a different\n-crate from the main library that you created.\n-\n-Now, you can use the `rustpkg test` command to build this test crate (and anything else\n-it depends on) and run the tests, all in one step:\n-\n-~~~ {.notrust}\n-$ rustpkg test hello\n-WARNING: The Rust package manager is experimental and may be unstable\n-note: Installed package hello-0.1 to /Users/tjc/.rust\n-\n-running 1 test\n-test test_is_even ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-~~~\n-\n-# More resources\n-\n-There's a lot more going on with `rustpkg`, this is just to get you started.\n-Check out [the rustpkg manual](rustpkg.html) for the full details on how to\n-customize `rustpkg`.\n-\n-A tag was created on GitHub specifically for `rustpkg`-related issues. You can\n-[see all the Issues for rustpkg\n-here](https://github.com/mozilla/rust/issues?direction=desc&labels=A-pkg&sort=created&state=open),\n-with bugs as well as new feature plans. `rustpkg` is still under development,\n-and so may be a bit flaky at the moment.\n-\n-You may also want to check out [this blog\n-post](http://tim.dreamwidth.org/1820526.html), which contains some of the early\n-design decisions and justifications."}, {"sha": "04ac982d420c2114bd50be3ca43b25f29d387a20", "filename": "doc/po/ja/guide-rustpkg.md.po", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,112 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2014 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2014.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.10-pre\\n\"\n-\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n-\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n-#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n-#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-msgid \"# Introduction\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:2\n-#, fuzzy\n-#| msgid \"% The Rust Language Tutorial\"\n-msgid \"% The Rust Packaging Guide\"\n-msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:11\n-#, fuzzy\n-#| msgid \"## Using other crates\"\n-msgid \"# Installing External Packages\"\n-msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:22\n-#, fuzzy, no-wrap\n-#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    hello::world();\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\"~~~~ {.ignore}\\n\"\n-\"// main.rs\\n\"\n-\"extern mod world;\\n\"\n-\"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n-\"~~~~\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:91\n-#, fuzzy\n-#| msgid \"## Using other crates\"\n-msgid \"# Building your own Package\"\n-msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:98\n-#, fuzzy\n-#| msgid \"## Using other crates\"\n-msgid \"## Creating our workspace\"\n-msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:115\n-#, fuzzy\n-#| msgid \"# Introduction\"\n-msgid \"## Installation\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:149\n-#, fuzzy, no-wrap\n-#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n-msgid \"\"\n-\"pub fn world() {\\n\"\n-\"    println!(\\\"Hello, world.\\\");\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\"~~~~ {.ignore}\\n\"\n-\"// main.rs\\n\"\n-\"extern mod world;\\n\"\n-\"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n-\"~~~~\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:161\n-#, fuzzy\n-#| msgid \"## Using other crates\"\n-msgid \"## Building your package\"\n-msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:209\n-#, fuzzy\n-#| msgid \"## Using other crates\"\n-msgid \"# Testing your Package\"\n-msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n-\n-#. type: Plain text\n-#: doc/guide-rustpkg.md:257\n-#, fuzzy\n-#| msgid \"## Managed boxes\"\n-msgid \"# More resources\"\n-msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30dc\u30c3\u30af\u30b9\""}, {"sha": "1ca75fa5bef10cc419bfdd72347ae84c1919a37a", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -791,7 +791,7 @@ extern mod extra; // equivalent to: extern mod extra = \"extra\";\n \n extern mod rustextra = \"extra\"; // linking to 'extra' under another name\n \n-extern mod foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for rustpkg\n+extern mod foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for external tools\n ~~~~\n \n ##### Use declarations"}, {"sha": "f36cbe7153cfe86121aca3c29e6433fb9316fb22", "filename": "doc/rustpkg.md", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,164 +0,0 @@\n-% Rustpkg Reference Manual\n-\n-# Introduction\n-\n-This document is the reference manual for the Rustpkg packaging and build tool for the Rust programming language.\n-\n-## Disclaimer\n-\n-Rustpkg is a work in progress, as is this reference manual.\n-If the actual behavior of rustpkg differs from the behavior described in this reference,\n-that reflects either an incompleteness or a bug in rustpkg.\n-\n-# Package searching\n-\n-rustpkg searches for packages using the `RUST_PATH` environment variable,\n-which is a colon-separated list (semicolon-separated on Windows) of directories.\n-\n-Each directory in this list is a *workspace* for rustpkg.\n-\n-`RUST_PATH` implicitly contains an entry for `./.rust` (as well as\n-`../.rust`, `../../.rust`,\n-and so on for every parent of `.` up to the filesystem root).\n-That means that if `RUST_PATH` is not set,\n-then rustpkg will still search for workspaces in `./.rust` and so on.\n-`RUST_PATH` also implicitly contains an entry for the system path:\n-`/usr/local` or the equivalent on Windows.\n-This entry comes after the implicit entries for `./.rust` and so on.\n-Finally, the last implicit entry in `RUST_PATH` is `~/.rust`\n-or the equivalent on Windows.\n-\n-Each workspace may contain one or more packages.\n-\n-When building code that contains one or more directives of the form `extern mod P`,\n-rustpkg automatically searches for packages named `P` in the `RUST_PATH` (as described above).\n-It builds those dependencies if necessary.\n-Thus, when using rustpkg,\n-there is no need for `-L` flags to tell the linker where to find libraries for external crates.\n-\n-# Package structure\n-\n-A valid workspace must contain each of the following subdirectories:\n-\n-* 'src/': contains one subdirectory per package. Each subdirectory contains source files for a given package.\n-\n-     For example, if `foo` is a workspace containing the package `bar`,\n-     then `foo/src/bar/main.rs` could be the `main` entry point for\n-     building a `bar` executable.\n-* 'lib/': `rustpkg install` installs libraries into a target-specific subdirectory of this directory.\n-\n-     For example, on a 64-bit machine running Mac OS X,\n-     if `foo` is a workspace containing the package `bar`,\n-     rustpkg will install libraries for bar to `foo/lib/x86_64-apple-darwin/`.\n-     The libraries will have names of the form `foo/lib/x86_64-apple-darwin/libbar-[hash].dylib`,\n-     where [hash] is a hash of the package ID.\n-* 'bin/': `rustpkg install` installs executable binaries into this directory.\n-\n-     For example, rustpkg will install executables for `bar` to\n-     `foo/bin`.\n-     The executables will have names of the form `foo/bin/bar`.\n-* 'build/': `rustpkg build` stores temporary build artifacts in a target-specific subdirectory of this directory.\n-\n-     For example, on a 64-bit machine running Mac OS X,\n-     if `foo` is a workspace containing the package `bar` and `foo/src/bar/main.rs` exists,\n-     then `rustpkg build` will create `foo/build/x86_64-apple-darwin/bar/main.o`.\n-\n-# Package identifiers\n-\n-A package identifier identifies a package uniquely.\n-A package can be stored in a workspace on the local file system,\n-or on a remote Web server, in which case the package ID resembles a URL.\n-For example, `github.com/mozilla/rust` is a package ID\n-that would refer to the git repository browsable at `http://github.com/mozilla/rust`.\n-A package ID can also specify a version, like:\n-`github.com/mozilla/rust#0.3`.\n-In this case, `rustpkg` will check that the repository `github.com/mozilla/rust` has a tag named `0.3`,\n-and report an error otherwise.\n-A package ID can also specify a particular revision of a repository, like:\n-`github.com/mozilla/rust#release-0.7`.\n-When the refspec (portion of the package ID after the `#`) can't be parsed as a decimal number,\n-rustpkg passes the refspec along to the version control system without interpreting it.\n-rustpkg also interprets any dependencies on such a package ID literally\n-(as opposed to versions, where a newer version satisfies a dependency on an older version).\n-Thus, `github.com/mozilla/rust#5c4cd30f80` is also a valid package ID,\n-since git can deduce that 5c4cd30f80 refers to a revision of the desired repository.\n-\n-A package identifier can name a subdirectory of another package.\n-For example, if `foo` is a workspace, and `foo/src/bar/lib.rs` exists,\n-as well as `foo/src/bar/extras/baz/lib.rs`,\n-then both `bar` and `bar/extras/baz` are valid package identifiers\n-in the workspace `foo`.\n-\n-Because rustpkg uses generic source file names as the main inputs, you will\n-need to specify the package identifier in them using the `crate_id` attribute\n-on the crate.\n-\n-## Source files\n-\n-rustpkg searches for four different fixed filenames in order to determine the crates to build:\n-\n-* `main.rs`: Assumed to be a main entry point for building an executable.\n-* `lib.rs`: Assumed to be a library crate.\n-* `test.rs`: Assumed to contain tests declared with the `#[test]` attribute.\n-* `bench.rs`: Assumed to contain benchmarks declared with the `#[bench]` attribute.\n-\n-## Versions\n-\n-`rustpkg` packages do not need to declare their versions with an attribute inside one of the source files,\n-because `rustpkg` infers it from the version control system.\n-When building a package that is in a `git` repository,\n-`rustpkg` assumes that the most recent tag specifies the current version.\n-When building a package that is not under version control,\n-or that has no tags, `rustpkg` assumes the intended version is 0.1.\n-\n-> **Note:** A future version of rustpkg will support semantic versions.\n-\n-# Dependencies\n-\n-rustpkg infers dependencies from `extern mod` directives.\n-Thus, there should be no need to pass a `-L` flag to rustpkg to tell it where to find a library.\n-(In the future, it will also be possible to write an `extern mod` directive referring to a remote package.)\n-\n-# Custom build scripts\n-\n-A file called `pkg.rs` at the root level in a package directory is called a *package script*.\n-If a package script exists, rustpkg executes it to build the package\n-rather than inferring crates as described previously.\n-\n-Inside `pkg.rs`, it's possible to call back into rustpkg to finish up the build.\n-`rustpkg::api` contains functions to build, install, or clean libraries and executables\n-in the way rustpkg normally would without custom build logic.\n-\n-# Command reference\n-\n-## build\n-\n-`rustpkg build foo` searches for a package with ID `foo`\n-and builds it in any workspace(s) where it finds one.\n-Supposing such packages are found in workspaces X, Y, and Z,\n-the command leaves behind files in `X`'s, `Y`'s, and `Z`'s `build` directories,\n-but not in their `lib` or `bin` directories.\n-(The exception is when rustpkg fetches a package `foo`'s sources from a remote repository.\n-In that case, it stores both the sources *and* the build artifacts for `foo`\n-in the workspace that `foo` will install to (see ##install below)).\n-\n-## clean\n-\n-`rustpkg clean foo` deletes the contents of `foo`'s `build` directory.\n-\n-## install\n-\n-`rustpkg install foo` builds the libraries and/or executables that are targets for `foo`.\n-If `RUST_PATH` is declared as an environment variable, then rustpkg installs the\n-libraries and executables into the `lib` and `bin` subdirectories\n-of the first entry in `RUST_PATH`.\n-Otherwise, if the current working directory CWD is a workspace,\n-it installs them into CWD's `lib` and `bin` subdirectories.\n-Otherwise, if the current working directory is CWD,\n-it installs them into the .rust/lib and .rust/bin subdirectories of CWD\n-(creating them if necessary). \n-\n-## test\n-\n-`rustpkg test foo` builds `foo`'s `test.rs` file if necessary,\n-then runs the resulting test executable."}, {"sha": "29446f23e1d935e20f382c780674465e15f7806e", "filename": "doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -117,8 +117,8 @@ can be adjusted by passing a `--prefix` argument to\n for more information on them.\n \n When complete, `make install` will place several programs into\n-`/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool; and `rustpkg`, the Rust package manager.\n+`/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+API-documentation tool.\n \n [tarball]: http://static.rust-lang.org/dist/rust-0.9.tar.gz\n [win-exe]: http://static.rust-lang.org/dist/rust-0.9-install.exe\n@@ -3087,15 +3087,6 @@ they model most closely what people expect to shadow.\n If you use `extern mod`, per default `rustc` will look for libraries in the library search path (which you can\n extend with the `-L` switch).\n \n-However, Rust also ships with rustpkg, a package manager that is able to automatically download and build\n-libraries if you use it for building your crate. How it works is explained [here][rustpkg],\n-but for this tutorial it's only important to know that you can optionally annotate an\n-`extern mod` statement with a package id that rustpkg can use to identify it:\n-\n-~~~ {.ignore}\n-extern mod rust = \"github.com/mozilla/rust\"; // pretend Rust is a simple library\n-~~~\n-\n ## Crate metadata and settings\n \n For every crate you can define a number of metadata items, such as link name, version or author.\n@@ -3146,11 +3137,6 @@ or setting the crate type (library or executable) explicitly:\n # fn farm() {}\n ~~~~\n \n-> ***Note:*** The rules regarding package IDs, both as attributes and as used\n-              in `extern mod`, as well as their interaction with `rustpkg` are\n-              currently not clearly defined and will likely change in the\n-              future.\n-\n ## A minimal example\n \n Now for something that you can actually compile yourself.\n@@ -3253,7 +3239,8 @@ library.  You can use them by linking to `extra` with an `extern mod extra;`.\n [extra library]: extra/index.html\n \n Right now `extra` contains those definitions directly, but in the future it will likely just\n-re-export a bunch of 'officially blessed' crates that get managed with `rustpkg`.\n+re-export a bunch of 'officially blessed' crates that get managed with a\n+package manager.\n \n # What next?\n \n@@ -3267,7 +3254,6 @@ guides on individual topics.\n * [The foreign function interface][ffi]\n * [Containers and iterators][container]\n * [Error-handling and Conditions][conditions]\n-* [Packaging up Rust code][rustpkg]\n * [Documenting Rust code][rustdoc]\n * [Testing Rust code][testing]\n * [The Rust Runtime][runtime]\n@@ -3281,7 +3267,6 @@ There is further documentation on the [wiki], however those tend to be even more\n [ffi]: guide-ffi.html\n [container]: guide-container.html\n [conditions]: guide-conditions.html\n-[rustpkg]: guide-rustpkg.html\n [testing]: guide-testing.html\n [runtime]: guide-runtime.html\n [rustdoc]: rustdoc.html"}, {"sha": "885ec37f37486cbeabe5e4b2cb5b1be7bf1c30d5", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -130,7 +130,7 @@ To build an executable with debug info (experimental):\n \n .SH \"SEE ALSO\"\n \n-rustdoc, rustpkg\n+rustdoc\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "80f992085c05a0e7026363bb7300b71e651107e9", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -84,7 +84,7 @@ The generated HTML can be viewed with any standard web browser.\n \n .SH \"SEE ALSO\"\n \n-rustc, rustpkg\n+rustc\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "856f90228137c03b430061d7daf4fed3e42f946a", "filename": "man/rustpkg.1", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/man%2Frustpkg.1", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/man%2Frustpkg.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustpkg.1?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,195 +0,0 @@\n-.TH RUSTPKG \"1\" \"July 2013\" \"rustpkg 0.7\" \"User Commands\"\n-.SH NAME\n-rustpkg \\- package manager for Rust applications\n-.SH SYNOPSIS\n-.B rustpkg\n-[\\fICOMMAND\\fR] [\\fIOPTIONS\\fR] \\fIINPUT\\fR\n-\n-.SH DESCRIPTION\n-\n-This tool is a package manager for applications written in the Rust language,\n-available at <\\fBhttps://www.rust-lang.org\\fR>. It provides commands to build,\n-install and test Rust programs.\n-\n-\\fBrustpkg\\fR is still a work in progress. See \\fBdoc/rustpkg.md\\fR in the Rust source distribution for future plans.\n-\n-.SH COMMANDS\n-\n-.TP\n-\\fBbuild\\fR\n-Searches for a package with the specified name and builds it in the workspace in\n-which it is found.\n-.TP\n-\\fBclean\\fR\n-Remove all generated files from the \\fIbuild\\fR directory in the target's workspace.\n-.TP\n-\\fBinstall\\fR\n-Builds the specified target, and all its dependencies, and then installs the\n-build products into the \\fIlib\\fR and \\fIbin\\fR directories of their respective\n-workspaces.\n-.TP\n-\\fBinit\\fR\n-Initializes the current working directory into a workspace.\n-\n-.SS \"BUILD COMMAND\"\n-\n-    rustpkg build \\fI[pkgname]\\fR\n-\n-The \\fBbuild\\fR command searches for a package with specified package name and\n-builds it in any workspace(s) where it finds one. Any dependent packages are\n-also built. The output files produced by the build phase are stored in the\n-\\fIbuild\\fR subdirectories of each package. The executables and libraries are\n-not copied to the 'bin' or 'lib' directories; that is the purpose of the\n-\\fBinstall\\fR command.\n-\n-.SS \"CLEAN COMMAND\"\n-\n-    rustpkg clean \\fI[pkgname]\\fR\n-\n-deletes the contents of package's build directory.\n-\n-.SS \"INSTALL COMMAND\"\n-\n-    rustpkg install \\fI[url]\\fR\n-\n-builds the libraries and/or executables that are targets for the specified\n-package name or URL, and then installs them either into package's \\fIlib\\fR\n-and \\fIbin\\fR directories, or into the \\fIlib\\fR and \\fIbin\\fR subdirectories\n-of the first entry in RUST_PATH.\n-\n-Examples:\n-\n-    $ rustpkg install github.com/mozilla/servo.git#1.2\n-    $ rustpkg install rust-glfw\n-\n-.SS \"INIT COMMAND\"\n-\n-    rustpkg init\n-\n-This will turn the current working directory into a workspace. The first\n-command you run when starting off a new project. \n-\n-Example:\n-\n-    $ rustpkg init\n-\n-.SH \"ENVIRONMENT\"\n-\n-.TP\n-RUST_PATH\n-A colon-separated (semicolon-separated) list of paths denoting workspaces\n-to search for Rust source files. See the section \\fBPATHS\\fR for full details.\n-\n-.SH \"PATHS\"\n-\n-The \\fBrustpkg\\fR tool searches for packages in the folders specified by the\n-\\fBRUST_PATH\\fR environment variable. Each folder constitutes a\n-\\fIworkspace\\fR, which contains one or more modules available to import.\n-\n-In addition to the RUST_PATH settings, the following implicit paths are\n-\\fIalways\\fR searched, in the following order:\n-\n-1. Any folders named \".rust\" in the current directory, \\fIand every parent\\fR\n-of the curent directory, up to the filesystem root;\n-\n-2. The system path \"/usr/local\" on Unix-style systems, or the equivalent on\n-Windows; and\n-\n-3. A folder named \".rust\" in the user's home directory (ie. \"~/.rust\" on Unix-\n-style systems or the equivalent on Windows).\n-\n-.SH \"PACKAGE STRUCTURE\"\n-\n-A valid workspace must contain each of the following subdirectories:\n-\n-.TP\n-\\fBsrc/\\fR\n-Contains the Rust source code, with one subdirectory per package. Each\n-subdirectory contains source files for a given package.\n-.TP\n-\\fBlib/\\fR\n-\"rustpkg install\" installs libraries into a target-specific subdirectory of this directory.\n-.TP\n-\\fBbin/\\fR\n-\"rustpkg install\" installs executable binaries into a target-specific subdirectory of this directory.\n-.TP\n-\\fBbuild/\\fR\n-\"rustpkg build\" stores temporary build artifacts in a target-specific subdirectory of this directory.\n-\n-For example, if \"foo\" is a workspace containing the package \"bar\", then\n-\"foo/src/bar/main.rs\" would be the \"main\" entry point for building a \"bar\"\n-executable.\n-\n-.SH \"PACKAGE IDENTIFIERS\"\n-\n-A package identifier uniquely identifies a package. A package can be stored in\n-a workspace on the local file system, or on a remote Web server, in which case\n-the package ID resembles a URL.\n-\n-For example, \\fIgithub.com/mozilla/rust\\fR is a package ID\n-that would refer to the git repository browsable at \\fIhttp://github.com/mozilla/rust\\fR.\n-\n-A package ID can also specify a version, like:\n-\\fIgithub.com/mozilla/rust#0.3\\fR. In this case, \\fBrustpkg\\fR will check that\n-the repository \\fIgithub.com/mozilla/rust\\fR has a tag named \\fI0.3\\fR, and\n-report an error otherwise.\n-\n-.SH \"SPECIAL MODULES\"\n-\n-\\fBrustpkg\\fR searches for four different known filenames in the src directory\n-in order to determine which crates to build:\n-\n-.TP\n-\\fBmain.rs\\fR\n-Assumed to be a main entry point for building an executable (install destination is 'bin' directory).\n-.TP\n-\\fBlib.rs\\fR\n-Assumed to be a library crate (install destination is 'lib' directory).\n-.TP\n-\\fBtest.rs\\fR\n-Assumed to contain tests declared with the \\fI#[test]\\fR attribute.\n-.TP\n-\\fBbench.rs\\fR\n-Assumed to contain benchmarks declared with the \\fI#[bench]\\fR attribute.\n-\n-.SH \"CRATE VERSIONS\"\n-\n-\\fBrustpkg\\fR packages do not need to declare their versions with an attribute\n-inside one of the source files, because rustpkg infers it from the version\n-control system. When building a package that is in a git repository,\n-rustpkg assumes that the most recent tag specifies the current version. When\n-building a package that is not under version control, or that has no tags,\n-rustpkg defaults the version to 0.1.\n-\n-.SH \"DEPENDENCIES\"\n-\n-rustpkg infers dependencies from \"extern mod\" directives. Thus, there should\n-be no need to pass a \"-L\" flag to rustpkg to tell it where to find a library.\n-(In the future, it will also be possible to write an \"extern mod\" directive\n-referring to a remote package.)\n-\n-.SH \"CUSTOM BUILD SCRIPTS\"\n-\n-A file called \\fIpkg.rs\\fR at the root level in a workspace is called a \\fIpackage\n-script\\fR. If a package script exists, rustpkg executes it to build the\n-package rather than inferring crates as described previously.\n-\n-Inside \\fIpkg.rs\\fR, it's possible to call back into rustpkg to finish up the\n-build. The \\fIrustpkg::api\\fR module contains functions to build, install, or\n-clean libraries and executables in the way rustpkg normally would without\n-custom build logic.\n-\n-.SH \"SEE ALSO\"\n-\n-rustc, rustdoc\n-\n-.SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n-\n-.SH \"AUTHOR\"\n-See \\fBAUTHORS.txt\\fR in the Rust source distribution. Graydon Hoare\n-<\\fIgraydon@mozilla.com\\fR> is the project leader.\n-\n-.SH \"COPYRIGHT\"\n-This work is dual-licensed under Apache 2.0 and MIT terms.  See \\fBCOPYRIGHT\\fR\n-file in the rust source distribution."}, {"sha": "7ac3c3b486b11138d8e2cf72d79f4c7b6c6d22b2", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -50,9 +50,9 @@\n ################################################################################\n \n TARGET_CRATES := std extra green rustuv native flate arena glob\n-HOST_CRATES := syntax rustc rustdoc rustpkg\n+HOST_CRATES := syntax rustc rustdoc\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n-TOOLS := compiletest rustpkg rustdoc rustc\n+TOOLS := compiletest rustdoc rustc\n \n DEPS_std := native:rustrt\n DEPS_extra := std\n@@ -62,17 +62,14 @@ DEPS_native := std\n DEPS_syntax := std extra\n DEPS_rustc := syntax native:rustllvm flate arena\n DEPS_rustdoc := rustc native:sundown\n-DEPS_rustpkg := rustc\n DEPS_flate := std native:miniz\n DEPS_arena := std extra\n DEPS_glob := std\n \n TOOL_DEPS_compiletest := extra green rustuv\n-TOOL_DEPS_rustpkg := rustpkg green rustuv\n TOOL_DEPS_rustdoc := rustdoc green rustuv\n TOOL_DEPS_rustc := rustc green rustuv\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n-TOOL_SOURCE_rustpkg := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n "}, {"sha": "656811bab4d0f2520aa08dba98e0797b8534ea75", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -28,7 +28,6 @@ PKG_FILES := \\\n     $(addprefix $(S)src/,                      \\\n       README.txt                               \\\n       driver                                   \\\n-      librustpkg                               \\\n       librustc                                 \\\n       compiletest                              \\\n       etc                                      \\"}, {"sha": "4130edba6162c9df25fcf9c2e126d61e32d5e72f", "filename": "mk/docs.mk", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -89,12 +89,6 @@ doc/rust.epub: rust.md\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(EPUB_OPTS) --output=$@\n \n-DOCS += doc/rustpkg.html\n-doc/rustpkg.html: rustpkg.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n DOCS += doc/rustdoc.html\n doc/rustdoc.html: rustdoc.md $(HTML_DEPS)\n \t@$(call E, pandoc: $@)\n@@ -212,12 +206,6 @@ doc/guide-conditions.html: $(S)doc/guide-conditions.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n-DOCS += doc/guide-rustpkg.html\n-doc/guide-rustpkg.html: $(S)doc/guide-rustpkg.md $(HTML_DEPS)\n-\t@$(call E, pandoc: $@)\n-\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n-\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n-\n DOCS += doc/guide-pointers.html\n doc/guide-pointers.html: $(S)doc/guide-pointers.md $(HTML_DEPS)\n \t@$(call E, pandoc: $@)"}, {"sha": "6d151cfc86abab5bb909fe537cf0888cd8e47a9b", "filename": "mk/tests.mk", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -185,7 +185,6 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n \tcheck-stage2-rustuv check-stage2-native check-stage2-green \\\n-\tcheck-stage2-rustpkg \\\n \tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n@@ -423,18 +422,6 @@ $(foreach host,$(CFG_HOST), \\\n       $(eval $(call DEF_TEST_CRATE_RULES,$(stage),$(target),$(host),$(crate))) \\\n      ))))))\n \n-# FIXME (#10104): Raise the stack size to work around rustpkg bypassing\n-# the code in rustc that would take care of it.\n-define DEF_RUSTPKG_STACK_FIX\n-$$(call TEST_OK_FILE,$(1),$(2),$(3),rustpkg): export RUST_MIN_STACK=8000000\n-endef\n-\n-$(foreach host,$(CFG_HOST), \\\n- $(foreach target,$(CFG_TARGET), \\\n-  $(foreach stage,$(STAGES), \\\n-   $(eval $(call DEF_RUSTPKG_STACK_FIX,$(stage),$(target),$(host))))))\n-\n-\n ######################################################################\n # Rules for the compiletest tests (rpass, rfail, etc.)\n ######################################################################"}, {"sha": "cc67a3717faada0656d580fe6152057620b170cb", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -30,7 +30,6 @@ Source layout:\n | `test/auxiliary`    | - Dependencies of tests                                   |\n | ------------------- | --------------------------------------------------------- |\n | `librustdoc/`       | The Rust API documentation tool                           |\n-| `librustpkg/`       | The package manager and build system                      |\n | `libuv/`            | The libuv submodule                                       |\n | ------------------- | --------------------------------------------------------- |\n | `llvm/`             | The LLVM submodule                                        |"}, {"sha": "25095950e1849cda522e3dd3343578517ea3663a", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(rustpkg)]\n-extern mod this = \"rustpkg\";\n-\n #[cfg(rustdoc)]\n extern mod this = \"rustdoc\";\n "}, {"sha": "4ef97e9234a9e8ec0148655177a353d42135f75a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fe2cadb10db1a54cefbd1520708d4397874bc3/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=25fe2cadb10db1a54cefbd1520708d4397874bc3", "patch": "@@ -150,8 +150,9 @@ pub struct Options {\n     lint_opts: ~[(lint::Lint, lint::level)],\n     save_temps: bool,\n     output_type: back::link::OutputType,\n-    // This is mutable for rustpkg, which updates search paths based on the\n-    // parsed code.\n+    // This was mutable for rustpkg, which updates search paths based on the\n+    // parsed code. It remains mutable in case its replacements wants to use\n+    // this.\n     addl_lib_search_paths: @RefCell<HashSet<Path>>,\n     ar: Option<~str>,\n     linker: Option<~str>,"}, {"sha": "acfbf395e4bcd95267cbab932609de5a2c3de017", "filename": "src/librustpkg/README.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2FREADME.txt?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,24 +0,0 @@\n-Right now, commands that work are \"build\" and \"clean\".\n-\n-`rustpkg build` and `rustpkg clean` should work\n-\n-for example:\n-$ cd ~/rust/src/librustpkg/testsuite/pass\n-$ rustpkg build hello-world\n-... some output ...\n-$ rustpkg clean hello-world\n-\n--------------\n-the following test packages in librustpkg/testsuite/pass:\n-      * hello-world\n-      * install-paths\n-      * simple-lib\n-      * deeply/nested/path\n-      * fancy-lib\n-\n-   It fails on the following test packages:\n-      * external-crate (no support for `extern mod` inference yet)\n-\n-and should fail with proper error messages\n-on all of the test packages in librustpkg/testsuite/fail\n-      * no-inferred-crates"}, {"sha": "13d5a1177049b720a68c881ce92022366096f2ef", "filename": "src/librustpkg/api.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use CtxMethods;\n-use context::*;\n-use crate::*;\n-use package_source::*;\n-use path_util::{platform_library_name, target_build_dir};\n-use target::*;\n-use workspace::pkg_parent_workspaces;\n-use workcache_support::*;\n-pub use path_util::default_workspace;\n-\n-pub use source_control::{safe_git_clone, git_clone_url};\n-\n-use std::run;\n-use extra::arc::{Arc,RWArc};\n-use extra::workcache;\n-use extra::workcache::{Database, FreshnessMap};\n-use extra::treemap::TreeMap;\n-use syntax::crateid::CrateId;\n-\n-// A little sad -- duplicated from rustc::back::*\n-#[cfg(target_arch = \"arm\")]\n-fn cc_args() -> ~[~str] { ~[~\"-marm\"] }\n-#[cfg(target_arch = \"mips\")]\n-fn cc_args() -> ~[~str] { ~[] }\n-#[cfg(target_arch = \"x86\")]\n-fn cc_args() -> ~[~str] { ~[~\"-m32\"] }\n-#[cfg(target_arch = \"x86_64\")]\n-fn cc_args() -> ~[~str] { ~[~\"-m64\"] }\n-\n-/// Convenience functions intended for calling from pkg.rs\n-/// p is where to put the cache file for dependencies\n-pub fn default_context(sysroot: Path, p: Path) -> BuildContext {\n-    new_default_context(new_workcache_context(&p), sysroot)\n-}\n-\n-pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n-    BuildContext {\n-        context: Context {\n-            cfgs: ~[],\n-            rustc_flags: RustcFlags::default(),\n-            use_rust_path_hack: false,\n-        },\n-        sysroot: p,\n-        workcache_context: c\n-    }\n-}\n-\n-fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::new(path);\n-    path.exists() && in_hash == digest_file_with_date(&path)\n-}\n-\n-fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n-    let path = Path::new(path);\n-    path.exists() && in_hash == digest_only_date(&path)\n-}\n-\n-pub fn new_workcache_context(p: &Path) -> workcache::Context {\n-    let db_file = p.join(\"rustpkg_db.json\"); // ??? probably wrong\n-    debug!(\"Workcache database file: {}\", db_file.display());\n-    let db = RWArc::new(Database::new(db_file));\n-    let cfg = Arc::new(TreeMap::new());\n-    let mut freshness: FreshnessMap = TreeMap::new();\n-    // Set up freshness functions for every type of dependency rustpkg\n-    // knows about\n-    freshness.insert(~\"file\", file_is_fresh);\n-    freshness.insert(~\"binary\", binary_is_fresh);\n-    workcache::Context::new_with_freshness(db, cfg, Arc::new(freshness))\n-}\n-\n-pub fn build_lib(sysroot: Path, root: Path, name: ~str, lib: Path) {\n-    build_lib_with_cfgs(sysroot, root, name, lib, ~[])\n-}\n-\n-pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str, lib: Path, cfgs: ~[~str]) {\n-    let cx = default_context(sysroot, root.clone());\n-    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n-    let pkg_src = PkgSrc {\n-        source_workspace: root.clone(),\n-        build_in_destination: false,\n-        destination_workspace: root.clone(),\n-        start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: crate_id,\n-        // n.b. This assumes the package only has one crate\n-        libs: ~[mk_crate(lib)],\n-        mains: ~[],\n-        tests: ~[],\n-        benchs: ~[]\n-    };\n-    pkg_src.build(&cx, cfgs, []);\n-}\n-\n-pub fn build_exe(sysroot: Path, root: Path, name: ~str, main: Path) {\n-    build_exe_with_cfgs(sysroot, root, name, main, ~[])\n-}\n-\n-pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str, main: Path, cfgs: ~[~str]) {\n-    let cx = default_context(sysroot, root.clone());\n-    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n-    let pkg_src = PkgSrc {\n-        source_workspace: root.clone(),\n-        build_in_destination: false,\n-        destination_workspace: root.clone(),\n-        start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: crate_id,\n-        libs: ~[],\n-        // n.b. This assumes the package only has one crate\n-        mains: ~[mk_crate(main)],\n-        tests: ~[],\n-        benchs: ~[]\n-    };\n-\n-    pkg_src.build(&cx, cfgs, []);\n-}\n-\n-pub fn install_pkg(cx: &BuildContext,\n-                   workspace: Path,\n-                   name: ~str,\n-                   // For now, these inputs are assumed to be inputs to each of the crates\n-                   more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n-    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crate_id),\n-               &WhatToBuild{ build_type: Inferred,\n-                             inputs_to_discover: more_inputs,\n-                             sources: Everything });\n-}\n-\n-/// Builds an arbitrary library whose short name is `output`,\n-/// by invoking `tool` with arguments `args` plus \"-o %s\", where %s\n-/// is the platform-specific library name for `output`.\n-/// Returns that platform-specific name, or None if `tool` could not be started.\n-pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n-                                  context: &mut Context,\n-                                  package_name: &str,\n-                                  tool: &str,\n-                                  flags: &[~str],\n-                                  paths: &[~str],\n-                                  output: &str) -> Option<~str> {\n-    use command_failed = conditions::command_failed::cond;\n-\n-    let workspace = my_workspace(context, package_name);\n-    let workspace_build_dir = target_build_dir(&workspace);\n-    let out_name = workspace_build_dir.join_many([package_name.to_str(),\n-                                                  platform_library_name(output)]);\n-    // make paths absolute\n-    let crateid: CrateId = from_str(package_name).expect(\"valid crate id\");\n-    let absolute_paths = paths.map(|s| {\n-            let whatever = workspace.join_many([~\"src\",\n-                                crateid.short_name_with_version(),\n-                                s.to_owned()]);\n-            whatever.as_str().unwrap().to_owned()\n-        });\n-\n-    let cc_args = cc_args();\n-\n-    let all_args = flags + absolute_paths + cc_args +\n-         ~[~\"-o\", out_name.as_str().unwrap().to_owned()];\n-    match run::process_status(tool, all_args) {\n-        Some(exit_process) => {\n-            if exit_process.success() {\n-                let out_name_str = out_name.as_str().unwrap().to_owned();\n-                exec.discover_output(\"binary\",\n-                                     out_name_str,\n-                                     digest_only_date(&out_name));\n-                context.add_library_path(out_name.dir_path());\n-                Some(out_name_str)\n-            } else {\n-                Some(command_failed.raise((tool.to_owned(), all_args, exit_process)))\n-            }\n-        },\n-        None => None\n-    }\n-}\n-\n-pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n-    use bad_pkg_id     = conditions::bad_pkg_id::cond;\n-\n-    // (this assumes no particular version is requested)\n-    let crateid = from_str(package_name).expect(\"valid crate id\");\n-    let workspaces = pkg_parent_workspaces(context, &crateid);\n-    if workspaces.is_empty() {\n-        bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n-    }\n-    workspaces[0]\n-}\n-\n-fn mk_crate(p: Path) -> Crate {\n-    Crate { file: p, flags: ~[], cfgs: ~[] }\n-}"}, {"sha": "d18161d7c4a370b1c46bf40b0e70ec8317974722", "filename": "src/librustpkg/conditions.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Useful conditions\n-\n-pub use syntax::crateid::CrateId;\n-pub use std::io::FileStat;\n-pub use std::io::process::ProcessExit;\n-pub use std::path::Path;\n-\n-condition! {\n-    pub bad_path: (Path, ~str) -> Path;\n-}\n-\n-condition! {\n-    pub nonexistent_package: (CrateId, ~str) -> Path;\n-}\n-\n-condition! {\n-    pub missing_pkg_files: (CrateId) -> ();\n-}\n-\n-condition! {\n-    pub bad_pkg_id: (Path, ~str) -> CrateId;\n-}\n-\n-condition! {\n-    pub failed_to_create_temp_dir: (~str) -> Path;\n-}\n-\n-condition! {\n-    pub git_checkout_failed: (~str, Path) -> ();\n-}\n-\n-condition! {\n-    // str is output of applying the command (first component)\n-    // to the args (second component)\n-    pub command_failed: (~str, ~[~str], ProcessExit) -> ~str;\n-}"}, {"sha": "01df2bf16193dd7584e3514fe64c36ced8c075ae", "filename": "src/librustpkg/context.rs", "status": "removed", "additions": 0, "deletions": 347, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,347 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Context data structure used by rustpkg\n-\n-use extra::workcache;\n-use rustc::driver::session;\n-use rustc::metadata::filesearch::rustlibdir;\n-\n-use std::hashmap::HashSet;\n-\n-#[deriving(Clone)]\n-pub struct Context {\n-    // Config strings that the user passed in with --cfg\n-    cfgs: ~[~str],\n-    // Flags to pass to rustc\n-    rustc_flags: RustcFlags,\n-    // If use_rust_path_hack is true, rustpkg searches for sources\n-    // in *package* directories that are in the RUST_PATH (for example,\n-    // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n-    // rustpkg stores build artifacts.\n-    use_rust_path_hack: bool,\n-}\n-\n-#[deriving(Clone)]\n-pub struct BuildContext {\n-    // Context for workcache\n-    workcache_context: workcache::Context,\n-    // Parsed command line options\n-    context: Context,\n-    // The root directory containing the Rust standard libraries\n-    sysroot: Path\n-}\n-\n-impl BuildContext {\n-    pub fn sysroot(&self) -> Path {\n-        self.sysroot.clone()\n-    }\n-\n-    // Hack so that rustpkg can run either out of a rustc target dir,\n-    // or the host dir\n-    pub fn sysroot_to_use(&self) -> Path {\n-        if !in_target(&self.sysroot) {\n-            self.sysroot.clone()\n-        } else {\n-            let mut p = self.sysroot.clone();\n-            p.pop();\n-            p.pop();\n-            p.pop();\n-            p\n-        }\n-    }\n-\n-    /// Returns the flags to pass to rustc, as a vector of strings\n-    pub fn flag_strs(&self) -> ~[~str] {\n-        self.context.flag_strs()\n-    }\n-\n-    pub fn compile_upto(&self) -> StopBefore {\n-        self.context.compile_upto()\n-    }\n-\n-    pub fn add_library_path(&mut self, p: Path) {\n-        debug!(\"Adding library path: {}\", p.display());\n-        self.context.add_library_path(p);\n-    }\n-\n-    pub fn additional_library_paths(&self) -> HashSet<Path> {\n-        self.context.rustc_flags.additional_library_paths.clone()\n-    }\n-}\n-\n-/*\n-Deliberately unsupported rustc flags:\n-   --bin, --lib           inferred from crate file names\n-   -L                     inferred from extern mods\n-   --out-dir              inferred from RUST_PATH\n-   --test                 use `rustpkg test`\n-   -v -h --ls             don't make sense with rustpkg\n-   -W -A -D -F -          use pragmas instead\n-\n-rustc flags that aren't implemented yet:\n-   --passes\n-   --llvm-arg\n-   --target-feature\n-   --android-cross-path\n-*/\n-pub struct RustcFlags {\n-    compile_upto: StopBefore,\n-    // Linker to use with the --linker flag\n-    linker: Option<~str>,\n-    // Extra arguments to pass to rustc with the --link-args flag\n-    link_args: Option<~str>,\n-    // Optimization level. 0 = default. -O = 2.\n-    optimization_level: session::OptLevel,\n-    // True if the user passed in --save-temps\n-    save_temps: bool,\n-    // Target (defaults to rustc's default target)\n-    target: Option<~str>,\n-    // Target CPU (defaults to rustc's default target CPU)\n-    target_cpu: Option<~str>,\n-    // Additional library directories, which get passed with the -L flag\n-    // This can't be set with a rustpkg flag, only from package scripts\n-    additional_library_paths: HashSet<Path>,\n-    // Any -Z features\n-    experimental_features: Option<~[~str]>\n-}\n-\n-impl Clone for RustcFlags {\n-    fn clone(&self) -> RustcFlags {\n-        RustcFlags {\n-            compile_upto: self.compile_upto,\n-            linker: self.linker.clone(),\n-            link_args: self.link_args.clone(),\n-            optimization_level: self.optimization_level,\n-            save_temps: self.save_temps,\n-            target: self.target.clone(),\n-            target_cpu: self.target_cpu.clone(),\n-            additional_library_paths: self.additional_library_paths.clone(),\n-            experimental_features: self.experimental_features.clone()\n-        }\n-    }\n-}\n-\n-#[deriving(Eq)]\n-pub enum StopBefore {\n-    Nothing,  // compile everything\n-    Link,     // --no-link\n-    LLVMCompileBitcode, // --emit-llvm without -S\n-    LLVMAssemble, // -S --emit-llvm\n-    Assemble, // -S without --emit-llvm\n-    Trans,    // --no-trans\n-    Pretty,   // --pretty\n-    Analysis, // --parse-only\n-}\n-\n-impl Context {\n-\n-    /// Returns the flags to pass to rustc, as a vector of strings\n-    pub fn flag_strs(&self) -> ~[~str] {\n-        self.rustc_flags.flag_strs()\n-    }\n-\n-    pub fn compile_upto(&self) -> StopBefore {\n-        self.rustc_flags.compile_upto\n-    }\n-\n-    pub fn add_library_path(&mut self, p: Path) {\n-        self.rustc_flags.additional_library_paths.insert(p);\n-    }\n-}\n-\n-/// We assume that if ../../rustlib exists, then we're running\n-/// rustpkg from a Rust target directory. This is part of a\n-/// kludgy hack used to adjust the sysroot.\n-pub fn in_target(sysroot: &Path) -> bool {\n-    debug!(\"Checking whether {} is in target\", sysroot.display());\n-    let mut p = sysroot.dir_path();\n-    p.pop();\n-    p.push(rustlibdir());\n-    p.is_dir()\n-}\n-\n-impl RustcFlags {\n-    fn flag_strs(&self) -> ~[~str] {\n-        let linker_flag = match self.linker {\n-            Some(ref l) => ~[~\"--linker\", l.clone()],\n-            None    => ~[]\n-        };\n-        let link_args_flag = match self.link_args {\n-            Some(ref l) => ~[~\"--link-args\", l.clone()],\n-            None        => ~[]\n-        };\n-        let save_temps_flag = if self.save_temps { ~[~\"--save-temps\"] } else { ~[] };\n-        let target_flag = match self.target {\n-            Some(ref l) => ~[~\"--target\", l.clone()],\n-            None        => ~[]\n-        };\n-        let target_cpu_flag = match self.target_cpu {\n-            Some(ref l) => ~[~\"--target-cpu\", l.clone()],\n-            None        => ~[]\n-        };\n-        let z_flags = match self.experimental_features {\n-            Some(ref ls)    => ls.flat_map(|s| ~[~\"-Z\", s.clone()]),\n-            None            => ~[]\n-        };\n-        linker_flag\n-            + link_args_flag\n-            + save_temps_flag\n-            + target_flag\n-            + target_cpu_flag\n-            + z_flags + (match self.compile_upto {\n-            LLVMCompileBitcode => ~[~\"--emit-llvm\"],\n-            LLVMAssemble => ~[~\"--emit-llvm\", ~\"-S\"],\n-            Link => ~[~\"-c\"],\n-            Trans => ~[~\"--no-trans\"],\n-            Assemble => ~[~\"-S\"],\n-            // n.b. Doesn't support all flavors of --pretty (yet)\n-            Pretty => ~[~\"--pretty\"],\n-            Analysis => ~[~\"--parse-only\"],\n-            Nothing => ~[]\n-        })\n-    }\n-\n-    pub fn default() -> RustcFlags {\n-        RustcFlags {\n-            linker: None,\n-            link_args: None,\n-            compile_upto: Nothing,\n-            optimization_level: session::Default,\n-            save_temps: false,\n-            target: None,\n-            target_cpu: None,\n-            additional_library_paths: HashSet::new(),\n-            experimental_features: None\n-        }\n-    }\n-}\n-\n-\n-#[deriving(Eq)]\n-pub enum Command {\n-    BuildCmd,\n-    CleanCmd,\n-    DoCmd,\n-    HelpCmd,\n-    InfoCmd,\n-    InitCmd,\n-    InstallCmd,\n-    ListCmd,\n-    PreferCmd,\n-    TestCmd,\n-    UninstallCmd,\n-    UnpreferCmd,\n-}\n-\n-impl FromStr for Command {\n-\n-    fn from_str(s: &str) -> Option<Command>  {\n-       match s {\n-            &\"build\" => Some(BuildCmd),\n-            &\"clean\" => Some(CleanCmd),\n-            &\"do\" => Some(DoCmd),\n-            &\"help\" => Some(HelpCmd),\n-            &\"info\" => Some(InfoCmd),\n-            &\"install\" => Some(InstallCmd),\n-            &\"list\"    => Some(ListCmd),\n-            &\"prefer\" => Some(PreferCmd),\n-            &\"test\" => Some(TestCmd),\n-            &\"init\" => Some(InitCmd),\n-            &\"uninstall\" => Some(UninstallCmd),\n-            &\"unprefer\" => Some(UnpreferCmd),\n-            _ => None\n-        }\n-    }\n-}\n-\n-/// Returns true if any of the flags given are incompatible with the cmd\n-pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n-                        cfgs: &[~str],\n-                        cmd: Command, user_supplied_opt_level: bool) -> bool {\n-    let complain = |s| {\n-        println!(\"The {} option can only be used with the `build` command:\n-                  rustpkg [options..] build {} [package-ID]\", s, s);\n-    };\n-\n-    if flags.linker.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The --linker option can only be used with the build or install commands.\");\n-        return true;\n-    }\n-    if flags.link_args.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The --link-args option can only be used with the build or install commands.\");\n-        return true;\n-    }\n-\n-    if !cfgs.is_empty() && cmd != BuildCmd && cmd != InstallCmd && cmd != TestCmd {\n-        println!(\"The --cfg option can only be used with the build, test, or install commands.\");\n-        return true;\n-    }\n-\n-    if user_supplied_opt_level && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The -O and --opt-level options can only be used with the build \\\n-                    or install commands.\");\n-        return true;\n-    }\n-\n-    if flags.save_temps  && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The --save-temps option can only be used with the build \\\n-                    or install commands.\");\n-        return true;\n-    }\n-\n-    if flags.target.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The --target option can only be used with the build \\\n-                    or install commands.\");\n-        return true;\n-    }\n-    if flags.target_cpu.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The --target-cpu option can only be used with the build \\\n-                    or install commands.\");\n-        return true;\n-    }\n-    if flags.experimental_features.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n-        println!(\"The -Z option can only be used with the build or install commands.\");\n-        return true;\n-    }\n-\n-    match flags.compile_upto {\n-        Link if cmd != BuildCmd => {\n-            complain(\"--no-link\");\n-            true\n-        }\n-        Trans if cmd != BuildCmd => {\n-            complain(\"--no-trans\");\n-            true\n-        }\n-        Assemble if cmd != BuildCmd => {\n-            complain(\"-S\");\n-            true\n-        }\n-        Pretty if cmd != BuildCmd => {\n-            complain(\"--pretty\");\n-            true\n-        }\n-        Analysis if cmd != BuildCmd => {\n-            complain(\"--parse-only\");\n-            true\n-        }\n-        LLVMCompileBitcode if cmd != BuildCmd => {\n-            complain(\"--emit-llvm\");\n-            true\n-        }\n-        LLVMAssemble if cmd != BuildCmd => {\n-            complain(\"--emit-llvm\");\n-            true\n-        }\n-        _ => false\n-    }\n-}\n-"}, {"sha": "345638386b2ad64885f0f5e5d00d6954fef32a7d", "filename": "src/librustpkg/crate.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(dead_code)];\n-\n-use std::path::Path;\n-use std::vec;\n-\n-/// A crate is a unit of Rust code to be compiled into a binary or library\n-#[deriving(Clone)]\n-pub struct Crate {\n-    file: Path,\n-    flags: ~[~str],\n-    cfgs: ~[~str]\n-}\n-\n-impl Crate {\n-\n-    pub fn new(p: &Path) -> Crate {\n-        Crate {\n-            file: (*p).clone(),\n-            flags: ~[],\n-            cfgs: ~[]\n-        }\n-    }\n-\n-    fn flag(&self, flag: ~str) -> Crate {\n-        Crate {\n-            flags: vec::append(self.flags.clone(), [flag]),\n-            .. (*self).clone()\n-        }\n-    }\n-\n-    fn flags(&self, flags: ~[~str]) -> Crate {\n-        Crate {\n-            flags: vec::append(self.flags.clone(), flags),\n-            .. (*self).clone()\n-        }\n-    }\n-\n-    fn cfg(&self, cfg: ~str) -> Crate {\n-        Crate {\n-            cfgs: vec::append(self.cfgs.clone(), [cfg]),\n-            .. (*self).clone()\n-        }\n-    }\n-\n-    fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n-        Crate {\n-            cfgs: vec::append(self.cfgs.clone(), cfgs),\n-            .. (*self).clone()\n-        }\n-    }\n-}"}, {"sha": "daa5eee62d205d29ba996685e1928f3edf612b20", "filename": "src/librustpkg/exit_codes.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fexit_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fexit_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fexit_codes.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub static COPY_FAILED_CODE: int = 65;\n-pub static BAD_FLAG_CODE: int    = 67;\n-pub static NONEXISTENT_PACKAGE_CODE: int = 68;\n-"}, {"sha": "c7900181a77d15220d585a308269755d1c0de52b", "filename": "src/librustpkg/installed_packages.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Listing installed packages\n-\n-use rustc::metadata::filesearch::rust_path;\n-use std::os;\n-use std::io;\n-use std::io::fs;\n-use syntax::crateid::CrateId;\n-\n-pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n-    let workspaces = rust_path();\n-    for p in workspaces.iter() {\n-        let binfiles = {\n-            let _guard = io::ignore_io_error();\n-            fs::readdir(&p.join(\"bin\"))\n-        };\n-        for exec in binfiles.iter() {\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            match exec.filestem_str() {\n-                None => (),\n-                Some(exec_path) => {\n-                    let crate_id = from_str(exec_path).expect(\"valid crate id\");\n-                    if !f(&crate_id) {\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-        let libfiles = {\n-            let _guard = io::ignore_io_error();\n-            fs::readdir(&p.join(\"lib\"))\n-        };\n-        for lib in libfiles.iter() {\n-            debug!(\"Full name: {}\", lib.display());\n-            match has_library(lib) {\n-                Some(basename) => {\n-                    let parent = p.join(\"lib\");\n-                    debug!(\"parent = {}, child = {}\",\n-                            parent.display(), lib.display());\n-                    let rel_p = lib.path_relative_from(&parent).unwrap();\n-                    debug!(\"Rel: {}\", rel_p.display());\n-                    let rel_path = rel_p.join(basename);\n-                    rel_path.display().with_str(|s| {\n-                        debug!(\"Rel name: {}\", s);\n-                        let crate_id = from_str(s).expect(\"valid crate id\");\n-                        f(&crate_id);\n-                    });\n-                }\n-                None => ()\n-            }\n-        };\n-    }\n-    true\n-}\n-\n-pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = {\n-        let _guard = io::ignore_io_error();\n-        fs::readdir(p)\n-    };\n-    for path in files.iter() {\n-        if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n-            let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");\n-            let mut stuff2 = stuff.split_str(\"-\");\n-            let stuff3: ~[&str] = stuff2.collect();\n-            // argh\n-            let chars_to_drop = os::consts::DLL_PREFIX.len();\n-            return Some(stuff3[0].slice(chars_to_drop, stuff3[0].len()).to_owned());\n-        }\n-    }\n-    None\n-}\n-\n-pub fn package_is_installed(p: &CrateId) -> bool {\n-    let mut is_installed = false;\n-    list_installed_packages(|installed| {\n-        if installed == p {\n-            is_installed = true;\n-            false\n-        } else {\n-            true\n-        }\n-    });\n-    is_installed\n-}"}, {"sha": "b43ffec2783cafb3d5e37613be81e0db69501fa4", "filename": "src/librustpkg/lib.rs", "status": "removed", "additions": 0, "deletions": 816, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,816 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg - a package manager and build system for Rust\n-\n-#[crate_id = \"rustpkg#0.10-pre\"];\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"dylib\"];\n-\n-#[feature(globs, managed_boxes)];\n-\n-extern mod extra;\n-extern mod rustc;\n-extern mod syntax;\n-\n-use std::{os, run, str, task};\n-use std::io::process;\n-use std::io;\n-use std::io::fs;\n-pub use std::path::Path;\n-\n-use extra::workcache;\n-use rustc::driver::{driver, session};\n-use rustc::metadata::creader::Loader;\n-use rustc::metadata::filesearch;\n-use rustc::metadata::filesearch::rust_path;\n-use rustc::util::sha2;\n-use syntax::{ast, diagnostic};\n-use syntax::crateid::CrateId;\n-use messages::{error, warn, note};\n-use parse_args::{ParseResult, parse_args};\n-use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n-use path_util::in_rust_path;\n-use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n-use path_util::{target_executable_in_workspace, target_library_in_workspace, dir_has_crate_file};\n-use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n-use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n-use workspace::determine_destination;\n-use context::{BuildContext, Trans, Nothing, Pretty, Analysis,\n-              LLVMAssemble, LLVMCompileBitcode};\n-use context::{Command, BuildCmd, CleanCmd, DoCmd, HelpCmd, InfoCmd, InstallCmd, ListCmd,\n-    PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n-use package_source::PkgSrc;\n-use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n-use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n-use workcache_support::digest_only_date;\n-use exit_codes::{COPY_FAILED_CODE};\n-\n-pub mod api;\n-mod conditions;\n-pub mod context;\n-mod crate;\n-pub mod exit_codes;\n-mod installed_packages;\n-mod messages;\n-pub mod package_source;\n-mod parse_args;\n-mod path_util;\n-mod source_control;\n-mod target;\n-#[cfg(not(windows), test)] // FIXME test failure on windows: #10471\n-mod tests;\n-mod util;\n-pub mod version;\n-pub mod workcache_support;\n-mod workspace;\n-\n-pub mod usage;\n-\n-/// A PkgScript represents user-supplied custom logic for\n-/// special build hooks. This only exists for packages with\n-/// an explicit package script.\n-struct PkgScript<'a> {\n-    /// Uniquely identifies this package\n-    id: &'a CrateId,\n-    /// File path for the package script\n-    input: Path,\n-    /// The session to use *only* for compiling the custom\n-    /// build script\n-    sess: session::Session,\n-    /// The config for compiling the custom build script\n-    cfg: ast::CrateConfig,\n-    /// The crate and ast_map for the custom build script\n-    crate_and_map: Option<(ast::Crate, syntax::ast_map::Map)>,\n-    /// Directory in which to store build output\n-    build_dir: Path\n-}\n-\n-impl<'a> PkgScript<'a> {\n-    /// Given the path name for a package script\n-    /// and a package ID, parse the package script into\n-    /// a PkgScript that we can then execute\n-    fn parse<'a>(sysroot: Path,\n-                 script: Path,\n-                 workspace: &Path,\n-                 id: &'a CrateId) -> PkgScript<'a> {\n-        // Get the executable name that was invoked\n-        let binary = os::args()[0];\n-        // Build the rustc session data structures to pass\n-        // to the compiler\n-        debug!(\"pkgscript parse: {}\", sysroot.display());\n-        let options = @session::Options {\n-            binary: binary,\n-            maybe_sysroot: Some(@sysroot),\n-            outputs: ~[session::OutputExecutable],\n-            .. (*session::basic_options()).clone()\n-        };\n-        let input = driver::FileInput(script.clone());\n-        let sess = driver::build_session(options,\n-                                         Some(script.clone()),\n-                                         @diagnostic::DefaultEmitter);\n-        let cfg = driver::build_configuration(sess);\n-        let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-        let loader = &mut Loader::new(sess);\n-        let crate_and_map = driver::phase_2_configure_and_expand(sess,\n-                                                         cfg.clone(),\n-                                                         loader,\n-                                                         crate);\n-        let work_dir = build_pkg_id_in_workspace(id, workspace);\n-\n-        debug!(\"Returning package script with id {}\", id.to_str());\n-\n-        PkgScript {\n-            id: id,\n-            input: script,\n-            sess: sess,\n-            cfg: cfg,\n-            crate_and_map: Some(crate_and_map),\n-            build_dir: work_dir\n-        }\n-    }\n-\n-    fn build_custom(&mut self, exec: &mut workcache::Exec) -> ~str {\n-        let sess = self.sess;\n-\n-        debug!(\"Working directory = {}\", self.build_dir.display());\n-        // Collect together any user-defined commands in the package script\n-        let (crate, ast_map) = self.crate_and_map.take_unwrap();\n-        let crate = util::ready_crate(sess, crate);\n-        debug!(\"Building output filenames with script name {}\",\n-               driver::source_name(&driver::FileInput(self.input.clone())));\n-        let exe = self.build_dir.join(\"pkg\" + util::exe_suffix());\n-        util::compile_crate_from_input(&self.input,\n-                                       exec,\n-                                       Nothing,\n-                                       &self.build_dir,\n-                                       sess,\n-                                       crate,\n-                                       ast_map,\n-                                       Main);\n-        // Discover the output\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        // Discover the output\n-        exec.discover_output(\"binary\", exe.as_str().unwrap().to_owned(), digest_only_date(&exe));\n-        exe.as_str().unwrap().to_owned()\n-    }\n-\n-    /// Run the contents of this package script, where <what>\n-    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n-    /// Returns a pair of an exit code and list of configs (obtained by\n-    /// calling the package script's configs() function if it exists, or\n-    /// None if `exe` could not be started.\n-    fn run_custom(exe: &Path, sysroot: &Path) -> Option<(~[~str], process::ProcessExit)> {\n-        debug!(\"Running program: {} {} {}\", exe.as_str().unwrap().to_owned(),\n-               sysroot.display(), \"install\");\n-        // FIXME #7401 should support commands besides `install`\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let opt_status = run::process_status(exe.as_str().unwrap(),\n-                                             [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n-        match opt_status {\n-            Some(status) => {\n-                if !status.success() {\n-                    debug!(\"run_custom: first pkg command failed with {:?}\", status);\n-                    Some((~[], status))\n-                }\n-                else {\n-                    debug!(\"Running program (configs): {} {} {}\",\n-                           exe.display(), sysroot.display(), \"configs\");\n-                    // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let opt_output = run::process_output(exe.as_str().unwrap(),\n-                                                         [sysroot.as_str().unwrap().to_owned(),\n-                                                          ~\"configs\"]);\n-                    match opt_output {\n-                        Some(output) => {\n-                            debug!(\"run_custom: second pkg command did {:?}\", output.status);\n-                            // Run the configs() function to get the configs\n-                            let cfgs = str::from_utf8(output.output).unwrap().words()\n-                                .map(|w| w.to_owned()).collect();\n-                            Some((cfgs, output.status))\n-                        },\n-                        None => {\n-                            debug!(\"run_custom: second pkg command failed to start\");\n-                            Some((~[], status))\n-                        }\n-                    }\n-                }\n-            },\n-            None => {\n-                debug!(\"run_custom: first pkg command failed to start\");\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-pub trait CtxMethods {\n-    fn run(&self, cmd: Command, args: ~[~str]);\n-    fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n-    /// Returns a pair of the selected package ID, and the destination workspace\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)>;\n-    /// Returns the destination workspace\n-    fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild);\n-    fn clean(&self, workspace: &Path, id: &CrateId);\n-    fn info(&self);\n-    /// Returns a pair. First component is a list of installed paths,\n-    /// second is a list of declared and discovered inputs\n-    fn install(&self, src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]);\n-    /// Returns a list of installed files\n-    fn install_no_build(&self,\n-                        build_workspace: &Path,\n-                        build_inputs: &[Path],\n-                        target_workspace: &Path,\n-                        id: &CrateId) -> ~[~str];\n-    fn prefer(&self, _id: &str, _vers: Option<~str>);\n-    fn test(&self, id: &CrateId, workspace: &Path);\n-    fn uninstall(&self, _id: &str, _vers: Option<~str>);\n-    fn unprefer(&self, _id: &str, _vers: Option<~str>);\n-    fn init(&self);\n-}\n-\n-impl CtxMethods for BuildContext {\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)> {\n-        let cwd = os::getcwd();\n-\n-        if args.len() < 1 {\n-            match cwd_to_workspace() {\n-                None if dir_has_crate_file(&cwd) => {\n-                    // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let crateid = from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n-                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n-                    self.build(&mut pkg_src, what);\n-                    match pkg_src {\n-                        PkgSrc { destination_workspace: ws,\n-                                 id: id, .. } => {\n-                            Some((id, ws))\n-                        }\n-                    }\n-                }\n-                None => { usage::build(); None }\n-                Some((ws, crateid)) => {\n-                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, crateid);\n-                    self.build(&mut pkg_src, what);\n-                    match pkg_src {\n-                        PkgSrc { destination_workspace: ws,\n-                                 id: id, .. } => {\n-                            Some((id, ws))\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            // The package id is presumed to be the first command-line\n-            // argument\n-            let crateid = from_str(args[0]).expect(\"valid crate id\");\n-            let mut dest_ws = default_workspace();\n-            each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n-                debug!(\"found pkg {} in workspace {}, trying to build\",\n-                       crateid.to_str(), workspace.display());\n-                dest_ws = determine_destination(os::getcwd(),\n-                                                self.context.use_rust_path_hack,\n-                                                workspace);\n-                let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n-                                              false, crateid.clone());\n-                self.build(&mut pkg_src, what);\n-                true\n-            });\n-            // n.b. If this builds multiple packages, it only returns the workspace for\n-            // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n-            // anyway and there are no tests for it, so maybe take it out\n-            Some((crateid, dest_ws))\n-        }\n-    }\n-\n-    fn run(&self, cmd: Command, args: ~[~str]) {\n-        let cwd = os::getcwd();\n-        match cmd {\n-            BuildCmd => {\n-                self.build_args(args, &WhatToBuild::new(MaybeCustom, Everything));\n-            }\n-            CleanCmd => {\n-                if args.len() < 1 {\n-                    match cwd_to_workspace() {\n-                        None => { usage::clean(); return }\n-                        // tjc: Maybe clean should clean all the packages in the\n-                        // current workspace, though?\n-                        Some((ws, crateid)) => self.clean(&ws, &crateid)\n-                    }\n-\n-                }\n-                else {\n-                    // The package id is presumed to be the first command-line\n-                    // argument\n-                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n-                    self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n-                }\n-            }\n-            DoCmd => {\n-                if args.len() < 2 {\n-                    return usage::do_cmd();\n-                }\n-\n-                self.do_cmd(args[0].clone(), args[1].clone());\n-            }\n-            HelpCmd => {\n-                if args.len() != 1 {\n-                    return usage::general();\n-                }\n-                match FromStr::from_str(args[0]) {\n-                    Some(help_cmd) => usage::usage_for_command(help_cmd),\n-                    None => {\n-                        usage::general();\n-                        error(format!(\"{} is not a recognized command\", args[0]))\n-                    }\n-                }\n-            }\n-            InfoCmd => {\n-                self.info();\n-            }\n-            InstallCmd => {\n-               if args.len() < 1 {\n-                    match cwd_to_workspace() {\n-                        None if dir_has_crate_file(&cwd) => {\n-                            // FIXME (#9639): This needs to handle non-utf8 paths\n-\n-                            let inferred_crateid =\n-                                from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n-                            self.install(PkgSrc::new(cwd, default_workspace(),\n-                                                     true, inferred_crateid),\n-                                         &WhatToBuild::new(MaybeCustom, Everything));\n-                        }\n-                        None  => { usage::install(); return; }\n-                        Some((ws, crateid))                => {\n-                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, crateid);\n-                            self.install(pkg_src, &WhatToBuild::new(MaybeCustom,\n-                                                                    Everything));\n-                      }\n-                  }\n-                }\n-                else {\n-                    // The package id is presumed to be the first command-line\n-                    // argument\n-                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n-                    let workspaces = pkg_parent_workspaces(&self.context, &crateid);\n-                    debug!(\"package ID = {}, found it in {:?} workspaces\",\n-                           crateid.to_str(), workspaces.len());\n-                    if workspaces.is_empty() {\n-                        let d = default_workspace();\n-                        let src = PkgSrc::new(d.clone(), d, false, crateid.clone());\n-                        self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n-                    }\n-                    else {\n-                        for workspace in workspaces.iter() {\n-                            let dest = determine_destination(os::getcwd(),\n-                                                             self.context.use_rust_path_hack,\n-                                                             workspace);\n-                            let src = PkgSrc::new(workspace.clone(),\n-                                                  dest,\n-                                                  self.context.use_rust_path_hack,\n-                                                  crateid.clone());\n-                            self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n-                        };\n-                    }\n-                }\n-            }\n-            ListCmd => {\n-                println!(\"Installed packages:\");\n-                installed_packages::list_installed_packages(|pkg_id| {\n-                    println!(\"{}\", pkg_id.path);\n-                    true\n-                });\n-            }\n-            PreferCmd => {\n-                if args.len() < 1 {\n-                    return usage::prefer();\n-                }\n-\n-                self.prefer(args[0], None);\n-            }\n-            TestCmd => {\n-                // Build the test executable\n-                let maybe_id_and_workspace = self.build_args(args,\n-                                                             &WhatToBuild::new(MaybeCustom, Tests));\n-                match maybe_id_and_workspace {\n-                    Some((pkg_id, workspace)) => {\n-                        // Assuming it's built, run the tests\n-                        self.test(&pkg_id, &workspace);\n-                    }\n-                    None => {\n-                        error(\"Testing failed because building the specified package failed.\");\n-                    }\n-                }\n-            }\n-            InitCmd => {\n-                if args.len() != 0 {\n-                    return usage::init();\n-                } else {\n-                    self.init();\n-                }\n-            }\n-            UninstallCmd => {\n-                if args.len() < 1 {\n-                    return usage::uninstall();\n-                }\n-\n-                let crateid = from_str(args[0]).expect(\"valid crate id\");\n-                if !installed_packages::package_is_installed(&crateid) {\n-                    warn(format!(\"Package {} doesn't seem to be installed! \\\n-                                  Doing nothing.\", args[0]));\n-                    return;\n-                }\n-                else {\n-                    let rp = rust_path();\n-                    assert!(!rp.is_empty());\n-                    each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n-                        path_util::uninstall_package_from(workspace, &crateid);\n-                        note(format!(\"Uninstalled package {} (was installed in {})\",\n-                                  crateid.to_str(), workspace.display()));\n-                        true\n-                    });\n-                }\n-            }\n-            UnpreferCmd => {\n-                if args.len() < 1 {\n-                    return usage::unprefer();\n-                }\n-\n-                self.unprefer(args[0], None);\n-            }\n-        }\n-    }\n-\n-    fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n-        // stub\n-        fail!(\"`do` not yet implemented\");\n-    }\n-\n-    fn build(&self, pkg_src: &mut PkgSrc, what_to_build: &WhatToBuild) {\n-        use conditions::git_checkout_failed::cond;\n-\n-        let workspace = pkg_src.source_workspace.clone();\n-        let crateid = pkg_src.id.clone();\n-\n-        let path = crateid.path.as_slice();\n-        debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n-                crateid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join(path)),\n-               crateid.to_str(), pkg_src.start_dir.display());\n-        debug!(\"build: what to build = {:?}\", what_to_build);\n-\n-        // If workspace isn't in the RUST_PATH, and it's a git repo,\n-        // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(path)) {\n-            let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push(path);\n-            let git_result = source_control::safe_git_clone(&workspace.join(path),\n-                                                            &crateid.version,\n-                                                            &out_dir);\n-            match git_result {\n-                CheckedOutSources => make_read_only(&out_dir),\n-                _ => cond.raise((path.to_owned(), out_dir.clone()))\n-            };\n-            let default_ws = default_workspace();\n-            debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n-                   crateid.to_str());\n-            return self.build(&mut PkgSrc::new(default_ws.clone(),\n-                                               default_ws,\n-                                               false,\n-                                               crateid.clone()), what_to_build);\n-        }\n-\n-        // Is there custom build logic? If so, use it\n-        let mut custom = false;\n-        debug!(\"Package source directory = {}\", pkg_src.to_str());\n-        let opt = pkg_src.package_script_option();\n-        debug!(\"Calling pkg_script_option on {:?}\", opt);\n-        let cfgs = match (pkg_src.package_script_option(), what_to_build.build_type) {\n-            (Some(package_script_path), MaybeCustom)  => {\n-                let sysroot = self.sysroot_to_use();\n-                // Build the package script if needed\n-                let script_build = format!(\"build_package_script({})\",\n-                                           package_script_path.display());\n-                let pkg_exe = self.workcache_context.with_prep(script_build, |prep| {\n-                    let subsysroot = sysroot.clone();\n-                    let psp = package_script_path.clone();\n-                    let ws = workspace.clone();\n-                    let pid = crateid.clone();\n-                    prep.exec(proc(exec) {\n-                        let mut pscript = PkgScript::parse(subsysroot.clone(),\n-                                                           psp.clone(),\n-                                                           &ws,\n-                                                           &pid);\n-                        pscript.build_custom(exec)\n-                    })\n-                });\n-                // We always *run* the package script\n-                match PkgScript::run_custom(&Path::new(pkg_exe), &sysroot) {\n-                    Some((cfgs, hook_result)) => {\n-                        debug!(\"Command return code = {:?}\", hook_result);\n-                        if !hook_result.success() {\n-                            fail!(\"Error running custom build command\")\n-                        }\n-                        custom = true;\n-                        // otherwise, the package script succeeded\n-                        cfgs\n-                    },\n-                    None => {\n-                        fail!(\"Error starting custom build command\")\n-                    }\n-                }\n-            }\n-            (Some(_), Inferred) => {\n-                debug!(\"There is a package script, but we're ignoring it\");\n-                ~[]\n-            }\n-            (None, _) => {\n-                debug!(\"No package script, continuing\");\n-                ~[]\n-            }\n-        } + self.context.cfgs;\n-\n-        // If there was a package script, it should have finished\n-        // the build already. Otherwise...\n-        if !custom {\n-            match what_to_build.sources {\n-                // Find crates inside the workspace\n-                Everything => pkg_src.find_crates(),\n-                // Find only tests\n-                Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n-                // Don't infer any crates -- just build the one that was requested\n-                JustOne(ref p) => {\n-                    // We expect that p is relative to the package source's start directory,\n-                    // so check that assumption\n-                    debug!(\"JustOne: p = {}\", p.display());\n-                    assert!(pkg_src.start_dir.join(p).exists());\n-                    if is_lib(p) {\n-                        PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n-                    } else if is_main(p) {\n-                        PkgSrc::push_crate(&mut pkg_src.mains, 0, p);\n-                    } else if is_test(p) {\n-                        PkgSrc::push_crate(&mut pkg_src.tests, 0, p);\n-                    } else if is_bench(p) {\n-                        PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n-                    } else {\n-                        warn(format!(\"Not building any crates for dependency {}\", p.display()));\n-                        return;\n-                    }\n-                }\n-            }\n-            // Build it!\n-            pkg_src.build(self, cfgs, []);\n-        }\n-    }\n-\n-    fn clean(&self, workspace: &Path, id: &CrateId)  {\n-        // Could also support a custom build hook in the pkg\n-        // script for cleaning files rustpkg doesn't know about.\n-        // Do something reasonable for now\n-\n-        let dir = build_pkg_id_in_workspace(id, workspace);\n-        note(format!(\"Cleaning package {} (removing directory {})\",\n-                        id.to_str(), dir.display()));\n-        if dir.exists() {\n-            fs::rmdir_recursive(&dir);\n-            note(format!(\"Removed directory {}\", dir.display()));\n-        }\n-\n-        note(format!(\"Cleaned package {}\", id.to_str()));\n-    }\n-\n-    fn info(&self) {\n-        // stub\n-        fail!(\"info not yet implemented\");\n-    }\n-\n-    fn install(&self, mut pkg_src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]) {\n-\n-        let id = pkg_src.id.clone();\n-\n-        let mut installed_files = ~[];\n-        let mut inputs = ~[];\n-        let mut build_inputs = ~[];\n-\n-        debug!(\"Installing package source: {}\", pkg_src.to_str());\n-\n-        // workcache only knows about *crates*. Building a package\n-        // just means inferring all the crates in it, then building each one.\n-        self.build(&mut pkg_src, what);\n-\n-        debug!(\"Done building package source {}\", pkg_src.to_str());\n-\n-        let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n-                      pkg_src.tests.clone(), pkg_src.benchs.clone()];\n-        debug!(\"In declare inputs for {}\", id.to_str());\n-        for cs in to_do.iter() {\n-            for c in cs.iter() {\n-                let path = pkg_src.start_dir.join(&c.file);\n-                debug!(\"Recording input: {}\", path.display());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                inputs.push((~\"file\", path.as_str().unwrap().to_owned()));\n-                build_inputs.push(path);\n-            }\n-        }\n-\n-        let result = self.install_no_build(pkg_src.build_workspace(),\n-                                           build_inputs,\n-                                           &pkg_src.destination_workspace,\n-                                           &id).map(|s| Path::new(s.as_slice()));\n-        installed_files = installed_files + result;\n-        note(format!(\"Installed package {} to {}\",\n-                     id.to_str(),\n-                     pkg_src.destination_workspace.display()));\n-        (installed_files, inputs)\n-    }\n-\n-    // again, working around lack of Encodable for Path\n-    fn install_no_build(&self,\n-                        build_workspace: &Path,\n-                        build_inputs: &[Path],\n-                        target_workspace: &Path,\n-                        id: &CrateId) -> ~[~str] {\n-\n-        debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n-               id.to_str(), build_workspace.display(), target_workspace.display());\n-\n-        // Now copy stuff into the install dirs\n-        let maybe_executable = built_executable_in_workspace(id, build_workspace);\n-        let maybe_library = built_library_in_workspace(id, build_workspace);\n-        let target_exec = target_executable_in_workspace(id, target_workspace);\n-        let target_lib = maybe_library.as_ref()\n-            .map(|_| target_library_in_workspace(id, target_workspace));\n-\n-        debug!(\"target_exec = {} target_lib = {:?} \\\n-               maybe_executable = {:?} maybe_library = {:?}\",\n-               target_exec.display(), target_lib,\n-               maybe_executable, maybe_library);\n-\n-        let install_tag = format!(\"install({}-{})\", id.path, id.version_or_default());\n-        self.workcache_context.with_prep(install_tag, |prep| {\n-            for ee in maybe_executable.iter() {\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                prep.declare_input(\"binary\",\n-                                   ee.as_str().unwrap(),\n-                                   workcache_support::digest_only_date(ee));\n-            }\n-            for ll in maybe_library.iter() {\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                prep.declare_input(\"binary\",\n-                                   ll.as_str().unwrap(),\n-                                   workcache_support::digest_only_date(ll));\n-            }\n-            let subex = maybe_executable.clone();\n-            let sublib = maybe_library.clone();\n-            let sub_target_ex = target_exec.clone();\n-            let sub_target_lib = target_lib.clone();\n-            let sub_build_inputs = build_inputs.to_owned();\n-            prep.exec(proc(exe_thing) {\n-                let mut outputs = ~[];\n-                // Declare all the *inputs* to the declared input too, as inputs\n-                for executable in subex.iter() {\n-                    exe_thing.discover_input(\"binary\",\n-                                             executable.as_str().unwrap().to_owned(),\n-                                             workcache_support::digest_only_date(executable));\n-                }\n-                for library in sublib.iter() {\n-                    exe_thing.discover_input(\"binary\",\n-                                             library.as_str().unwrap().to_owned(),\n-                                             workcache_support::digest_only_date(library));\n-                }\n-\n-                for transitive_dependency in sub_build_inputs.iter() {\n-                    exe_thing.discover_input(\n-                        \"file\",\n-                        transitive_dependency.as_str().unwrap().to_owned(),\n-                        workcache_support::digest_file_with_date(transitive_dependency));\n-                }\n-\n-\n-                for exec in subex.iter() {\n-                    debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n-                    fs::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n-                    fs::copy(exec, &sub_target_ex);\n-                    // FIXME (#9639): This needs to handle non-utf8 paths\n-                    exe_thing.discover_output(\"binary\",\n-                        sub_target_ex.as_str().unwrap(),\n-                        workcache_support::digest_only_date(&sub_target_ex));\n-                    outputs.push(sub_target_ex.as_str().unwrap().to_owned());\n-                }\n-                for lib in sublib.iter() {\n-                    let mut target_lib = sub_target_lib\n-                        .clone().expect(format!(\"I built {} but apparently \\\n-                                             didn't install it!\", lib.display()));\n-                    target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n-                    fs::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n-                    fs::copy(lib, &target_lib);\n-                    debug!(\"3. discovering output {}\", target_lib.display());\n-                    exe_thing.discover_output(\"binary\",\n-                                              target_lib.as_str().unwrap(),\n-                                              workcache_support::digest_only_date(&target_lib));\n-                    outputs.push(target_lib.as_str().unwrap().to_owned());\n-                }\n-                outputs\n-            })\n-        })\n-    }\n-\n-    fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"prefer not yet implemented\");\n-    }\n-\n-    fn test(&self, crateid: &CrateId, workspace: &Path)  {\n-        match built_test_in_workspace(crateid, workspace) {\n-            Some(test_exec) => {\n-                debug!(\"test: test_exec = {}\", test_exec.display());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let opt_status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n-                match opt_status {\n-                    Some(status) => {\n-                        if !status.success() {\n-                            fail!(\"Some tests failed\");\n-                        }\n-                    },\n-                    None => fail!(\"Could not exec `{}`\", test_exec.display())\n-                }\n-            }\n-            None => {\n-                error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n-                           wasn't built! Please report this as a bug.\",\n-                           crateid.to_str(), workspace.display()));\n-            }\n-        }\n-    }\n-\n-    fn init(&self) {\n-        fs::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n-        fs::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n-    }\n-\n-    fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"uninstall not yet implemented\");\n-    }\n-\n-    fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(\"unprefer not yet implemented\");\n-    }\n-}\n-\n-pub fn main() {\n-    println!(\"WARNING: The Rust package manager is experimental and may be unstable\");\n-    os::set_exit_status(main_args(os::args()));\n-}\n-\n-pub fn main_args(args: &[~str]) -> int {\n-\n-    let (command, args, context, supplied_sysroot) = match parse_args(args) {\n-        Ok(ParseResult {\n-            command: cmd,\n-            args: args,\n-            context: ctx,\n-            sysroot: sroot}) => (cmd, args, ctx, sroot),\n-        Err(error_code) => {\n-            debug!(\"Parsing failed. Returning error code {}\", error_code);\n-            return error_code\n-        }\n-    };\n-    debug!(\"Finished parsing commandline args {:?}\", args);\n-    debug!(\"  Using command: {:?}\", command);\n-    debug!(\"  Using args {:?}\", args);\n-    debug!(\"  Using cflags: {:?}\", context.rustc_flags);\n-    debug!(\"  Using rust_path_hack {:b}\", context.use_rust_path_hack);\n-    debug!(\"  Using cfgs: {:?}\", context.cfgs);\n-    debug!(\"  Using supplied_sysroot: {:?}\", supplied_sysroot);\n-\n-    let sysroot = match supplied_sysroot {\n-        Some(s) => Path::new(s),\n-        _ => filesearch::get_or_default_sysroot()\n-    };\n-\n-    debug!(\"Using sysroot: {}\", sysroot.display());\n-    let ws = default_workspace();\n-    debug!(\"Will store workcache in {}\", ws.display());\n-\n-    // Wrap the rest in task::try in case of a condition failure in a task\n-    let result = task::try(proc() {\n-        BuildContext {\n-            context: context,\n-            sysroot: sysroot.clone(), // Currently, only tests override this\n-            workcache_context: api::default_context(sysroot.clone(),\n-                                                    default_workspace()).workcache_context\n-        }.run(command, args.clone())\n-    });\n-    // FIXME #9262: This is using the same error code for all errors,\n-    // and at least one test case succeeds if rustpkg returns COPY_FAILED_CODE,\n-    // when actually, it might set the exit code for that even if a different\n-    // unhandled condition got raised.\n-    if result.is_err() { return COPY_FAILED_CODE; }\n-    return 0;\n-}"}, {"sha": "dbd0ee80f2875bf257fc8610aaeef973ebfc0afe", "filename": "src/librustpkg/messages.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use extra::term;\n-use std::io;\n-\n-pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color::GREEN);\n-}\n-\n-pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color::YELLOW);\n-}\n-\n-pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color::RED);\n-}\n-\n-fn pretty_message<'a>(msg: &'a str,\n-                      prefix: &'a str,\n-                      color: term::color::Color) {\n-    let mut term = term::Terminal::new(io::stdout());\n-    let mut stdout = io::stdout();\n-    match term {\n-        Ok(ref mut t) => {\n-            t.fg(color);\n-            t.write(prefix.as_bytes());\n-            t.reset();\n-        },\n-        _ => {\n-            stdout.write(prefix.as_bytes());\n-        }\n-    }\n-    stdout.write(msg.as_bytes());\n-    stdout.write(['\\n' as u8]);\n-}"}, {"sha": "6b4f1c1ae1abc60c40fdd3e908369095d36ada3b", "filename": "src/librustpkg/package_source.rs", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,554 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod extra;\n-\n-use target::*;\n-use std::io;\n-use std::io::fs;\n-use std::os;\n-use context::*;\n-use crate::Crate;\n-use messages::*;\n-use source_control::{safe_git_clone, git_clone_url, DirToUse, CheckedOutSources};\n-use source_control::make_read_only;\n-use path_util::{find_dir_using_rust_path_hack, make_dir_rwx_recursive, default_workspace};\n-use path_util::{target_build_dir, versionize, dir_has_crate_file};\n-use util::{compile_crate, DepMap};\n-use workcache_support;\n-use workcache_support::{digest_only_date, digest_file_with_date, crate_tag};\n-use extra::workcache;\n-use extra::treemap::TreeMap;\n-use syntax::crateid::CrateId;\n-use rustc::driver::session;\n-\n-// An enumeration of the unpacked source of a package workspace.\n-// This contains a list of files found in the source workspace.\n-#[deriving(Clone)]\n-pub struct PkgSrc {\n-    /// Root of where the package source code lives\n-    source_workspace: Path,\n-    /// If build_in_destination is true, temporary results should\n-    /// go in the build/ subdirectory of the destination workspace.\n-    /// (Otherwise, they go in the build/ subdirectory of the\n-    /// source workspace.) This happens if the \"RUST_PATH hack\" is\n-    /// in effect, or if sources were fetched from a remote\n-    /// repository.\n-    build_in_destination: bool,\n-    /// Where to install the results. May or may not be the same\n-    /// as source_workspace\n-    destination_workspace: Path,\n-    // Directory to start looking in for packages -- normally\n-    // this is workspace/src/id but it may be just workspace\n-    start_dir: Path,\n-    id: CrateId,\n-    libs: ~[Crate],\n-    mains: ~[Crate],\n-    tests: ~[Crate],\n-    benchs: ~[Crate],\n-}\n-\n-pub enum BuildSort { InPlace, Discovered }\n-\n-impl ToStr for PkgSrc {\n-    fn to_str(&self) -> ~str {\n-        format!(\"Package ID {} in start dir {} [workspaces = {} -> {}]\",\n-                self.id.to_str(),\n-                self.start_dir.display(),\n-                self.source_workspace.display(),\n-                self.destination_workspace.display())\n-    }\n-}\n-condition! {\n-    build_err: (~str) -> ~str;\n-}\n-\n-fn prefixes(p: &Path) -> Prefixes {\n-    Prefixes {\n-        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n-        remaining: ~[]\n-    }\n-}\n-\n-struct Prefixes {\n-    components: ~[~str],\n-    remaining: ~[~str]\n-}\n-\n-impl Iterator<(Path, Path)> for Prefixes {\n-    #[inline]\n-    fn next(&mut self) -> Option<(Path, Path)> {\n-        if self.components.len() <= 1 {\n-            None\n-        }\n-        else {\n-            let last = self.components.pop().unwrap();\n-            self.remaining.unshift(last);\n-            // converting to str and then back is a little unfortunate\n-            Some((Path::new(self.components.connect(\"/\")),\n-                  Path::new(self.remaining.connect(\"/\"))))\n-        }\n-    }\n-}\n-\n-impl PkgSrc {\n-    pub fn new(mut source_workspace: Path,\n-               destination_workspace: Path,\n-               use_rust_path_hack: bool,\n-               id: CrateId) -> PkgSrc {\n-        use conditions::nonexistent_package::cond;\n-\n-        debug!(\"Checking package source for package ID {}, \\\n-                workspace = {} -> {}, use_rust_path_hack = {:?}\",\n-                id.to_str(),\n-                source_workspace.display(),\n-                destination_workspace.display(),\n-                use_rust_path_hack);\n-\n-        let mut destination_workspace = destination_workspace.clone();\n-\n-        let mut to_try = ~[];\n-        let mut output_names = ~[];\n-        let build_dir = target_build_dir(&source_workspace);\n-\n-        if use_rust_path_hack {\n-            to_try.push(source_workspace.clone());\n-        } else {\n-            // We search for sources under both src/ and build/ , because build/ is where\n-            // automatically-checked-out sources go.\n-            let path = Path::new(id.path.as_slice());\n-            let mut result = source_workspace.join(\"src\");\n-            result.push(&path.dir_path());\n-            result.push(id.short_name_with_version());\n-            to_try.push(result);\n-            let mut result = source_workspace.join(\"src\");\n-            result.push(&path);\n-            to_try.push(result);\n-\n-            let mut result = build_dir.join(\"src\");\n-            result.push(&path.dir_path());\n-            result.push(id.short_name_with_version());\n-            to_try.push(result.clone());\n-            output_names.push(result);\n-            let mut other_result = build_dir.join(\"src\");\n-            other_result.push(&path);\n-            to_try.push(other_result.clone());\n-            output_names.push(other_result);\n-\n-        }\n-\n-        debug!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n-\n-        let path = to_try.iter().find(|&d| d.is_dir()\n-                                      && dir_has_crate_file(d));\n-\n-        // See the comments on the definition of PkgSrc\n-        let mut build_in_destination = use_rust_path_hack;\n-        debug!(\"1. build_in_destination = {:?}\", build_in_destination);\n-\n-        let dir: Path = match path {\n-            Some(d) => (*d).clone(),\n-            None => {\n-                // See if any of the prefixes of this package ID form a valid package ID\n-                // That is, is this a package ID that points into the middle of a workspace?\n-                for (prefix, suffix) in prefixes(&Path::new(id.path.as_slice())) {\n-                    let crate_id: Option<CrateId> = from_str(prefix.as_str().unwrap());\n-                    let crate_id = crate_id.expect(\"valid crate id\");\n-                    let path = build_dir.join(crate_id.path.as_slice());\n-                    debug!(\"in loop: checking if {} is a directory\", path.display());\n-                    if path.is_dir() {\n-                        let ps = PkgSrc::new(source_workspace,\n-                                             destination_workspace,\n-                                             use_rust_path_hack,\n-                                             crate_id);\n-                        match ps {\n-                            PkgSrc {\n-                                source_workspace: source,\n-                                destination_workspace: destination,\n-                                start_dir: start,\n-                                id: id, .. } => {\n-                                let result = PkgSrc {\n-                                    source_workspace: source.clone(),\n-                                    build_in_destination: build_in_destination,\n-                                    destination_workspace: destination,\n-                                    start_dir: start.join(&suffix),\n-                                    id: id,\n-                                    libs: ~[],\n-                                    mains: ~[],\n-                                    tests: ~[],\n-                                    benchs: ~[]\n-                                };\n-                                debug!(\"pkgsrc: Returning {}\", result.to_str());\n-                                return result;\n-                            }\n-                        }\n-\n-                    }\n-                }\n-\n-                // Ok, no prefixes work, so try fetching from git\n-                let mut ok_d = None;\n-                for w in output_names.iter() {\n-                    debug!(\"Calling fetch_git on {}\", w.display());\n-                    let target_dir_opt = PkgSrc::fetch_git(w, &id);\n-                    for p in target_dir_opt.iter() {\n-                        ok_d = Some(p.clone());\n-                        build_in_destination = true;\n-                        debug!(\"2. build_in_destination = {:?}\", build_in_destination);\n-                        break;\n-                    }\n-                    match ok_d {\n-                        Some(ref d) => {\n-                            let path = Path::new(id.path.as_slice());\n-                            if d.is_ancestor_of(&path)\n-                                || d.is_ancestor_of(&versionize(id.path, &id.version)) {\n-                                // Strip off the package ID\n-                                source_workspace = d.clone();\n-                                for _ in path.components() {\n-                                    source_workspace.pop();\n-                                }\n-                                // Strip off the src/ part\n-                                source_workspace.pop();\n-                                // Strip off the build/<target-triple> part to get the workspace\n-                                destination_workspace = source_workspace.clone();\n-                                destination_workspace.pop();\n-                                destination_workspace.pop();\n-                            }\n-                            break;\n-                        }\n-                        None => ()\n-                    }\n-                }\n-                match ok_d {\n-                    Some(d) => d,\n-                    None => {\n-                        // See if the sources are in $CWD\n-                        let cwd = os::getcwd();\n-                        if dir_has_crate_file(&cwd) {\n-                            return PkgSrc {\n-                                // In this case, source_workspace isn't really a workspace.\n-                                // This data structure needs yet more refactoring.\n-                                source_workspace: cwd.clone(),\n-                                destination_workspace: default_workspace(),\n-                                build_in_destination: true,\n-                                start_dir: cwd,\n-                                id: id,\n-                                libs: ~[],\n-                                mains: ~[],\n-                                benchs: ~[],\n-                                tests: ~[]\n-                            }\n-                        } else if use_rust_path_hack {\n-                            match find_dir_using_rust_path_hack(&id) {\n-                                Some(d) => d,\n-                                None => {\n-                                    cond.raise((id.clone(),\n-                                        ~\"supplied path for package dir does not \\\n-                                        exist, and couldn't interpret it as a URL fragment\"))\n-                                }\n-                            }\n-                        } else {\n-                            cond.raise((id.clone(),\n-                                ~\"supplied path for package dir does not \\\n-                                exist, and couldn't interpret it as a URL fragment\"))\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-        debug!(\"3. build_in_destination = {:?}\", build_in_destination);\n-        debug!(\"source: {} dest: {}\", source_workspace.display(), destination_workspace.display());\n-\n-        debug!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n-\n-        if !dir.is_dir() {\n-            cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n-                                        non-directory\"));\n-        }\n-\n-        PkgSrc {\n-            source_workspace: source_workspace.clone(),\n-            build_in_destination: build_in_destination,\n-            destination_workspace: destination_workspace,\n-            start_dir: dir,\n-            id: id,\n-            libs: ~[],\n-            mains: ~[],\n-            tests: ~[],\n-            benchs: ~[]\n-        }\n-    }\n-\n-    /// Try interpreting self's package id as a git repository, and try\n-    /// fetching it and caching it in a local directory. Return the cached directory\n-    /// if this was successful, None otherwise. Similarly, if the package id\n-    /// refers to a git repo on the local version, also check it out.\n-    /// (right now we only support git)\n-    pub fn fetch_git(local: &Path, crateid: &CrateId) -> Option<Path> {\n-        use conditions::git_checkout_failed::cond;\n-\n-        let cwd = os::getcwd();\n-        let path = Path::new(crateid.path.as_slice());\n-        debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                crateid.to_str(), crateid.path,\n-                cwd.display(),\n-                path.exists());\n-\n-        match safe_git_clone(&path, &crateid.version, local) {\n-            CheckedOutSources => {\n-                make_read_only(local);\n-                Some(local.clone())\n-            }\n-            DirToUse(clone_target) => {\n-                if path.components().nth(1).is_none() {\n-                    // If a non-URL, don't bother trying to fetch\n-                    return None;\n-                }\n-\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let url = format!(\"https://{}\", path.as_str().unwrap());\n-                debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), crateid.version_or_default());\n-\n-                let mut failed = false;\n-\n-                cond.trap(|_| {\n-                    failed = true;\n-                }).inside(|| git_clone_url(url, &clone_target, &crateid.version));\n-\n-                if failed {\n-                    return None;\n-                }\n-\n-                // Move clone_target to local.\n-                // First, create all ancestor directories.\n-                let moved = make_dir_rwx_recursive(&local.dir_path())\n-                    && io::result(|| fs::rename(&clone_target, local)).is_ok();\n-                if moved { Some(local.clone()) }\n-                    else { None }\n-            }\n-        }\n-    }\n-\n-    // If a file named \"pkg.rs\" in the start directory exists,\n-    // return the path for it. Otherwise, None\n-    pub fn package_script_option(&self) -> Option<Path> {\n-        let maybe_path = self.start_dir.join(\"pkg.rs\");\n-        debug!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n-        if maybe_path.exists() {\n-            Some(maybe_path)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n-        let mut it = p.components().peekable();\n-        if prefix > 0 {\n-            it.nth(prefix-1); // skip elements\n-        }\n-        assert!(it.peek().is_some());\n-        let mut sub = Path::new(\".\");\n-        for c in it {\n-            sub.push(c);\n-        }\n-        debug!(\"Will compile crate {}\", sub.display());\n-        cs.push(Crate::new(&sub));\n-    }\n-\n-    /// Infers crates to build. Called only in the case where there\n-    /// is no custom build logic\n-    pub fn find_crates(&mut self) {\n-        self.find_crates_with_filter(|_| true);\n-    }\n-\n-    pub fn find_crates_with_filter(&mut self, filter: |&str| -> bool) {\n-        use conditions::missing_pkg_files::cond;\n-\n-        let prefix = self.start_dir.components().len();\n-        debug!(\"Matching against {}\", self.id.name);\n-        for pth in fs::walk_dir(&self.start_dir) {\n-            let maybe_known_crate_set = match pth.filename_str() {\n-                Some(filename) if filter(filename) => match filename {\n-                    \"lib.rs\" => Some(&mut self.libs),\n-                    \"main.rs\" => Some(&mut self.mains),\n-                    \"test.rs\" => Some(&mut self.tests),\n-                    \"bench.rs\" => Some(&mut self.benchs),\n-                    _ => None\n-                },\n-                _ => None\n-            };\n-\n-            match maybe_known_crate_set {\n-                Some(crate_set) => PkgSrc::push_crate(crate_set, prefix, &pth),\n-                None => ()\n-            }\n-        }\n-\n-        let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n-        if crate_sets.iter().all(|crate_set| crate_set.is_empty()) {\n-\n-            note(\"Couldn't infer any crates to build.\\n\\\n-                         Try naming a crate `main.rs`, `lib.rs`, \\\n-                         `test.rs`, or `bench.rs`.\");\n-            cond.raise(self.id.clone());\n-        }\n-\n-        debug!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n-               self.start_dir.display(),\n-               self.libs.len(),\n-               self.mains.len(),\n-               self.tests.len(),\n-               self.benchs.len())\n-    }\n-\n-    fn build_crates(&self,\n-                    ctx: &BuildContext,\n-                    deps: &mut DepMap,\n-                    crates: &[Crate],\n-                    cfgs: &[~str],\n-                    what: OutputType,\n-                    inputs_to_discover: &[(~str, Path)]) {\n-        for crate in crates.iter() {\n-            let path = self.start_dir.join(&crate.file);\n-            debug!(\"build_crates: compiling {}\", path.display());\n-            let cfgs = crate.cfgs + cfgs;\n-\n-            ctx.workcache_context.with_prep(crate_tag(&path), |prep| {\n-                debug!(\"Building crate {}, declaring it as an input\", path.display());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                prep.declare_input(\"file\", path.as_str().unwrap(),\n-                                   workcache_support::digest_file_with_date(&path));\n-                let subpath = path.clone();\n-                let subcfgs = cfgs.clone();\n-                let subcx = ctx.clone();\n-                let id = self.id.clone();\n-                let sub_dir = self.build_workspace().clone();\n-                let sub_flags = crate.flags.clone();\n-                let sub_deps = deps.clone();\n-                let inputs = inputs_to_discover.map(|&(ref k, ref p)|\n-                                                    (k.clone(), p.as_str().unwrap().to_owned()));\n-                prep.exec(proc(exec) {\n-                    for &(ref kind, ref p) in inputs.iter() {\n-                        let pth = Path::new(p.clone());\n-                        exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n-                                digest_file_with_date(&pth)\n-                            } else if *kind == ~\"binary\" {\n-                                digest_only_date(&Path::new(p.clone()))\n-                            } else {\n-                                fail!(\"Bad kind in build_crates\")\n-                            });\n-                    }\n-                    debug!(\"Compiling crate {}; its output will be in {}\",\n-                           subpath.display(), sub_dir.display());\n-                    let opt: session::OptLevel = subcx.context.rustc_flags.optimization_level;\n-                    let result = compile_crate(&subcx,\n-                                               exec,\n-                                               &id,\n-                                               &subpath,\n-                                               &sub_dir,\n-                                               &mut (sub_deps.clone()),\n-                                               sub_flags,\n-                                               subcfgs,\n-                                               opt,\n-                                               what);\n-                    // FIXME: result is an Option<Path>. The following code did not take that\n-                    // into account. I'm not sure if the workcache really likes seeing the\n-                    // output as \"Some(\\\"path\\\")\". But I don't know what to do about it.\n-                    // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let result = result.as_ref().map(|p|p.as_str().unwrap());\n-                    debug!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n-                    result.to_str()\n-                })\n-            });\n-        }\n-    }\n-\n-    /// Declare all the crate files in the package source as inputs\n-    /// (to the package)\n-    pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n-        let to_do = ~[self.libs.clone(), self.mains.clone(),\n-                      self.tests.clone(), self.benchs.clone()];\n-        debug!(\"In declare inputs, self = {}\", self.to_str());\n-        for cs in to_do.iter() {\n-            for c in cs.iter() {\n-                let path = self.start_dir.join(&c.file);\n-                debug!(\"Declaring input: {}\", path.display());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                prep.declare_input(\"file\", path.as_str().unwrap(),\n-                                   workcache_support::digest_file_with_date(&path.clone()));\n-            }\n-        }\n-    }\n-\n-    pub fn build(&self,\n-                 build_context: &BuildContext,\n-                 // DepMap is a map from str (crate name) to (kind, name) --\n-                 // it tracks discovered dependencies per-crate\n-                 cfgs: ~[~str],\n-                 inputs_to_discover: &[(~str, Path)]) -> DepMap {\n-        let mut deps = TreeMap::new();\n-        let libs = self.libs.clone();\n-        let mains = self.mains.clone();\n-        let tests = self.tests.clone();\n-        let benchs = self.benchs.clone();\n-        debug!(\"Building libs in {}, destination = {}\",\n-               self.source_workspace.display(),\n-               self.build_workspace().display());\n-        self.build_crates(build_context,\n-                          &mut deps,\n-                          libs,\n-                          cfgs,\n-                          Lib,\n-                          inputs_to_discover);\n-        debug!(\"Building mains\");\n-        self.build_crates(build_context,\n-                          &mut deps,\n-                          mains,\n-                          cfgs,\n-                          Main,\n-                          inputs_to_discover);\n-        debug!(\"Building tests\");\n-        self.build_crates(build_context,\n-                          &mut deps,\n-                          tests,\n-                          cfgs,\n-                          Test,\n-                          inputs_to_discover);\n-        debug!(\"Building benches\");\n-        self.build_crates(build_context,\n-                          &mut deps,\n-                          benchs,\n-                          cfgs,\n-                          Bench,\n-                          inputs_to_discover);\n-        deps\n-    }\n-\n-    /// Return the workspace to put temporary files in. See the comment on `PkgSrc`\n-    pub fn build_workspace<'a>(&'a self) -> &'a Path {\n-        if self.build_in_destination {\n-            &self.destination_workspace\n-        }\n-        else {\n-            &self.source_workspace\n-        }\n-    }\n-\n-    /// Debugging\n-    pub fn dump_crates(&self) {\n-        let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n-        for crate_set in crate_sets.iter() {\n-            for c in crate_set.iter() {\n-                debug!(\"Built crate: {}\", c.file.display())\n-            }\n-        }\n-    }\n-}"}, {"sha": "9a9a9c5fccb48f731e7a57e930c59eef899e418f", "filename": "src/librustpkg/parse_args.rs", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fparse_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fparse_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fparse_args.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,196 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use context::{Context, RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n-                       LLVMAssemble, LLVMCompileBitcode};\n-use context::{Command, flags_forbidden_for_cmd};\n-use rustc::version;\n-use exit_codes::{BAD_FLAG_CODE};\n-use rustc::driver::{session};\n-\n-use usage;\n-\n-use extra::{getopts};\n-use std::{result};\n-use std::hashmap::HashSet;\n-\n-///  Result of parsing command line arguments\n-pub struct ParseResult {\n-    // Command\n-    command: Command,\n-    // Args\n-    args: ~[~str],\n-    // Parsed command line flags\n-    context: Context,\n-    // Path to system root\n-    sysroot: Option<~str>\n-}\n-\n-/// Parses command line arguments of rustpkg.\n-/// Returns a triplet (command, remaining_args, context)\n-pub fn parse_args(args: &[~str]) -> Result<ParseResult, int> {\n-    let opts = ~[ getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n-                                        getopts::optflag(\"no-link\"),\n-                                        getopts::optflag(\"no-trans\"),\n-                 // n.b. Ignores different --pretty options for now\n-                                        getopts::optflag(\"pretty\"),\n-                                        getopts::optflag(\"parse-only\"),\n-                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n-                 getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n-                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n-                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n-                                        getopts::optopt(\"sysroot\"),\n-                                        getopts::optflag(\"emit-llvm\"),\n-                                        getopts::optopt(\"linker\"),\n-                                        getopts::optopt(\"link-args\"),\n-                                        getopts::optopt(\"opt-level\"),\n-                 getopts::optflag(\"O\"),\n-                                        getopts::optflag(\"save-temps\"),\n-                                        getopts::optopt(\"target\"),\n-                                        getopts::optopt(\"target-cpu\"),\n-                 getopts::optmulti(\"Z\")                                   ];\n-    let matches = &match getopts::getopts(args, opts) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            error!(\"{}\", f.to_err_msg());\n-            return Err(1);\n-        }\n-    };\n-    let no_link = matches.opt_present(\"no-link\");\n-    let no_trans = matches.opt_present(\"no-trans\");\n-    let supplied_sysroot = matches.opt_str(\"sysroot\");\n-    let generate_asm = matches.opt_present(\"S\") ||\n-        matches.opt_present(\"assembly\");\n-    let parse_only = matches.opt_present(\"parse-only\");\n-    let pretty = matches.opt_present(\"pretty\");\n-    let emit_llvm = matches.opt_present(\"emit-llvm\");\n-\n-    if matches.opt_present(\"h\") ||\n-       matches.opt_present(\"help\") {\n-         usage::general();\n-         return Err(0);\n-    }\n-\n-    if matches.opt_present(\"v\") ||\n-       matches.opt_present(\"version\") {\n-        version(args[0]);\n-        return Err(0);\n-    }\n-\n-    let use_rust_path_hack = matches.opt_present(\"r\") ||\n-                             matches.opt_present(\"rust-path-hack\");\n-\n-    let linker = matches.opt_str(\"linker\");\n-    let link_args = matches.opt_str(\"link-args\");\n-    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n-    let mut user_supplied_opt_level = true;\n-    let opt_level = match matches.opt_str(\"opt-level\") {\n-        Some(~\"0\") => session::No,\n-        Some(~\"1\") => session::Less,\n-        Some(~\"2\") => session::Default,\n-        Some(~\"3\") => session::Aggressive,\n-        _ if matches.opt_present(\"O\") => session::Default,\n-        _ => {\n-            user_supplied_opt_level = false;\n-            session::No\n-        }\n-    };\n-\n-    let save_temps = matches.opt_present(\"save-temps\");\n-    let target     = matches.opt_str(\"target\");\n-    let target_cpu = matches.opt_str(\"target-cpu\");\n-    let experimental_features = {\n-        let strs = matches.opt_strs(\"Z\");\n-        if matches.opt_present(\"Z\") {\n-            Some(strs)\n-        }\n-        else {\n-            None\n-        }\n-    };\n-\n-    let mut args = matches.free.clone();\n-    args.shift();\n-\n-    if args.len() < 1 {\n-        usage::general();\n-        return Err(1);\n-    }\n-\n-    let rustc_flags = RustcFlags {\n-        linker: linker,\n-        link_args: link_args,\n-        optimization_level: opt_level,\n-        compile_upto: if no_trans {\n-            Trans\n-        } else if no_link {\n-            Link\n-        } else if pretty {\n-            Pretty\n-        } else if parse_only {\n-            Analysis\n-        } else if emit_llvm && generate_asm {\n-            LLVMAssemble\n-        } else if generate_asm {\n-            Assemble\n-        } else if emit_llvm {\n-            LLVMCompileBitcode\n-        } else {\n-            Nothing\n-        },\n-        save_temps: save_temps,\n-        target: target,\n-        target_cpu: target_cpu,\n-        additional_library_paths:\n-            HashSet::new(), // No way to set this from the rustpkg command line\n-        experimental_features: experimental_features\n-    };\n-\n-    let cmd_opt = args.iter().filter_map( |s| from_str(s.clone())).next();\n-    let command = match cmd_opt {\n-        None => {\n-            debug!(\"No legal command. Returning 0\");\n-            usage::general();\n-            return Err(0);\n-        }\n-        Some(cmd) => {\n-            let bad_option = flags_forbidden_for_cmd(&rustc_flags,\n-                                                              cfgs,\n-                                                              cmd,\n-                                                              user_supplied_opt_level);\n-            if bad_option {\n-                usage::usage_for_command(cmd);\n-                debug!(\"Bad  option, returning BAD_FLAG_CODE\");\n-                return Err(BAD_FLAG_CODE);\n-            } else {\n-                cmd\n-            }\n-        }\n-    };\n-\n-    // Pop off all flags, plus the command\n-    let mut remaining_args: ~[~str] = args.iter().skip_while(|&s| {\n-        let maybe_command: Option<Command> = from_str(*s);\n-        maybe_command.is_none()\n-    }).map(|s| s.clone()).collect();\n-    remaining_args.shift();\n-\n-    let context = Context{\n-        rustc_flags: rustc_flags,\n-        cfgs: cfgs,\n-        use_rust_path_hack: use_rust_path_hack,\n-    };\n-    Ok(ParseResult {\n-        command:  command,\n-        args: remaining_args,\n-        context: context,\n-        sysroot: supplied_sysroot\n-    })\n-}"}, {"sha": "908e5e5c3810f5fd638a0c132e825ac764627318", "filename": "src/librustpkg/path_util.rs", "status": "removed", "additions": 0, "deletions": 426, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,426 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg utilities having to do with paths and directories\n-\n-#[allow(dead_code)];\n-\n-pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, split_version_general};\n-pub use rustc::metadata::filesearch::rust_path;\n-\n-use std::libc;\n-use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-use std::os;\n-use std::io;\n-use std::io::fs;\n-use syntax::crateid::CrateId;\n-use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n-use rustc::driver::driver::host_triple;\n-use messages::*;\n-\n-pub fn default_workspace() -> Path {\n-    let p = rust_path();\n-    if p.is_empty() {\n-        fail!(\"Empty RUST_PATH\");\n-    }\n-    let result = p[0];\n-    if !result.is_dir() {\n-        fs::mkdir_recursive(&result, io::UserRWX);\n-    }\n-    result\n-}\n-\n-pub fn in_rust_path(p: &Path) -> bool {\n-    rust_path().contains(p)\n-}\n-\n-pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n-\n-/// Creates a directory that is readable, writeable,\n-/// and executable by the user. Returns true iff creation\n-/// succeeded.\n-pub fn make_dir_rwx(p: &Path) -> bool {\n-    io::result(|| fs::mkdir(p, io::UserRWX)).is_ok()\n-}\n-\n-pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n-    io::result(|| fs::mkdir_recursive(p, io::UserRWX)).is_ok()\n-}\n-\n-// n.b. The next three functions ignore the package version right\n-// now. Should fix that.\n-\n-/// True if there's a directory in <workspace> with\n-/// crateid's short name\n-pub fn workspace_contains_crate_id(crateid: &CrateId, workspace: &Path) -> bool {\n-    workspace_contains_crate_id_(crateid, workspace, |p| p.join(\"src\")).is_some()\n-}\n-\n-pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n-// Returns the directory it was actually found in\n-             workspace_to_src_dir: |&Path| -> Path) -> Option<Path> {\n-    if !workspace.is_dir() {\n-        return None;\n-    }\n-\n-    let src_dir = workspace_to_src_dir(workspace);\n-    if !src_dir.is_dir() { return None }\n-\n-    let mut found = None;\n-    for p in fs::walk_dir(&src_dir) {\n-        if p.is_dir() {\n-            if p == src_dir.join(crateid.path.as_slice()) || {\n-                let pf = p.filename_str();\n-                pf.iter().any(|&g| {\n-                    match split_version_general(g, '-') {\n-                        None => false,\n-                        Some((ref might_match, ref vers)) => {\n-                            *might_match == crateid.name\n-                                && (crateid.version == *vers || crateid.version == None)\n-                        }\n-                    }\n-                })\n-            } {\n-                found = Some(p.clone());\n-            }\n-\n-        }\n-    }\n-\n-    if found.is_some() {\n-        debug!(\"Found {} in {}\", crateid.to_str(), workspace.display());\n-    } else {\n-        debug!(\"Didn't find {} in {}\", crateid.to_str(), workspace.display());\n-    }\n-    found\n-}\n-\n-/// Return the target-specific build subdirectory, pushed onto `base`;\n-/// doesn't check that it exists or create it\n-pub fn target_build_dir(workspace: &Path) -> Path {\n-    let mut dir = workspace.join(\"build\");\n-    dir.push(host_triple());\n-    dir\n-}\n-\n-/// Return the target-specific lib subdirectory, pushed onto `base`;\n-/// doesn't check that it exists or create it\n-fn target_lib_dir(workspace: &Path) -> Path {\n-    let mut dir = workspace.join(libdir());\n-    dir.push(host_triple());\n-    dir\n-}\n-\n-/// Return the bin subdirectory, pushed onto `base`;\n-/// doesn't check that it exists or create it\n-/// note: this isn't target-specific\n-fn target_bin_dir(workspace: &Path) -> Path {\n-    workspace.join(\"bin\")\n-}\n-\n-/// Figure out what the executable name for <crateid> in <workspace>'s build\n-/// directory is, and if the file exists, return it.\n-pub fn built_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    let mut result = target_build_dir(workspace);\n-    result = mk_output_path(Main, Build, crateid, result);\n-    debug!(\"built_executable_in_workspace: checking whether {} exists\",\n-           result.display());\n-    if result.exists() {\n-        Some(result)\n-    }\n-    else {\n-        debug!(\"built_executable_in_workspace: {} does not exist\", result.display());\n-        None\n-    }\n-}\n-\n-/// Figure out what the test name for <crateid> in <workspace>'s build\n-/// directory is, and if the file exists, return it.\n-pub fn built_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(crateid, workspace, Test)\n-}\n-\n-/// Figure out what the test name for <crateid> in <workspace>'s build\n-/// directory is, and if the file exists, return it.\n-pub fn built_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(crateid, workspace, Bench)\n-}\n-\n-fn output_in_workspace(crateid: &CrateId, workspace: &Path, what: OutputType) -> Option<Path> {\n-    let mut result = target_build_dir(workspace);\n-    // should use a target-specific subdirectory\n-    result = mk_output_path(what, Build, crateid, result);\n-    debug!(\"output_in_workspace: checking whether {} exists\",\n-           result.display());\n-    if result.exists() {\n-        Some(result)\n-    }\n-    else {\n-        error!(\"output_in_workspace: {} does not exist\", result.display());\n-        None\n-    }\n-}\n-\n-/// Figure out what the library name for <crateid> in <workspace>'s build\n-/// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(crateid, Build, workspace)\n-}\n-\n-/// Does the actual searching stuff\n-pub fn installed_library_in_workspace(crate_id: &CrateId, workspace: &Path) -> Option<Path> {\n-    // This could break once we're handling multiple versions better -- I should add a test for it\n-    let path = Path::new(crate_id.path.as_slice());\n-    match path.filename_str() {\n-        None => None,\n-        Some(_short_name) => library_in_workspace(crate_id, Install, workspace)\n-    }\n-}\n-\n-/// `workspace` is used to figure out the directory to search.\n-/// `name` is taken as the link name of the library.\n-pub fn library_in_workspace(crate_id: &CrateId, where: Target, workspace: &Path) -> Option<Path> {\n-    debug!(\"library_in_workspace: checking whether a library named {} exists\",\n-           crate_id.name);\n-\n-    let dir_to_search = match where {\n-        Build => target_build_dir(workspace).join(crate_id.path.as_slice()),\n-        Install => target_lib_dir(workspace)\n-    };\n-\n-    library_in(crate_id, &dir_to_search)\n-}\n-\n-pub fn system_library(sysroot: &Path, crate_id: &CrateId) -> Option<Path> {\n-    library_in(crate_id, &sysroot.join(relative_target_lib_path(host_triple())))\n-}\n-\n-fn library_in(crate_id: &CrateId, dir_to_search: &Path) -> Option<Path> {\n-    let version_str = match crate_id.version {\n-        Some(ref v) => format!(\"-{}\", *v),\n-        None => ~\"\",\n-    };\n-    let patterns = ~[\n-        (format!(\"lib{}\", crate_id.name), format!(\"{}.rlib\", version_str)),\n-        (format!(\"{}{}\", os::consts::DLL_PREFIX, crate_id.name),\n-         format!(\"{}{}\", version_str, os::consts::DLL_SUFFIX)),\n-    ];\n-\n-    for (prefix, suffix) in patterns.move_iter() {\n-        let files = match io::result(|| fs::readdir(dir_to_search)) {\n-            Ok(dir) => dir, Err(..) => continue,\n-        };\n-        for file in files.move_iter() {\n-            let filename = match file.filename_str() {\n-                Some(s) => s, None => continue,\n-            };\n-            if filename.starts_with(prefix) && filename.ends_with(suffix) {\n-                return Some(file.clone())\n-            }\n-        }\n-    }\n-    debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n-           dir_to_search.display(), crate_id.to_str());\n-    return None;\n-}\n-\n-/// Returns the executable that would be installed for <crateid>\n-/// in <workspace>\n-/// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n-    target_file_in_workspace(crateid, workspace, Main, Install)\n-}\n-\n-\n-/// Returns the executable that would be installed for <crateid>\n-/// in <workspace>\n-/// As a side effect, creates the lib-dir if it doesn't exist\n-pub fn target_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n-    use conditions::bad_path::cond;\n-    if !workspace.is_dir() {\n-        cond.raise(((*workspace).clone(),\n-                    format!(\"Workspace supplied to target_library_in_workspace \\\n-                             is not a directory! {}\", workspace.display())));\n-    }\n-    target_file_in_workspace(crateid, workspace, Lib, Install)\n-}\n-\n-/// Returns the test executable that would be installed for <crateid>\n-/// in <workspace>\n-/// note that we *don't* install test executables, so this is just for unit testing\n-pub fn target_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n-    target_file_in_workspace(crateid, workspace, Test, Install)\n-}\n-\n-/// Returns the bench executable that would be installed for <crateid>\n-/// in <workspace>\n-/// note that we *don't* install bench executables, so this is just for unit testing\n-pub fn target_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n-    target_file_in_workspace(crateid, workspace, Bench, Install)\n-}\n-\n-\n-/// Returns the path that crateid `crateid` would have if placed `where`\n-/// in `workspace`\n-fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n-                            what: OutputType, where: Target) -> Path {\n-    use conditions::bad_path::cond;\n-\n-    let subdir = match what {\n-        Lib => \"lib\", Main | Test | Bench => \"bin\"\n-    };\n-    // Artifacts in the build directory live in a package-ID-specific subdirectory,\n-    // but installed ones don't.\n-    let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join(crateid.path.as_slice()),\n-                (Install, Lib)  => target_lib_dir(workspace),\n-                (Install, _)    => target_bin_dir(workspace)\n-    };\n-    if io::result(|| fs::mkdir_recursive(&result, io::UserRWX)).is_err() {\n-        cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n-            create the {} dir (crateid={}, workspace={}, what={:?}, where={:?}\",\n-            subdir, crateid.to_str(), workspace.display(), what, where)));\n-    }\n-    mk_output_path(what, where, crateid, result)\n-}\n-\n-/// Return the directory for <crateid>'s build artifacts in <workspace>.\n-/// Creates it if it doesn't exist.\n-pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n-    let mut result = target_build_dir(workspace);\n-    result.push(crateid.path.as_slice());\n-    debug!(\"Creating build dir {} for package id {}\", result.display(),\n-           crateid.to_str());\n-    fs::mkdir_recursive(&result, io::UserRWX);\n-    return result;\n-}\n-\n-/// Return the output file for a given directory name,\n-/// given whether we're building a library and whether we're building tests\n-pub fn mk_output_path(what: OutputType, where: Target,\n-                      crate_id: &CrateId, workspace: Path) -> Path {\n-    let short_name_with_version = crate_id.short_name_with_version();\n-    // Not local_path.dir_path()! For package foo/bar/blat/, we want\n-    // the executable blat-0.5 to live under blat/\n-    let dir = match where {\n-        // If we're installing, it just goes under <workspace>...\n-        Install => workspace,\n-        // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.join(crate_id.path.as_slice())\n-    };\n-    debug!(\"[{:?}:{:?}] mk_output_path: name = {}, path = {}\", what, where,\n-           if what == Lib { short_name_with_version.clone() } else { crate_id.name.clone() },\n-           dir.display());\n-    let mut output_path = match what {\n-        // this code is duplicated from elsewhere; fix this\n-        Lib => dir.join(os::dll_filename(short_name_with_version)),\n-        // executable names *aren't* versioned\n-        _ => dir.join(format!(\"{}{}{}\", crate_id.name,\n-                           match what {\n-                               Test => \"test\",\n-                               Bench => \"bench\",\n-                               _     => \"\"\n-                           },\n-                           os::consts::EXE_SUFFIX))\n-    };\n-    if !output_path.is_absolute() {\n-        output_path = os::getcwd().join(&output_path);\n-    }\n-    debug!(\"mk_output_path: returning {}\", output_path.display());\n-    output_path\n-}\n-\n-/// Removes files for the package `crateid`, assuming it's installed in workspace `workspace`\n-pub fn uninstall_package_from(workspace: &Path, crateid: &CrateId) {\n-    let mut did_something = false;\n-    let installed_bin = target_executable_in_workspace(crateid, workspace);\n-    if installed_bin.exists() {\n-        fs::unlink(&installed_bin);\n-        did_something = true;\n-    }\n-    let installed_lib = target_library_in_workspace(crateid, workspace);\n-    if installed_lib.exists() {\n-        fs::unlink(&installed_lib);\n-        did_something = true;\n-    }\n-    if !did_something {\n-        warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n-             crateid.to_str(), workspace.display()));\n-    }\n-\n-}\n-\n-pub fn dir_has_crate_file(dir: &Path) -> bool {\n-    dir_has_file(dir, \"lib.rs\") || dir_has_file(dir, \"main.rs\")\n-        || dir_has_file(dir, \"test.rs\") || dir_has_file(dir, \"bench.rs\")\n-}\n-\n-fn dir_has_file(dir: &Path, file: &str) -> bool {\n-    assert!(dir.is_absolute());\n-    dir.join(file).exists()\n-}\n-\n-pub fn find_dir_using_rust_path_hack(p: &CrateId) -> Option<Path> {\n-    let rp = rust_path();\n-    let path = Path::new(p.path.as_slice());\n-    for dir in rp.iter() {\n-        // Require that the parent directory match the package ID\n-        // Note that this only matches if the package ID being searched for\n-        // has a name that's a single component\n-        if dir.ends_with_path(&path) || dir.ends_with_path(&versionize(p.path, &p.version)) {\n-            debug!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n-            if dir_has_crate_file(dir) {\n-                debug!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n-                return Some(dir.clone());\n-            }\n-        }\n-        debug!(\"Didn't find id {} in dir {}\", p.to_str(), dir.display())\n-    }\n-    None\n-}\n-\n-/// True if the user set RUST_PATH to something non-empty --\n-/// as opposed to the default paths that rustpkg adds automatically\n-pub fn user_set_rust_path() -> bool {\n-    match os::getenv(\"RUST_PATH\") {\n-        None | Some(~\"\") => false,\n-        Some(_)         => true\n-    }\n-}\n-\n-/// Append the version string onto the end of the path's filename\n-pub fn versionize(p: &str, v: &Version) -> Path {\n-    let p = Path::new(p);\n-    let q = p.filename().expect(\"path is a directory\");\n-    let mut q = q.to_owned();\n-    q.push('-' as u8);\n-    let vs = match v { &Some(ref s) => s.to_owned(), &None => ~\"0.0\" };\n-    q.push_all(vs.as_bytes());\n-    p.with_filename(q)\n-}\n-\n-#[cfg(target_os = \"win32\")]\n-pub fn chmod_read_only(p: &Path) -> bool {\n-    unsafe {\n-        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int)\n-    }\n-}\n-\n-#[cfg(not(target_os = \"win32\"))]\n-pub fn chmod_read_only(p: &Path) -> bool {\n-    unsafe {\n-        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0 as libc::c_int)\n-    }\n-}\n-\n-pub fn platform_library_name(s: &str) -> ~str {\n-    format!(\"{}{}{}\", os::consts::DLL_PREFIX, s, os::consts::DLL_SUFFIX)\n-}"}, {"sha": "255172e0988a67a20864b146dca0c0c126c3651c", "filename": "src/librustpkg/sha1.rs", "status": "removed", "additions": 0, "deletions": 633, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,633 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * An implementation of the SHA-1 cryptographic hash.\n- *\n- * First create a `sha1` object using the `sha1` constructor, then\n- * feed it input using the `input` or `input_str` methods, which may be\n- * called any number of times.\n- *\n- * After the entire input has been fed to the hash read the result using\n- * the `result` or `result_str` methods.\n- *\n- * The `sha1` object may be reused to create multiple hashes by calling\n- * the `reset` method.\n- *\n- * This implementation has not been reviewed for cryptographic uses.\n- * As such, all cryptographic uses of this implementation are strongly\n- * discouraged.\n- */\n-\n-use std::num::Zero;\n-use std::vec;\n-use std::vec::bytes::{MutableByteVector, copy_memory};\n-use extra::hex::ToHex;\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n-/// format.\n-fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be32(input as i32);\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n-fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        for _ in range(0, dst.len()) {\n-            *x = to_be32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n-trait ToBits {\n-    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n-    /// high-order value and the 2nd item is the low order value.\n-    fn to_bits(self) -> (Self, Self);\n-}\n-\n-impl ToBits for u64 {\n-    fn to_bits(self) -> (u64, u64) {\n-        return (self >> 61, self << 3);\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n-/// overflow.\n-fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-\n-    if new_high_bits > Zero::zero() {\n-        fail!(\"Numeric overflow occured.\")\n-    }\n-\n-    match bits.checked_add(&new_low_bits) {\n-        Some(x) => return x,\n-        None => fail!(\"Numeric overflow occured.\")\n-    }\n-}\n-\n-/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n-/// must be processed. The input() method takes care of processing and then clearing the buffer\n-/// automatically. However, other methods do not and require the caller to process the buffer. Any\n-/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n-/// results in those bytes being marked as used by the buffer.\n-trait FixedBuffer {\n-    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n-    /// function and then clear the buffer.\n-    fn input(&mut self, input: &[u8], func: |&[u8]|);\n-\n-    /// Reset the buffer.\n-    fn reset(&mut self);\n-\n-    /// Zero the buffer up until the specified index. The buffer position currently must not be\n-    /// greater than that index.\n-    fn zero_until(&mut self, idx: uint);\n-\n-    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n-    /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n-\n-    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n-\n-    /// Get the current position of the buffer.\n-    fn position(&self) -> uint;\n-\n-    /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> uint;\n-\n-    /// Get the size of the buffer\n-    fn size(&self) -> uint;\n-}\n-\n-/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n-struct FixedBuffer64 {\n-    priv buffer: [u8, ..64],\n-    priv buffer_idx: uint,\n-}\n-\n-impl FixedBuffer64 {\n-    /// Create a new buffer\n-    fn new() -> FixedBuffer64 {\n-        return FixedBuffer64 {\n-            buffer: [0u8, ..64],\n-            buffer_idx: 0\n-        };\n-    }\n-}\n-\n-impl FixedBuffer for FixedBuffer64 {\n-    fn input(&mut self, input: &[u8], func: |&[u8]|) {\n-        let mut i = 0;\n-\n-        let size = 64;\n-\n-        // If there is already data in the buffer, copy as much as we can into it and process\n-        // the data if the buffer becomes full.\n-        if self.buffer_idx != 0 {\n-            let buffer_remaining = size - self.buffer_idx;\n-            if input.len() >= buffer_remaining {\n-                    copy_memory(\n-                        self.buffer.mut_slice(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining));\n-                self.buffer_idx = 0;\n-                func(self.buffer);\n-                i += buffer_remaining;\n-            } else {\n-                copy_memory(\n-                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                    input);\n-                self.buffer_idx += input.len();\n-                return;\n-            }\n-        }\n-\n-        // While we have at least a full buffer size chunks's worth of data, process that data\n-        // without copying it into the buffer\n-        while input.len() - i >= size {\n-            func(input.slice(i, i + size));\n-            i += size;\n-        }\n-\n-        // Copy any input data into the buffer. At this point in the method, the ammount of\n-        // data left in the input vector will be less than the buffer size and the buffer will\n-        // be empty.\n-        let input_remaining = input.len() - i;\n-        copy_memory(\n-            self.buffer.mut_slice(0, input_remaining),\n-            input.slice_from(i));\n-        self.buffer_idx += input_remaining;\n-    }\n-\n-    fn reset(&mut self) {\n-        self.buffer_idx = 0;\n-    }\n-\n-    fn zero_until(&mut self, idx: uint) {\n-        assert!(idx >= self.buffer_idx);\n-        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n-        self.buffer_idx = idx;\n-    }\n-\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n-        self.buffer_idx += len;\n-        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n-    }\n-\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-        assert!(self.buffer_idx == 64);\n-        self.buffer_idx = 0;\n-        return self.buffer.slice_to(64);\n-    }\n-\n-    fn position(&self) -> uint { self.buffer_idx }\n-\n-    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n-\n-    fn size(&self) -> uint { 64 }\n-}\n-\n-/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n-/// struct.\n-trait StandardPadding {\n-    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n-    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n-    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n-    /// filled with zeros again until only rem bytes are remaining.\n-    fn standard_padding(&mut self, rem: uint, func: |&[u8]|);\n-}\n-\n-impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding(&mut self, rem: uint, func: |&[u8]|) {\n-        let size = self.size();\n-\n-        self.next(1)[0] = 128;\n-\n-        if self.remaining() < rem {\n-            self.zero_until(size);\n-            func(self.full_buffer());\n-        }\n-\n-        self.zero_until(size - rem);\n-    }\n-}\n-\n-/**\n- * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n- * family of digest functions.\n- */\n-pub trait Digest {\n-    /**\n-     * Provide message data.\n-     *\n-     * # Arguments\n-     *\n-     * * input - A vector of message data\n-     */\n-    fn input(&mut self, input: &[u8]);\n-\n-    /**\n-     * Retrieve the digest result. This method may be called multiple times.\n-     *\n-     * # Arguments\n-     *\n-     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n-     */\n-    fn result(&mut self, out: &mut [u8]);\n-\n-    /**\n-     * Reset the digest. This method must be called after result() and before supplying more\n-     * data.\n-     */\n-    fn reset(&mut self);\n-\n-    /**\n-     * Get the output size in bits.\n-     */\n-    fn output_bits(&self) -> uint;\n-\n-    /**\n-     * Convenience function that feeds a string into a digest.\n-     *\n-     * # Arguments\n-     *\n-     * * `input` The string to feed into the digest\n-     */\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * newly allocated vec of bytes.\n-     */\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n-        self.result(buf);\n-        buf\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * ~str in hexadecimal format.\n-     */\n-    fn result_str(&mut self) -> ~str {\n-        self.result_bytes().to_hex()\n-    }\n-}\n-\n-/*\n- * A SHA-1 implementation derived from Paul E. Jones's reference\n- * implementation, which is written for clarity, not speed. At some\n- * point this will want to be rewritten.\n- */\n-\n-// Some unexported constants\n-static DIGEST_BUF_LEN: uint = 5u;\n-static WORK_BUF_LEN: uint = 80u;\n-static K0: u32 = 0x5A827999u32;\n-static K1: u32 = 0x6ED9EBA1u32;\n-static K2: u32 = 0x8F1BBCDCu32;\n-static K3: u32 = 0xCA62C1D6u32;\n-\n-/// Structure representing the state of a Sha1 computation\n-pub struct Sha1 {\n-    priv h: [u32, ..DIGEST_BUF_LEN],\n-    priv length_bits: u64,\n-    priv buffer: FixedBuffer64,\n-    priv computed: bool,\n-}\n-\n-fn add_input(st: &mut Sha1, msg: &[u8]) {\n-    assert!((!st.computed));\n-    // Assumes that msg.len() can be converted to u64 without overflow\n-    st.length_bits = add_bytes_to_bits(st.length_bits, msg.len() as u64);\n-    st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n-}\n-\n-fn process_msg_block(data: &[u8], h: &mut [u32, ..DIGEST_BUF_LEN]) {\n-    let mut t: int; // Loop counter\n-\n-    let mut w = [0u32, ..WORK_BUF_LEN];\n-\n-    // Initialize the first 16 words of the vector w\n-    read_u32v_be(w.mut_slice(0, 16), data);\n-\n-    // Initialize the rest of vector w\n-    t = 16;\n-    while t < 80 {\n-        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n-        w[t] = circular_shift(1, val);\n-        t += 1;\n-    }\n-    let mut a = h[0];\n-    let mut b = h[1];\n-    let mut c = h[2];\n-    let mut d = h[3];\n-    let mut e = h[4];\n-    let mut temp: u32;\n-    t = 0;\n-    while t < 20 {\n-        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 40 {\n-        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 60 {\n-        temp =\n-            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n-                K2;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 80 {\n-        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    h[0] += a;\n-    h[1] += b;\n-    h[2] += c;\n-    h[3] += d;\n-    h[4] += e;\n-}\n-\n-fn circular_shift(bits: u32, word: u32) -> u32 {\n-    return word << bits | word >> 32u32 - bits;\n-}\n-\n-fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n-    if !st.computed {\n-        st.buffer.standard_padding(8, |d: &[u8]| { process_msg_block(d, &mut st.h) });\n-        write_u32_be(st.buffer.next(4), (st.length_bits >> 32) as u32 );\n-        write_u32_be(st.buffer.next(4), st.length_bits as u32);\n-        process_msg_block(st.buffer.full_buffer(), &mut st.h);\n-\n-        st.computed = true;\n-    }\n-\n-    write_u32_be(rs.mut_slice(0, 4), st.h[0]);\n-    write_u32_be(rs.mut_slice(4, 8), st.h[1]);\n-    write_u32_be(rs.mut_slice(8, 12), st.h[2]);\n-    write_u32_be(rs.mut_slice(12, 16), st.h[3]);\n-    write_u32_be(rs.mut_slice(16, 20), st.h[4]);\n-}\n-\n-impl Sha1 {\n-    /// Construct a `sha` object\n-    pub fn new() -> Sha1 {\n-        let mut st = Sha1 {\n-            h: [0u32, ..DIGEST_BUF_LEN],\n-            length_bits: 0u64,\n-            buffer: FixedBuffer64::new(),\n-            computed: false,\n-        };\n-        st.reset();\n-        return st;\n-    }\n-}\n-\n-impl Digest for Sha1 {\n-    fn reset(&mut self) {\n-        self.length_bits = 0;\n-        self.h[0] = 0x67452301u32;\n-        self.h[1] = 0xEFCDAB89u32;\n-        self.h[2] = 0x98BADCFEu32;\n-        self.h[3] = 0x10325476u32;\n-        self.h[4] = 0xC3D2E1F0u32;\n-        self.buffer.reset();\n-        self.computed = false;\n-    }\n-    fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n-    fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n-    fn output_bits(&self) -> uint { 160 }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::num::Bounded;\n-    use std::rand::{IsaacRng, Rng};\n-    use std::vec;\n-    use extra::hex::FromHex;\n-    use super::{Digest, Sha1, add_bytes_to_bits};\n-\n-    #[deriving(Clone)]\n-    struct Test {\n-        input: ~str,\n-        output: ~[u8],\n-        output_str: ~str,\n-    }\n-\n-    #[test]\n-    fn test() {\n-        // Test messages from FIPS 180-1\n-\n-        let fips_180_1_tests = ~[\n-            Test {\n-                input: ~\"abc\",\n-                output: ~[\n-                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                ],\n-                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-            },\n-            Test {\n-                input:\n-                     ~\"abcdbcdecdefdefgefghfghighij\" +\n-                     \"hijkijkljklmklmnlmnomnopnopq\",\n-                output: ~[\n-                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                ],\n-                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-            },\n-        ];\n-        // Examples from wikipedia\n-\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output: ~[\n-                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                ],\n-                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy cog\",\n-                output: ~[\n-                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                ],\n-                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-            },\n-        ];\n-        let tests = fips_180_1_tests + wikipedia_tests;\n-\n-        // Test that it works when accepting the message all at once\n-\n-        let mut out = [0u8, ..20];\n-\n-        let mut sh = ~Sha1::new();\n-        for t in tests.iter() {\n-            (*sh).input_str(t.input);\n-            sh.result(out);\n-            assert!(t.output.as_slice() == out);\n-\n-            let out_str = (*sh).result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                (*sh).input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-            sh.result(out);\n-            assert!(t.output.as_slice() == out);\n-\n-            let out_str = (*sh).result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n-    /// correct.\n-    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n-        let total_size = 1000000;\n-        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n-        let mut rng = IsaacRng::new_unseeded();\n-        let mut count = 0;\n-\n-        digest.reset();\n-\n-        while count < total_size {\n-            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n-            let remaining = total_size - count;\n-            let size = if next > remaining { remaining } else { next };\n-            digest.input(buffer.slice_to(size));\n-            count += size;\n-        }\n-\n-        let result_str = digest.result_str();\n-        let result_bytes = digest.result_bytes();\n-\n-        assert_eq!(expected, result_str.as_slice());\n-        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha1() {\n-        let mut sh = Sha1::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n-    }\n-\n-    // A normal addition - no overflow occurs\n-    #[test]\n-    fn test_add_bytes_to_bits_ok() {\n-        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_overflow() {\n-        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use extra::test::BenchHarness;\n-    use super::Sha1;\n-\n-    #[bench]\n-    pub fn sha1_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..10];\n-        bh.iter(|| sh.input(bytes));\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha1_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..1024];\n-        bh.iter(|| sh.input(bytes));\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha1_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..65536];\n-        bh.iter(|| sh.input(bytes));\n-        bh.bytes = bytes.len() as u64;\n-    }\n-}"}, {"sha": "2346749feb53a0da3a0516dc8f2bc2236a1f4fa5", "filename": "src/librustpkg/source_control.rs", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,148 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Utils for working with version control repositories. Just git right now.\n-\n-use std::{run, str};\n-use std::run::{ProcessOutput, ProcessOptions, Process};\n-use std::io::fs;\n-use extra::tempfile::TempDir;\n-use path_util::chmod_read_only;\n-\n-/// Attempts to clone `source`, a local git repository, into `target`, a local\n-/// directory that doesn't exist.\n-/// Returns `DirToUse(p)` if the clone fails, where `p` is a newly created temporary\n-/// directory (that the callee may use, for example, to check out remote sources into).\n-/// Returns `CheckedOutSources` if the clone succeeded.\n-pub fn safe_git_clone(source: &Path, v: &Option<~str>, target: &Path) -> CloneResult {\n-    if source.exists() {\n-        debug!(\"{} exists locally! Cloning it into {}\",\n-                source.display(), target.display());\n-        // Ok to use target here; we know it will succeed\n-        assert!(source.is_dir());\n-        assert!(is_git_dir(source));\n-\n-        if !target.exists() {\n-            debug!(\"Running: git clone {} {}\", source.display(), target.display());\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            let opt_outp = run::process_output(\"git\", [~\"clone\",\n-                                                       source.as_str().unwrap().to_owned(),\n-                                                       target.as_str().unwrap().to_owned()]);\n-            let outp = opt_outp.expect(\"Failed to exec `git`\");\n-            if !outp.status.success() {\n-                println!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n-                println!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n-                return DirToUse(target.clone());\n-            }\n-            else {\n-                match v {\n-                    &Some(ref s) => {\n-                        let git_dir = target.join(\".git\");\n-                        debug!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n-                                *s, target.display(), git_dir.display());\n-                        // FIXME (#9639: This needs to handle non-utf8 paths\n-                        let outp = run::process_output(\"git\",\n-                            [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n-                             format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n-                             ~\"checkout\", format!(\"{}\", *s)]).expect(\"Failed to exec `git`\");\n-                        if !outp.status.success() {\n-                            println!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n-                            println!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n-                            return DirToUse(target.clone());\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        } else {\n-            // Check that no version was specified. There's no reason to not handle the\n-            // case where a version was requested, but I haven't implemented it.\n-            assert!(*v == None);\n-            let git_dir = target.join(\".git\");\n-            debug!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n-                    target.display(), git_dir.display(), source.display());\n-            // FIXME (#9639: This needs to handle non-utf8 paths\n-            let args = [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n-                        format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n-                        ~\"pull\", ~\"--no-edit\", source.as_str().unwrap().to_owned()];\n-            let opt_outp = run::process_output(\"git\", args);\n-            let outp = opt_outp.expect(\"Failed to exec `git`\");\n-            assert!(outp.status.success());\n-        }\n-        CheckedOutSources\n-    } else {\n-        use conditions::failed_to_create_temp_dir::cond;\n-\n-        let scratch_dir = TempDir::new(\"rustpkg\");\n-        let clone_target = match scratch_dir {\n-            Some(d) => d.unwrap().join(\"rustpkg_temp\"),\n-            None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n-        };\n-\n-        DirToUse(clone_target)\n-    }\n-}\n-\n-pub enum CloneResult {\n-    DirToUse(Path), // Created this empty directory to use as the temp dir for git\n-    CheckedOutSources // Successfully checked sources out into the given target dir\n-}\n-\n-pub fn make_read_only(target: &Path) {\n-    // Now, make all the files in the target dir read-only\n-    for p in fs::walk_dir(target) {\n-        if !p.is_dir() {\n-            assert!(chmod_read_only(&p));\n-        }\n-    }\n-}\n-\n-/// Source can be either a URL or a local file path.\n-pub fn git_clone_url(source: &str, target: &Path, v: &Option<~str>) {\n-    use conditions::git_checkout_failed::cond;\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let opt_outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n-                                               target.as_str().unwrap().to_owned()]);\n-    let outp = opt_outp.expect(\"Failed to exec `git`\");\n-    if !outp.status.success() {\n-         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n-         debug!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n-         cond.raise((source.to_owned(), target.clone()))\n-    }\n-    else {\n-        match v {\n-            &Some(ref s) => {\n-                    let opt_outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n-                                                         target);\n-                    let outp = opt_outp.expect(\"Failed to exec `git`\");\n-                    if !outp.status.success() {\n-                        debug!(\"{}\", str::from_utf8_owned(outp.output.clone()).unwrap());\n-                        debug!(\"{}\", str::from_utf8_owned(outp.error).unwrap());\n-                        cond.raise((source.to_owned(), target.clone()))\n-                    }\n-            }\n-            _ => ()\n-        }\n-    }\n-}\n-\n-fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> Option<ProcessOutput> {\n-    let mut opt_prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n-                                    ,..ProcessOptions::new()});\n-    match opt_prog {\n-        Some(ref mut prog) => Some(prog.finish_with_output()),\n-        None => None\n-    }\n-}\n-\n-pub fn is_git_dir(p: &Path) -> bool {\n-    p.join(\".git\").is_dir()\n-}"}, {"sha": "73c305be798e259f89745df36372cd696fd3ad74", "filename": "src/librustpkg/target.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// Data types that express build artifacts\n-\n-#[deriving(Eq)]\n-pub enum OutputType { Main, Lib, Bench, Test }\n-\n-#[deriving(Eq)]\n-pub enum Target {\n-    /// In-place build\n-    Build,\n-    /// Install to bin/ or lib/ dir\n-    Install\n-}\n-\n-#[deriving(Eq, Clone)]\n-pub struct WhatToBuild {\n-    build_type: BuildType, // Whether or not to ignore the pkg.rs file\n-    sources: SourceType, // Which crates to build\n-    inputs_to_discover: ~[(~str, Path)] // Inputs to these crates to be discovered\n-        // (For now all of these inputs will be taken as discovered inputs\n-        // for all of the crates)\n-        // (Paired with their kinds)\n-}\n-\n-impl WhatToBuild {\n-    pub fn new(build_type: BuildType, sources: SourceType) -> WhatToBuild {\n-        WhatToBuild { build_type: build_type,\n-                      sources: sources,\n-                      inputs_to_discover: ~[] }\n-    }\n-}\n-\n-#[deriving(Eq, Clone)]\n-pub enum BuildType {\n-    Inferred, // Ignore the pkg.rs file even if one exists\n-    MaybeCustom // Use the pkg.rs file if it exists\n-}\n-\n-#[deriving(Eq, Clone)]\n-pub enum SourceType {\n-    /// Build just one lib.rs file in `path`, which is relative to the active workspace's src/ dir\n-    JustOne(Path),\n-    /// Build any test.rs files that can be recursively found in the active workspace\n-    Tests,\n-    /// Build everything\n-    Everything\n-}\n-\n-pub fn is_lib(p: &Path) -> bool {\n-    file_is(p, \"lib\")\n-}\n-\n-pub fn is_main(p: &Path) -> bool {\n-    file_is(p, \"main\")\n-}\n-\n-pub fn is_test(p: &Path) -> bool {\n-    file_is(p, \"test\")\n-}\n-\n-pub fn is_bench(p: &Path) -> bool {\n-    file_is(p, \"bench\")\n-}\n-\n-fn file_is(p: &Path, stem: &str) -> bool {\n-    match p.filestem() {\n-        Some(s) if s == stem.as_bytes() => true,\n-        _ => false\n-    }\n-}\n-\n-#[allow(dead_code)]\n-pub fn lib_name_of(p: &Path) -> Path {\n-    p.join(\"lib.rs\")\n-}\n-\n-pub static lib_crate_filename: &'static str = \"lib.rs\";"}, {"sha": "091399c3fb7de274659d9b6e2b740cd35d7fde64", "filename": "src/librustpkg/tests.rs", "status": "removed", "additions": 0, "deletions": 2407, "changes": 2407, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,2407 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg unit tests\n-\n-use CtxMethods;\n-use context::{BuildContext, Context, RustcFlags};\n-use std::{os, run, str, task};\n-use std::io;\n-use std::io::fs;\n-use std::io::File;\n-use extra::arc::Arc;\n-use extra::arc::RWArc;\n-use extra::tempfile::TempDir;\n-use extra::workcache;\n-use extra::workcache::Database;\n-use extra::treemap::TreeMap;\n-use extra::getopts::groups::getopts;\n-use std::run::ProcessOutput;\n-use installed_packages::list_installed_packages;\n-use syntax::crateid::CrateId;\n-use path_util::{target_executable_in_workspace, target_test_in_workspace,\n-               target_bench_in_workspace, make_dir_rwx,\n-               library_in_workspace, installed_library_in_workspace,\n-               built_bench_in_workspace, built_test_in_workspace,\n-               built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n-               chmod_read_only, platform_library_name};\n-use rustc::back::link::get_cc_prog;\n-use rustc::metadata::filesearch::{rust_path, libdir, rustlibdir};\n-use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n-use syntax::diagnostic;\n-use target::*;\n-use package_source::PkgSrc;\n-use source_control::{CheckedOutSources, DirToUse, safe_git_clone};\n-use exit_codes::{BAD_FLAG_CODE, COPY_FAILED_CODE};\n-\n-fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n-    let context = workcache::Context::new(\n-        RWArc::new(Database::new(workspace.join(\"rustpkg_db.json\"))),\n-        Arc::new(TreeMap::new()));\n-    BuildContext {\n-        workcache_context: context,\n-        context: Context {\n-            cfgs: ~[],\n-            rustc_flags: RustcFlags::default(),\n-\n-            use_rust_path_hack: false,\n-        },\n-        sysroot: sysroot\n-    }\n-}\n-\n-fn fake_pkg() -> CrateId {\n-    CrateId {\n-        path: ~\"bogus\",\n-        name: ~\"bogus\",\n-        version: None\n-    }\n-}\n-\n-fn git_repo_pkg() -> CrateId {\n-    CrateId {\n-        path: ~\"mockgithub.com/catamorphism/test-pkg\",\n-        name: ~\"test-pkg\",\n-        version: None\n-    }\n-}\n-\n-fn writeFile(file_path: &Path, contents: &str) {\n-    let mut out = File::create(file_path);\n-    out.write(contents.as_bytes());\n-    out.write(['\\n' as u8]);\n-}\n-\n-fn mk_emptier_workspace(tag: &str) -> TempDir {\n-    let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n-    let package_dir = workspace.path().join(\"src\");\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-    workspace\n-}\n-\n-fn mk_empty_workspace(crate_id: &CrateId, tag: &str) -> TempDir {\n-    let workspace_dir = TempDir::new(tag).expect(\"couldn't create temp dir\");\n-    mk_workspace(workspace_dir.path(), crate_id);\n-    workspace_dir\n-}\n-\n-fn mk_workspace(workspace: &Path, crate_id: &CrateId) -> Path {\n-    // include version number in directory name\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace.join_many([~\"src\", crate_id.short_name_with_version()]);\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-    package_dir\n-}\n-\n-fn mk_temp_workspace(crate_id: &CrateId) -> (TempDir, Path) {\n-    let workspace_dir = mk_empty_workspace(crate_id, \"temp_workspace\");\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let package_dir = workspace_dir.path().join_many([~\"src\", crate_id.short_name_with_version()]);\n-\n-    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-           package_dir.is_dir());\n-    // Create main, lib, test, and bench files\n-    debug!(\"mk_workspace: creating {}\", package_dir.display());\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-           package_dir.is_dir());\n-    // Create main, lib, test, and bench files\n-\n-    writeFile(&package_dir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    (workspace_dir, package_dir)\n-}\n-\n-fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n-    let cwd = (*cwd).clone();\n-    let mut prog = run::Process::new(\"git\", args, run::ProcessOptions {\n-        env: env,\n-        dir: Some(&cwd),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    }).expect(\"failed to exec `git`\");\n-    let rslt = prog.finish_with_output();\n-    if !rslt.status.success() {\n-        fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n-           rslt.status, str::from_utf8(rslt.output).unwrap(), str::from_utf8(rslt.error).unwrap());\n-    }\n-}\n-\n-/// Should create an empty git repo in p, relative to the tmp dir, and return the new\n-/// absolute path\n-fn init_git_repo(p: &Path) -> TempDir {\n-    assert!(p.is_relative());\n-    let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n-    let work_dir = tmp.path().join(p);\n-    let work_dir_for_opts = work_dir.clone();\n-    fs::mkdir_recursive(&work_dir, io::UserRWX);\n-    debug!(\"Running: git init in {}\", work_dir.display());\n-    run_git([~\"init\"], None, &work_dir_for_opts,\n-        format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n-    // Add stuff to the dir so that git tag succeeds\n-    writeFile(&work_dir.join(\"README\"), \"\");\n-    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, format!(\"Couldn't add in {}\",\n-                                                                work_dir.display()));\n-    git_commit(&work_dir_for_opts, ~\"whatever\");\n-    tmp\n-}\n-\n-fn add_all_and_commit(repo: &Path) {\n-    git_add_all(repo);\n-    git_commit(repo, ~\"floop\");\n-}\n-\n-fn git_commit(repo: &Path, msg: ~str) {\n-    run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n-            None, repo, format!(\"Couldn't commit in {}\", repo.display()));\n-}\n-\n-fn git_add_all(repo: &Path) {\n-    run_git([~\"add\", ~\"-A\"], None, repo, format!(\"Couldn't add all files in {}\", repo.display()));\n-}\n-\n-fn add_git_tag(repo: &Path, tag: ~str) {\n-    assert!(repo.is_absolute());\n-    git_add_all(repo);\n-    git_commit(repo, ~\"whatever\");\n-    run_git([~\"tag\", tag.clone()], None, repo,\n-            format!(\"Couldn't add git tag {} in {}\", tag, repo.display()));\n-}\n-\n-fn is_rwx(p: &Path) -> bool {\n-    if !p.exists() { return false }\n-    p.stat().perm & io::UserRWX == io::UserRWX\n-}\n-\n-fn is_read_only(p: &Path) -> bool {\n-    if !p.exists() { return false }\n-    p.stat().perm & io::UserRWX == io::UserRead\n-}\n-\n-fn test_sysroot() -> Path {\n-    // Totally gross hack but it's just for test cases.\n-    // Infer the sysroot from the exe name and pray that it's right.\n-    // (Did I mention it was a gross hack?)\n-    let mut self_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n-    self_path.pop();\n-    self_path\n-}\n-\n-// Returns the path to rustpkg\n-fn rustpkg_exec() -> Path {\n-    // Ugh\n-    let first_try = test_sysroot().join_many(\n-        [libdir(), rustlibdir(), host_triple(), ~\"bin\", ~\"rustpkg\"]);\n-    if is_executable(&first_try) {\n-        first_try\n-    }\n-    else {\n-        let second_try = test_sysroot().join_many([\"bin\", \"rustpkg\"]);\n-        if is_executable(&second_try) {\n-            second_try\n-        }\n-        else {\n-            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n-        }\n-    }\n-}\n-\n-fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n-    match command_line_test_with_env(args, cwd, None) {\n-        Success(r) => r,\n-        Fail(error) => fail!(\"Command line test failed with error {}\",\n-                             error.status)\n-    }\n-}\n-\n-fn command_line_test_partial(args: &[~str], cwd: &Path) -> ProcessResult {\n-    command_line_test_with_env(args, cwd, None)\n-}\n-\n-fn command_line_test_expect_fail(args: &[~str],\n-                                 cwd: &Path,\n-                                 env: Option<~[(~str, ~str)]>,\n-                                 expected_exitcode: int) {\n-    match command_line_test_with_env(args, cwd, env) {\n-        Success(_) => fail!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n-        Fail(ref error) if error.status.matches_exit_status(expected_exitcode) => (), // ok\n-        Fail(other) => fail!(\"Expected to fail with {}, but failed with {} instead\",\n-                              expected_exitcode, other.status)\n-    }\n-}\n-\n-enum ProcessResult {\n-    Success(ProcessOutput),\n-    Fail(ProcessOutput)\n-}\n-\n-/// Runs `rustpkg` (based on the directory that this executable was\n-/// invoked from) with the given arguments, in the given working directory.\n-/// Returns the process's output.\n-fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n-    -> ProcessResult {\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let exec_path = rustpkg_exec();\n-    let cmd = exec_path.as_str().unwrap().to_owned();\n-    let env_str = match env {\n-        Some(ref pairs) => pairs.map(|&(ref k, ref v)| { format!(\"{}={}\", *k, *v) }).connect(\",\"),\n-        None        => ~\"\"\n-    };\n-    debug!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n-    assert!(cwd.is_dir());\n-    let cwd = (*cwd).clone();\n-    let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n-        env: env.map(|e| e + os::env()),\n-        dir: Some(&cwd),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    }).expect(format!(\"failed to exec `{}`\", cmd));\n-    let output = prog.finish_with_output();\n-    debug!(\"Output from command {} with args {:?} was --- {} \\\\{{}\\\\} --- [{:?}]\",\n-           cmd, args, str::from_utf8(output.output).unwrap(),\n-           str::from_utf8(output.error).unwrap(),\n-           output.status);\n-    if !output.status.success() {\n-        Fail(output)\n-    }\n-    else {\n-        Success(output)\n-    }\n-}\n-\n-fn create_local_package(crateid: &CrateId) -> TempDir {\n-    let (workspace, parent_dir) = mk_temp_workspace(crateid);\n-    debug!(\"Created empty package dir for {}, returning {}\", crateid.to_str(),\n-           parent_dir.display());\n-    workspace\n-}\n-\n-fn create_local_package_in(crateid: &CrateId, pkgdir: &Path) -> Path {\n-\n-    let package_dir = pkgdir.join_many([~\"src\", crateid.short_name_with_version()]);\n-\n-    // Create main, lib, test, and bench files\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-           package_dir.is_dir());\n-    // Create main, lib, test, and bench files\n-\n-    writeFile(&package_dir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    package_dir\n-}\n-\n-fn create_local_package_with_test(crateid: &CrateId) -> TempDir {\n-    debug!(\"Dry run -- would create package {:?} with test\", crateid);\n-    create_local_package(crateid) // Already has tests???\n-}\n-\n-fn create_local_package_with_dep(crateid: &CrateId, subord_crateid: &CrateId) -> TempDir {\n-    let package_dir = create_local_package(crateid);\n-    create_local_package_in(subord_crateid, package_dir.path());\n-    // Write a main.rs file into crateid that references subord_crateid\n-    writeFile(&package_dir.path().join_many([~\"src\",\n-                                             crateid.short_name_with_version(),\n-                                             ~\"main.rs\"]),\n-              format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n-                   subord_crateid.name));\n-    // Write a lib.rs file into subord_crateid that has something in it\n-    writeFile(&package_dir.path().join_many([~\"src\",\n-                                             subord_crateid.short_name_with_version(),\n-                                             ~\"lib.rs\"]),\n-              \"pub fn f() {}\");\n-    package_dir\n-}\n-\n-fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n-                                               custom_build_hook: &str) -> TempDir {\n-    debug!(\"Dry run -- would create package {} with custom build hook {}\",\n-           crateid.to_str(), custom_build_hook);\n-    create_local_package(crateid)\n-    // actually write the pkg.rs with the custom build hook\n-\n-}\n-\n-fn assert_lib_exists(repo: &Path, crate_id: &CrateId) {\n-    assert!(lib_exists(repo, crate_id));\n-}\n-\n-fn lib_exists(repo: &Path, crate_id: &CrateId) -> bool {\n-    debug!(\"assert_lib_exists: repo = {}, crate_id = {}\", repo.display(), crate_id.to_str());\n-    let lib = installed_library_in_workspace(crate_id, repo);\n-    debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n-    lib.is_some() && {\n-        let libname = lib.get_ref();\n-        libname.exists()\n-    }\n-}\n-\n-fn assert_executable_exists(repo: &Path, short_name: &str) {\n-    assert!(executable_exists(repo, short_name));\n-}\n-\n-fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    let crate_id = from_str(short_name).expect(\"valid crate id\");\n-    debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = target_executable_in_workspace(&crate_id, repo);\n-    exec.exists() && is_rwx(&exec)\n-}\n-\n-fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    let crate_id = from_str(short_name).expect(\"valid crate id\");\n-    debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = built_test_in_workspace(&crate_id, repo);\n-    exec.map_or(false, |exec| exec.exists() && is_rwx(&exec))\n-}\n-\n-fn remove_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = target_executable_in_workspace(p, workspace);\n-    if exec.exists() {\n-        fs::unlink(&exec);\n-    }\n-}\n-\n-fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n-    assert!(built_executable_exists(repo, short_name));\n-}\n-\n-fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n-            repo.display(), short_name);\n-    let crate_id = from_str(short_name).expect(\"valid crate id\");\n-    let exec = built_executable_in_workspace(&crate_id, repo);\n-    exec.is_some() && {\n-       let execname = exec.get_ref();\n-       execname.exists() && is_rwx(execname)\n-    }\n-}\n-\n-fn remove_built_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = built_executable_in_workspace(p, workspace);\n-    match exec {\n-        Some(r) => fs::unlink(&r),\n-        None    => ()\n-    }\n-}\n-\n-fn object_file_exists(repo: &Path, short_name: &str) -> bool {\n-    file_exists(repo, short_name, \"o\")\n-}\n-\n-fn assembly_file_exists(repo: &Path, short_name: &str) -> bool {\n-    file_exists(repo, short_name, \"s\")\n-}\n-\n-fn llvm_assembly_file_exists(repo: &Path, short_name: &str) -> bool {\n-    file_exists(repo, short_name, \"ll\")\n-}\n-\n-fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n-    file_exists(repo, short_name, \"bc\")\n-}\n-\n-fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    target_build_dir(repo).join_many([short_name.to_owned(),\n-                                     format!(\"{}.{}\", short_name, extension)])\n-                          .exists()\n-}\n-\n-fn assert_built_library_exists(repo: &Path, short_name: &str) {\n-    assert!(built_library_exists(repo, short_name));\n-}\n-\n-fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let crate_id = from_str(short_name).expect(\"valid crate id\");\n-    let lib = built_library_in_workspace(&crate_id, repo);\n-    lib.is_some() && {\n-        let libname = lib.get_ref();\n-        libname.exists()\n-    }\n-}\n-\n-fn command_line_test_output(args: &[~str]) -> ~[~str] {\n-    let mut result = ~[];\n-    let p_output = command_line_test(args, &os::getcwd());\n-    let test_output = str::from_utf8(p_output.output).unwrap();\n-    for s in test_output.split('\\n') {\n-        result.push(s.to_owned());\n-    }\n-    result\n-}\n-\n-fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~str] {\n-    let mut result = ~[];\n-    let p_output = match command_line_test_with_env(args,\n-        &os::getcwd(), Some(env)) {\n-        Fail(_) => fail!(\"Command-line test failed\"),\n-        Success(r) => r\n-    };\n-    let test_output = str::from_utf8(p_output.output).unwrap();\n-    for s in test_output.split('\\n') {\n-        result.push(s.to_owned());\n-    }\n-    result\n-}\n-\n-// assumes short_name and path are one and the same -- I should fix\n-fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    debug!(\"lib_output_file_name: given {} and short name {}\",\n-           workspace.display(), short_name);\n-    let crate_id = from_str(short_name).expect(\"valid crate id\");\n-    library_in_workspace(&crate_id,\n-                         Build,\n-                         workspace).expect(\"lib_output_file_name\")\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n-    use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n-    let contents = fs::readdir(&pkg_src_dir);\n-    for p in contents.iter() {\n-        if p.extension_str() == Some(\"rs\") {\n-            // should be able to do this w/o a process\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            // n.b. Bumps time up by 2 seconds to get around granularity issues\n-            if !run::process_output(\"touch\", [~\"--date\",\n-                                             ~\"+2 seconds\",\n-                                             p.as_str().unwrap().to_owned()])\n-                .expect(\"failed to exec `touch`\").status.success() {\n-                let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n-    use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n-    let contents = fs::readdir(&pkg_src_dir);\n-    for p in contents.iter() {\n-        if p.extension_str() == Some(\"rs\") {\n-            // should be able to do this w/o a process\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            // n.b. Bumps time up by 2 seconds to get around granularity issues\n-            if !run::process_output(\"touch\", [~\"-A02\",\n-                                             p.as_str().unwrap().to_owned()])\n-                .expect(\"failed to exec `touch`\").status.success() {\n-                let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n-            }\n-        }\n-    }\n-}\n-\n-/// Add a comment at the end\n-fn frob_source_file(workspace: &Path, crateid: &CrateId, filename: &str) {\n-    use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n-    let mut maybe_p = None;\n-    let maybe_file = pkg_src_dir.join(filename);\n-    debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n-    if maybe_file.exists() {\n-        maybe_p = Some(maybe_file);\n-    }\n-    debug!(\"Frobbed? {:?}\", maybe_p);\n-    match maybe_p {\n-        Some(ref p) => {\n-            io::io_error::cond.trap(|e| {\n-                cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n-            }).inside(|| {\n-                let mut w = File::open_mode(p, io::Append, io::Write);\n-                w.write(bytes!(\"/* hi */\\n\"));\n-            })\n-        }\n-        None => fail!(\"frob_source_file failed to find a source file in {}\",\n-                           pkg_src_dir.display())\n-    }\n-}\n-\n-#[test]\n-fn test_make_dir_rwx() {\n-    let temp = &os::tmpdir();\n-    let dir = temp.join(\"quux\");\n-    if dir.exists() {\n-        fs::rmdir_recursive(&dir);\n-    }\n-    debug!(\"Trying to make {}\", dir.display());\n-    assert!(make_dir_rwx(&dir));\n-    assert!(dir.is_dir());\n-    assert!(is_rwx(&dir));\n-    fs::rmdir_recursive(&dir);\n-}\n-\n-// n.b. I ignored the next two tests for now because something funny happens on linux\n-// and I don't want to debug the issue right now (calling into the rustpkg lib directly\n-// is a little sketchy anyway)\n-#[test]\n-#[ignore]\n-fn test_install_valid() {\n-    use path_util::installed_library_in_workspace;\n-\n-    let sysroot = test_sysroot();\n-    debug!(\"sysroot = {}\", sysroot.display());\n-    let temp_pkg_id = fake_pkg();\n-    let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id);\n-    let temp_workspace = temp_workspace.path();\n-    let ctxt = fake_ctxt(sysroot, temp_workspace);\n-    debug!(\"temp_workspace = {}\", temp_workspace.display());\n-    // should have test, bench, lib, and main\n-    let src = PkgSrc::new(temp_workspace.clone(),\n-                          temp_workspace.clone(),\n-                          false,\n-                          temp_pkg_id.clone());\n-    ctxt.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n-    // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"exec = {}\", exec.display());\n-    assert!(exec.exists());\n-    assert!(is_rwx(&exec));\n-\n-    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_or(false, |l| l.exists()));\n-    assert!(lib.as_ref().map_or(false, |l| is_rwx(l)));\n-\n-    // And that the test and bench executables aren't installed\n-    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"bench = {}\", bench.display());\n-    assert!(!bench.exists());\n-\n-    // Make sure the db isn't dirty, so that it doesn't try to save()\n-    // asynchronously after the temporary directory that it wants to save\n-    // to has been deleted.\n-    ctxt.workcache_context.db.write(|db| db.db_dirty = false);\n-}\n-\n-#[test]\n-#[ignore]\n-fn test_install_invalid() {\n-    let sysroot = test_sysroot();\n-    let crateid = fake_pkg();\n-    let temp_workspace = TempDir::new(\"test\").expect(\"couldn't create temp dir\");\n-    let temp_workspace = temp_workspace.path().clone();\n-    let ctxt = fake_ctxt(sysroot, &temp_workspace);\n-\n-    // Uses task::try because of #9001\n-    let result = task::try(proc() {\n-        let pkg_src = PkgSrc::new(temp_workspace.clone(),\n-                                  temp_workspace.clone(),\n-                                  false,\n-                                  crateid.clone());\n-        ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n-    });\n-    assert!(result.unwrap_err()\n-            .to_str().contains(\"supplied path for package dir does not exist\"));\n-}\n-\n-#[test]\n-fn test_install_valid_external() {\n-    let temp_pkg_id: CrateId = from_str(\"foo\").unwrap();\n-    let (tempdir, _) = mk_temp_workspace(&temp_pkg_id);\n-    let temp_workspace = tempdir.path();\n-    command_line_test([~\"install\", ~\"foo\"], temp_workspace);\n-\n-    // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"exec = {}\", exec.display());\n-    assert!(exec.exists());\n-    assert!(is_rwx(&exec));\n-\n-    let lib = installed_library_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_or(false, |l| l.exists()));\n-\n-    // And that the test and bench executables aren't installed\n-    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug!(\"bench = {}\", bench.display());\n-    assert!(!bench.exists());\n-\n-}\n-\n-#[test]\n-#[ignore(reason = \"9994\")]\n-fn test_install_invalid_external() {\n-    let cwd = os::getcwd();\n-    command_line_test_expect_fail([~\"install\", ~\"foo\"],\n-                                  &cwd,\n-                                  None,\n-                                  // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n-                                  COPY_FAILED_CODE);\n-}\n-\n-#[test]\n-fn test_install_git() {\n-    let temp_pkg_id = git_repo_pkg();\n-    let path = Path::new(temp_pkg_id.path.as_slice());\n-    let repo = init_git_repo(&path);\n-    let repo = repo.path();\n-    debug!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug!(\"repo_subdir = {}\", repo_subdir.display());\n-\n-    writeFile(&repo_subdir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n-\n-    debug!(\"test_install_git: calling rustpkg install {} in {}\",\n-           temp_pkg_id.path, repo.display());\n-    // should have test, bench, lib, and main\n-    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n-    let ws = repo.join(\".rust\");\n-    // Check that all files exist\n-    debug!(\"Checking for files in {}\", ws.display());\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"exec = {}\", exec.display());\n-    assert!(exec.exists());\n-    assert!(is_rwx(&exec));\n-    let _built_lib =\n-        built_library_in_workspace(&temp_pkg_id,\n-                                   &ws).expect(\"test_install_git: built lib should exist\");\n-    assert_lib_exists(&ws, &temp_pkg_id);\n-    let built_test = built_test_in_workspace(&temp_pkg_id,\n-                         &ws).expect(\"test_install_git: built test should exist\");\n-    assert!(built_test.exists());\n-    let built_bench = built_bench_in_workspace(&temp_pkg_id,\n-                          &ws).expect(\"test_install_git: built bench should exist\");\n-    assert!(built_bench.exists());\n-    // And that the test and bench executables aren't installed\n-    let test = target_test_in_workspace(&temp_pkg_id, &ws);\n-    assert!(!test.exists());\n-    debug!(\"test = {}\", test.display());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"bench = {}\", bench.display());\n-    assert!(!bench.exists());\n-}\n-\n-#[test]\n-fn test_crate_ids_must_be_relative_path_like() {\n-    /*\n-    Okay:\n-    - One identifier, with no slashes\n-    - Several slash-delimited things, with no / at the root\n-\n-    Not okay:\n-    - Empty string\n-    - Absolute path (as per os::is_absolute)\n-\n-    */\n-\n-    let foo: CrateId = from_str(\"foo\").unwrap();\n-    assert_eq!(~\"foo#0.0\", foo.to_str());\n-    let test_pkg: CrateId = from_str(\"github.com/catamorphism/test-pkg\").unwrap();\n-    assert_eq!(~\"github.com/catamorphism/test-pkg#0.0\", test_pkg.to_str());\n-\n-    let x: Option<CrateId> = from_str(\"\");\n-    assert_eq!(x, None);\n-\n-    let z: Option<CrateId> = from_str(\"/foo/bar/quux\");\n-    assert_eq!(z, None);\n-}\n-\n-#[test]\n-fn test_package_request_version() {\n-    let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n-    let repo = init_git_repo(&Path::new(local_path));\n-    let repo = repo.path();\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n-    debug!(\"Writing files in: {}\", repo_subdir.display());\n-    writeFile(&repo_subdir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    writeFile(&repo_subdir.join(\"version-0.3-file.txt\"), \"hi\");\n-    add_git_tag(&repo_subdir, ~\"0.3\");\n-    writeFile(&repo_subdir.join(\"version-0.4-file.txt\"), \"hello\");\n-    add_git_tag(&repo_subdir, ~\"0.4\");\n-\n-    command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n-\n-    let crate_id = from_str(format!(\"{}\\\\#0.3\", local_path)).unwrap();\n-    assert!(match installed_library_in_workspace(&crate_id,\n-                                                 &repo.join(\".rust\")) {\n-        Some(p) => {\n-            debug!(\"installed: {}\", p.display());\n-            let suffix = format!(\"0.3{}\", os::consts::DLL_SUFFIX);\n-            p.as_vec().ends_with(suffix.as_bytes()) ||\n-                p.as_vec().ends_with(bytes!(\"0.3.rlib\"))\n-        }\n-        None    => false\n-    });\n-    let temp_pkg_id = from_str(\"mockgithub.com/catamorphism/test_pkg_version#0.3\").unwrap();\n-    assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n-            == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n-\n-    let mut dir = target_build_dir(&repo.join(\".rust\"));\n-    dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n-    debug!(\"dir = {}\", dir.display());\n-    assert!(dir.is_dir());\n-    assert!(dir.join(\"version-0.3-file.txt\").exists());\n-    assert!(!dir.join(\"version-0.4-file.txt\").exists());\n-}\n-\n-#[test]\n-#[ignore (reason = \"http-client not ported to rustpkg yet\")]\n-fn rustpkg_install_url_2() {\n-    let temp_dir = TempDir::new(\"rustpkg_install_url_2\").expect(\"rustpkg_install_url_2\");\n-    command_line_test([~\"install\", ~\"github.com/mozilla-servo/rust-http-client\"],\n-                     temp_dir.path());\n-}\n-\n-#[test]\n-fn rustpkg_library_target() {\n-    let foo_repo = init_git_repo(&Path::new(\"foo\"));\n-    let foo_repo = foo_repo.path();\n-    let package_dir = foo_repo.join(\"foo\");\n-\n-    debug!(\"Writing files in: {}\", package_dir.display());\n-    writeFile(&package_dir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    writeFile(&package_dir.join(\"test.rs\"),\n-              \"#[test] pub fn f() { (); }\");\n-    writeFile(&package_dir.join(\"bench.rs\"),\n-              \"#[bench] pub fn f() { (); }\");\n-    add_git_tag(&package_dir, ~\"0.0\");\n-\n-    command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &crate_id);\n-}\n-\n-#[test]\n-fn rustpkg_local_pkg() {\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let dir = create_local_package(&crate_id);\n-    command_line_test([~\"install\", ~\"foo\"], dir.path());\n-    assert_executable_exists(dir.path(), \"foo\");\n-}\n-\n-#[test]\n-#[ignore(reason=\"busted\")]\n-fn package_script_with_default_build() {\n-    let crate_id: CrateId = from_str(\"fancy-lib\").unwrap();\n-    let dir = create_local_package(&crate_id);\n-    let dir = dir.path();\n-    debug!(\"dir = {}\", dir.display());\n-    let mut source = test_sysroot().dir_path();\n-    source.pop(); source.pop();\n-    let source = Path::new(file!()).dir_path().join_many(\n-        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n-    debug!(\"package_script_with_default_build: {}\", source.display());\n-    fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n-    command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &crate_id);\n-    assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n-    let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n-    debug!(\"generated path = {}\", generated_path.display());\n-    assert!(generated_path.exists());\n-}\n-\n-#[test]\n-fn rustpkg_build_no_arg() {\n-    let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n-    let tmp = tmp.path().join(\".rust\");\n-    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-\n-    writeFile(&package_dir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    debug!(\"build_no_arg: dir = {}\", package_dir.display());\n-    command_line_test([~\"build\"], &package_dir);\n-    assert_built_executable_exists(&tmp, \"foo\");\n-}\n-\n-#[test]\n-fn rustpkg_install_no_arg() {\n-    let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n-    let tmp = tmp.path().join(\".rust\");\n-    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-    writeFile(&package_dir.join(\"lib.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    debug!(\"install_no_arg: dir = {}\", package_dir.display());\n-    command_line_test([~\"install\"], &package_dir);\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    assert_lib_exists(&tmp, &crate_id);\n-}\n-\n-#[test]\n-fn rustpkg_clean_no_arg() {\n-    let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n-    let tmp = tmp.path().join(\".rust\");\n-    let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    fs::mkdir_recursive(&package_dir, io::UserRWX);\n-\n-    writeFile(&package_dir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    debug!(\"clean_no_arg: dir = {}\", package_dir.display());\n-    command_line_test([~\"build\"], &package_dir);\n-    assert_built_executable_exists(&tmp, \"foo\");\n-    command_line_test([~\"clean\"], &package_dir);\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let res = built_executable_in_workspace(&crate_id, &tmp);\n-    assert!(!res.as_ref().map_or(false, |m| m.exists()));\n-}\n-\n-#[test]\n-fn rust_path_test() {\n-    let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let dir = mk_workspace(dir_for_path.path(), &crate_id);\n-    debug!(\"dir = {}\", dir.display());\n-    writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n-\n-    let cwd = os::getcwd();\n-    debug!(\"cwd = {}\", cwd.display());\n-                                     // use command_line_test_with_env\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_with_env([~\"install\", ~\"foo\"],\n-                               &cwd,\n-                               Some(~[(~\"RUST_PATH\",\n-                                       dir_for_path.path().as_str().unwrap().to_owned())]));\n-    assert_executable_exists(dir_for_path.path(), \"foo\");\n-}\n-\n-#[test]\n-#[ignore] // FIXME(#9184) tests can't change the cwd (other tests are sad then)\n-fn rust_path_contents() {\n-    let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n-    let abc = &dir.path().join_many([\"A\", \"B\", \"C\"]);\n-    fs::mkdir_recursive(&abc.join(\".rust\"), io::UserRWX);\n-    fs::mkdir_recursive(&abc.with_filename(\".rust\"), io::UserRWX);\n-    fs::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), io::UserRWX);\n-    assert!(os::change_dir(abc));\n-\n-    let p = rust_path();\n-    let cwd = os::getcwd().join(\".rust\");\n-    let parent = cwd.dir_path().with_filename(\".rust\");\n-    let grandparent = cwd.dir_path().dir_path().with_filename(\".rust\");\n-    assert!(p.contains(&cwd));\n-    assert!(p.contains(&parent));\n-    assert!(p.contains(&grandparent));\n-    for a_path in p.iter() {\n-        assert!(a_path.filename().is_some());\n-    }\n-}\n-\n-#[test]\n-fn rust_path_parse() {\n-    os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n-    let paths = rust_path();\n-    assert!(paths.contains(&Path::new(\"/g/h/i\")));\n-    assert!(paths.contains(&Path::new(\"/d/e/f\")));\n-    assert!(paths.contains(&Path::new(\"/a/b/c\")));\n-    os::unsetenv(\"RUST_PATH\");\n-}\n-\n-#[test]\n-fn test_list() {\n-    let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n-    let dir = dir.path();\n-    let foo: CrateId = from_str(\"foo\").unwrap();\n-    create_local_package_in(&foo, dir);\n-    let bar: CrateId = from_str(\"bar\").unwrap();\n-    create_local_package_in(&bar, dir);\n-    let quux: CrateId = from_str(\"quux\").unwrap();\n-    create_local_package_in(&quux, dir);\n-\n-// list doesn't output very much right now...\n-    command_line_test([~\"install\", ~\"foo\"], dir);\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let env_arg = ~[(~\"RUST_PATH\", dir.as_str().unwrap().to_owned())];\n-    let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n-\n-    command_line_test([~\"install\", ~\"bar\"], dir);\n-    let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n-\n-    command_line_test([~\"install\", ~\"quux\"], dir);\n-    let list_output = command_line_test_output_with_env([~\"list\"], env_arg);\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n-}\n-\n-#[test]\n-fn install_remove() {\n-    let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n-    let dir = dir.path();\n-    let foo: CrateId = from_str(\"foo\").unwrap();\n-    let bar: CrateId = from_str(\"bar\").unwrap();\n-    let quux: CrateId = from_str(\"quux\").unwrap();\n-    create_local_package_in(&foo, dir);\n-    create_local_package_in(&bar, dir);\n-    create_local_package_in(&quux, dir);\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path_to_use = ~[(~\"RUST_PATH\", dir.as_str().unwrap().to_owned())];\n-    command_line_test([~\"install\", ~\"foo\"], dir);\n-    command_line_test([~\"install\", ~\"bar\"], dir);\n-    command_line_test([~\"install\", ~\"quux\"], dir);\n-    let list_output = command_line_test_output_with_env([~\"list\"], rust_path_to_use.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n-    command_line_test([~\"uninstall\", ~\"foo\"], dir);\n-    let list_output = command_line_test_output_with_env([~\"list\"], rust_path_to_use.clone());\n-    assert!(!list_output.iter().any(|x| x.starts_with(\"foo\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n-}\n-\n-#[test]\n-fn install_check_duplicates() {\n-    // should check that we don't install two packages with the same full name *and* version\n-    // (\"Is already installed -- doing nothing\")\n-    // check invariant that there are no dups in the pkg database\n-    let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n-    let dir = dir.path();\n-    let foo: CrateId = from_str(\"foo\").unwrap();\n-    create_local_package_in(&foo, dir);\n-\n-    command_line_test([~\"install\", ~\"foo\"], dir);\n-    command_line_test([~\"install\", ~\"foo\"], dir);\n-    let mut contents = ~[];\n-    let check_dups = |p: &CrateId| {\n-        if contents.contains(p) {\n-            fail!(\"package {} appears in `list` output more than once\", p.path);\n-        }\n-        else {\n-            contents.push((*p).clone());\n-        }\n-        true\n-    };\n-    list_installed_packages(check_dups);\n-}\n-\n-#[test]\n-fn no_rebuilding() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let foo_lib = lib_output_file_name(workspace, \"foo\");\n-    // Now make `foo` read-only so that subsequent rebuilds of it will fail\n-    assert!(chmod_read_only(&foo_lib));\n-\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-\n-    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(..) => (), // ok\n-        Fail(ref status) if status.status.matches_exit_status(65) =>\n-            fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n-        Fail(_) => fail!(\"no_rebuilding failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-#[ignore]\n-fn no_recopying() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"install\", ~\"foo\"], workspace);\n-    let foo_lib = installed_library_in_workspace(&p_id, workspace);\n-    assert!(foo_lib.is_some());\n-    // Now make `foo` read-only so that subsequent attempts to copy to it will fail\n-    assert!(chmod_read_only(&foo_lib.unwrap()));\n-\n-    match command_line_test_partial([~\"install\", ~\"foo\"], workspace) {\n-        Success(..) => (), // ok\n-        Fail(ref status) if status.status.matches_exit_status(65) =>\n-            fail!(\"no_recopying failed: it tried to re-copy foo\"),\n-        Fail(_) => fail!(\"no_copying failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-fn no_rebuilding_dep() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let dep_id: CrateId = from_str(\"bar\").unwrap();\n-    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let bar_lib = lib_output_file_name(workspace, \"bar\");\n-    frob_source_file(workspace, &p_id, \"main.rs\");\n-    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n-    assert!(chmod_read_only(&bar_lib));\n-    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(..) => (), // ok\n-        Fail(ref r) if r.status.matches_exit_status(65) =>\n-            fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n-        Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-fn do_rebuild_dep_dates_change() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let dep_id: CrateId = from_str(\"bar\").unwrap();\n-    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n-    touch_source_file(workspace, &dep_id);\n-\n-    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n-    assert!(chmod_read_only(&bar_lib_name));\n-\n-    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(..) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n-        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n-        Fail(_) => fail!(\"do_rebuild_dep_dates_change failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-fn do_rebuild_dep_only_contents_change() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let dep_id: CrateId = from_str(\"bar\").unwrap();\n-    let workspace = create_local_package_with_dep(&p_id, &dep_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    frob_source_file(workspace, &dep_id, \"lib.rs\");\n-    let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n-\n-    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n-    assert!(chmod_read_only(&bar_lib_name));\n-\n-    // should adjust the datestamp\n-    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(..) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n-        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n-        Fail(_) => fail!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-fn test_versions() {\n-    let foo_01: CrateId = from_str(\"foo#0.1\").unwrap();\n-    let foo_02: CrateId = from_str(\"foo#0.2\").unwrap();\n-    let workspace = create_local_package(&foo_01);\n-    let _other_workspace = create_local_package(&foo_02);\n-    command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n-    let output = command_line_test_output([~\"list\"]);\n-    // make sure output includes versions\n-    assert!(!output.iter().any(|x| x == &~\"foo#0.2\"));\n-}\n-\n-#[test]\n-#[ignore(reason = \"do not yet implemented\")]\n-fn test_build_hooks() {\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package_with_custom_build_hook(&crate_id,\n-                                                                \"frob\");\n-    command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n-}\n-\n-\n-#[test]\n-#[ignore(reason = \"info not yet implemented\")]\n-fn test_info() {\n-    let expected_info = ~\"package foo\"; // fill in\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&crate_id);\n-    let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n-    assert_eq!(str::from_utf8_owned(output.output).unwrap(), expected_info);\n-}\n-\n-#[test]\n-fn test_uninstall() {\n-    let crate_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&crate_id);\n-    command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n-    let output = command_line_test([~\"list\"], workspace.path());\n-    assert!(!str::from_utf8(output.output).unwrap().contains(\"foo\"));\n-}\n-\n-#[test]\n-fn test_non_numeric_tag() {\n-    let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n-    let repo = repo.path();\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    writeFile(&repo_subdir.join(\"foo\"), \"foo\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    add_git_tag(&repo_subdir, ~\"testbranch\");\n-    writeFile(&repo_subdir.join(\"testbranch_only\"), \"hello\");\n-    add_git_tag(&repo_subdir, ~\"another_tag\");\n-    writeFile(&repo_subdir.join(\"not_on_testbranch_only\"), \"bye bye\");\n-    add_all_and_commit(&repo_subdir);\n-\n-    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path)], repo);\n-    let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n-    let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n-    assert!(file1.exists());\n-    assert!(!file2.exists());\n-}\n-\n-#[test]\n-fn test_extern_mod() {\n-    let dir = TempDir::new(\"test_extern_mod\").expect(\"test_extern_mod\");\n-    let dir = dir.path();\n-    let main_file = dir.join(\"main.rs\");\n-    let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n-    let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.join_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n-    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n-    let aux_pkg_file = aux_dir.join(\"lib.rs\");\n-\n-    writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(aux_pkg_file.exists());\n-\n-    writeFile(&main_file,\n-              \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n-               fn main() { bar::assert_true(); }\\n\");\n-\n-    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], lib_depend_dir);\n-\n-    let exec_file = dir.join(\"out\");\n-    // Be sure to extend the existing environment\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n-    let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename(\"rustc\");\n-\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut prog = run::Process::new(rustc.as_str().unwrap(),\n-                                     [main_file.as_str().unwrap().to_owned(),\n-                                      ~\"--sysroot\", test_sys.as_str().unwrap().to_owned(),\n-                                      ~\"-o\", exec_file.as_str().unwrap().to_owned()],\n-                                     run::ProcessOptions {\n-        env: env,\n-        dir: Some(dir),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    }).expect(format!(\"failed to exec `{}`\", rustc.as_str().unwrap()));\n-    let outp = prog.finish_with_output();\n-    if !outp.status.success() {\n-        fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output).unwrap(),\n-              str::from_utf8(outp.error).unwrap());\n-    }\n-    assert!(exec_file.exists() && is_executable(&exec_file));\n-}\n-\n-#[test]\n-fn test_extern_mod_simpler() {\n-    let dir = TempDir::new(\"test_extern_mod_simpler\").expect(\"test_extern_mod_simpler\");\n-    let dir = dir.path();\n-    let main_file = dir.join(\"main.rs\");\n-    let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n-    let lib_depend_dir = lib_depend_dir.path();\n-    let aux_dir = lib_depend_dir.join_many([\"src\", \"rust-awesomeness\"]);\n-    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n-    let aux_pkg_file = aux_dir.join(\"lib.rs\");\n-\n-    writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(aux_pkg_file.exists());\n-\n-    writeFile(&main_file,\n-              \"extern mod test = \\\"rust-awesomeness\\\";\\nuse test::bar;\\\n-               fn main() { bar::assert_true(); }\\n\");\n-\n-    command_line_test([~\"install\", ~\"rust-awesomeness\"], lib_depend_dir);\n-\n-    let exec_file = dir.join(\"out\");\n-    // Be sure to extend the existing environment\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let env = Some([(~\"RUST_PATH\", lib_depend_dir.as_str().unwrap().to_owned())] + os::env());\n-    let rustpkg_exec = rustpkg_exec();\n-    let rustc = rustpkg_exec.with_filename(\"rustc\");\n-    let test_sys = test_sysroot();\n-    debug!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n-                     lib_depend_dir.display(),\n-                     rustc.display(),\n-                     main_file.display(),\n-                     test_sys.display(),\n-                     exec_file.display());\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut prog = run::Process::new(rustc.as_str().unwrap(),\n-                                     [main_file.as_str().unwrap().to_owned(),\n-                                      ~\"--sysroot\", test_sys.as_str().unwrap().to_owned(),\n-                                      ~\"-o\", exec_file.as_str().unwrap().to_owned()],\n-                                     run::ProcessOptions {\n-        env: env,\n-        dir: Some(dir),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    }).expect(format!(\"failed to exec `{}`\", rustc.as_str().unwrap()));\n-    let outp = prog.finish_with_output();\n-    if !outp.status.success() {\n-        fail!(\"output was {}, error was {}\",\n-              str::from_utf8(outp.output).unwrap(),\n-              str::from_utf8(outp.error).unwrap());\n-    }\n-    assert!(exec_file.exists() && is_executable(&exec_file));\n-}\n-\n-#[test]\n-fn test_import_rustpkg() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n-              \"extern mod rustpkg; fn main() {}\");\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug!(\"workspace = {}\", workspace.display());\n-    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::consts::EXE_SUFFIX)).exists());\n-}\n-\n-#[test]\n-fn test_macro_pkg_script() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n-              \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug!(\"workspace = {}\", workspace.display());\n-    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::consts::EXE_SUFFIX)).exists());\n-}\n-\n-#[test]\n-fn multiple_workspaces() {\n-// Make a package foo; build/install in directory A\n-// Copy the exact same package into directory B and install it\n-// Set the RUST_PATH to A:B\n-// Make a third package that uses foo, make sure we can build/install it\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n-    let (a_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n-    let (b_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n-    let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n-    debug!(\"Trying to install foo in {}\", a_loc.display());\n-    command_line_test([~\"install\", ~\"foo\"], a_loc);\n-    debug!(\"Trying to install foo in {}\", b_loc.display());\n-    command_line_test([~\"install\", ~\"foo\"], b_loc);\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n-                                            b_loc.as_str().unwrap()))]);\n-    let c_loc = create_local_package_with_dep(&bar_p_id, &p_id);\n-    command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n-}\n-\n-fn rust_path_hack_test(hack_flag: bool) {\n-/*\n-      Make a workspace containing a pkg foo [A]\n-      Make a second, empty workspace        [B]\n-      Set RUST_PATH to B:A\n-      rustpkg install foo\n-      make sure built files for foo are in B\n-      make sure nothing gets built into A or A/../build[lib,bin]\n-*/\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let dest_workspace = mk_empty_workspace(&bar_p_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-    let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n-    let rust_path = Some(~[(~\"RUST_PATH\",\n-        format!(\"{}:{}\",\n-                dest_workspace.as_str().unwrap(),\n-                foo_path.as_str().unwrap()))]);\n-    command_line_test_with_env(~[~\"install\"] +\n-                               if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } + ~[~\"foo\"],\n-                               dest_workspace, rust_path);\n-    assert_lib_exists(dest_workspace, &p_id);\n-    assert_executable_exists(dest_workspace, \"foo\");\n-    assert_built_library_exists(dest_workspace, \"foo\");\n-    assert_built_executable_exists(dest_workspace, \"foo\");\n-    assert!(!lib_exists(workspace, &p_id));\n-    assert!(!executable_exists(workspace, \"foo\"));\n-    assert!(!built_library_exists(workspace, \"foo\"));\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-}\n-\n-// Notice that this is the only test case where the --rust-path-hack\n-// flag is actually needed\n-#[test]\n-fn test_rust_path_can_contain_package_dirs_with_flag() {\n-/*\n-   Test that the temporary hack added for bootstrapping Servo builds\n-   works. That is: if you add $FOO/src/some_pkg to the RUST_PATH,\n-   it will find the sources in some_pkg, build them, and install them\n-   into the first entry in the RUST_PATH.\n-\n-   When the hack is removed, we should change this to a should_fail test.\n-*/\n-   rust_path_hack_test(true);\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_rust_path_can_contain_package_dirs_without_flag() {\n-   rust_path_hack_test(false);\n-}\n-\n-#[test]\n-fn rust_path_hack_cwd() {\n-    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n-    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n-    let cwd = cwd.path().join(\"foo\");\n-    fs::mkdir_recursive(&cwd, io::UserRWX);\n-    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let bar_id: CrateId = from_str(\"bar\").unwrap();\n-\n-    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-    assert_lib_exists(dest_workspace, &foo_id);\n-    assert_built_library_exists(dest_workspace, \"foo\");\n-    assert!(!lib_exists(&cwd, &foo_id));\n-    assert!(!built_library_exists(&cwd, \"foo\"));\n-}\n-\n-#[test]\n-fn rust_path_hack_multi_path() {\n-    // Same as rust_path_hack_test, but with a more complex package ID\n-    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n-    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-    fs::mkdir_recursive(&subdir, io::UserRWX);\n-    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n-    let name = ~\"foo/bar/quux\";\n-    let foo_id: CrateId = from_str(\"foo/bar/quux\").unwrap();\n-    let bar_id: CrateId = from_str(\"bar\").unwrap();\n-\n-    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-    assert_lib_exists(dest_workspace, &foo_id);\n-    assert_built_library_exists(dest_workspace, name);\n-    assert!(!lib_exists(&subdir, &foo_id));\n-    assert!(!built_library_exists(&subdir, name));\n-}\n-\n-#[test]\n-fn rust_path_hack_install_no_arg() {\n-    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n-    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n-    let cwd = cwd.path();\n-    let source_dir = cwd.join(\"foo\");\n-    assert!(make_dir_rwx(&source_dir));\n-    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let bar_id: CrateId = from_str(\"bar\").unwrap();\n-    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-    assert_lib_exists(dest_workspace, &foo_id);\n-    assert_built_library_exists(dest_workspace, \"foo\");\n-    assert!(!lib_exists(&source_dir, &foo_id));\n-    assert!(!built_library_exists(cwd, \"foo\"));\n-}\n-\n-#[test]\n-fn rust_path_hack_build_no_arg() {\n-    // Same as rust_path_hack_install_no_arg, but building instead of installing\n-    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-    let source_dir = cwd.path().join(\"foo\");\n-    assert!(make_dir_rwx(&source_dir));\n-    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-    let bar_id: CrateId = from_str(\"bar\").unwrap();\n-    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-    assert_built_library_exists(dest_workspace, \"foo\");\n-    assert!(!built_library_exists(&source_dir, \"foo\"));\n-}\n-\n-#[test]\n-fn rust_path_hack_build_with_dependency() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let dep_id: CrateId = from_str(\"dep\").unwrap();\n-    // Tests that when --rust-path-hack is in effect, dependencies get built\n-    // into the destination workspace and not the source directory\n-    let work_dir = create_local_package(&foo_id);\n-    let work_dir = work_dir.path();\n-    let dep_workspace = create_local_package(&dep_id);\n-    let dep_workspace = dep_workspace.path();\n-    let dest_workspace = mk_emptier_workspace(\"dep\");\n-    let dest_workspace = dest_workspace.path();\n-    let source_dir = work_dir.join_many([\"src\", \"foo-0.0\"]);\n-    writeFile(&source_dir.join(\"lib.rs\"), \"extern mod dep; pub fn f() { }\");\n-    let dep_dir = dep_workspace.join_many([\"src\", \"dep-0.0\"]);\n-    let rust_path = Some(~[(~\"RUST_PATH\",\n-                          format!(\"{}:{}\",\n-                                  dest_workspace.display(),\n-                                  dep_dir.display()))]);\n-    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\", ~\"foo\"], work_dir, rust_path);\n-    assert_built_library_exists(dest_workspace, \"dep\");\n-    assert!(!built_library_exists(dep_workspace, \"dep\"));\n-}\n-\n-#[test]\n-fn rust_path_install_target() {\n-    let dir_for_path = TempDir::new(\n-        \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let mut dir = mk_workspace(dir_for_path.path(), &foo_id);\n-    debug!(\"dir = {}\", dir.display());\n-    writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n-    let dir_to_install_to = TempDir::new(\n-        \"dest_workspace\").expect(\"rust_path_install_target failed\");\n-    let dir_to_install_to = dir_to_install_to.path();\n-    dir.pop(); dir.pop();\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\",\n-                                                  dir_to_install_to.as_str().unwrap(),\n-                                                  dir.as_str().unwrap()))]);\n-    let cwd = os::getcwd();\n-    command_line_test_with_env([~\"install\", ~\"foo\"],\n-                               &cwd,\n-                               rust_path);\n-\n-    assert_executable_exists(dir_to_install_to, \"foo\");\n-\n-}\n-\n-#[test]\n-fn sysroot_flag() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    // no-op sysroot setting; I'm not sure how else to test this\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"--sysroot\",\n-                       test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert_built_executable_exists(workspace, \"foo\");\n-}\n-\n-#[test]\n-fn compile_flag_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"--no-link\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(object_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn compile_flag_fail() {\n-    // --no-link shouldn't be accepted for install\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"--no-link\",\n-                       ~\"foo\"],\n-                      workspace, None, BAD_FLAG_CODE);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn notrans_flag_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n-                         ~\"--pretty\", ~\"-S\"];\n-\n-    for flag in flags_to_test.iter() {\n-        let test_sys = test_sysroot();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                           ~\"build\",\n-                           flag.clone(),\n-                           ~\"foo\"],\n-                          workspace);\n-        // Ideally we'd test that rustpkg actually succeeds, but\n-        // since task failure doesn't set the exit code properly,\n-        // we can't tell\n-        assert!(!built_executable_exists(workspace, \"foo\"));\n-        assert!(!object_file_exists(workspace, \"foo\"));\n-    }\n-}\n-\n-#[test]\n-fn notrans_flag_fail() {\n-    // --no-trans shouldn't be accepted for install\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n-                         ~\"--pretty\", ~\"-S\"];\n-    for flag in flags_to_test.iter() {\n-        let test_sys = test_sysroot();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                           ~\"install\",\n-                           flag.clone(),\n-                           ~\"foo\"],\n-                          workspace, None, BAD_FLAG_CODE);\n-        assert!(!built_executable_exists(workspace, \"foo\"));\n-        assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &p_id));\n-    }\n-}\n-\n-#[test]\n-fn dash_S() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"-S\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn dash_S_fail() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"-S\",\n-                       ~\"foo\"],\n-                       workspace, None, BAD_FLAG_CODE);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(!assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_cfg_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    // If the cfg flag gets messed up, this won't compile\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n-               \"#[cfg(quux)] fn main() {}\");\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"--cfg\",\n-                       ~\"quux\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert_built_executable_exists(workspace, \"foo\");\n-}\n-\n-#[test]\n-fn test_cfg_fail() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n-               \"#[cfg(quux)] fn main() {}\");\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    match command_line_test_partial([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"foo\"],\n-                      workspace) {\n-        Success(..) => fail!(\"test_cfg_fail failed\"),\n-        _          => ()\n-    }\n-}\n-\n-\n-#[test]\n-fn test_emit_llvm_S_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"-S\", ~\"--emit-llvm\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(llvm_assembly_file_exists(workspace, \"foo\"));\n-    assert!(!assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_emit_llvm_S_fail() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"-S\", ~\"--emit-llvm\",\n-                       ~\"foo\"],\n-                       workspace,\n-                       None,\n-                       BAD_FLAG_CODE);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n-    assert!(!assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_emit_llvm_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"--emit-llvm\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(llvm_bitcode_file_exists(workspace, \"foo\"));\n-    assert!(!assembly_file_exists(workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_emit_llvm_fail() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"--emit-llvm\",\n-                       ~\"foo\"],\n-                                  workspace,\n-                                  None,\n-                                  BAD_FLAG_CODE);\n-    assert!(!built_executable_exists(workspace, \"foo\"));\n-    assert!(!object_file_exists(workspace, \"foo\"));\n-    assert!(!llvm_bitcode_file_exists(workspace, \"foo\"));\n-    assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n-    assert!(!assembly_file_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_linker_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let matches = getopts([], optgroups());\n-    let options = build_session_options(~\"rustpkg\",\n-                                        matches.as_ref().unwrap(),\n-                                        @diagnostic::DefaultEmitter);\n-    let sess = build_session(options, None, @diagnostic::DefaultEmitter);\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let cc = get_cc_prog(sess);\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"--linker\",\n-                       cc,\n-                       ~\"foo\"],\n-                      workspace);\n-    assert_executable_exists(workspace, \"foo\");\n-}\n-\n-#[test]\n-fn test_build_install_flags_fail() {\n-    // The following flags can only be used with build or install:\n-    let forbidden = [~[~\"--linker\", ~\"ld\"],\n-                     ~[~\"--link-args\", ~\"quux\"],\n-                     ~[~\"-O\"],\n-                     ~[~\"--opt-level\", ~\"2\"],\n-                     ~[~\"--save-temps\"],\n-                     ~[~\"--target\", host_triple()],\n-                     ~[~\"--target-cpu\", ~\"generic\"],\n-                     ~[~\"-Z\", ~\"--time-passes\"]];\n-    let cwd = os::getcwd();\n-    for flag in forbidden.iter() {\n-        let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-        command_line_test_expect_fail([test_sys.as_str().unwrap().to_owned(),\n-                           ~\"list\"] + *flag, &cwd, None, BAD_FLAG_CODE);\n-    }\n-}\n-\n-#[test]\n-fn test_optimized_build() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"-O\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(built_executable_exists(workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn crateid_pointing_to_subdir() {\n-    // The actual repo is mockgithub.com/mozilla/some_repo\n-    // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n-    let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n-    let workspace = workspace.path();\n-    fs::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n-                                                \"mozilla\", \"some_repo\"]),\n-                          io::UserRWX);\n-\n-    let foo_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n-                                       \"extras\", \"foo\"]);\n-    let bar_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n-                                       \"extras\", \"bar\"]);\n-    fs::mkdir_recursive(&foo_dir, io::UserRWX);\n-    fs::mkdir_recursive(&bar_dir, io::UserRWX);\n-    writeFile(&foo_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/foo\\\"];\" +\n-              \"pub fn f() {}\");\n-    writeFile(&bar_dir.join(\"lib.rs\"),\n-              \"#[crate_id=\\\"mockgithub.com/mozilla/some_repo/extras/bar\\\"];\" +\n-              \"pub fn g() {}\");\n-\n-    debug!(\"Creating a file in {}\", workspace.display());\n-    let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.0\"]);\n-    fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n-\n-    writeFile(&testpkg_dir.join(\"main.rs\"),\n-              \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo#foo:0.0\\\";\\n\n-               extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar#bar:0.0\\\";\\n\n-               use foo::f; use bar::g; \\n\n-               fn main() { f(); g(); }\");\n-\n-    command_line_test([~\"install\", ~\"testpkg\"], workspace);\n-    assert_executable_exists(workspace, \"testpkg\");\n-}\n-\n-#[test]\n-fn test_recursive_deps() {\n-    let a_id: CrateId = from_str(\"a\").unwrap();\n-    let b_id: CrateId = from_str(\"b\").unwrap();\n-    let c_id: CrateId = from_str(\"c\").unwrap();\n-    let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n-    let b_workspace = b_workspace.path();\n-    writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n-               \"pub fn g() {}\");\n-    let a_workspace = create_local_package(&a_id);\n-    let a_workspace = a_workspace.path();\n-    writeFile(&a_workspace.join_many([\"src\", \"a-0.0\", \"main.rs\"]),\n-               \"extern mod b; use b::f; fn main() { f(); }\");\n-    writeFile(&b_workspace.join_many([\"src\", \"b-0.0\", \"lib.rs\"]),\n-               \"extern mod c; use c::g; pub fn f() { g(); }\");\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let environment = Some(~[(~\"RUST_PATH\", b_workspace.as_str().unwrap().to_owned())]);\n-    debug!(\"RUST_PATH={}\", b_workspace.display());\n-    command_line_test_with_env([~\"install\", ~\"a\"],\n-                               a_workspace,\n-                               environment);\n-    assert_lib_exists(a_workspace, &a_id);\n-    assert_lib_exists(b_workspace, &b_id);\n-    assert_lib_exists(b_workspace, &c_id);\n-}\n-\n-#[test]\n-fn test_install_to_rust_path() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let second_workspace = create_local_package(&p_id);\n-    let second_workspace = second_workspace.path();\n-    let none_id: CrateId = from_str(\"p\").unwrap();\n-    let first_workspace = mk_empty_workspace(&none_id, \"dest\");\n-    let first_workspace = first_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\",\n-                            format!(\"{}:{}\", first_workspace.as_str().unwrap(),\n-                                    second_workspace.as_str().unwrap()))]);\n-    debug!(\"RUST_PATH={}:{}\", first_workspace.display(), second_workspace.display());\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test_with_env([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"foo\"],\n-                      &os::getcwd(), rust_path);\n-    assert!(!built_executable_exists(first_workspace, \"foo\"));\n-    assert!(built_executable_exists(second_workspace, \"foo\"));\n-    assert_executable_exists(first_workspace, \"foo\");\n-    assert!(!executable_exists(second_workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_target_specific_build_dir() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"build\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(target_build_dir(workspace).is_dir());\n-    assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(fs::readdir(&workspace.join(\"build\")).len() == 1);\n-}\n-\n-#[test]\n-fn test_target_specific_install_dir() {\n-    let p_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package(&p_id);\n-    let workspace = workspace.path();\n-    let test_sys = test_sysroot();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([test_sys.as_str().unwrap().to_owned(),\n-                       ~\"install\",\n-                       ~\"foo\"],\n-                      workspace);\n-    assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &p_id);\n-    assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n-    assert!(workspace.join(\"bin\").is_dir());\n-    assert_executable_exists(workspace, \"foo\");\n-}\n-\n-#[test]\n-#[ignore(reason = \"See #7240\")]\n-fn test_dependencies_terminate() {\n-    let b_id: CrateId = from_str(\"b\").unwrap();\n-    let workspace = create_local_package(&b_id);\n-    let workspace = workspace.path();\n-    let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n-    let b_subdir = b_dir.join(\"test\");\n-    fs::mkdir_recursive(&b_subdir, io::UserRWX);\n-    writeFile(&b_subdir.join(\"test.rs\"),\n-              \"extern mod b; use b::f; #[test] fn g() { f() }\");\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-}\n-\n-#[test]\n-fn install_after_build() {\n-    let b_id: CrateId = from_str(\"b\").unwrap();\n-    let workspace = create_local_package(&b_id);\n-    let workspace = workspace.path();\n-    command_line_test([~\"build\", ~\"b\"], workspace);\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b_id.name);\n-    assert_lib_exists(workspace, &b_id);\n-}\n-\n-#[test]\n-fn reinstall() {\n-    let b: CrateId = from_str(\"b\").unwrap();\n-    let workspace = create_local_package(&b);\n-    let workspace = workspace.path();\n-    // 1. Install, then remove executable file, then install again,\n-    // and make sure executable was re-installed\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.name);\n-    assert_lib_exists(workspace, &b);\n-    remove_executable_file(&b, workspace);\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.name);\n-    // 2. Build, then remove build executable file, then build again,\n-    // and make sure executable was re-built.\n-    command_line_test([~\"build\", ~\"b\"], workspace);\n-    remove_built_executable_file(&b, workspace);\n-    command_line_test([~\"build\", ~\"b\"], workspace);\n-    assert_built_executable_exists(workspace, b.name);\n-    // 3. Install, then remove both executable and built executable,\n-    // then install again, make sure both were recreated\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-    remove_executable_file(&b, workspace);\n-    remove_built_executable_file(&b, workspace);\n-    command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.name);\n-    assert_built_executable_exists(workspace, b.name);\n-}\n-\n-#[test]\n-fn correct_package_name_with_rust_path_hack() {\n-    /*\n-    Set rust_path_hack flag\n-\n-    Try to install bar\n-    Check that:\n-    - no output gets produced in any workspace\n-    - there's an error\n-    */\n-\n-    // Set RUST_PATH to something containing only the sources for foo\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let bar_id: CrateId = from_str(\"bar\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n-    let dest_workspace = dest_workspace.path();\n-\n-    writeFile(&dest_workspace.join_many([\"src\", \"bar-0.0\", \"main.rs\"]),\n-              \"extern mod blat; fn main() { let _x = (); }\");\n-\n-    let foo_path = foo_workspace.join_many([\"src\", \"foo-0.0\"]);\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n-                                                  foo_path.as_str().unwrap()))]);\n-    // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n-    command_line_test_expect_fail([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n-                                  // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n-                               dest_workspace, rust_path, COPY_FAILED_CODE);\n-    assert!(!executable_exists(dest_workspace, \"bar\"));\n-    assert!(!lib_exists(dest_workspace, &bar_id));\n-    assert!(!executable_exists(dest_workspace, \"foo\"));\n-    assert!(!lib_exists(dest_workspace, &foo_id));\n-    assert!(!executable_exists(foo_workspace, \"bar\"));\n-    assert!(!lib_exists(foo_workspace, &bar_id));\n-    assert!(!executable_exists(foo_workspace, \"foo\"));\n-    assert!(!lib_exists(foo_workspace, &foo_id));\n-}\n-\n-#[test]\n-fn test_rustpkg_test_creates_exec() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n-              \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n-    assert!(test_executable_exists(foo_workspace, \"foo\"));\n-}\n-\n-#[test]\n-fn test_rustpkg_test_output() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let workspace = create_local_package_with_test(&foo_id);\n-    let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n-    let output_str = str::from_utf8(output.output).unwrap();\n-    // The first two assertions are separate because test output may\n-    // contain color codes, which could appear between \"test f\" and \"ok\".\n-    assert!(output_str.contains(\"test f\"));\n-    assert!(output_str.contains(\"ok\"));\n-    assert!(output_str.contains(\"1 passed; 0 failed; 0 ignored; 0 measured\"));\n-}\n-\n-#[test]\n-fn test_rustpkg_test_failure_exit_status() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n-              \"#[test] fn f() { assert!('a' != 'a'); }\");\n-    let res = command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace);\n-    match res {\n-        Fail(_) => {},\n-        Success(..) => fail!(\"Expected test failure but got success\")\n-    }\n-}\n-\n-#[test]\n-fn test_rustpkg_test_cfg() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n-              \"#[test] #[cfg(not(foobar))] fn f() { assert!('a' != 'a'); }\");\n-    let output = command_line_test([~\"test\", ~\"--cfg\", ~\"foobar\", ~\"foo\"],\n-                                   foo_workspace);\n-    let output_str = str::from_utf8(output.output).unwrap();\n-    assert!(output_str.contains(\"0 passed; 0 failed; 0 ignored; 0 measured\"));\n-}\n-\n-#[test]\n-fn test_rebuild_when_needed() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n-    writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n-    assert!(test_executable_exists(foo_workspace, \"foo\"));\n-    let test_executable = built_test_in_workspace(&foo_id,\n-            foo_workspace).expect(\"test_rebuild_when_needed failed\");\n-    frob_source_file(foo_workspace, &foo_id, \"test.rs\");\n-    chmod_read_only(&test_executable);\n-    match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n-        Success(..) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n-        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n-        Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-#[ignore] // FIXME (#10257): This doesn't work as is since a read only file can't execute\n-fn test_no_rebuilding() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n-    writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n-    command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n-    assert!(test_executable_exists(foo_workspace, \"foo\"));\n-    let test_executable = built_test_in_workspace(&foo_id,\n-                            foo_workspace).expect(\"test_no_rebuilding failed\");\n-    chmod_read_only(&test_executable);\n-    match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n-        Success(..) => (), // ok\n-        Fail(ref r) if r.status.matches_exit_status(65) =>\n-            fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n-        Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-fn test_installed_read_only() {\n-    // Install sources from a \"remote\" (actually a local github repo)\n-    // Check that afterward, sources are read-only and installed under build/\n-    let temp_pkg_id = git_repo_pkg();\n-    let path = Path::new(temp_pkg_id.path.as_slice());\n-    let repo = init_git_repo(&path);\n-    let repo = repo.path();\n-    debug!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug!(\"repo_subdir = {}\", repo_subdir.display());\n-\n-    writeFile(&repo_subdir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    add_git_tag(&repo_subdir, ~\"0.0\"); // this has the effect of committing the files\n-    // update crateid to what will be auto-detected\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.to_str()], repo);\n-\n-    let ws = repo.join(\".rust\");\n-    // Check that all files exist\n-    debug!(\"Checking for files in {}\", ws.display());\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug!(\"exec = {}\", exec.display());\n-    assert!(exec.exists());\n-    assert!(is_rwx(&exec));\n-    let built_lib =\n-        built_library_in_workspace(&temp_pkg_id,\n-                                   &ws).expect(\"test_install_git: built lib should exist\");\n-    assert!(built_lib.exists());\n-\n-    // Make sure sources are (a) under \"build\" and (b) read-only\n-    let temp_dir = format!(\"{}-{}\", temp_pkg_id.path, temp_pkg_id.version_or_default());\n-    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"main.rs\"]);\n-    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"lib.rs\"]);\n-    debug!(\"src1: {}\", src1.display());\n-    assert!(src1.exists());\n-    assert!(src2.exists());\n-    assert!(is_read_only(&src1));\n-    assert!(is_read_only(&src2));\n-}\n-\n-#[test]\n-fn test_installed_local_changes() {\n-    let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n-    let repo = repo.path();\n-    debug!(\"repo = {}\", repo.display());\n-    let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug!(\"repo_subdir = {}\", repo_subdir.display());\n-    fs::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), io::UserRWX);\n-\n-    writeFile(&repo_subdir.join(\"main.rs\"),\n-              \"fn main() { let _x = (); }\");\n-    writeFile(&repo_subdir.join(\"lib.rs\"),\n-              \"pub fn f() { let _x = (); }\");\n-    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n-\n-    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n-\n-    // We installed the dependency.\n-    // Now start a new workspace and clone it into it\n-    let hacking_workspace = mk_emptier_workspace(\"hacking_workspace\");\n-    let hacking_workspace = hacking_workspace.path();\n-    let target_dir = hacking_workspace.join_many([\"src\",\n-                                                  \"mockgithub.com\",\n-                                                  \"catamorphism\",\n-                                                  \"test-pkg-0.0\"]);\n-    debug!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n-\n-    let c_res = safe_git_clone(&repo_subdir, &None, &target_dir);\n-\n-    match c_res {\n-        DirToUse(_) => fail!(\"test_installed_local_changes failed\"),\n-        CheckedOutSources => ()\n-    };\n-\n-    // Make a local change to it\n-    writeFile(&target_dir.join(\"lib.rs\"),\n-              \"pub fn g() { let _x = (); }\");\n-\n-    // Finally, make *another* package that uses it\n-    let importer_pkg_id = fake_pkg();\n-    let main_subdir = create_local_package_in(&importer_pkg_id, hacking_workspace);\n-    writeFile(&main_subdir.join(\"main.rs\"),\n-              \"extern mod test = \\\"mockgithub.com/catamorphism/test-pkg\\\"; \\\n-              use test::g;\n-              fn main() { g(); }\");\n-    // And make sure we can build it\n-\n-    command_line_test([~\"build\", importer_pkg_id.path.to_owned()], hacking_workspace);\n-}\n-\n-#[test]\n-fn test_7402() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let dir = create_local_package(&foo_id);\n-    let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n-    let dest_workspace = dest_workspace.path();\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let rust_path = Some(~[(~\"RUST_PATH\",\n-                            format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n-                                    dir.path().as_str().unwrap()))]);\n-    let cwd = os::getcwd();\n-    command_line_test_with_env([~\"install\", ~\"foo\"], &cwd, rust_path);\n-    assert_executable_exists(dest_workspace, \"foo\");\n-}\n-\n-#[test]\n-fn test_compile_error() {\n-    let foo_id: CrateId = from_str(\"foo\").unwrap();\n-    let foo_workspace = create_local_package(&foo_id);\n-    let foo_workspace = foo_workspace.path();\n-    let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n-    // Write something bogus\n-    writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n-    let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n-    match result {\n-        Success(..) => fail!(\"Failed by succeeding!\"), // should be a compile error\n-        Fail(ref status) => {\n-            debug!(\"Failed with status {:?}... that's good, right?\", status);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn find_sources_in_cwd() {\n-    let temp_dir = TempDir::new(\"sources\").expect(\"find_sources_in_cwd failed\");\n-    let temp_dir = temp_dir.path();\n-    let source_dir = temp_dir.join(\"foo\");\n-    fs::mkdir_recursive(&source_dir, io::UserRWX);\n-    writeFile(&source_dir.join(\"main.rs\"),\n-              r#\"#[crate_id=\"rust-foo#foo:0.0\"]; fn main() { let _x = (); }\"#);\n-    command_line_test([~\"install\", ~\"foo\"], &source_dir);\n-    assert_executable_exists(&source_dir.join(\".rust\"), \"foo\");\n-}\n-\n-#[test]\n-#[ignore(reason=\"busted\")]\n-fn test_c_dependency_ok() {\n-    // Pkg has a custom build script that adds a single C file as a dependency, and\n-    // registers a hook to build it if it's not fresh\n-    // After running `build`, test that the C library built\n-\n-    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n-    let dir = create_local_package(&cdep_id);\n-    let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n-              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\nfn main() { unsafe { f(); } }\");\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]), \"void f() {}\");\n-\n-    debug!(\"dir = {}\", dir.display());\n-    let source = Path::new(file!()).dir_path().join_many(\n-        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]));\n-    command_line_test([~\"build\", ~\"cdep\"], dir);\n-    assert_executable_exists(dir, \"cdep\");\n-    let out_dir = target_build_dir(dir).join(\"cdep\");\n-    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n-    debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(c_library_path.exists());\n-}\n-\n-#[ignore(reason=\"rustpkg is not reentrant\")]\n-#[test]\n-#[ignore(reason=\"busted\")]\n-fn test_c_dependency_no_rebuilding() {\n-    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n-    let dir = create_local_package(&cdep_id);\n-    let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n-              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\nfn main() { unsafe { f(); } }\");\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]), \"void f() {}\");\n-\n-    debug!(\"dir = {}\", dir.display());\n-    let source = Path::new(file!()).dir_path().join_many(\n-        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]));\n-    command_line_test([~\"build\", ~\"cdep\"], dir);\n-    assert_executable_exists(dir, \"cdep\");\n-    let out_dir = target_build_dir(dir).join(\"cdep\");\n-    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n-    debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(c_library_path.exists());\n-\n-    // Now, make it read-only so rebuilding will fail\n-    assert!(chmod_read_only(&c_library_path));\n-\n-    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n-        Success(..) => (), // ok\n-        Fail(ref r) if r.status.matches_exit_status(65) =>\n-            fail!(\"test_c_dependency_no_rebuilding failed: \\\n-                    it tried to rebuild foo.c\"),\n-        Fail(_) =>\n-            fail!(\"test_c_dependency_no_rebuilding failed for some other reason\")\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason=\"busted\")]\n-fn test_c_dependency_yes_rebuilding() {\n-    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n-    let dir = create_local_package(&cdep_id);\n-    let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n-              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n-              \\nfn main() { unsafe { f(); } }\");\n-    let c_file_name = dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]);\n-    writeFile(&c_file_name, \"void f() {}\");\n-\n-    let source = Path::new(file!()).dir_path().join_many(\n-        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    let target = dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]);\n-    debug!(\"Copying {} -> {}\", source.display(), target.display());\n-    fs::copy(&source, &target);\n-    command_line_test([~\"build\", ~\"cdep\"], dir);\n-    assert_executable_exists(dir, \"cdep\");\n-    let out_dir = target_build_dir(dir).join(\"cdep\");\n-    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n-    debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(c_library_path.exists());\n-\n-    // Now, make the Rust library read-only so rebuilding will fail\n-    match built_library_in_workspace(&cdep_id, dir) {\n-        Some(ref pth) => assert!(chmod_read_only(pth)),\n-        None => assert_built_library_exists(dir, \"cdep\")\n-    }\n-\n-    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n-        Success(..) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n-                            it didn't rebuild and should have\"),\n-        Fail(ref r) if r.status.matches_exit_status(65) => (),\n-        Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n-    }\n-}\n-\n-// n.b. This might help with #10253, or at least the error will be different.\n-#[test]\n-fn correct_error_dependency() {\n-    // Supposing a package we're trying to install via a dependency doesn't\n-    // exist, we should throw a condition, and not ICE\n-    let crate_id: CrateId = from_str(\"badpkg\").unwrap();\n-    let workspace_dir = create_local_package(&crate_id);\n-\n-    let dir = workspace_dir.path();\n-    let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);\n-    writeFile(&main_rs,\n-              \"extern mod p = \\\"some_package_that_doesnt_exist\\\";\n-               fn main() {}\");\n-    match command_line_test_partial([~\"build\", ~\"badpkg\"], dir) {\n-        Fail(ProcessOutput{ error: error, output: output, .. }) => {\n-            assert!(str::is_utf8(error));\n-            assert!(str::is_utf8(output));\n-            let error_str = str::from_utf8(error).unwrap();\n-            let out_str   = str::from_utf8(output).unwrap();\n-            debug!(\"ss = {}\", error_str);\n-            debug!(\"out_str = {}\", out_str);\n-            if out_str.contains(\"Package badpkg depends on some_package_that_doesnt_exist\") &&\n-                !error_str.contains(\"nonexistent_package\") {\n-                // Ok\n-                ()\n-            } else {\n-                fail!(\"Wrong error\");\n-            }\n-        }\n-        Success(..)       => fail!(\"Test passed when it should have failed\")\n-    }\n-}\n-\n-/// Returns true if p exists and is executable\n-fn is_executable(p: &Path) -> bool {\n-    p.exists() && p.stat().perm & io::UserExecute == io::UserExecute\n-}"}, {"sha": "a4c2c1baabeffe37906b0fa8cc66e230da2a4c2a", "filename": "src/librustpkg/testsuite/fail/src/no-inferred-crates/src/zzyzx.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg build hello-world`:\n-  * testsuite/hello-world/build/ exists\n-  * testsuite/hello-world/build/ contains an executable named hello-world\n-  * testsuite/hello-world/build/ does not contain a library\n-*/\n-\n-fn main() {\n-    println!(\"Hello world!\");\n-}"}, {"sha": "baeaef1e3c791b278cce3dc9e6abd0caed613d3b", "filename": "src/librustpkg/testsuite/pass/commands.txt", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,34 +0,0 @@\n-Commands that should succeed:\n-\n-1. rustpkg install github.com/mozilla-servo/rust-http-client\n-\n-2. Create a git repo containing a package \"foo\", add a tag called \"1.0\" -- `rustpkg install foo` should install a library called \"libfoo-....-1.0...\"\n-\n-3. rustpkg install foo, if ./.rust/foo exists and is a valid package directory\n-\n-4. RUST_PATH=/home/rust rustpkg install foo installs an executable in /home/rust/foo if ./foo exists and is a valid package directory\n-\n-5. RUST_PATH=/home/rust:/home/more_rust rustpkg install foo succeeds if /home/more_rust/foo exists and is a valid package directory\n-\n-6. rustpkg install foo; rustpkg install bar; rustpkg install quux; rustpkg list should show foo, bar, and quux\n-  6a. then, rustpkg remove foo; rustpkg list should show bar and quux, but not foo\n-\n-7. Execute `rustpkg build foo`. Check the datestamp on build/foo. Execute the same command again. Make sure the datestamp hasn't changed.\n-\n-8. Execute `rustpkg build foo` where foo has a dependency on bar, which hasn't been built before. Check the datestamps on build/foo and build/bar and make sure bar's datestamp is earlier than foo's.\n-\n-9. Execute `rustpkg build foo` where foo has a dependency on bar, which hasn't been built before. Then, change one of the source files in bar. Execute `rustpkg build foo` again. Make sure, based on datestamps, that foo was really rebuilt.\n-\n-10. Repeat test 9 in the case where the contents of the source file in bar change but its datestamp doesn't change.\n-\n-11. If the current directory contains package directories for foo-0.1 and foo.0.2, `rustpkg install foo#0.1` installs foo#0.1 and doesn't install foo#0.2.\n-\n-12. `rustpkg do fancy-pkg frob` succeeds if `fancy-pkg` has a package script that defines a custom build hook named `frob`.\n-\n-13. `rustpkg info foo` prints out something about foo, if foo is installed.\n-\n-14. (Not sure what prefer and unprefer do)\n-\n-15. `rustpkg test foo` runs tests and prints their output, if foo contains #[test]s.\n-\n-16. If foo is installed, `rustpkg uninstall foo; rustpkg list` doesn't include foo in the list"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/bar.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn assert_true() {\n-    assert!(true);\n-}"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/foo.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn do_nothing() {\n-}"}, {"sha": "bd1cb240a34cb88f3b2bb6a4df568aa797dece35", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/lib.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod std;\n-\n-pub mod foo;\n-pub mod bar;"}, {"sha": "dcc39ae0e92b43d9fe7ec20e138b05710f657969", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod rustpkg;\n-extern mod rustc;\n-\n-use std::{os, task};\n-use rustpkg::api;\n-use rustpkg::version::None;\n-use rustpkg::workcache_support::digest_file_with_date;\n-use rustpkg::exit_codes::COPY_FAILED_CODE;\n-\n-pub fn main() {\n-    let args = os::args();\n-\n-// by convention, first arg is sysroot\n-    if args.len() < 2 {\n-        fail!(\"Package script requires a directory where rustc libraries live as the first \\\n-               argument\");\n-    }\n-\n-    let path_for_db = api::default_workspace();\n-    debug!(\"path_for_db = {}\", path_for_db.display());\n-\n-    let sysroot_arg = args[1].clone();\n-    let sysroot = Path::new(sysroot_arg);\n-    if !sysroot.exists() {\n-        fail!(\"Package script requires a sysroot that exists; {} doesn't\", sysroot.display());\n-    }\n-\n-    if args[2] != ~\"install\" {\n-        println!(\"Warning: I don't know how to {}\", args[2]);\n-        return;\n-    }\n-\n-    let mut context = api::default_context(sysroot, path_for_db);\n-    let my_workspace = api::my_workspace(&context.context, \"cdep\");\n-    let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]);\n-\n-    let out_lib_path = context.workcache_context.with_prep(\"foo.c\", |prep| {\n-        let sub_cx = context.context.clone();\n-        debug!(\"foo_c_name = {}\", foo_c_name.display());\n-        prep.declare_input(\"file\",\n-                           foo_c_name.as_str().unwrap().to_owned(),\n-                           digest_file_with_date(&foo_c_name));\n-        let out_path = prep.exec(|exec| {\n-            let out_path = api::build_library_in_workspace(exec,\n-                                                           &mut sub_cx.clone(),\n-                                                           \"cdep\",\n-                                                           \"gcc\",\n-                                                           [~\"-c\"],\n-                                                           [~\"foo.c\"],\n-                                                           \"foo\");\n-            let out_p = Path::new(out_path.unwrap());\n-            out_p.as_str().unwrap().to_owned()\n-        });\n-        out_path\n-    });\n-    let out_lib_path = Path::new(out_lib_path);\n-    debug!(\"out_lib_path = {}\", out_lib_path.display());\n-    context.add_library_path(out_lib_path.dir_path());\n-\n-    let context_clone = context.clone();\n-    let task_res = task::try(proc() {\n-        let mut cc = context_clone.clone();\n-        api::install_pkg(&mut cc,\n-                         os::getcwd(),\n-                         ~\"cdep\",\n-                         None,\n-                         ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n-    });\n-\n-    if task_res.is_err() {\n-        os::set_exit_status(COPY_FAILED_CODE);\n-    }\n-}"}, {"sha": "62785c06db31ab1dcd5af6e101a02a2af4c6aeab", "filename": "src/librustpkg/testsuite/pass/src/deeply/nested/path/foo/main.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg install deeply/nested/path/foo`:\n-  with RUST_PATH undefined in the environment:\n-   * ./deeply/nested/path/foo exists and is an executable\n-*/\n-\n-fn main() {}"}, {"sha": "1e5c1d5e627d18a9c4f8ee57d5bd6bd574ace710", "filename": "src/librustpkg/testsuite/pass/src/external-crate/main.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg install external crate`\n-  with RUST_PATH undefined in the environment\n-  and with `rustpkg install deeply/nested/path/foo` already\n-     executed:\n-   * ../bin/external_crate exists and is an executable\n-\n-  tjc: Also want a test like this where foo is an external URL,\n-    which requires the `extern mod` changes\n-*/\n-\n-extern mod foo;\n-\n-fn main() {}"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/bar.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fbar.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn assert_true() {\n-    assert!(true);\n-}"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/foo.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn do_nothing() {\n-}"}, {"sha": "17386cd03c22b605a6edd3c6f758005bbcb67d00", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/lib.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg build fancy-lib`:\n-  * testsuite/fancy-lib/build/ exists\n-  * testsuite/fancy-lib/build/ contains a file called generated.rs\n-  * testsuite/fancy-lib/build/ contains a library named libfancy_lib\n-  * testsuite/fancy-lib/build/ does not contain an executable\n-  *\n-*/\n-\n-extern mod std;\n-\n-pub mod foo;\n-pub mod bar;\n-#[path = \"../../build/fancy-lib/generated.rs\"] pub mod generated;"}, {"sha": "7b1291025e40b222ae51f7195943b651a606586b", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern mod rustpkg;\n-extern mod rustc;\n-\n-use std::os;\n-use std::io::File;\n-use rustpkg::api;\n-use rustpkg::version::None;\n-\n-pub fn main() {\n-    let args = os::args();\n-\n-// by convention, first arg is sysroot\n-    if args.len() < 2 {\n-        debug!(\"Failing, arg len\");\n-        fail!(\"Package script requires a directory where rustc libraries live as the first \\\n-               argument\");\n-    }\n-\n-    let sysroot_arg = args[1].clone();\n-    let sysroot = Path::new(sysroot_arg);\n-    if !sysroot.exists() {\n-        debug!(\"Failing, sysroot\");\n-        fail!(\"Package script requires a sysroot that exists;{} doesn't\", sysroot.display());\n-    }\n-\n-    if args[2] != ~\"install\" {\n-        debug!(\"Failing, weird command\");\n-        println!(\"Warning: I don't know how to {}\", args[2]);\n-        return;\n-    }\n-\n-    debug!(\"Checking self_exe_path\");\n-    let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n-\n-    debug!(\"Writing file\");\n-    let mut file = File::create(&out_path.join(\"generated.rs\"));\n-    file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n-                for _ in xs.iter() { assert!(true); } }\".as_bytes());\n-\n-    let context = api::default_context(sysroot, api::default_workspace());\n-    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", None, ~[]);\n-}"}, {"sha": "63743160d12e1f7be52e761144a7bd44c6bb0807", "filename": "src/librustpkg/testsuite/pass/src/foo/lib.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn f() {}"}, {"sha": "54b536664a3453943822f51dfacc2136a36e3227", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg build hello-world`:\n-  * testsuite/pass/hello-world/build/ exists\n-  * testsuite/pass/hello-world/build/ contains an executable named hello-world\n-  * testsuite/pass/hello-world/build/ does not contain a library\n-\n- It should also check that after `rustpkg clean hello-world`:\n-  * testsuite/pass/hello-world/build is empty\n-*/\n-\n-fn main() {\n-    println!(\"Hello world!\");\n-}"}, {"sha": "62ee0ed88fdd98171e6d8089cbdf4ee3585682ea", "filename": "src/librustpkg/testsuite/pass/src/install-paths/bench.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[bench]\n-pub fn g() {\n-    let mut x = 0;\n-    while x < 1000 {\n-        x += 1;\n-    }\n-}"}, {"sha": "2cc0056696f31e1c2cccd5bf24f23b6249f558db", "filename": "src/librustpkg/testsuite/pass/src/install-paths/lib.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn f() -> int { 42 }"}, {"sha": "431350c07b487dbcdb31eefba84315d7568ee67f", "filename": "src/librustpkg/testsuite/pass/src/install-paths/main.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fmain.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg install install-paths`\n-  with RUST_PATH undefined in the environment:\n-   * ./.rust/install_paths exists and is an executable\n-   * ./.rust/libinstall_paths exists and is a library\n-   * ./.rust/install_pathstest does not exist\n-   * ./.rust/install_pathsbench does not exist\n-   * install-paths/build/install_pathstest exists and is an executable\n-   * install-paths/build/install_pathsbench exists and is an executable\n-*/\n-\n-use lib::f;\n-\n-mod lib;\n-\n-fn main() {\n-    f();\n-}"}, {"sha": "011a1540e1bca90dd2a8ad0a8e21fce0874e747e", "filename": "src/librustpkg/testsuite/pass/src/install-paths/test.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Ftest.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[test]\n-fn test_two_plus_two() {\n-    assert_eq!(2 + 2, 4);\n-}"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/simple-lib/src/bar.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Fbar.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn assert_true() {\n-    assert!(true);\n-}"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/simple-lib/src/foo.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn do_nothing() {\n-}"}, {"sha": "1cdca6cdd5d87f3208ac2d85c9ba255447c59dbf", "filename": "src/librustpkg/testsuite/pass/src/simple-lib/src/lib.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Flib.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-The test runner should check that, after `rustpkg build simple-lib`:\n-  * testsuite/simple-lib/build/ exists\n-  * testsuite/simple-lib/build/ contains a library named libsimple_lib\n-  * testsuite/simple-lib/build/ does not contain an executable\n-*/\n-\n-extern mod std;\n-\n-pub mod foo;\n-pub mod bar;"}, {"sha": "04cc13d0650c951d703de65578c978744cebd698", "filename": "src/librustpkg/usage.rs", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,181 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use context::Command;\n-\n-pub fn general() {\n-    println!(\"Usage: rustpkg [options] <cmd> [args..]\n-\n-Where <cmd> is one of:\n-    build, clean, do, info, install, list, prefer, test, uninstall, unprefer\n-\n-For more help on a given command, you can run:\n-    rustpkg help <cmd>\n-\n-Options:\n-\n-    -h, --help                  Display this message\n-    --sysroot PATH              Override the system root\n-    <cmd> -h, <cmd> --help      Display help for <cmd>\");\n-}\n-\n-pub fn build() {\n-    println!(\"rustpkg build [options..] [package-ID]\n-\n-Build the given package ID if specified. With no package ID argument,\n-build the package in the current directory. In that case, the current\n-directory must be a direct child of an `src` directory in a workspace.\n-\n-Options:\n-    -c, --cfg      Pass a cfg flag to the package script\n-    --no-link      Compile and assemble, but don't link (like -c in rustc)\n-    --no-trans     Parse and translate, but don't generate any code\n-    --pretty       Pretty-print the code, but don't generate output\n-    --parse-only   Parse the code, but don't typecheck or generate code\n-    -S             Generate assembly code, but don't assemble or link it\n-    -S --emit-llvm Generate LLVM assembly code\n-    --emit-llvm    Generate LLVM bitcode\n-    --linker PATH  Use a linker other than the system linker\n-    --link-args [ARG..] Extra arguments to pass to the linker\n-    --opt-level=n  Set the optimization level (0 <= n <= 3)\n-    -O             Equivalent to --opt-level=2\n-    --save-temps   Don't delete temporary files\n-    --target TRIPLE Set the target triple\n-    --target-cpu CPU Set the target CPU\n-    -Z FLAG        Enable an experimental rustc feature (see `rustc --help`)\");\n-}\n-\n-pub fn clean() {\n-    println!(\"rustpkg clean\n-\n-Remove all build files in the work cache for the package in the current\n-directory.\");\n-}\n-\n-pub fn do_cmd() {\n-    println!(r\"rustpkg do <cmd>\n-\n-Runs a command in the package script. You can listen to a command\n-by tagging a function with the attribute `\\#[pkg_do(cmd)]`.\");\n-}\n-\n-pub fn info() {\n-    println!(\"rustpkg [options..] info\n-\n-Probe the package script in the current directory for information.\n-\n-Options:\n-    -j, --json      Output the result as JSON\");\n-}\n-\n-pub fn list() {\n-    println!(\"rustpkg list\n-\n-List all installed packages.\");\n-}\n-\n-pub fn install() {\n-    println!(r\"rustpkg install [options..] [package-ID]\n-\n-Install the given package ID if specified. With no package ID\n-argument, install the package in the current directory.\n-In that case, the current directory must be a direct child of a\n-`src` directory in a workspace.\n-\n-Examples:\n-    rustpkg install\n-    rustpkg install github.com/mozilla/servo\n-    rustpkg install github.com/mozilla/servo\\#0.1.2\n-\n-Options:\n-    -c, --cfg      Pass a cfg flag to the package script\n-    --emit-llvm    Generate LLVM bitcode\n-    --linker PATH  Use a linker other than the system linker\n-    --link-args [ARG..] Extra arguments to pass to the linker\n-    --opt-level=n  Set the optimization level (0 <= n <= 3)\n-    -O             Equivalent to --opt-level=2\n-    --save-temps   Don't delete temporary files\n-    --target TRIPLE Set the target triple\n-    --target-cpu CPU Set the target CPU\n-    -Z FLAG        Enable an experimental rustc feature (see `rustc --help`)\");\n-}\n-\n-pub fn uninstall() {\n-    println!(\"rustpkg uninstall <id|name>[@version]\n-\n-Remove a package by id or name and optionally version. If the package(s)\n-is/are depended on by another package then they cannot be removed.\");\n-}\n-\n-pub fn prefer() {\n-    println!(\"rustpkg [options..] prefer <id|name>[@version]\n-\n-By default all binaries are given a unique name so that multiple versions can\n-coexist. The prefer command will symlink the uniquely named binary to\n-the binary directory under its bare name. If version is not supplied, the\n-latest version of the package will be preferred.\n-\n-Example:\n-    export PATH=$PATH:/home/user/.rustpkg/bin\n-    rustpkg prefer machine@1.2.4\n-    machine -v\n-    ==> v1.2.4\n-    rustpkg prefer machine@0.4.6\n-    machine -v\n-    ==> v0.4.6\");\n-}\n-\n-pub fn unprefer() {\n-    println!(\"rustpkg [options..] unprefer <id|name>[@version]\n-\n-Remove all symlinks from the store to the binary directory for a package\n-name and optionally version. If version is not supplied, the latest version\n-of the package will be unpreferred. See `rustpkg prefer -h` for more\n-information.\");\n-}\n-\n-pub fn test() {\n-    println!(\"rustpkg [options..] test\n-\n-Build all test crates in the current directory with the test flag.\n-Then, run all the resulting test executables, redirecting the output\n-and exit code.\n-\n-Options:\n-    -c, --cfg      Pass a cfg flag to the package script\");\n-}\n-\n-pub fn init() {\n-    println!(\"rustpkg init\n-\n-This will turn the current working directory into a workspace. The first\n-command you run when starting off a new project.\n-\");\n-}\n-\n-pub fn usage_for_command(command: Command){\n-    match command {\n-        BuildCmd => build(),\n-        CleanCmd => clean(),\n-        DoCmd => do_cmd(),\n-        HelpCmd => general(),\n-        InfoCmd => info(),\n-        InstallCmd => install(),\n-        ListCmd => list(),\n-        PreferCmd => prefer(),\n-        TestCmd => test(),\n-        InitCmd => init(),\n-        UninstallCmd => uninstall(),\n-        UnpreferCmd => unprefer(),\n-    };\n-}\n-\n-\n-"}, {"sha": "ba31699a7d04e54450f894edc3d02e965b630e78", "filename": "src/librustpkg/util.rs", "status": "removed", "additions": 0, "deletions": 699, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,699 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(dead_code)];\n-\n-pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n-pub use target::{Target, Build, Install};\n-pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n-\n-use std::cell::RefCell;\n-use std::libc;\n-use std::os;\n-use std::io;\n-use std::io::fs;\n-use extra::workcache;\n-use rustc::metadata::creader::Loader;\n-use extra::treemap::TreeMap;\n-use extra::getopts::groups::getopts;\n-use syntax;\n-use syntax::codemap::{DUMMY_SP, Spanned};\n-use syntax::ext::base;\n-use syntax::ext::base::{ExtCtxt, MacroCrate};\n-use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n-use syntax::attr::AttrMetaMethods;\n-use syntax::fold::Folder;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n-use syntax::visit::Visitor;\n-use syntax::util::small_vector::SmallVector;\n-use syntax::crateid::CrateId;\n-use rustc::back::link::OutputTypeExe;\n-use rustc::back::link;\n-use rustc::driver::{driver, session};\n-use CtxMethods;\n-use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n-use package_source::PkgSrc;\n-use workspace::pkg_parent_workspaces;\n-use path_util::{system_library, target_build_dir};\n-use path_util::{default_workspace, built_library_in_workspace};\n-use workcache_support::{digest_file_with_date, digest_only_date};\n-use messages::error;\n-\n-\n-pub type ExitCode = int; // For now\n-\n-pub struct Pkg {\n-    id: CrateId,\n-    bins: ~[~str],\n-    libs: ~[~str],\n-}\n-\n-impl ToStr for Pkg {\n-    fn to_str(&self) -> ~str {\n-        self.id.to_str()\n-    }\n-}\n-\n-struct ListenerFn {\n-    cmds: ~[~str],\n-    span: codemap::Span,\n-    path: ~[ast::Ident]\n-}\n-\n-struct ReadyCtx<'a> {\n-    sess: session::Session,\n-    ext_cx: ExtCtxt<'a>,\n-    path: ~[ast::Ident],\n-    fns: ~[ListenerFn]\n-}\n-\n-fn fold_mod(m: &ast::Mod, fold: &mut CrateSetup) -> ast::Mod {\n-    fn strip_main(item: @ast::Item) -> @ast::Item {\n-        @ast::Item {\n-            attrs: item.attrs.iter().filter_map(|attr| {\n-                if !attr.name().equiv(&(\"main\")) {\n-                    Some(*attr)\n-                } else {\n-                    None\n-                }\n-            }).collect(),\n-            .. (*item).clone()\n-        }\n-    }\n-\n-    fold::noop_fold_mod(&ast::Mod {\n-        items: m.items.map(|item| strip_main(*item)),\n-        .. (*m).clone()\n-    }, fold)\n-}\n-\n-fn fold_item(item: @ast::Item, fold: &mut CrateSetup)\n-             -> SmallVector<@ast::Item> {\n-    fold.ctx.path.push(item.ident);\n-\n-    let mut cmds = ~[];\n-    let mut had_pkg_do = false;\n-\n-    for attr in item.attrs.iter() {\n-        if attr.name().equiv(&(\"pkg_do\")) {\n-            had_pkg_do = true;\n-            match attr.node.value.node {\n-                ast::MetaList(_, ref mis) => {\n-                    for mi in mis.iter() {\n-                        match mi.node {\n-                            ast::MetaWord(ref cmd) => {\n-                                cmds.push(cmd.get().to_owned())\n-                            }\n-                            _ => {}\n-                        };\n-                    }\n-                }\n-                _ => cmds.push(~\"build\")\n-            }\n-        }\n-    }\n-\n-    if had_pkg_do {\n-        fold.ctx.fns.push(ListenerFn {\n-            cmds: cmds,\n-            span: item.span,\n-            path: /*bad*/fold.ctx.path.clone()\n-        });\n-    }\n-\n-    let res = fold::noop_fold_item(item, fold);\n-\n-    fold.ctx.path.pop();\n-\n-    res\n-}\n-\n-struct CrateSetup<'a> {\n-    ctx: &'a mut ReadyCtx<'a>,\n-}\n-\n-impl<'a> Folder for CrateSetup<'a> {\n-    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n-        fold_item(item, self)\n-    }\n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n-        fold_mod(module, self)\n-    }\n-}\n-\n-/// Generate/filter main function, add the list of commands, etc.\n-pub fn ready_crate(sess: session::Session,\n-                   crate: ast::Crate) -> ast::Crate {\n-    let loader = &mut Loader::new(sess);\n-    let mut ctx = ReadyCtx {\n-        sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(), loader),\n-        path: ~[],\n-        fns: ~[]\n-    };\n-    let mut fold = CrateSetup {\n-        ctx: &mut ctx,\n-    };\n-    fold.fold_crate(crate)\n-}\n-\n-pub fn compile_input(context: &BuildContext,\n-                     exec: &mut workcache::Exec,\n-                     crate_id: &CrateId,\n-                     in_file: &Path,\n-                     workspace: &Path,\n-                     deps: &mut DepMap,\n-                     flags: &[~str],\n-                     cfgs: &[~str],\n-                     opt: session::OptLevel,\n-                     what: OutputType) -> Option<Path> {\n-    assert!(in_file.components().nth(1).is_some());\n-    let input = driver::FileInput(in_file.clone());\n-    debug!(\"compile_input: {} / {:?}\", in_file.display(), what);\n-    // tjc: by default, use the package ID name as the link name\n-    // not sure if we should support anything else\n-\n-    let mut out_dir = target_build_dir(workspace);\n-    out_dir.push(crate_id.path.as_slice());\n-    // Make the output directory if it doesn't exist already\n-    fs::mkdir_recursive(&out_dir, io::UserRWX);\n-\n-    let binary = os::args()[0];\n-\n-    debug!(\"flags: {}\", flags.connect(\" \"));\n-    debug!(\"cfgs: {}\", cfgs.connect(\" \"));\n-    let csysroot = context.sysroot();\n-    debug!(\"compile_input's sysroot = {}\", csysroot.display());\n-\n-    let matches = getopts(debug_flags()\n-                          + match what {\n-                              Lib => ~[~\"--lib\"],\n-                              // --test compiles both #[test] and #[bench] fns\n-                              Test | Bench => ~[~\"--test\"],\n-                              Main => ~[]\n-                          }\n-                          + flags\n-                          + context.flag_strs()\n-                          + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n-                          driver::optgroups()).unwrap();\n-    debug!(\"rustc flags: {:?}\", matches);\n-\n-    // Hack so that rustpkg can run either out of a rustc target dir,\n-    // or the host dir\n-    let sysroot_to_use = @if !in_target(&context.sysroot()) {\n-        context.sysroot()\n-    }\n-    else {\n-        let mut p = context.sysroot().clone();\n-        p.pop();\n-        p.pop();\n-        p.pop();\n-        p\n-    };\n-    let csysroot = context.sysroot();\n-    debug!(\"compile_input's sysroot = {}\", csysroot.display());\n-    debug!(\"sysroot_to_use = {}\", sysroot_to_use.display());\n-\n-    let output_type = match context.compile_upto() {\n-        Assemble => link::OutputTypeAssembly,\n-        Link     => link::OutputTypeObject,\n-        Pretty | Trans | Analysis => link::OutputTypeNone,\n-        LLVMAssemble => link::OutputTypeLlvmAssembly,\n-        LLVMCompileBitcode => link::OutputTypeBitcode,\n-        Nothing => link::OutputTypeExe\n-    };\n-\n-    debug!(\"Output type = {:?}\", output_type);\n-\n-    let options = @session::Options {\n-        optimize: opt,\n-        test: what == Test || what == Bench,\n-        maybe_sysroot: Some(sysroot_to_use),\n-        addl_lib_search_paths:\n-            @RefCell::new(context.additional_library_paths()),\n-        output_type: output_type,\n-        .. (*driver::build_session_options(binary,\n-                                           &matches,\n-                                           @diagnostic::DefaultEmitter as\n-                                            @diagnostic::Emitter)).clone()\n-    };\n-\n-    debug!(\"Created options...\");\n-\n-    let addl_lib_search_paths = @RefCell::new(options.addl_lib_search_paths);\n-    // Make sure all the library directories actually exist, since the linker will complain\n-    // otherwise\n-    {\n-        let mut addl_lib_search_paths = addl_lib_search_paths.borrow_mut();\n-        let addl_lib_search_paths = addl_lib_search_paths.get();\n-        let mut addl_lib_search_paths = addl_lib_search_paths.borrow_mut();\n-        for p in addl_lib_search_paths.get().iter() {\n-            if p.exists() {\n-                assert!(p.is_dir())\n-            }\n-            else {\n-                fs::mkdir_recursive(p, io::UserRWX);\n-            }\n-        }\n-    }\n-\n-    debug!(\"About to build session...\");\n-\n-    let sess = driver::build_session(options,\n-                                     Some(in_file.clone()),\n-                                     @diagnostic::DefaultEmitter as\n-                                        @diagnostic::Emitter);\n-\n-    debug!(\"About to build config...\");\n-\n-    // Infer dependencies that rustpkg needs to build, by scanning for\n-    // `extern mod` directives.\n-    let cfg = driver::build_configuration(sess);\n-    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-\n-    let (mut crate, ast_map) = {\n-        let installer = CrateInstaller {\n-            context: context,\n-            parent: crate_id,\n-            parent_crate: in_file,\n-            sess: sess,\n-            exec: exec,\n-            deps: deps,\n-            save: |p| {\n-                debug!(\"a dependency: {}\", p.display());\n-                let mut addl_lib_search_paths =\n-                    addl_lib_search_paths.borrow_mut();\n-                let addl_lib_search_paths =\n-                    addl_lib_search_paths.get();\n-                let mut addl_lib_search_paths =\n-                    addl_lib_search_paths.borrow_mut();\n-                // Pass the directory containing a dependency\n-                // as an additional lib search path\n-                addl_lib_search_paths.get().insert(p);\n-            },\n-        };\n-        let mut loader = CrateLoader {\n-            installer: installer,\n-            loader: Loader::new(sess),\n-        };\n-        let (crate, ast_map) = driver::phase_2_configure_and_expand(sess,\n-                                                     cfg.clone(),\n-                                                     &mut loader,\n-                                                     crate);\n-        let CrateLoader { mut installer, .. } = loader;\n-        debug!(\"About to call find_and_install_dependencies...\");\n-        find_and_install_dependencies(&mut installer, &crate);\n-        (crate, ast_map)\n-    };\n-\n-    // Inject the crate_id attribute so we get the right package name and version\n-    if !attr::contains_name(crate.attrs, \"crate_id\") {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let crateid_attr =\n-            attr::mk_name_value_item_str(\n-                InternedString::new(\"crate_id\"),\n-                token::intern_and_get_ident(crate_id.to_str()));\n-\n-        debug!(\"crateid attr: {:?}\", crateid_attr);\n-        crate.attrs.push(attr::mk_attr(crateid_attr));\n-    }\n-\n-    debug!(\"calling compile_crate_from_input, workspace = {},\n-           building_library = {:?}\", out_dir.display(), sess.building_library);\n-    let result = compile_crate_from_input(in_file,\n-                                          exec,\n-                                          context.compile_upto(),\n-                                          &out_dir,\n-                                          sess,\n-                                          crate,\n-                                          ast_map,\n-                                          what);\n-    // Discover the output\n-    let discovered_output = if what == Lib  {\n-        built_library_in_workspace(crate_id, workspace) // Huh???\n-    }\n-    else {\n-        result\n-    };\n-    for p in discovered_output.iter() {\n-        debug!(\"About to discover output {}\", p.display());\n-        if p.exists() {\n-            debug!(\"4. discovering output {}\", p.display());\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            exec.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n-        }\n-        // Nothing to do if it doesn't exist -- that could happen if we had the\n-        // -S or -emit-llvm flags, etc.\n-    }\n-    discovered_output\n-}\n-\n-// Should use workcache to avoid recompiling when not necessary\n-// Should also rename this to something better\n-// If crate_opt is present, then finish compilation. If it's None, then\n-// call compile_upto and return the crate\n-// also, too many arguments\n-// Returns list of discovered dependencies\n-pub fn compile_crate_from_input(input: &Path,\n-                                exec: &mut workcache::Exec,\n-                                stop_before: StopBefore,\n- // should be of the form <workspace>/build/<pkg id's path>\n-                                out_dir: &Path,\n-                                sess: session::Session,\n-// Returns None if one of the flags that suppresses compilation output was\n-// given\n-                                crate: ast::Crate,\n-                                ast_map: syntax::ast_map::Map,\n-                                what: OutputType) -> Option<Path> {\n-    debug!(\"Calling build_output_filenames with {}, building library? {:?}\",\n-           out_dir.display(), sess.building_library);\n-\n-    // bad copy\n-    debug!(\"out_dir = {}\", out_dir.display());\n-    let file_input = driver::FileInput(input.clone());\n-    let mut outputs = driver::build_output_filenames(&file_input,\n-                                                     &Some(out_dir.clone()), &None,\n-                                                     crate.attrs, sess);\n-    match what {\n-        Lib | Main => {}\n-        Test => {\n-            let mut ofile = outputs.out_filename.filename_str().unwrap().to_owned();\n-            ofile.push_str(\"test\");\n-            outputs.out_filename.set_filename(ofile);\n-        }\n-        Bench => {\n-            let mut ofile = outputs.out_filename.filename_str().unwrap().to_owned();\n-            ofile.push_str(\"bench\");\n-            outputs.out_filename.set_filename(ofile);\n-        }\n-    };\n-\n-    debug!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n-           outputs.out_filename.display(),\n-           outputs.obj_filename.display(),\n-           sess.opts.output_type);\n-    debug!(\"additional libraries:\");\n-    {\n-        let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n-        for lib in addl_lib_search_paths.get().iter() {\n-            debug!(\"an additional library: {}\", lib.display());\n-        }\n-    }\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &crate, ast_map);\n-    if driver::stop_after_phase_3(sess) { return None; }\n-    let translation = driver::phase_4_translate_to_llvm(sess, crate,\n-                                                        &analysis,\n-                                                        outputs);\n-    driver::phase_5_run_llvm_passes(sess, &translation, outputs);\n-    // The second check shouldn't be necessary, but rustc seems to ignore\n-    // -c\n-    if driver::stop_after_phase_5(sess)\n-        || stop_before == Link || stop_before == Assemble { return Some(outputs.out_filename); }\n-    driver::phase_6_link_output(sess, &translation, outputs);\n-\n-    // Register dependency on the source file\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    exec.discover_input(\"file\", input.as_str().unwrap(), digest_file_with_date(input));\n-\n-    debug!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n-           datestamp(&outputs.out_filename));\n-    Some(outputs.out_filename)\n-}\n-\n-#[cfg(windows)]\n-pub fn exe_suffix() -> ~str { ~\".exe\" }\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"macos\")]\n-pub fn exe_suffix() -> ~str { ~\"\" }\n-\n-// Called by build_crates\n-pub fn compile_crate(ctxt: &BuildContext,\n-                     exec: &mut workcache::Exec,\n-                     crate_id: &CrateId,\n-                     crate: &Path,\n-                     workspace: &Path,\n-                     deps: &mut DepMap,\n-                     flags: &[~str],\n-                     cfgs: &[~str],\n-                     opt: session::OptLevel,\n-                     what: OutputType) -> Option<Path> {\n-    debug!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n-    debug!(\"compile_crate: name = {}, flags =...\", crate_id.to_str());\n-    for fl in flags.iter() {\n-        debug!(\"+++ {}\", *fl);\n-    }\n-    compile_input(ctxt, exec, crate_id, crate, workspace, deps, flags, cfgs, opt, what)\n-}\n-\n-struct CrateInstaller<'a> {\n-    context: &'a BuildContext,\n-    parent: &'a CrateId,\n-    parent_crate: &'a Path,\n-    sess: session::Session,\n-    exec: &'a mut workcache::Exec,\n-    save: 'a |Path|,\n-    deps: &'a mut DepMap\n-}\n-\n-impl<'a> CrateInstaller<'a> {\n-    fn install_crate(&mut self, vi: &ast::ViewItem) {\n-        use conditions::nonexistent_package::cond;\n-\n-        match vi.node {\n-            // ignore metadata, I guess\n-            ast::ViewItemExternMod(ref lib_ident, ref path_opt, _) => {\n-                let lib_name = match *path_opt {\n-                    Some((ref p, _)) => (*p).clone(),\n-                    None => token::get_ident(lib_ident.name),\n-                };\n-                debug!(\"Finding and installing... {}\", lib_name);\n-                let crate_id: CrateId =\n-                    from_str(lib_name.get()).expect(\"valid crate id\");\n-                // Check standard Rust library path first\n-                let whatever = system_library(&self.context.sysroot_to_use(), &crate_id);\n-                debug!(\"system library returned {:?}\", whatever);\n-                match whatever {\n-                    Some(ref installed_path) => {\n-                        debug!(\"It exists: {}\", installed_path.display());\n-                        // Say that [path for c] has a discovered dependency on\n-                        // installed_path\n-                        // For binary files, we only hash the datestamp, not the contents.\n-                        // I'm not sure what the right thing is.\n-                        // Now we know that this crate has a discovered dependency on\n-                        // installed_path\n-                        // FIXME (#9639): This needs to handle non-utf8 paths\n-                        add_dep(self.deps, self.parent_crate.as_str().unwrap().to_owned(),\n-                                (~\"binary\", installed_path.as_str().unwrap().to_owned()));\n-                        self.exec.discover_input(\"binary\",\n-                                                 installed_path.as_str().unwrap(),\n-                                                 digest_only_date(installed_path));\n-                    }\n-                    None => {\n-                        // FIXME #8711: need to parse version out of path_opt\n-                        debug!(\"Trying to install library {}, rebuilding it\", crate_id.to_str());\n-                        // Try to install it\n-                        // Find all the workspaces in the RUST_PATH that contain this package.\n-                        let workspaces = pkg_parent_workspaces(&self.context.context,\n-                                                               &crate_id);\n-                        // Three cases:\n-                        // (a) `workspaces` is empty. That means there's no local source\n-                        // for this package. In that case, we pass the default workspace\n-                        // into `PkgSrc::new`, so that if it exists as a remote repository,\n-                        // its sources will be fetched into it. We also put the output in the\n-                        // same workspace.\n-                        // (b) We're using the Rust path hack. In that case, the output goes\n-                        // in the destination workspace.\n-                        // (c) `workspaces` is non-empty -- we found a local source for this\n-                        // package and will build in that workspace.\n-                        let (source_workspace, dest_workspace) = if workspaces.is_empty() {\n-                            (default_workspace(), default_workspace())\n-                        } else {\n-                            if self.context.context.use_rust_path_hack {\n-                                (workspaces[0], default_workspace())\n-                            } else {\n-                                 (workspaces[0].clone(), workspaces[0])\n-                            }\n-                        };\n-                        // In this case, the source and destination workspaces are the same:\n-                        // Either it's a remote package, so the local sources don't exist\n-                        // and the `PkgSrc` constructor will detect that;\n-                        // or else it's already in a workspace and we'll build into that\n-                        // workspace\n-                        let pkg_src = cond.trap(|_| {\n-                                 // Nonexistent package? Then print a better error\n-                                 error(format!(\"Package {} depends on {}, but I don't know \\\n-                                               how to find it\",\n-                                               self.parent.path,\n-                                               crate_id.path));\n-                                 fail!()\n-                        }).inside(|| {\n-                            PkgSrc::new(source_workspace.clone(),\n-                                        dest_workspace.clone(),\n-                                        // Use the rust_path_hack to search for dependencies iff\n-                                        // we were already using it\n-                                        self.context.context.use_rust_path_hack,\n-                                        crate_id.clone())\n-                        });\n-                        let (outputs_disc, inputs_disc) =\n-                            self.context.install(\n-                                pkg_src,\n-                                &WhatToBuild::new(Inferred,\n-                                                  JustOne(Path::new(lib_crate_filename))));\n-                        debug!(\"Installed {}, returned {:?} dependencies and \\\n-                               {:?} transitive dependencies\",\n-                               lib_name, outputs_disc.len(), inputs_disc.len());\n-                        debug!(\"discovered outputs = {:?} discovered_inputs = {:?}\",\n-                               outputs_disc, inputs_disc);\n-                        // It must have installed *something*...\n-                        assert!(!outputs_disc.is_empty());\n-                        for dep in outputs_disc.iter() {\n-                            debug!(\"Discovering a binary input: {}\", dep.display());\n-                            // FIXME (#9639): This needs to handle non-utf8 paths\n-                            self.exec.discover_input(\"binary\",\n-                                                     dep.as_str().unwrap(),\n-                                                     digest_only_date(dep));\n-                            add_dep(self.deps,\n-                                    self.parent_crate.as_str().unwrap().to_owned(),\n-                                    (~\"binary\", dep.as_str().unwrap().to_owned()));\n-\n-                            // Also, add an additional search path\n-                            let dep_dir = dep.dir_path();\n-                            debug!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n-                            (self.save)(dep_dir);\n-                        }\n-                        debug!(\"Installed {}, returned {} dependencies and \\\n-                                {} transitive dependencies\",\n-                                lib_name, outputs_disc.len(), inputs_disc.len());\n-                        // It must have installed *something*...\n-                        assert!(!outputs_disc.is_empty());\n-                        let mut target_workspace = outputs_disc[0].clone();\n-                        target_workspace.pop();\n-                        for &(ref what, ref dep) in inputs_disc.iter() {\n-                            if *what == ~\"file\" {\n-                                add_dep(self.deps,\n-                                        self.parent_crate.as_str().unwrap().to_owned(),\n-                                        (~\"file\", dep.clone()));\n-                                self.exec.discover_input(*what,\n-                                                         *dep,\n-                                                         digest_file_with_date(\n-                                                             &Path::new(dep.as_slice())));\n-                            } else if *what == ~\"binary\" {\n-                                add_dep(self.deps,\n-                                        self.parent_crate.as_str().unwrap().to_owned(),\n-                                        (~\"binary\", dep.clone()));\n-                                self.exec.discover_input(*what,\n-                                                         *dep,\n-                                                         digest_only_date(\n-                                                             &Path::new(dep.as_slice())));\n-                            } else {\n-                                fail!(\"Bad kind: {}\", *what);\n-                            }\n-                            // Also, add an additional search path\n-                            debug!(\"Installed {} into {}\",\n-                                    lib_name, target_workspace.as_str().unwrap().to_owned());\n-                            (self.save)(target_workspace.clone());\n-                        }\n-                    }\n-                }\n-            }\n-            // Ignore `use`s\n-            _ => ()\n-        }\n-    }\n-}\n-\n-impl<'a> Visitor<()> for CrateInstaller<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem, env: ()) {\n-        self.install_crate(vi);\n-        visit::walk_view_item(self, vi, env)\n-    }\n-}\n-\n-struct CrateLoader<'a> {\n-    installer: CrateInstaller<'a>,\n-    loader: Loader,\n-}\n-\n-impl<'a> base::CrateLoader for CrateLoader<'a> {\n-    fn load_crate(&mut self, crate: &ast::ViewItem) -> MacroCrate {\n-        self.installer.install_crate(crate);\n-        self.loader.load_crate(crate)\n-    }\n-\n-    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> ~[~str] {\n-        self.loader.get_exported_macros(cnum)\n-    }\n-\n-    fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n-        self.loader.get_registrar_symbol(cnum)\n-    }\n-}\n-\n-/// Collect all `extern mod` directives in `c`, then\n-/// try to install their targets, failing if any target\n-/// can't be found.\n-pub fn find_and_install_dependencies(installer: &mut CrateInstaller,\n-                                     c: &ast::Crate) {\n-    debug!(\"In find_and_install_dependencies...\");\n-    visit::walk_crate(installer, c, ())\n-}\n-\n-pub fn mk_string_lit(s: InternedString) -> ast::Lit {\n-    Spanned {\n-        node: ast::LitStr(s, ast::CookedStr),\n-        span: DUMMY_SP\n-    }\n-}\n-\n-pub fn option_to_vec<T>(x: Option<T>) -> ~[T] {\n-    match x {\n-       Some(y) => ~[y],\n-       None    => ~[]\n-    }\n-}\n-\n-// tjc: cheesy\n-fn debug_flags() -> ~[~str] { ~[] }\n-// static DEBUG_FLAGS: ~[~str] = ~[~\"-Z\", ~\"time-passes\"];\n-\n-\n-/// Returns the last-modified date as an Option\n-pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(),\n-           p.exists());\n-    match io::result(|| p.stat()) {\n-        Ok(s) => {\n-            let out = s.modified;\n-            debug!(\"Date = {:?}\", out);\n-            Some(out as libc::time_t)\n-        }\n-        Err(..) => None,\n-    }\n-}\n-\n-pub type DepMap = TreeMap<~str, ~[(~str, ~str)]>;\n-\n-/// Records a dependency from `parent` to the kind and value described by `info`,\n-/// in `deps`\n-fn add_dep(deps: &mut DepMap, parent: ~str, info: (~str, ~str)) {\n-    let mut done = false;\n-    let info_clone = info.clone();\n-    match deps.find_mut(&parent) {\n-        None => { }\n-        Some(v) => { done = true; (*v).push(info) }\n-    };\n-    if !done {\n-        deps.insert(parent, ~[info_clone]);\n-    }\n-}"}, {"sha": "93e7a052efa06d9bf29917e18968f3d6fee7ab22", "filename": "src/librustpkg/version.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,93 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// A version is either an exact revision,\n-/// or a semantic version\n-\n-extern mod std;\n-\n-use std::char;\n-\n-pub type Version = Option<~str>;\n-\n-// Being lazy since we don't have a regexp library now\n-#[deriving(Eq)]\n-enum ParseState {\n-    Start,\n-    SawDigit,\n-    SawDot\n-}\n-\n-pub fn try_parsing_version(s: &str) -> Option<~str> {\n-    let s = s.trim();\n-    debug!(\"Attempting to parse: {}\", s);\n-    let mut parse_state = Start;\n-    for c in s.chars() {\n-        if char::is_digit(c) {\n-            parse_state = SawDigit;\n-        }\n-        else if c == '.' && parse_state == SawDigit {\n-            parse_state = SawDot;\n-        }\n-        else {\n-            return None;\n-        }\n-    }\n-    match parse_state {\n-        SawDigit => Some(s.to_owned()),\n-        _        => None\n-    }\n-}\n-\n-/// If s is of the form foo#bar, where bar is a valid version\n-/// number, return the prefix before the # and the version.\n-/// Otherwise, return None.\n-pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n-    // Check for extra '#' characters separately\n-    if s.split('#').len() > 2 {\n-        return None;\n-    }\n-    split_version_general(s, '#')\n-}\n-\n-pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n-    match s.rfind(sep) {\n-        Some(i) => {\n-            let path = s.slice(0, i);\n-            // n.b. for now, assuming an exact revision is intended, not a SemVer\n-            Some((path, Some(s.slice(i + 1, s.len()).to_owned())))\n-        }\n-        None => {\n-            None\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_parse_version() {\n-    assert!(try_parsing_version(\"1.2\") == Some(~\"1.2\"));\n-    assert!(try_parsing_version(\"1.0.17\") == Some(~\"1.0.17\"));\n-    assert!(try_parsing_version(\"you're_a_kitty\") == None);\n-    assert!(try_parsing_version(\"42..1\") == None);\n-    assert!(try_parsing_version(\"17\") == Some(~\"17\"));\n-    assert!(try_parsing_version(\".1.2.3\") == None);\n-    assert!(try_parsing_version(\"2.3.\") == None);\n-}\n-\n-#[test]\n-fn test_split_version() {\n-    let s = \"a/b/c#0.1\";\n-    debug!(\"== {:?} ==\", split_version(s));\n-    assert!(split_version(s) == Some((s.slice(0, 5), Some(~\"0.1\"))));\n-    assert!(split_version(\"a/b/c\") == None);\n-    let s = \"a#1.2\";\n-    assert!(split_version(s) == Some((s.slice(0, 1), Some(~\"1.2\"))));\n-    assert!(split_version(\"a#a#3.4\") == None);\n-}"}, {"sha": "824ba5341d4f6cd6823d76662f7fce10f71168fb", "filename": "src/librustpkg/workcache_support.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use std::io::File;\n-use extra::workcache;\n-use sha2::{Digest, Sha256};\n-\n-/// Hashes the file contents along with the last-modified time\n-pub fn digest_file_with_date(path: &Path) -> ~str {\n-    use conditions::bad_path::cond;\n-\n-    match io::result(|| File::open(path).read_to_end()) {\n-        Ok(bytes) => {\n-            let mut sha = Sha256::new();\n-            sha.input(bytes);\n-            let st = path.stat();\n-            sha.input_str(st.modified.to_str());\n-            sha.result_str()\n-        }\n-        Err(e) => {\n-            cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e.desc)));\n-            ~\"\"\n-        }\n-    }\n-}\n-\n-/// Hashes only the last-modified time\n-pub fn digest_only_date(path: &Path) -> ~str {\n-    let mut sha = Sha256::new();\n-    let st = path.stat();\n-    sha.input_str(st.modified.to_str());\n-    sha.result_str()\n-}\n-\n-/// Adds multiple discovered outputs\n-pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n-    debug!(\"Discovering {:?} outputs\", outputs.len());\n-    for p in outputs.iter() {\n-        debug!(\"Discovering output! {}\", p.display());\n-        // For now, assume that all discovered outputs are binaries\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        e.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n-    }\n-}\n-\n-/// Returns the function name for building a crate\n-pub fn crate_tag(p: &Path) -> ~str {\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    p.as_str().unwrap().to_owned() // implicitly, it's \"build(p)\"...\n-}"}, {"sha": "e19a19dc8ab6addaae34142a44a487bd7e6fec00", "filename": "src/librustpkg/workspace.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e39e3e80dcf726a96ec0fe778f96e2a9dde620b/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=3e39e3e80dcf726a96ec0fe778f96e2a9dde620b", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg utilities having to do with workspaces\n-\n-use std::os;\n-use context::Context;\n-use path_util::{workspace_contains_crate_id, find_dir_using_rust_path_hack, default_workspace};\n-use path_util::rust_path;\n-use util::option_to_vec;\n-use syntax::crateid::CrateId;\n-\n-pub fn each_pkg_parent_workspace(cx: &Context,\n-                                 crateid: &CrateId,\n-                                 action: |&Path| -> bool)\n-                                 -> bool {\n-    // Using the RUST_PATH, find workspaces that contain\n-    // this package ID\n-    let workspaces = pkg_parent_workspaces(cx, crateid);\n-    if workspaces.is_empty() {\n-        // tjc: make this a condition\n-        fail!(\"Package {} not found in any of \\\n-                    the following workspaces: {}\",\n-                   crateid.path,\n-                   rust_path().map(|p| p.display().to_str()).to_str());\n-    }\n-    for ws in workspaces.iter() {\n-        if action(ws) {\n-            break;\n-        }\n-    }\n-    return true;\n-}\n-\n-/// Given a package ID, return a vector of all of the workspaces in\n-/// the RUST_PATH that contain it\n-pub fn pkg_parent_workspaces(cx: &Context, crateid: &CrateId) -> ~[Path] {\n-    let rs: ~[Path] = rust_path().move_iter()\n-        .filter(|ws| workspace_contains_crate_id(crateid, ws))\n-        .collect();\n-    if cx.use_rust_path_hack {\n-        rs + option_to_vec(find_dir_using_rust_path_hack(crateid))\n-    }\n-    else {\n-        rs\n-    }\n-}\n-\n-/// Construct a workspace and package-ID name based on the current directory.\n-/// This gets used when rustpkg gets invoked without a package-ID argument.\n-pub fn cwd_to_workspace() -> Option<(Path, CrateId)> {\n-    let cwd = os::getcwd();\n-    for path in rust_path().move_iter() {\n-        let srcpath = path.join(\"src\");\n-        if srcpath.is_ancestor_of(&cwd) {\n-            let rel = cwd.path_relative_from(&srcpath);\n-            let rel_s = rel.as_ref().and_then(|p|p.as_str());\n-            if rel_s.is_some() {\n-                let crate_id = from_str(rel_s.unwrap()).expect(\"valid crate id\");\n-                return Some((path, crate_id));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-/// If `workspace` is the same as `cwd`, and use_rust_path_hack is false,\n-/// return `workspace`; otherwise, return the first workspace in the RUST_PATH.\n-pub fn determine_destination(cwd: Path, use_rust_path_hack: bool, workspace: &Path) -> Path {\n-    if workspace == &cwd && !use_rust_path_hack {\n-        workspace.clone()\n-    }\n-    else {\n-        default_workspace()\n-    }\n-}"}]}