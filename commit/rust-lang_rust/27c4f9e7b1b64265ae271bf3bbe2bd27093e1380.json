{"sha": "27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YzRmOWU3YjFiNjQyNjVhZTI3MWJmM2JiZTJiZDI3MDkzZTEzODA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-12-01T23:06:34Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-12-10T02:55:05Z"}, "message": "Fix a bug in which the visibility of a use declaration defining a name in one namespace (e.g. the value namespace) is overridden by a later use declaration defining the same name in the other namespace (e.g. the type namespace).", "tree": {"sha": "7e2fdc6d830a0176af541058933299eb7f15056d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e2fdc6d830a0176af541058933299eb7f15056d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "html_url": "https://github.com/rust-lang/rust/commit/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ae8be71c5ce8e3b5f6b7ef480d140ed2248cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ae8be71c5ce8e3b5f6b7ef480d140ed2248cf2", "html_url": "https://github.com/rust-lang/rust/commit/81ae8be71c5ce8e3b5f6b7ef480d140ed2248cf2"}], "stats": {"total": 300, "additions": 153, "deletions": 147}, "files": [{"sha": "0fc87c8b74ad12ce1f1d58e314d5194073d31c16", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -16,7 +16,7 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::ImportResolution;\n+use resolve_imports::{ImportResolution, NsImportResolution};\n use Module;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n@@ -827,9 +827,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         resolution.outstanding_references += 1;\n \n                         // the source of this name is different now\n-                        resolution.type_id = id;\n-                        resolution.value_id = id;\n-                        resolution.is_public = is_public;\n+                        let ns_resolution =\n+                            NsImportResolution { id: id, is_public: is_public, target: None };\n+                        resolution[TypeNS] = ns_resolution.clone();\n+                        resolution[ValueNS] = ns_resolution;\n                         return;\n                     }\n                     None => {}"}, {"sha": "3cb0edf88c73023702917fbcaf3bfb57c17b4e20", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -328,7 +328,7 @@ fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                              .import_resolutions\n                                              .borrow()\n                                              .get(&name) {\n-                let item = resolver.ast_map.expect_item(directive.value_id);\n+                let item = resolver.ast_map.expect_item(directive.value_ns.id);\n                 resolver.session.span_note(item.span, \"constant imported here\");\n             }\n         }\n@@ -1491,7 +1491,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n         if let Some(import_resolution) = module_.import_resolutions.borrow().get(&name) {\n-            match (*import_resolution).target_for_namespace(namespace) {\n+            match import_resolution[namespace].target.clone() {\n                 None => {\n                     // Not found; continue.\n                     debug!(\"(resolving item in lexical scope) found import resolution, but not \\\n@@ -1501,7 +1501,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Some(target) => {\n                     debug!(\"(resolving item in lexical scope) using import resolution\");\n                     // track used imports and extern crates as well\n-                    let id = import_resolution.id(namespace);\n+                    let id = import_resolution[namespace].id;\n                     self.used_imports.insert((id, namespace));\n                     self.record_import_use(id, name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n@@ -1712,21 +1712,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Check the list of resolved imports.\n         match module_.import_resolutions.borrow().get(&name) {\n-            Some(import_resolution) if allow_private_imports || import_resolution.is_public => {\n+            Some(import_resolution) if allow_private_imports ||\n+                                       import_resolution[namespace].is_public => {\n \n-                if import_resolution.is_public && import_resolution.outstanding_references != 0 {\n+                if import_resolution[namespace].is_public &&\n+                   import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                match import_resolution.target_for_namespace(namespace) {\n+                match import_resolution[namespace].target.clone() {\n                     None => {\n                         debug!(\"(resolving name in module) name found, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n                         debug!(\"(resolving name in module) resolved to import\");\n                         // track used imports and extern crates as well\n-                        let id = import_resolution.id(namespace);\n+                        let id = import_resolution[namespace].id;\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n                         if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n@@ -3651,17 +3653,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // Look for imports.\n             for (_, import) in search_module.import_resolutions.borrow().iter() {\n-                let target = match import.target_for_namespace(TypeNS) {\n+                let target = match import.type_ns.target {\n                     None => continue,\n-                    Some(target) => target,\n+                    Some(ref target) => target,\n                 };\n                 let did = match target.binding.def() {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    let id = import.type_id;\n+                    let id = import.type_ns.id;\n                     self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n                     self.record_import_use(id, trait_name);\n@@ -3734,7 +3736,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let import_resolutions = module_.import_resolutions.borrow();\n         for (&name, import_resolution) in import_resolutions.iter() {\n             let value_repr;\n-            match import_resolution.target_for_namespace(ValueNS) {\n+            match import_resolution.value_ns.target {\n                 None => {\n                     value_repr = \"\".to_string();\n                 }\n@@ -3745,7 +3747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             let type_repr;\n-            match import_resolution.target_for_namespace(TypeNS) {\n+            match import_resolution.type_ns.target {\n                 None => {\n                     type_repr = \"\".to_string();\n                 }"}, {"sha": "59cf83e91d2da68bc13f4997fa58af3b160abeb2", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -130,13 +130,14 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n \n     fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: &Module) {\n         for (name, import_resolution) in module_.import_resolutions.borrow().iter() {\n-            if !import_resolution.is_public {\n-                continue;\n-            }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n-                match import_resolution.target_for_namespace(ns) {\n-                    Some(target) => {\n+                if !import_resolution[ns].is_public {\n+                    continue;\n+                }\n+\n+                match import_resolution[ns].target {\n+                    Some(ref target) => {\n                         debug!(\"(computing exports) maybe export '{}'\", name);\n                         self.add_export_of_namebinding(exports, *name, &target.binding)\n                     }"}, {"sha": "18dfaa096df1a5ecf3122dfa9fe5171695e09d11", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 82, "deletions": 126, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -102,80 +102,61 @@ impl Target {\n     }\n }\n \n-/// An ImportResolution represents a particular `use` directive.\n #[derive(Debug)]\n+/// An ImportResolution records what we know about an imported name.\n+/// More specifically, it records the number of unresolved `use` directives that import the name,\n+/// and for each namespace, it records the `use` directive importing the name in the namespace\n+/// and the `Target` to which the name in the namespace resolves (if applicable).\n+/// Different `use` directives may import the same name in different namespaces.\n pub struct ImportResolution {\n-    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n-    /// should *not* be used whenever resolution is being performed. Privacy\n-    /// testing occurs during a later phase of compilation.\n+    // When outstanding_references reaches zero, outside modules can count on the targets being\n+    // correct. Before then, all bets are off; future `use` directives could override the name.\n+    // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n+    // is if the name is imported by exactly two `use` directives, one of which resolves to a\n+    // value and the other of which resolves to a type.\n+    pub outstanding_references: usize,\n+    pub type_ns: NsImportResolution,\n+    pub value_ns: NsImportResolution,\n+}\n+\n+/// Records what we know about an imported name in a namespace (see `ImportResolution`).\n+#[derive(Clone,Debug)]\n+pub struct NsImportResolution {\n+    /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n     pub is_public: bool,\n \n-    // The number of outstanding references to this name. When this reaches\n-    // zero, outside modules can count on the targets being correct. Before\n-    // then, all bets are off; future imports could override this name.\n-    // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n-    // way outstanding_references is > 1 in a legal program is if the name is\n-    // used in both namespaces.\n-    pub outstanding_references: usize,\n+    /// Resolution of the name in the namespace\n+    pub target: Option<Target>,\n \n-    /// The value that this `use` directive names, if there is one.\n-    pub value_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the value target\n-    /// being non-none\n-    pub value_id: NodeId,\n-\n-    /// The type that this `use` directive names, if there is one.\n-    pub type_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the type target\n-    /// being non-none\n-    pub type_id: NodeId,\n+    /// The source node of the `use` directive\n+    pub id: NodeId,\n }\n \n-impl ImportResolution {\n-    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n-        ImportResolution {\n-            type_id: id,\n-            value_id: id,\n-            outstanding_references: 0,\n-            value_target: None,\n-            type_target: None,\n-            is_public: is_public,\n-        }\n+impl ::std::ops::Index<Namespace> for ImportResolution {\n+    type Output = NsImportResolution;\n+    fn index(&self, ns: Namespace) -> &NsImportResolution {\n+        match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n+}\n \n-    pub fn target_for_namespace(&self, namespace: Namespace) -> Option<Target> {\n-        match namespace {\n-            TypeNS => self.type_target.clone(),\n-            ValueNS => self.value_target.clone(),\n-        }\n+impl ::std::ops::IndexMut<Namespace> for ImportResolution {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut NsImportResolution {\n+        match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n     }\n+}\n \n-    pub fn id(&self, namespace: Namespace) -> NodeId {\n-        match namespace {\n-            TypeNS => self.type_id,\n-            ValueNS => self.value_id,\n+impl ImportResolution {\n+    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n+        let resolution = NsImportResolution { id: id, is_public: is_public, target: None };\n+        ImportResolution {\n+            outstanding_references: 0, type_ns: resolution.clone(), value_ns: resolution,\n         }\n     }\n \n     pub fn shadowable(&self, namespace: Namespace) -> Shadowable {\n-        let target = self.target_for_namespace(namespace);\n-        if target.is_none() {\n-            return Shadowable::Always;\n-        }\n-\n-        target.unwrap().shadowable\n-    }\n-\n-    pub fn set_target_and_id(&mut self, namespace: Namespace, target: Option<Target>, id: NodeId) {\n-        match namespace {\n-            TypeNS => {\n-                self.type_target = target;\n-                self.type_id = id;\n-            }\n-            ValueNS => {\n-                self.value_target = target;\n-                self.value_id = id;\n-            }\n+        match self[namespace].target {\n+            Some(ref target) => target.shadowable,\n+            None => Shadowable::Always,\n         }\n     }\n }\n@@ -530,11 +511,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n-                            if !import_resolution.is_public {\n+                            if !import_resolution[namespace].is_public {\n                                 return UnboundResult;\n                             }\n \n-                            match import_resolution.target_for_namespace(namespace) {\n+                            match import_resolution[namespace].target.clone() {\n                                 None => {\n                                     return UnboundResult;\n                                 }\n@@ -545,7 +526,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                 }) => {\n                                     debug!(\"(resolving single import) found import in ns {:?}\",\n                                            namespace);\n-                                    let id = import_resolution.id(namespace);\n+                                    let id = import_resolution[namespace].id;\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n                                     this.record_import_use(id, source);\n@@ -567,14 +548,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                        import_resolution,\n                                                        ValueNS,\n                                                        source);\n-                            value_used_reexport = import_resolution.is_public;\n+                            value_used_reexport = import_resolution.value_ns.is_public;\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self.resolver,\n                                                       import_resolution,\n                                                       TypeNS,\n                                                       source);\n-                            type_used_reexport = import_resolution.is_public;\n+                            type_used_reexport = import_resolution.type_ns.is_public;\n                         }\n \n                     }\n@@ -663,11 +644,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        let target = Some(Target::new(target_module.clone(),\n-                                                      name_binding.clone(),\n-                                                      directive.shadowable));\n-                        import_resolution.set_target_and_id(namespace, target, directive.id);\n-                        import_resolution.is_public = directive.is_public;\n+                        import_resolution[namespace] = NsImportResolution {\n+                            target: Some(Target::new(target_module.clone(),\n+                                                     name_binding.clone(),\n+                                                     directive.shadowable)),\n+                            id: directive.id,\n+                            is_public: directive.is_public\n+                        };\n                         *used_public = name_binding.is_public();\n                     }\n                     UnboundResult => {\n@@ -702,7 +685,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n+        let value_def_and_priv = import_resolution.value_ns.target.as_ref().map(|target| {\n             let def = target.binding.def().unwrap();\n             (def,\n              if value_used_public {\n@@ -711,7 +694,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 DependsOn(def.def_id())\n             })\n         });\n-        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n+        let type_def_and_priv = import_resolution.type_ns.target.as_ref().map(|target| {\n             let def = target.binding.def().unwrap();\n             (def,\n              if type_used_public {\n@@ -791,54 +774,26 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    *name,\n                    module_to_string(module_));\n \n-            if !target_import_resolution.is_public {\n-                debug!(\"(resolving glob import) nevermind, just kidding\");\n-                continue;\n-            }\n-\n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.get_mut(name) {\n-                Some(dest_import_resolution) => {\n-                    // Merge the two import resolutions at a finer-grained\n-                    // level.\n-\n-                    match target_import_resolution.value_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref value_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution,\n-                                                              import_directive.span,\n-                                                              *name,\n-                                                              ValueNS);\n-                            dest_import_resolution.value_target = Some(value_target.clone());\n-                        }\n-                    }\n-                    match target_import_resolution.type_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref type_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution,\n-                                                              import_directive.span,\n-                                                              *name,\n-                                                              TypeNS);\n-                            dest_import_resolution.type_target = Some(type_target.clone());\n-                        }\n+            let mut dest_import_resolution = import_resolutions.entry(*name).or_insert_with(|| {\n+                ImportResolution::new(id, is_public)\n+            });\n+\n+            for &ns in [TypeNS, ValueNS].iter() {\n+                match target_import_resolution[ns].target {\n+                    Some(ref target) if target_import_resolution[ns].is_public => {\n+                        self.check_for_conflicting_import(&dest_import_resolution,\n+                                                          import_directive.span,\n+                                                          *name,\n+                                                          ns);\n+                        dest_import_resolution[ns] = NsImportResolution {\n+                            id: id, is_public: is_public, target: Some(target.clone())\n+                        };\n                     }\n-                    dest_import_resolution.is_public = is_public;\n-                    continue;\n+                    _ => {}\n                 }\n-                None => {}\n             }\n-\n-            // Simple: just copy the old import resolution.\n-            let mut new_import_resolution = ImportResolution::new(id, is_public);\n-            new_import_resolution.value_target = target_import_resolution.value_target.clone();\n-            new_import_resolution.type_target = target_import_resolution.type_target.clone();\n-\n-            import_resolutions.insert(*name, new_import_resolution);\n         }\n \n         // Add all children from the containing module.\n@@ -909,19 +864,20 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   \"{}\",\n                                   msg);\n                     } else {\n-                        let target = Target::new(containing_module.clone(),\n-                                                 name_bindings[namespace].clone(),\n-                                                 import_directive.shadowable);\n-                        dest_import_resolution.set_target_and_id(namespace, Some(target), id);\n+                        dest_import_resolution[namespace] = NsImportResolution {\n+                            target: Some(Target::new(containing_module.clone(),\n+                                                     name_bindings[namespace].clone(),\n+                                                     import_directive.shadowable)),\n+                            id: id,\n+                            is_public: is_public\n+                        };\n                     }\n                 }\n             };\n             merge_child_item(ValueNS);\n             merge_child_item(TypeNS);\n         }\n \n-        dest_import_resolution.is_public = is_public;\n-\n         self.check_for_conflicts_between_imports_and_items(module_,\n                                                            dest_import_resolution,\n                                                            import_directive.span,\n@@ -934,12 +890,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        let target = import_resolution.target_for_namespace(namespace);\n+        let target = &import_resolution[namespace].target;\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                name,\n                target.is_some());\n \n-        match target {\n+        match *target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n@@ -957,7 +913,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                           \"a {} named `{}` has already been imported in this module\",\n                           ns_word,\n                           name);\n-                let use_id = import_resolution.id(namespace);\n+                let use_id = import_resolution[namespace].id;\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n                 span_note!(self.resolver.session,\n@@ -990,7 +946,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         if module.external_module_children\n                  .borrow()\n                  .contains_key(&name) {\n-            match import_resolution.type_target {\n+            match import_resolution.type_ns.target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let msg = format!(\"import `{0}` conflicts with imported crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n@@ -1011,7 +967,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref name_bindings) => (*name_bindings).clone(),\n         };\n \n-        match import_resolution.value_target {\n+        match import_resolution.value_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_ns.borrow() {\n                     span_err!(self.resolver.session,\n@@ -1027,7 +983,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(_) | None => {}\n         }\n \n-        match import_resolution.type_target {\n+        match import_resolution.type_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n                     let (what, note) = match ty.module() {"}, {"sha": "1bf7f3933849de76ba2307357ba574ebc776b90c", "filename": "src/test/compile-fail/shadowed-use-visibility.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub fn f() {}\n+\n+    use foo as bar;\n+    pub use self::f as bar;\n+}\n+\n+mod bar {\n+    use foo::bar::f as g; //~ ERROR unresolved import\n+\n+    use foo as f;\n+    pub use foo::*;\n+}\n+\n+use bar::f::f; //~ ERROR unresolved import\n+fn main() {}"}, {"sha": "d2a32da4feaa29ffcc286a93ae96ff2118b026c6", "filename": "src/test/run-pass/shadowed-use-visibility.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c4f9e7b1b64265ae271bf3bbe2bd27093e1380/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs?ref=27c4f9e7b1b64265ae271bf3bbe2bd27093e1380", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub fn f() {}\n+\n+    pub use self::f as bar;\n+    use foo as bar;\n+}\n+\n+fn main() {\n+    foo::bar();\n+}"}]}