{"sha": "f2834a403abe78f56d750a302807eab5206bb2c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODM0YTQwM2FiZTc4ZjU2ZDc1MGEzMDI4MDdlYWI1MjA2YmIyYzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-08T23:17:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-11T11:24:21Z"}, "message": "Keep the original token in `ast::Lit`", "tree": {"sha": "40282168119247e0e033d1d5dca4caa47e47feb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40282168119247e0e033d1d5dca4caa47e47feb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2834a403abe78f56d750a302807eab5206bb2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2834a403abe78f56d750a302807eab5206bb2c5", "html_url": "https://github.com/rust-lang/rust/commit/f2834a403abe78f56d750a302807eab5206bb2c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2834a403abe78f56d750a302807eab5206bb2c5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b125b83d9db4094a08b512a956c187bd29a51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b125b83d9db4094a08b512a956c187bd29a51f", "html_url": "https://github.com/rust-lang/rust/commit/28b125b83d9db4094a08b512a956c187bd29a51f"}], "stats": {"total": 145, "additions": 86, "deletions": 59}, "files": [{"sha": "a59322bbe4da9c2ef7f777fff86ca5f522024f28", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -1353,7 +1353,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 72);\n+static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 80);\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {"}, {"sha": "7ff546b7467da548652e9dbecc94950c57af2ca6", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -164,6 +164,8 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n \n impl_stable_hash_for!(struct ::syntax::ast::Lit {\n     node,\n+    token,\n+    suffix,\n     span\n });\n \n@@ -284,6 +286,19 @@ for tokenstream::TokenStream {\n     }\n }\n \n+impl_stable_hash_for!(enum token::Lit {\n+    Bool(val),\n+    Byte(val),\n+    Char(val),\n+    Err(val),\n+    Integer(val),\n+    Float(val),\n+    Str_(val),\n+    ByteStr(val),\n+    StrRaw(val, n),\n+    ByteStrRaw(val, n)\n+});\n+\n fn hash_token<'a, 'gcx, W: StableHasherResult>(\n     token: &token::Token,\n     hcx: &mut StableHashingContext<'a>,\n@@ -331,22 +346,8 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n         token::Token::CloseDelim(delim_token) => {\n             std_hash::Hash::hash(&delim_token, hasher);\n         }\n-        token::Token::Literal(ref lit, ref opt_name) => {\n-            mem::discriminant(lit).hash_stable(hcx, hasher);\n-            match *lit {\n-                token::Lit::Byte(val) |\n-                token::Lit::Char(val) |\n-                token::Lit::Err(val) |\n-                token::Lit::Integer(val) |\n-                token::Lit::Float(val) |\n-                token::Lit::Str_(val) |\n-                token::Lit::ByteStr(val) => val.hash_stable(hcx, hasher),\n-                token::Lit::StrRaw(val, n) |\n-                token::Lit::ByteStrRaw(val, n) => {\n-                    val.hash_stable(hcx, hasher);\n-                    n.hash_stable(hcx, hasher);\n-                }\n-            };\n+        token::Token::Literal(lit, opt_name) => {\n+            lit.hash_stable(hcx, hasher);\n             opt_name.hash_stable(hcx, hasher);\n         }\n "}, {"sha": "5bb06516ac49e81ebaf917d4ea9b9dcb8fd6a407", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -318,6 +318,8 @@ impl<'a> Classifier<'a> {\n \n                     // Number literals.\n                     token::Integer(..) | token::Float(..) => Class::Number,\n+\n+                    token::Bool(..) => panic!(\"literal token contains `Lit::Bool`\"),\n                 }\n             }\n "}, {"sha": "04bc146e145ec663c1049c15c122620e898c089b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -6,6 +6,7 @@ pub use crate::symbol::{Ident, Symbol as Name};\n pub use crate::util::parser::ExprPrecedence;\n \n use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n@@ -1354,6 +1355,8 @@ pub enum StrStyle {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n pub struct Lit {\n     pub node: LitKind,\n+    pub token: token::Lit,\n+    pub suffix: Option<Symbol>,\n     pub span: Span,\n }\n "}, {"sha": "2b874581083365da5fb338e0fb5ad459fdcda08d", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -350,7 +350,9 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n-    let value = Lit { node: LitKind::Str(value.node, ast::StrStyle::Cooked), span: value.span };\n+    let node = LitKind::Str(value.node, ast::StrStyle::Cooked);\n+    let (token, suffix) = node.lit_token();\n+    let value = Lit { node, token, suffix, span: value.span };\n     mk_name_value_item(ident.span.to(value.span), ident, value)\n }\n \n@@ -417,7 +419,9 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n \n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = Lit { node: LitKind::Str(text, ast::StrStyle::Cooked), span };\n+    let node = LitKind::Str(text, ast::StrStyle::Cooked);\n+    let (token, suffix) = node.lit_token();\n+    let lit = Lit { node, token, suffix, span };\n     Attribute {\n         id,\n         style,\n@@ -562,7 +566,7 @@ impl MetaItemKind {\n                 tokens.next();\n                 return if let Some(TokenTree::Token(span, token)) = tokens.next() {\n                     LitKind::from_token(token)\n-                        .map(|node| MetaItemKind::NameValue(Lit { node, span }))\n+                        .map(|(node, token, suffix)| MetaItemKind::NameValue(Lit { node, token, suffix, span }))\n                 } else {\n                     None\n                 };\n@@ -607,9 +611,9 @@ impl NestedMetaItem {\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n-            if let Some(node) = LitKind::from_token(token) {\n+            if let Some((node, token, suffix)) = LitKind::from_token(token) {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(Lit { node, span }));\n+                return Some(NestedMetaItem::Literal(Lit { node, token, suffix, span }));\n             }\n         }\n \n@@ -625,67 +629,75 @@ impl Lit {\n \n impl LitKind {\n     fn token(&self) -> Token {\n+        match self.lit_token() {\n+            (token::Bool(symbol), _) => Token::Ident(Ident::with_empty_ctxt(symbol), false),\n+            (lit, suffix) => Token::Literal(lit, suffix),\n+        }\n+    }\n+\n+    pub(crate) fn lit_token(&self) -> (token::Lit, Option<Symbol>) {\n         use std::ascii;\n \n         match *self {\n             LitKind::Str(string, ast::StrStyle::Cooked) => {\n                 let escaped = string.as_str().escape_default().to_string();\n-                Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n+                (token::Lit::Str_(Symbol::intern(&escaped)), None)\n             }\n             LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n-                Token::Literal(token::Lit::StrRaw(string, n), None)\n+                (token::Lit::StrRaw(string, n), None)\n             }\n             LitKind::ByteStr(ref bytes) => {\n                 let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n                     .map(Into::<char>::into).collect::<String>();\n-                Token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None)\n+                (token::Lit::ByteStr(Symbol::intern(&string)), None)\n             }\n             LitKind::Byte(byte) => {\n                 let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Byte(Symbol::intern(&string)), None)\n+                (token::Lit::Byte(Symbol::intern(&string)), None)\n             }\n             LitKind::Char(ch) => {\n                 let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                Token::Literal(token::Lit::Char(Symbol::intern(&string)), None)\n+                (token::Lit::Char(Symbol::intern(&string)), None)\n             }\n             LitKind::Int(n, ty) => {\n                 let suffix = match ty {\n                     ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n                     ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n                     ast::LitIntType::Unsuffixed => None,\n                 };\n-                Token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n+                (token::Lit::Integer(Symbol::intern(&n.to_string())), suffix)\n             }\n             LitKind::Float(symbol, ty) => {\n-                Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n+                (token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n             }\n-            LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n-            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(if value {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            })), false),\n-            LitKind::Err(val) => Token::Literal(token::Lit::Err(val), None),\n+            LitKind::FloatUnsuffixed(symbol) => (token::Lit::Float(symbol), None),\n+            LitKind::Bool(value) => {\n+                let kw = if value { keywords::True } else { keywords::False };\n+                (token::Lit::Bool(kw.name()), None)\n+            }\n+            LitKind::Err(val) => (token::Lit::Err(val), None),\n         }\n     }\n \n-    fn from_token(token: Token) -> Option<LitKind> {\n+    fn from_token(token: Token) -> Option<(LitKind, token::Lit, Option<Symbol>)> {\n         match token {\n-            Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n-            Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n+            Token::Ident(ident, false) if ident.name == keywords::True.name() =>\n+                Some((LitKind::Bool(true), token::Bool(ident.name), None)),\n+            Token::Ident(ident, false) if ident.name == keywords::False.name() =>\n+                Some((LitKind::Bool(false), token::Bool(ident.name), None)),\n             Token::Interpolated(nt) => match *nt {\n                 token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n-                    ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n+                    ExprKind::Lit(ref lit) => Some((lit.node.clone(), lit.token, lit.suffix)),\n                     _ => None,\n                 },\n                 _ => None,\n             },\n             Token::Literal(lit, suf) => {\n                 let (suffix_illegal, result) = parse::lit_token(lit, suf, None);\n-                if suffix_illegal && suf.is_some() {\n+                if result.is_none() || suffix_illegal && suf.is_some() {\n                     return None;\n                 }\n-                result\n+                Some((result.unwrap(), lit, suf))\n             }\n             _ => None,\n         }"}, {"sha": "0f9977e85038bd3fd93e4b4001263ed39deb23b1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -698,7 +698,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_lit(&self, span: Span, node: ast::LitKind) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Lit(ast::Lit { node, span }))\n+        let (token, suffix) = node.lit_token();\n+        self.expr(span, ast::ExprKind::Lit(ast::Lit { node, token, suffix, span }))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n@@ -1166,8 +1167,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn meta_name_value(&self, span: Span, name: ast::Name, node: ast::LitKind)\n                        -> ast::MetaItem {\n+        let (token, suffix) = node.lit_token();\n         attr::mk_name_value_item(span, Ident::with_empty_ctxt(name).with_span_pos(span),\n-                                 ast::Lit { node, span })\n+                                 ast::Lit { node, token, suffix, span })\n     }\n \n     fn item_use(&self, sp: Span,"}, {"sha": "4d4e99009a9d2554b81571d20a622379cbddf1d5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -376,6 +376,7 @@ crate fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Ha\n     use ast::LitKind;\n \n     match lit {\n+        token::Bool(_) => panic!(\"literal token contains `Lit::Bool`\"),\n         token::Byte(i) => {\n             let lit_kind = match unescape_byte(&i.as_str()) {\n                 Ok(c) => LitKind::Byte(c),"}, {"sha": "b988cb1447df7a49dddbea8c16e70a78b9a8270b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -2070,11 +2070,11 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `token_lit = LIT_INTEGER | ...`.\n-    fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n+    fn parse_lit_token(&mut self) -> PResult<'a, (LitKind, token::Lit, Option<Symbol>)> {\n         let out = match self.token {\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n-                    ExprKind::Lit(ref lit) => { lit.node.clone() }\n+                    ExprKind::Lit(ref lit) => { (lit.node.clone(), lit.token, lit.suffix) }\n                     _ => { return self.unexpected_last(&self.token); }\n                 },\n                 _ => { return self.unexpected_last(&self.token); }\n@@ -2088,19 +2088,19 @@ impl<'a> Parser<'a> {\n                     self.expect_no_suffix(sp, &format!(\"a {}\", lit.literal_name()), suf)\n                 }\n \n-                result.unwrap()\n+                (result.unwrap(), lit, suf)\n             }\n             token::Dot if self.look_ahead(1, |t| match t {\n-                token::Literal(parse::token::Lit::Integer(_) , _) => true,\n+                token::Literal(token::Lit::Integer(_) , _) => true,\n                 _ => false,\n             }) => { // recover from `let x = .4;`\n                 let lo = self.span;\n                 self.bump();\n                 if let token::Literal(\n-                    parse::token::Lit::Integer(val),\n+                    token::Lit::Integer(val),\n                     suffix,\n                 ) = self.token {\n-                    let suffix = suffix.and_then(|s| {\n+                    let float_suffix = suffix.and_then(|s| {\n                         let s = s.as_str();\n                         if s == \"f32\" {\n                             Some(\"f32\")\n@@ -2117,14 +2117,14 @@ impl<'a> Parser<'a> {\n                     err.span_suggestion(\n                         sp,\n                         \"must have an integer part\",\n-                        format!(\"0.{}{}\", val, suffix),\n+                        format!(\"0.{}{}\", val, float_suffix),\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n-                    return Ok(match suffix {\n-                        \"f32\" => ast::LitKind::Float(val, ast::FloatTy::F32),\n-                        \"f64\" => ast::LitKind::Float(val, ast::FloatTy::F64),\n-                        _ => ast::LitKind::FloatUnsuffixed(val),\n+                    return Ok(match float_suffix {\n+                        \"f32\" => (ast::LitKind::Float(val, ast::FloatTy::F32), token::Float(val), suffix),\n+                        \"f64\" => (ast::LitKind::Float(val, ast::FloatTy::F64), token::Float(val), suffix),\n+                        _ => (ast::LitKind::FloatUnsuffixed(val), token::Float(val), suffix),\n                     });\n                 } else {\n                     unreachable!();\n@@ -2140,14 +2140,14 @@ impl<'a> Parser<'a> {\n     /// Matches `lit = true | false | token_lit`.\n     crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         let lo = self.span;\n-        let node = if self.eat_keyword(keywords::True) {\n-            LitKind::Bool(true)\n+        let (node, token, suffix) = if self.eat_keyword(keywords::True) {\n+            (LitKind::Bool(true), token::Bool(keywords::True.name()), None)\n         } else if self.eat_keyword(keywords::False) {\n-            LitKind::Bool(false)\n+            (LitKind::Bool(false), token::Bool(keywords::False.name()), None)\n         } else {\n             self.parse_lit_token()?\n         };\n-        Ok(Lit { node, span: lo.to(self.prev_span) })\n+        Ok(Lit { node, token, suffix, span: lo.to(self.prev_span) })\n     }\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`)."}, {"sha": "48a949257ffb323d7166ad1c4fce44e427ead463", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -61,6 +61,7 @@ impl DelimToken {\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Lit {\n+    Bool(ast::Name), // AST only, must never appear in a `Token`\n     Byte(ast::Name),\n     Char(ast::Name),\n     Err(ast::Name),\n@@ -72,9 +73,13 @@ pub enum Lit {\n     ByteStrRaw(ast::Name, u16), /* raw byte str delimited by n hash symbols */\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_LIT: mem::size_of::<Lit>() == 8);\n+\n impl Lit {\n     crate fn literal_name(&self) -> &'static str {\n         match *self {\n+            Bool(_) => panic!(\"literal token contains `Lit::Bool`\"),\n             Byte(_) => \"byte literal\",\n             Char(_) => \"char literal\",\n             Err(_) => \"invalid literal\","}, {"sha": "0e93b857708f75b27e5ef5033e99700f6fb82836", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2834a403abe78f56d750a302807eab5206bb2c5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f2834a403abe78f56d750a302807eab5206bb2c5", "patch": "@@ -225,6 +225,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         /* Literals */\n         token::Literal(lit, suf) => {\n             let mut out = match lit {\n+                token::Bool(_)          => panic!(\"literal token contains `Lit::Bool`\"),\n                 token::Byte(b)           => format!(\"b'{}'\", b),\n                 token::Char(c)           => format!(\"'{}'\", c),\n                 token::Err(c)            => format!(\"'{}'\", c),"}]}