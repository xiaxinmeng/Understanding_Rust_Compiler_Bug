{"sha": "3e08171fc21f7fcc403aa315d8fb54f04c552841", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMDgxNzFmYzIxZjdmY2M0MDNhYTMxNWQ4ZmI1NGYwNGM1NTI4NDE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-29T23:29:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-29T23:29:55Z"}, "message": "Change mutability into a type constructor.", "tree": {"sha": "b4ff7c529374fe4680c70b9d26d95a3b0499afbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4ff7c529374fe4680c70b9d26d95a3b0499afbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e08171fc21f7fcc403aa315d8fb54f04c552841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e08171fc21f7fcc403aa315d8fb54f04c552841", "html_url": "https://github.com/rust-lang/rust/commit/3e08171fc21f7fcc403aa315d8fb54f04c552841", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e08171fc21f7fcc403aa315d8fb54f04c552841/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "386f363cfea72899fa3c3f2a194d00819cdbe806", "url": "https://api.github.com/repos/rust-lang/rust/commits/386f363cfea72899fa3c3f2a194d00819cdbe806", "html_url": "https://github.com/rust-lang/rust/commit/386f363cfea72899fa3c3f2a194d00819cdbe806"}], "stats": {"total": 126, "additions": 51, "deletions": 75}, "files": [{"sha": "87e8e4c15822f62ff0443667b7292d10e2b89813", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -910,6 +910,13 @@ let check_block (cx:Semant.ctxt) : (fn_ctx -> Ast.block -> unit) =\n       Array.iter check_stmt' block.Common.node\n \n     and check_stmt (stmt:Ast.stmt) : unit =\n+      try\n+        check_stmt_full stmt\n+      with\n+          Common.Semant_err (None, msg) ->\n+            raise (Common.Semant_err ((Some stmt.Common.id), msg))\n+\n+    and check_stmt_full (stmt:Ast.stmt) : unit =\n       check_ret stmt;\n       match stmt.Common.node with\n           Ast.STMT_spawn (dst, _, _, callee, args) ->"}, {"sha": "3b1a31b85168edc38122afa93f942decd26f261b", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -152,7 +152,7 @@ tag ty_ {\n     ty_str;\n     ty_box(@ty);\n     ty_vec(@ty);\n-    ty_tup(vec[tup(mutability, @ty)]);\n+    ty_tup(vec[@ty]);\n     ty_fn(vec[rec(mode mode, @ty ty)], @ty);        // TODO: effect\n     ty_path(path, option.t[def]);\n     ty_mutable(@ty);"}, {"sha": "6b0c2cc8c95afe4bcc06d8f441738e00a73f9d61", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -96,19 +96,6 @@ impure fn parse_ident(parser p) -> ast.ident {\n     }\n }\n \n-impure fn parse_possibly_mutable_ty(parser p)\n-    -> tup(ast.mutability, @ast.ty) {\n-    auto mut;\n-    if (p.peek() == token.MUTABLE) {\n-        p.bump();\n-        mut = ast.mut;\n-    } else {\n-        mut = ast.imm;\n-    }\n-\n-    ret tup(mut, parse_ty(p));\n-}\n-\n impure fn parse_ty_fn(parser p) -> ast.ty_ {\n     impure fn parse_fn_input_ty(parser p) -> rec(ast.mode mode, @ast.ty ty) {\n         auto mode;\n@@ -192,11 +179,10 @@ impure fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.TUP) {\n             p.bump();\n-            auto f = parse_possibly_mutable_ty; // FIXME: trans_const_lval bug\n-            auto elems =\n-                parse_seq[tup(ast.mutability, @ast.ty)]\n-                (token.LPAREN,\n-                 token.RPAREN, some(token.COMMA), f, p);\n+            auto f = parse_ty; // FIXME: trans_const_lval bug\n+            auto elems = parse_seq[@ast.ty] (token.LPAREN,\n+                                             token.RPAREN,\n+                                             some(token.COMMA), f, p);\n             hi = p.get_span();\n             t = ast.ty_tup(elems.node);\n         }"}, {"sha": "f2fb11cbde88099f2bce763a9b98a80cdf66e2b8", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -46,8 +46,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_box,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_vec,\n \n-     (fn(&ENV e, &span sp,\n-         vec[tup(mutability, @ty)] elts) -> @ty)  fold_ty_tup,\n+     (fn(&ENV e, &span sp, vec[@ty] elts) -> @ty) fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n          vec[rec(ast.mode mode, @ty ty)] inputs,\n@@ -246,9 +245,9 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         }\n \n         case (ast.ty_tup(?elts)) {\n-            let vec[tup(mutability, @ty)] elts_ = vec();\n-            for (tup(mutability, @ty) elt in elts) {\n-                elts_ += tup(elt._0, fold_ty(env, fld, elt._1));\n+            let vec[@ty] elts_ = vec();\n+            for (@ty elt in elts) {\n+                append[@ty](elts_,fold_ty(env, fld, elt));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts);\n         }\n@@ -652,7 +651,7 @@ fn identity_fold_ty_vec[ENV](&ENV env, &span sp, @ty t) -> @ty {\n }\n \n fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n-                             vec[tup(mutability,@ty)] elts) -> @ty {\n+                             vec[@ty] elts) -> @ty {\n     ret @respan(sp, ast.ty_tup(elts));\n }\n "}, {"sha": "9aa367d5ae60eee04fd6760600587d967ecd23bd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -275,8 +275,8 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n         }\n         case (typeck.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (tup(ast.mutability, @typeck.ty) elt in elts) {\n-                tys += type_of(cx, elt._1);\n+            for (@typeck.ty elt in elts) {\n+                tys += type_of(cx, elt);\n             }\n             ret T_struct(tys);\n         }\n@@ -493,9 +493,9 @@ fn iter_structural_ty(@block_ctxt cx,\n     alt (t.struct) {\n         case (typeck.ty_tup(?args)) {\n             let int i = 0;\n-            for (tup(ast.mutability, @typeck.ty) arg in args) {\n+            for (@typeck.ty arg in args) {\n                 auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n-                r = f(r.bcx, elt, arg._1);\n+                r = f(r.bcx, elt, arg);\n                 i += 1;\n             }\n         }"}, {"sha": "0aabcac3833fb001f5ae17345ddc5ff30e21f0ea", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e08171fc21f7fcc403aa315d8fb54f04c552841/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3e08171fc21f7fcc403aa315d8fb54f04c552841", "patch": "@@ -40,7 +40,7 @@ tag sty {\n     ty_str;\n     ty_box(@ty);\n     ty_vec(@ty);\n-    ty_tup(vec[tup(mutability, @ty)]);\n+    ty_tup(vec[@ty]);\n     ty_fn(vec[arg], @ty);                           // TODO: effect\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n@@ -66,16 +66,6 @@ type ty_getter = fn(ast.def_id) -> @ty;\n // Error-reporting utility functions\n \n fn ast_ty_to_str(&@ast.ty ty) -> str {\n-    fn ast_tup_elem_to_str(&tup(mutability, @ast.ty) elem) -> str {\n-        auto s;\n-        if (elem._0 == ast.mut) {\n-            s = \"mutable \";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ast_ty_to_str(elem._1);\n-    }\n \n     fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n         auto s;\n@@ -101,11 +91,9 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n         case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n \n         case (ast.ty_tup(?elems)) {\n-            auto f = ast_tup_elem_to_str;\n+            auto f = ast_ty_to_str;\n             s = \"tup(\";\n-            s +=\n-                _str.connect(_vec.map[tup(mutability,@ast.ty),str](f, elems),\n-                             \",\");\n+            s += _str.connect(_vec.map[@ast.ty,str](f, elems), \",\");\n             s += \")\";\n         }\n \n@@ -153,17 +141,7 @@ fn path_to_str(&ast.path path) -> str {\n     ret _str.connect(_vec.map[ast.name,str](f, path), \".\");\n }\n \n-fn ty_to_str(@ty typ) -> str {\n-    fn tup_elem_to_str(&tup(mutability, @ty) elem) -> str {\n-        auto s;\n-        if (elem._0 == ast.mut) {\n-            s = \"mutable \";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ty_to_str(elem._1);\n-    }\n+fn ty_to_str(&@ty typ) -> str {\n \n     fn fn_input_to_str(&rec(ast.mode mode, @ty ty) input) -> str {\n         auto s;\n@@ -176,7 +154,11 @@ fn ty_to_str(@ty typ) -> str {\n         ret s + ty_to_str(input.ty);\n     }\n \n-    auto s;\n+    auto s = \"\";\n+    if (typ.mut == ast.mut) {\n+        s += \"mutable \";\n+    }\n+\n     alt (typ.struct) {\n         case (ty_nil)          { s = \"()\";                        }\n         case (ty_bool)         { s = \"bool\";                      }\n@@ -189,8 +171,8 @@ fn ty_to_str(@ty typ) -> str {\n         case (ty_vec(?t))      { s = \"vec[\" + ty_to_str(t) + \"]\"; }\n \n         case (ty_tup(?elems)) {\n-            auto f = tup_elem_to_str;\n-            auto strs = _vec.map[tup(mutability,@ty),str](f, elems);\n+            auto f = ty_to_str;\n+            auto strs = _vec.map[@ty,str](f, elems);\n             s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n@@ -234,9 +216,9 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         case (ast.ty_box(?t))      { sty = ty_box(ast_ty_to_ty(getter, t)); }\n         case (ast.ty_vec(?t))      { sty = ty_vec(ast_ty_to_ty(getter, t)); }\n         case (ast.ty_tup(?fields)) {\n-            let vec[tup(mutability,@ty)] flds = vec();\n-            for (tup(mutability, @ast.ty) field in fields) {\n-                flds += tup(field._0, ast_ty_to_ty(getter, field._1));\n+            let vec[@ty] flds = vec();\n+            for (@ast.ty field in fields) {\n+                append[@ty](flds, ast_ty_to_ty(getter, field));\n             }\n             sty = ty_tup(flds);\n         }\n@@ -710,10 +692,8 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n             case (ty_tup(?expected_elems)) {\n                 alt (actual.struct) {\n                     case (ty_tup(?actual_elems)) {\n-                        auto expected_len =\n-                            _vec.len[tup(mutability,@ty)](expected_elems);\n-                        auto actual_len =\n-                            _vec.len[tup(mutability,@ty)](actual_elems);\n+                        auto expected_len = _vec.len[@ty](expected_elems);\n+                        auto actual_len = _vec.len[@ty](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -722,24 +702,23 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[tup(mutability, @ty)] result_elems = vec();\n+                        let vec[@ty] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n                             auto actual_elem = actual_elems.(i);\n-                            if (expected_elem._0 != actual_elem._0) {\n+                            if (expected_elem.mut != actual_elem.mut) {\n                                 auto err = terr_tuple_mutability;\n                                 ret ures_err(err, expected, actual);\n                             }\n \n                             auto result = unify_step(fcx,\n                                                      bindings,\n-                                                     expected_elem._1,\n-                                                     actual_elem._1);\n+                                                     expected_elem,\n+                                                     actual_elem);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    result_elems += vec(tup(expected_elem._0,\n-                                                            rty));\n+                                    append[@ty](result_elems,rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1258,12 +1237,17 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_tup(?args, _)) {\n             let vec[tup(mutability, @ast.expr)] args_1 = vec();\n-            let vec[tup(mutability, @ty)] args_t = vec();\n+            let vec[@ty] args_t = vec();\n \n             for (tup(mutability, @ast.expr) arg in args) {\n                 auto expr_1 = check_expr(fcx, arg._1);\n                 args_1 += tup(arg._0, expr_1);\n-                args_t += tup(arg._0, expr_ty(expr_1));\n+                if (arg._0 == ast.mut) {\n+                    append[@ty](args_t,@rec(mut=ast.mut\n+                                            with *expr_ty(expr_1)));\n+                } else {\n+                    append[@ty](args_t,expr_ty(expr_1));\n+                }\n             }\n \n             auto ann = ast.ann_type(plain_ty(ty_tup(args_t)));\n@@ -1278,11 +1262,11 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty_tup(?args)) {\n                     let uint ix = field_num(fcx.ccx.sess,\n                                             expr.span, field);\n-                    if (ix >= _vec.len[tup(mutability,@ty)](args)) {\n+                    if (ix >= _vec.len[@ty](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix)._1);\n+                    auto ann = ast.ann_type(args.(ix));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,"}]}