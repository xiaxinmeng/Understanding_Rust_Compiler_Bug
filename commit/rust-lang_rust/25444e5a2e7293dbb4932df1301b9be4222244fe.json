{"sha": "25444e5a2e7293dbb4932df1301b9be4222244fe", "node_id": "C_kwDOAAsO6NoAKDI1NDQ0ZTVhMmU3MjkzZGJiNDkzMmRmMTMwMWI5YmU0MjIyMjQ0ZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T06:53:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T06:53:47Z"}, "message": "Auto merge of #111414 - matthiaskrgr:rollup-q0qoc47, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #110673 (Make alias bounds sound in the new solver (take 2))\n - #110747 (Encode types in SMIR)\n - #111095 (Correctly handle associated items of a trait inside a `#[doc(hidden)]` item)\n - #111381 (Keep encoding attributes for closures)\n - #111408 (Fix incorrect implication of transmuting slices)\n - #111410 (Switch to `EarlyBinder` for `thir_abstract_const` query)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1886317956574d19a52726e0743e435e96d35b02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1886317956574d19a52726e0743e435e96d35b02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25444e5a2e7293dbb4932df1301b9be4222244fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25444e5a2e7293dbb4932df1301b9be4222244fe", "html_url": "https://github.com/rust-lang/rust/commit/25444e5a2e7293dbb4932df1301b9be4222244fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25444e5a2e7293dbb4932df1301b9be4222244fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63fc57b98eea5d6d84f1ccc4dbfcb12d58ad430b", "url": "https://api.github.com/repos/rust-lang/rust/commits/63fc57b98eea5d6d84f1ccc4dbfcb12d58ad430b", "html_url": "https://github.com/rust-lang/rust/commit/63fc57b98eea5d6d84f1ccc4dbfcb12d58ad430b"}, {"sha": "70d5bf7fae8dfacf9db1b58190d8eaae5e4e4104", "url": "https://api.github.com/repos/rust-lang/rust/commits/70d5bf7fae8dfacf9db1b58190d8eaae5e4e4104", "html_url": "https://github.com/rust-lang/rust/commit/70d5bf7fae8dfacf9db1b58190d8eaae5e4e4104"}], "stats": {"total": 836, "additions": 616, "deletions": 220}, "files": [{"sha": "9a95a9c8375e00a2483d8d8b239ace66246aa2b0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -1530,7 +1530,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         // variables\n         let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            if let Some(ct) = tcx.bound_abstract_const(unevaluated.def)? {\n+            if let Some(ct) = tcx.thir_abstract_const(unevaluated.def)? {\n                 let ct = tcx.expand_abstract_consts(ct.subst(tcx, substs));\n                 if let Err(e) = ct.error_reported() {\n                     return Err(ErrorHandled::Reported(e));"}, {"sha": "29cf432b8f9186030725272371c737d0033db6e2", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -862,6 +862,11 @@ fn should_encode_attrs(def_kind: DefKind) -> bool {\n         | DefKind::Macro(_)\n         | DefKind::Field\n         | DefKind::Impl { .. } => true,\n+        // Tools may want to be able to detect their tool lints on\n+        // closures from upstream crates, too. This is used by\n+        // https://github.com/model-checking/kani and is not a performance\n+        // or maintenance issue for us.\n+        DefKind::Closure => true,\n         DefKind::TyParam\n         | DefKind::ConstParam\n         | DefKind::Ctor(..)\n@@ -874,7 +879,6 @@ fn should_encode_attrs(def_kind: DefKind) -> bool {\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::LifetimeParam\n         | DefKind::GlobalAsm\n-        | DefKind::Closure\n         | DefKind::Generator => false,\n     }\n }"}, {"sha": "e2f6acb186b7234204f536ce424d644f17fc412e", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -394,7 +394,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n-    thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::Const<'static>>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "28a9c1eef1a6d30c1daff18fd066af628d064e21", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -82,9 +82,10 @@ impl EraseType for Result<Option<ty::Instance<'_>>, rustc_errors::ErrorGuarantee\n         [u8; size_of::<Result<Option<ty::Instance<'static>>, rustc_errors::ErrorGuaranteed>>()];\n }\n \n-impl EraseType for Result<Option<ty::Const<'_>>, rustc_errors::ErrorGuaranteed> {\n-    type Result =\n-        [u8; size_of::<Result<Option<ty::Const<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+impl EraseType for Result<Option<ty::EarlyBinder<ty::Const<'_>>>, rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<\n+        Result<Option<ty::EarlyBinder<ty::Const<'static>>>, rustc_errors::ErrorGuaranteed>,\n+    >()];\n }\n \n impl EraseType for Result<ty::GenericArg<'_>, traits::query::NoSolution> {"}, {"sha": "dd89283d704e8b33b92d2cbbbc4a1cf93448df92", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -402,7 +402,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }"}, {"sha": "972c417cbbabd907ef53a0a204a51920dad7a510", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -4,7 +4,6 @@ use crate::ty::{\n     TypeVisitableExt,\n };\n use rustc_errors::ErrorGuaranteed;\n-use rustc_hir::def_id::DefId;\n \n #[derive(Hash, Debug, Clone, Copy, Ord, PartialOrd, PartialEq, Eq)]\n #[derive(TyDecodable, TyEncodable, HashStable, TypeVisitable, TypeFoldable)]\n@@ -35,12 +34,6 @@ TrivialTypeTraversalAndLiftImpls! {\n pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed>;\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Returns a const without substs applied\n-    pub fn bound_abstract_const(self, uv: DefId) -> BoundAbstractConst<'tcx> {\n-        let ac = self.thir_abstract_const(uv);\n-        Ok(ac?.map(|ac| EarlyBinder(ac)))\n-    }\n-\n     pub fn expand_abstract_consts<T: TypeFoldable<TyCtxt<'tcx>>>(self, ac: T) -> T {\n         struct Expander<'tcx> {\n             tcx: TyCtxt<'tcx>,\n@@ -59,7 +52,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n             fn fold_const(&mut self, c: Const<'tcx>) -> Const<'tcx> {\n                 let ct = match c.kind() {\n-                    ty::ConstKind::Unevaluated(uv) => match self.tcx.bound_abstract_const(uv.def) {\n+                    ty::ConstKind::Unevaluated(uv) => match self.tcx.thir_abstract_const(uv.def) {\n                         Err(e) => self.tcx.const_error_with_guaranteed(c.ty(), e),\n                         Ok(Some(bac)) => {\n                             let substs = self.tcx.erase_regions(uv.substs);"}, {"sha": "b00f0a1c1531236a409c8bfe4eff24ab4f64a7cd", "filename": "compiler/rustc_smir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Flib.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -11,6 +11,8 @@\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![cfg_attr(not(feature = \"default\"), feature(rustc_private))]\n+#![feature(local_key_cell_methods)]\n+#![feature(ptr_metadata)]\n \n pub mod rustc_internal;\n pub mod stable_mir;"}, {"sha": "609a04d263c961eabe7092aba59bd1b66544668a", "filename": "compiler/rustc_smir/src/rustc_internal/mod.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -3,30 +3,49 @@\n //! For that, we define APIs that will temporarily be public to 3P that exposes rustc internal APIs\n //! until stable MIR is complete.\n \n-use std::sync::RwLock;\n-\n-use crate::stable_mir;\n+use crate::{\n+    rustc_smir::Tables,\n+    stable_mir::{self, with},\n+};\n+use rustc_middle::ty::TyCtxt;\n pub use rustc_span::def_id::{CrateNum, DefId};\n \n-static DEF_ID_MAP: RwLock<Vec<DefId>> = RwLock::new(Vec::new());\n+fn with_tables<R>(mut f: impl FnMut(&mut Tables<'_>) -> R) -> R {\n+    let mut ret = None;\n+    with(|tables| tables.rustc_tables(&mut |t| ret = Some(f(t))));\n+    ret.unwrap()\n+}\n \n pub fn item_def_id(item: &stable_mir::CrateItem) -> DefId {\n-    DEF_ID_MAP.read().unwrap()[item.0]\n+    with_tables(|t| t.item_def_id(item))\n }\n \n pub fn crate_item(did: DefId) -> stable_mir::CrateItem {\n-    // FIXME: this becomes inefficient when we have too many ids\n-    let mut map = DEF_ID_MAP.write().unwrap();\n-    for (i, &d) in map.iter().enumerate() {\n-        if d == did {\n-            return stable_mir::CrateItem(i);\n+    with_tables(|t| t.crate_item(did))\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn item_def_id(&self, item: &stable_mir::CrateItem) -> DefId {\n+        self.def_ids[item.0]\n+    }\n+\n+    pub fn crate_item(&mut self, did: DefId) -> stable_mir::CrateItem {\n+        // FIXME: this becomes inefficient when we have too many ids\n+        for (i, &d) in self.def_ids.iter().enumerate() {\n+            if d == did {\n+                return stable_mir::CrateItem(i);\n+            }\n         }\n+        let id = self.def_ids.len();\n+        self.def_ids.push(did);\n+        stable_mir::CrateItem(id)\n     }\n-    let id = map.len();\n-    map.push(did);\n-    stable_mir::CrateItem(id)\n }\n \n pub fn crate_num(item: &stable_mir::Crate) -> CrateNum {\n     item.id.into()\n }\n+\n+pub fn run(tcx: TyCtxt<'_>, f: impl FnOnce()) {\n+    crate::stable_mir::run(Tables { tcx, def_ids: vec![], types: vec![] }, f);\n+}"}, {"sha": "6af43f5d3f358fe73aed0a4fa5cf913c1d20b30f", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 92, "deletions": 43, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -7,41 +7,107 @@\n //!\n //! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n \n-use crate::{\n-    rustc_internal::{crate_item, item_def_id},\n-    stable_mir::{self},\n-};\n-use rustc_middle::ty::{tls::with, TyCtxt};\n-use rustc_span::def_id::{CrateNum, LOCAL_CRATE};\n+use crate::stable_mir::{self, ty::TyKind, Context};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use tracing::debug;\n \n-/// Get information about the local crate.\n-pub fn local_crate() -> stable_mir::Crate {\n-    with(|tcx| smir_crate(tcx, LOCAL_CRATE))\n-}\n+impl<'tcx> Context for Tables<'tcx> {\n+    fn local_crate(&self) -> stable_mir::Crate {\n+        smir_crate(self.tcx, LOCAL_CRATE)\n+    }\n \n-/// Retrieve a list of all external crates.\n-pub fn external_crates() -> Vec<stable_mir::Crate> {\n-    with(|tcx| tcx.crates(()).iter().map(|crate_num| smir_crate(tcx, *crate_num)).collect())\n-}\n+    fn external_crates(&self) -> Vec<stable_mir::Crate> {\n+        self.tcx.crates(()).iter().map(|crate_num| smir_crate(self.tcx, *crate_num)).collect()\n+    }\n \n-/// Find a crate with the given name.\n-pub fn find_crate(name: &str) -> Option<stable_mir::Crate> {\n-    with(|tcx| {\n-        [LOCAL_CRATE].iter().chain(tcx.crates(()).iter()).find_map(|crate_num| {\n-            let crate_name = tcx.crate_name(*crate_num).to_string();\n-            (name == crate_name).then(|| smir_crate(tcx, *crate_num))\n+    fn find_crate(&self, name: &str) -> Option<stable_mir::Crate> {\n+        [LOCAL_CRATE].iter().chain(self.tcx.crates(()).iter()).find_map(|crate_num| {\n+            let crate_name = self.tcx.crate_name(*crate_num).to_string();\n+            (name == crate_name).then(|| smir_crate(self.tcx, *crate_num))\n         })\n-    })\n+    }\n+\n+    fn all_local_items(&mut self) -> stable_mir::CrateItems {\n+        self.tcx.mir_keys(()).iter().map(|item| self.crate_item(item.to_def_id())).collect()\n+    }\n+    fn entry_fn(&mut self) -> Option<stable_mir::CrateItem> {\n+        Some(self.crate_item(self.tcx.entry_fn(())?.0))\n+    }\n+    fn mir_body(&mut self, item: &stable_mir::CrateItem) -> stable_mir::mir::Body {\n+        let def_id = self.item_def_id(item);\n+        let mir = self.tcx.optimized_mir(def_id);\n+        stable_mir::mir::Body {\n+            blocks: mir\n+                .basic_blocks\n+                .iter()\n+                .map(|block| stable_mir::mir::BasicBlock {\n+                    terminator: rustc_terminator_to_terminator(block.terminator()),\n+                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n+                })\n+                .collect(),\n+            locals: mir.local_decls.iter().map(|decl| self.intern_ty(decl.ty)).collect(),\n+        }\n+    }\n+\n+    fn rustc_tables(&mut self, f: &mut dyn FnMut(&mut Tables<'_>)) {\n+        f(self)\n+    }\n+\n+    fn ty_kind(&mut self, ty: crate::stable_mir::ty::Ty) -> TyKind {\n+        self.rustc_ty_to_ty(self.types[ty.0])\n+    }\n }\n \n-/// Retrieve all items of the local crate that have a MIR associated with them.\n-pub fn all_local_items() -> stable_mir::CrateItems {\n-    with(|tcx| tcx.mir_keys(()).iter().map(|item| crate_item(item.to_def_id())).collect())\n+pub struct Tables<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub def_ids: Vec<DefId>,\n+    pub types: Vec<Ty<'tcx>>,\n }\n \n-pub fn entry_fn() -> Option<stable_mir::CrateItem> {\n-    with(|tcx| Some(crate_item(tcx.entry_fn(())?.0)))\n+impl<'tcx> Tables<'tcx> {\n+    fn rustc_ty_to_ty(&mut self, ty: Ty<'tcx>) -> TyKind {\n+        match ty.kind() {\n+            ty::Bool => TyKind::Bool,\n+            ty::Char => todo!(),\n+            ty::Int(_) => todo!(),\n+            ty::Uint(_) => todo!(),\n+            ty::Float(_) => todo!(),\n+            ty::Adt(_, _) => todo!(),\n+            ty::Foreign(_) => todo!(),\n+            ty::Str => todo!(),\n+            ty::Array(_, _) => todo!(),\n+            ty::Slice(_) => todo!(),\n+            ty::RawPtr(_) => todo!(),\n+            ty::Ref(_, _, _) => todo!(),\n+            ty::FnDef(_, _) => todo!(),\n+            ty::FnPtr(_) => todo!(),\n+            ty::Placeholder(..) => todo!(),\n+            ty::Dynamic(_, _, _) => todo!(),\n+            ty::Closure(_, _) => todo!(),\n+            ty::Generator(_, _, _) => todo!(),\n+            ty::GeneratorWitness(_) => todo!(),\n+            ty::GeneratorWitnessMIR(_, _) => todo!(),\n+            ty::Never => todo!(),\n+            ty::Tuple(fields) => {\n+                TyKind::Tuple(fields.iter().map(|ty| self.intern_ty(ty)).collect())\n+            }\n+            ty::Alias(_, _) => todo!(),\n+            ty::Param(_) => todo!(),\n+            ty::Bound(_, _) => todo!(),\n+            ty::Infer(_) => todo!(),\n+            ty::Error(_) => todo!(),\n+        }\n+    }\n+\n+    fn intern_ty(&mut self, ty: Ty<'tcx>) -> stable_mir::ty::Ty {\n+        if let Some(id) = self.types.iter().position(|&t| t == ty) {\n+            return stable_mir::ty::Ty(id);\n+        }\n+        let id = self.types.len();\n+        self.types.push(ty);\n+        stable_mir::ty::Ty(id)\n+    }\n }\n \n /// Build a stable mir crate from a given crate number.\n@@ -52,23 +118,6 @@ fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n }\n \n-pub fn mir_body(item: &stable_mir::CrateItem) -> stable_mir::mir::Body {\n-    with(|tcx| {\n-        let def_id = item_def_id(item);\n-        let mir = tcx.optimized_mir(def_id);\n-        stable_mir::mir::Body {\n-            blocks: mir\n-                .basic_blocks\n-                .iter()\n-                .map(|block| stable_mir::mir::BasicBlock {\n-                    terminator: rustc_terminator_to_terminator(block.terminator()),\n-                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n-                })\n-                .collect(),\n-        }\n-    })\n-}\n-\n fn rustc_statement_to_statement(\n     s: &rustc_middle::mir::Statement<'_>,\n ) -> stable_mir::mir::Statement {"}, {"sha": "6328c35aa5982f563e4c4e127a20ddd35f214228", "filename": "compiler/rustc_smir/src/stable_mir/mir/body.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -1,6 +1,9 @@\n+use crate::stable_mir::ty::Ty;\n+\n #[derive(Clone, Debug)]\n pub struct Body {\n     pub blocks: Vec<BasicBlock>,\n+    pub locals: Vec<Ty>,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "612777b9c75395d279f91d9e278ff652d548e599", "filename": "compiler/rustc_smir/src/stable_mir/mod.rs", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -11,7 +11,14 @@\n //! There shouldn't be any direct references to internal compiler constructs in this module.\n //! If you need an internal construct, consider using `rustc_internal` or `rustc_smir`.\n \n+use std::cell::Cell;\n+\n+use crate::rustc_smir::Tables;\n+\n+use self::ty::{Ty, TyKind};\n+\n pub mod mir;\n+pub mod ty;\n \n /// Use String for now but we should replace it.\n pub type Symbol = String;\n@@ -41,33 +48,80 @@ pub struct CrateItem(pub(crate) DefId);\n \n impl CrateItem {\n     pub fn body(&self) -> mir::Body {\n-        crate::rustc_smir::mir_body(self)\n+        with(|cx| cx.mir_body(self))\n     }\n }\n \n /// Return the function where execution starts if the current\n /// crate defines that. This is usually `main`, but could be\n /// `start` if the crate is a no-std crate.\n pub fn entry_fn() -> Option<CrateItem> {\n-    crate::rustc_smir::entry_fn()\n+    with(|cx| cx.entry_fn())\n }\n \n /// Access to the local crate.\n pub fn local_crate() -> Crate {\n-    crate::rustc_smir::local_crate()\n+    with(|cx| cx.local_crate())\n }\n \n /// Try to find a crate with the given name.\n pub fn find_crate(name: &str) -> Option<Crate> {\n-    crate::rustc_smir::find_crate(name)\n+    with(|cx| cx.find_crate(name))\n }\n \n /// Try to find a crate with the given name.\n pub fn external_crates() -> Vec<Crate> {\n-    crate::rustc_smir::external_crates()\n+    with(|cx| cx.external_crates())\n }\n \n /// Retrieve all items in the local crate that have a MIR associated with them.\n pub fn all_local_items() -> CrateItems {\n-    crate::rustc_smir::all_local_items()\n+    with(|cx| cx.all_local_items())\n+}\n+\n+pub trait Context {\n+    fn entry_fn(&mut self) -> Option<CrateItem>;\n+    /// Retrieve all items of the local crate that have a MIR associated with them.\n+    fn all_local_items(&mut self) -> CrateItems;\n+    fn mir_body(&mut self, item: &CrateItem) -> mir::Body;\n+    /// Get information about the local crate.\n+    fn local_crate(&self) -> Crate;\n+    /// Retrieve a list of all external crates.\n+    fn external_crates(&self) -> Vec<Crate>;\n+\n+    /// Find a crate with the given name.\n+    fn find_crate(&self, name: &str) -> Option<Crate>;\n+\n+    /// Obtain the representation of a type.\n+    fn ty_kind(&mut self, ty: Ty) -> TyKind;\n+\n+    /// HACK: Until we have fully stable consumers, we need an escape hatch\n+    /// to get `DefId`s out of `CrateItem`s.\n+    fn rustc_tables(&mut self, f: &mut dyn FnMut(&mut Tables<'_>));\n+}\n+\n+thread_local! {\n+    /// A thread local variable that stores a pointer to the tables mapping between TyCtxt\n+    /// datastructures and stable MIR datastructures.\n+    static TLV: Cell<*mut ()> = const { Cell::new(std::ptr::null_mut()) };\n+}\n+\n+pub fn run(mut context: impl Context, f: impl FnOnce()) {\n+    assert!(TLV.get().is_null());\n+    fn g<'a>(mut context: &mut (dyn Context + 'a), f: impl FnOnce()) {\n+        TLV.set(&mut context as *mut &mut _ as _);\n+        f();\n+        TLV.replace(std::ptr::null_mut());\n+    }\n+    g(&mut context, f);\n+}\n+\n+/// Loads the current context and calls a function with it.\n+/// Do not nest these, as that will ICE.\n+pub(crate) fn with<R>(f: impl FnOnce(&mut dyn Context) -> R) -> R {\n+    let ptr = TLV.replace(std::ptr::null_mut()) as *mut &mut dyn Context;\n+    assert!(!ptr.is_null());\n+    let ret = f(unsafe { *ptr });\n+    TLV.set(ptr as _);\n+    ret\n }"}, {"sha": "f27801b0f6caec31947c984b6ca4f3575057b736", "filename": "compiler/rustc_smir/src/stable_mir/ty.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,15 @@\n+use super::with;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Ty(pub usize);\n+\n+impl Ty {\n+    pub fn kind(&self) -> TyKind {\n+        with(|context| context.ty_kind(*self))\n+    }\n+}\n+\n+pub enum TyKind {\n+    Bool,\n+    Tuple(Vec<Ty>),\n+}"}, {"sha": "25cc82f01d5535822fc09611e7add79ab26c4a08", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 154, "deletions": 4, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate;\n+use rustc_infer::traits::Reveal;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -87,7 +88,9 @@ pub(super) enum CandidateSource {\n }\n \n /// Methods used to assemble candidates for either trait or projection goals.\n-pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n+pub(super) trait GoalKind<'tcx>:\n+    TypeFoldable<TyCtxt<'tcx>> + Copy + Eq + std::fmt::Display\n+{\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n@@ -96,6 +99,17 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n+    // Try equating an assumption predicate against a goal's predicate. If it\n+    // holds, then execute the `then` callback, which should do any additional\n+    // work, then produce a response (typically by executing\n+    // [`EvalCtxt::evaluate_added_goals_and_make_canonical_response`]).\n+    fn probe_and_match_goal_against_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n     // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n     // goal by equating it with the assumption.\n@@ -104,7 +118,26 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.add_goals(requirements);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    /// Consider a bound originating from the item bounds of an alias. For this we\n+    /// require that the well-formed requirements of the self type of the goal\n+    /// are \"satisfied from the param-env\".\n+    /// See [`EvalCtxt::validate_alias_bound_self_from_param_env`].\n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.validate_alias_bound_self_from_param_env(goal)\n+        })\n+    }\n \n     // Consider a clause specifically for a `dyn Trait` self type. This requires\n     // additionally checking all of the supertraits and object bounds to hold,\n@@ -113,7 +146,25 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            let tcx = ecx.tcx();\n+            let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+            ecx.add_goals(\n+                structural_traits::predicates_for_object_candidate(\n+                    &ecx,\n+                    goal.param_env,\n+                    goal.predicate.trait_ref(tcx),\n+                    bounds,\n+                )\n+                .into_iter()\n+                .map(|pred| goal.with(tcx, pred)),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n \n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n@@ -463,7 +514,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n+            match G::consider_alias_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -472,6 +523,105 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// Check that we are allowed to use an alias bound originating from the self\n+    /// type of this goal. This means something different depending on the self type's\n+    /// alias kind.\n+    ///\n+    /// * Projection: Given a goal with a self type such as `<Ty as Trait>::Assoc`,\n+    /// we require that the bound `Ty: Trait` can be proven using either a nested alias\n+    /// bound candidate, or a param-env candidate.\n+    ///\n+    /// * Opaque: The param-env must be in `Reveal::UserFacing` mode. Otherwise,\n+    /// the goal should be proven by using the hidden type instead.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn validate_alias_bound_self_from_param_env<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+    ) -> QueryResult<'tcx> {\n+        match *goal.predicate.self_ty().kind() {\n+            ty::Alias(ty::Projection, projection_ty) => {\n+                let mut param_env_candidates = vec![];\n+                let self_trait_ref = projection_ty.trait_ref(self.tcx());\n+\n+                if self_trait_ref.self_ty().is_ty_var() {\n+                    return self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+\n+                let trait_goal: Goal<'_, ty::TraitPredicate<'tcx>> = goal.with(\n+                    self.tcx(),\n+                    ty::TraitPredicate {\n+                        trait_ref: self_trait_ref,\n+                        constness: ty::BoundConstness::NotConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    },\n+                );\n+\n+                self.assemble_param_env_candidates(trait_goal, &mut param_env_candidates);\n+                // FIXME: We probably need some sort of recursion depth check here.\n+                // Can't come up with an example yet, though, and the worst case\n+                // we can have is a compiler stack overflow...\n+                self.assemble_alias_bound_candidates(trait_goal, &mut param_env_candidates);\n+\n+                // FIXME: We must also consider alias-bound candidates for a peculiar\n+                // class of built-in candidates that I'll call \"defaulted\" built-ins.\n+                //\n+                // For example, we always know that `T: Pointee` is implemented, but\n+                // we do not always know what `<T as Pointee>::Metadata` actually is,\n+                // similar to if we had a user-defined impl with a `default type ...`.\n+                // For these traits, since we're not able to always normalize their\n+                // associated types to a concrete type, we must consider their alias bounds\n+                // instead, so we can prove bounds such as `<T as Pointee>::Metadata: Copy`.\n+                self.assemble_alias_bound_candidates_for_builtin_impl_default_items(\n+                    trait_goal,\n+                    &mut param_env_candidates,\n+                );\n+\n+                self.merge_candidates(param_env_candidates)\n+            }\n+            ty::Alias(ty::Opaque, _opaque_ty) => match goal.param_env.reveal() {\n+                Reveal::UserFacing => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                Reveal::All => return Err(NoSolution),\n+            },\n+            _ => bug!(\"only expected to be called on alias tys\"),\n+        }\n+    }\n+\n+    /// Assemble a subset of builtin impl candidates for a class of candidates called\n+    /// \"defaulted\" built-in traits.\n+    ///\n+    /// For example, we always know that `T: Pointee` is implemented, but we do not\n+    /// always know what `<T as Pointee>::Metadata` actually is! See the comment in\n+    /// [`EvalCtxt::validate_alias_bound_self_from_param_env`] for more detail.\n+    #[instrument(level = \"debug\", skip_all)]\n+    fn assemble_alias_bound_candidates_for_builtin_impl_default_items<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+\n+        // You probably shouldn't add anything to this list unless you\n+        // know what you're doing.\n+        let result = if lang_items.pointee_trait() == Some(trait_def_id) {\n+            G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip_all)]\n     fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,"}, {"sha": "20ce2d9416e73eeeb3c30676a74dfc1735d05bcb", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -56,11 +56,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n@@ -75,49 +75,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n                     .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.probe(|ecx| {\n-                let tcx = ecx.tcx();\n-\n-                let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.projection_ty.trait_ref(tcx),\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "dcfa33ae842e9b5f02d14dd9265055cb802bc02b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -78,11 +78,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -97,48 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n-        {\n-            // FIXME: Constness and polarity\n-            ecx.probe(|ecx| {\n-                let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.trait_ref,\n-                    assumption_trait_pred.trait_ref,\n-                )?;\n-\n-                let tcx = ecx.tcx();\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.trait_ref,\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "3dd1d056be24f603e272e5e68486547d709a2882", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -394,7 +394,7 @@ impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n pub fn thir_abstract_const(\n     tcx: TyCtxt<'_>,\n     def: LocalDefId,\n-) -> Result<Option<ty::Const<'_>>, ErrorGuaranteed> {\n+) -> Result<Option<ty::EarlyBinder<ty::Const<'_>>>, ErrorGuaranteed> {\n     if !tcx.features().generic_const_exprs {\n         return Ok(None);\n     }\n@@ -420,7 +420,7 @@ pub fn thir_abstract_const(\n \n     let root_span = body.exprs[body_id].span;\n \n-    Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n+    Ok(Some(ty::EarlyBinder(recurse_build(tcx, body, body_id, root_span)?)))\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "23ded42fa6679c53f19c489ad2fa5ffff75c1609", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -1187,7 +1187,7 @@ extern \"rust-intrinsic\" {\n     /// Below are common applications of `transmute` which can be replaced with safer\n     /// constructs.\n     ///\n-    /// Turning raw bytes (`&[u8]`) into `u32`, `f64`, etc.:\n+    /// Turning raw bytes (`[u8; SZ]`) into `u32`, `f64`, etc.:\n     ///\n     /// ```\n     /// let raw_bytes = [0x78, 0x56, 0x34, 0x12];"}, {"sha": "c432ce3c324c470f368075e5b36245c43c8cb67e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -119,7 +119,39 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     });\n \n     let kind = ModuleItem(Module { items, span });\n-    Item::from_def_id_and_parts(doc.def_id.to_def_id(), Some(doc.name), kind, cx)\n+    generate_item_with_correct_attrs(cx, kind, doc.def_id, doc.name, doc.import_id, doc.renamed)\n+}\n+\n+fn generate_item_with_correct_attrs(\n+    cx: &mut DocContext<'_>,\n+    kind: ItemKind,\n+    local_def_id: LocalDefId,\n+    name: Symbol,\n+    import_id: Option<LocalDefId>,\n+    renamed: Option<Symbol>,\n+) -> Item {\n+    let def_id = local_def_id.to_def_id();\n+    let target_attrs = inline::load_attrs(cx, def_id);\n+    let attrs = if let Some(import_id) = import_id {\n+        let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n+            .lists(sym::doc)\n+            .get_word_attr(sym::inline)\n+            .is_some();\n+        let mut attrs = get_all_import_attributes(cx, import_id, local_def_id, is_inline);\n+        add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n+        attrs\n+    } else {\n+        // We only keep the item's attributes.\n+        target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n+    };\n+\n+    let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+    let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n+\n+    let name = renamed.or(Some(name));\n+    let mut item = Item::from_def_id_and_attrs_and_parts(def_id, name, kind, Box::new(attrs), cfg);\n+    item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n+    item\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -2345,29 +2377,14 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let target_attrs = inline::load_attrs(cx, def_id);\n-        let attrs = if let Some(import_id) = import_id {\n-            let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n-                .lists(sym::doc)\n-                .get_word_attr(sym::inline)\n-                .is_some();\n-            let mut attrs =\n-                get_all_import_attributes(cx, import_id, item.owner_id.def_id, is_inline);\n-            add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n-            attrs\n-        } else {\n-            // We only keep the item's attributes.\n-            target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n-        };\n-\n-        let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n-        let attrs =\n-            Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n-\n-        let mut item =\n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n-        vec![item]\n+        vec![generate_item_with_correct_attrs(\n+            cx,\n+            kind,\n+            item.owner_id.def_id,\n+            name,\n+            import_id,\n+            renamed,\n+        )]\n     })\n }\n "}, {"sha": "c0730e90740ebf02e06641a0fd9af3f04177b7f9", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -195,7 +195,13 @@ impl Cache {\n impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.item_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.item_id);\n+            let is_stripped = matches!(*item.kind, clean::ItemKind::StrippedItem(..));\n+            debug!(\n+                \"folding {} (stripped: {is_stripped:?}) \\\"{:?}\\\", id {:?}\",\n+                item.type_(),\n+                item.name,\n+                item.item_id\n+            );\n         }\n \n         // If this is a stripped module,"}, {"sha": "10295cbd189b110357ff0f981a972b8062463a8f", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -95,7 +95,7 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())\n-        || inherits_doc_hidden(cx.tcx, def_id)\n+        || inherits_doc_hidden(cx.tcx, def_id, None)\n         || cx.tcx.def_span(def_id.to_def_id()).in_derive_expansion()\n     {\n         return false;"}, {"sha": "972b0c5ec190ea85d0c53d0781c20b4601aff48d", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -1,5 +1,6 @@\n //! Strip all doc(hidden) items from the output.\n \n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use std::mem;\n@@ -29,6 +30,7 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n             update_retained: true,\n             tcx: cx.tcx,\n             is_in_hidden_item: false,\n+            last_reexport: None,\n         };\n         stripper.fold_crate(krate)\n     };\n@@ -49,13 +51,24 @@ struct Stripper<'a, 'tcx> {\n     update_retained: bool,\n     tcx: TyCtxt<'tcx>,\n     is_in_hidden_item: bool,\n+    last_reexport: Option<LocalDefId>,\n }\n \n impl<'a, 'tcx> Stripper<'a, 'tcx> {\n+    fn set_last_reexport_then_fold_item(&mut self, i: Item) -> Item {\n+        let prev_from_reexport = self.last_reexport;\n+        if i.inline_stmt_id.is_some() {\n+            self.last_reexport = i.item_id.as_def_id().and_then(|def_id| def_id.as_local());\n+        }\n+        let ret = self.fold_item_recur(i);\n+        self.last_reexport = prev_from_reexport;\n+        ret\n+    }\n+\n     fn set_is_in_hidden_item_and_fold(&mut self, is_in_hidden_item: bool, i: Item) -> Item {\n         let prev = self.is_in_hidden_item;\n         self.is_in_hidden_item |= is_in_hidden_item;\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -64,7 +77,7 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n     /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n     fn recurse_in_impl_or_exported_macro(&mut self, i: Item) -> Item {\n         let prev = mem::replace(&mut self.is_in_hidden_item, false);\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -86,13 +99,20 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n         if !is_impl_or_exported_macro {\n             is_hidden = self.is_in_hidden_item || has_doc_hidden;\n             if !is_hidden && i.inline_stmt_id.is_none() {\n-                // We don't need to check if it's coming from a reexport since the reexport itself was\n-                // already checked.\n+                // `i.inline_stmt_id` is `Some` if the item is directly reexported. If it is, we\n+                // don't need to check it, because the reexport itself was already checked.\n+                //\n+                // If this item is the child of a reexported module, `self.last_reexport` will be\n+                // `Some` even though `i.inline_stmt_id` is `None`. Hiddenness inheritance needs to\n+                // account for the possibility that an item's true parent module is hidden, but it's\n+                // inlined into a visible module true. This code shouldn't be reachable if the\n+                // module's reexport is itself hidden, for the same reason it doesn't need to be\n+                // checked if `i.inline_stmt_id` is Some: hidden reexports are never inlined.\n                 is_hidden = i\n                     .item_id\n                     .as_def_id()\n                     .and_then(|def_id| def_id.as_local())\n-                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id, self.last_reexport))\n                     .unwrap_or(false);\n             }\n         }"}, {"sha": "deb29b1e7a9115166387374e43017155028f4704", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -27,6 +27,8 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) def_id: LocalDefId,\n+    pub(crate) renamed: Option<Symbol>,\n+    pub(crate) import_id: Option<LocalDefId>,\n     /// The key is the item `ItemId` and the value is: (item, renamed, import_id).\n     /// We use `FxIndexMap` to keep the insert order.\n     pub(crate) items: FxIndexMap<\n@@ -37,11 +39,19 @@ pub(crate) struct Module<'hir> {\n }\n \n impl Module<'_> {\n-    pub(crate) fn new(name: Symbol, def_id: LocalDefId, where_inner: Span) -> Self {\n+    pub(crate) fn new(\n+        name: Symbol,\n+        def_id: LocalDefId,\n+        where_inner: Span,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) -> Self {\n         Module {\n             name,\n             def_id,\n             where_inner,\n+            renamed,\n+            import_id,\n             mods: Vec::new(),\n             items: FxIndexMap::default(),\n             foreigns: Vec::new(),\n@@ -60,9 +70,16 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+pub(crate) fn inherits_doc_hidden(\n+    tcx: TyCtxt<'_>,\n+    mut def_id: LocalDefId,\n+    stop_at: Option<LocalDefId>,\n+) -> bool {\n     let hir = tcx.hir();\n     while let Some(id) = tcx.opt_local_parent(def_id) {\n+        if let Some(stop_at) = stop_at && id == stop_at {\n+            return false;\n+        }\n         def_id = id;\n         if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n@@ -100,6 +117,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             cx.tcx.crate_name(LOCAL_CRATE),\n             CRATE_DEF_ID,\n             cx.tcx.hir().root_module().spans.inner_span,\n+            None,\n+            None,\n         );\n \n         RustdocVisitor {\n@@ -261,7 +280,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let is_private =\n             !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n@@ -278,7 +297,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 .cache\n                 .effective_visibilities\n                 .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n@@ -427,7 +446,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                self.enter_mod(item.owner_id.def_id, m, name);\n+                self.enter_mod(item.owner_id.def_id, m, name, renamed, import_id);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -480,8 +499,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// This method will create a new module and push it onto the \"modules stack\" then call\n     /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n     /// add into the list of modules of the current module.\n-    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n-        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+    fn enter_mod(\n+        &mut self,\n+        id: LocalDefId,\n+        m: &'tcx hir::Mod<'tcx>,\n+        name: Symbol,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span, renamed, import_id));\n \n         self.visit_mod_contents(id, m);\n \n@@ -501,19 +527,14 @@ impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         self.visit_item_inner(i, None, None);\n-        let new_value = if self.is_importable_from_parent {\n-            matches!(\n+        let new_value = self.is_importable_from_parent\n+            && matches!(\n                 i.kind,\n                 hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod { .. }\n                     | hir::ItemKind::Impl(..)\n                     | hir::ItemKind::Trait(..)\n-            )\n-        } else {\n-            // Whatever the context, if it's an impl block, the items inside it can be used so they\n-            // should be visible.\n-            matches!(i.kind, hir::ItemKind::Impl(..))\n-        };\n+            );\n         let prev = mem::replace(&mut self.is_importable_from_parent, new_value);\n         walk_item(self, i);\n         self.is_importable_from_parent = prev;"}, {"sha": "8e1029a1ca3df9fc54c1f67539dd5a5475ddc193", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,31 @@\n+#![feature(no_core)]\n+#![no_core]\n+#![crate_name = \"foo\"]\n+\n+// @!has 'foo/hidden/index.html'\n+// FIXME: add missing `@` for the two next tests once issue is fixed!\n+// To be done in <https://github.com/rust-lang/rust/issues/111249>.\n+// !has 'foo/hidden/inner/index.html'\n+// !has 'foo/hidden/inner/trait.Foo.html'\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub mod inner {\n+        pub trait Foo {\n+            /// Hello, world!\n+            fn test();\n+        }\n+    }\n+}\n+\n+// @has 'foo/visible/index.html'\n+// @has 'foo/visible/trait.Foo.html'\n+#[doc(inline)]\n+pub use hidden::inner as visible;\n+\n+// @has 'foo/struct.Bar.html'\n+// @count - '//*[@id=\"impl-Foo-for-Bar\"]' 1\n+pub struct Bar;\n+\n+impl visible::Foo for Bar {\n+    fn test() {}\n+}"}, {"sha": "a9ce4a34507e6e73d82c96f201bfaa325c164c18", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/111064>.\n+// Methods from a re-exported trait inside a `#[doc(hidden)]` item should\n+// be visible.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"item-name\"]/a[@href=\"trait.Foo.html\"]' 'Foo'\n+\n+// @has 'foo/trait.Foo.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"code-header\"]' 'fn test()'\n+\n+#[doc(hidden)]\n+mod hidden {\n+    pub trait Foo {\n+        /// Hello, world!\n+        fn test();\n+    }\n+}\n+\n+pub use hidden::Foo;"}, {"sha": "a3db2e9ef24c4a2db9e86dd0078b9b3e546e5fa2", "filename": "tests/ui-fulldeps/stable-mir/crate-info.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -40,6 +40,7 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n \n     let bar = get_item(tcx, &items, (DefKind::Fn, \"bar\")).unwrap();\n     let body = bar.body();\n+    assert_eq!(body.locals.len(), 2);\n     assert_eq!(body.blocks.len(), 1);\n     let block = &body.blocks[0];\n     assert_eq!(block.statements.len(), 1);\n@@ -54,6 +55,7 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n \n     let foo_bar = get_item(tcx, &items, (DefKind::Fn, \"foo_bar\")).unwrap();\n     let body = foo_bar.body();\n+    assert_eq!(body.locals.len(), 7);\n     assert_eq!(body.blocks.len(), 4);\n     let block = &body.blocks[0];\n     match &block.terminator {\n@@ -123,7 +125,7 @@ impl Callbacks for SMirCalls {\n         queries: &'tcx Queries<'tcx>,\n     ) -> Compilation {\n         queries.global_ctxt().unwrap().enter(|tcx| {\n-            test_stable_mir(tcx);\n+            rustc_smir::rustc_internal::run(tcx, || test_stable_mir(tcx));\n         });\n         // No need to keep going.\n         Compilation::Stop"}, {"sha": "00294c708f1fa059701f02808d1fad4f3e018378", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// Makes sure that alias bounds are not unsound!\n+\n+#![feature(trivial_bounds)]\n+\n+trait Foo {\n+    type Item: Copy\n+    where\n+        <Self as Foo>::Item: Copy;\n+\n+    fn copy_me(x: &Self::Item) -> Self::Item {\n+        *x\n+    }\n+}\n+\n+impl Foo for () {\n+    type Item = String where String: Copy;\n+}\n+\n+fn main() {\n+    let x = String::from(\"hello, world\");\n+    drop(<() as Foo>::copy_me(&x));\n+    //~^ ERROR `<() as Foo>::Item: Copy` is not satisfied\n+    //~| ERROR `<() as Foo>::Item` is not well-formed\n+    println!(\"{x}\");\n+}"}, {"sha": "9a43d2a6639ce86bf4ded8d1ca86277a8fa41b01", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `<() as Foo>::Item: Copy` is not satisfied\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `<() as Foo>::Item`\n+   |\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/alias-bound-unsound.rs:10:30\n+   |\n+LL |     type Item: Copy\n+   |          ---- required by a bound in this associated type\n+LL |     where\n+LL |         <Self as Foo>::Item: Copy;\n+   |                              ^^^^ required by this bound in `Foo::Item`\n+\n+error: the type `<() as Foo>::Item` is not well-formed\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c365902dbe5e833a07f1e5f98f247d1774b708aa", "filename": "tests/ui/traits/new-solver/nested-alias-bound.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25444e5a2e7293dbb4932df1301b9be4222244fe/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs?ref=25444e5a2e7293dbb4932df1301b9be4222244fe", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait A {\n+    type A: B;\n+}\n+\n+trait B {\n+    type B: C;\n+}\n+\n+trait C {}\n+\n+fn needs_c<T: C>() {}\n+\n+fn test<T: A>() {\n+    needs_c::<<T::A as B>::B>();\n+}\n+\n+fn main() {}"}]}