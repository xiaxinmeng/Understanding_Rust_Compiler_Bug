{"sha": "057c9ae30ac968e7693d4748294bf0563ee346fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1N2M5YWUzMGFjOTY4ZTc2OTNkNDc0ODI5NGJmMDU2M2VlMzQ2ZmE=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-05T17:47:32Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-05T17:47:32Z"}, "message": "Guide: generics", "tree": {"sha": "ed44d2f2ff7461d006dc72a565c632b4a41423b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed44d2f2ff7461d006dc72a565c632b4a41423b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/057c9ae30ac968e7693d4748294bf0563ee346fa", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/057c9ae30ac968e7693d4748294bf0563ee346fa", "html_url": "https://github.com/rust-lang/rust/commit/057c9ae30ac968e7693d4748294bf0563ee346fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/057c9ae30ac968e7693d4748294bf0563ee346fa/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4", "html_url": "https://github.com/rust-lang/rust/commit/efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4"}], "stats": {"total": 176, "additions": 176, "deletions": 0}, "files": [{"sha": "69377b1185b95cdf9c0de3d9ec58982c98e20c22", "filename": "src/doc/guide.md", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/057c9ae30ac968e7693d4748294bf0563ee346fa/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/057c9ae30ac968e7693d4748294bf0563ee346fa/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=057c9ae30ac968e7693d4748294bf0563ee346fa", "patch": "@@ -3620,6 +3620,182 @@ guide](http://doc.rust-lang.org/guide-pointers.html#rc-and-arc).\n \n # Generics\n \n+Sometimes, when writing a function or data type, we may want it to work for\n+multiple types of arguments. For example, remember our `OptionalInt` type?\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+```\n+\n+If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n+\n+```{rust}\n+enum OptionalFloat64 {\n+    Valuef64(f64),\n+    Missingf64,\n+}\n+```\n+\n+This is really unfortunate. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called **parametric polymorphism** in type theory,\n+which means that they are types or functions that have multiple forms (\"poly\"\n+is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+\n+Anyway, enough with type theory declarations, let's check out the generic form\n+of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+\n+```rust\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+```\n+\n+The `<T>` part, which you've seen a few times before, indicates that this is\n+a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n+we substitute that type for the same type used in the generic. Here's an\n+example of using `Option<T>`, with some extra type annotations:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+```\n+\n+In the type declaration, we say `Option<int>`. Note how similar this looks to\n+`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n+the right hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n+Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n+match, we'd get an error:\n+\n+```{rust,ignore}\n+let x: Option<f64> = Some(5i);\n+// error: mismatched types: expected `core::option::Option<f64>`\n+// but found `core::option::Option<int>` (expected f64 but found int)\n+```\n+\n+That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n+match up:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+let y: Option<f64> = Some(5.0f64);\n+```\n+\n+This is just fine. One definition, multiple uses.\n+\n+Generics don't have to only be generic over one type. Consider Rust's built-in\n+`Result<T, E>` type:\n+\n+```{rust}\n+enum Result<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+```\n+\n+This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n+can be any letter you'd like. We could define `Result<T, E>` as:\n+\n+```{rust}\n+enum Result<H, N> {\n+    Ok(H),\n+    Err(N),\n+}\n+```\n+\n+if we wanted to. Convention says that the first generic parameter should be\n+`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+\n+The `Result<T, E>` type is intended to\n+be used to return the result of a computation, and to have the ability to\n+return an error if it didn't work out. Here's an example:\n+\n+```{rust}\n+let x: Result<f64, String> = Ok(2.3f64);\n+let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n+```\n+\n+This particular Result will return an `int` if there's a success, and a\n+`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+\n+```{rust}\n+fn square_root(x: f64) -> Result<f64, String> {\n+    if x < 0.0f64 { return Err(\"x must be positive!\".to_string()); }\n+\n+    Ok(x * (1.0f64 / 2.0f64))\n+}\n+```\n+\n+We don't want to take the square root of a negative number, so we check\n+to make sure that's true. If it's not, then we return an `Err`, with a\n+message. If it's okay, we return an `Ok`, with the answer.\n+\n+Why does this matter? Well, remember how `match` does exhaustive matches?\n+Here's how this function gets used:\n+\n+```{rust}\n+# fn square_root(x: f64) -> Result<f64, String> {\n+#     if x < 0.0f64 { return Err(\"x must be positive!\".to_string()); }\n+#     Ok(x * (1.0f64 / 2.0f64))\n+# }\n+let x = square_root(25.0f64);\n+\n+match x {\n+    Ok(x) => println!(\"The square root of 25 is {}\", x),\n+    Err(msg) => println!(\"Error: {}\", msg),\n+}\n+```\n+\n+The `match enforces that we handle the `Err` case. In addition, because the\n+answer is wrapped up in an `Ok`, we can't just use the result without doing\n+the match:\n+\n+```{rust,ignore}\n+let x = square_root(25.0f64);\n+println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied \n+           // to type `core::result::Result<f64,collections::string::String>`\n+```\n+\n+This function is great, but there's one other problem: it only works for 64 bit\n+floating point values. What if we wanted to handle 32 bit floating point as\n+well? We'd have to write this:\n+\n+```{rust}\n+fn square_root32(x: f32) -> Result<f32, String> {\n+    if x < 0.0f32 { return Err(\"x must be positive!\".to_string()); }\n+\n+    Ok(x * (1.0f32 / 2.0f32))\n+}\n+```\n+\n+Bummer. What we need is a **generic function**. Luckily, we can write one!\n+However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n+A generic version of `square_root` would look something like this:\n+\n+```{rust,ignore}\n+fn square_root<T>(x: T) -> Result<T, String> {\n+    if x < 0.0 { return Err(\"x must be positive!\".to_string()); }\n+\n+    Ok(x * (1.0 / 2.0))\n+}\n+```\n+\n+Just like how we had `Option<T>`, we use a similar syntax for `square_root<T>`.\n+We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n+of the `Result` has type `T`. However, if we try to compile that example, we'll get\n+an error:\n+\n+```{notrust,ignore}\n+error: binary operation `<` cannot be applied to type `T`\n+```\n+\n+Because `T` can be _any_ type, it may be a type that doesn't implement `<`,\n+and therefore, the first line would be wrong. What do we do?\n+\n+To fix this example, we need to learn about another Rust feature: traits.\n+\n # Traits\n \n # Operators and built-in Traits"}]}