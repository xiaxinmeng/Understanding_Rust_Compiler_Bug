{"sha": "282445a288b3c409a998eb72e51827537e81abd3", "node_id": "C_kwDOAAsO6NoAKDI4MjQ0NWEyODhiM2M0MDlhOTk4ZWI3MmU1MTgyNzUzN2U4MWFiZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-09T01:52:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-09T01:52:15Z"}, "message": "Auto merge of #97740 - RalfJung:ctfe-cycle-spans, r=lcnr\n\nuse precise spans for recursive const evaluation\n\nThis fixes https://github.com/rust-lang/rust/issues/73283 by using a `TyCtxtAt` with a more precise span when the interpreter recursively calls itself. Hopefully such calls are sufficiently rare that this does not cost us too much performance.\n\n(In theory, cycles can also arise through layout computation, as layout can depend on consts -- but layout computation happens all the time so we'd have to do something to not make this terrible for performance.)", "tree": {"sha": "c831b10c563a35cd39d8ef4e7c3b2d56945e9b49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c831b10c563a35cd39d8ef4e7c3b2d56945e9b49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/282445a288b3c409a998eb72e51827537e81abd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/282445a288b3c409a998eb72e51827537e81abd3", "html_url": "https://github.com/rust-lang/rust/commit/282445a288b3c409a998eb72e51827537e81abd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/282445a288b3c409a998eb72e51827537e81abd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15f5622a53210099a19ab46ce2316494fb413d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/15f5622a53210099a19ab46ce2316494fb413d7c", "html_url": "https://github.com/rust-lang/rust/commit/15f5622a53210099a19ab46ce2316494fb413d7c"}, {"sha": "467e0f44463f4026922925e6666d96a772ae39d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/467e0f44463f4026922925e6666d96a772ae39d7", "html_url": "https://github.com/rust-lang/rust/commit/467e0f44463f4026922925e6666d96a772ae39d7"}], "stats": {"total": 106, "additions": 66, "deletions": 40}, "files": [{"sha": "1c1bbd370bd4932ac1469e34e726e6f8581689ac", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -126,7 +126,9 @@ pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n     /// We basically abuse `Result` as `Either`.\n-    pub(super) loc: Result<mir::Location, Span>,\n+    ///\n+    /// Needs to be public because ConstProp does unspeakable things to it.\n+    pub loc: Result<mir::Location, Span>,\n }\n \n /// What we store about a frame in an interpreter backtrace.\n@@ -320,6 +322,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOfHelpers<'tcx> for InterpC\n \n     #[inline]\n     fn layout_tcx_at_span(&self) -> Span {\n+        // Using the cheap root span for performance.\n         self.tcx.span\n     }\n \n@@ -923,7 +926,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.param_env\n         };\n         let param_env = param_env.with_const();\n-        let val = self.tcx.eval_to_allocation_raw(param_env.and(gid))?;\n+        // Use a precise span for better cycle errors.\n+        let val = self.tcx.at(self.cur_span()).eval_to_allocation_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }\n "}, {"sha": "c5770f505262e891df5007ce3ec794db211de414", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -169,7 +169,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::needs_drop => self.tcx.types.bool,\n                     sym::type_id => self.tcx.types.u64,\n                     sym::type_name => self.tcx.mk_static_str(),\n-                    _ => bug!(\"already checked for nullary intrinsics\"),\n+                    _ => bug!(),\n                 };\n                 let val =\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n@@ -215,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::add_with_overflow => BinOp::Add,\n                     sym::sub_with_overflow => BinOp::Sub,\n                     sym::mul_with_overflow => BinOp::Mul,\n-                    _ => bug!(\"Already checked for int ops\"),\n+                    _ => bug!(),\n                 };\n                 self.binop_with_overflow(bin_op, &lhs, &rhs, dest)?;\n             }\n@@ -251,7 +251,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::unchecked_mul => BinOp::Mul,\n                     sym::unchecked_div => BinOp::Div,\n                     sym::unchecked_rem => BinOp::Rem,\n-                    _ => bug!(\"Already checked for int ops\"),\n+                    _ => bug!(),\n                 };\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {"}, {"sha": "23ae2db6438c65a8a6a0bf4854f6f9d51b45ee08", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -70,7 +70,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        bug!(\"no non-`#[track_caller]` frame found\")\n+        span_bug!(self.cur_span(), \"no non-`#[track_caller]` frame found\")\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers."}, {"sha": "f725a0591c5b69f75fa1c55e27b267ac9ec84806", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -504,7 +504,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n-                (self.tcx.eval_static_initializer(def_id)?, Some(def_id))\n+                // Use a precise span for better cycle errors.\n+                (self.tcx.at(self.cur_span()).eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n         M::before_access_global(*self.tcx, &self.machine, id, alloc, def_id, is_write)?;"}, {"sha": "85ee88e9e474e72b292752bc242611a413950a72", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -154,14 +154,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = match bin_op {\n                     Shl => l.checked_shl(r).unwrap(),\n                     Shr => l.checked_shr(r).unwrap(),\n-                    _ => bug!(\"it has already been checked that this is a shift op\"),\n+                    _ => bug!(),\n                 };\n                 result as u128\n             } else {\n                 match bin_op {\n                     Shl => l.checked_shl(r).unwrap(),\n                     Shr => l.checked_shr(r).unwrap(),\n-                    _ => bug!(\"it has already been checked that this is a shift op\"),\n+                    _ => bug!(),\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);"}, {"sha": "98f69456e49aab029a0fc0c4aea7987a852f32ab", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -55,33 +55,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         let basic_block = &self.body().basic_blocks()[loc.block];\n \n-        let old_frames = self.frame_idx();\n-\n         if let Some(stmt) = basic_block.statements.get(loc.statement_index) {\n-            assert_eq!(old_frames, self.frame_idx());\n+            let old_frames = self.frame_idx();\n             self.statement(stmt)?;\n+            // Make sure we are not updating `statement_index` of the wrong frame.\n+            assert_eq!(old_frames, self.frame_idx());\n+            // Advance the program counter.\n+            self.frame_mut().loc.as_mut().unwrap().statement_index += 1;\n             return Ok(true);\n         }\n \n         M::before_terminator(self)?;\n \n         let terminator = basic_block.terminator();\n-        assert_eq!(old_frames, self.frame_idx());\n         self.terminator(terminator)?;\n         Ok(true)\n     }\n \n     /// Runs the interpretation logic for the given `mir::Statement` at the current frame and\n-    /// statement counter. This also moves the statement counter forward.\n+    /// statement counter.\n+    ///\n+    /// This does NOT move the statement counter forward, the caller has to do that!\n     pub fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n \n         use rustc_middle::mir::StatementKind::*;\n \n-        // Some statements (e.g., box) push new stack frames.\n-        // We have to record the stack frame number *before* executing the statement.\n-        let frame_idx = self.frame_idx();\n-\n         match &stmt.kind {\n             Assign(box (place, rvalue)) => self.eval_rvalue_into_place(rvalue, *place)?,\n \n@@ -144,7 +143,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Nop => {}\n         }\n \n-        self.stack_mut()[frame_idx].loc.as_mut().unwrap().statement_index += 1;\n         Ok(())\n     }\n \n@@ -300,6 +298,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Evaluate the given terminator. Will also adjust the stack frame and statement position accordingly.\n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n "}, {"sha": "8fc957cf49c8863aab852db8026d23e5fe178693", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -3,9 +3,9 @@ use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n use crate::mir;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::InternalSubsts;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty::{self, query::TyCtxtAt, TyCtxt};\n use rustc_hir::def_id::DefId;\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates a constant without providing any substitutions. This is useful to evaluate consts\n@@ -86,14 +86,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Evaluate a static's initializer, returning the allocation of the initializer's memory.\n+    #[inline(always)]\n+    pub fn eval_static_initializer(\n+        self,\n+        def_id: DefId,\n+    ) -> Result<mir::ConstAllocation<'tcx>, ErrorHandled> {\n+        self.at(DUMMY_SP).eval_static_initializer(def_id)\n+    }\n+}\n+\n+impl<'tcx> TyCtxtAt<'tcx> {\n     /// Evaluate a static's initializer, returning the allocation of the initializer's memory.\n     pub fn eval_static_initializer(\n         self,\n         def_id: DefId,\n     ) -> Result<mir::ConstAllocation<'tcx>, ErrorHandled> {\n         trace!(\"eval_static_initializer: Need to compute {:?}\", def_id);\n         assert!(self.is_static(def_id));\n-        let instance = ty::Instance::mono(self, def_id);\n+        let instance = ty::Instance::mono(*self, def_id);\n         let gid = GlobalId { instance, promoted: None };\n         self.eval_to_allocation(gid, ty::ParamEnv::reveal_all())\n     }\n@@ -109,7 +120,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         let raw_const = self.eval_to_allocation_raw(param_env.and(gid))?;\n         Ok(self.global_alloc(raw_const.alloc_id).unwrap_memory())\n     }\n+}\n \n+impl<'tcx> TyCtxt<'tcx> {\n     /// Destructure a type-level constant ADT or array into its variant index and its field values.\n     /// Panics if the destructuring fails, use `try_destructure_const` for fallible version.\n     pub fn destructure_const("}, {"sha": "84fdb136bd41cf404b201d825766ed375ebcaba6", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -437,10 +437,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info.scope.lint_root(self.source_scopes)\n     }\n \n-    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n+        // Overwrite the PC -- whatever the interpreter does to it does not make any sense anyway.\n+        self.ecx.frame_mut().loc = Err(source_info.span);\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -501,17 +503,17 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns the value, if any, of evaluating `place`.\n-    fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n     /// or `eval_place`, depending on the variant of `Operand` used.\n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, source_info),\n         }\n     }\n \n@@ -537,7 +539,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         arg: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        if let (val, true) = self.use_ecx(|this| {\n+        if let (val, true) = self.use_ecx(source_info, |this| {\n             let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n@@ -564,8 +566,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n+        let r = self.use_ecx(source_info, |this| {\n+            this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?)\n+        });\n+        let l = self.use_ecx(source_info, |this| {\n+            this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n+        });\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let r = r?;\n@@ -602,7 +608,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         if let (Some(l), Some(r)) = (&l, &r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(|this| {\n+            if self.use_ecx(source_info, |this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n                 Ok(overflow)\n             })? {\n@@ -690,7 +696,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n     }\n }\n \n@@ -890,7 +896,10 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 StatementKind::SetDiscriminant { ref place, .. } => {\n                     match self.ecx.machine.can_const_prop[place.local] {\n                         ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n+                            if self\n+                                .use_ecx(source_info, |this| this.ecx.statement(statement))\n+                                .is_some()\n+                            {\n                                 trace!(\"propped discriminant into {:?}\", place);\n                             } else {\n                                 Self::remove_const(&mut self.ecx, place.local);"}, {"sha": "2a4ad5825ecfa7df9ea9b8e2a6616f93b24203a4", "filename": "src/test/ui/consts/recursive-zst-static.default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.default.stderr?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -5,10 +5,10 @@ LL | static FOO: () = FOO;\n    | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating + checking `FOO`...\n-  --> $DIR/recursive-zst-static.rs:10:1\n+  --> $DIR/recursive-zst-static.rs:10:18\n    |\n LL | static FOO: () = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n    = note: ...which again requires const-evaluating + checking `FOO`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n "}, {"sha": "2a4ad5825ecfa7df9ea9b8e2a6616f93b24203a4", "filename": "src/test/ui/consts/recursive-zst-static.unleash.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.unleash.stderr?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -5,10 +5,10 @@ LL | static FOO: () = FOO;\n    | ^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating + checking `FOO`...\n-  --> $DIR/recursive-zst-static.rs:10:1\n+  --> $DIR/recursive-zst-static.rs:10:18\n    |\n LL | static FOO: () = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n    = note: ...which again requires const-evaluating + checking `FOO`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n "}, {"sha": "ab4b8844e5b5a4e207a76ae94e5cfc90a15eae40", "filename": "src/test/ui/consts/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Fconsts%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite-to-static-mut-in-static.stderr?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -11,10 +11,10 @@ LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating + checking `C`...\n-  --> $DIR/write-to-static-mut-in-static.rs:5:1\n+  --> $DIR/write-to-static-mut-in-static.rs:5:34\n    |\n LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  ^^^^^\n    = note: ...which again requires const-evaluating + checking `C`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n "}, {"sha": "be4f09f9286d1a5ec0ec652e73c0d4ea010cced8", "filename": "src/test/ui/recursion/recursive-static-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/282445a288b3c409a998eb72e51827537e81abd3/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-static-definition.stderr?ref=282445a288b3c409a998eb72e51827537e81abd3", "patch": "@@ -5,10 +5,10 @@ LL | pub static FOO: u32 = FOO;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating + checking `FOO`...\n-  --> $DIR/recursive-static-definition.rs:1:1\n+  --> $DIR/recursive-static-definition.rs:1:23\n    |\n LL | pub static FOO: u32 = FOO;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^\n    = note: ...which again requires const-evaluating + checking `FOO`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n "}]}