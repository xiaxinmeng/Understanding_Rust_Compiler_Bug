{"sha": "894ab2ce7ab15b3bdb1d976aee21ff3157c8779b", "node_id": "C_kwDOAAsO6NoAKDg5NGFiMmNlN2FiMTViM2JkYjFkOTc2YWVlMjFmZjMxNTdjODc3OWI", "commit": {"author": {"name": "bohan", "email": "bohan-zhang@foxmail.com", "date": "2023-06-18T12:55:16Z"}, "committer": {"name": "bohan", "email": "bohan-zhang@foxmail.com", "date": "2023-06-18T13:03:59Z"}, "message": "refactor(resolve): delete `update_resolution` function", "tree": {"sha": "0026f0d5c2b9ee1dd47523f4859751a9f372642a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0026f0d5c2b9ee1dd47523f4859751a9f372642a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b", "html_url": "https://github.com/rust-lang/rust/commit/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b/comments", "author": {"login": "bvanjoi", "id": 30187863, "node_id": "MDQ6VXNlcjMwMTg3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/30187863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bvanjoi", "html_url": "https://github.com/bvanjoi", "followers_url": "https://api.github.com/users/bvanjoi/followers", "following_url": "https://api.github.com/users/bvanjoi/following{/other_user}", "gists_url": "https://api.github.com/users/bvanjoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/bvanjoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bvanjoi/subscriptions", "organizations_url": "https://api.github.com/users/bvanjoi/orgs", "repos_url": "https://api.github.com/users/bvanjoi/repos", "events_url": "https://api.github.com/users/bvanjoi/events{/privacy}", "received_events_url": "https://api.github.com/users/bvanjoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bvanjoi", "id": 30187863, "node_id": "MDQ6VXNlcjMwMTg3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/30187863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bvanjoi", "html_url": "https://github.com/bvanjoi", "followers_url": "https://api.github.com/users/bvanjoi/followers", "following_url": "https://api.github.com/users/bvanjoi/following{/other_user}", "gists_url": "https://api.github.com/users/bvanjoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/bvanjoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bvanjoi/subscriptions", "organizations_url": "https://api.github.com/users/bvanjoi/orgs", "repos_url": "https://api.github.com/users/bvanjoi/repos", "events_url": "https://api.github.com/users/bvanjoi/events{/privacy}", "received_events_url": "https://api.github.com/users/bvanjoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fb0e38087cb8fcc6de5fe2ce347e939dfdb0bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fb0e38087cb8fcc6de5fe2ce347e939dfdb0bd", "html_url": "https://github.com/rust-lang/rust/commit/76fb0e38087cb8fcc6de5fe2ce347e939dfdb0bd"}], "stats": {"total": 93, "additions": 40, "deletions": 53}, "files": [{"sha": "23ef9bf53a195f821c676bab575080b1196dc5d8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894ab2ce7ab15b3bdb1d976aee21ff3157c8779b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=894ab2ce7ab15b3bdb1d976aee21ff3157c8779b", "patch": "@@ -304,21 +304,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let res = binding.res();\n         self.check_reserved_macro_name(key.ident, res);\n         self.set_binding_parent_module(binding, module);\n-        self.update_resolution(module, key, |this, resolution| {\n-            if let Some(old_binding) = resolution.binding {\n-                if res == Res::Err && old_binding.res() != Res::Err {\n-                    // Do not override real bindings with `Res::Err`s from error recovery.\n-                    return Ok(());\n-                }\n+\n+        let mut resolution = self.resolution(module, key).borrow_mut();\n+        let old_binding = resolution.binding();\n+        let mut t = Ok(());\n+        if let Some(old_binding) = resolution.binding {\n+            if res == Res::Err && old_binding.res() != Res::Err {\n+                // Do not override real bindings with `Res::Err`s from error recovery.\n+            } else {\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n                         if res != old_binding.res() {\n-                            resolution.binding = Some(this.ambiguity(\n+                            resolution.binding = Some(self.ambiguity(\n                                 AmbiguityKind::GlobVsGlob,\n                                 old_binding,\n                                 binding,\n                             ));\n-                        } else if !old_binding.vis.is_at_least(binding.vis, this.tcx) {\n+                        } else if !old_binding.vis.is_at_least(binding.vis, self.tcx) {\n                             // We are glob-importing the same item but with greater visibility.\n                             resolution.binding = Some(binding);\n                         }\n@@ -330,7 +332,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             && key.ns == MacroNS\n                             && nonglob_binding.expansion != LocalExpnId::ROOT\n                         {\n-                            resolution.binding = Some(this.ambiguity(\n+                            resolution.binding = Some(self.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n                                 nonglob_binding,\n                                 glob_binding,\n@@ -342,66 +344,40 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         if let Some(old_binding) = resolution.shadowed_glob {\n                             assert!(old_binding.is_glob_import());\n                             if glob_binding.res() != old_binding.res() {\n-                                resolution.shadowed_glob = Some(this.ambiguity(\n+                                resolution.shadowed_glob = Some(self.ambiguity(\n                                     AmbiguityKind::GlobVsGlob,\n                                     old_binding,\n                                     glob_binding,\n                                 ));\n-                            } else if !old_binding.vis.is_at_least(binding.vis, this.tcx) {\n+                            } else if !old_binding.vis.is_at_least(binding.vis, self.tcx) {\n                                 resolution.shadowed_glob = Some(glob_binding);\n                             }\n                         } else {\n                             resolution.shadowed_glob = Some(glob_binding);\n                         }\n                     }\n                     (false, false) => {\n-                        return Err(old_binding);\n+                        t = Err(old_binding);\n                     }\n                 }\n-            } else {\n-                resolution.binding = Some(binding);\n             }\n+        } else {\n+            resolution.binding = Some(binding);\n+        };\n \n-            Ok(())\n-        })\n-    }\n-\n-    fn ambiguity(\n-        &self,\n-        kind: AmbiguityKind,\n-        primary_binding: &'a NameBinding<'a>,\n-        secondary_binding: &'a NameBinding<'a>,\n-    ) -> &'a NameBinding<'a> {\n-        self.arenas.alloc_name_binding(NameBinding {\n-            ambiguity: Some((secondary_binding, kind)),\n-            ..primary_binding.clone()\n-        })\n-    }\n-\n-    // Use `f` to mutate the resolution of the name in the module.\n-    // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, key: BindingKey, f: F) -> T\n-    where\n-        F: FnOnce(&mut Resolver<'a, 'tcx>, &mut NameResolution<'a>) -> T,\n-    {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n-        let (binding, t) = {\n-            let resolution = &mut *self.resolution(module, key).borrow_mut();\n-            let old_binding = resolution.binding();\n-\n-            let t = f(self, resolution);\n-\n-            match resolution.binding() {\n-                _ if old_binding.is_some() => return t,\n-                None => return t,\n-                Some(binding) => match old_binding {\n-                    Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n-                    _ => (binding, t),\n-                },\n-            }\n+        let (binding, t) = match resolution.binding() {\n+            _ if old_binding.is_some() => return t,\n+            None => return t,\n+            Some(binding) => match old_binding {\n+                Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n+                _ => (binding, t),\n+            },\n         };\n \n+        drop(resolution);\n+\n         // Define `binding` in `module`s glob importers.\n         for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n@@ -420,6 +396,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         t\n     }\n \n+    fn ambiguity(\n+        &self,\n+        kind: AmbiguityKind,\n+        primary_binding: &'a NameBinding<'a>,\n+        secondary_binding: &'a NameBinding<'a>,\n+    ) -> &'a NameBinding<'a> {\n+        self.arenas.alloc_name_binding(NameBinding {\n+            ambiguity: Some((secondary_binding, kind)),\n+            ..primary_binding.clone()\n+        })\n+    }\n+\n     // Define a dummy resolution containing a `Res::Err` as a placeholder for a failed\n     // or indeterminate resolution, also mark such failed imports as used to avoid duplicate diagnostics.\n     fn import_dummy_binding(&mut self, import: &'a Import<'a>, is_indeterminate: bool) {\n@@ -769,9 +757,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 .emit();\n                         }\n                         let key = BindingKey::new(target, ns);\n-                        this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&Interned::new_unchecked(import));\n-                        });\n+                        let mut resolution = this.resolution(parent, key).borrow_mut();\n+                        resolution.single_imports.remove(&Interned::new_unchecked(import));\n                     }\n                 }\n             }"}]}