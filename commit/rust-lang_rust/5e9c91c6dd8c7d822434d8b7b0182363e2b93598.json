{"sha": "5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "node_id": "C_kwDOAAsO6NoAKDVlOWM5MWM2ZGQ4YzdkODIyNDM0ZDhiN2IwMTgyMzYzZTJiOTM1OTg", "commit": {"author": {"name": "fee1-dead", "email": "ent3rm4n@gmail.com", "date": "2022-12-28T07:51:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-28T07:51:43Z"}, "message": "Rollup merge of #106205 - compiler-errors:oopsy, r=fee1-dead\n\nRemove some totally duplicated files in `rustc_infer`\n\nI have no idea why or how I duplicated these files from `compiler/rustc_infer/src/infer/error_reporting/note.rs`, but I did by accident, and nothing caught it :facepalm:", "tree": {"sha": "b3e7bbe91cae89563c1ec3c44497808c9e3b8958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3e7bbe91cae89563c1ec3c44497808c9e3b8958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjq/WPCRBK7hj4Ov3rIwAAEKwIAE8JXXgW8W0jk9l/sY3CsnNq\nGJxxtHeA1S5J9CR4nhrGC3NPq3fV6gAjbB9OxkKlYLA07Z7xoPYiAINf4D+XMoJb\nyIh43NaYG9mLTEb0R/FAU3vvc6FfzU+onubGF78l0ssNB84cbnHM/OQe9BU20se6\nnLOtH07BWvUWwfHRwtl5TPB0FoyDP08DSXRa6P1J4VS96aPuEWT5eb3QNNBWwd8Q\n+OU3yK8uJTdEbI/CtJBqPNiOKPXIFp1ZFT+HlsaHVMHQPc1ZdT424qCnSdm141Hv\nJJQfaHpn/WUFqKP/oyc/p+cQhn4oKVOgpBMDvTsz8Jo2ufzlyOhcTaxNuWrBvpA=\n=iDvJ\n-----END PGP SIGNATURE-----\n", "payload": "tree b3e7bbe91cae89563c1ec3c44497808c9e3b8958\nparent f837da736f1d455b86d1e743a7afa63fa156b6a6\nparent 605ad65f6a9f3833f864fe52ede1aeb317431518\nauthor fee1-dead <ent3rm4n@gmail.com> 1672213903 +0800\ncommitter GitHub <noreply@github.com> 1672213903 +0800\n\nRollup merge of #106205 - compiler-errors:oopsy, r=fee1-dead\n\nRemove some totally duplicated files in `rustc_infer`\n\nI have no idea why or how I duplicated these files from `compiler/rustc_infer/src/infer/error_reporting/note.rs`, but I did by accident, and nothing caught it :facepalm:\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "html_url": "https://github.com/rust-lang/rust/commit/5e9c91c6dd8c7d822434d8b7b0182363e2b93598", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9c91c6dd8c7d822434d8b7b0182363e2b93598/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f837da736f1d455b86d1e743a7afa63fa156b6a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f837da736f1d455b86d1e743a7afa63fa156b6a6", "html_url": "https://github.com/rust-lang/rust/commit/f837da736f1d455b86d1e743a7afa63fa156b6a6"}, {"sha": "605ad65f6a9f3833f864fe52ede1aeb317431518", "url": "https://api.github.com/repos/rust-lang/rust/commits/605ad65f6a9f3833f864fe52ede1aeb317431518", "html_url": "https://github.com/rust-lang/rust/commit/605ad65f6a9f3833f864fe52ede1aeb317431518"}], "stats": {"total": 630, "additions": 0, "deletions": 630}, "files": [{"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/f837da736f1d455b86d1e743a7afa63fa156b6a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f837da736f1d455b86d1e743a7afa63fa156b6a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=f837da736f1d455b86d1e743a7afa63fa156b6a6", "patch": "@@ -1,427 +0,0 @@\n-use crate::errors::RegionOriginNote;\n-use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n-use crate::infer::{self, SubregionOrigin};\n-use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n-use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::{self, Region};\n-\n-use super::ObligationCauseAsDiagArg;\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n-                span: trace.cause.span,\n-                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n-                expected_found: self.values_str(trace.values),\n-            }\n-            .add_to_diagnostic(err),\n-            infer::Reborrow(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reborrow,\n-                    name: &var_name.to_string(),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateObjectBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_data_borrowed,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reference_outlives_referent,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_relate_param_bound,\n-                    name: &self.ty_to_string(ty),\n-                    continues: opt_span.is_some(),\n-                }\n-                .add_to_diagnostic(err);\n-                if let Some(span) = opt_span {\n-                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n-                        .add_to_diagnostic(err);\n-                }\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CompareImplItemObligation { span, .. } => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n-                    .add_to_diagnostic(err);\n-            }\n-            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n-                self.note_region_origin(err, &parent);\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                RegionOriginNote::Plain {\n-                    span,\n-                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_concrete_failure(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        match origin {\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                let mut err = self.report_and_explain_type_error(trace, terr);\n-                match (*sub, *sup) {\n-                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n-                    (ty::RePlaceholder(_), _) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"\",\n-                            sup,\n-                            \" doesn't meet the lifetime requirements\",\n-                            None,\n-                        );\n-                    }\n-                    (_, ty::RePlaceholder(_)) => {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"the required lifetime does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                    _ => {\n-                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            &mut err,\n-                            \"...does not necessarily outlive \",\n-                            sub,\n-                            \"\",\n-                            None,\n-                        );\n-                    }\n-                }\n-                err\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n-                    var_name\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    &format!(\"...but `{}` is only valid for \", var_name),\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n-                );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0490,\n-                    \"a value of type `{}` is borrowed for too long\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n-                .report_extra_impl_obligation(\n-                    span,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                    &format!(\"`{}: {}`\", sup, sub),\n-                ),\n-            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n-                let mut err = self.report_concrete_failure(*parent, sub, sup);\n-\n-                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n-                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n-                err.span_label(\n-                    trait_item_span,\n-                    format!(\"definition of `{}` from trait\", item_name),\n-                );\n-\n-                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n-                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n-\n-                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n-                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n-                let clauses: Vec<_> = trait_predicates\n-                    .predicates\n-                    .into_iter()\n-                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n-                    .map(|(pred, _)| format!(\"{}\", pred))\n-                    .collect();\n-\n-                if !clauses.is_empty() {\n-                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n-                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n-\n-                    let suggestion = format!(\n-                        \"{} {}\",\n-                        generics.add_where_or_trailing_comma(),\n-                        clauses.join(\", \"),\n-                    );\n-                    err.span_suggestion(\n-                        where_clause_span,\n-                        &format!(\n-                            \"try copying {} from the trait\",\n-                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n-                        ),\n-                        suggestion,\n-                        rustc_errors::Applicability::MaybeIncorrect,\n-                    );\n-                }\n-\n-                err\n-            }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n-        }\n-    }\n-\n-    pub(super) fn report_placeholder_failure(\n-        &self,\n-        placeholder_origin: SubregionOrigin<'tcx>,\n-        sub: Region<'tcx>,\n-        sup: Region<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        // I can't think how to do better than this right now. -nikomatsakis\n-        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n-        match placeholder_origin {\n-            infer::Subtype(box ref trace)\n-                if matches!(\n-                    &trace.cause.code().peel_derives(),\n-                    ObligationCauseCode::BindingObligation(..)\n-                        | ObligationCauseCode::ExprBindingObligation(..)\n-                ) =>\n-            {\n-                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n-                    &trace.cause.code().peel_derives()\n-                {\n-                    let span = *span;\n-                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n-                    err.span_note(span, \"the lifetime requirement is introduced here\");\n-                    err\n-                } else {\n-                    unreachable!()\n-                }\n-            }\n-            infer::Subtype(box trace) => {\n-                let terr = TypeError::RegionsPlaceholderMismatch;\n-                return self.report_and_explain_type_error(trace, terr);\n-            }\n-            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n-        }\n-    }\n-}"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f837da736f1d455b86d1e743a7afa63fa156b6a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f837da736f1d455b86d1e743a7afa63fa156b6a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=f837da736f1d455b86d1e743a7afa63fa156b6a6", "patch": "@@ -1,203 +0,0 @@\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    fn note_error_origin(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n-        terr: TypeError<'tcx>,\n-    ) {\n-        match *cause.code() {\n-            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n-                let ty = self.resolve_vars_if_possible(root_ty);\n-                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n-                {\n-                    // don't show type `_`\n-                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n-                        && let ty::Adt(def, substs) = ty.kind()\n-                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n-                    {\n-                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n-                    } else {\n-                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n-                }\n-                }\n-                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n-                    && ty.is_box() && ty.boxed_ty() == found\n-                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-                {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider dereferencing the boxed value\",\n-                        format!(\"*{}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n-                err.span_label(span, \"expected due to this\");\n-            }\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_block_id,\n-                arm_span,\n-                arm_ty,\n-                prior_arm_block_id,\n-                prior_arm_span,\n-                prior_arm_ty,\n-                source,\n-                ref prior_arms,\n-                scrut_hir_id,\n-                opt_suggest_box_span,\n-                scrut_span,\n-                ..\n-            }) => match source {\n-                hir::MatchSource::TryDesugar => {\n-                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n-                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n-                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n-                            self.typeck_results.as_ref().and_then(|typeck_results| {\n-                                typeck_results.expr_ty_opt(arg_expr)\n-                            })\n-                        } else {\n-                            bug!(\"try desugaring w/out call expr as scrutinee\");\n-                        };\n-\n-                        match scrut_ty {\n-                            Some(ty) if expected == ty => {\n-                                let source_map = self.tcx.sess.source_map();\n-                                err.span_suggestion(\n-                                    source_map.end_point(cause.span),\n-                                    \"try removing this `?`\",\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n-                    let t = self.resolve_vars_if_possible(match exp_found {\n-                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => prior_arm_ty,\n-                    });\n-                    let source_map = self.tcx.sess.source_map();\n-                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n-                    if prior_arms.len() <= 4 {\n-                        for sp in prior_arms {\n-                            any_multiline_arm |= source_map.is_multiline(*sp);\n-                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n-                        }\n-                    } else if let Some(sp) = prior_arms.last() {\n-                        any_multiline_arm |= source_map.is_multiline(*sp);\n-                        err.span_label(\n-                            *sp,\n-                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n-                        );\n-                    }\n-                    let outer_error_span = if any_multiline_arm {\n-                        // Cover just `match` and the scrutinee expression, not\n-                        // the entire match body, to reduce diagram noise.\n-                        cause.span.shrink_to_lo().to(scrut_span)\n-                    } else {\n-                        cause.span\n-                    };\n-                    let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(outer_error_span, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n-                        prior_arm_block_id,\n-                        prior_arm_ty,\n-                        prior_arm_span,\n-                        arm_block_id,\n-                        arm_ty,\n-                        arm_span,\n-                    );\n-                    if let Some(ret_sp) = opt_suggest_box_span {\n-                        // Get return type span and point to it.\n-                        self.suggest_boxing_for_return_impl_trait(\n-                            err,\n-                            ret_sp,\n-                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n-                        );\n-                    }\n-                }\n-            },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then_id,\n-                else_id,\n-                then_ty,\n-                else_ty,\n-                outer_span,\n-                opt_suggest_box_span,\n-            }) => {\n-                let then_span = self.find_block_span_from_hir_id(then_id);\n-                let else_span = self.find_block_span_from_hir_id(else_id);\n-                err.span_label(then_span, \"expected because of this\");\n-                if let Some(sp) = outer_span {\n-                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n-                }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n-                    Some(then_id),\n-                    then_ty,\n-                    then_span,\n-                    Some(else_id),\n-                    else_ty,\n-                    else_span,\n-                );\n-                if let Some(ret_sp) = opt_suggest_box_span {\n-                    self.suggest_boxing_for_return_impl_trait(\n-                        err,\n-                        ret_sp,\n-                        [then_span, else_span].into_iter(),\n-                    );\n-                }\n-            }\n-            ObligationCauseCode::LetElse => {\n-                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n-                err.help(\"...or use `match` instead of `let...else`\");\n-            }\n-            _ => {\n-                if let ObligationCauseCode::BindingObligation(_, span)\n-                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n-                = cause.code().peel_derives()\n-                    && let TypeError::RegionsPlaceholderMismatch = terr\n-                {\n-                    err.span_note( * span,\n-                    \"the lifetime requirement is introduced here\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> InferCtxt<'tcx> {\n-    /// Given a [`hir::Block`], get the span of its last expression or\n-    /// statement, peeling off any inner blocks.\n-    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n-        let block = block.innermost_block();\n-        if let Some(expr) = &block.expr {\n-            expr.span\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            stmt.span\n-        } else {\n-            // empty block; point at its entirety\n-            block.span\n-        }\n-    }\n-\n-    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n-    /// or statement, peeling off any inner blocks.\n-    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n-        match self.tcx.hir().get(hir_id) {\n-            hir::Node::Block(blk) => self.find_block_span(blk),\n-            // The parser was in a weird state if either of these happen, but\n-            // it's better not to panic.\n-            hir::Node::Expr(e) => e.span,\n-            _ => rustc_span::DUMMY_SP,\n-        }\n-    }\n-}"}]}