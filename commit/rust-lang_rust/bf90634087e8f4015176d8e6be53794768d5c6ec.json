{"sha": "bf90634087e8f4015176d8e6be53794768d5c6ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOTA2MzQwODdlOGY0MDE1MTc2ZDhlNmJlNTM3OTQ3NjhkNWM2ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T15:01:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T15:01:44Z"}, "message": "auto merge of #8604 : kballard/rust/iter-size-hint, r=graydon\n\nImplement `size_hint()` on the new std::vec Iterators.\r\n\r\nAdd or update `size_hint()` on std::iterator Iterators where appropriate.\r\n\r\nr? @thestinger", "tree": {"sha": "e784ce3eb4d9c3f54775eeb41cb16bd2fbc2b6ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e784ce3eb4d9c3f54775eeb41cb16bd2fbc2b6ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf90634087e8f4015176d8e6be53794768d5c6ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf90634087e8f4015176d8e6be53794768d5c6ec", "html_url": "https://github.com/rust-lang/rust/commit/bf90634087e8f4015176d8e6be53794768d5c6ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf90634087e8f4015176d8e6be53794768d5c6ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9765f337a944b6c09d3b1f86fd0288f73f5b0e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9765f337a944b6c09d3b1f86fd0288f73f5b0e2f", "html_url": "https://github.com/rust-lang/rust/commit/9765f337a944b6c09d3b1f86fd0288f73f5b0e2f"}, {"sha": "8741770471d08c78780fd6c22c18c0cf28fcf074", "url": "https://api.github.com/repos/rust-lang/rust/commits/8741770471d08c78780fd6c22c18c0cf28fcf074", "html_url": "https://github.com/rust-lang/rust/commit/8741770471d08c78780fd6c22c18c0cf28fcf074"}], "stats": {"total": 111, "additions": 100, "deletions": 11}, "files": [{"sha": "c2d2e62a3c85fbc139ff5e4426283ea91ab3e7ae", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bf90634087e8f4015176d8e6be53794768d5c6ec/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf90634087e8f4015176d8e6be53794768d5c6ec/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=bf90634087e8f4015176d8e6be53794768d5c6ec", "patch": "@@ -18,7 +18,7 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use num::{Zero, One, Integer, Saturating};\n+use num::{Zero, One, Integer, CheckedAdd, Saturating};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n use cmp::Ord;\n@@ -838,7 +838,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n         let lower = a_lower.saturating_add(b_lower);\n \n         let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(x.saturating_add(y)),\n+            (Some(x), Some(y)) => x.checked_add(&y),\n             _ => None\n         };\n \n@@ -1115,22 +1115,34 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n         if self.peeked.is_some() { self.peeked.take() }\n         else { self.iter.next() }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (lo, hi) = self.iter.size_hint();\n+        if self.peeked.is_some() {\n+            let lo = lo.saturating_add(1);\n+            let hi = match hi {\n+                Some(x) => x.checked_add(&1),\n+                None => None\n+            };\n+            (lo, hi)\n+        } else {\n+            (lo, hi)\n+        }\n+    }\n }\n \n impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n     #[inline]\n     pub fn peek(&'self mut self) -> Option<&'self A> {\n+        if self.peeked.is_none() {\n+            self.peeked = self.iter.next();\n+        }\n         match self.peeked {\n             Some(ref value) => Some(value),\n-            None => {\n-                self.peeked = self.iter.next();\n-                match self.peeked {\n-                    Some(ref value) => Some(value),\n-                    None => None,\n-                }\n-            },\n+            None => None,\n         }\n     }\n }\n@@ -1376,7 +1388,7 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n         let (blo, bhi) = self.backiter.map_default((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, Some(a.saturating_add(b))),\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(&b)),\n             _ => (lo, None)\n         }\n     }\n@@ -1482,6 +1494,12 @@ impl<'self, A, St> Iterator<A> for Unfoldr<'self, A, St> {\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // no possible known bounds at this point\n+        (0, None)\n+    }\n }\n \n /// An infinite iterator starting at `start` and advancing by `step` with each\n@@ -1525,6 +1543,9 @@ impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n             None\n         }\n     }\n+\n+    // FIXME: #8606 Implement size_hint() on Range\n+    // Blocked on #8605 Need numeric trait for converting to `Option<uint>`\n }\n \n impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {"}, {"sha": "01e7e053cf5d62da337c9f4ce39902e6fc688f93", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bf90634087e8f4015176d8e6be53794768d5c6ec/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf90634087e8f4015176d8e6be53794768d5c6ec/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=bf90634087e8f4015176d8e6be53794768d5c6ec", "patch": "@@ -65,7 +65,7 @@ use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use iterator::*;\n use libc::c_void;\n-use num::Zero;\n+use num::{Integer, Zero, CheckedAdd, Saturating};\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -209,6 +209,7 @@ pub struct SplitIterator<'self, T> {\n }\n \n impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n+    #[inline]\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.finished { return None; }\n \n@@ -230,6 +231,21 @@ impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            return (0, Some(0))\n+        }\n+        // if the predicate doesn't match anything, we yield one slice\n+        // if it matches every element, we yield N+1 empty slices where\n+        // N is either the number of elements or the number of splits.\n+        match (self.v.len(), self.n) {\n+            (0,_) => (1, Some(1)),\n+            (_,0) => (1, Some(1)),\n+            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+        }\n+    }\n }\n \n /// An iterator over the slices of a vector separated by elements that\n@@ -242,6 +258,7 @@ pub struct RSplitIterator<'self, T> {\n }\n \n impl<'self, T> Iterator<&'self [T]> for RSplitIterator<'self, T> {\n+    #[inline]\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.finished { return None; }\n \n@@ -263,6 +280,18 @@ impl<'self, T> Iterator<&'self [T]> for RSplitIterator<'self, T> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            return (0, Some(0))\n+        }\n+        match (self.v.len(), self.n) {\n+            (0,_) => (1, Some(1)),\n+            (_,0) => (1, Some(1)),\n+            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+        }\n+    }\n }\n \n // Appending\n@@ -453,6 +482,7 @@ pub struct WindowIter<'self, T> {\n }\n \n impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n+    #[inline]\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.size > self.v.len() {\n             None\n@@ -462,6 +492,16 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n             ret\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let x = self.v.len() - self.size;\n+            (x.saturating_add(1), x.checked_add(&1u))\n+        }\n+    }\n }\n \n /// An iterator over a vector in (non-overlapping) chunks (`size`\n@@ -476,6 +516,7 @@ pub struct ChunkIter<'self, T> {\n }\n \n impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n+    #[inline]\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.v.len() == 0 {\n             None\n@@ -487,9 +528,21 @@ impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = self.v.len().div_rem(&self.size);\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n }\n \n impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n+    #[inline]\n     fn next_back(&mut self) -> Option<&'self [T]> {\n         if self.v.len() == 0 {\n             None\n@@ -2236,6 +2289,7 @@ impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n         exact\n     }\n \n+    #[inline]\n     fn idx(&self, index: uint) -> Option<&'self T> {\n         unsafe {\n             if index < self.indexable() {\n@@ -2281,6 +2335,7 @@ pub struct MoveIterator<T> {\n }\n \n impl<T> Iterator<T> for MoveIterator<T> {\n+    #[inline]\n     fn next(&mut self) -> Option<T> {\n         // this is peculiar, but is required for safety with respect\n         // to dtors. It traverses the first half of the vec, and\n@@ -2298,6 +2353,12 @@ impl<T> Iterator<T> for MoveIterator<T> {\n \n         self.v.pop_opt()\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let l = self.v.len();\n+        (l, Some(l))\n+    }\n }\n \n /// An iterator that moves out of a vector in reverse order.\n@@ -2307,9 +2368,16 @@ pub struct MoveRevIterator<T> {\n }\n \n impl<T> Iterator<T> for MoveRevIterator<T> {\n+    #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.v.pop_opt()\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let l = self.v.len();\n+        (l, Some(l))\n+    }\n }\n \n impl<A> FromIterator<A> for ~[A] {"}]}