{"sha": "946bb4b10b3b758dbebf773a178cf99de1dd023c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NmJiNGIxMGIzYjc1OGRiZWJmNzczYTE3OGNmOTlkZTFkZDAyM2M=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-05-18T20:17:59Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T01:20:35Z"}, "message": "regex_macros: fix fallout from using ptr::P.", "tree": {"sha": "7335fba646ff7d540deb5b77243d09d72e4a9b7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7335fba646ff7d540deb5b77243d09d72e4a9b7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/946bb4b10b3b758dbebf773a178cf99de1dd023c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/946bb4b10b3b758dbebf773a178cf99de1dd023c", "html_url": "https://github.com/rust-lang/rust/commit/946bb4b10b3b758dbebf773a178cf99de1dd023c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/946bb4b10b3b758dbebf773a178cf99de1dd023c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2094514049a6e2485ca4a9468895989a78669a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2094514049a6e2485ca4a9468895989a78669a6b", "html_url": "https://github.com/rust-lang/rust/commit/2094514049a6e2485ca4a9468895989a78669a6b"}], "stats": {"total": 36, "additions": 17, "deletions": 19}, "files": [{"sha": "cd00e459a79988c66ff946c038c059c517772cb7", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/946bb4b10b3b758dbebf773a178cf99de1dd023c/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946bb4b10b3b758dbebf773a178cf99de1dd023c/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=946bb4b10b3b758dbebf773a178cf99de1dd023c", "patch": "@@ -26,7 +26,6 @@ extern crate syntax;\n extern crate rustc;\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n \n use syntax::ast;\n use syntax::codemap;\n@@ -35,6 +34,7 @@ use syntax::ext::base::{ExtCtxt, MacResult, MacExpr, DummyResult};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::fold::Folder;\n+use syntax::ptr::P;\n \n use rustc::plugin::Registry;\n \n@@ -111,7 +111,7 @@ struct NfaGen<'a> {\n }\n \n impl<'a> NfaGen<'a> {\n-    fn code(&mut self) -> Gc<ast::Expr> {\n+    fn code(&mut self) -> P<ast::Expr> {\n         // Most or all of the following things are used in the quasiquoted\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n@@ -332,7 +332,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n     // Generates code for the `add` method, which is responsible for adding\n     // zero-width states to the next queue of states to visit.\n-    fn add_insts(&self) -> Gc<ast::Expr> {\n+    fn add_insts(&self) -> P<ast::Expr> {\n         let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n             let nextpc = pc + 1;\n             let body = match *inst {\n@@ -433,7 +433,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n     // Generates the code for the `step` method, which processes all states\n     // in the current queue that consume a single character.\n-    fn step_insts(&self) -> Gc<ast::Expr> {\n+    fn step_insts(&self) -> P<ast::Expr> {\n         let arms = self.prog.insts.iter().enumerate().map(|(pc, inst)| {\n             let nextpc = pc + 1;\n             let body = match *inst {\n@@ -524,17 +524,15 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Translates a character class into a match expression.\n     // This avoids a binary search (and is hopefully replaced by a jump\n     // table).\n-    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> Gc<ast::Expr> {\n-        let expr_true = quote_expr!(self.cx, true);\n-\n+    fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> P<ast::Expr> {\n         let mut arms = ranges.iter().map(|&(mut start, mut end)| {\n             if casei {\n                 start = start.to_uppercase();\n                 end = end.to_uppercase();\n             }\n             let pat = self.cx.pat(self.sp, ast::PatRange(quote_expr!(self.cx, $start),\n                                                          quote_expr!(self.cx, $end)));\n-            self.cx.arm(self.sp, vec!(pat), expr_true)\n+            self.cx.arm(self.sp, vec!(pat), quote_expr!(self.cx, true))\n         }).collect::<Vec<ast::Arm>>();\n \n         arms.push(self.wild_arm_expr(quote_expr!(self.cx, false)));\n@@ -546,7 +544,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Generates code for checking a literal prefix of the search string.\n     // The code is only generated if the regex *has* a literal prefix.\n     // Otherwise, a no-op is returned.\n-    fn check_prefix(&self) -> Gc<ast::Expr> {\n+    fn check_prefix(&self) -> P<ast::Expr> {\n         if self.prog.prefix.len() == 0 {\n             self.empty_block()\n         } else {\n@@ -570,32 +568,32 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // A wild-card arm is automatically added that executes a no-op. It will\n     // never be used, but is added to satisfy the compiler complaining about\n     // non-exhaustive patterns.\n-    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> Gc<ast::Expr> {\n+    fn match_insts(&self, mut arms: Vec<ast::Arm>) -> P<ast::Expr> {\n         arms.push(self.wild_arm_expr(self.empty_block()));\n         self.cx.expr_match(self.sp, quote_expr!(self.cx, pc), arms)\n     }\n \n-    fn empty_block(&self) -> Gc<ast::Expr> {\n+    fn empty_block(&self) -> P<ast::Expr> {\n         quote_expr!(self.cx, {})\n     }\n \n     // Creates a match arm for the instruction at `pc` with the expression\n     // `body`.\n-    fn arm_inst(&self, pc: uint, body: Gc<ast::Expr>) -> ast::Arm {\n+    fn arm_inst(&self, pc: uint, body: P<ast::Expr>) -> ast::Arm {\n         let pc_pat = self.cx.pat_lit(self.sp, quote_expr!(self.cx, $pc));\n \n         self.cx.arm(self.sp, vec!(pc_pat), body)\n     }\n \n     // Creates a wild-card match arm with the expression `body`.\n-    fn wild_arm_expr(&self, body: Gc<ast::Expr>) -> ast::Arm {\n+    fn wild_arm_expr(&self, body: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec!(),\n-            pats: vec!(box(GC) ast::Pat{\n+            pats: vec!(P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.sp,\n                 node: ast::PatWild(ast::PatWildSingle),\n-            }),\n+            })),\n             guard: None,\n             body: body,\n         }\n@@ -605,8 +603,8 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n     fn vec_expr<T, It: Iterator<T>>(&self, xs: It,\n-                                    to_expr: |&ExtCtxt, T| -> Gc<ast::Expr>)\n-                  -> Gc<ast::Expr> {\n+                                    to_expr: |&ExtCtxt, T| -> P<ast::Expr>)\n+                  -> P<ast::Expr> {\n         let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n         self.cx.expr_vec(self.sp, exprs)\n     }\n@@ -618,13 +616,13 @@ fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n     let mut parser = cx.new_parser_from_tts(tts);\n     let entry = cx.expander().fold_expr(parser.parse_expr());\n     let regex = match entry.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => s.to_string(),\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\",\n-                        pprust::lit_to_string(&*lit)).as_slice());\n+                        pprust::lit_to_string(&**lit)).as_slice());\n                     return None\n                 }\n             }"}]}