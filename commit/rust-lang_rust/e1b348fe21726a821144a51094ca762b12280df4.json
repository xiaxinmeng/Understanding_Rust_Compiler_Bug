{"sha": "e1b348fe21726a821144a51094ca762b12280df4", "node_id": "C_kwDOAAsO6NoAKGUxYjM0OGZlMjE3MjZhODIxMTQ0YTUxMDk0Y2E3NjJiMTIyODBkZjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T22:34:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T22:34:50Z"}, "message": "Auto merge of #99133 - matthiaskrgr:rollup-eignphd, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #98713 (promote placeholder bounds to 'static obligations)\n - #99094 (Remove extra space in AtomicPtr::new docs)\n - #99095 (Remove duplicate notes from error on inter-crate ambiguous impl of traits)\n - #99114 (Group .test-arrow CSS rules and fix rgb/rgba property)\n - #99128 (Fix `download-ci-llvm` NixOS patching for binaries)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e193bba697a616e77cd660660254c83e3ab7b1b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e193bba697a616e77cd660660254c83e3ab7b1b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b348fe21726a821144a51094ca762b12280df4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b348fe21726a821144a51094ca762b12280df4", "html_url": "https://github.com/rust-lang/rust/commit/e1b348fe21726a821144a51094ca762b12280df4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b348fe21726a821144a51094ca762b12280df4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c396bb3b8a16b1f2762b7c6078dc3e023f6a2493", "url": "https://api.github.com/repos/rust-lang/rust/commits/c396bb3b8a16b1f2762b7c6078dc3e023f6a2493", "html_url": "https://github.com/rust-lang/rust/commit/c396bb3b8a16b1f2762b7c6078dc3e023f6a2493"}, {"sha": "7cd617490de8e4443b854bd32624bd40e0e2eed0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd617490de8e4443b854bd32624bd40e0e2eed0", "html_url": "https://github.com/rust-lang/rust/commit/7cd617490de8e4443b854bd32624bd40e0e2eed0"}], "stats": {"total": 165, "additions": 136, "deletions": 29}, "files": [{"sha": "0cf04b369de5f4a11f2a8bce1c2d215701c5e65b", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -917,6 +917,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// The idea then is to lower the `T: 'X` constraint into multiple\n     /// bounds -- e.g., if `'X` is the union of two free lifetimes,\n     /// `'1` and `'2`, then we would create `T: '1` and `T: '2`.\n+    #[instrument(level = \"debug\", skip(self, infcx, propagated_outlives_requirements))]\n     fn try_promote_type_test(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -934,11 +935,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return false;\n         };\n \n+        debug!(\"subject = {:?}\", subject);\n+\n+        let r_scc = self.constraint_sccs.scc(*lower_bound);\n+\n+        debug!(\n+            \"lower_bound = {:?} r_scc={:?} universe={:?}\",\n+            lower_bound, r_scc, self.scc_universes[r_scc]\n+        );\n+\n+        // If the type test requires that `T: 'a` where `'a` is a\n+        // placeholder from another universe, that effectively requires\n+        // `T: 'static`, so we have to propagate that requirement.\n+        //\n+        // It doesn't matter *what* universe because the promoted `T` will\n+        // always be in the root universe.\n+        if let Some(p) = self.scc_values.placeholders_contained_in(r_scc).next() {\n+            debug!(\"encountered placeholder in higher universe: {:?}, requiring 'static\", p);\n+            let static_r = self.universal_regions.fr_static;\n+            propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                subject,\n+                outlived_free_region: static_r,\n+                blame_span: locations.span(body),\n+                category: ConstraintCategory::Boring,\n+            });\n+\n+            // we can return here -- the code below might push add'l constraints\n+            // but they would all be weaker than this one.\n+            return true;\n+        }\n+\n         // For each region outlived by lower_bound find a non-local,\n         // universal region (it may be the same region) and add it to\n         // `ClosureOutlivesRequirement`.\n-        let r_scc = self.constraint_sccs.scc(*lower_bound);\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n+            debug!(\"universal_region_outlived_by ur={:?}\", ur);\n             // Check whether we can already prove that the \"subject\" outlives `ur`.\n             // If so, we don't have to propagate this requirement to our caller.\n             //\n@@ -963,8 +994,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 continue;\n             }\n \n-            debug!(\"try_promote_type_test: ur={:?}\", ur);\n-\n             let non_local_ub = self.universal_region_relations.non_local_upper_bounds(ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n@@ -1001,15 +1030,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// will use it's *external name*, which will be a `RegionKind`\n     /// variant that can be used in query responses such as\n     /// `ReEarlyBound`.\n+    #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n \n-        debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n-\n         let ty = tcx.fold_regions(ty, |r, _depth| {\n             let region_vid = self.to_region_vid(r);\n "}, {"sha": "52ca23c4b303ebd906a9b10eaf33fcabb7a64f48", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -13,7 +13,7 @@ use crate::traits::{\n     self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n     PredicateObligations, SelectionContext,\n };\n-//use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -44,7 +44,7 @@ pub enum Conflict {\n \n pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n-    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+    pub intercrate_ambiguity_causes: FxIndexSet<IntercrateAmbiguityCause>,\n \n     /// `true` if the overlap might've been permitted before the shift\n     /// to universes."}, {"sha": "96d83deeeb7ab885e57d717a4d7d47add0c24303", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -110,7 +110,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n                         };\n                         debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n                     }\n                 }\n             }"}, {"sha": "2bb53a466caa462bfdef02a96442bf18fe9babb3", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -24,7 +24,7 @@ use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -52,7 +52,7 @@ pub use rustc_middle::traits::select::*;\n mod candidate_assembly;\n mod confirmation;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum IntercrateAmbiguityCause {\n     DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n     UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n@@ -128,7 +128,7 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// We don't do his until we detect a coherence error because it can\n     /// lead to false overflow results (#47139) and because always\n     /// computing it may negatively impact performance.\n-    intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n+    intercrate_ambiguity_causes: Option<FxIndexSet<IntercrateAmbiguityCause>>,\n \n     /// The mode that trait queries run in, which informs our error handling\n     /// policy. In essence, canonicalized queries need their errors propagated\n@@ -254,14 +254,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n         assert!(self.intercrate);\n         assert!(self.intercrate_ambiguity_causes.is_none());\n-        self.intercrate_ambiguity_causes = Some(vec![]);\n+        self.intercrate_ambiguity_causes = Some(FxIndexSet::default());\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n     }\n \n     /// Gets the intercrate ambiguity causes collected since tracking\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n-    pub fn take_intercrate_ambiguity_causes(&mut self) -> Vec<IntercrateAmbiguityCause> {\n+    pub fn take_intercrate_ambiguity_causes(&mut self) -> FxIndexSet<IntercrateAmbiguityCause> {\n         assert!(self.intercrate);\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n@@ -960,7 +960,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             });\n \n                             debug!(?cause, \"evaluate_stack: pushing cause\");\n-                            self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                            self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n                         }\n                     }\n                 }\n@@ -1252,7 +1252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  reservation impl ambiguity on {:?}\",\n                             def_id\n                         );\n-                        intercrate_ambiguity_clauses.push(\n+                        intercrate_ambiguity_clauses.insert(\n                             IntercrateAmbiguityCause::ReservationImpl {\n                                 message: value.to_string(),\n                             },"}, {"sha": "2c4a453aefc3404d50e3de3fb58d1b2a219465c0", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -15,7 +15,7 @@ use specialization_graph::GraphExt;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, EmissionGuarantee, LintDiagnosticBuilder};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n@@ -33,7 +33,7 @@ pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n     pub self_desc: Option<String>,\n-    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+    pub intercrate_ambiguity_causes: FxIndexSet<IntercrateAmbiguityCause>,\n     pub involves_placeholder: bool,\n }\n "}, {"sha": "ebc769ac7ca3bd2ced76361382800e3c87e9320d", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -991,7 +991,7 @@ impl<T> AtomicPtr<T> {\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n     /// let ptr = &mut 5;\n-    /// let atomic_ptr  = AtomicPtr::new(ptr);\n+    /// let atomic_ptr = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "8254f01ce874d3f37c192aeb19e3bc078c49851e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -147,8 +147,8 @@ pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n     let key = format!(\"{}{}\", llvm_sha, config.llvm_assertions);\n     if program_out_of_date(&llvm_stamp, &key) && !config.dry_run {\n         download_ci_llvm(builder, &llvm_sha);\n-        for binary in [\"llvm-config\", \"FileCheck\"] {\n-            builder.fix_bin_or_dylib(&llvm_root.join(\"bin\").join(binary));\n+        for entry in t!(fs::read_dir(llvm_root.join(\"bin\"))) {\n+            builder.fix_bin_or_dylib(&t!(entry).path());\n         }\n \n         // Update the timestamp of llvm-config to force rustc_llvm to be"}, {"sha": "184d0e77a90b8f0dad40579b30ff2fe468fe5c63", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -178,9 +178,6 @@ a {\n \tcolor: #D2991D;\n }\n \n-a.test-arrow {\n-\tcolor: #dedede;\n-}\n body.source .example-wrap pre.rust a {\n \tbackground: #333;\n }\n@@ -255,6 +252,7 @@ pre.rust .question-mark {\n }\n \n a.test-arrow {\n+\tcolor: #dedede;\n \tbackground-color: rgba(78, 139, 202, 0.2);\n }\n "}, {"sha": "c6ba13fe1d6fbc03e3d3b26467952080581feb82", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -175,9 +175,6 @@ a {\n \tcolor: #3873AD;\n }\n \n-a.test-arrow {\n-\tcolor: #f5f5f5;\n-}\n body.source .example-wrap pre.rust a {\n \tbackground: #eee;\n }\n@@ -239,7 +236,8 @@ pre.rust .question-mark {\n }\n \n a.test-arrow {\n-\tbackground-color: rgb(78, 139, 202, 0.2);\n+\tcolor: #f5f5f5;\n+\tbackground-color: rgba(78, 139, 202, 0.2);\n }\n \n a.test-arrow:hover{"}, {"sha": "b1ee0795b2eb3b7293fd8f79b21f72b81746a6e4", "filename": "src/test/ui/coherence/coherence-projection-conflict-orphan.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -8,7 +8,6 @@ LL | impl<A:Iterator> Foo<A::Item> for A { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`\n    |\n    = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n-   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "5b11c78ab2605667137e459cdd0dd7f61cf061f0", "filename": "src/test/ui/coherence/inter-crate-ambiguity-causes-notes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -0,0 +1,19 @@\n+struct S;\n+\n+impl From<()> for S {\n+    fn from(x: ()) -> Self {\n+        S\n+    }\n+}\n+\n+impl<I> From<I> for S\n+//~^ ERROR conflicting implementations of trait\n+where\n+    I: Iterator<Item = ()>,\n+{\n+    fn from(x: I) -> Self {\n+        S\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "038a0199a8f270105716725913c4e6142ba50926", "filename": "src/test/ui/coherence/inter-crate-ambiguity-causes-notes.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Finter-crate-ambiguity-causes-notes.stderr?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -0,0 +1,14 @@\n+error[E0119]: conflicting implementations of trait `std::convert::From<()>` for type `S`\n+  --> $DIR/inter-crate-ambiguity-causes-notes.rs:9:1\n+   |\n+LL | impl From<()> for S {\n+   | ------------------- first implementation here\n+...\n+LL | impl<I> From<I> for S\n+   | ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `S`\n+   |\n+   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `()` in future versions\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "40eef11f058e15cd04a9c0b03b77372afad9f7d1", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -22,6 +22,7 @@ fn foo<T>() {\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` may not live long enough\n     //\n     // FIXME: This error is bogus, but it arises because we try to validate\n     // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving"}, {"sha": "b789b3a42f3302032a0e7c46cbb06d2d9c76899b", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -34,6 +34,17 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |                                                          ^^^^^^^^^\n \n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'static>() {\n+   |         +++++++++\n+\n error: `T` does not live long enough\n   --> $DIR/issue-91139.rs:16:58\n    |\n@@ -46,5 +57,6 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |                                                          ^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "18e6ec630464657410329fb09e01c3d48387fcc7", "filename": "src/test/ui/nll/issue-98693.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #98693.\n+//\n+// The closure encounters an obligation that `T` must outlive `!U1`,\n+// a placeholder from universe U1. We were ignoring this placeholder\n+// when promoting the constraint to the enclosing function, and\n+// thus incorrectly judging the closure to be safe.\n+\n+fn assert_static<T>()\n+where\n+    for<'a> T: 'a,\n+{\n+}\n+\n+fn test<T>() {\n+    || {\n+        //~^ ERROR the parameter type `T` may not live long enough\n+        assert_static::<T>();\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "31689620c6414e781c5bdd5c1b038b5645a96302", "filename": "src/test/ui/nll/issue-98693.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b348fe21726a821144a51094ca762b12280df4/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr?ref=e1b348fe21726a821144a51094ca762b12280df4", "patch": "@@ -0,0 +1,17 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-98693.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         assert_static::<T>();\n+LL | |     };\n+   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test<T: 'static>() {\n+   |          +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}]}