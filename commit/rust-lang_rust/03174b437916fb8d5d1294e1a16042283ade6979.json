{"sha": "03174b437916fb8d5d1294e1a16042283ade6979", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTc0YjQzNzkxNmZiOGQ1ZDEyOTRlMWExNjA0MjI4M2FkZTY5Nzk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-16T19:38:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-16T19:41:53Z"}, "message": "rustc: Implement unique pointer allocation and deallocation", "tree": {"sha": "ce1e6bd660d13484c30d8608d1a976408f01a2e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce1e6bd660d13484c30d8608d1a976408f01a2e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03174b437916fb8d5d1294e1a16042283ade6979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03174b437916fb8d5d1294e1a16042283ade6979", "html_url": "https://github.com/rust-lang/rust/commit/03174b437916fb8d5d1294e1a16042283ade6979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03174b437916fb8d5d1294e1a16042283ade6979/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27169387fe615269fa79d0d904d96be0226d628a", "url": "https://api.github.com/repos/rust-lang/rust/commits/27169387fe615269fa79d0d904d96be0226d628a", "html_url": "https://github.com/rust-lang/rust/commit/27169387fe615269fa79d0d904d96be0226d628a"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "e73d91ab203904baac6623453a0ffb2632435008", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/03174b437916fb8d5d1294e1a16042283ade6979/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03174b437916fb8d5d1294e1a16042283ade6979/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=03174b437916fb8d5d1294e1a16042283ade6979", "patch": "@@ -1420,7 +1420,7 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n             maybe_free_ivec_heap_part(rslt.bcx, v1, tm.ty)\n           }\n           ty::ty_box(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_uniq(_) { fail \"drop uniq unimplemented\"; }\n+          ty::ty_uniq(_) { trans_shared_free(cx, cx.build.Load(v0)) }\n           ty::ty_obj(_) {\n             let box_cell =\n                 cx.build.GEP(v0, ~[C_int(0), C_int(abi::obj_field_box)]);\n@@ -2311,6 +2311,7 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n // FIXME: We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n // doesn't need to be dropped.\n+// FIXME: This can return only a block_ctxt, not a result.\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: &lval_result, t: &ty::t) -> result {\n     let src_val = src.res.val;\n@@ -2322,18 +2323,18 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     } else if (ty::type_is_nil(bcx_tcx(cx), t) ||\n                    ty::type_is_bot(bcx_tcx(cx), t)) {\n         ret rslt(cx, C_nil());\n-    } else if (ty::type_is_boxed(bcx_tcx(cx), t)) {\n+    } else if (ty::type_is_unique(bcx_tcx(cx), t) ||\n+               ty::type_is_boxed(bcx_tcx(cx), t)) {\n         if src.is_mem { src_val = cx.build.Load(src_val); }\n         if action == DROP_EXISTING {\n             cx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n         }\n         cx.build.Store(src_val, dst);\n-        if src.is_mem {\n-            ret zero_alloca(cx, src.res.val, t);\n-        } else { // It must be a temporary\n-            revoke_clean(cx, src_val);\n-            ret rslt(cx, C_nil());\n-        }\n+        if src.is_mem { ret zero_alloca(cx, src.res.val, t); }\n+\n+        // If we're here, it must be a temporary.\n+        revoke_clean(cx, src_val);\n+        ret rslt(cx, C_nil());\n     } else if (ty::type_is_structural(bcx_tcx(cx), t) ||\n                    ty::type_has_dynamic_size(bcx_tcx(cx), t)) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t).bcx; }\n@@ -2356,7 +2357,8 @@ fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     if src.is_mem {\n         ret copy_val(cx, action, dst, load_if_immediate(cx, src.res.val, t),\n                      t);\n-    } else { ret move_val(cx, action, dst, src, t); }\n+    }\n+    ret move_val(cx, action, dst, src, t);\n }\n \n fn trans_lit_istr(cx: &@block_ctxt, s: str) -> result {\n@@ -4092,6 +4094,7 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n             };\n         ret lval_mem(sub.bcx, val);\n       }\n+      ast::expr_uniq(contents) { ret trans_uniq(cx, contents); }\n       ast::expr_self_method(ident) {\n         alt { cx.fcx.llself } {\n           some(pair) {\n@@ -5346,6 +5349,25 @@ fn trans_put(cx: &@block_ctxt, e: &option::t[@ast::expr]) -> result {\n     ret rslt(bcx, C_nil());\n }\n \n+fn trans_uniq(cx: &@block_ctxt, contents: &@ast::expr) -> lval_result {\n+    let bcx = cx;\n+\n+    let contents_ty = ty::expr_ty(bcx_tcx(bcx), contents);\n+    let r = size_of(bcx, contents_ty);\n+    bcx = r.bcx;\n+    let llsz = r.val;\n+\n+    let llptrty = T_ptr(type_of_or_i8(bcx, contents_ty));\n+\n+    r = trans_shared_malloc(bcx, llptrty, llsz);\n+    bcx = r.bcx;\n+    let llptrptr = r.val;\n+\n+    let llptr = bcx.build.Load(llptrptr);\n+    r = trans_expr_out(bcx, contents, save_in(llptr));\n+    ret lval_val(r.bcx, llptrptr);\n+}\n+\n fn trans_break_cont(sp: &span, cx: &@block_ctxt, to_end: bool) -> result {\n     let bcx = cx;\n     // Locate closest loop block, outputting cleanup as we go."}, {"sha": "d43333f8a1901edaa25cf211312431c33596a201", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03174b437916fb8d5d1294e1a16042283ade6979/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03174b437916fb8d5d1294e1a16042283ade6979/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=03174b437916fb8d5d1294e1a16042283ade6979", "patch": "@@ -175,6 +175,7 @@ export type_is_structural;\n export type_is_copyable;\n export type_is_tup_like;\n export type_is_str;\n+export type_is_unique;\n export type_owns_heap_mem;\n export type_autoderef;\n export type_param;\n@@ -934,6 +935,10 @@ fn type_is_boxed(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n+fn type_is_unique(cx: &ctxt, ty: &t) -> bool {\n+    alt struct(cx, ty) { ty_uniq(_) { ret true; } _ { ret false; } }\n+}\n+\n fn type_is_scalar(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_nil. { ret true; }"}]}