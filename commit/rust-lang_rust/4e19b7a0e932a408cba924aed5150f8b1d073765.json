{"sha": "4e19b7a0e932a408cba924aed5150f8b1d073765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMTliN2EwZTkzMmE0MDhjYmE5MjRhZWQ1MTUwZjhiMWQwNzM3NjU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-26T21:26:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-26T21:26:42Z"}, "message": "Rollup merge of #59330 - DevQps:improve-std-convert-documentation, r=steveklabnik\n\nImprove the documentation for std::convert (From, Into, AsRef and AsMut)\n\n# Description\nIn this PR I updated the documentation of From, Into, AsRef and AsMut, as well as the general std::convert module documentation. The discussion in #59163 provided information that was not yet present in the docs, or was not expressed clearly enough. I tried to clarify the examples that were already present in the docs as well as add more information about considered best-practices that came out of the discussion in #59163\n\n@steveklabnik I hope I didn't change too much. This is an initial version! I will scan through everything tomorrow as well again to see if I made any typo's or errors, and maybe make some small changes here and there.\n\nAll suggestions are welcome!\n\ncloses #59163", "tree": {"sha": "5b737db338bea17d00f517ff480465f93838dee4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b737db338bea17d00f517ff480465f93838dee4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e19b7a0e932a408cba924aed5150f8b1d073765", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmpkSCRBK7hj4Ov3rIwAAdHIIAKO42Bqe3VCa++kKGyuUeZdg\nZ2fweWRPHuQnStRHZ90B0lVqfJA6TLUgMvTgTHsDkl4ZXUagUm4Wu4tqN9U1ekXP\nEck8mZsz313sO1BTgAy9dPVmbyyFnJlIzfeRAUy68A/Zzo/gEVfZ3m/4+0Onokj3\n/9V56c7zWXBvgTkeicu8X0vn66ibHeuwsVL07d6S50xSgTiQecXztu3fsKjRiLdR\nY8hH38BbpG0P7DN7v1nv0LUnzuot8luJEUvCC/RoLPTZYNIcLATLNPG+c12oeg2n\nPV8Rq/JzYM2M+KEUYYT8hnGZdA5QUqB9poyjnK+MQrXVOLapRylv4KUCZrMGSRE=\n=oew+\n-----END PGP SIGNATURE-----\n", "payload": "tree 5b737db338bea17d00f517ff480465f93838dee4\nparent 3747868889f0f40f6fed9a5de0816a12a1fb3605\nparent 6c479c3d02e134dbc8812582c3241fa8747c35d7\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1553635602 +0100\ncommitter GitHub <noreply@github.com> 1553635602 +0100\n\nRollup merge of #59330 - DevQps:improve-std-convert-documentation, r=steveklabnik\n\nImprove the documentation for std::convert (From, Into, AsRef and AsMut)\n\n# Description\nIn this PR I updated the documentation of From, Into, AsRef and AsMut, as well as the general std::convert module documentation. The discussion in #59163 provided information that was not yet present in the docs, or was not expressed clearly enough. I tried to clarify the examples that were already present in the docs as well as add more information about considered best-practices that came out of the discussion in #59163\n\n@steveklabnik I hope I didn't change too much. This is an initial version! I will scan through everything tomorrow as well again to see if I made any typo's or errors, and maybe make some small changes here and there.\n\nAll suggestions are welcome!\n\ncloses #59163\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e19b7a0e932a408cba924aed5150f8b1d073765", "html_url": "https://github.com/rust-lang/rust/commit/4e19b7a0e932a408cba924aed5150f8b1d073765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e19b7a0e932a408cba924aed5150f8b1d073765/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3747868889f0f40f6fed9a5de0816a12a1fb3605", "url": "https://api.github.com/repos/rust-lang/rust/commits/3747868889f0f40f6fed9a5de0816a12a1fb3605", "html_url": "https://github.com/rust-lang/rust/commit/3747868889f0f40f6fed9a5de0816a12a1fb3605"}, {"sha": "6c479c3d02e134dbc8812582c3241fa8747c35d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c479c3d02e134dbc8812582c3241fa8747c35d7", "html_url": "https://github.com/rust-lang/rust/commit/6c479c3d02e134dbc8812582c3241fa8747c35d7"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "cee4fc6f49a713cdfb8ae38350154d5628e226eb", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 89, "deletions": 78, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4e19b7a0e932a408cba924aed5150f8b1d073765/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e19b7a0e932a408cba924aed5150f8b1d073765/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=4e19b7a0e932a408cba924aed5150f8b1d073765", "patch": "@@ -1,26 +1,25 @@\n //! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about conversions\n-//! from one type to another. They follow the standard Rust conventions of\n-//! `as`/`into`/`from`.\n+//! The traits in this module provide a way to convert from one type to another type.\n+//! Each trait serves a different purpose:\n //!\n-//! Like many traits, these are often used as bounds for generic functions, to\n-//! support arguments of multiple types.\n+//! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n+//! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n+//! - Implement the [`From`] trait for consuming value-to-value conversions\n+//! - Implement the [`Into`] trait for consuming value-to-value conversions to types\n+//!   outside the current crate\n+//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`],\n+//!   but should be implemented when the conversion can fail.\n //!\n-//! - Implement the `As*` traits for reference-to-reference conversions\n-//! - Implement the [`Into`] trait when you want to consume the value in the conversion\n-//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n-//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n-//!   conversion to fail\n+//! The traits in this module are often used as trait bounds for generic functions such that to\n+//! arguments of multiple types are supported. See the documentation of each trait for examples.\n //!\n-//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n+//! As a library author, you should always prefer implementing [`From<T>`][`From`] or\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n //! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n-//! blanket implementation in the standard library.  However, there are some cases\n-//! where this is not possible, such as creating conversions into a type defined\n-//! outside your library, so implementing [`Into`] instead of [`From`] is\n-//! sometimes necessary.\n+//! blanket implementation in the standard library. Only implement [`Into`] or [`TryInto`]\n+//! when a conversion to a type outside the current crate is required.\n //!\n //! # Generic Implementations\n //!\n@@ -99,28 +98,22 @@ use fmt;\n #[inline]\n pub const fn identity<T>(x: T) -> T { x }\n \n-/// A cheap reference-to-reference conversion. Used to convert a value to a\n-/// reference value within generic code.\n+/// Used to do a cheap reference-to-reference conversion.\n ///\n-/// `AsRef` is very similar to, but serves a slightly different purpose than,\n-/// [`Borrow`].\n+/// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n+/// If you need to do a costly conversion it is better to implement [`From`] with type\n+/// `&T` or write a custom function.\n ///\n-/// `AsRef` is to be used when wishing to convert to a reference of another\n-/// type.\n-/// `Borrow` is more related to the notion of taking the reference. It is\n-/// useful when wishing to abstract over the type of reference\n-/// (`&T`, `&mut T`) or allow both the referenced and owned type to be treated\n-/// in the same manner.\n ///\n-/// The key difference between the two traits is the intention:\n+/// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n ///\n /// - Use `AsRef` when the goal is to simply convert into a reference\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n ///\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -134,7 +127,12 @@ pub const fn identity<T>(x: T) -> T { x }\n ///\n /// # Examples\n ///\n-/// Both [`String`] and `&str` implement `AsRef<str>`:\n+/// By using trait bounds we can accept arguments of different types as long as they can be\n+/// converted a the specified type `T`.\n+///\n+/// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n+/// want to accept all references that can be converted to &str as an argument.\n+/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n ///\n /// [`String`]: ../../std/string/struct.String.html\n ///\n@@ -157,12 +155,13 @@ pub trait AsRef<T: ?Sized> {\n     fn as_ref(&self) -> &T;\n }\n \n-/// A cheap, mutable reference-to-mutable reference conversion.\n+/// Used to do a cheap mutable-to-mutable reference conversion.\n ///\n-/// This trait is similar to `AsRef` but used for converting between mutable\n-/// references.\n+/// This trait is similar to [`AsRef`] but used for converting between mutable\n+/// references. If you need to do a costly conversion it is better to\n+/// implement [`From`] with type `&mut T` or write a custom function.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a\n+/// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n@@ -176,10 +175,11 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Examples\n ///\n-/// [`Box<T>`] implements `AsMut<T>`:\n-///\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-///\n+/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n+/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n+/// write a function `add_one`that takes all arguments that can be converted to `&mut u64`.\n+/// Because [`Box<T>`] implements `AsMut<T>` `add_one` accepts arguments of type\n+/// `&mut Box<u64>` as well:\n /// ```\n /// fn add_one<T: AsMut<u64>>(num: &mut T) {\n ///     *num.as_mut() += 1;\n@@ -189,7 +189,7 @@ pub trait AsRef<T: ?Sized> {\n /// add_one(&mut boxed_num);\n /// assert_eq!(*boxed_num, 1);\n /// ```\n-///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n@@ -198,29 +198,27 @@ pub trait AsMut<T: ?Sized> {\n     fn as_mut(&mut self) -> &mut T;\n }\n \n-/// A conversion that consumes `self`, which may or may not be expensive. The\n-/// reciprocal of [`From`][From].\n+/// A value-to-value conversion that consumes the input value. The\n+/// opposite of [`From`].\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryInto`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n+/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n+/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n+/// the blanket implementation in the standard library. [`From`] cannot do these type of\n+/// conversions because of Rust's orphaning rules.\n ///\n-/// Library authors should not directly implement this trait, but should prefer\n-/// implementing the [`From`][From] trait, which offers greater flexibility and\n-/// provides an equivalent `Into` implementation for free, thanks to a blanket\n-/// implementation in the standard library.\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n ///\n /// # Generic Implementations\n ///\n-/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n-/// - [`into`] is reflexive, which means that `Into<T> for T` is implemented\n+/// - [`From<T>`]` for U` implies `Into<U> for T`\n+/// - [`Into`]` is reflexive, which means that `Into<T> for T` is implemented\n ///\n-/// # Implementing `Into`\n+/// # Implementing `Into` for conversions to external types\n ///\n-/// There is one exception to implementing `Into`, and it's kind of esoteric.\n-/// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly. For example,\n-/// take this crate:\n+/// If the destination type is not part of the current crate\n+/// then you can't implement [`From`] directly.\n+/// For example, take this code:\n ///\n /// ```compile_fail\n /// struct Wrapper<T>(Vec<T>);\n@@ -230,8 +228,9 @@ pub trait AsMut<T: ?Sized> {\n ///     }\n /// }\n /// ```\n-///\n-/// To fix this, you can implement `Into` directly:\n+/// This will fail to compile because we cannot implement a trait for a type\n+/// if both the trait and the type are not defined by the current crate.\n+/// This is due to Rust's orphaning rules. To bypass this, you can implement `Into` directly:\n ///\n /// ```\n /// struct Wrapper<T>(Vec<T>);\n@@ -242,17 +241,22 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// This won't always allow the conversion: for example, `try!` and `?`\n-/// always use `From`. However, in most cases, people use `Into` to do the\n-/// conversions, and this will allow that.\n+/// It is important to understand that `Into` does not provide a [`From`] implementation\n+/// (as [`From`] does with `Into`). Therefore, you should always try to implement [`From`]\n+/// and then fall back to `Into` if [`From`] can't be implemented.\n ///\n-/// In almost all cases, you should try to implement `From`, then fall back\n-/// to `Into` if `From` can't be implemented.\n+/// Prefer using `Into` over [`From`] when specifying trait bounds on a generic function\n+/// to ensure that types that only implement `Into` can be used as well.\n ///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n ///\n+/// In order to express that we want a generic function to take all arguments that can be\n+/// converted to a specified type `T`, we can use a trait bound of `Into<T>`.\n+/// For example: The function `is_hello` takes all arguments that can be converted into a\n+/// `Vec<u8>`.\n+///\n /// ```\n /// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n ///    let bytes = b\"hello\".to_vec();\n@@ -276,44 +280,51 @@ pub trait Into<T>: Sized {\n     fn into(self) -> T;\n }\n \n-/// Simple and safe type conversions in to `Self`. It is the reciprocal of\n-/// `Into`.\n+/// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n+/// [`Into`].\n ///\n-/// This trait is useful when performing error handling as described by\n-/// [the book][book] and is closely related to the `?` operator.\n+/// One should always prefer implementing [`From`] over [`Into`]\n+/// because implementing [`From`] automatically provides one with a implementation of [`Into`]\n+/// thanks to the blanket implementation in the standard library.\n ///\n-/// When constructing a function that is capable of failing the return type\n-/// will generally be of the form `Result<T, E>`.\n+/// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n+/// [`From`] cannot do these type of conversions because of Rust's orphaning rules.\n+/// See [`Into`] for more details.\n ///\n-/// The `From` trait allows for simplification of error handling by providing a\n-/// means of returning a single error type that encapsulates numerous possible\n-/// erroneous situations.\n+/// Prefer using [`Into`] over using [`From`] when specifying trait bounds on a generic function.\n+/// This way, types that directly implement [`Into`] can be used as arguments as well.\n ///\n-/// This trait is not limited to error handling, rather the general case for\n-/// this trait would be in any type conversions to have an explicit definition\n-/// of how they are performed.\n+/// The [`From`] is also very useful when performing error handling. When constructing a function\n+/// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n+/// The `From` trait simplifies error handling by allowing a function to return a single error type\n+/// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n+/// details.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use\n-/// [`TryFrom`] or a dedicated method which returns an [`Option<T>`] or a\n-/// [`Result<T, E>`].\n+/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n ///\n /// # Generic Implementations\n ///\n-/// - `From<T> for U` implies [`Into<U>`]` for T`\n-/// - [`from`] is reflexive, which means that `From<T> for T` is implemented\n+/// - [`From<T>`]` for U` implies [`Into<U>`]` for T`\n+/// - [`From`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// # Examples\n ///\n /// [`String`] implements `From<&str>`:\n ///\n+/// An explicit conversion from a &str to a String is done as follows:\n /// ```\n /// let string = \"hello\".to_string();\n /// let other_string = String::from(\"hello\");\n ///\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// An example usage for error handling:\n+/// While performing error handling it is often useful to implement `From` for your own error type.\n+/// By converting underlying error types to our own custom error type that encapsulates the\n+/// underlying error type, we can return a single error type without losing information on the\n+/// underlying cause. The '?' operator automatically converts the underlying error type to our\n+/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n+/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n ///\n /// ```\n /// use std::fs;"}]}