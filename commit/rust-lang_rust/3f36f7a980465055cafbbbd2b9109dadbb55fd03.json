{"sha": "3f36f7a980465055cafbbbd2b9109dadbb55fd03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMzZmN2E5ODA0NjUwNTVjYWZiYmJkMmI5MTA5ZGFkYmI1NWZkMDM=", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2016-06-10T21:27:19Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2016-06-10T22:26:42Z"}, "message": "Remove linking with AR\n\nSince we only support LLVM 3.7 and above, we will never need to use the\nAR linker. Remove the possibility of calling it and all the now-dead\ncode.", "tree": {"sha": "31e1c3fc0622a1e2c9dbbd806403d5eceecb0c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e1c3fc0622a1e2c9dbbd806403d5eceecb0c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f36f7a980465055cafbbbd2b9109dadbb55fd03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f36f7a980465055cafbbbd2b9109dadbb55fd03", "html_url": "https://github.com/rust-lang/rust/commit/3f36f7a980465055cafbbbd2b9109dadbb55fd03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f36f7a980465055cafbbbd2b9109dadbb55fd03/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "html_url": "https://github.com/rust-lang/rust/commit/a267d6cee40c2f2fa3db999afbb2bd1384f7840a"}], "stats": {"total": 283, "additions": 31, "deletions": 252}, "files": [{"sha": "e757201c8863383a5065420713c7f847dc6770a3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=3f36f7a980465055cafbbbd2b9109dadbb55fd03", "patch": "@@ -54,6 +54,7 @@ pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n pub use self::DLLStorageClassTypes::*;\n \n+use std::str::FromStr;\n use std::ffi::{CString, CStr};\n use std::cell::RefCell;\n use std::slice;\n@@ -426,6 +427,20 @@ pub enum ArchiveKind {\n     K_COFF,\n }\n \n+impl FromStr for ArchiveKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"gnu\" => Ok(ArchiveKind::K_GNU),\n+            \"mips64\" => Ok(ArchiveKind::K_MIPS64),\n+            \"bsd\" => Ok(ArchiveKind::K_BSD),\n+            \"coff\" => Ok(ArchiveKind::K_COFF),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n /// Represents the different LLVM passes Rust supports\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]"}, {"sha": "29019f3683dead592681278afbbce89fcf349461", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 15, "deletions": 241, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=3f36f7a980465055cafbbbd2b9109dadbb55fd03", "patch": "@@ -10,22 +10,17 @@\n \n //! A helper class for dealing with static archives\n \n-use std::env;\n use std::ffi::{CString, CStr, OsString};\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, Stdio};\n use std::ptr;\n use std::str;\n \n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n use rustc::session::Session;\n-use rustc_back::tempdir::TempDir;\n \n pub struct ArchiveConfig<'a> {\n     pub sess: &'a Session,\n@@ -41,7 +36,6 @@ pub struct ArchiveConfig<'a> {\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct ArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n-    work_dir: TempDir,\n     removals: Vec<String>,\n     additions: Vec<Addition>,\n     should_update_symbols: bool,\n@@ -55,17 +49,10 @@ enum Addition {\n     },\n     Archive {\n         archive: ArchiveRO,\n-        archive_name: String,\n         skip: Box<FnMut(&str) -> bool>,\n     },\n }\n \n-enum Action<'a> {\n-    Remove(&'a [String]),\n-    AddObjects(&'a [&'a PathBuf], bool),\n-    UpdateSymbols,\n-}\n-\n pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n                     -> PathBuf {\n     // On Windows, static libraries sometimes show up as libfoo.a and other\n@@ -102,7 +89,6 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn new(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n         ArchiveBuilder {\n             config: config,\n-            work_dir: TempDir::new(\"rsar\").unwrap(),\n             removals: Vec::new(),\n             additions: Vec::new(),\n             should_update_symbols: false,\n@@ -148,7 +134,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn add_native_library(&mut self, name: &str) {\n         let location = find_library(name, &self.config.lib_search_paths,\n                                     self.config.sess);\n-        self.add_archive(&location, name, |_| false).unwrap_or_else(|e| {\n+        self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n             self.config.sess.fatal(&format!(\"failed to add native library {}: {}\",\n                                             location.to_string_lossy(), e));\n         });\n@@ -172,14 +158,14 @@ impl<'a> ArchiveBuilder<'a> {\n         let metadata_filename =\n             self.config.sess.cstore.metadata_filename().to_owned();\n \n-        self.add_archive(rlib, &name[..], move |fname: &str| {\n+        self.add_archive(rlib, move |fname: &str| {\n             let skip_obj = lto && fname.starts_with(&obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == metadata_filename\n         })\n     }\n \n-    fn add_archive<F>(&mut self, archive: &Path, name: &str, skip: F)\n+    fn add_archive<F>(&mut self, archive: &Path, skip: F)\n                       -> io::Result<()>\n         where F: FnMut(&str) -> bool + 'static\n     {\n@@ -190,7 +176,6 @@ impl<'a> ArchiveBuilder<'a> {\n         };\n         self.additions.push(Addition::Archive {\n             archive: archive,\n-            archive_name: name.to_string(),\n             skip: Box::new(skip),\n         });\n         Ok(())\n@@ -214,234 +199,23 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n     pub fn build(&mut self) {\n-        let res = match self.llvm_archive_kind() {\n-            Some(kind) => self.build_with_llvm(kind),\n-            None => self.build_with_ar_cmd(),\n-        };\n-        if let Err(e) = res {\n-            self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n-        }\n-    }\n-\n-    pub fn llvm_archive_kind(&self) -> Option<ArchiveKind> {\n-        if unsafe { llvm::LLVMVersionMinor() < 7 } {\n-            return None\n-        }\n-\n-        // Currently LLVM only supports writing archives in the 'gnu' format.\n-        match &self.config.sess.target.target.options.archive_format[..] {\n-            \"gnu\" => Some(ArchiveKind::K_GNU),\n-            \"mips64\" => Some(ArchiveKind::K_MIPS64),\n-            \"bsd\" => Some(ArchiveKind::K_BSD),\n-            \"coff\" => Some(ArchiveKind::K_COFF),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn using_llvm(&self) -> bool {\n-        self.llvm_archive_kind().is_some()\n-    }\n-\n-    fn build_with_ar_cmd(&mut self) -> io::Result<()> {\n-        let removals = mem::replace(&mut self.removals, Vec::new());\n-        let additions = mem::replace(&mut self.additions, Vec::new());\n-        let should_update_symbols = mem::replace(&mut self.should_update_symbols,\n-                                                 false);\n-\n-        // Don't use fs::copy because libs may be installed as read-only and we\n-        // want to modify this archive, so we use `io::copy` to not preserve\n-        // permission bits.\n-        if let Some(ref s) = self.config.src {\n-            io::copy(&mut File::open(s)?,\n-                     &mut File::create(&self.config.dst)?)?;\n-        }\n-\n-        if removals.len() > 0 {\n-            self.run(None, Action::Remove(&removals));\n-        }\n-\n-        let mut members = Vec::new();\n-        for addition in additions {\n-            match addition {\n-                Addition::File { path, name_in_archive } => {\n-                    let dst = self.work_dir.path().join(&name_in_archive);\n-                    fs::copy(&path, &dst)?;\n-                    members.push(PathBuf::from(name_in_archive));\n-                }\n-                Addition::Archive { archive, archive_name, mut skip } => {\n-                    self.add_archive_members(&mut members, archive,\n-                                             &archive_name, &mut *skip)?;\n-                }\n-            }\n-        }\n-\n-        // Get an absolute path to the destination, so `ar` will work even\n-        // though we run it from `self.work_dir`.\n-        let mut objects = Vec::new();\n-        let mut total_len = self.config.dst.to_string_lossy().len();\n-\n-        if members.is_empty() {\n-            if should_update_symbols {\n-                self.run(Some(self.work_dir.path()), Action::UpdateSymbols);\n-            }\n-            return Ok(())\n-        }\n-\n-        // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n-        // Windows will raise an error if the argument string is longer than\n-        // 32,768, and we leave a bit of extra space for the program name.\n-        const ARG_LENGTH_LIMIT: usize = 32_000;\n-\n-        for member_name in &members {\n-            let len = member_name.to_string_lossy().len();\n-\n-            // `len + 1` to account for the space that's inserted before each\n-            // argument.  (Windows passes command-line arguments as a single\n-            // string, not an array of strings.)\n-            if total_len + len + 1 > ARG_LENGTH_LIMIT {\n-                // Add the archive members seen so far, without updating the\n-                // symbol table.\n-                self.run(Some(self.work_dir.path()),\n-                         Action::AddObjects(&objects, false));\n-\n-                objects.clear();\n-                total_len = self.config.dst.to_string_lossy().len();\n-            }\n-\n-            objects.push(member_name);\n-            total_len += len + 1;\n-        }\n-\n-        // Add the remaining archive members, and update the symbol table if\n-        // necessary.\n-        self.run(Some(self.work_dir.path()),\n-                         Action::AddObjects(&objects, should_update_symbols));\n-        Ok(())\n-    }\n-\n-    fn add_archive_members(&mut self, members: &mut Vec<PathBuf>,\n-                           archive: ArchiveRO, name: &str,\n-                           skip: &mut FnMut(&str) -> bool) -> io::Result<()> {\n-        // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // We write each file into `self.work_dir` under its new unique name.\n-        // The reason for this renaming is that archives are keyed off the name\n-        // of the files, so if two files have the same name they will override\n-        // one another in the archive (bad).\n-        //\n-        // We skip any files explicitly desired for skipping, and we also skip\n-        // all SYMDEF files as these are just magical placeholders which get\n-        // re-created when we make a new archive anyway.\n-        for file in archive.iter() {\n-            let file = file.map_err(string_to_io_error)?;\n-            if !is_relevant_child(&file) {\n-                continue\n-            }\n-            let filename = file.name().unwrap();\n-            if skip(filename) {\n-                continue\n+        let kind = match self.llvm_archive_kind() {\n+            Ok(kind) => kind,\n+            Err(kind) => {\n+                self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\",\n+                                                kind));\n             }\n-            let filename = Path::new(filename).file_name().unwrap()\n-                                              .to_str().unwrap();\n-\n-            // Archives on unix systems typically do not have slashes in\n-            // filenames as the `ar` utility generally only uses the last\n-            // component of a path for the filename list in the archive. On\n-            // Windows, however, archives assembled with `lib.exe` will preserve\n-            // the full path to the file that was placed in the archive,\n-            // including path separators.\n-            //\n-            // The code below is munging paths so it'll go wrong pretty quickly\n-            // if there's some unexpected slashes in the filename, so here we\n-            // just chop off everything but the filename component. Note that\n-            // this can cause duplicate filenames, but that's also handled below\n-            // as well.\n-            let filename = Path::new(filename).file_name().unwrap()\n-                                              .to_str().unwrap();\n-\n-            // An archive can contain files of the same name multiple times, so\n-            // we need to be sure to not have them overwrite one another when we\n-            // extract them. Consequently we need to find a truly unique file\n-            // name for us!\n-            let mut new_filename = String::new();\n-            for n in 0.. {\n-                let n = if n == 0 {String::new()} else {format!(\"-{}\", n)};\n-                new_filename = format!(\"r{}-{}-{}\", n, name, filename);\n-\n-                // LLDB (as mentioned in back::link) crashes on filenames of\n-                // exactly\n-                // 16 bytes in length. If we're including an object file with\n-                //    exactly 16-bytes of characters, give it some prefix so\n-                //    that it's not 16 bytes.\n-                new_filename = if new_filename.len() == 16 {\n-                    format!(\"lldb-fix-{}\", new_filename)\n-                } else {\n-                    new_filename\n-                };\n-\n-                let present = members.iter().filter_map(|p| {\n-                    p.file_name().and_then(|f| f.to_str())\n-                }).any(|s| s == new_filename);\n-                if !present {\n-                    break\n-                }\n-            }\n-            let dst = self.work_dir.path().join(&new_filename);\n-            File::create(&dst)?.write_all(file.data())?;\n-            members.push(PathBuf::from(new_filename));\n-        }\n-        Ok(())\n-    }\n-\n-    fn run(&self, cwd: Option<&Path>, action: Action) -> Output {\n-        let abs_dst = env::current_dir().unwrap().join(&self.config.dst);\n-        let ar = &self.config.ar_prog;\n-        let mut cmd = Command::new(ar);\n-        cmd.env(\"PATH\", &self.config.command_path);\n-        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n-        self.prepare_ar_action(&mut cmd, &abs_dst, action);\n-        info!(\"{:?}\", cmd);\n+        };\n \n-        if let Some(p) = cwd {\n-            cmd.current_dir(p);\n-            info!(\"inside {:?}\", p.display());\n+        if let Err(e) = self.build_with_llvm(kind) {\n+            self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n         }\n \n-        let sess = &self.config.sess;\n-        match cmd.spawn() {\n-            Ok(prog) => {\n-                let o = prog.wait_with_output().unwrap();\n-                if !o.status.success() {\n-                    sess.struct_err(&format!(\"{:?} failed with: {}\", cmd, o.status))\n-                        .note(&format!(\"stdout ---\\n{}\",\n-                                       str::from_utf8(&o.stdout).unwrap()))\n-                        .note(&format!(\"stderr ---\\n{}\",\n-                                       str::from_utf8(&o.stderr).unwrap()))\n-                        .emit();\n-                    sess.abort_if_errors();\n-                }\n-                o\n-            },\n-            Err(e) => {\n-                sess.fatal(&format!(\"could not exec `{}`: {}\",\n-                                    self.config.ar_prog, e));\n-            }\n-        }\n     }\n \n-    fn prepare_ar_action(&self, cmd: &mut Command, dst: &Path, action: Action) {\n-        match action {\n-            Action::Remove(files) => {\n-                cmd.arg(\"d\").arg(dst).args(files);\n-            }\n-            Action::AddObjects(objs, update_symbols) => {\n-                cmd.arg(if update_symbols {\"crs\"} else {\"crS\"})\n-                   .arg(dst)\n-                   .args(objs);\n-            }\n-            Action::UpdateSymbols => {\n-                cmd.arg(\"s\").arg(dst);\n-            }\n-        }\n+    fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n+        let kind = &self.config.sess.target.target.options.archive_format[..];\n+        kind.parse().map_err(|_| kind)\n     }\n \n     fn build_with_llvm(&mut self, kind: ArchiveKind) -> io::Result<()> {\n@@ -480,7 +254,7 @@ impl<'a> ArchiveBuilder<'a> {\n                         strings.push(path);\n                         strings.push(name);\n                     }\n-                    Addition::Archive { archive, archive_name: _, mut skip } => {\n+                    Addition::Archive { archive, mut skip } => {\n                         for child in archive.iter() {\n                             let child = child.map_err(string_to_io_error)?;\n                             if !is_relevant_child(&child) {"}, {"sha": "4676b0a67e4ae6fa226cda62c82636a68ee05751", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f36f7a980465055cafbbbd2b9109dadbb55fd03/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3f36f7a980465055cafbbbd2b9109dadbb55fd03", "patch": "@@ -412,13 +412,6 @@ fn link_rlib<'a>(sess: &'a Session,\n     // symbol table of the archive.\n     ab.update_symbols();\n \n-    // For OSX/iOS, we must be careful to update symbols only when adding\n-    // object files.  We're about to start adding non-object files, so run\n-    // `ar` now to process the object files.\n-    if sess.target.target.options.is_like_osx && !ab.using_llvm() {\n-        ab.build();\n-    }\n-\n     // Note that it is important that we add all of our non-object \"magical\n     // files\" *after* all of the object files in the archive. The reason for\n     // this is as follows:\n@@ -515,7 +508,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on OSX (see\n             // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx || ab.using_llvm() {\n+            if !sess.target.target.options.is_like_osx {\n                 ab.update_symbols();\n             }\n         }\n@@ -575,9 +568,6 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n                   tempdir: &Path) {\n     let mut ab = link_rlib(sess, None, objects, out_filename, tempdir);\n-    if sess.target.target.options.is_like_osx && !ab.using_llvm() {\n-        ab.build();\n-    }\n     if !sess.target.target.options.no_compiler_rt {\n         ab.add_native_library(\"compiler-rt\");\n     }"}]}