{"sha": "6cb425d964637da3ffa99cac902bf8fe696baf08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYjQyNWQ5NjQ2MzdkYTNmZmE5OWNhYzkwMmJmOGZlNjk2YmFmMDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T22:42:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-31T17:50:30Z"}, "message": "Rework normalization so that it works recursively, since the types extracted from an impl are potentially in need of normalization.  This also lays groundwork for further cleanup in other areas by disconnecting normalization from the fulfillment context.", "tree": {"sha": "3c60aa585177df1cf7d49240c7eedfc16ddef478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c60aa585177df1cf7d49240c7eedfc16ddef478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb425d964637da3ffa99cac902bf8fe696baf08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb425d964637da3ffa99cac902bf8fe696baf08", "html_url": "https://github.com/rust-lang/rust/commit/6cb425d964637da3ffa99cac902bf8fe696baf08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb425d964637da3ffa99cac902bf8fe696baf08/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aa7ba9f5e9882c63a8f4bf4397ba8cd558b33ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa7ba9f5e9882c63a8f4bf4397ba8cd558b33ab", "html_url": "https://github.com/rust-lang/rust/commit/0aa7ba9f5e9882c63a8f4bf4397ba8cd558b33ab"}], "stats": {"total": 950, "additions": 575, "deletions": 375}, "files": [{"sha": "a0413701abcad4110afe35df5fb4b22353cf8cf5", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 69, "deletions": 63, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -77,13 +77,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     \"overflow evaluating the requirement `{}`\",\n                     predicate.user_string(infcx.tcx)).as_slice());\n \n-            let current_limit = infcx.tcx.sess.recursion_limit.get();\n-            let suggested_limit = current_limit * 2;\n-            infcx.tcx.sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                    suggested_limit)[]);\n+            suggest_new_overflow_limit(infcx, obligation.cause.span);\n \n             note_obligation_cause(infcx, obligation);\n         }\n@@ -165,73 +159,76 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n \n-    let trait_ref = match obligation.predicate {\n-        ty::Predicate::Trait(ref trait_predicate) => {\n-            infcx.resolve_type_vars_if_possible(\n-                &trait_predicate.to_poly_trait_ref())\n-        }\n-        _ => {\n-            infcx.tcx.sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.predicate.repr(infcx.tcx)).as_slice());\n-        }\n-    };\n-\n-    let self_ty = trait_ref.self_ty();\n+    let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n \n-    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n-           trait_ref.repr(infcx.tcx),\n-           self_ty.repr(infcx.tcx),\n+    debug!(\"maybe_report_ambiguity(predicate={}, obligation={})\",\n+           predicate.repr(infcx.tcx),\n            obligation.repr(infcx.tcx));\n-    let all_types = &trait_ref.substs().types;\n-    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n-    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n-        // This is kind of a hack: it frequently happens that some earlier\n-        // error prevents types from being fully inferred, and then we get\n-        // a bunch of uninteresting errors saying something like \"<generic\n-        // #0> doesn't implement Sized\".  It may even be true that we\n-        // could just skip over all checks where the self-ty is an\n-        // inference variable, but I was afraid that there might be an\n-        // inference variable created, registered as an obligation, and\n-        // then never forced by writeback, and hence by skipping here we'd\n-        // be ignoring the fact that we don't KNOW the type works\n-        // out. Though even that would probably be harmless, given that\n-        // we're only talking about builtin traits, which are known to be\n-        // inhabited. But in any case I just threw in this check for\n-        // has_errors() to be sure that compilation isn't happening\n-        // anyway. In that case, why inundate the user.\n-        if !infcx.tcx.sess.has_errors() {\n-            if infcx.tcx.lang_items.sized_trait()\n-                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n-                infcx.tcx.sess.span_err(\n+\n+    match predicate {\n+        ty::Predicate::Trait(ref data) => {\n+            let trait_ref = data.to_poly_trait_ref();\n+            let self_ty = trait_ref.self_ty();\n+            let all_types = &trait_ref.substs().types;\n+            if all_types.iter().any(|&t| ty::type_is_error(t)) {\n+            } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. But in any case I just threw in this check for\n+                // has_errors() to be sure that compilation isn't happening\n+                // anyway. In that case, why inundate the user.\n+                if !infcx.tcx.sess.has_errors() {\n+                    if\n+                        infcx.tcx.lang_items.sized_trait()\n+                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                    {\n+                        infcx.tcx.sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"unable to infer enough type information about `{}`; \\\n+                                 type annotations required\",\n+                                self_ty.user_string(infcx.tcx)).as_slice());\n+                    } else {\n+                        infcx.tcx.sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"type annotations required: cannot resolve `{}`\",\n+                                predicate.user_string(infcx.tcx)).as_slice());\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+                }\n+            } else if !infcx.tcx.sess.has_errors() {\n+                // Ambiguity. Coherence should have reported an error.\n+                infcx.tcx.sess.span_bug(\n                     obligation.cause.span,\n                     format!(\n-                        \"unable to infer enough type information about `{}`; type annotations \\\n-                         required\",\n+                        \"coherence failed to report ambiguity: \\\n+                         cannot locate the impl of the trait `{}` for \\\n+                         the type `{}`\",\n+                        trait_ref.user_string(infcx.tcx),\n                         self_ty.user_string(infcx.tcx)).as_slice());\n-            } else {\n+            }\n+        }\n+\n+        _ => {\n+            if !infcx.tcx.sess.has_errors() {\n                 infcx.tcx.sess.span_err(\n                     obligation.cause.span,\n                     format!(\n-                        \"unable to infer enough type information to \\\n-                         locate the impl of the trait `{}` for \\\n-                         the type `{}`; type annotations required\",\n-                        trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx)).as_slice());\n+                        \"type annotations required: cannot resolve `{}`\",\n+                        predicate.user_string(infcx.tcx)).as_slice());\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n-    } else if !infcx.tcx.sess.has_errors() {\n-         // Ambiguity. Coherence should have reported an error.\n-        infcx.tcx.sess.span_bug(\n-            obligation.cause.span,\n-            format!(\n-                \"coherence failed to report ambiguity: \\\n-                 cannot locate the impl of the trait `{}` for \\\n-                 the type `{}`\",\n-                trait_ref.user_string(infcx.tcx),\n-                self_ty.user_string(infcx.tcx)).as_slice());\n     }\n }\n \n@@ -335,3 +332,12 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+pub fn suggest_new_overflow_limit(infcx: &InferCtxt, span: Span) {\n+    let current_limit = infcx.tcx.sess.recursion_limit.get();\n+    let suggested_limit = current_limit * 2;\n+    infcx.tcx.sess.span_note(\n+        span,\n+        format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+            suggested_limit)[]);\n+}"}, {"sha": "c85baccd6336d64bc643acff151f59ac5ba2655b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 26, "deletions": 109, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::infer::{mod, InferCtxt};\n+use middle::infer::{InferCtxt};\n use middle::mem_categorization::Typer;\n-use middle::ty::{mod, AsPredicate, RegionEscape, Ty, ToPolyTraitRef};\n+use middle::ty::{mod, RegionEscape, Ty};\n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::default::Default;\n@@ -23,7 +23,6 @@ use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::FulfillmentError;\n-use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n@@ -110,6 +109,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n+                                         param_env: &ty::ParameterEnvironment<'tcx>,\n+                                         typer: &Typer<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -121,18 +122,16 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         // FIXME(#20304) -- cache\n \n-        let ty_var = infcx.next_ty_var();\n-        let projection =\n-            ty::Binder(ty::ProjectionPredicate {\n-                projection_ty: projection_ty,\n-                ty: ty_var\n-            });\n-        let obligation = Obligation::new(cause, projection.as_predicate());\n-        self.register_predicate(infcx, obligation);\n+        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+        let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n+\n+        for obligation in normalized.obligations.into_iter() {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n \n-        debug!(\"normalize_associated_type: result={}\", ty_var.repr(infcx.tcx));\n+        debug!(\"normalize_associated_type: result={}\", normalized.value.repr(infcx.tcx));\n \n-        ty_var\n+        normalized.value\n     }\n \n     pub fn register_builtin_bound<'a>(&mut self,\n@@ -143,7 +142,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     {\n         match predicate_for_builtin_bound(infcx.tcx, cause, builtin_bound, 0, ty) {\n             Ok(predicate) => {\n-                self.register_predicate(infcx, predicate);\n+                self.register_predicate_obligation(infcx, predicate);\n             }\n             Err(ErrorReported) => { }\n         }\n@@ -158,10 +157,14 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         register_region_obligation(infcx.tcx, t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n-    pub fn register_predicate<'a>(&mut self,\n-                                  infcx: &InferCtxt<'a,'tcx>,\n-                                  obligation: PredicateObligation<'tcx>)\n+    pub fn register_predicate_obligation<'a>(&mut self,\n+                                             infcx: &InferCtxt<'a,'tcx>,\n+                                             obligation: PredicateObligation<'tcx>)\n     {\n+        // this helps to reduce duplicate errors, as well as making\n+        // debug output much nicer to read and so on.\n+        let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+\n         if !self.duplicate_set.insert(obligation.predicate.clone()) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;\n@@ -290,7 +293,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n             for new_obligation in new_obligations.into_iter() {\n-                self.register_predicate(selcx.infcx(), new_obligation);\n+                self.register_predicate_obligation(selcx.infcx(), new_obligation);\n             }\n         }\n \n@@ -398,104 +401,18 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                    project_obligation.repr(tcx),\n                    result.repr(tcx));\n             match result {\n-                Ok(()) => {\n+                Ok(Some(obligations)) => {\n+                    new_obligations.extend(obligations.into_iter());\n                     true\n                 }\n-                Err(project::ProjectionError::TooManyCandidates) => {\n-                    // Without more type information, we can't say much.\n+                Ok(None) => {\n                     false\n                 }\n-                Err(project::ProjectionError::NoCandidate) => {\n-                    // This means that we have a type like `<T as\n-                    // Trait>::name = U` but we couldn't find any more\n-                    // information. This could just be that we're in a\n-                    // function like:\n-                    //\n-                    //     fn foo<T:Trait>(...)\n-                    //\n-                    // in which case this is not an error. But it\n-                    // might also mean we're in a situation where we\n-                    // don't actually know that `T : Trait` holds,\n-                    // which would be weird (e.g., if `T` was not a\n-                    // parameter type but a normal type, like `int`).\n-                    //\n-                    // So what we do is to (1) add a requirement that\n-                    // `T : Trait` (just in case) and (2) try to unify\n-                    // `U` with `<T as Trait>::name`.\n-\n-                    if !ty::binds_late_bound_regions(selcx.tcx(), data) {\n-                        // Check that `T : Trait` holds.\n-                        let trait_ref = data.to_poly_trait_ref();\n-                        new_obligations.push(obligation.with(trait_ref.as_predicate()));\n-\n-                        // Fallback to `<T as Trait>::name`. If this\n-                        // fails, then the output must be at least\n-                        // somewhat constrained, and we cannot verify\n-                        // that constraint, so yield an error.\n-                        let ty_projection = ty::mk_projection(tcx,\n-                                                              trait_ref.0.clone(),\n-                                                              data.0.projection_ty.item_name);\n-\n-                        debug!(\"process_predicate: falling back to projection {}\",\n-                               ty_projection.repr(selcx.tcx()));\n-\n-                        match infer::mk_eqty(selcx.infcx(),\n-                                             true,\n-                                             infer::EquatePredicate(obligation.cause.span),\n-                                             ty_projection,\n-                                             data.0.ty) {\n-                            Ok(()) => { }\n-                            Err(_) => {\n-                                debug!(\"process_predicate: fallback failed to unify; error\");\n-                                errors.push(\n-                                    FulfillmentError::new(\n-                                        obligation.clone(),\n-                                        CodeSelectionError(Unimplemented)));\n-                            }\n-                        }\n-\n-                        true\n-                    } else {\n-                        // If we have something like\n-                        //\n-                        //     for<'a> <T<'a> as Trait>::name == &'a int\n-                        //\n-                        // there is no \"canonical form\" for us to\n-                        // make, so just report the lack of candidates\n-                        // as an error.\n-\n-                        debug!(\"process_predicate: can't fallback, higher-ranked\");\n-                        errors.push(\n-                            FulfillmentError::new(\n-                                obligation.clone(),\n-                                CodeSelectionError(Unimplemented)));\n-\n-                        true\n-                    }\n-                }\n-                Err(project::ProjectionError::MismatchedTypes(e)) => {\n+                Err(err) => {\n                     errors.push(\n                         FulfillmentError::new(\n                             obligation.clone(),\n-                            CodeProjectionError(e)));\n-                    true\n-                }\n-                Err(project::ProjectionError::TraitSelectionError(_)) => {\n-                    // There was an error matching `T : Trait` (which\n-                    // is a pre-requisite for `<T as Trait>::Name`\n-                    // being valid).  We could just report the error\n-                    // now, but that tends to lead to double error\n-                    // reports for the user (one for the obligation `T\n-                    // : Trait`, typically incurred somewhere else,\n-                    // and one from here). Instead, we'll create the\n-                    // `T : Trait` obligation and add THAT as a\n-                    // requirement. This will (eventually) trigger the\n-                    // same error, but it will also wind up flagged as\n-                    // a duplicate if another requirement that `T :\n-                    // Trait` arises from somewhere else.\n-                    let trait_predicate = data.to_poly_trait_ref();\n-                    let trait_obligation = obligation.with(trait_predicate.as_predicate());\n-                    new_obligations.push(trait_obligation);\n+                            CodeProjectionError(err)));\n                     true\n                 }\n             }"}, {"sha": "b10dfa5b718136ca058ec4844920cc2266d20f72", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -27,8 +27,8 @@ use util::ppaux::Repr;\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::project_type;\n-pub use self::project::ProjectionResult;\n+pub use self::project::normalize;\n+pub use self::project::Normalized;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n@@ -320,6 +320,16 @@ impl<'tcx,O> Obligation<'tcx,O> {\n                      predicate: trait_ref }\n     }\n \n+    fn with_depth(cause: ObligationCause<'tcx>,\n+                  recursion_depth: uint,\n+                  trait_ref: O)\n+                  -> Obligation<'tcx, O>\n+    {\n+        Obligation { cause: cause,\n+                     recursion_depth: recursion_depth,\n+                     predicate: trait_ref }\n+    }\n+\n     pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n         Obligation::new(ObligationCause::misc(span, body_id), trait_ref)\n     }"}, {"sha": "28a826b859b4cad45ff9c1a94750256c885bc9dc", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 303, "deletions": 66, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -12,14 +12,17 @@\n \n use super::elaborate_predicates;\n use super::Obligation;\n+use super::ObligationCause;\n+use super::Overflow;\n use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableImplData;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{mod, AsPredicate, ToPolyTraitRef, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -31,21 +34,11 @@ pub type ProjectionObligation<'tcx> =\n pub type ProjectionTyObligation<'tcx> =\n     Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n \n-/// When attempting to resolve `<T as TraitRef>::Name == U`...\n-pub enum ProjectionError<'tcx> {\n-    /// ...we could not find any helpful information on what `Name`\n-    /// might be. This could occur, for example, if there is a where\n-    /// clause `T : TraitRef` but not `T : TraitRef<Name=V>`. When\n-    /// normalizing, this case is where we opt to normalize back to\n-    /// the projection type `<T as TraitRef>::Name`.\n-    NoCandidate,\n-\n+/// When attempting to resolve `<T as TraitRef>::Name` ...\n+pub enum ProjectionTyError<'tcx> {\n     /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n     TooManyCandidates,\n \n-    /// ...`<T as TraitRef::Name>` ws resolved to some type `V` that failed to unify with `U`\n-    MismatchedTypes(MismatchedProjectionTypes<'tcx>),\n-\n     /// ...an error occurred matching `T : TraitRef`\n     TraitSelectionError(SelectionError<'tcx>),\n }\n@@ -55,8 +48,6 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::type_err<'tcx>\n }\n \n-pub type ProjectionResult<'tcx, T> = Result<T, ProjectionError<'tcx>>;\n-\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n@@ -70,73 +61,325 @@ struct ProjectionTyCandidateSet<'tcx> {\n pub fn poly_project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n-    -> ProjectionResult<'tcx, ()>\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"poly_project(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-\n-    infcx.try(|snapshot| {\n+    let result = infcx.try(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n \n         let skol_obligation = obligation.with(skol_predicate);\n-        let () = try!(project_and_unify_type(selcx, &skol_obligation));\n-        match infcx.leak_check(&skol_map, snapshot) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+        match project_and_unify_type(selcx, &skol_obligation) {\n+            Ok(Some(obligations)) => {\n+                match infcx.leak_check(&skol_map, snapshot) {\n+                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &obligations)),\n+                    Err(e) => Err(Some(MismatchedProjectionTypes { err: e })),\n+                }\n+            }\n+            Ok(None) => {\n+                // Signal ambiguity using Err just so that infcx.try()\n+                // rolls back the snapshot. We adapt below.\n+                Err(None)\n+            }\n+            Err(e) => {\n+                Err(Some(e))\n+            }\n         }\n-    })\n+    });\n+\n+    // Above, we use Err(None) to signal ambiguity so that the\n+    // snapshot will be rolled back. But here, we want to translate to\n+    // Ok(None). Kind of weird.\n+    match result {\n+        Ok(obligations) => Ok(Some(obligations)),\n+        Err(None) => Ok(None),\n+        Err(Some(e)) => Err(e),\n+    }\n }\n \n /// Compute result of projecting an associated type and unify it with\n /// `obligation.predicate.ty` (if we can).\n pub fn project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n-    -> ProjectionResult<'tcx, ()>\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"project_and_unify(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n-    let ty_obligation = obligation.with(obligation.predicate.projection_ty.clone());\n-    let projected_ty = try!(project_type(selcx, &ty_obligation));\n+    let Normalized { value: normalized_ty, obligations } =\n+        match opt_normalize_projection_type(selcx,\n+                                            obligation.predicate.projection_ty.clone(),\n+                                            obligation.cause.clone(),\n+                                            obligation.recursion_depth) {\n+            Some(n) => n,\n+            None => { return Ok(None); }\n+        };\n+\n+    debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n+           normalized_ty.repr(selcx.tcx()),\n+           obligations.repr(selcx.tcx()));\n+\n     let infcx = selcx.infcx();\n     let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-    debug!(\"project_and_unify_type: projected_ty = {}\", projected_ty.repr(selcx.tcx()));\n-    match infer::mk_eqty(infcx, true, origin, projected_ty, obligation.predicate.ty) {\n-        Ok(()) => Ok(()),\n-        Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+    match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n+        Ok(()) => Ok(Some(obligations)),\n+        Err(err) => Err(MismatchedProjectionTypes { err: err }),\n+    }\n+}\n+\n+pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n+                               cause: ObligationCause<'tcx>,\n+                               value: &T)\n+                               -> Normalized<'tcx, T>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone\n+{\n+    let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, 0);\n+    let result = normalizer.fold(value);\n+    Normalized {\n+        value: result,\n+        obligations: normalizer.obligations,\n+    }\n+}\n+\n+struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n+    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+    depth: uint,\n+}\n+\n+impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n+    fn new(selcx: &'a mut SelectionContext<'b,'tcx>,\n+           cause: ObligationCause<'tcx>,\n+           depth: uint)\n+           -> AssociatedTypeNormalizer<'a,'b,'tcx>\n+    {\n+        AssociatedTypeNormalizer {\n+            selcx: selcx,\n+            cause: cause,\n+            obligations: vec!(),\n+            depth: depth,\n+        }\n+    }\n+\n+    fn fold<T:TypeFoldable<'tcx> + HasProjectionTypes + Clone>(&mut self, value: &T) -> T {\n+        let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n+\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.selcx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // We don't want to normalize associated types that occur inside of region\n+        // binders, because they may contain bound regions, and we can't cope with that.\n+        //\n+        // Example:\n+        //\n+        //     for<'a> fn(<T as Foo<&'a>>::A)\n+        //\n+        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n+        // normalize it when we instantiate those bound regions (which\n+        // should occur eventually).\n+\n+        match ty.sty {\n+            ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n+\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n+                let Normalized { value: ty, obligations } =\n+                    normalize_projection_type(self.selcx,\n+                                              data.clone(),\n+                                              self.cause.clone(),\n+                                              self.depth);\n+                self.obligations.extend(obligations.into_iter());\n+                ty\n+            }\n+            _ => {\n+                ty_fold::super_fold_ty(self, ty)\n+            }\n+        }\n+    }\n+}\n+\n+pub struct Normalized<'tcx,T> {\n+    pub value: T,\n+    pub obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n+\n+pub fn normalize_projection_type<'a,'b,'tcx>(\n+    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: uint)\n+    -> NormalizedTy<'tcx>\n+{\n+    opt_normalize_projection_type(selcx, projection_ty.clone(), cause.clone(), depth)\n+        .unwrap_or_else(move || {\n+            // if we bottom out in ambiguity, create a type variable\n+            // and a deferred predicate to resolve this when more type\n+            // information is available.\n+\n+            let ty_var = selcx.infcx().next_ty_var();\n+            let projection = ty::Binder(ty::ProjectionPredicate {\n+                projection_ty: projection_ty,\n+                ty: ty_var\n+            });\n+            let obligation = Obligation::with_depth(cause, depth+1, projection.as_predicate());\n+            Normalized {\n+                value: ty_var,\n+                obligations: vec!(obligation)\n+            }\n+        })\n+}\n+\n+fn opt_normalize_projection_type<'a,'b,'tcx>(\n+    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: uint)\n+    -> Option<NormalizedTy<'tcx>>\n+{\n+    debug!(\"normalize_projection_type(\\\n+           projection_ty={}, \\\n+           depth={})\",\n+           projection_ty.repr(selcx.tcx()),\n+           depth);\n+\n+    let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n+    match project_type(selcx, &obligation) {\n+        Ok(ProjectedTy::Progress(projected_ty, mut obligations)) => {\n+            // if projection succeeded, then what we get out of this\n+            // is also non-normalized (consider: it was derived from\n+            // an impl, where-clause etc) and hence we must\n+            // re-normalize it\n+\n+            debug!(\"normalize_projection_type: projected_ty={} depth={}\",\n+                   projected_ty.repr(selcx.tcx()),\n+                   depth);\n+\n+            if ty::type_has_projection(projected_ty) {\n+                let tcx = selcx.tcx();\n+                let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n+                let normalized_ty = normalizer.fold(&projected_ty);\n+\n+                debug!(\"normalize_projection_type: normalized_ty={} depth={}\",\n+                       normalized_ty.repr(tcx),\n+                       depth);\n+\n+                obligations.extend(normalizer.obligations.into_iter());\n+                Some(Normalized {\n+                    value: normalized_ty,\n+                    obligations: obligations,\n+                })\n+            } else {\n+                Some(Normalized {\n+                    value: projected_ty,\n+                    obligations: obligations,\n+                })\n+            }\n+        }\n+        Ok(ProjectedTy::NoProgress(projected_ty)) => {\n+            Some(Normalized {\n+                value: projected_ty,\n+                obligations: vec!()\n+            })\n+        }\n+        Err(ProjectionTyError::TooManyCandidates) => {\n+            None\n+        }\n+        Err(ProjectionTyError::TraitSelectionError(_)) => {\n+            // if we got an error processing the `T as Trait` part,\n+            // just return `ty::err` but add the obligation `T :\n+            // Trait`, which when processed will cause the error to be\n+            // reported later\n+\n+            Some(normalize_to_error(selcx, projection_ty, cause, depth))\n+        }\n+    }\n+}\n+\n+/// in various error cases, we just set ty_err and return an obligation\n+/// that, when fulfiled, will lead to an error\n+fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                               projection_ty: ty::ProjectionTy<'tcx>,\n+                               cause: ObligationCause<'tcx>,\n+                               depth: uint)\n+                               -> NormalizedTy<'tcx>\n+{\n+    let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n+    let trait_obligation = Obligation { cause: cause,\n+                                        recursion_depth: depth,\n+                                        predicate: trait_ref.as_predicate() };\n+    Normalized {\n+        value: selcx.tcx().types.err,\n+        obligations: vec!(trait_obligation)\n     }\n }\n \n+enum ProjectedTy<'tcx> {\n+    Progress(Ty<'tcx>, Vec<PredicateObligation<'tcx>>),\n+    NoProgress(Ty<'tcx>),\n+}\n+\n /// Compute the result of a projection type (if we can).\n-pub fn project_type<'cx,'tcx>(\n+fn project_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n-    -> ProjectionResult<'tcx, Ty<'tcx>>\n+    -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n     debug!(\"project(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n+    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+    if obligation.recursion_depth >= recursion_limit {\n+        debug!(\"project: overflow!\");\n+        return Err(ProjectionTyError::TraitSelectionError(Overflow));\n+    }\n+\n     let mut candidates = ProjectionTyCandidateSet {\n         vec: Vec::new(),\n         ambiguous: false,\n     };\n \n-    let () = assemble_candidates_from_object_type(selcx,\n-                                                  obligation,\n-                                                  &mut candidates);\n+    assemble_candidates_from_object_type(selcx,\n+                                         obligation,\n+                                         &mut candidates);\n \n     if candidates.vec.is_empty() {\n-        let () = assemble_candidates_from_param_env(selcx,\n-                                                    obligation,\n-                                                    &mut candidates);\n-\n-        let () = try!(assemble_candidates_from_impls(selcx,\n-                                                     obligation,\n-                                                     &mut candidates));\n+        assemble_candidates_from_param_env(selcx,\n+                                           obligation,\n+                                           &mut candidates);\n+\n+        if let Err(e) = assemble_candidates_from_impls(selcx,\n+                                                       obligation,\n+                                                       &mut candidates) {\n+            return Err(ProjectionTyError::TraitSelectionError(e));\n+        }\n     }\n \n     debug!(\"{} candidates, ambiguous={}\",\n@@ -146,15 +389,18 @@ pub fn project_type<'cx,'tcx>(\n     // We probably need some winnowing logic similar to select here.\n \n     if candidates.ambiguous || candidates.vec.len() > 1 {\n-        return Err(ProjectionError::TooManyCandidates);\n+        return Err(ProjectionTyError::TooManyCandidates);\n     }\n \n     match candidates.vec.pop() {\n         Some(candidate) => {\n-            Ok(try!(confirm_candidate(selcx, obligation, candidate)))\n+            let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n+            Ok(ProjectedTy::Progress(ty, obligations))\n         }\n         None => {\n-            Err(ProjectionError::NoCandidate)\n+            Ok(ProjectedTy::NoProgress(ty::mk_projection(selcx.tcx(),\n+                                                         obligation.predicate.trait_ref.clone(),\n+                                                         obligation.predicate.item_name)))\n         }\n     }\n }\n@@ -230,9 +476,9 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-    -> ProjectionResult<'tcx, ()>\n+    -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n@@ -249,7 +495,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n         Err(e) => {\n             debug!(\"assemble_candidates_from_impls: selection error {}\",\n                    e.repr(selcx.tcx()));\n-            return Err(ProjectionError::TraitSelectionError(e));\n+            return Err(e);\n         }\n     };\n \n@@ -301,17 +547,17 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n \n fn confirm_candidate<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n-    -> ProjectionResult<'tcx, Ty<'tcx>>\n+    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let infcx = selcx.infcx();\n \n     debug!(\"confirm_candidate(candidate={}, obligation={})\",\n            candidate.repr(infcx.tcx),\n            obligation.repr(infcx.tcx));\n \n-    let projected_ty = match candidate {\n+    match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n             let projection =\n                 infcx.replace_late_bound_regions_with_fresh_var(\n@@ -338,7 +584,7 @@ fn confirm_candidate<'cx,'tcx>(\n                 }\n             }\n \n-            projection.ty\n+            (projection.ty, vec!())\n         }\n \n         ProjectionTyCandidate::Impl(impl_vtable) => {\n@@ -363,10 +609,8 @@ fn confirm_candidate<'cx,'tcx>(\n                 break;\n             }\n \n-            // TODO we need the impl_vtable items here\n-\n             match impl_ty {\n-                Some(ty) => ty,\n+                Some(ty) => (ty, impl_vtable.nested.to_vec()),\n                 None => {\n                     selcx.tcx().sess.span_bug(\n                         obligation.cause.span,\n@@ -376,21 +620,15 @@ fn confirm_candidate<'cx,'tcx>(\n                 }\n             }\n         }\n-    };\n-\n-    Ok(projected_ty)\n+    }\n }\n \n-impl<'tcx> Repr<'tcx> for ProjectionError<'tcx> {\n+impl<'tcx> Repr<'tcx> for ProjectionTyError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            ProjectionError::NoCandidate =>\n+            ProjectionTyError::TooManyCandidates =>\n                 format!(\"NoCandidate\"),\n-            ProjectionError::TooManyCandidates =>\n-                format!(\"NoCandidate\"),\n-            ProjectionError::MismatchedTypes(ref m) =>\n-                format!(\"MismatchedTypes({})\", m.repr(tcx)),\n-            ProjectionError::TraitSelectionError(ref e) =>\n+            ProjectionTyError::TraitSelectionError(ref e) =>\n                 format!(\"TraitSelectionError({})\", e.repr(tcx)),\n         }\n     }\n@@ -406,4 +644,3 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "1b00a77fe5129c7ce3722caa9d35c1dba1361ac0", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -960,7 +960,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // iterating early.\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let vtable = selection.map_move_nested(|predicate| {\n-        fulfill_cx.register_predicate(&infcx, predicate);\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }"}, {"sha": "c693c6ea428a69f844d11fc9c376937e397ae296", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 13, "deletions": 51, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -16,7 +16,7 @@ use middle::infer;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::traits;\n-use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use trans::base::{trans_fn, decl_internal_rust_fn};\n@@ -32,7 +32,6 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use std::hash::{sip, Hash};\n-use std::rc::Rc;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n@@ -310,66 +309,29 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// monomorphization, we know that only concrete types are involved,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n-pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, t: &T) -> T\n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n {\n-    debug!(\"normalize_associated_type(t={})\", t.repr(tcx));\n+    debug!(\"normalize_associated_type(t={})\", value.repr(tcx));\n \n-    if !t.has_projection_types() {\n-        return t.clone();\n+    if !value.has_projection_types() {\n+        return value.clone();\n     }\n \n     // FIXME(#20304) -- cache\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n-    let mut normalizer = AssociatedTypeNormalizer { selcx: &mut selcx };\n-    let result = t.fold_with(&mut normalizer);\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: result, obligations } =\n+        traits::normalize(&mut selcx, cause, value);\n \n-    debug!(\"normalize_associated_type: t={} result={}\",\n-           t.repr(tcx),\n-           result.repr(tcx));\n+    debug!(\"normalize_associated_type: result={} obligations={}\",\n+           result.repr(tcx),\n+           obligations.repr(tcx));\n \n-    result\n-}\n-\n-struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n-    selcx: &'a mut traits::SelectionContext<'a,'tcx>,\n-}\n-\n-impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> { self.selcx.tcx() }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.sty {\n-            ty::ty_projection(ref data) => {\n-                debug!(\"ty_projection({})\", data.repr(self.tcx()));\n-\n-                let tcx = self.selcx.tcx();\n-                let substs = data.trait_ref.substs.clone().erase_regions();\n-                let substs = self.tcx().mk_substs(substs);\n-                assert!(substs.types.iter().all(|&t| (!ty::type_has_params(t) &&\n-                                                      !ty::type_has_self(t))));\n-                let trait_ref = Rc::new(ty::TraitRef::new(data.trait_ref.def_id, substs));\n-                let projection_ty = ty::ProjectionTy { trait_ref: trait_ref.clone(),\n-                                                       item_name: data.item_name };\n-                let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                                         projection_ty);\n-                match traits::project_type(self.selcx, &obligation) {\n-                    Ok(ty) => ty,\n-                    Err(errors) => {\n-                        tcx.sess.bug(\n-                            format!(\"Encountered error(s) `{}` selecting `{}` during trans\",\n-                                    errors.repr(tcx),\n-                                    trait_ref.repr(tcx)).as_slice());\n-                    }\n-                }\n-            }\n+    assert_eq!(obligations.len(), 0); // TODO not good enough\n \n-            _ => {\n-                ty_fold::super_fold_ty(self, ty)\n-            }\n-        }\n-    }\n+    result\n }"}, {"sha": "98081e28f2fd7d36c2a99095f895fb575bf9f6ae", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 19, "deletions": 70, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -9,85 +9,34 @@\n // except according to those terms.\n \n use middle::infer::InferCtxt;\n-use middle::traits::{ObligationCause, ObligationCauseCode, FulfillmentContext};\n-use middle::ty::{mod, RegionEscape, HasProjectionTypes, Ty};\n-use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use middle::mem_categorization as mc;\n+use middle::traits::{mod, FulfillmentContext, Normalized, MiscObligation,\n+                     SelectionContext, ObligationCause};\n+use middle::ty::{mod, HasProjectionTypes};\n+use middle::ty_fold::{TypeFoldable, TypeFolder};\n use syntax::ast;\n use syntax::codemap::Span;\n+use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                                param_env: &ty::ParameterEnvironment<'tcx>,\n+                                                typer: &(mc::Typer<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n {\n-    let value = infcx.resolve_type_vars_if_possible(value);\n-\n-    if !value.has_projection_types() {\n-        return value.clone();\n-    }\n-\n-    let mut normalizer = AssociatedTypeNormalizer { span: span,\n-                                                    body_id: body_id,\n-                                                    infcx: infcx,\n-                                                    fulfillment_cx: fulfillment_cx };\n-    value.fold_with(&mut normalizer)\n-}\n-\n-struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    fulfillment_cx: &'a mut FulfillmentContext<'tcx>,\n-    span: Span,\n-    body_id: ast::NodeId,\n-}\n-\n-impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        // We don't want to normalize associated types that occur inside of region\n-        // binders, because they may contain bound regions, and we can't cope with that.\n-        //\n-        // Example:\n-        //\n-        //     for<'a> fn(<T as Foo<&'a>>::A)\n-        //\n-        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n-        // normalize it when we instantiate those bound regions (which\n-        // should occur eventually).\n-\n-        match ty.sty {\n-            ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n-\n-                // (*) This is kind of hacky -- we need to be able to\n-                // handle normalization within binders because\n-                // otherwise we wind up a need to normalize when doing\n-                // trait matching (since you can have a trait\n-                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n-                // we can't normalize with bound regions in scope. So\n-                // far now we just ignore binders but only normalize\n-                // if all bound regions are gone (and then we still\n-                // have to renormalize whenever we instantiate a\n-                // binder). It would be better to normalize in a\n-                // binding-aware fashion.\n-\n-                let cause =\n-                    ObligationCause::new(\n-                        self.span,\n-                        self.body_id,\n-                        ObligationCauseCode::MiscObligation);\n-                self.fulfillment_cx\n-                    .normalize_projection_type(self.infcx,\n-                                               data.clone(),\n-                                               cause)\n-            }\n-            _ => {\n-                ty_fold::super_fold_ty(self, ty)\n-            }\n-        }\n+    debug!(\"normalize_associated_types_in(value={})\", value.repr(infcx.tcx));\n+    let mut selcx = SelectionContext::new(infcx, param_env, typer);\n+    let cause = ObligationCause::new(span, body_id, MiscObligation);\n+    let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n+    debug!(\"normalize_associated_types_in: result={} predicates={}\",\n+           result.repr(infcx.tcx),\n+           obligations.repr(infcx.tcx));\n+    for obligation in obligations.into_iter() {\n+        fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }\n+    result\n }"}, {"sha": "12cebabc997a4bae1ffd931963f225a1186c5f4e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -350,11 +350,18 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         }\n     }\n \n-    fn normalize_associated_types_in<T>(&self, span: Span, body_id: ast::NodeId, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+    fn normalize_associated_types_in<T>(&self,\n+                                        typer: &mc::Typer<'tcx>,\n+                                        span: Span,\n+                                        body_id: ast::NodeId,\n+                                        value: &T)\n+                                        -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n+                                             &self.param_env,\n+                                             typer,\n                                              &mut *fulfillment_cx, span,\n                                              body_id,\n                                              value)\n@@ -438,7 +445,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+                inh.normalize_associated_types_in(ccx.tcx, body.span, body.id, &fn_sig);\n \n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n@@ -1190,6 +1197,8 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1209,6 +1218,8 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             trait_sig.subst(tcx, &trait_to_skol_substs);\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 infcx.tcx,\n                                                  &mut fulfillment_cx,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n@@ -1756,9 +1767,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n     {\n-        self.inh.normalize_associated_types_in(span, self.body_id, value)\n+        self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n \n     fn normalize_associated_type(&self,\n@@ -1773,6 +1784,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n+                                       &self.inh.param_env,\n+                                       self,\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n                                            item_name: item_name,\n@@ -1943,7 +1956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.inh.fulfillment_cx\n             .borrow_mut()\n-            .register_predicate(self.infcx(), obligation);\n+            .register_predicate_obligation(self.infcx(), obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {"}, {"sha": "989214d81da9e508d87a3186f96cbb94c1c6616e", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -25,11 +25,30 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n     panic!();\n }\n \n-pub fn main() {\n-    f1(2i, 4i); //~ ERROR expected uint, found int\n+pub fn f1_int_int() {\n+    f1(2i, 4i);\n+    //~^ ERROR expected uint, found int\n+}\n+\n+pub fn f1_int_uint() {\n     f1(2i, 4u);\n-    f1(2u, 4u); //~ ERROR the trait `Foo` is not implemented\n-    f1(2u, 4i); //~ ERROR the trait `Foo` is not implemented\n+}\n+\n+pub fn f1_uint_uint() {\n+    f1(2u, 4u);\n+    //~^ ERROR the trait `Foo` is not implemented\n+    //~| ERROR the trait `Foo` is not implemented\n+}\n+\n+pub fn f1_uint_int() {\n+    f1(2u, 4i);\n+    //~^ ERROR the trait `Foo` is not implemented\n+    //~| ERROR the trait `Foo` is not implemented\n+}\n \n-    let _: int = f2(2i); //~ERROR expected `int`, found `uint`\n+pub fn f2_int() {\n+    let _: int = f2(2i);\n+    //~^ ERROR expected `int`, found `uint`\n }\n+\n+pub fn main() { }"}, {"sha": "0e13efdebc9558cc64f1436cd1390f71ab5231ea", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-fn-body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -29,9 +29,10 @@ fn bar<'a, 'b, I : for<'x> Foo<&'x int>>(\n     x: <I as Foo<&'a int>>::A,\n     y: <I as Foo<&'b int>>::A,\n     cond: bool)\n-{ //~ ERROR cannot infer\n+{\n     // x and y here have two distinct lifetimes:\n     let z: I::A = if cond { x } else { y };\n+    //~^ ERROR cannot infer\n }\n \n pub fn main() {}"}, {"sha": "02e1121880678cdbf70d0308a17f9e53e9a3b068", "filename": "src/test/compile-fail/associated-types-unconstrained.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that an associated type cannot be bound in an expression path.\n+\n+#![feature(associated_types)]\n+\n+trait Foo {\n+    type A;\n+    fn bar() -> int;\n+}\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn bar() -> int { 42 }\n+}\n+\n+pub fn main() {\n+    let x: int = Foo::bar();\n+    //~^ ERROR type annotations required\n+}"}, {"sha": "3c461fd5b4b70948bd607de1f70229e4261e7903", "filename": "src/test/compile-fail/traits-multidispatch-convert-ambig-dest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -33,7 +33,7 @@ where T : Convert<U>\n }\n \n fn a() {\n-    test(22_i32, 44); //~ ERROR unable to infer\n+    test(22_i32, 44); //~ ERROR type annotations required\n }\n \n fn main() {}"}, {"sha": "a28cf34633684565ab299b732baea4b8a7ae6d76", "filename": "src/test/run-pass/associated-types-impl-redirect.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb425d964637da3ffa99cac902bf8fe696baf08/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-impl-redirect.rs?ref=6cb425d964637da3ffa99cac902bf8fe696baf08", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how resolving a projection interacts with inference.  In this\n+// case, we were eagerly unifying the type variable for the iterator\n+// type with `I` from the where clause, ignoring the in-scope `impl`\n+// for `ByRef`. The right answer was to consider the result ambiguous\n+// until more type information was available.\n+\n+// ignore-pretty -- FIXME(#17362)\n+\n+#![feature(associated_types, lang_items, unboxed_closures)]\n+#![no_implicit_prelude]\n+\n+use std::option::Option::{None, Some, mod};\n+\n+trait Iterator {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+}\n+\n+trait IteratorExt: Iterator {\n+    fn by_ref(&mut self) -> ByRef<Self> {\n+        ByRef(self)\n+    }\n+}\n+\n+impl<I> IteratorExt for I where I: Iterator {}\n+\n+struct ByRef<'a, I: 'a + Iterator>(&'a mut I);\n+\n+impl<'a, I: Iterator> Iterator for ByRef<'a, I> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option< <I as Iterator>::Item > {\n+        self.0.next()\n+    }\n+}\n+\n+fn is_iterator_of<A, I: Iterator<Item=A>>(_: &I) {}\n+\n+fn test<A, I: Iterator<Item=A>>(mut it: I) {\n+    is_iterator_of::<A, _>(&it.by_ref());\n+}\n+\n+fn test2<A, I1: Iterator<Item=A>, I2: Iterator<Item=I1::Item>>(mut it: I2) {\n+    is_iterator_of::<A, _>(&it)\n+}\n+\n+fn main() { }"}]}