{"sha": "8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNTJiODVkNWE2ZjZlM2FhYTJmMTVkN2MxZTkwN2QwY2U4NTg5ZWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-10T22:02:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:48Z"}, "message": "libsyntax: De-`@str` literal strings in the AST", "tree": {"sha": "afcac214c65f792304926a71117ffdf37a0fd060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afcac214c65f792304926a71117ffdf37a0fd060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "html_url": "https://github.com/rust-lang/rust/commit/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc", "html_url": "https://github.com/rust-lang/rust/commit/70c5a0fbf784d6a89b1c2c50f9fe83093bd21abc"}], "stats": {"total": 707, "additions": 432, "deletions": 275}, "files": [{"sha": "4a3e2ac5e2abcff53b7d57555c5f4fb75b3f22c5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -74,20 +74,20 @@ pub fn source_name(input: &Input) -> @str {\n pub fn default_configuration(sess: Session) ->\n    ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n-        abi::OsWin32 =>   @\"win32\",\n-        abi::OsMacos =>   @\"macos\",\n-        abi::OsLinux =>   @\"linux\",\n-        abi::OsAndroid => @\"android\",\n-        abi::OsFreebsd => @\"freebsd\"\n+        abi::OsWin32 =>   InternedString::new(\"win32\"),\n+        abi::OsMacos =>   InternedString::new(\"macos\"),\n+        abi::OsLinux =>   InternedString::new(\"linux\"),\n+        abi::OsAndroid => InternedString::new(\"android\"),\n+        abi::OsFreebsd => InternedString::new(\"freebsd\"),\n     };\n \n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 =>    (@\"little\", @\"x86\",    @\"32\"),\n-        abi::X86_64 => (@\"little\", @\"x86_64\", @\"64\"),\n-        abi::Arm =>    (@\"little\", @\"arm\",    @\"32\"),\n-        abi::Mips =>   (@\"big\",    @\"mips\",   @\"32\")\n+        abi::X86 =>    (\"little\", \"x86\",    \"32\"),\n+        abi::X86_64 => (\"little\", \"x86_64\", \"64\"),\n+        abi::Arm =>    (\"little\", \"arm\",    \"32\"),\n+        abi::Mips =>   (\"big\",    \"mips\",   \"32\")\n     };\n \n     let fam = match sess.targ_cfg.os {\n@@ -99,10 +99,11 @@ pub fn default_configuration(sess: Session) ->\n     return ~[ // Target bindings.\n          attr::mk_word_item(fam.clone()),\n          mk(InternedString::new(\"target_os\"), tos),\n-         mk(InternedString::new(\"target_family\"), fam.get().to_managed()),\n-         mk(InternedString::new(\"target_arch\"), arch),\n-         mk(InternedString::new(\"target_endian\"), end),\n-         mk(InternedString::new(\"target_word_size\"), wordsz),\n+         mk(InternedString::new(\"target_family\"), fam),\n+         mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n+         mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n+         mk(InternedString::new(\"target_word_size\"),\n+            InternedString::new(wordsz)),\n     ];\n }\n "}, {"sha": "eceed2422b62be40e899c75fd531101767921be8", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -417,7 +417,12 @@ pub fn building_library(options: &Options, crate: &ast::Crate) -> bool {\n         }\n     }\n     match syntax::attr::first_attr_value_str_by_name(crate.attrs, \"crate_type\") {\n-        Some(s) => \"lib\" == s || \"rlib\" == s || \"dylib\" == s || \"staticlib\" == s,\n+        Some(s) => {\n+            s.equiv(&(\"lib\")) ||\n+            s.equiv(&(\"rlib\")) ||\n+            s.equiv(&(\"dylib\")) ||\n+            s.equiv(&(\"staticlib\"))\n+        }\n         _ => false\n     }\n }\n@@ -437,14 +442,20 @@ pub fn collect_outputs(session: &Session,\n     let mut iter = attrs.iter().filter_map(|a| {\n         if a.name().equiv(&(\"crate_type\")) {\n             match a.value_str() {\n-                Some(n) if \"rlib\" == n => Some(OutputRlib),\n-                Some(n) if \"dylib\" == n => Some(OutputDylib),\n-                Some(n) if \"lib\" == n => Some(default_lib_output()),\n-                Some(n) if \"staticlib\" == n => Some(OutputStaticlib),\n-                Some(n) if \"bin\" == n => Some(OutputExecutable),\n+                Some(ref n) if n.equiv(&(\"rlib\")) => Some(OutputRlib),\n+                Some(ref n) if n.equiv(&(\"dylib\")) => Some(OutputDylib),\n+                Some(ref n) if n.equiv(&(\"lib\")) => {\n+                    Some(default_lib_output())\n+                }\n+                Some(ref n) if n.equiv(&(\"staticlib\")) => {\n+                    Some(OutputStaticlib)\n+                }\n+                Some(ref n) if n.equiv(&(\"bin\")) => Some(OutputExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n-                                     a.span, ~\"invalid `crate_type` value\");\n+                    session.add_lint(lint::UnknownCrateType,\n+                                     ast::CRATE_NODE_ID,\n+                                     a.span,\n+                                     ~\"invalid `crate_type` value\");\n                     None\n                 }\n                 _ => {"}, {"sha": "6813addc55226aa9eff36a1a1902cff594861b1d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -28,6 +28,7 @@ use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::util::small_vector::SmallVector;\n@@ -426,7 +427,8 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     debug!(\"encoding {}\", ast_util::path_name_i(path));\n \n     let name_lit: ast::Lit =\n-        nospan(ast::LitStr(ast_util::path_name_i(path).to_managed(), ast::CookedStr));\n+        nospan(ast::LitStr(token::intern_and_get_ident(\n+                    ast_util::path_name_i(path)), ast::CookedStr));\n \n     let name_expr = @ast::Expr {\n           id: ast::DUMMY_NODE_ID,"}, {"sha": "c43cf0a6ad79d26bd6e8d9bab6ad9dfe4d5135b8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -27,8 +27,8 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::diagnostic::SpanHandler;\n use syntax::ext::base::{CrateLoader, MacroCrate};\n+use syntax::parse::token::{IdentInterner, InternedString};\n use syntax::parse::token;\n-use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n use syntax::visit;\n \n@@ -126,10 +126,8 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n \n     for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n-          Some(ref linkarg) => {\n-            cstore.add_used_link_args(*linkarg);\n-          }\n-          None => {/* fallthrough */ }\n+          Some(ref linkarg) => cstore.add_used_link_args(linkarg.get()),\n+          None => { /* fallthrough */ }\n         }\n     }\n }\n@@ -214,9 +212,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.value_str() {\n-                    Some(linkarg) => {\n-                        cstore.add_used_link_args(linkarg);\n-                    }\n+                    Some(linkarg) => cstore.add_used_link_args(linkarg.get()),\n                     None => { /* fallthrough */ }\n                 }\n             }\n@@ -238,12 +234,12 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                         }).and_then(|a| a.value_str());\n                         let kind = match kind {\n                             Some(k) => {\n-                                if \"static\" == k {\n+                                if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n                                 } else if e.sess.targ_cfg.os == abi::OsMacos &&\n-                                          \"framework\" == k {\n+                                          k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n-                                } else if \"framework\" == k {\n+                                } else if k.equiv(&(\"framework\")) {\n                                     e.sess.span_err(m.span,\n                                         \"native frameworks are only available \\\n                                          on OSX targets\");\n@@ -265,13 +261,13 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                 e.sess.span_err(m.span,\n                                     \"#[link(...)] specified without \\\n                                      `name = \\\"foo\\\"`\");\n-                                @\"foo\"\n+                                InternedString::new(\"foo\")\n                             }\n                         };\n-                        if n.is_empty() {\n+                        if n.get().is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            cstore.add_used_library(n.to_owned(), kind);\n+                            cstore.add_used_library(n.get().to_owned(), kind);\n                         }\n                     }\n                     None => {}"}, {"sha": "65eb273b9b887b33fb3ea7a199317b93c0b399da", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -1050,7 +1050,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n-        let v = vd.as_str_slice().to_managed();\n+        let v = token::intern_and_get_ident(vd.as_str_slice());\n         // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));"}, {"sha": "d58187641dbd3f0ced7415bb41bca481df2b16a1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -1513,15 +1513,15 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      MetaNameValue(ref name, value) => {\n+      MetaNameValue(ref name, ref value) => {\n         match value.node {\n-          LitStr(value, _) => {\n+          LitStr(ref value, _) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n             ebml_w.writer.write(name.get().as_bytes());\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n-            ebml_w.writer.write(value.as_bytes());\n+            ebml_w.writer.write(value.get().as_bytes());\n             ebml_w.end_tag();\n             ebml_w.end_tag();\n           }\n@@ -1563,7 +1563,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n         attr::mk_attr(\n             attr::mk_name_value_item_str(\n                 InternedString::new(\"crate_id\"),\n-                ecx.link_meta.crateid.to_str().to_managed()))\n+                token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))\n     }\n \n     let mut attrs = ~[];"}, {"sha": "228dbb0175596a794496717b62f8011a6831514b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -214,9 +214,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n \n type matrix = ~[~[@Pat]];\n \n-enum useful { useful(ty::t, ctor), useful_, not_useful }\n+#[deriving(Clone)]\n+enum useful {\n+    useful(ty::t, ctor),\n+    useful_,\n+    not_useful,\n+}\n \n-#[deriving(Eq)]\n+#[deriving(Clone, Eq)]\n enum ctor {\n     single,\n     variant(DefId),\n@@ -261,15 +266,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                                           val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n-                  ref u => *u,\n+                  ref u => (*u).clone(),\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n                 for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n-                      ref u => return *u,\n+                      ref u => return (*u).clone(),\n                     }\n                 }\n                 not_useful\n@@ -289,7 +294,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 for n in iter::range(0u, max_len + 1) {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n-                    ref u => return *u,\n+                    ref u => return (*u).clone(),\n                   }\n                 }\n                 not_useful\n@@ -304,15 +309,15 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n             match is_useful(cx,\n                             &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n-              useful_ => useful(left_ty, *ctor),\n-              ref u => *u,\n+              useful_ => useful(left_ty, (*ctor).clone()),\n+              ref u => (*u).clone(),\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n         let arity = ctor_arity(cx, v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, *v0_ctor, arity, left_ty)\n+        is_useful_specialized(cx, m, v, (*v0_ctor).clone(), arity, left_ty)\n       }\n     }\n }\n@@ -329,7 +334,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      ref u => *u,\n+      ref u => (*u).clone(),\n     }\n }\n \n@@ -407,7 +412,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n             let r = pat_ctor_id(cx, r[0]);\n             for id in r.iter() {\n                 if !found.contains(id) {\n-                    found.push(*id);\n+                    found.push((*id).clone());\n                 }\n             }\n         }\n@@ -770,8 +775,8 @@ fn specialize(cx: &MatchCheckCtxt,\n             }\n             PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => (*v, *v),\n-                    range(ref lo, ref hi) => (*lo, *hi),\n+                    val(ref v) => ((*v).clone(), (*v).clone()),\n+                    range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n                     single => return Some(r.tail().to_owned()),\n                     _ => fail!(\"type error\")\n                 };"}, {"sha": "68ac2f11bdaaf14f036f3f97963b38812948720b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -16,10 +16,11 @@ use middle::ty;\n use middle::typeck::astconv;\n use middle;\n \n-use syntax::{ast, ast_map, ast_util};\n-use syntax::visit;\n-use syntax::visit::Visitor;\n use syntax::ast::*;\n+use syntax::parse::token::InternedString;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+use syntax::{ast, ast_map, ast_util};\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n@@ -319,7 +320,7 @@ pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n-    const_str(@str),\n+    const_str(InternedString),\n     const_binary(@[u8]),\n     const_bool(bool)\n }\n@@ -508,7 +509,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n \n pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n-        LitStr(s, _) => const_str(s),\n+        LitStr(ref s, _) => const_str((*s).clone()),\n         LitBinary(data) => const_binary(data),\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),\n@@ -530,7 +531,7 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_int(a), &const_int(b)) => compare_vals(a, b),\n         (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n         (&const_float(a), &const_float(b)) => compare_vals(a, b),\n-        (&const_str(a), &const_str(b)) => compare_vals(a, b),\n+        (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n         _ => None\n     }"}, {"sha": "2b100ffa4c98d9cc4726216acb1587fb989153c9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -26,8 +26,9 @@ use middle::ty::{BuiltinBound, BoundFreeze, BoundPod, BoundSend, BoundSized};\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n-use syntax::visit;\n+use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n+use syntax::visit;\n \n use std::hashmap::HashMap;\n use std::iter::Enumerate;\n@@ -182,11 +183,11 @@ impl LanguageItemCollector {\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<@str> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     for attribute in attrs.iter() {\n         match attribute.name_str_pair() {\n-            Some((ref key, value)) if key.equiv(&(\"lang\")) => {\n-                return Some(value);\n+            Some((ref key, ref value)) if key.equiv(&(\"lang\")) => {\n+                return Some((*value).clone());\n             }\n             Some(..) | None => {}\n         }"}, {"sha": "12183632948046bc2ca68d1a855a40c0c9ccb8b0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -229,6 +229,7 @@ use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::parse::token::InternedString;\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -1174,7 +1175,7 @@ fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n struct DynamicFailureHandler<'a> {\n     bcx: &'a Block<'a>,\n     sp: Span,\n-    msg: @str,\n+    msg: InternedString,\n     finished: @Cell<Option<BasicBlockRef>>,\n }\n \n@@ -1187,7 +1188,7 @@ impl<'a> DynamicFailureHandler<'a> {\n \n         let fcx = self.bcx.fcx;\n         let fail_cx = fcx.new_block(false, \"case_fallthrough\", None);\n-        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n+        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg.clone());\n         self.finished.set(Some(fail_cx.llbb));\n         fail_cx.llbb\n     }\n@@ -1891,7 +1892,8 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n             let fail_handler = ~DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,\n-                msg: @\"scrutinizing value that can't exist\",\n+                msg: InternedString::new(\"scrutinizing value that can't \\\n+                                          exist\"),\n                 finished: fail_cx,\n             };\n             DynamicFailureHandlerClass(fail_handler)"}, {"sha": "42123f536d6e7d93836c3f6ebbb7e9e4f4d8e989", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -79,13 +79,18 @@ use std::local_data;\n use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr;\n+use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n+use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n use syntax::{ast, ast_util, ast_map};\n use syntax::attr::AttrMetaMethods;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::visit;\n use syntax::visit::Visitor;\n+use syntax::visit;\n+use syntax::{ast, ast_util, codemap, ast_map};\n \n pub use middle::trans::context::task_llcx;\n \n@@ -604,7 +609,8 @@ pub fn compare_scalar_types<'a>(\n             rslt(\n                 controlflow::trans_fail(\n                     cx, None,\n-                    @\"attempt to compare values of type type\"),\n+                    InternedString::new(\"attempt to compare values of type \\\n+                                         type\")),\n                 C_nil())\n         }\n         _ => {\n@@ -856,9 +862,9 @@ pub fn fail_if_zero<'a>(\n                     rhs_t: ty::t)\n                     -> &'a Block<'a> {\n     let text = if divrem == ast::BiDiv {\n-        @\"attempted to divide by zero\"\n+        \"attempted to divide by zero\"\n     } else {\n-        @\"attempted remainder with a divisor of zero\"\n+        \"attempted remainder with a divisor of zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n@@ -875,7 +881,7 @@ pub fn fail_if_zero<'a>(\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), text)\n+        controlflow::trans_fail(bcx, Some(span), InternedString::new(text))\n     })\n }\n \n@@ -1951,7 +1957,7 @@ fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.to_owned(),\n+        Some(name) => name.get().to_owned(),\n \n         // Don't mangle\n         _ if attr::contains_name(attrs, \"no_mangle\")\n@@ -2099,7 +2105,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match attr::first_attr_value_str_by_name(i.attrs, \"link_section\") {\n                         Some(sect) => unsafe {\n-                            sect.with_c_str(|buf| {\n+                            sect.get().with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n                             })\n                         },\n@@ -2161,9 +2167,9 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     ccx.crate_map\n                                 }\n                             } else {\n-                                let ident = foreign::link_name(ccx, ni);\n+                                let ident = foreign::link_name(ni);\n                                 unsafe {\n-                                    ident.with_c_str(|buf| {\n+                                    ident.get().with_c_str(|buf| {\n                                         let ty = type_of(ccx, ty);\n                                         llvm::LLVMAddGlobal(ccx.llmod,\n                                                             ty.to_ref(), buf)\n@@ -2476,21 +2482,21 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         let mut keys = ~[];\n         let module_data = ccx.module_data.borrow();\n         for (k, _) in module_data.get().iter() {\n-            keys.push(k.to_managed());\n+            keys.push(k.clone());\n         }\n         keys\n     };\n \n     for key in keys.iter() {\n-            let llstrval = C_str_slice(ccx, *key);\n-            let module_data = ccx.module_data.borrow();\n-            let val = *module_data.get().find_equiv(key).unwrap();\n-            let v_ptr = p2i(ccx, val);\n-            let elt = C_struct([\n-                llstrval,\n-                v_ptr\n-            ], false);\n-            elts.push(elt);\n+        let llstrval = C_str_slice(ccx, token::intern_and_get_ident(*key));\n+        let module_data = ccx.module_data.borrow();\n+        let val = *module_data.get().find_equiv(key).unwrap();\n+        let v_ptr = p2i(ccx, val);\n+        let elt = C_struct([\n+            llstrval,\n+            v_ptr\n+        ], false);\n+        elts.push(elt);\n     }\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));"}, {"sha": "a17ad98e42666154bb2a5de53731edbcf3c72e27", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -30,7 +30,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n-\n use arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cast::transmute;\n@@ -41,6 +40,7 @@ use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use syntax::ast::{Ident};\n use syntax::ast_map::{Path, PathElem, PathPrettyName};\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n \n@@ -597,18 +597,19 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n         {\n             let const_cstr_cache = cx.const_cstr_cache.borrow();\n-            match const_cstr_cache.get().find_equiv(&s) {\n+            match const_cstr_cache.get().find(&s) {\n                 Some(&llval) => return llval,\n                 None => ()\n             }\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.as_ptr() as *c_char, s.len() as c_uint,\n+                                                s.get().as_ptr() as *c_char,\n+                                                s.get().len() as c_uint,\n                                                 False);\n \n         let gsym = token::gensym(\"str\");\n@@ -627,9 +628,9 @@ pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n-        let len = s.len();\n+        let len = s.get().len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len)], false)\n     }\n@@ -970,7 +971,8 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n                                        -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-    let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(),\n+                               token::intern_and_get_ident(loc.file.name));\n     let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)"}, {"sha": "ddab6407f9df7116d93ffc6451744732e350e702", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -72,7 +72,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n-        ast::LitStr(s, _) => C_str_slice(cx, s),\n+        ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(data) => C_binary_slice(cx, data),\n     }\n }\n@@ -312,7 +312,9 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n-          ast::ExprLit(lit) => (consts::const_lit(cx, e, *lit), true),\n+          ast::ExprLit(lit) => {\n+              (consts::const_lit(cx, e, (*lit).clone()), true)\n+          }\n           ast::ExprBinary(_, b, e1, e2) => {\n             let (te1, _) = const_expr(cx, e1, is_local);\n             let (te2, _) = const_expr(cx, e2, is_local);"}, {"sha": "7968f0342098096297f3ad06469893789a5481ab", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -19,12 +19,12 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n-use middle::trans::debuginfo;\n use middle::trans::common::{C_i32, C_null};\n-use middle::ty;\n-\n+use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n+use middle::trans::base::{decl_crate_map};\n+use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n-\n+use middle::ty;\n use util::sha2::Sha256;\n \n use std::cell::{Cell, RefCell};\n@@ -33,10 +33,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::libc::c_uint;\n use syntax::ast;\n-\n-use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n-\n-use middle::trans::base::{decl_crate_map};\n+use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n      sess: session::Session,\n@@ -71,7 +68,7 @@ pub struct CrateContext {\n      // Cache generated vtables\n      vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n      // Cache of constant strings,\n-     const_cstr_cache: RefCell<HashMap<@str, ValueRef>>,\n+     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,"}, {"sha": "6de34d98941e8d7c329f2eb82b6b7ccdcface5c1", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -28,6 +28,8 @@ use syntax::ast;\n use syntax::ast::Name;\n use syntax::ast_util;\n use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n \n pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n@@ -342,14 +344,14 @@ pub fn trans_fail_expr<'a>(\n                     ppaux::ty_to_str(tcx, arg_datum.ty));\n             }\n         }\n-        _ => trans_fail(bcx, sp_opt, @\"explicit failure\")\n+        _ => trans_fail(bcx, sp_opt, InternedString::new(\"explicit failure\"))\n     }\n }\n \n pub fn trans_fail<'a>(\n                   bcx: &'a Block<'a>,\n                   sp_opt: Option<Span>,\n-                  fail_str: @str)\n+                  fail_str: InternedString)\n                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n@@ -367,11 +369,11 @@ fn trans_fail_value<'a>(\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        (C_cstr(bcx.ccx(), loc.file.name),\n+        (C_cstr(bcx.ccx(), token::intern_and_get_ident(loc.file.name)),\n          loc.line as int)\n       }\n       None => {\n-        (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n+        (C_cstr(bcx.ccx(), InternedString::new(\"<runtime>\")), 0)\n       }\n     };\n     let V_str = PointerCast(bcx, V_fail_str, Type::i8p());"}, {"sha": "b5c7284dca52824e3caccc56a9d631a3070e536d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -543,9 +543,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             let heap = heap_exchange;\n             return trans_boxed_expr(bcx, box_ty, contents, contents_ty, heap)\n         }\n-        ast::ExprLit(lit) => {\n-            trans_immediate_lit(bcx, expr, *lit)\n-        }\n+        ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n             {\n@@ -836,8 +834,8 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n-                    tvec::trans_lit_str(bcx, expr, s, dest)\n+                ast::LitStr(ref s, _) => {\n+                    tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n                     bcx.tcx()"}, {"sha": "bc9dd767ec670348a31d72baa6c4f750e69ab413", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -31,7 +31,8 @@ use std::vec;\n use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token;\n use syntax::{ast};\n use syntax::{attr, ast_map};\n use util::ppaux::{Repr, UserString};\n@@ -135,7 +136,7 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     };\n \n     // Register the function as a C extern fn\n-    let lname = link_name(ccx, foreign_item);\n+    let lname = link_name(foreign_item);\n     let tys = foreign_types_for_id(ccx, foreign_item.id);\n \n     // Make sure the calling convention is right for variadic functions\n@@ -150,8 +151,12 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     let llfn;\n     {\n         let mut externs = ccx.externs.borrow_mut();\n-        llfn = base::get_extern_fn(externs.get(), ccx.llmod, lname,\n-                                   cc, llfn_ty, tys.fn_sig.output);\n+        llfn = base::get_extern_fn(externs.get(),\n+                                   ccx.llmod,\n+                                   lname.get(),\n+                                   cc,\n+                                   llfn_ty,\n+                                   tys.fn_sig.output);\n     };\n     add_argument_attributes(&tys, llfn);\n \n@@ -372,9 +377,9 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n             _ => ()\n         }\n \n-        let lname = link_name(ccx, foreign_item);\n+        let lname = link_name(foreign_item);\n         let mut item_symbols = ccx.item_symbols.borrow_mut();\n-        item_symbols.get().insert(foreign_item.id, lname.to_owned());\n+        item_symbols.get().insert(foreign_item.id, lname.get().to_owned());\n     }\n }\n \n@@ -726,10 +731,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // This code is kind of a confused mess and needs to be reworked given\n // the massive simplifications that have occurred.\n \n-pub fn link_name(ccx: &CrateContext, i: @ast::ForeignItem) -> @str {\n+pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-        None => ccx.sess.str_of(i.ident),\n-        Some(ln) => ln,\n+        None => token::get_ident(i.ident.name),\n+        Some(ln) => ln.clone(),\n     }\n }\n "}, {"sha": "e002ecf04710c5b5d95c2fac3e39ddf03974b083", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -15,32 +15,33 @@\n \n use back::abi;\n use back::link::*;\n-use lib;\n use lib::llvm::{llvm, ValueRef, True};\n+use lib;\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::trans::adt;\n use middle::trans::base::*;\n+use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n-use middle::trans::build::*;\n+use middle::trans::datum::immediate_rvalue;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::type_of;\n use middle::ty;\n-use util::ppaux;\n use util::ppaux::ty_to_short_str;\n-\n-use middle::trans::type_::Type;\n+use util::ppaux;\n \n use arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cell::Cell;\n use std::libc::c_uint;\n use syntax::ast;\n+use syntax::parse::token;\n \n pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_free\");\n@@ -480,7 +481,8 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         }\n     });\n \n-    let ty_name = C_str_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n+    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx, t));\n+    let ty_name = C_estr_slice(ccx, ty_name);\n \n     let inf = @tydesc_info {\n         ty: t,"}, {"sha": "7e01f162bb1daabfff7214c04178748353f9dadf", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -20,6 +20,7 @@ use middle::trans::datum::*;\n use middle::trans::glue;\n use middle::trans::machine;\n use middle::trans::meth;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -31,9 +32,8 @@ use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::ast_map::PathName;\n-use syntax::parse::token::special_idents;\n-\n-use middle::trans::type_::Type;\n+use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token;\n \n pub struct Reflector<'a> {\n     visitor_val: ValueRef,\n@@ -56,14 +56,14 @@ impl<'a> Reflector<'a> {\n         C_bool(b)\n     }\n \n-    pub fn c_slice(&mut self, s: @str) -> ValueRef {\n+    pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::ReStatic);\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n-        let len = C_uint(bcx.ccx(), s.len());\n+        let len = C_uint(bcx.ccx(), s.get().len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n@@ -260,15 +260,19 @@ impl<'a> Reflector<'a> {\n                         fields[0].ident.name != special_idents::unnamed_field.name;\n               }\n \n-              let extra = ~[self.c_slice(ty_to_str(tcx, t).to_managed()),\n-                            self.c_bool(named_fields),\n-                            self.c_uint(fields.len())] + self.c_size_and_align(t);\n+              let extra = ~[\n+                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n+                                                                     t))),\n+                  self.c_bool(named_fields),\n+                  self.c_uint(fields.len())\n+              ] + self.c_size_and_align(t);\n               self.bracketed(\"class\", extra, |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = ~[this.c_uint(i),\n-                                    this.c_slice(bcx.ccx().sess.str_of(field.ident)),\n-                                    this.c_bool(named_fields)]\n-                          + this.c_mt(&field.mt);\n+                      let extra = ~[\n+                        this.c_uint(i),\n+                        this.c_slice(token::get_ident(field.ident.name)),\n+                        this.c_bool(named_fields)\n+                      ] + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n                   }\n               })\n@@ -330,7 +334,7 @@ impl<'a> Reflector<'a> {\n                 + self.c_size_and_align(t);\n             self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n-                    let name = ccx.sess.str_of(v.name);\n+                    let name = token::get_ident(v.name.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n@@ -352,7 +356,9 @@ impl<'a> Reflector<'a> {\n           }\n \n           ty::ty_trait(_, _, _, _, _) => {\n-              let extra = [self.c_slice(ty_to_str(tcx, t).to_managed())];\n+              let extra = [\n+                  self.c_slice(token::intern_and_get_ident(ty_to_str(tcx, t)))\n+              ];\n               self.visit(\"trait\", extra);\n           }\n "}, {"sha": "b0b7abbf66487840c4e39a5813633ab2f8df892d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -31,6 +31,7 @@ use middle::ty;\n use util::ppaux::ty_to_str;\n \n use syntax::ast;\n+use syntax::parse::token::InternedString;\n \n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n@@ -232,7 +233,10 @@ pub fn trans_slice_vstore<'a>(\n         ast::ExprLit(lit) => {\n             match lit.node {\n                 ast::LitStr(s, _) => {\n-                    return trans_lit_str(bcx, content_expr, s, dest);\n+                    return trans_lit_str(bcx,\n+                                         content_expr,\n+                                         (*s).clone(),\n+                                         dest)\n                 }\n                 _ => {}\n             }\n@@ -284,7 +288,7 @@ pub fn trans_slice_vstore<'a>(\n pub fn trans_lit_str<'a>(\n                      bcx: &'a Block<'a>,\n                      lit_expr: &ast::Expr,\n-                     str_lit: @str,\n+                     str_lit: InternedString,\n                      dest: Dest)\n                      -> &'a Block<'a> {\n     /*!\n@@ -301,7 +305,7 @@ pub fn trans_lit_str<'a>(\n         Ignore => bcx,\n         SaveIn(lldest) => {\n             unsafe {\n-                let bytes = str_lit.len();\n+                let bytes = str_lit.get().len();\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n@@ -337,11 +341,15 @@ pub fn trans_uniq_or_managed_vstore<'a>(bcx: &'a Block<'a>,\n                 ast::ExprLit(lit) => {\n                     match lit.node {\n                         ast::LitStr(s, _) => {\n-                            let llptrval = C_cstr(bcx.ccx(), s);\n-                            let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n+                            let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n+                            let llptrval = PointerCast(bcx,\n+                                                       llptrval,\n+                                                       Type::i8p());\n                             let llsizeval = C_uint(bcx.ccx(), s.len());\n                             let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n-                            let lldestval = rvalue_scratch_datum(bcx, typ, \"\");\n+                            let lldestval = rvalue_scratch_datum(bcx,\n+                                                                 typ,\n+                                                                 \"\");\n                             let alloc_fn = langcall(bcx,\n                                                     Some(lit.span),\n                                                     \"\",\n@@ -405,15 +413,13 @@ pub fn write_content<'a>(\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => {\n+                ast::LitStr(ref s, _) => {\n                     match dest {\n-                        Ignore => {\n-                            return bcx;\n-                        }\n+                        Ignore => return bcx,\n                         SaveIn(lldest) => {\n-                            let bytes = s.len();\n+                            let bytes = s.get().len();\n                             let llbytes = C_uint(bcx.ccx(), bytes);\n-                            let llcstr = C_cstr(bcx.ccx(), s);\n+                            let llcstr = C_cstr(bcx.ccx(), (*s).clone());\n                             base::call_memcpy(bcx,\n                                               lldest,\n                                               llcstr,\n@@ -516,7 +522,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     match content_expr.node {\n         ast::ExprLit(lit) => {\n             match lit.node {\n-                ast::LitStr(s, _) => s.len(),\n+                ast::LitStr(ref s, _) => s.get().len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"Unexpected evec content\")"}, {"sha": "4a4e7741982d780f5b67589e31c56dfa951c1a11", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -252,14 +252,16 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n         }\n     }\n \n-    fn value_str(&self) -> Option<@str> {\n+    fn value_str(&self) -> Option<InternedString> {\n         match **self {\n-            NameValue(_, ref v) => Some(v.to_managed()),\n+            NameValue(_, ref v) => Some(token::intern_and_get_ident(*v)),\n             _ => None,\n         }\n     }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n-    fn name_str_pair(&self) -> Option<(InternedString, @str)> { None }\n+    fn name_str_pair(&self) -> Option<(InternedString, InternedString)> {\n+        None\n+    }\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -1144,7 +1146,7 @@ impl ToSource for syntax::codemap::Span {\n \n fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n-        ast::LitStr(st, _) => st.to_owned(),\n+        ast::LitStr(ref st, _) => st.get().to_owned(),\n         ast::LitBinary(data) => format!(\"{:?}\", data.as_slice()),\n         ast::LitChar(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n         ast::LitInt(i, _t) => i.to_str(),"}, {"sha": "86b6a5734a5d8d07aba49f902600defb463235c0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -45,6 +45,7 @@ use extra::arc::Arc;\n use extra::json::ToJson;\n use syntax::ast;\n use syntax::attr;\n+use syntax::parse::token::InternedString;\n \n use clean;\n use doctree;\n@@ -803,12 +804,13 @@ impl<'a> Item<'a> {\n impl<'a> fmt::Default for Item<'a> {\n     fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) {\n         match attr::find_stability(it.item.attrs.iter()) {\n-            Some(stability) => {\n+            Some(ref stability) => {\n                 write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n-                           Some(s) => s, None => @\"\",\n+                           Some(ref s) => (*s).clone(),\n+                           None => InternedString::new(\"\"),\n                        });\n             }\n             None => {}"}, {"sha": "d806194ffbce531429ab246bb2914bfcd097c2bf", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -31,6 +31,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n use syntax::crateid::CrateId;\n@@ -317,8 +318,9 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(InternedString::new(\"crate_id\"),\n-                                         crate_id.to_str().to_managed());\n+            attr::mk_name_value_item_str(\n+                InternedString::new(\"crate_id\"),\n+                token::intern_and_get_ident(crate_id.to_str()));\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));\n@@ -646,7 +648,7 @@ pub fn find_and_install_dependencies(installer: &mut CrateInstaller,\n     visit::walk_crate(installer, c, ())\n }\n \n-pub fn mk_string_lit(s: @str) -> ast::Lit {\n+pub fn mk_string_lit(s: InternedString) -> ast::Lit {\n     Spanned {\n         node: ast::LitStr(s, ast::CookedStr),\n         span: DUMMY_SP"}, {"sha": "7416e21379270b4424768ad314d43f7eab6dcb39", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -722,7 +722,7 @@ pub type Lit = Spanned<Lit_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Lit_ {\n-    LitStr(@str, StrStyle),\n+    LitStr(InternedString, StrStyle),\n     LitBinary(@[u8]),\n     LitChar(u32),\n     LitInt(i64, IntTy),"}, {"sha": "78e9d3bd46f8c5c476d03de7b4f254f8d66a075e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -17,6 +17,7 @@ use codemap::BytePos;\n use diagnostic::SpanHandler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n+use parse::token;\n use crateid::CrateId;\n \n use std::hashmap::HashSet;\n@@ -34,24 +35,26 @@ pub trait AttrMetaMethods {\n      * Gets the string value if self is a MetaNameValue variant\n      * containing a string, otherwise None.\n      */\n-    fn value_str(&self) -> Option<@str>;\n+    fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]>;\n \n     /**\n      * If the meta item is a name-value type with a string value then returns\n      * a tuple containing the name and string value, otherwise `None`\n      */\n-    fn name_str_pair(&self) -> Option<(InternedString, @str)>;\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)>;\n }\n \n impl AttrMetaMethods for Attribute {\n     fn name(&self) -> InternedString { self.meta().name() }\n-    fn value_str(&self) -> Option<@str> { self.meta().value_str() }\n+    fn value_str(&self) -> Option<InternedString> {\n+        self.meta().value_str()\n+    }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         self.node.value.meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n         self.meta().name_str_pair()\n     }\n }\n@@ -65,11 +68,11 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn value_str(&self) -> Option<@str> {\n+    fn value_str(&self) -> Option<InternedString> {\n         match self.node {\n             MetaNameValue(_, ref v) => {\n                 match v.node {\n-                    ast::LitStr(s, _) => Some(s),\n+                    ast::LitStr(ref s, _) => Some((*s).clone()),\n                     _ => None,\n                 }\n             },\n@@ -84,19 +87,19 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n         self.value_str().map(|s| (self.name(), s))\n     }\n }\n \n // Annoying, but required to get test_cfg to work\n impl AttrMetaMethods for @MetaItem {\n     fn name(&self) -> InternedString { (**self).name() }\n-    fn value_str(&self) -> Option<@str> { (**self).value_str() }\n+    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [@MetaItem]> {\n         (**self).meta_item_list()\n     }\n-    fn name_str_pair(&self) -> Option<(InternedString, @str)> {\n+    fn name_str_pair(&self) -> Option<(InternedString,InternedString)> {\n         (**self).name_str_pair()\n     }\n }\n@@ -119,8 +122,10 @@ impl AttributeMethods for Attribute {\n     fn desugar_doc(&self) -> Attribute {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n-            let meta = mk_name_value_item_str(InternedString::new(\"doc\"),\n-                                              strip_doc_comment_decoration(comment).to_managed());\n+            let meta = mk_name_value_item_str(\n+                InternedString::new(\"doc\"),\n+                token::intern_and_get_ident(strip_doc_comment_decoration(\n+                        comment.get())));\n             mk_attr(meta)\n         } else {\n             *self\n@@ -130,7 +135,7 @@ impl AttributeMethods for Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: InternedString, value: @str)\n+pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n                               -> @MetaItem {\n     let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n@@ -157,8 +162,9 @@ pub fn mk_attr(item: @MetaItem) -> Attribute {\n     })\n }\n \n-pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n-    let style = doc_comment_style(text);\n+pub fn mk_sugared_doc_attr(text: InternedString, lo: BytePos, hi: BytePos)\n+                           -> Attribute {\n+    let style = doc_comment_style(text.get());\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         style: style,\n@@ -191,14 +197,14 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<@str> {\n+                                 -> Option<InternedString> {\n     attrs.iter()\n         .find(|at| at.name().equiv(&name))\n         .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n-                                     -> Option<@str> {\n+                                     -> Option<InternedString> {\n     items.rev_iter()\n          .find(|mi| mi.name().equiv(&name))\n          .and_then(|i| i.value_str())\n@@ -247,7 +253,7 @@ pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n pub fn find_crateid(attrs: &[Attribute]) -> Option<CrateId> {\n     match first_attr_value_str_by_name(attrs, \"crate_id\") {\n         None => None,\n-        Some(id) => from_str::<CrateId>(id),\n+        Some(id) => from_str::<CrateId>(id.get()),\n     }\n }\n \n@@ -331,7 +337,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n /// Represents the #[deprecated=\"foo\"] (etc) attributes.\n pub struct Stability {\n     level: StabilityLevel,\n-    text: Option<@str>\n+    text: Option<InternedString>\n }\n \n /// The available stability levels.\n@@ -346,7 +352,8 @@ pub enum StabilityLevel {\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> Option<Stability> {\n+pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n+                      -> Option<Stability> {\n     for m in metas {\n         let level = match m.name().get() {\n             \"deprecated\" => Deprecated,"}, {"sha": "babf0f13874169d9d9a1a5c850cd489dcf2ad27f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -17,6 +17,7 @@ use codemap::Span;\n use ext::base;\n use ext::base::*;\n use parse;\n+use parse::token::InternedString;\n use parse::token;\n \n enum State {\n@@ -43,7 +44,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                            cx.cfg(),\n                                            tts.to_owned());\n \n-    let mut asm = @\"\";\n+    let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = ~[];\n     let mut inputs = ~[];\n@@ -191,7 +192,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MRExpr(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n-            asm: asm,\n+            asm: asm.get().to_managed(),\n             asm_str_style: asm_str_style.unwrap(),\n             clobbers: cons.to_managed(),\n             inputs: inputs,"}, {"sha": "eda0a47148a4f3850cab80b001edaec761524874", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -16,7 +16,7 @@ use ext;\n use ext::expand;\n use parse;\n use parse::token;\n-use parse::token::{ident_to_str, intern, str_to_ident};\n+use parse::token::{InternedString, ident_to_str, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use std::hashmap::HashMap;\n@@ -407,11 +407,11 @@ impl<'a> ExtCtxt<'a> {\n /// Extract a string literal from `expr`, emitting `err_msg` if `expr`\n /// is not a string literal. This does not stop compilation on error,\n /// merely emits a non-fatal error and returns None.\n-pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr,\n-                   err_msg: &str) -> Option<(@str, ast::StrStyle)> {\n+pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str)\n+                   -> Option<(InternedString, ast::StrStyle)> {\n     match expr.node {\n         ast::ExprLit(l) => match l.node {\n-            ast::LitStr(s, style) => return Some((s, style)),\n+            ast::LitStr(s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -424,7 +424,9 @@ pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr,\n /// compilation should call\n /// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n /// done as rarely as possible).\n-pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree],\n+pub fn check_zero_tts(cx: &ExtCtxt,\n+                      sp: Span,\n+                      tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_err(sp, format!(\"{} takes no arguments\", name));"}, {"sha": "c5ee19484668e675f3194d23dde290ef6c188490", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -19,6 +19,7 @@ use fold::Folder;\n use opt_vec;\n use opt_vec::OptVec;\n use parse::token::special_idents;\n+use parse::token;\n \n pub struct Field {\n     ident: ast::Ident,\n@@ -134,13 +135,13 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr;\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr;\n+    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n \n     fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n     fn expr_none(&self, sp: Span) -> @ast::Expr;\n \n-    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr;\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr;\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n@@ -589,10 +590,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n-    fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr {\n+    fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n         self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n-    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr {\n+    fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n     }\n \n@@ -620,7 +621,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n-    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr {\n+    fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -631,13 +632,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             ],\n             ~[\n                 self.expr_str(span, msg),\n-                self.expr_str(span, loc.file.name),\n+                self.expr_str(span,\n+                              token::intern_and_get_ident(loc.file.name)),\n                 self.expr_uint(span, loc.line),\n             ])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n-        self.expr_fail(span, @\"internal error: entered unreachable code\")\n+        self.expr_fail(span,\n+                       InternedString::new(\n+                           \"internal error: entered unreachable code\"))\n     }\n \n "}, {"sha": "6852a0cec33ac4b3507e3fbbbd84dee6363922a4", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -31,8 +31,8 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n             // expression is a literal\n             ast::ExprLit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n-                ast::LitStr(s, _) => {\n-                    for byte in s.bytes() {\n+                ast::LitStr(ref s, _) => {\n+                    for byte in s.get().bytes() {\n                         bytes.push(cx.expr_u8(expr.span, byte));\n                     }\n                 }"}, {"sha": "f570ca4c1bf1801ac33b018feaa0bc341c6b4425", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -14,6 +14,7 @@ use ast;\n use codemap;\n use ext::base;\n use ext::build::AstBuilder;\n+use parse::token;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n@@ -28,8 +29,10 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n         match e.node {\n             ast::ExprLit(lit) => {\n                 match lit.node {\n-                    ast::LitStr(s, _) | ast::LitFloat(s, _)\n-                    | ast::LitFloatUnsuffixed(s) => {\n+                    ast::LitStr(ref s, _) => {\n+                        accumulator.push_str(s.get());\n+                    }\n+                    ast::LitFloat(s, _) | ast::LitFloatUnsuffixed(s) => {\n                         accumulator.push_str(s);\n                     }\n                     ast::LitChar(c) => {\n@@ -55,5 +58,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    return base::MRExpr(cx.expr_str(sp, accumulator.to_managed()));\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(accumulator)))\n }"}, {"sha": "019a4dfe7cca4573b162078dbb205d6253958b53", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -18,6 +18,8 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n+use parse::token;\n \n pub fn expand_deriving_decodable(cx: &ExtCtxt,\n                                  span: Span,\n@@ -82,10 +84,15 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n             });\n-            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_struct\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(trait_span, nfields),\n-                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n+            cx.expr_method_call(trait_span,\n+                                decoder,\n+                                cx.ident_of(\"read_struct\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_uint(trait_span, nfields),\n+                cx.lambda_expr_1(trait_span, result, blkarg)\n+            ])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -95,7 +102,8 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, cx.str_of(name)));\n+                variants.push(cx.expr_str(v_span,\n+                                          token::get_ident(name.name)));\n \n                 let decoded = decode_static_fields(cx,\n                                                    v_span,\n@@ -120,9 +128,14 @@ fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n                                              ~[variant_vec, lambda]);\n-            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_enum\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n+            cx.expr_method_call(trait_span,\n+                                decoder,\n+                                cx.ident_of(\"read_enum\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.lambda_expr_1(trait_span, result, blkarg)\n+            ])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n@@ -135,15 +148,18 @@ fn decode_static_fields(cx: &ExtCtxt,\n                         trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: |Span, @str, uint| -> @Expr)\n+                        getarg: |Span, InternedString, uint| -> @Expr)\n                         -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {\n                 cx.expr_ident(trait_span, outer_pat_ident)\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n-                    getarg(span, format!(\"_field{}\", i).to_managed(), i)\n+                    getarg(span,\n+                           token::intern_and_get_ident(format!(\"_field{}\",\n+                                                               i)),\n+                           i)\n                 }).collect();\n \n                 cx.expr_call_ident(trait_span, outer_pat_ident, fields)\n@@ -152,7 +168,9 @@ fn decode_static_fields(cx: &ExtCtxt,\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n-                cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n+                cx.field_imm(span,\n+                             name,\n+                             getarg(span, token::get_ident(name.name), i))\n             }).collect();\n             cx.expr_struct_ident(trait_span, outer_pat_ident, fields)\n         }"}, {"sha": "1dfc5b59e062ef2b4befd5a3c95260d0c837a1f3", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -80,6 +80,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token;\n \n pub fn expand_deriving_encodable(cx: &ExtCtxt,\n                                  span: Span,\n@@ -125,10 +126,17 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for (i, &FieldInfo { name, self_, span, .. }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo {\n+                    name,\n+                    self_,\n+                    span,\n+                    ..\n+                }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => cx.str_of(id),\n-                    None => format!(\"_field{}\", i).to_managed()\n+                    Some(id) => token::get_ident(id),\n+                    None => {\n+                        token::intern_and_get_ident(format!(\"_field{}\", i))\n+                    }\n                 };\n                 let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n@@ -141,10 +149,15 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            cx.expr_method_call(trait_span, encoder, cx.ident_of(\"emit_struct\"),\n-                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(trait_span, fields.len()),\n-                                  blk])\n+            cx.expr_method_call(trait_span,\n+                                encoder,\n+                                cx.ident_of(\"emit_struct\"),\n+                                ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                cx.expr_uint(trait_span, fields.len()),\n+                blk\n+            ])\n         }\n \n         EnumMatching(idx, variant, ref fields) => {\n@@ -167,19 +180,23 @@ fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, cx.str_of(variant.node.name));\n+            let name = cx.expr_str(trait_span,\n+                                   token::get_ident(variant.node.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,\n                                              cx.expr_uint(trait_span, idx),\n                                              cx.expr_uint(trait_span, fields.len()),\n                                              blk]);\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n-            let ret = cx.expr_method_call(trait_span, encoder,\n+            let ret = cx.expr_method_call(trait_span,\n+                                          encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[cx.expr_str(trait_span,\n-                                            cx.str_of(substr.type_ident)),\n-                                            blk]);\n+                                          ~[\n+                cx.expr_str(trait_span,\n+                            token::get_ident(substr.type_ident.name)),\n+                blk\n+            ]);\n             cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n         }\n "}, {"sha": "45e3be7f23d0e252ce3814bb649f2816fd53b66b", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -185,6 +185,7 @@ use codemap;\n use codemap::Span;\n use opt_vec;\n use parse::token::InternedString;\n+use parse::token;\n \n use std::vec;\n \n@@ -398,7 +399,9 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             cx.meta_name_value(self.span,\n                                InternedString::new(\"doc\"),\n-                               ast::LitStr(@\"Automatically derived.\", ast::CookedStr)));\n+                               ast::LitStr(token::intern_and_get_ident(\n+                                       \"Automatically derived.\"),\n+                                       ast::CookedStr)));\n         cx.item(\n             self.span,\n             ::parse::token::special_idents::clownshoes_extensions,"}, {"sha": "e2f72e8708551adea5a574b95868316cb52d0754", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -14,6 +14,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n \n pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n                                       span: Span,\n@@ -73,13 +74,13 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n     match *substr.fields {\n         StaticStruct(..) => {\n             cx.span_err(trait_span, \"`FromPrimitive` cannot be derived for structs\");\n-            return cx.expr_fail(trait_span, @\"\");\n+            return cx.expr_fail(trait_span, InternedString::new(\"\"));\n         }\n         StaticEnum(enum_def, _) => {\n             if enum_def.variants.is_empty() {\n                 cx.span_err(trait_span,\n                             \"`FromPrimitive` cannot be derived for enums with no variants\");\n-                return cx.expr_fail(trait_span, @\"\");\n+                return cx.expr_fail(trait_span, InternedString::new(\"\"));\n             }\n \n             let mut arms = ~[];\n@@ -91,7 +92,8 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n                             cx.span_err(trait_span,\n                                         \"`FromPrimitive` cannot be derived for \\\n                                         enum variants with arguments\");\n-                            return cx.expr_fail(trait_span, @\"\");\n+                            return cx.expr_fail(trait_span,\n+                                                InternedString::new(\"\"));\n                         }\n                         let span = variant.span;\n \n@@ -117,7 +119,8 @@ fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) ->\n                         cx.span_err(trait_span,\n                                     \"`FromPrimitive` cannot be derived for enums \\\n                                     with struct variants\");\n-                        return cx.expr_fail(trait_span, @\"\");\n+                        return cx.expr_fail(trait_span,\n+                                            InternedString::new(\"\"));\n                     }\n                 }\n             }"}, {"sha": "97412595b29c38f4dac72583098b817b894a5108", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -14,6 +14,8 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+use parse::token::InternedString;\n+use parse::token;\n \n pub fn expand_deriving_to_str(cx: &ExtCtxt,\n                               span: Span,\n@@ -47,18 +49,20 @@ pub fn expand_deriving_to_str(cx: &ExtCtxt,\n // doesn't invoke the to_str() method on each field. Hence we mirror\n // the logic of the repr_to_str() method, but with tweaks to call to_str()\n // on sub-fields.\n-fn to_str_substructure(cx: &ExtCtxt, span: Span,\n-                       substr: &Substructure) -> @Expr {\n+fn to_str_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure)\n+                       -> @Expr {\n     let to_str = cx.ident_of(\"to_str\");\n \n-    let doit = |start: &str, end: @str, name: ast::Ident,\n+    let doit = |start: &str,\n+                end: InternedString,\n+                name: ast::Ident,\n                 fields: &[FieldInfo]| {\n         if fields.len() == 0 {\n-            cx.expr_str_uniq(span, cx.str_of(name))\n+            cx.expr_str_uniq(span, token::get_ident(name.name))\n         } else {\n             let buf = cx.ident_of(\"buf\");\n-            let start = cx.str_of(name) + start;\n-            let init = cx.expr_str_uniq(span, start.to_managed());\n+            let start = token::intern_and_get_ident(cx.str_of(name) + start);\n+            let init = cx.expr_str_uniq(span, start);\n             let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n             let push_str = cx.ident_of(\"push_str\");\n \n@@ -70,38 +74,52 @@ fn to_str_substructure(cx: &ExtCtxt, span: Span,\n \n             for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    push(cx.expr_str(span, @\", \"));\n+                    push(cx.expr_str(span, InternedString::new(\", \")));\n                 }\n                 match name {\n                     None => {}\n                     Some(id) => {\n                         let name = cx.str_of(id) + \": \";\n-                        push(cx.expr_str(span, name.to_managed()));\n+                        push(cx.expr_str(span,\n+                                         token::intern_and_get_ident(name)));\n                     }\n                 }\n                 push(cx.expr_method_call(span, self_, to_str, ~[]));\n             }\n             push(cx.expr_str(span, end));\n \n-            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span, buf))))\n+            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span,\n+                                                                   buf))))\n         }\n     };\n \n     return match *substr.fields {\n         Struct(ref fields) => {\n             if fields.len() == 0 || fields[0].name.is_none() {\n-                doit(\"(\", @\")\", substr.type_ident, *fields)\n+                doit(\"(\",\n+                     InternedString::new(\")\"),\n+                     substr.type_ident,\n+                     *fields)\n             } else {\n-                doit(\"{\", @\"}\", substr.type_ident, *fields)\n+                doit(\"{\",\n+                     InternedString::new(\"}\"),\n+                     substr.type_ident,\n+                     *fields)\n             }\n         }\n \n         EnumMatching(_, variant, ref fields) => {\n             match variant.node.kind {\n                 ast::TupleVariantKind(..) =>\n-                    doit(\"(\", @\")\", variant.node.name, *fields),\n+                    doit(\"(\",\n+                         InternedString::new(\")\"),\n+                         variant.node.name,\n+                         *fields),\n                 ast::StructVariantKind(..) =>\n-                    doit(\"{\", @\"}\", variant.node.name, *fields),\n+                    doit(\"{\",\n+                         InternedString::new(\"}\"),\n+                         variant.node.name,\n+                         *fields),\n             }\n         }\n "}, {"sha": "c23a1ce1e28d5f8592ec559bec8a12323cf1b7bb", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -19,6 +19,7 @@ use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n+use parse::token;\n \n use std::os;\n \n@@ -52,7 +53,11 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some((v, _style)) => v\n     };\n     let msg = match exprs.len() {\n-        1 => format!(\"environment variable `{}` not defined\", var).to_managed(),\n+        1 => {\n+            token::intern_and_get_ident(format!(\"environment variable `{}` \\\n+                                                 not defined\",\n+                                                var))\n+        }\n         2 => {\n             match expr_to_str(cx, exprs[1], \"expected string literal\") {\n                 None => return MacResult::dummy_expr(),\n@@ -65,12 +70,12 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     };\n \n-    let e = match os::getenv(var) {\n+    let e = match os::getenv(var.get()) {\n         None => {\n-            cx.span_err(sp, msg);\n+            cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, s.to_managed())\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s))\n     };\n     MRExpr(e)\n }"}, {"sha": "5bedb1a887e2c164b78fa534d24d1121ada18156", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -416,7 +416,7 @@ impl<'a> Context<'a> {\n                         let result = arm.result.iter().map(|p| {\n                             self.trans_piece(p)\n                         }).collect();\n-                        let s = arm.selector.to_managed();\n+                        let s = token::intern_and_get_ident(arm.selector);\n                         let selector = self.ecx.expr_str(sp, s);\n                         self.ecx.expr_struct(sp, p, ~[\n                             self.ecx.field_imm(sp,\n@@ -492,8 +492,12 @@ impl<'a> Context<'a> {\n \n         match *piece {\n             parse::String(s) => {\n-                self.ecx.expr_call_global(sp, rtpath(\"String\"),\n-                                          ~[self.ecx.expr_str(sp, s.to_managed())])\n+                let s = token::intern_and_get_ident(s);\n+                self.ecx.expr_call_global(sp,\n+                                          rtpath(\"String\"),\n+                                          ~[\n+                    self.ecx.expr_str(sp, s)\n+                ])\n             }\n             parse::CurrentArgument => {\n                 let nil = self.ecx.expr_lit(sp, ast::LitNil);\n@@ -763,8 +767,9 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n     let expr = cx.ecx.expand_expr(efmt);\n-    let fmt = match expr_to_str(cx.ecx, expr,\n-                                     \"format argument must be a string literal.\") {\n+    let fmt = match expr_to_str(cx.ecx,\n+                                expr,\n+                                \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n         None => return MacResult::dummy_expr()\n     };\n@@ -776,7 +781,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n             cx.ecx.span_err(efmt.span, m);\n         }\n     }).inside(|| {\n-        for piece in parse::Parser::new(fmt) {\n+        for piece in parse::Parser::new(fmt.get()) {\n             if !err {\n                 cx.verify_piece(&piece);\n                 let piece = cx.trans_piece(&piece);"}, {"sha": "425ac8865b274949c405557650fe4bf41b7e88f1", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -31,6 +31,7 @@ use parse;\n pub mod rt {\n     use ast;\n     use ext::base::ExtCtxt;\n+    use parse::token;\n     use parse;\n     use print::pprust;\n \n@@ -118,7 +119,8 @@ pub mod rt {\n \n     impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::LitStr(self.to_managed(), ast::CookedStr));\n+            let lit = dummy_spanned(ast::LitStr(\n+                    token::intern_and_get_ident(*self), ast::CookedStr));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n@@ -349,7 +351,7 @@ fn id_ext(str: &str) -> ast::Ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n-    let e_str = cx.expr_str(sp, cx.str_of(ident));\n+    let e_str = cx.expr_str(sp, token::get_ident(ident.name));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),"}, {"sha": "b67f3ed263ea929864dfe9b01f381c07db0bba24", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -16,7 +16,8 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n-use parse::token::{get_ident_interner};\n+use parse::token::get_ident_interner;\n+use parse::token;\n use print::pprust;\n \n use std::io;\n@@ -57,21 +58,21 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = loc.file.name;\n+    let filename = token::intern_and_get_ident(loc.file.name);\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n-    base::MRExpr(cx.expr_str(sp, s.to_managed()))\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    base::MRExpr(cx.expr_str(sp,\n-                             cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\").to_managed()))\n+    let string = cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\");\n+    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }\n \n // include! : parse the given file as an expr\n@@ -117,7 +118,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let filename = file.display().to_str().to_managed();\n             cx.parse_sess.cm.new_filemap(filename, src);\n \n-            base::MRExpr(cx.expr_str(sp, src))\n+            base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(src)))\n         }\n         None => {\n             cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));"}, {"sha": "9a346e17d287eb743121e92b9093f1c7d64bdd7e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -326,7 +326,9 @@ fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n                     MetaList((*id).clone(), mis.map(|e| fold_meta_item(*e)))\n                 }\n-                MetaNameValue(ref id, s) => MetaNameValue((*id).clone(), s)\n+                MetaNameValue(ref id, ref s) => {\n+                    MetaNameValue((*id).clone(), (*s).clone())\n+                }\n             },\n         span: fld.new_span(mi.span) }\n }"}, {"sha": "c9bea78d02db5acac5e8f0fa77d8669052cf5876", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -45,7 +45,7 @@ impl ParserAttr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                    self.id_to_str(s),\n+                    self.id_to_interned_str(s),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -133,7 +133,7 @@ impl ParserAttr for Parser {\n                 }\n                 token::DOC_COMMENT(s) => {\n                     self.bump();\n-                    ::attr::mk_sugared_doc_attr(self.id_to_str(s),\n+                    ::attr::mk_sugared_doc_attr(self.id_to_interned_str(s),\n                                                 self.span.lo,\n                                                 self.span.hi)\n                 }"}, {"sha": "21a34ab5e1e6c7a3fef7442d48f0f7f31ec61506", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -54,7 +54,6 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n }\n \n pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n-\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n         let mut i = 0u;"}, {"sha": "636dc504ff24ebbd601155e58fc4d9c579134342", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -345,7 +345,7 @@ pub struct Parser {\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    mod_path_stack: ~[@str],\n+    mod_path_stack: ~[InternedString],\n     /// Stack of spans of open delimiters. Used for error message.\n     open_braces: ~[Span],\n     /* do not copy the parser; its state is tied to outside state */\n@@ -1408,8 +1408,12 @@ impl Parser {\n             token::LIT_FLOAT(s, ft) => LitFloat(self.id_to_str(s), ft),\n             token::LIT_FLOAT_UNSUFFIXED(s) =>\n                 LitFloatUnsuffixed(self.id_to_str(s)),\n-            token::LIT_STR(s) => LitStr(self.id_to_str(s), ast::CookedStr),\n-            token::LIT_STR_RAW(s, n) => LitStr(self.id_to_str(s), ast::RawStr(n)),\n+            token::LIT_STR(s) => {\n+                LitStr(self.id_to_interned_str(s), ast::CookedStr)\n+            }\n+            token::LIT_STR_RAW(s, n) => {\n+                LitStr(self.id_to_interned_str(s), ast::RawStr(n))\n+            }\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }\n@@ -4146,11 +4150,11 @@ impl Parser {\n     }\n \n     fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n-        let default_path = token::interner_get(id.name);\n+        let default_path = self.id_to_interned_str(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n                                                                    \"path\") {\n             Some(d) => d,\n-            None => default_path\n+            None => default_path,\n         };\n         self.mod_path_stack.push(file_path)\n     }"}, {"sha": "9291cba54f634c79ad2ff674f31bba033429aa8e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -20,6 +20,7 @@ use std::cast;\n use std::char;\n use std::fmt;\n use std::local_data;\n+use std::path::BytesContainer;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n@@ -537,7 +538,7 @@ pub fn get_ident_interner() -> @IdentInterner {\n /// be fixed in the future by just leaking all strings until task death\n /// somehow.\n #[no_send]\n-#[deriving(Clone, Eq, IterBytes, TotalEq, TotalOrd)]\n+#[deriving(Clone, Eq, IterBytes, Ord, TotalEq, TotalOrd)]\n pub struct InternedString {\n     priv string: @str,\n }\n@@ -571,6 +572,17 @@ impl InternedString {\n     }\n }\n \n+impl BytesContainer for InternedString {\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        // XXX(pcwalton): This is a workaround for the incorrect signature of\n+        // `BytesContainer`, which is itself a workaround for the lack of DST.\n+        unsafe {\n+            let this = self.get();\n+            cast::transmute(this.container_as_bytes())\n+        }\n+    }\n+}\n+\n impl fmt::Default for InternedString {\n     fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n         write!(f.buf, \"{}\", obj.string);"}, {"sha": "32b0766249e7347184cd8a48fb335162e88b1421", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8e52b85d5a6f6e3aaa2f15d7c1e907d0ce8589ee", "patch": "@@ -897,7 +897,7 @@ pub fn print_attribute(s: &mut State, attr: &ast::Attribute) {\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-        word(&mut s.s, comment);\n+        word(&mut s.s, comment.get());\n     } else {\n         word(&mut s.s, \"#[\");\n         print_meta_item(s, attr.meta());\n@@ -1931,10 +1931,10 @@ pub fn print_meta_item(s: &mut State, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::MetaWord(ref name) => word(&mut s.s, name.get()),\n-      ast::MetaNameValue(ref name, value) => {\n+      ast::MetaNameValue(ref name, ref value) => {\n         word_space(s, name.get());\n         word_space(s, \"=\");\n-        print_literal(s, &value);\n+        print_literal(s, value);\n       }\n       ast::MetaList(ref name, ref items) => {\n         word(&mut s.s, name.get());\n@@ -2172,7 +2172,7 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) {\n       _ => ()\n     }\n     match lit.node {\n-      ast::LitStr(st, style) => print_string(s, st, style),\n+      ast::LitStr(ref st, style) => print_string(s, st.get(), style),\n       ast::LitChar(ch) => {\n           let mut res = ~\"'\";\n           char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));"}]}