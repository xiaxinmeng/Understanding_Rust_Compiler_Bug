{"sha": "fa1b15f6279a95923b8a19046f45f27f243d49d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMWIxNWY2Mjc5YTk1OTIzYjhhMTkwNDZmNDVmMjdmMjQzZDQ5ZDI=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-04T00:06:30Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-08T04:29:34Z"}, "message": "Preserve the parent module of `DocFragment`s\n\n- Add `parent_module` to `DocFragment`\n- Require the `parent_module` of the item being inlined\n- Preserve the hir_id for ExternCrates so rustdoc can find the parent module later\n- Take an optional `parent_module` for `build_impl` and `merge_attrs`.\n  Preserve the difference between parent modules for each doc-comment.\n- Support arbitrarily many re-exports in from_ast. In retrospect this is\n  probably not used and could be simplified to a single\n  `Option<(Attrs, DefId)>`.\n- Don't require the parent_module for all `impl`s, just inlined items\n\n  In particular, this will be `None` whenever the attribute is not on a\n  re-export.\n\n- Only store the parent_module, not the HirId\n\n  When re-exporting a re-export, the HirId is not available. Fortunately,\n  `collect_intra_doc_links` doesn't actually need all the info from a\n  HirId, just the parent module.", "tree": {"sha": "de8765437d0af99459b288bdb1e2c5810fb67a4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de8765437d0af99459b288bdb1e2c5810fb67a4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa1b15f6279a95923b8a19046f45f27f243d49d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1b15f6279a95923b8a19046f45f27f243d49d2", "html_url": "https://github.com/rust-lang/rust/commit/fa1b15f6279a95923b8a19046f45f27f243d49d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa1b15f6279a95923b8a19046f45f27f243d49d2/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4437b4b1509c3c15b41a05489c4bddd2fe30e33f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4437b4b1509c3c15b41a05489c4bddd2fe30e33f", "html_url": "https://github.com/rust-lang/rust/commit/4437b4b1509c3c15b41a05489c4bddd2fe30e33f"}], "stats": {"total": 141, "additions": 101, "deletions": 40}, "files": [{"sha": "a6c754ab67f617b7ce295bf0bbbc02f1fdca1e5c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use crate::clean::{self, GetDefId, ToSource, TypeKind};\n+use crate::clean::{self, Attributes, GetDefId, ToSource, TypeKind};\n use crate::core::DocContext;\n use crate::doctree;\n \n@@ -35,8 +35,11 @@ type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n+///\n+/// `parent_module` refers to the parent of the *re-export*, not the original item.\n pub fn try_inline(\n     cx: &DocContext<'_>,\n+    parent_module: DefId,\n     res: Res,\n     name: Symbol,\n     attrs: Option<Attrs<'_>>,\n@@ -48,12 +51,13 @@ pub fn try_inline(\n     }\n     let mut ret = Vec::new();\n \n+    debug!(\"attrs={:?}\", attrs);\n     let attrs_clone = attrs;\n \n     let inner = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -62,27 +66,27 @@ pub fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -117,7 +121,7 @@ pub fn try_inline(\n     };\n \n     let target_attrs = load_attrs(cx, did);\n-    let attrs = merge_attrs(cx, target_attrs, attrs_clone);\n+    let attrs = merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n \n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n@@ -291,40 +295,52 @@ pub fn build_ty(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n }\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n-pub fn build_impls(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>) -> Vec<clean::Item> {\n+pub fn build_impls(\n+    cx: &DocContext<'_>,\n+    parent_module: Option<DefId>,\n+    did: DefId,\n+    attrs: Option<Attrs<'_>>,\n+) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, did, attrs, &mut impls);\n+        build_impl(cx, parent_module, did, attrs, &mut impls);\n     }\n \n     impls\n }\n \n+/// `parent_module` refers to the parent of the re-export, not the original item\n fn merge_attrs(\n     cx: &DocContext<'_>,\n-    attrs: Attrs<'_>,\n-    other_attrs: Option<Attrs<'_>>,\n+    parent_module: Option<DefId>,\n+    old_attrs: Attrs<'_>,\n+    new_attrs: Option<Attrs<'_>>,\n ) -> clean::Attributes {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n-    let merged_attrs = if let Some(inner) = other_attrs {\n-        let mut both = inner.to_vec();\n-        both.extend_from_slice(attrs);\n-        both\n+    if let Some(inner) = new_attrs {\n+        if let Some(new_id) = parent_module {\n+            let diag = cx.sess().diagnostic();\n+            Attributes::from_ast(diag, old_attrs, Some((inner, new_id)))\n+        } else {\n+            let mut both = inner.to_vec();\n+            both.extend_from_slice(old_attrs);\n+            both.clean(cx)\n+        }\n     } else {\n-        attrs.to_vec()\n-    };\n-    merged_attrs.clean(cx)\n+        old_attrs.clean(cx)\n+    }\n }\n \n /// Builds a specific implementation of a type. The `did` could be a type method or trait method.\n pub fn build_impl(\n     cx: &DocContext<'_>,\n+    parent_module: impl Into<Option<DefId>>,\n     did: DefId,\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n@@ -333,7 +349,8 @@ pub fn build_impl(\n         return;\n     }\n \n-    let attrs = merge_attrs(cx, load_attrs(cx, did), attrs);\n+    let attrs = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n+    debug!(\"merged_attrs={:?}\", attrs);\n \n     let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);\n@@ -499,7 +516,9 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                             },\n                         )),\n                     });\n-                } else if let Some(i) = try_inline(cx, item.res, item.ident.name, None, visited) {\n+                } else if let Some(i) =\n+                    try_inline(cx, did, item.res, item.ident.name, None, visited)\n+                {\n                     items.extend(i)\n                 }\n             }"}, {"sha": "ca9135cd11a1682a0a68c20d2a55d075028f7d3a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -284,7 +284,7 @@ impl Clean<Item> for doctree::Module<'_> {\n \n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext<'_>) -> Attributes {\n-        Attributes::from_ast(cx.sess().diagnostic(), self)\n+        Attributes::from_ast(cx.sess().diagnostic(), self, None)\n     }\n }\n \n@@ -2205,9 +2205,14 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n \n             let res = Res::Def(DefKind::Mod, DefId { krate: self.cnum, index: CRATE_DEF_INDEX });\n \n-            if let Some(items) =\n-                inline::try_inline(cx, res, self.name, Some(self.attrs), &mut visited)\n-            {\n+            if let Some(items) = inline::try_inline(\n+                cx,\n+                cx.tcx.parent_module(self.hir_id).to_def_id(),\n+                res,\n+                self.name,\n+                Some(self.attrs),\n+                &mut visited,\n+            ) {\n                 return items;\n             }\n         }\n@@ -2268,9 +2273,14 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             }\n             if !denied {\n                 let mut visited = FxHashSet::default();\n-                if let Some(items) =\n-                    inline::try_inline(cx, path.res, name, Some(self.attrs), &mut visited)\n-                {\n+                if let Some(items) = inline::try_inline(\n+                    cx,\n+                    cx.tcx.parent_module(self.id).to_def_id(),\n+                    path.res,\n+                    name,\n+                    Some(self.attrs),\n+                    &mut visited,\n+                ) {\n                     return items;\n                 }\n             }"}, {"sha": "cd20e241c8fdf6152244dbe46bb9838344da8dc4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -373,6 +373,11 @@ impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n pub struct DocFragment {\n     pub line: usize,\n     pub span: rustc_span::Span,\n+    /// The module this doc-comment came from.\n+    ///\n+    /// This allows distinguishing between the original documentation and a pub re-export.\n+    /// If it is `None`, the item was not re-exported.\n+    pub parent_module: Option<DefId>,\n     pub doc: String,\n     pub kind: DocFragmentKind,\n }\n@@ -521,16 +526,25 @@ impl Attributes {\n         false\n     }\n \n-    pub fn from_ast(diagnostic: &::rustc_errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n+    pub fn from_ast(\n+        diagnostic: &::rustc_errors::Handler,\n+        attrs: &[ast::Attribute],\n+        additional_attrs: Option<(&[ast::Attribute], DefId)>,\n+    ) -> Attributes {\n         let mut doc_strings = vec![];\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n-        let other_attrs = attrs\n-            .iter()\n-            .filter_map(|attr| {\n+        // Additional documentation should be shown before the original documentation\n+        let other_attrs = additional_attrs\n+            .into_iter()\n+            .map(|(attrs, id)| attrs.iter().map(move |attr| (attr, Some(id))))\n+            .flatten()\n+            .chain(attrs.iter().map(|attr| (attr, None)))\n+            .filter_map(|(attr, parent_module)| {\n                 if let Some(value) = attr.doc_str() {\n+                    trace!(\"got doc_str={:?}\", value);\n                     let value = beautify_doc_string(value);\n                     let kind = if attr.is_doc_comment() {\n                         DocFragmentKind::SugaredDoc\n@@ -540,7 +554,13 @@ impl Attributes {\n \n                     let line = doc_line;\n                     doc_line += value.lines().count();\n-                    doc_strings.push(DocFragment { line, span: attr.span, doc: value, kind });\n+                    doc_strings.push(DocFragment {\n+                        line,\n+                        span: attr.span,\n+                        doc: value,\n+                        kind,\n+                        parent_module,\n+                    });\n \n                     if sp.is_none() {\n                         sp = Some(attr.span);\n@@ -565,6 +585,7 @@ impl Attributes {\n                                     span: attr.span,\n                                     doc: contents,\n                                     kind: DocFragmentKind::Include { filename },\n+                                    parent_module: parent_module,\n                                 });\n                             }\n                         }"}, {"sha": "913342e271513f4ce8d9a080501eae32302f035d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -361,7 +361,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, None));\n+                ret.extend(inline::build_impls(cx, None, did, None));\n                 continue;\n             }\n             _ => match target.primitive_type() {\n@@ -371,7 +371,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n         };\n         for &did in primitive.impls(tcx) {\n             if !did.is_local() {\n-                inline::build_impl(cx, did, None, ret);\n+                inline::build_impl(cx, None, did, None, ret);\n             }\n         }\n     }"}, {"sha": "eb33890fb5fceeb9b16306d00240965cb5dc312f", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -927,7 +927,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         sp: Span,\n         nested: F,\n     ) {\n-        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n+        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs, None);\n         if let Some(ref cfg) = attrs.cfg {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;"}, {"sha": "6bb9b58bead65422f588509905eaaec8375fc429", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -8,6 +8,7 @@ use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n+use rustc_hir::HirId;\n \n pub struct Module<'hir> {\n     pub name: Option<Symbol>,\n@@ -236,6 +237,7 @@ pub struct Macro<'hir> {\n \n pub struct ExternCrate<'hir> {\n     pub name: Symbol,\n+    pub hir_id: HirId,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: &'hir hir::Visibility<'hir>,"}, {"sha": "6d52733b3843848c928f06c7fef9fe9bb75f4a4d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -767,8 +767,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             self.mod_ids.push(item.def_id);\n         }\n \n+        #[cfg(debug_assertions)]\n+        for attr in &item.attrs.doc_strings {\n+            if let Some(id) = attr.parent_module {\n+                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n+            } else {\n+                debug!(\"no parent found for {:?}\", attr.doc);\n+            }\n+        }\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-        trace!(\"got documentation '{}'\", dox);\n+        //trace!(\"got documentation '{}'\", dox);\n \n         // find item's parent to resolve `Self` in item's docs below\n         let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {"}, {"sha": "5eb3f98b12371b0686e3249431b9e995a750e2da", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -30,15 +30,15 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &cnum in cx.tcx.crates().iter() {\n         for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n             cx.tcx.sess.time(\"build_extern_trait_impl\", || {\n-                inline::build_impl(cx, did, None, &mut new_items);\n+                inline::build_impl(cx, None, did, None, &mut new_items);\n             });\n         }\n     }\n \n     // Also try to inline primitive impls from other crates.\n     for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n         if !def_id.is_local() {\n-            inline::build_impl(cx, def_id, None, &mut new_items);\n+            inline::build_impl(cx, None, def_id, None, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n             if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n@@ -90,7 +90,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             cx.tcx.sess.time(\"build_local_trait_impl\", || {\n-                inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n+                inline::build_impl(cx, None, impl_did.to_def_id(), None, &mut new_items);\n             });\n         }\n     }"}, {"sha": "cbfd2199d9fd6503ea6ec0dd57772ee470e2d194", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1b15f6279a95923b8a19046f45f27f243d49d2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fa1b15f6279a95923b8a19046f45f27f243d49d2", "patch": "@@ -399,6 +399,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE),\n                     name: ident.name,\n+                    hir_id: item.hir_id,\n                     path: orig_name.map(|x| x.to_string()),\n                     vis: &item.vis,\n                     attrs: &item.attrs,"}]}