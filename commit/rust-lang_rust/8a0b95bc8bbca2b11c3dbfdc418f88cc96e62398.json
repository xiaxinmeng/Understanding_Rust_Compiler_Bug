{"sha": "8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMGI5NWJjOGJiY2EyYjExYzNkYmZkYzQxOGY4OGNjOTZlNjIzOTg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-12T03:27:54Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-12T03:27:54Z"}, "message": "Support structs and single-variant enums.", "tree": {"sha": "708af99b412f508f0fd4ee40df38100fedcfb70f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708af99b412f508f0fd4ee40df38100fedcfb70f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "html_url": "https://github.com/rust-lang/rust/commit/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd10ec9278ab302ef4223b3b7921ad062f4396a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd10ec9278ab302ef4223b3b7921ad062f4396a7", "html_url": "https://github.com/rust-lang/rust/commit/fd10ec9278ab302ef4223b3b7921ad062f4396a7"}], "stats": {"total": 108, "additions": 61, "deletions": 47}, "files": [{"sha": "2590cd656a4d8c97a3e0f932795492b9b2bf610d", "filename": "src/interpreter.rs", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::repr as mir;\n use std::error::Error;\n use std::fmt;\n \n-use memory::{Memory, Pointer, Repr};\n+use memory::{FieldRepr, Memory, Pointer, Repr};\n \n const TRACE_EXECUTION: bool = true;\n \n@@ -107,7 +107,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         let mut locals = Vec::with_capacity(num_args + num_vars + num_temps);\n \n         for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n-            let repr = Repr::from_ty(arg_decl.ty);\n+            let repr = self.ty_to_repr(arg_decl.ty);\n             let dest = self.memory.allocate(repr.size());\n             let src = try!(self.operand_to_ptr(arg_operand));\n             try!(self.memory.copy(src, dest, repr.size()));\n@@ -117,7 +117,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n         locals.extend(var_tys.chain(temp_tys).map(|ty| {\n-            self.memory.allocate(Repr::from_ty(ty).size())\n+            let repr = self.ty_to_repr(ty).size();\n+            self.memory.allocate(repr)\n         }));\n \n         self.stack.push(Frame {\n@@ -273,7 +274,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     {\n         let dest = try!(self.lvalue_to_ptr(lvalue));\n         let dest_ty = self.current_frame().mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n-        let dest_repr = Repr::from_ty(dest_ty);\n+        let dest_repr = self.ty_to_repr(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -297,7 +298,21 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 self.memory.write_int(dest, n)\n             }\n \n-            Aggregate(mir::AggregateKind::Tuple, ref operands) => {\n+            Aggregate(ref _kind, ref operands) => {\n+                // TODO(tsion): Handle different `kind` variants.\n+\n+                // let max_fields = adt_def.variants\n+                //     .iter()\n+                //     .map(|v| v.fields.len())\n+                //     .max()\n+                //     .unwrap_or(0);\n+                // let ptr = self.allocate_aggregate(max_fields);\n+                // for (i, operand) in operands.iter().enumerate() {\n+                //     let val = self.operand_to_ptr(operand);\n+                //     self.write_pointer(ptr.offset(i), val);\n+                // }\n+                // Value::Adt { variant: variant, data_ptr: ptr }\n+\n                 match dest_repr {\n                     Repr::Aggregate { ref fields, .. } => {\n                         for (field, operand) in fields.iter().zip(operands) {\n@@ -316,24 +331,6 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             //     Value::Pointer(self.lvalue_to_ptr(lvalue))\n             // }\n \n-            // Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n-            //                        ref operands) => {\n-            //     let max_fields = adt_def.variants\n-            //         .iter()\n-            //         .map(|v| v.fields.len())\n-            //         .max()\n-            //         .unwrap_or(0);\n-\n-            //     let ptr = self.allocate_aggregate(max_fields);\n-\n-            //     for (i, operand) in operands.iter().enumerate() {\n-            //         let val = self.operand_to_ptr(operand);\n-            //         self.write_pointer(ptr.offset(i), val);\n-            //     }\n-\n-            //     Value::Adt { variant: variant, data_ptr: ptr }\n-            // }\n-\n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n     }\n@@ -433,6 +430,36 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n+    fn make_aggregate_repr<I>(&self, iter: I) -> Repr where I: IntoIterator<Item = ty::Ty<'tcx>> {\n+        let mut size = 0;\n+        let fields = iter.into_iter().map(|ty| {\n+            let repr = self.ty_to_repr(ty);\n+            let old_size = size;\n+            size += repr.size();\n+            FieldRepr { offset: old_size, repr: repr }\n+        }).collect();\n+        Repr::Aggregate { size: size, fields: fields }\n+    }\n+\n+    // TODO(tsion): Cache these outputs.\n+    fn ty_to_repr(&self, ty: ty::Ty<'tcx>) -> Repr {\n+        match ty.sty {\n+            ty::TyBool => Repr::Bool,\n+            ty::TyInt(_) => Repr::Int,\n+            ty::TyTuple(ref fields) => self.make_aggregate_repr(fields.iter().cloned()),\n+\n+            ty::TyEnum(adt_def, ref subst) | ty::TyStruct(adt_def, ref subst) => {\n+                // TODO(tsion): Support multi-variant enums.\n+                assert!(adt_def.variants.len() == 1);\n+                let field_tys = adt_def.variants[0].fields.iter().map(|f| f.ty(self.tcx, subst));\n+                self.make_aggregate_repr(field_tys)\n+            }\n+\n+            ref t => panic!(\"can't convert type to repr: {:?}\", t),\n+        }\n+    }\n+\n+\n     fn current_frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n@@ -449,7 +476,10 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n \n                 let mut miri = Interpreter::new(tcx, mir_map);\n                 let return_ptr = match mir.return_ty {\n-                    ty::FnConverging(ty) => Some(miri.memory.allocate(Repr::from_ty(ty).size())),\n+                    ty::FnConverging(ty) => {\n+                        let repr = miri.ty_to_repr(ty).size();\n+                        Some(miri.memory.allocate(repr))\n+                    }\n                     ty::FnDiverging => None,\n                 };\n                 miri.call(mir, &[], return_ptr).unwrap();"}, {"sha": "744424a1ffb33b3a9f1c636f70709eb1e11d7e16", "filename": "src/memory.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "patch": "@@ -1,5 +1,4 @@\n use byteorder::{self, ByteOrder};\n-use rustc::middle::ty;\n use std::collections::HashMap;\n use std::mem;\n use std::ptr;\n@@ -141,28 +140,6 @@ impl Pointer {\n }\n \n impl Repr {\n-    // TODO(tsion): Cache these outputs.\n-    pub fn from_ty(ty: ty::Ty) -> Self {\n-        match ty.sty {\n-            ty::TyBool => Repr::Bool,\n-\n-            ty::TyInt(_) => Repr::Int,\n-\n-            ty::TyTuple(ref fields) => {\n-                let mut size = 0;\n-                let fields = fields.iter().map(|ty| {\n-                    let repr = Repr::from_ty(ty);\n-                    let old_size = size;\n-                    size += repr.size();\n-                    FieldRepr { offset: old_size, repr: repr }\n-                }).collect();\n-                Repr::Aggregate { size: size, fields: fields }\n-            },\n-\n-            ref t => panic!(\"can't convert type to repr: {:?}\", t),\n-        }\n-    }\n-\n     pub fn size(&self) -> usize {\n         match *self {\n             Repr::Bool => 1,"}, {"sha": "795915a504112310a7e40d631f39ae0f90e6d99b", "filename": "test/basic.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/test%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398/test%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fbasic.rs?ref=8a0b95bc8bbca2b11c3dbfdc418f88cc96e62398", "patch": "@@ -61,6 +61,13 @@ fn if_true() -> i32 {\n     if true { 1 } else { 0 }\n }\n \n+struct Pair { x: i64, y: i64 }\n+\n+#[miri_run]\n+fn pair() -> Pair {\n+    Pair { x: 10, y: 20 }\n+}\n+\n // #[miri_run(expected = \"Int(2)\")]\n // fn call() -> i32 {\n //     fn increment(x: i32) -> i32 {"}]}