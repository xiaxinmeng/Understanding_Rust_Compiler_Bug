{"sha": "141b91da6cb756ff5f36eebe9eee65922e295876", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MWI5MWRhNmNiNzU2ZmY1ZjM2ZWViZTllZWU2NTkyMmUyOTU4NzY=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-26T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-26T13:38:56Z"}, "message": "liveness: Inline contents of specials struct", "tree": {"sha": "e72a3d051e1326f8dd6b5acd5b08072a8115c24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e72a3d051e1326f8dd6b5acd5b08072a8115c24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/141b91da6cb756ff5f36eebe9eee65922e295876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/141b91da6cb756ff5f36eebe9eee65922e295876", "html_url": "https://github.com/rust-lang/rust/commit/141b91da6cb756ff5f36eebe9eee65922e295876", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/141b91da6cb756ff5f36eebe9eee65922e295876/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f150b51e7d13e3bcd8977ff124a348057cf7ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f150b51e7d13e3bcd8977ff124a348057cf7ef", "html_url": "https://github.com/rust-lang/rust/commit/70f150b51e7d13e3bcd8977ff124a348057cf7ef"}], "stats": {"total": 55, "additions": 25, "deletions": 30}, "files": [{"sha": "cb452d3d04153cbdea4c8a0b20855330666bd9ab", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/141b91da6cb756ff5f36eebe9eee65922e295876/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/141b91da6cb756ff5f36eebe9eee65922e295876/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=141b91da6cb756ff5f36eebe9eee65922e295876", "patch": "@@ -79,7 +79,7 @@\n //! ## Special nodes and variables\n //!\n //! We generate various special nodes for various, well, special purposes.\n-//! These are described in the `Specials` struct.\n+//! These are described in the `Liveness` struct.\n \n use self::LiveNodeKind::*;\n use self::VarKind::*;\n@@ -626,17 +626,6 @@ impl RWUTable {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-struct Specials {\n-    /// A live node representing a point of execution before closure entry &\n-    /// after closure exit. Used to calculate liveness of captured variables\n-    /// through calls to the same closure. Used for Fn & FnMut closures only.\n-    closure_ln: LiveNode,\n-    /// A live node representing every 'exit' from the function, whether it be\n-    /// by explicit return, panic, or other means.\n-    exit_ln: LiveNode,\n-}\n-\n const ACC_READ: u32 = 1;\n const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n@@ -645,10 +634,17 @@ struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    s: Specials,\n     successors: Vec<LiveNode>,\n     rwu_table: RWUTable,\n \n+    /// A live node representing a point of execution before closure entry &\n+    /// after closure exit. Used to calculate liveness of captured variables\n+    /// through calls to the same closure. Used for Fn & FnMut closures only.\n+    closure_ln: LiveNode,\n+    /// A live node representing every 'exit' from the function, whether it be\n+    /// by explicit return, panic, or other means.\n+    exit_ln: LiveNode,\n+\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -658,24 +654,23 @@ struct Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        let specials = Specials {\n-            closure_ln: ir.add_live_node(ClosureNode),\n-            exit_ln: ir.add_live_node(ExitNode),\n-        };\n-\n         let typeck_results = ir.tcx.typeck(def_id);\n         let param_env = ir.tcx.param_env(def_id);\n \n+        let closure_ln = ir.add_live_node(ClosureNode);\n+        let exit_ln = ir.add_live_node(ExitNode);\n+\n         let num_live_nodes = ir.lnks.len();\n         let num_vars = ir.var_kinds.len();\n \n         Liveness {\n             ir,\n             typeck_results,\n             param_env,\n-            s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n+            closure_ln,\n+            exit_ln,\n             break_ln: Default::default(),\n             cont_ln: Default::default(),\n         }\n@@ -935,14 +930,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 match self.typeck_results.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n                         let var = self.variable(var_hir_id, upvar.span);\n-                        self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n+                        self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n                     }\n                     ty::UpvarCapture::ByValue(_) => {}\n                 }\n             }\n         }\n \n-        let succ = self.propagate_through_expr(&body.value, self.s.exit_ln);\n+        let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n         match fk {\n             FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n@@ -965,19 +960,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // Propagate through calls to the closure.\n         let mut first_merge = true;\n         loop {\n-            self.init_from_succ(self.s.closure_ln, succ);\n+            self.init_from_succ(self.closure_ln, succ);\n             for param in body.params {\n                 param.pat.each_binding(|_bm, hir_id, _x, ident| {\n                     let var = self.variable(hir_id, ident.span);\n-                    self.define(self.s.closure_ln, var);\n+                    self.define(self.closure_ln, var);\n                 })\n             }\n \n-            if !self.merge_from_succ(self.s.exit_ln, self.s.closure_ln, first_merge) {\n+            if !self.merge_from_succ(self.exit_ln, self.closure_ln, first_merge) {\n                 break;\n             }\n             first_merge = false;\n-            assert_eq!(succ, self.propagate_through_expr(&body.value, self.s.exit_ln));\n+            assert_eq!(succ, self.propagate_through_expr(&body.value, self.exit_ln));\n         }\n \n         succ\n@@ -1099,7 +1094,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Ret(ref o_e) => {\n                 // ignore succ and subst exit_ln:\n-                let exit_ln = self.s.exit_ln;\n+                let exit_ln = self.exit_ln;\n                 self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n             }\n \n@@ -1174,7 +1169,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1189,7 +1184,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1226,7 +1221,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::InlineAsm(ref asm) => {\n                 // Handle non-returning asm\n                 let mut succ = if asm.options.contains(InlineAsmOptions::NORETURN) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1696,7 +1691,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n             // {ret}`, there is only one node, so asking about\n             // assigned_on_exit() is not meaningful.\n             let is_assigned =\n-                if ln == self.s.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n+                if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n \n             if is_assigned {\n                 self.ir.tcx.struct_span_lint_hir("}]}