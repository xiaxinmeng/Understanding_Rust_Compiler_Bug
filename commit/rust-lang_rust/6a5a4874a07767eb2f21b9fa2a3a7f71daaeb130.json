{"sha": "6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNWE0ODc0YTA3NzY3ZWIyZjIxYjlmYTJhM2E3ZjcxZGFhZWIxMzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-05T15:06:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T15:02:14Z"}, "message": "convert type-check constraints into NLL constraints on the fly\n\nWe used to accumulate a vector of type-check constraints, but now we\ngenerate them as we go, and just store the NLL-style\n`OutlivesConstraint` and `TypeTest` information.", "tree": {"sha": "da7434711220a7ef0c1073db3f11b50617e0f7eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da7434711220a7ef0c1073db3f11b50617e0f7eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "html_url": "https://github.com/rust-lang/rust/commit/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba6a7f7500381a111fd67b32abcac75349dd3807", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6a7f7500381a111fd67b32abcac75349dd3807", "html_url": "https://github.com/rust-lang/rust/commit/ba6a7f7500381a111fd67b32abcac75349dd3807"}], "stats": {"total": 605, "additions": 339, "deletions": 266}, "files": [{"sha": "ad3710e9536f1af1c401821992c3fec0e23476c0", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -367,6 +367,11 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: Vec::new(), _marker: PhantomData }\n     }\n \n+    #[inline]\n+    pub fn from_raw(raw: Vec<T>) -> Self {\n+        IndexVec { raw, _marker: PhantomData }\n+    }\n+\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         IndexVec { raw: Vec::with_capacity(capacity), _marker: PhantomData }"}, {"sha": "72db9f8da987251f1e69bf71da2de0167349b1d2", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -11,6 +11,8 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::ToRegionVid;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n@@ -21,9 +23,7 @@ use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n-\n-use super::region_infer::{Cause, RegionInferenceContext};\n-use super::ToRegionVid;\n+use std::iter;\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -32,6 +32,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location, Cause)],\n ) {\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n@@ -42,6 +43,8 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         mir,\n     };\n \n+    cg.add_region_liveness_constraints_from_type_check(liveness_set_from_typeck);\n+\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n@@ -209,7 +212,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                 self.add_reborrow_constraint(location, region, borrowed_place);\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n \n         self.super_rvalue(rvalue, location);\n@@ -225,6 +228,42 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n+    /// The MIR type checker generates region liveness constraints\n+    /// that we also have to respect.\n+    fn add_region_liveness_constraints_from_type_check(\n+        &mut self,\n+        liveness_set: &[(ty::Region<'tcx>, Location, Cause)],\n+    ) {\n+        debug!(\n+            \"add_region_liveness_constraints_from_type_check(liveness_set={} items)\",\n+            liveness_set.len(),\n+        );\n+\n+        let ConstraintGeneration {\n+            regioncx,\n+            location_table,\n+            all_facts,\n+            ..\n+        } = self;\n+\n+        for (region, location, cause) in liveness_set {\n+            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n+            let region_vid = regioncx.to_region_vid(region);\n+            regioncx.add_live_point(region_vid, *location, &cause);\n+        }\n+\n+        if let Some(all_facts) = all_facts {\n+            all_facts\n+                .region_live_at\n+                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                    let r = regioncx.to_region_vid(region);\n+                    let p1 = location_table.start_index(*location);\n+                    let p2 = location_table.mid_index(*location);\n+                    iter::once((r, p1)).chain(iter::once((r, p2)))\n+                }));\n+        }\n+    }\n+\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "dcb52a3b18a724cf2829b9a5653471815ea2625d", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -11,6 +11,7 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n+use borrow_check::nll::type_check::MirTypeckRegionConstraints;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -41,7 +42,6 @@ mod facts;\n mod invalidation;\n crate mod region_infer;\n mod renumber;\n-mod subtype_constraint_generation;\n crate mod type_check;\n mod universal_regions;\n \n@@ -91,53 +91,61 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     Option<ClosureRegionRequirements<'gcx>>,\n ) {\n+    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts\n+        || infcx.tcx.sess.opts.debugging_opts.polonius\n+    {\n+        Some(AllFacts::default())\n+    } else {\n+        None\n+    };\n+\n     // Run the MIR type-checker.\n     let liveness = &LivenessResults::compute(mir);\n-    let constraint_sets = &type_check::type_check(\n+    let constraint_sets = type_check::type_check(\n         infcx,\n         param_env,\n         mir,\n         def_id,\n         &universal_regions,\n+        location_table,\n         &liveness,\n+        &mut all_facts,\n         flow_inits,\n         move_data,\n     );\n \n-    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts\n-        || infcx.tcx.sess.opts.debugging_opts.polonius\n-    {\n-        Some(AllFacts::default())\n-    } else {\n-        None\n-    };\n-\n     if let Some(all_facts) = &mut all_facts {\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n     }\n \n-    // Create the region inference context, taking ownership of the region inference\n-    // data that was contained in `infcx`.\n+    // Create the region inference context, taking ownership of the\n+    // region inference data that was contained in `infcx`, and the\n+    // base constraints generated by the type-check.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n-\n-    // Generate various constraints.\n-    subtype_constraint_generation::generate(\n-        &mut regioncx,\n-        &mut all_facts,\n-        location_table,\n+    let MirTypeckRegionConstraints {\n+        liveness_set,\n+        outlives_constraints,\n+        type_tests,\n+    } = constraint_sets;\n+    let mut regioncx = RegionInferenceContext::new(\n+        var_origins,\n+        universal_regions,\n         mir,\n-        constraint_sets,\n+        outlives_constraints,\n+        type_tests,\n     );\n+\n+    // Generate various additional constraints.\n     constraint_generation::generate_constraints(\n         infcx,\n         &mut regioncx,\n         &mut all_facts,\n         location_table,\n         &mir,\n         borrow_set,\n+        &liveness_set,\n     );\n     invalidation::generate_invalidates(\n         infcx,"}, {"sha": "f123d4217001c596d31232af10a0d685899d907e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -123,15 +123,14 @@ pub struct OutlivesConstraint {\n     // it is for convenience. Before we dump the constraints in the\n     // debugging logs, we sort them, and we'd like the \"super region\"\n     // to be first, etc. (In particular, span should remain last.)\n-\n     /// The region SUP must outlive SUB...\n-    sup: RegionVid,\n+    pub sup: RegionVid,\n \n     /// Region that must be outlived.\n-    sub: RegionVid,\n+    pub sub: RegionVid,\n \n     /// At this location.\n-    point: Location,\n+    pub point: Location,\n \n     /// Later on, we thread the constraints onto a linked list\n     /// grouped by their `sub` field. So if you had:\n@@ -141,10 +140,10 @@ pub struct OutlivesConstraint {\n     /// 0     | `'a: 'b`   | Some(2)\n     /// 1     | `'b: 'c`   | None\n     /// 2     | `'c: 'b`   | None\n-    next: Option<ConstraintIndex>,\n+    pub next: Option<ConstraintIndex>,\n \n     /// Where did this constraint arise?\n-    span: Span,\n+    pub span: Span,\n }\n \n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n@@ -240,11 +239,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n+    ///\n+    /// The `outlives_constraints` and `type_tests` are an initial set\n+    /// of constraints produced by the MIR type check.\n     pub(crate) fn new(\n         var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n+        outlives_constraints: Vec<OutlivesConstraint>,\n+        type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n+        // The `next` field should not yet have been initialized:\n+        debug_assert!(outlives_constraints.iter().all(|c| c.next.is_none()));\n+\n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n@@ -262,8 +269,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             dependency_map: None,\n-            constraints: IndexVec::new(),\n-            type_tests: Vec::new(),\n+            constraints: IndexVec::from_raw(outlives_constraints),\n+            type_tests,\n             universal_regions,\n         };\n \n@@ -346,15 +353,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     where\n         R: ToRegionVid,\n     {\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n         inferred_values.contains(r.to_region_vid(), p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     crate fn region_value_str(&self, r: RegionVid) -> String {\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n@@ -397,11 +406,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n-    /// Add a \"type test\" that must be satisfied.\n-    pub(super) fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n-        self.type_tests.push(type_test);\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -596,7 +600,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if self.universal_regions.is_universal_region(r) {\n             return self.definitions[r].external_name;\n         } else {\n-            let inferred_values = self.inferred_values\n+            let inferred_values = self\n+                .inferred_values\n                 .as_ref()\n                 .expect(\"region values not yet inferred\");\n             let upper_bound = self.universal_upper_bound(r);\n@@ -635,8 +640,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(!self.universal_regions\n-            .is_local_free_region(lower_bound_plus));\n+        assert!(\n+            !self\n+                .universal_regions\n+                .is_local_free_region(lower_bound_plus)\n+        );\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -664,7 +672,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'gcx>> {\n         let tcx = infcx.tcx;\n         let gcx = tcx.global_tcx();\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n@@ -845,7 +854,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             sup_region, sub_region, point\n         );\n \n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"values for regions not yet inferred\");\n \n@@ -912,7 +922,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let universal_definitions = self.definitions\n+        let universal_definitions = self\n+            .definitions\n             .iter_enumerated()\n             .take_while(|(_, fr_definition)| fr_definition.is_universal);\n "}, {"sha": "fd445c62e4e6dd0f7f38bc81a97d3a6e0c5c29e5", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/ba6a7f7500381a111fd67b32abcac75349dd3807/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba6a7f7500381a111fd67b32abcac75349dd3807/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=ba6a7f7500381a111fd67b32abcac75349dd3807", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use borrow_check::location::LocationTable;\n-use borrow_check::nll::facts::AllFacts;\n-use rustc::infer::region_constraints::Constraint;\n-use rustc::infer::region_constraints::RegionConstraintData;\n-use rustc::infer::region_constraints::{Verify, VerifyBound};\n-use rustc::mir::{Location, Mir};\n-use rustc::ty;\n-use std::iter;\n-use syntax::codemap::Span;\n-\n-use super::region_infer::{RegionInferenceContext, RegionTest, TypeTest};\n-use super::type_check::Locations;\n-use super::type_check::MirTypeckRegionConstraints;\n-use super::type_check::OutlivesSet;\n-\n-/// When the MIR type-checker executes, it validates all the types in\n-/// the MIR, and in the process generates a set of constraints that\n-/// must hold regarding the regions in the MIR, along with locations\n-/// *where* they must hold. This code takes those constriants and adds\n-/// them into the NLL `RegionInferenceContext`.\n-pub(super) fn generate<'tcx>(\n-    regioncx: &mut RegionInferenceContext<'tcx>,\n-    all_facts: &mut Option<AllFacts>,\n-    location_table: &LocationTable,\n-    mir: &Mir<'tcx>,\n-    constraints: &MirTypeckRegionConstraints<'tcx>,\n-) {\n-    SubtypeConstraintGenerator {\n-        regioncx,\n-        location_table,\n-        mir,\n-    }.generate(constraints, all_facts);\n-}\n-\n-struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n-    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    location_table: &'cx LocationTable,\n-    mir: &'cx Mir<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n-    fn generate(\n-        &mut self,\n-        constraints: &MirTypeckRegionConstraints<'tcx>,\n-        all_facts: &mut Option<AllFacts>,\n-    ) {\n-        let MirTypeckRegionConstraints {\n-            liveness_set,\n-            outlives_sets,\n-        } = constraints;\n-\n-        debug!(\n-            \"generate(liveness_set={} items, outlives_sets={} items)\",\n-            liveness_set.len(),\n-            outlives_sets.len()\n-        );\n-\n-        for (region, location, cause) in liveness_set {\n-            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n-            let region_vid = self.to_region_vid(region);\n-            self.regioncx.add_live_point(region_vid, *location, &cause);\n-        }\n-\n-        if let Some(all_facts) = all_facts {\n-            all_facts\n-                .region_live_at\n-                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n-                    let r = self.to_region_vid(region);\n-                    let p1 = self.location_table.start_index(*location);\n-                    let p2 = self.location_table.mid_index(*location);\n-                    iter::once((r, p1)).chain(iter::once((r, p2)))\n-                }));\n-        }\n-\n-        for OutlivesSet { locations, data } in outlives_sets {\n-            debug!(\"generate: constraints at: {:#?}\", locations);\n-            let RegionConstraintData {\n-                constraints,\n-                verifys,\n-                givens,\n-            } = &**data;\n-\n-            let span = self.mir\n-                .source_info(locations.from_location().unwrap_or(Location::START))\n-                .span;\n-\n-            let at_location = locations.at_location().unwrap_or(Location::START);\n-\n-            for constraint in constraints.keys() {\n-                debug!(\"generate: constraint: {:?}\", constraint);\n-                let (a_vid, b_vid) = match constraint {\n-                    Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n-                    Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n-                    Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n-                    Constraint::RegSubReg(a_r, b_r) => {\n-                        (self.to_region_vid(a_r), self.to_region_vid(b_r))\n-                    }\n-                };\n-\n-                // We have the constraint that `a_vid <= b_vid`. Add\n-                // `b_vid: a_vid` to our region checker. Note that we\n-                // reverse direction, because `regioncx` talks about\n-                // \"outlives\" (`>=`) whereas the region constraints\n-                // talk about `<=`.\n-                self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n-\n-                // In the new analysis, all outlives relations etc\n-                // \"take effect\" at the mid point of the statement\n-                // that requires them, so ignore the `at_location`.\n-                if let Some(all_facts) = all_facts {\n-                    if let Some(from_location) = locations.from_location() {\n-                        all_facts.outlives.push((\n-                            b_vid,\n-                            a_vid,\n-                            self.location_table.mid_index(from_location),\n-                        ));\n-                    } else {\n-                        for location in self.location_table.all_points() {\n-                            all_facts.outlives.push((b_vid, a_vid, location));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for verify in verifys {\n-                let type_test = self.verify_to_type_test(verify, span, locations);\n-                self.regioncx.add_type_test(type_test);\n-            }\n-\n-            assert!(\n-                givens.is_empty(),\n-                \"MIR type-checker does not use givens (thank goodness)\"\n-            );\n-        }\n-    }\n-\n-    fn verify_to_type_test(\n-        &self,\n-        verify: &Verify<'tcx>,\n-        span: Span,\n-        locations: &Locations,\n-    ) -> TypeTest<'tcx> {\n-        let generic_kind = verify.kind;\n-\n-        let lower_bound = self.to_region_vid(verify.region);\n-\n-        let point = locations.at_location().unwrap_or(Location::START);\n-\n-        let test = self.verify_bound_to_region_test(&verify.bound);\n-\n-        TypeTest {\n-            generic_kind,\n-            lower_bound,\n-            point,\n-            span,\n-            test,\n-        }\n-    }\n-\n-    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n-        match verify_bound {\n-            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-\n-            VerifyBound::AllBounds(bounds) => RegionTest::All(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-        }\n-    }\n-\n-    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        self.regioncx.to_region_vid(r)\n-    }\n-}"}, {"sha": "06aaf6810faa3662984ba0dab079f57420e69579", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n+use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use rustc::infer::region_constraints::Constraint;\n+use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::mir::{Location, Mir};\n+use rustc::ty;\n+use syntax::codemap::Span;\n+\n+crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    universal_regions: &'a UniversalRegions<'tcx>,\n+    location_table: &'a LocationTable,\n+    outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+    type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+    all_facts: &'a mut Option<AllFacts>,\n+\n+}\n+\n+impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n+    crate fn new(\n+        mir: &'a Mir<'tcx>,\n+        universal_regions: &'a UniversalRegions<'tcx>,\n+        location_table: &'a LocationTable,\n+        outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+        type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+        all_facts: &'a mut Option<AllFacts>,\n+    ) -> Self {\n+        Self {\n+            mir,\n+            universal_regions,\n+            location_table,\n+            outlives_constraints,\n+            type_tests,\n+            all_facts,\n+        }\n+    }\n+\n+    crate fn convert(\n+        &mut self,\n+        locations: Locations,\n+        data: &RegionConstraintData<'tcx>,\n+    ) {\n+        debug!(\"generate: constraints at: {:#?}\", locations);\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = data;\n+\n+        let span = self\n+            .mir\n+            .source_info(locations.from_location().unwrap_or(Location::START))\n+            .span;\n+\n+        let at_location = locations.at_location().unwrap_or(Location::START);\n+\n+        for constraint in constraints.keys() {\n+            debug!(\"generate: constraint: {:?}\", constraint);\n+            let (a_vid, b_vid) = match constraint {\n+                Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n+                Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n+                Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n+                Constraint::RegSubReg(a_r, b_r) => {\n+                    (self.to_region_vid(a_r), self.to_region_vid(b_r))\n+                }\n+            };\n+\n+            // We have the constraint that `a_vid <= b_vid`. Add\n+            // `b_vid: a_vid` to our region checker. Note that we\n+            // reverse direction, because `regioncx` talks about\n+            // \"outlives\" (`>=`) whereas the region constraints\n+            // talk about `<=`.\n+            self.add_outlives(span, b_vid, a_vid, at_location);\n+\n+            // In the new analysis, all outlives relations etc\n+            // \"take effect\" at the mid point of the statement\n+            // that requires them, so ignore the `at_location`.\n+            if let Some(all_facts) = &mut self.all_facts {\n+                if let Some(from_location) = locations.from_location() {\n+                    all_facts.outlives.push((\n+                        b_vid,\n+                        a_vid,\n+                        self.location_table.mid_index(from_location),\n+                    ));\n+                } else {\n+                    for location in self.location_table.all_points() {\n+                        all_facts.outlives.push((b_vid, a_vid, location));\n+                    }\n+                }\n+            }\n+        }\n+\n+        for verify in verifys {\n+            let type_test = self.verify_to_type_test(verify, span, locations);\n+            self.add_type_test(type_test);\n+        }\n+\n+        assert!(\n+            givens.is_empty(),\n+            \"MIR type-checker does not use givens (thank goodness)\"\n+        );\n+    }\n+\n+    fn verify_to_type_test(\n+        &self,\n+        verify: &Verify<'tcx>,\n+        span: Span,\n+        locations: Locations,\n+    ) -> TypeTest<'tcx> {\n+        let generic_kind = verify.kind;\n+\n+        let lower_bound = self.to_region_vid(verify.region);\n+\n+        let point = locations.at_location().unwrap_or(Location::START);\n+\n+        let test = self.verify_bound_to_region_test(&verify.bound);\n+\n+        TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point,\n+            span,\n+            test,\n+        }\n+    }\n+\n+    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n+        match verify_bound {\n+            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+\n+            VerifyBound::AllBounds(bounds) => RegionTest::All(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+        }\n+    }\n+\n+    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        self.universal_regions.to_region_vid(r)\n+    }\n+\n+    fn add_outlives(\n+        &mut self,\n+        span: Span,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        point: Location,\n+    ) {\n+        self.outlives_constraints.push(OutlivesConstraint {\n+            span,\n+            sub,\n+            sup,\n+            point,\n+            next: None,\n+        });\n+    }\n+\n+    fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n+        self.type_tests.push(type_test);\n+    }\n+}"}, {"sha": "bed0fec4d4de422b980e5b6f85c87b9aa35cc35a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6a5a4874a07767eb2f21b9fa2a3a7f71daaeb130", "patch": "@@ -11,8 +11,10 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n+use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, OutlivesConstraint, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -63,6 +65,7 @@ macro_rules! span_mirbug_and_err {\n     })\n }\n \n+mod constraint_conversion;\n mod input_output;\n mod liveness;\n \n@@ -101,7 +104,9 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n+    location_table: &LocationTable,\n     liveness: &LivenessResults,\n+    all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n@@ -114,6 +119,11 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         mir,\n         &universal_regions.region_bound_pairs,\n         Some(implicit_region_bound),\n+        Some(BorrowCheckContext {\n+            universal_regions,\n+            location_table,\n+            all_facts,\n+        }),\n         &mut |cx| {\n             liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n@@ -129,6 +139,7 @@ fn type_check_internal<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n+    borrowck_context: Option<BorrowCheckContext<'_, 'tcx>>,\n     extra: &mut dyn FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(\n@@ -137,6 +148,8 @@ fn type_check_internal<'gcx, 'tcx>(\n         param_env,\n         region_bound_pairs,\n         implicit_region_bound,\n+        borrowck_context,\n+        mir,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -587,37 +600,32 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n+    borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+struct BorrowCheckContext<'a, 'tcx: 'a> {\n+    universal_regions: &'a UniversalRegions<'tcx>,\n+    location_table: &'a LocationTable,\n+    all_facts: &'a mut Option<AllFacts>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n #[derive(Default)]\n-pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n+crate struct MirTypeckRegionConstraints<'tcx> {\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n     /// cases, the MIR type-checker creates temporary regions that do\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    pub liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n+    crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n-    /// During the course of type-checking, we will accumulate region\n-    /// constraints due to performing subtyping operations or solving\n-    /// traits. These are accumulated into this vector for later use.\n-    pub outlives_sets: Vec<OutlivesSet<'tcx>>,\n-}\n-\n-/// Outlives relationships between regions and types created at a\n-/// particular point within the control-flow graph.\n-pub struct OutlivesSet<'tcx> {\n-    /// The locations associated with these constraints.\n-    pub locations: Locations,\n+    crate outlives_constraints: Vec<OutlivesConstraint>,\n \n-    /// Constraints generated. In terms of the NLL RFC, when you have\n-    /// a constraint `R1: R2 @ P`, the data in there specifies things\n-    /// like `R1: R2`.\n-    pub data: Rc<RegionConstraintData<'tcx>>,\n+    crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n /// The `Locations` type summarizes *where* region constraints are\n@@ -695,6 +703,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n+        borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+        mir: &'a Mir<'tcx>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -703,6 +713,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             param_env,\n             region_bound_pairs,\n             implicit_region_bound,\n+            borrowck_context,\n+            mir,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n         }\n@@ -750,9 +762,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             locations, data\n         );\n \n-        self.constraints\n-            .outlives_sets\n-            .push(OutlivesSet { locations, data });\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.mir,\n+                borrowck_context.universal_regions,\n+                borrowck_context.location_table,\n+                &mut self.constraints.outlives_constraints,\n+                &mut self.constraints.type_tests,\n+                &mut borrowck_context.all_facts,\n+            ).convert(locations, &data);\n+        }\n     }\n \n     /// Helper for `fully_perform_op`, but also used on its own\n@@ -1712,7 +1731,7 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _ = type_check_internal(&infcx, id, param_env, mir, &[], None, &mut |_| ());\n+            let _ = type_check_internal(&infcx, id, param_env, mir, &[], None, None, &mut |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}]}