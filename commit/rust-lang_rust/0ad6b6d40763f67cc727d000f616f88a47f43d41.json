{"sha": "0ad6b6d40763f67cc727d000f616f88a47f43d41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDZiNmQ0MDc2M2Y2N2NjNzI3ZDAwMGY2MTZmODhhNDdmNDNkNDE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-20T20:25:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-20T20:25:33Z"}, "message": "Merge #4061\n\n4061: ra_proc_macro: cleanups here and there r=edwin0cheng a=Veetaha\n\nr? @edwin0cheng \n\nCo-authored-by: veetaha <veetaha2@gmail.com>\nCo-authored-by: Veetaha <veetaha2@gmail.com>", "tree": {"sha": "af30190b11a1ffa2a18ebdd9c0ee69bfb771513a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af30190b11a1ffa2a18ebdd9c0ee69bfb771513a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad6b6d40763f67cc727d000f616f88a47f43d41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJengU9CRBK7hj4Ov3rIwAAdHIIAC4/qUmXF1v/KOpi2HPon80k\n5MdT31N1OZvIRhiCdaRdj4yYvVwxFPVRbOZnrwlUfoE6R9a78/Z6kiMLNHx9HDVA\n9NanDoRzgiEPZ0L9X3/cTYb0hnbzj65EpTLHHJc2Dlc5NnE/etbd8Yb6AWzSpLrC\n0Crs5/f24i8EKZL491cq0vs5K6nuXeC1z6THr0SXvN1QSTAyo7ZhXyX1lfvZXhkp\nqvhUP+VU9jI/uJhI2PZtCqP5zLPJdYQJbf+T19gP8XIr8b5P6GIgMhMjr+OPaWNM\nlV4X9zQYc4Hr6HjLKpwr6pqpgoEJDb/7KGDENW6mm6ulkuMJCHhxlcg+EiSLcFQ=\n=V+pU\n-----END PGP SIGNATURE-----\n", "payload": "tree af30190b11a1ffa2a18ebdd9c0ee69bfb771513a\nparent cd6d788c159240e3910b5df92b641f93d1cf79a5\nparent fc460b1e423c2c510a10539f8289af548685676c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587414333 +0000\ncommitter GitHub <noreply@github.com> 1587414333 +0000\n\nMerge #4061\n\n4061: ra_proc_macro: cleanups here and there r=edwin0cheng a=Veetaha\n\nr? @edwin0cheng \n\nCo-authored-by: veetaha <veetaha2@gmail.com>\nCo-authored-by: Veetaha <veetaha2@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad6b6d40763f67cc727d000f616f88a47f43d41", "html_url": "https://github.com/rust-lang/rust/commit/0ad6b6d40763f67cc727d000f616f88a47f43d41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad6b6d40763f67cc727d000f616f88a47f43d41/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6d788c159240e3910b5df92b641f93d1cf79a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6d788c159240e3910b5df92b641f93d1cf79a5", "html_url": "https://github.com/rust-lang/rust/commit/cd6d788c159240e3910b5df92b641f93d1cf79a5"}, {"sha": "fc460b1e423c2c510a10539f8289af548685676c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc460b1e423c2c510a10539f8289af548685676c", "html_url": "https://github.com/rust-lang/rust/commit/fc460b1e423c2c510a10539f8289af548685676c"}], "stats": {"total": 333, "additions": 142, "deletions": 191}, "files": [{"sha": "004943b9e0653becfe6b1daa7970624068178b9e", "filename": "crates/ra_proc_macro/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Flib.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -2,7 +2,7 @@\n //!\n //! We separate proc-macro expanding logic to an extern program to allow\n //! different implementations (e.g. wasm or dylib loading). And this crate\n-//! is used to provide basic infrastructure  for communication between two\n+//! is used to provide basic infrastructure for communication between two\n //! processes: Client (RA itself), Server (the external program)\n \n mod rpc;\n@@ -13,6 +13,7 @@ use process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n use ra_tt::{SmolStr, Subtree};\n use std::{\n     ffi::OsStr,\n+    io,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n@@ -57,14 +58,10 @@ pub struct ProcMacroClient {\n }\n \n impl ProcMacroClient {\n-    pub fn extern_process<I, S>(\n-        process_path: &Path,\n-        args: I,\n-    ) -> Result<ProcMacroClient, std::io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n+    pub fn extern_process(\n+        process_path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<ProcMacroClient> {\n         let (thread, process) = ProcMacroProcessSrv::run(process_path, args)?;\n         Ok(ProcMacroClient {\n             kind: ProcMacroClientKind::Process { process: Arc::new(process), thread },\n@@ -84,7 +81,7 @@ impl ProcMacroClient {\n             ProcMacroClientKind::Process { process, .. } => {\n                 let macros = match process.find_proc_macros(dylib_path) {\n                     Err(err) => {\n-                        eprintln!(\"Fail to find proc macro. Error: {:#?}\", err);\n+                        eprintln!(\"Failed to find proc macros. Error: {:#?}\", err);\n                         return vec![];\n                     }\n                     Ok(macros) => macros,"}, {"sha": "95d9b8804e1481615e64383e26dbd29ba56760bb", "filename": "crates/ra_proc_macro/src/msg.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -1,4 +1,4 @@\n-//! Defines messages for cross-process message based on `ndjson` wire protocol\n+//! Defines messages for cross-process message passing based on `ndjson` wire protocol\n \n use std::{\n     convert::TryFrom,\n@@ -31,7 +31,7 @@ macro_rules! impl_try_from_response {\n             fn try_from(value: Response) -> Result<Self, Self::Error> {\n                 match value {\n                     Response::$tag(res) => Ok(res),\n-                    _ => Err(\"Fail to convert from response\"),\n+                    _ => Err(concat!(\"Failed to convert response to \", stringify!($tag))),\n                 }\n             }\n         }\n@@ -53,18 +53,16 @@ pub enum ErrorCode {\n     ExpansionError,\n }\n \n-pub trait Message: Sized + Serialize + DeserializeOwned {\n-    fn read(r: &mut impl BufRead) -> io::Result<Option<Self>> {\n-        let text = match read_json(r)? {\n-            None => return Ok(None),\n-            Some(text) => text,\n-        };\n-        let msg = serde_json::from_str(&text)?;\n-        Ok(Some(msg))\n+pub trait Message: Serialize + DeserializeOwned {\n+    fn read(inp: &mut impl BufRead) -> io::Result<Option<Self>> {\n+        Ok(match read_json(inp)? {\n+            None => None,\n+            Some(text) => Some(serde_json::from_str(&text)?),\n+        })\n     }\n-    fn write(self, w: &mut impl Write) -> io::Result<()> {\n+    fn write(self, out: &mut impl Write) -> io::Result<()> {\n         let text = serde_json::to_string(&self)?;\n-        write_json(w, &text)\n+        write_json(out, &text)\n     }\n }\n \n@@ -73,15 +71,12 @@ impl Message for Response {}\n \n fn read_json(inp: &mut impl BufRead) -> io::Result<Option<String>> {\n     let mut buf = String::new();\n-    if inp.read_line(&mut buf)? == 0 {\n-        return Ok(None);\n-    }\n-    // Remove ending '\\n'\n-    let buf = &buf[..buf.len() - 1];\n-    if buf.is_empty() {\n-        return Ok(None);\n-    }\n-    Ok(Some(buf.to_string()))\n+    inp.read_line(&mut buf)?;\n+    buf.pop(); // Remove traling '\\n'\n+    Ok(match buf.len() {\n+        0 => None,\n+        _ => Some(buf),\n+    })\n }\n \n fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {"}, {"sha": "e24944af4b9a0e2938ec5a4d17ab338d603180c2", "filename": "crates/ra_proc_macro/src/process.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -45,24 +45,23 @@ impl Drop for Process {\n }\n \n impl Process {\n-    fn run<I, S>(process_path: &Path, args: I) -> Result<Process, io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n-        let child = Command::new(process_path.clone())\n+    fn run(\n+        process_path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<Process> {\n+        let child = Command::new(&process_path)\n             .args(args)\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped())\n             .stderr(Stdio::null())\n             .spawn()?;\n \n-        Ok(Process { path: process_path.into(), child })\n+        Ok(Process { path: process_path, child })\n     }\n \n-    fn restart(&mut self) -> Result<(), io::Error> {\n+    fn restart(&mut self) -> io::Result<()> {\n         let _ = self.child.kill();\n-        self.child = Command::new(self.path.clone())\n+        self.child = Command::new(&self.path)\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped())\n             .stderr(Stdio::null())\n@@ -80,14 +79,10 @@ impl Process {\n }\n \n impl ProcMacroProcessSrv {\n-    pub fn run<I, S>(\n-        process_path: &Path,\n-        args: I,\n-    ) -> Result<(ProcMacroProcessThread, ProcMacroProcessSrv), io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n+    pub fn run(\n+        process_path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<(ProcMacroProcessThread, ProcMacroProcessSrv)> {\n         let process = Process::run(process_path, args)?;\n \n         let (task_tx, task_rx) = bounded(0);\n@@ -201,7 +196,7 @@ fn send_request(\n     mut writer: &mut impl Write,\n     mut reader: &mut impl BufRead,\n     req: Request,\n-) -> Result<Option<Response>, io::Error> {\n+) -> io::Result<Option<Response>> {\n     req.write(&mut writer)?;\n     Ok(Response::read(&mut reader)?)\n }"}, {"sha": "4ce485926369ed23f21a06492e9f991c57d1c845", "filename": "crates/ra_proc_macro/src/rpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -1,9 +1,9 @@\n-//! Data struture serialization related stuffs for RPC\n+//! Data struture serialization related stuff for RPC\n //!\n-//! Define all necessary rpc serialization data structure,\n-//! which include ra_tt related data and some task messages.\n-//! Although adding Serialize and Deserialize trait to ra_tt directly seem to be much easier,\n-//! we deliberately duplicate the ra_tt struct with #[serde(with = \"XXDef\")]\n+//! Defines all necessary rpc serialization data structures,\n+//! which includes `ra_tt` related data and some task messages.\n+//! Although adding `Serialize` and `Deserialize` traits to `ra_tt` directly seems\n+//! to be much easier, we deliberately duplicate `ra_tt` structs with `#[serde(with = \"XXDef\")]`\n //! for separation of code responsibility.\n \n use ra_tt::{\n@@ -34,15 +34,15 @@ pub struct ListMacrosResult {\n pub struct ExpansionTask {\n     /// Argument of macro call.\n     ///\n-    /// In custom derive that would be a struct or enum; in attribute-like macro - underlying\n+    /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n     /// item; in function-like macro - the macro body.\n     #[serde(with = \"SubtreeDef\")]\n     pub macro_body: Subtree,\n \n-    /// Names of macros to expand.\n+    /// Name of macro to expand.\n     ///\n-    /// In custom derive those are names of derived traits (`Serialize`, `Getters`, etc.). In\n-    /// attribute-like and functiona-like macros - single name of macro itself (`show_streams`).\n+    /// In custom derive this is the name of the derived trait (`Serialize`, `Getters`, etc.).\n+    /// In attribute-like and function-like macros - single name of macro itself (`show_streams`).\n     pub macro_name: String,\n \n     /// Possible attributes for the attribute-like macros."}, {"sha": "5f1f3ba3c7d8582483555518bf7911575310aeec", "filename": "crates/ra_proc_macro_srv/src/cli.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -2,55 +2,43 @@\n \n use crate::{expand_task, list_macros};\n use ra_proc_macro::msg::{self, Message};\n-\n use std::io;\n \n-fn read_request() -> Result<Option<msg::Request>, io::Error> {\n-    let stdin = io::stdin();\n-    let mut stdin = stdin.lock();\n-    msg::Request::read(&mut stdin)\n-}\n-\n-fn write_response(res: Result<msg::Response, String>) -> Result<(), io::Error> {\n-    let msg: msg::Response = match res {\n-        Ok(res) => res,\n-        Err(err) => msg::Response::Error(msg::ResponseError {\n-            code: msg::ErrorCode::ExpansionError,\n-            message: err,\n-        }),\n-    };\n-\n-    let stdout = io::stdout();\n-    let mut stdout = stdout.lock();\n-    msg.write(&mut stdout)\n-}\n-\n pub fn run() {\n     loop {\n         let req = match read_request() {\n             Err(err) => {\n-                eprintln!(\"Read message error on ra_proc_macro_srv: {}\", err.to_string());\n+                eprintln!(\"Read message error on ra_proc_macro_srv: {}\", err);\n                 continue;\n             }\n             Ok(None) => continue,\n             Ok(Some(req)) => req,\n         };\n \n-        match req {\n-            msg::Request::ListMacro(task) => {\n-                if let Err(err) =\n-                    write_response(list_macros(&task).map(|it| msg::Response::ListMacro(it)))\n-                {\n-                    eprintln!(\"Write message error on list macro: {}\", err);\n-                }\n-            }\n+        let res = match req {\n+            msg::Request::ListMacro(task) => Ok(msg::Response::ListMacro(list_macros(&task))),\n             msg::Request::ExpansionMacro(task) => {\n-                if let Err(err) =\n-                    write_response(expand_task(&task).map(|it| msg::Response::ExpansionMacro(it)))\n-                {\n-                    eprintln!(\"Write message error on expansion macro: {}\", err);\n-                }\n+                expand_task(&task).map(msg::Response::ExpansionMacro)\n             }\n+        };\n+\n+        let msg = res.unwrap_or_else(|err| {\n+            msg::Response::Error(msg::ResponseError {\n+                code: msg::ErrorCode::ExpansionError,\n+                message: err,\n+            })\n+        });\n+\n+        if let Err(err) = write_response(msg) {\n+            eprintln!(\"Write message error: {}\", err);\n         }\n     }\n }\n+\n+fn read_request() -> io::Result<Option<msg::Request>> {\n+    msg::Request::read(&mut io::stdin().lock())\n+}\n+\n+fn write_response(msg: msg::Response) -> io::Result<()> {\n+    msg.write(&mut io::stdout().lock())\n+}"}, {"sha": "d202eb0fde42fb21d5fd7ba81d8453f9c2896823", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 45, "deletions": 58, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -9,43 +9,37 @@ use libloading::Library;\n use memmap::Mmap;\n use ra_proc_macro::ProcMacroKind;\n \n-use std::io::Error as IoError;\n-use std::io::ErrorKind as IoErrorKind;\n+use std::io;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n-fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> IoError {\n-    IoError::new(IoErrorKind::InvalidData, e)\n+fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n+    io::Error::new(io::ErrorKind::InvalidData, e)\n }\n \n fn is_derive_registrar_symbol(symbol: &str) -> bool {\n     symbol.contains(NEW_REGISTRAR_SYMBOL)\n }\n \n-fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n+fn find_registrar_symbol(file: &Path) -> io::Result<Option<String>> {\n     let file = File::open(file)?;\n     let buffer = unsafe { Mmap::map(&file)? };\n     let object = Object::parse(&buffer).map_err(invalid_data_err)?;\n \n-    match object {\n+    let name = match object {\n         Object::Elf(elf) => {\n             let symbols = elf.dynstrtab.to_vec().map_err(invalid_data_err)?;\n-            let name =\n-                symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| s.to_string());\n-            Ok(name)\n-        }\n-        Object::PE(pe) => {\n-            let name = pe\n-                .exports\n-                .iter()\n-                .flat_map(|s| s.name)\n-                .find(|s| is_derive_registrar_symbol(s))\n-                .map(|s| s.to_string());\n-            Ok(name)\n+            symbols.into_iter().find(|s| is_derive_registrar_symbol(s)).map(&str::to_owned)\n         }\n+        Object::PE(pe) => pe\n+            .exports\n+            .iter()\n+            .flat_map(|s| s.name)\n+            .find(|s| is_derive_registrar_symbol(s))\n+            .map(&str::to_owned),\n         Object::Mach(Mach::Binary(binary)) => {\n             let exports = binary.exports().map_err(invalid_data_err)?;\n-            let name = exports\n+            exports\n                 .iter()\n                 .map(|s| {\n                     // In macos doc:\n@@ -59,11 +53,11 @@ fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n                     }\n                 })\n                 .find(|s| is_derive_registrar_symbol(s))\n-                .map(|s| s.to_string());\n-            Ok(name)\n+                .map(&str::to_owned)\n         }\n-        _ => Ok(None),\n-    }\n+        _ => return Ok(None),\n+    };\n+    return Ok(name);\n }\n \n /// Loads dynamic library in platform dependent manner.\n@@ -93,15 +87,16 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n }\n \n struct ProcMacroLibraryLibloading {\n-    // Hold the dylib to prevent it for unloadeding\n+    // Hold the dylib to prevent it from unloading\n     _lib: Library,\n     exported_macros: Vec<bridge::client::ProcMacro>,\n }\n \n impl ProcMacroLibraryLibloading {\n-    fn open(file: &Path) -> Result<Self, IoError> {\n-        let symbol_name = find_registrar_symbol(file)?\n-            .ok_or(invalid_data_err(format!(\"Cannot find registrar symbol in file {:?}\", file)))?;\n+    fn open(file: &Path) -> io::Result<Self> {\n+        let symbol_name = find_registrar_symbol(file)?.ok_or_else(|| {\n+            invalid_data_err(format!(\"Cannot find registrar symbol in file {}\", file.display()))\n+        })?;\n \n         let lib = load_library(file).map_err(invalid_data_err)?;\n         let exported_macros = {\n@@ -121,18 +116,16 @@ pub struct Expander {\n }\n \n impl Expander {\n-    pub fn new<P: AsRef<Path>>(lib: &P) -> Result<Expander, String> {\n-        let mut libs = vec![];\n-        /* Some libraries for dynamic loading require canonicalized path (even when it is\n-        already absolute\n-        */\n-        let lib =\n-            lib.as_ref().canonicalize().expect(&format!(\"Cannot canonicalize {:?}\", lib.as_ref()));\n+    pub fn new(lib: &Path) -> Result<Expander, String> {\n+        // Some libraries for dynamic loading require canonicalized path even when it is\n+        // already absolute\n+        let lib = lib\n+            .canonicalize()\n+            .unwrap_or_else(|err| panic!(\"Cannot canonicalize {}: {:?}\", lib.display(), err));\n \n         let library = ProcMacroLibraryImpl::open(&lib).map_err(|e| e.to_string())?;\n-        libs.push(library);\n \n-        Ok(Expander { libs })\n+        Ok(Expander { libs: vec![library] })\n     }\n \n     pub fn expand(\n@@ -176,7 +169,6 @@ impl Expander {\n                             parsed_attributes,\n                             parsed_body,\n                         );\n-\n                         return res.map(|it| it.subtree);\n                     }\n                     _ => continue,\n@@ -187,26 +179,21 @@ impl Expander {\n         Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n     }\n \n-    pub fn list_macros(&self) -> Result<Vec<(String, ProcMacroKind)>, bridge::PanicMessage> {\n-        let mut result = vec![];\n-\n-        for lib in &self.libs {\n-            for proc_macro in &lib.exported_macros {\n-                let res = match proc_macro {\n-                    bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                        (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                    }\n-                    bridge::client::ProcMacro::Bang { name, .. } => {\n-                        (name.to_string(), ProcMacroKind::FuncLike)\n-                    }\n-                    bridge::client::ProcMacro::Attr { name, .. } => {\n-                        (name.to_string(), ProcMacroKind::Attr)\n-                    }\n-                };\n-                result.push(res);\n-            }\n-        }\n-\n-        Ok(result)\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.libs\n+            .iter()\n+            .flat_map(|it| &it.exported_macros)\n+            .map(|proc_macro| match proc_macro {\n+                bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n     }\n }"}, {"sha": "3aca859db34b03e089c5fc8c7e9524556bc54a26", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -3,10 +3,10 @@\n //! This library is able to call compiled Rust custom derive dynamic libraries on arbitrary code.\n //! The general idea here is based on https://github.com/fedochet/rust-proc-macro-expander.\n //!\n-//! But we change some several design for fitting RA needs:\n+//! But we adapt it to better fit RA needs:\n //!\n-//! * We use `ra_tt` for proc-macro `TokenStream` server, it is easy to manipute and interact with\n-//!   RA then proc-macro2 token stream.\n+//! * We use `ra_tt` for proc-macro `TokenStream` server, it is easier to manipulate and interact with\n+//!   RA than `proc-macro2` token stream.\n //! * By **copying** the whole rustc `lib_proc_macro` code, we are able to build this with `stable`\n //!   rustc rather than `unstable`. (Although in gerenal ABI compatibility is still an issue)\n \n@@ -21,36 +21,28 @@ mod dylib;\n \n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n+use std::path::Path;\n \n pub(crate) fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-    let expander = dylib::Expander::new(&task.lib)\n-        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+    let expander = create_expander(&task.lib);\n \n     match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n         Ok(expansion) => Ok(ExpansionResult { expansion }),\n         Err(msg) => {\n-            let reason = format!(\n-                \"Cannot perform expansion for {}: error {:?}!\",\n-                &task.macro_name,\n-                msg.as_str()\n-            );\n-            Err(reason)\n+            Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n         }\n     }\n }\n \n-pub(crate) fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n-    let expander = dylib::Expander::new(&task.lib)\n-        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+pub(crate) fn list_macros(task: &ListMacrosTask) -> ListMacrosResult {\n+    let expander = create_expander(&task.lib);\n \n-    match expander.list_macros() {\n-        Ok(macros) => Ok(ListMacrosResult { macros }),\n-        Err(msg) => {\n-            let reason =\n-                format!(\"Cannot perform expansion for {:?}: error {:?}!\", &task.lib, msg.as_str());\n-            Err(reason)\n-        }\n-    }\n+    ListMacrosResult { macros: expander.list_macros() }\n+}\n+\n+fn create_expander(lib: &Path) -> dylib::Expander {\n+    dylib::Expander::new(lib)\n+        .unwrap_or_else(|err| panic!(\"Cannot create expander for {}: {:?}\", lib.display(), err))\n }\n \n pub mod cli;"}, {"sha": "f481d70b22f51de03b2bf44510b379cedccd147f", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -6,7 +6,7 @@\n //! The original idea from fedochet is using proc-macro2 as backend,\n //! we use ra_tt instead for better intergation with RA.\n //!\n-//! FIXME: No span and source file informatin is implemented yet\n+//! FIXME: No span and source file information is implemented yet\n \n use crate::proc_macro::bridge::{self, server};\n use ra_tt as tt;"}, {"sha": "2139ec7a4dac87a960b255da09a67c265cfb2a71", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -60,6 +60,6 @@ pub fn list(crate_name: &str, version: &str) -> Vec<String> {\n     let path = fixtures::dylib_path(crate_name, version);\n     let task = ListMacrosTask { lib: path };\n \n-    let res = list_macros(&task).unwrap();\n+    let res = list_macros(&task);\n     res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n }"}, {"sha": "e8d5dad6577c84945fe01043cbf859167e564403", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -51,7 +51,7 @@ fn main() -> Result<()> {\n             cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n         }\n \n-        args::Command::ProcMacro => run_proc_macro_sv()?,\n+        args::Command::ProcMacro => run_proc_macro_srv()?,\n         args::Command::RunServer => run_server()?,\n         args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n     }\n@@ -65,7 +65,7 @@ fn setup_logging() -> Result<()> {\n     Ok(())\n }\n \n-fn run_proc_macro_sv() -> Result<()> {\n+fn run_proc_macro_srv() -> Result<()> {\n     ra_proc_macro_srv::cli::run();\n     Ok(())\n }"}, {"sha": "d0a71120aafb390fb73ee45647fd5f7884a9d153", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -76,7 +76,7 @@ pub(crate) fn load_cargo(\n         ProcMacroClient::dummy()\n     } else {\n         let path = std::env::current_exe()?;\n-        ProcMacroClient::extern_process(&path, &[\"proc-macro\"]).unwrap()\n+        ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap()\n     };\n     let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs, &proc_macro_client);\n     Ok((host, source_roots))"}, {"sha": "8e1744bf9026b30bd6e719119ae6f77f3aba945e", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad6b6d40763f67cc727d000f616f88a47f43d41/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=0ad6b6d40763f67cc727d000f616f88a47f43d41", "patch": "@@ -148,20 +148,17 @@ impl WorldState {\n \n         let proc_macro_client = match &config.proc_macro_srv {\n             None => ProcMacroClient::dummy(),\n-            Some((path, args)) => {\n-                let path = std::path::Path::new(path);\n-                match ProcMacroClient::extern_process(path, args) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        log::error!(\n-                            \"Fail to run ra_proc_macro_srv from path {}, error : {}\",\n-                            path.to_string_lossy(),\n-                            err\n-                        );\n-                        ProcMacroClient::dummy()\n-                    }\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+                Ok(it) => it,\n+                Err(err) => {\n+                    log::error!(\n+                        \"Fail to run ra_proc_macro_srv from path {}, error: {:?}\",\n+                        path,\n+                        err\n+                    );\n+                    ProcMacroClient::dummy()\n                 }\n-            }\n+            },\n         };\n \n         workspaces"}]}