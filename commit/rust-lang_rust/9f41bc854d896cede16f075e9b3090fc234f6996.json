{"sha": "9f41bc854d896cede16f075e9b3090fc234f6996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDFiYzg1NGQ4OTZjZWRlMTZmMDc1ZTliMzA5MGZjMjM0ZjY5OTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-29T14:14:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-29T14:14:24Z"}, "message": "Don't duplicate ivec-iterating loop code\n\ntrans_ivec is starting to look almost pleasant", "tree": {"sha": "0f9e5aef0a406e59ad03858d97c1758ce72fba90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f9e5aef0a406e59ad03858d97c1758ce72fba90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f41bc854d896cede16f075e9b3090fc234f6996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f41bc854d896cede16f075e9b3090fc234f6996", "html_url": "https://github.com/rust-lang/rust/commit/9f41bc854d896cede16f075e9b3090fc234f6996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f41bc854d896cede16f075e9b3090fc234f6996/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9084a3ca1b5fd3a68b7163914a9005a2a7357f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/9084a3ca1b5fd3a68b7163914a9005a2a7357f43", "html_url": "https://github.com/rust-lang/rust/commit/9084a3ca1b5fd3a68b7163914a9005a2a7357f43"}], "stats": {"total": 132, "additions": 42, "deletions": 90}, "files": [{"sha": "5ee03bf8a83fef9830b0e0b2bce51b45b376a026", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 42, "deletions": 90, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9f41bc854d896cede16f075e9b3090fc234f6996/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f41bc854d896cede16f075e9b3090fc234f6996/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=9f41bc854d896cede16f075e9b3090fc234f6996", "patch": "@@ -151,37 +151,22 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let lhs_data = get_dataptr(bcx, lhs, llunitty);\n     let lhs_off = lfill;\n-    if strings { lhs_off = Sub(bcx, lfill, C_int(1)); }\n+    if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill(bcx, write_ptr);\n-    let end_ptr = pointer_add(bcx, write_ptr, rfill);\n-    let read_ptr_ptr = do_spill(bcx, get_dataptr(bcx, rhs, llunitty));\n-\n-    let header_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_header\");\n-    Br(bcx, header_cx.llbb);\n-    let write_ptr = Load(header_cx, write_ptr_ptr);\n-    let not_yet_at_end = ICmp(header_cx, lib::llvm::LLVMIntNE,\n-                              write_ptr, end_ptr);\n-    let body_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    CondBr(header_cx, not_yet_at_end,\n-           body_cx.llbb, next_cx.llbb);\n-\n-    let read_ptr = Load(body_cx, read_ptr_ptr);\n-    let body_cx = copy_val(body_cx, INIT, write_ptr,\n-                           load_if_immediate(body_cx, read_ptr, unit_ty),\n-                           unit_ty);\n-    // Increment both pointers.\n-    if dynamic {\n-        // We have to increment by the dynamically-computed size.\n-        incr_ptr(body_cx, write_ptr, unit_sz, write_ptr_ptr);\n-        incr_ptr(body_cx, read_ptr, unit_sz, read_ptr_ptr);\n-    } else {\n-        incr_ptr(body_cx, write_ptr, C_int(1), write_ptr_ptr);\n-        incr_ptr(body_cx, read_ptr, C_int(1), read_ptr_ptr);\n-    }\n-    Br(body_cx, header_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rfill, { | &bcx, addr, _ty |\n+        let write_ptr = Load(bcx, write_ptr_ptr);\n+        let bcx = copy_val(bcx, INIT, write_ptr,\n+                           load_if_immediate(bcx, addr, unit_ty), unit_ty);\n+        if dynamic {\n+            // We have to increment by the dynamically-computed size.\n+            incr_ptr(bcx, write_ptr, unit_sz, write_ptr_ptr);\n+        } else {\n+            incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n+        }\n+        ret rslt(bcx, C_nil());\n+    }).bcx;\n+    ret rslt(bcx, C_nil());\n }\n \n fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n@@ -216,75 +201,35 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let {bcx, val: new_vec, unit_ty, llunitsz, llunitty} =\n         alloc(bcx, vec_ty, new_fill, true);\n \n-    // Emit the copy loop\n     let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n-    let lhs_ptr = get_dataptr(bcx, lhs, llunitty);\n-    let lhs_ptr_ptr = do_spill(bcx, lhs_ptr);\n-    let lhs_end_ptr = pointer_add(bcx, lhs_ptr, lhs_fill);\n-    let rhs_ptr = get_dataptr(bcx, rhs, llunitty);\n-    let rhs_ptr_ptr = do_spill(bcx, rhs_ptr);\n-    let rhs_end_ptr = pointer_add(bcx, rhs_ptr, rhs_fill);\n+    let copy_block = { | &bcx, addr, _ty |\n+        let write_ptr = Load(bcx, write_ptr_ptr);\n+        let bcx = copy_val(bcx, INIT, write_ptr,\n+                           load_if_immediate(bcx, addr, unit_ty), unit_ty);\n+        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+            // We have to increment by the dynamically-computed size.\n+            incr_ptr(bcx, write_ptr, llunitsz, write_ptr_ptr);\n+        } else {\n+            incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n+        }\n+        ret rslt(bcx, C_nil());\n+    };\n \n-    // Copy in elements from the LHS.\n-    let lhs_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy_header\");\n-    Br(bcx, lhs_cx.llbb);\n-    let lhs_ptr = Load(lhs_cx, lhs_ptr_ptr);\n-    let not_at_end_lhs =\n-        ICmp(lhs_cx, lib::llvm::LLVMIntNE, lhs_ptr, lhs_end_ptr);\n-    let lhs_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy_body\");\n-    let rhs_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy_header\");\n-    CondBr(lhs_cx, not_at_end_lhs, lhs_copy_cx.llbb, rhs_cx.llbb);\n-    let write_ptr = Load(lhs_copy_cx, write_ptr_ptr);\n-    lhs_copy_cx =\n-        copy_val(lhs_copy_cx, INIT, write_ptr,\n-                 load_if_immediate(lhs_copy_cx, lhs_ptr, unit_ty), unit_ty);\n-    // Increment both pointers.\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        // We have to increment by the dynamically-computed size.\n-        incr_ptr(lhs_copy_cx, write_ptr, llunitsz, write_ptr_ptr);\n-        incr_ptr(lhs_copy_cx, lhs_ptr, llunitsz, lhs_ptr_ptr);\n-    } else {\n-        incr_ptr(lhs_copy_cx, write_ptr, C_int(1), write_ptr_ptr);\n-        incr_ptr(lhs_copy_cx, lhs_ptr, C_int(1), lhs_ptr_ptr);\n-    }\n-    Br(lhs_copy_cx, lhs_cx.llbb);\n+    let bcx = iter_ivec_raw(bcx, lhs, vec_ty, lhs_fill, copy_block).bcx;\n+    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rhs_fill, copy_block).bcx;\n+    ret rslt(bcx, new_vec);\n+}\n \n-    // Copy in elements from the RHS.\n-    let rhs_ptr = Load(rhs_cx, rhs_ptr_ptr);\n-    let not_at_end_rhs =\n-        ICmp(rhs_cx, lib::llvm::LLVMIntNE, rhs_ptr, rhs_end_ptr);\n-    let rhs_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    CondBr(rhs_cx, not_at_end_rhs, rhs_copy_cx.llbb, next_cx.llbb);\n-    let write_ptr = Load(rhs_copy_cx, write_ptr_ptr);\n-    rhs_copy_cx =\n-        copy_val(rhs_copy_cx, INIT, write_ptr,\n-                 load_if_immediate(rhs_copy_cx, rhs_ptr, unit_ty), unit_ty);\n-    // Increment both pointers.\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        // We have to increment by the dynamically-computed size.\n-        incr_ptr(rhs_copy_cx, write_ptr, llunitsz, write_ptr_ptr);\n-        incr_ptr(rhs_copy_cx, rhs_ptr, llunitsz, rhs_ptr_ptr);\n-    } else {\n-        incr_ptr(rhs_copy_cx, write_ptr, C_int(1), write_ptr_ptr);\n-        incr_ptr(rhs_copy_cx, rhs_ptr, C_int(1), rhs_ptr_ptr);\n-    }\n-    Br(rhs_copy_cx, rhs_cx.llbb);\n+type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n \n-    ret rslt(next_cx, new_vec);\n-}\n+type iter_ivec_block = block(&@block_ctxt, ValueRef, ty::t) -> result;\n \n-// FIXME factor out a utility that can be used to create the loops built\n-// above\n-fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-             f: &trans::val_and_ty_fn) -> result {\n+fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n+                 fill: ValueRef, f: &iter_ivec_block) -> result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-\n-    let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n-                                     T_ptr(T_ptr(T_ivec(llunitty)))));\n-    let fill = get_fill(bcx, vptr);\n+    let vptr = PointerCast(bcx, vptr, T_ptr(T_ivec(llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n@@ -312,6 +257,13 @@ fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret rslt(next_cx, C_nil());\n }\n \n+fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+             f: &iter_ivec_block) -> result {\n+    let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n+                                     T_ptr(T_ptr(T_opaque_ivec()))));\n+    ret iter_ivec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}