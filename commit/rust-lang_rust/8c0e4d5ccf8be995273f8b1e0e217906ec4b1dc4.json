{"sha": "8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "node_id": "C_kwDOAAsO6NoAKDhjMGU0ZDVjY2Y4YmU5OTUyNzNmOGIxZTBlMjE3OTA2ZWM0YjFkYzQ", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-01-10T23:51:43Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-09-30T19:07:58Z"}, "message": "Rewrite shadow lint", "tree": {"sha": "503eb03a33aebb2af38350c0502e00767a3a0246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/503eb03a33aebb2af38350c0502e00767a3a0246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "html_url": "https://github.com/rust-lang/rust/commit/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99861c0e88493e6f8fa1363d7040866bfef912ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/99861c0e88493e6f8fa1363d7040866bfef912ac", "html_url": "https://github.com/rust-lang/rust/commit/99861c0e88493e6f8fa1363d7040866bfef912ac"}], "stats": {"total": 786, "additions": 379, "deletions": 407}, "files": [{"sha": "4e21b03217dfa71b27f06482aa41073892252389", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -324,7 +324,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n-    store.register_late_pass(|| Box::new(shadow::Shadow));\n+    store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n     store.register_late_pass(|| Box::new(unit_types::UnitTypes));\n     store.register_late_pass(|| Box::new(loops::Loops));\n     store.register_late_pass(|| Box::new(main_recursion::MainRecursion::default()));"}, {"sha": "2ca7c18800ee2e362e299393058239cf35324ce3", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 126, "deletions": 297, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -1,17 +1,14 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::span_lint_and_note;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_name, higher, iter_input_pats};\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{\n-    Block, Body, Expr, ExprKind, FnDecl, Guard, HirId, Local, MutTy, Pat, PatKind, Path, QPath, StmtKind, Ty, TyKind,\n-    UnOp,\n-};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use clippy_utils::visitors::is_local_used;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::hir_id::ItemLocalId;\n+use rustc_hir::{Block, Body, BodyOwnerKind, Expr, ExprKind, HirId, Node, Pat, PatKind, QPath, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -23,10 +20,6 @@ declare_clippy_lint! {\n     /// code. Still, some may opt to avoid it in their code base, they can set this\n     /// lint to `Warn`.\n     ///\n-    /// ### Known problems\n-    /// This lint, as the other shadowing related lints,\n-    /// currently only catches very simple patterns.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// # let x = 1;\n@@ -52,10 +45,6 @@ declare_clippy_lint! {\n     /// because a value may be bound to different things depending on position in\n     /// the code.\n     ///\n-    /// ### Known problems\n-    /// This lint, as the other shadowing related lints,\n-    /// currently only catches very simple patterns.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// let x = 2;\n@@ -83,12 +72,6 @@ declare_clippy_lint! {\n     /// any place in the code. This can be alleviated by either giving more specific\n     /// names to bindings or introducing more scopes to contain the bindings.\n     ///\n-    /// ### Known problems\n-    /// This lint, as the other shadowing related lints,\n-    /// currently only catches very simple patterns. Note that\n-    /// `allow`/`warn`/`deny`/`forbid` attributes only work on the function level\n-    /// for this lint.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// # let y = 1;\n@@ -106,301 +89,147 @@ declare_clippy_lint! {\n     \"rebinding a name without even using the original value\"\n }\n \n-declare_lint_pass!(Shadow => [SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED]);\n+#[derive(Default)]\n+pub(crate) struct Shadow {\n+    bindings: Vec<FxHashMap<Symbol, Vec<ItemLocalId>>>,\n+}\n+\n+impl_lint_pass!(Shadow => [SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED]);\n \n impl<'tcx> LateLintPass<'tcx> for Shadow {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        body: &'tcx Body<'_>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        if in_external_macro(cx.sess(), body.value.span) {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        let (id, ident) = match pat.kind {\n+            PatKind::Binding(_, hir_id, ident, _) => (hir_id, ident),\n+            _ => return,\n+        };\n+        if ident.span.from_expansion() || ident.span.is_dummy() {\n             return;\n         }\n-        check_fn(cx, decl, body);\n-    }\n-}\n+        let HirId { owner, local_id } = id;\n+\n+        // get (or insert) the list of items for this owner and symbol\n+        let data = self.bindings.last_mut().unwrap();\n+        let items_with_name = data.entry(ident.name).or_default();\n \n-fn check_fn<'tcx>(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Body<'_>) {\n-    let mut bindings = Vec::with_capacity(decl.inputs.len());\n-    for arg in iter_input_pats(decl, body) {\n-        if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n-            bindings.push((ident.name, ident.span));\n+        // check other bindings with the same name, most recently seen first\n+        for &prev in items_with_name.iter().rev() {\n+            if prev == local_id {\n+                // repeated binding in an `Or` pattern\n+                return;\n+            }\n+\n+            if is_shadow(cx, owner, prev, local_id) {\n+                let prev_hir_id = HirId { owner, local_id: prev };\n+                lint_shadow(cx, pat, prev_hir_id, ident.span);\n+                // only lint against the \"nearest\" shadowed binding\n+                break;\n+            }\n         }\n+        // store the binding\n+        items_with_name.push(local_id);\n     }\n-    check_expr(cx, &body.value, &mut bindings);\n-}\n \n-fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n-    let len = bindings.len();\n-    for stmt in block.stmts {\n-        match stmt.kind {\n-            StmtKind::Local(local) => check_local(cx, local, bindings),\n-            StmtKind::Expr(e) | StmtKind::Semi(e) => check_expr(cx, e, bindings),\n-            StmtKind::Item(..) => {},\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n+        let hir = cx.tcx.hir();\n+        if !matches!(hir.body_owner_kind(hir.body_owner(body.id())), BodyOwnerKind::Closure) {\n+            self.bindings.push(FxHashMap::default());\n         }\n     }\n-    if let Some(o) = block.expr {\n-        check_expr(cx, o, bindings);\n-    }\n-    bindings.truncate(len);\n-}\n \n-fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n-    if in_external_macro(cx.sess(), local.span) {\n-        return;\n-    }\n-    if higher::is_from_for_desugar(local) {\n-        return;\n-    }\n-    let Local {\n-        pat,\n-        ref ty,\n-        ref init,\n-        span,\n-        ..\n-    } = *local;\n-    if let Some(t) = *ty {\n-        check_ty(cx, t, bindings);\n-    }\n-    if let Some(o) = *init {\n-        check_expr(cx, o, bindings);\n-        check_pat(cx, pat, Some(o), span, bindings);\n-    } else {\n-        check_pat(cx, pat, None, span, bindings);\n+    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n+        let hir = cx.tcx.hir();\n+        if !matches!(hir.body_owner_kind(hir.body_owner(body.id())), BodyOwnerKind::Closure) {\n+            self.bindings.pop();\n+        }\n     }\n }\n \n-fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n-    let var_ty = cx.typeck_results().node_type_opt(pat_id);\n-    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind(), ty::Adt(..)))\n+fn is_shadow(cx: &LateContext<'_>, owner: LocalDefId, first: ItemLocalId, second: ItemLocalId) -> bool {\n+    let scope_tree = cx.tcx.region_scope_tree(owner.to_def_id());\n+    let first_scope = scope_tree.var_scope(first);\n+    let second_scope = scope_tree.var_scope(second);\n+    scope_tree.is_subscope_of(second_scope, first_scope)\n }\n \n-fn check_pat<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    init: Option<&'tcx Expr<'_>>,\n-    span: Span,\n-    bindings: &mut Vec<(Symbol, Span)>,\n-) {\n-    // TODO: match more stuff / destructuring\n-    match pat.kind {\n-        PatKind::Binding(.., ident, ref inner) => {\n-            let name = ident.name;\n-            if is_binding(cx, pat.hir_id) {\n-                let mut new_binding = true;\n-                for tup in bindings.iter_mut() {\n-                    if tup.0 == name {\n-                        lint_shadow(cx, name, span, pat.span, init, tup.1);\n-                        tup.1 = ident.span;\n-                        new_binding = false;\n-                        break;\n-                    }\n-                }\n-                if new_binding {\n-                    bindings.push((name, ident.span));\n-                }\n-            }\n-            if let Some(p) = *inner {\n-                check_pat(cx, p, init, span, bindings);\n-            }\n-        },\n-        PatKind::Struct(_, pfields, _) => {\n-            if let Some(init_struct) = init {\n-                if let ExprKind::Struct(_, efields, _) = init_struct.kind {\n-                    for field in pfields {\n-                        let name = field.ident.name;\n-                        let efield = efields\n-                            .iter()\n-                            .find_map(|f| if f.ident.name == name { Some(&*f.expr) } else { None });\n-                        check_pat(cx, field.pat, efield, span, bindings);\n-                    }\n-                } else {\n-                    for field in pfields {\n-                        check_pat(cx, field.pat, init, span, bindings);\n-                    }\n-                }\n-            } else {\n-                for field in pfields {\n-                    check_pat(cx, field.pat, None, span, bindings);\n-                }\n-            }\n+fn lint_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, shadowed: HirId, span: Span) {\n+    let (lint, msg) = match find_init(cx, pat.hir_id) {\n+        Some(expr) if is_self_shadow(cx, pat, expr, shadowed) => {\n+            let msg = format!(\n+                \"`{}` is shadowed by itself in `{}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, expr.span, \"..\")\n+            );\n+            (SHADOW_SAME, msg)\n         },\n-        PatKind::Tuple(inner, _) => {\n-            if let Some(init_tup) = init {\n-                if let ExprKind::Tup(tup) = init_tup.kind {\n-                    for (i, p) in inner.iter().enumerate() {\n-                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n-                    }\n-                } else {\n-                    for p in inner {\n-                        check_pat(cx, p, init, span, bindings);\n-                    }\n-                }\n-            } else {\n-                for p in inner {\n-                    check_pat(cx, p, None, span, bindings);\n-                }\n-            }\n+        Some(expr) if is_local_used(cx, expr, shadowed) => {\n+            let msg = format!(\n+                \"`{}` is shadowed by `{}` which reuses the original value\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, expr.span, \"..\")\n+            );\n+            (SHADOW_REUSE, msg)\n         },\n-        PatKind::Box(inner) => {\n-            if let Some(initp) = init {\n-                if let ExprKind::Box(inner_init) = initp.kind {\n-                    check_pat(cx, inner, Some(inner_init), span, bindings);\n-                } else {\n-                    check_pat(cx, inner, init, span, bindings);\n-                }\n-            } else {\n-                check_pat(cx, inner, init, span, bindings);\n-            }\n+        _ => {\n+            let msg = format!(\"`{}` shadows a previous, unrelated binding\", snippet(cx, pat.span, \"_\"));\n+            (SHADOW_UNRELATED, msg)\n         },\n-        PatKind::Ref(inner, _) => check_pat(cx, inner, init, span, bindings),\n-        // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n-        _ => (),\n-    }\n+    };\n+    span_lint_and_note(\n+        cx,\n+        lint,\n+        span,\n+        &msg,\n+        Some(cx.tcx.hir().span(shadowed)),\n+        \"previous binding is here\",\n+    );\n }\n \n-fn lint_shadow<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    name: Symbol,\n-    span: Span,\n-    pattern_span: Span,\n-    init: Option<&'tcx Expr<'_>>,\n-    prev_span: Span,\n-) {\n-    if let Some(expr) = init {\n-        if is_self_shadow(name, expr) {\n-            span_lint_and_then(\n-                cx,\n-                SHADOW_SAME,\n-                span,\n-                &format!(\n-                    \"`{}` is shadowed by itself in `{}`\",\n-                    snippet(cx, pattern_span, \"_\"),\n-                    snippet(cx, expr.span, \"..\")\n-                ),\n-                |diag| {\n-                    diag.span_note(prev_span, \"previous binding is here\");\n-                },\n-            );\n-        } else if contains_name(name, expr) {\n-            span_lint_and_then(\n-                cx,\n-                SHADOW_REUSE,\n-                pattern_span,\n-                &format!(\n-                    \"`{}` is shadowed by `{}` which reuses the original value\",\n-                    snippet(cx, pattern_span, \"_\"),\n-                    snippet(cx, expr.span, \"..\")\n-                ),\n-                |diag| {\n-                    diag.span_note(prev_span, \"previous binding is here\");\n-                },\n-            );\n-        } else {\n-            span_lint_and_then(\n-                cx,\n-                SHADOW_UNRELATED,\n-                pattern_span,\n-                &format!(\"`{}` is being shadowed\", snippet(cx, pattern_span, \"_\")),\n-                |diag| {\n-                    diag.span_note(prev_span, \"previous binding is here\");\n+/// Returns true if the expression is a simple transformation of a local binding such as `&x`\n+fn is_self_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, mut expr: &Expr<'_>, hir_id: HirId) -> bool {\n+    let hir = cx.tcx.hir();\n+    let is_direct_binding = hir\n+        .parent_iter(pat.hir_id)\n+        .map_while(|(_id, node)| match node {\n+            Node::Pat(pat) => Some(pat),\n+            _ => None,\n+        })\n+        .all(|pat| matches!(pat.kind, PatKind::Ref(..) | PatKind::Or(_)));\n+    if !is_direct_binding {\n+        return false;\n+    }\n+    loop {\n+        expr = match expr.kind {\n+            ExprKind::Box(e)\n+            | ExprKind::AddrOf(_, _, e)\n+            | ExprKind::Block(\n+                &Block {\n+                    stmts: [],\n+                    expr: Some(e),\n+                    ..\n                 },\n-            );\n+                _,\n+            )\n+            | ExprKind::Unary(UnOp::Deref, e) => e,\n+            ExprKind::Path(QPath::Resolved(None, path)) => break path.res == Res::Local(hir_id),\n+            _ => break false,\n         }\n-    } else {\n-        span_lint_and_then(\n-            cx,\n-            SHADOW_UNRELATED,\n-            span,\n-            &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n-            |diag| {\n-                diag.span_note(prev_span, \"previous binding is here\");\n-            },\n-        );\n-    }\n-}\n-\n-fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n-    if in_external_macro(cx.sess(), expr.span) {\n-        return;\n-    }\n-    match expr.kind {\n-        ExprKind::Unary(_, e) | ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) | ExprKind::Box(e) => {\n-            check_expr(cx, e, bindings);\n-        },\n-        ExprKind::Block(block, _) | ExprKind::Loop(block, ..) => check_block(cx, block, bindings),\n-        // ExprKind::Call\n-        // ExprKind::MethodCall\n-        ExprKind::Array(v) | ExprKind::Tup(v) => {\n-            for e in v {\n-                check_expr(cx, e, bindings);\n-            }\n-        },\n-        ExprKind::If(cond, then, ref otherwise) => {\n-            check_expr(cx, cond, bindings);\n-            check_expr(cx, then, bindings);\n-            if let Some(o) = *otherwise {\n-                check_expr(cx, o, bindings);\n-            }\n-        },\n-        ExprKind::Match(init, arms, _) => {\n-            check_expr(cx, init, bindings);\n-            let len = bindings.len();\n-            for arm in arms {\n-                check_pat(cx, arm.pat, Some(init), arm.pat.span, bindings);\n-                // This is ugly, but needed to get the right type\n-                if let Some(ref guard) = arm.guard {\n-                    match guard {\n-                        Guard::If(if_expr) => check_expr(cx, if_expr, bindings),\n-                        Guard::IfLet(guard_pat, guard_expr) => {\n-                            check_pat(cx, guard_pat, Some(*guard_expr), guard_pat.span, bindings);\n-                            check_expr(cx, guard_expr, bindings);\n-                        },\n-                    }\n-                }\n-                check_expr(cx, arm.body, bindings);\n-                bindings.truncate(len);\n-            }\n-        },\n-        _ => (),\n-    }\n-}\n-\n-fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n-    match ty.kind {\n-        TyKind::Slice(sty) => check_ty(cx, sty, bindings),\n-        TyKind::Array(fty, ref anon_const) => {\n-            check_ty(cx, fty, bindings);\n-            check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings);\n-        },\n-        TyKind::Ptr(MutTy { ty: mty, .. }) | TyKind::Rptr(_, MutTy { ty: mty, .. }) => check_ty(cx, mty, bindings),\n-        TyKind::Tup(tup) => {\n-            for t in tup {\n-                check_ty(cx, t, bindings);\n-            }\n-        },\n-        TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings),\n-        _ => (),\n     }\n }\n \n-fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Box(inner) | ExprKind::AddrOf(_, _, inner) => is_self_shadow(name, inner),\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n-        },\n-        ExprKind::Unary(op, inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n-        ExprKind::Path(QPath::Resolved(_, path)) => path_eq_name(name, path),\n-        _ => false,\n+/// Finds the \"init\" expression for a pattern: `let <pat> = <init>;` or\n+/// `match <init> { .., <pat> => .., .. }`\n+fn find_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Expr<'tcx>> {\n+    for (_, node) in cx.tcx.hir().parent_iter(hir_id) {\n+        let init = match node {\n+            Node::Arm(_) | Node::Pat(_) => continue,\n+            Node::Expr(expr) => match expr.kind {\n+                ExprKind::Match(e, _, _) => Some(e),\n+                _ => None,\n+            },\n+            Node::Local(local) => local.init,\n+            _ => None,\n+        };\n+        return init;\n     }\n-}\n-\n-fn path_eq_name(name: Symbol, path: &Path<'_>) -> bool {\n-    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.name == name\n+    None\n }"}, {"sha": "0860dcf8e0ddb610a1ec41cb65f0fd23b94752d7", "filename": "tests/ui/map_clone.fixed", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fmap_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fmap_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.fixed?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -1,11 +1,11 @@\n // run-rustfix\n-#![warn(clippy::all, clippy::pedantic)]\n-#![allow(clippy::iter_cloned_collect)]\n-#![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n-#![allow(clippy::let_underscore_drop)]\n-#![allow(clippy::missing_docs_in_private_items)]\n-#![allow(clippy::redundant_closure_for_method_calls)]\n-#![allow(clippy::many_single_char_names)]\n+#![warn(clippy::map_clone)]\n+#![allow(\n+    clippy::clone_on_copy,\n+    clippy::iter_cloned_collect,\n+    clippy::many_single_char_names,\n+    clippy::redundant_clone\n+)]\n \n fn main() {\n     let _: Vec<i8> = vec![5_i8; 6].iter().copied().collect();"}, {"sha": "b6987336834b84dec65af32aba776a0facbd0150", "filename": "tests/ui/map_clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -1,11 +1,11 @@\n // run-rustfix\n-#![warn(clippy::all, clippy::pedantic)]\n-#![allow(clippy::iter_cloned_collect)]\n-#![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n-#![allow(clippy::let_underscore_drop)]\n-#![allow(clippy::missing_docs_in_private_items)]\n-#![allow(clippy::redundant_closure_for_method_calls)]\n-#![allow(clippy::many_single_char_names)]\n+#![warn(clippy::map_clone)]\n+#![allow(\n+    clippy::clone_on_copy,\n+    clippy::iter_cloned_collect,\n+    clippy::many_single_char_names,\n+    clippy::redundant_clone\n+)]\n \n fn main() {\n     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();"}, {"sha": "02e838456d0b574559f34404e79f22ffa158100e", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -1,54 +1,77 @@\n-#![warn(\n-    clippy::all,\n-    clippy::pedantic,\n-    clippy::shadow_same,\n-    clippy::shadow_reuse,\n-    clippy::shadow_unrelated\n-)]\n-#![allow(\n-    unused_parens,\n-    unused_variables,\n-    clippy::manual_unwrap_or,\n-    clippy::missing_docs_in_private_items,\n-    clippy::single_match\n-)]\n-\n-fn id<T>(x: T) -> T {\n-    x\n+#![warn(clippy::shadow_same, clippy::shadow_reuse, clippy::shadow_unrelated)]\n+\n+fn shadow_same() {\n+    let x = 1;\n+    let x = x;\n+    let mut x = &x;\n+    let x = &mut x;\n+    let x = *x;\n }\n \n-#[must_use]\n-fn first(x: (isize, isize)) -> isize {\n-    x.0\n+fn shadow_reuse() -> Option<()> {\n+    let x = ([[0]], ());\n+    let x = x.0;\n+    let x = x[0];\n+    let [x] = x;\n+    let x = Some(x);\n+    let x = foo(x);\n+    let x = || x;\n+    let x = Some(1).map(|_| x)?;\n+    None\n }\n \n-fn main() {\n-    let mut x = 1;\n-    let x = &mut x;\n-    let x = { x };\n-    let x = (&*x);\n-    let x = { *x + 1 };\n-    let x = id(x);\n-    let x = (1, x);\n-    let x = first(x);\n-    let y = 1;\n-    let x = y;\n-\n-    let x;\n-    x = 42;\n-\n-    let o = Some(1_u8);\n-\n-    if let Some(p) = o {\n-        assert_eq!(1, p);\n+fn shadow_unrelated() {\n+    let x = 1;\n+    let x = 2;\n+}\n+\n+fn syntax() {\n+    fn f(x: u32) {\n+        let x = 1;\n+    }\n+    let x = 1;\n+    match Some(1) {\n+        Some(1) => {},\n+        Some(x) => {\n+            let x = 1;\n+        },\n+        _ => {},\n     }\n-    match o {\n-        Some(p) => p, // no error, because the p above is in its own scope\n-        None => 0,\n+    if let Some(x) = Some(1) {}\n+    while let Some(x) = Some(1) {}\n+    let _ = |[x]: [u32; 1]| {\n+        let x = 1;\n     };\n+}\n \n-    match (x, o) {\n-        (1, Some(a)) | (a, Some(1)) => (), // no error though `a` appears twice\n-        _ => (),\n+fn negative() {\n+    match Some(1) {\n+        Some(x) if x == 1 => {},\n+        Some(x) => {},\n+        None => {},\n     }\n+    match [None, Some(1)] {\n+        [Some(x), None] | [None, Some(x)] => {},\n+        _ => {},\n+    }\n+    if let Some(x) = Some(1) {\n+        let y = 1;\n+    } else {\n+        let x = 1;\n+        let y = 1;\n+    }\n+    let x = 1;\n+    #[allow(clippy::shadow_unrelated)]\n+    let x = 1;\n+}\n+\n+fn foo<T>(_: T) {}\n+\n+fn question_mark() -> Option<()> {\n+    let val = 1;\n+    // `?` expands with a `val` binding\n+    None?;\n+    None\n }\n+\n+fn main() {}"}, {"sha": "8b60e072c9342c9c763dc6b8de1740cef3f99dac", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 170, "deletions": 50, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=8c0e4d5ccf8be995273f8b1e0e217906ec4b1dc4", "patch": "@@ -1,113 +1,233 @@\n-error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:27:5\n+error: `x` is shadowed by itself in `x`\n+  --> $DIR/shadow.rs:5:9\n    |\n-LL |     let x = &mut x;\n-   |     ^^^^^^^^^^^^^^^\n+LL |     let x = x;\n+   |         ^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:13\n+  --> $DIR/shadow.rs:4:9\n    |\n-LL |     let mut x = 1;\n-   |             ^\n+LL |     let x = 1;\n+   |         ^\n \n-error: `x` is shadowed by itself in `{ x }`\n-  --> $DIR/shadow.rs:28:5\n+error: `mut x` is shadowed by itself in `&x`\n+  --> $DIR/shadow.rs:6:13\n    |\n-LL |     let x = { x };\n-   |     ^^^^^^^^^^^^^^\n+LL |     let mut x = &x;\n+   |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:27:9\n+  --> $DIR/shadow.rs:5:9\n+   |\n+LL |     let x = x;\n+   |         ^\n+\n+error: `x` is shadowed by itself in `&mut x`\n+  --> $DIR/shadow.rs:7:9\n    |\n LL |     let x = &mut x;\n    |         ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:6:9\n+   |\n+LL |     let mut x = &x;\n+   |         ^^^^^\n \n-error: `x` is shadowed by itself in `(&*x)`\n-  --> $DIR/shadow.rs:29:5\n+error: `x` is shadowed by itself in `*x`\n+  --> $DIR/shadow.rs:8:9\n    |\n-LL |     let x = (&*x);\n-   |     ^^^^^^^^^^^^^^\n+LL |     let x = *x;\n+   |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:7:9\n    |\n-LL |     let x = { x };\n+LL |     let x = &mut x;\n    |         ^\n \n-error: `x` is shadowed by `{ *x + 1 }` which reuses the original value\n-  --> $DIR/shadow.rs:30:9\n+error: `x` is shadowed by `x.0` which reuses the original value\n+  --> $DIR/shadow.rs:13:9\n    |\n-LL |     let x = { *x + 1 };\n+LL |     let x = x.0;\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:12:9\n    |\n-LL |     let x = (&*x);\n+LL |     let x = ([[0]], ());\n    |         ^\n \n-error: `x` is shadowed by `id(x)` which reuses the original value\n-  --> $DIR/shadow.rs:31:9\n+error: `x` is shadowed by `x[0]` which reuses the original value\n+  --> $DIR/shadow.rs:14:9\n    |\n-LL |     let x = id(x);\n+LL |     let x = x[0];\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:13:9\n    |\n-LL |     let x = { *x + 1 };\n+LL |     let x = x.0;\n    |         ^\n \n-error: `x` is shadowed by `(1, x)` which reuses the original value\n-  --> $DIR/shadow.rs:32:9\n+error: `x` is shadowed by `x` which reuses the original value\n+  --> $DIR/shadow.rs:15:10\n+   |\n+LL |     let [x] = x;\n+   |          ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:14:9\n    |\n-LL |     let x = (1, x);\n+LL |     let x = x[0];\n+   |         ^\n+\n+error: `x` is shadowed by `Some(x)` which reuses the original value\n+  --> $DIR/shadow.rs:16:9\n+   |\n+LL |     let x = Some(x);\n+   |         ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:15:10\n+   |\n+LL |     let [x] = x;\n+   |          ^\n+\n+error: `x` is shadowed by `foo(x)` which reuses the original value\n+  --> $DIR/shadow.rs:17:9\n+   |\n+LL |     let x = foo(x);\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:16:9\n    |\n-LL |     let x = id(x);\n+LL |     let x = Some(x);\n    |         ^\n \n-error: `x` is shadowed by `first(x)` which reuses the original value\n-  --> $DIR/shadow.rs:33:9\n+error: `x` is shadowed by `|| x` which reuses the original value\n+  --> $DIR/shadow.rs:18:9\n    |\n-LL |     let x = first(x);\n+LL |     let x = || x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:17:9\n    |\n-LL |     let x = (1, x);\n+LL |     let x = foo(x);\n    |         ^\n \n-error: `x` is being shadowed\n-  --> $DIR/shadow.rs:35:9\n+error: `x` is shadowed by `Some(1).map(|_| x)?` which reuses the original value\n+  --> $DIR/shadow.rs:19:9\n    |\n-LL |     let x = y;\n+LL |     let x = Some(1).map(|_| x)?;\n+   |         ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:18:9\n+   |\n+LL |     let x = || x;\n+   |         ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:25:9\n+   |\n+LL |     let x = 2;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:33:9\n+  --> $DIR/shadow.rs:24:9\n    |\n-LL |     let x = first(x);\n+LL |     let x = 1;\n    |         ^\n \n-error: `x` shadows a previous declaration\n-  --> $DIR/shadow.rs:37:5\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:30:13\n    |\n-LL |     let x;\n-   |     ^^^^^^\n+LL |         let x = 1;\n+   |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:35:9\n+  --> $DIR/shadow.rs:29:10\n    |\n-LL |     let x = y;\n+LL |     fn f(x: u32) {\n+   |          ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:35:14\n+   |\n+LL |         Some(x) => {\n+   |              ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:32:9\n+   |\n+LL |     let x = 1;\n    |         ^\n \n-error: aborting due to 9 previous errors\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:36:17\n+   |\n+LL |             let x = 1;\n+   |                 ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:35:14\n+   |\n+LL |         Some(x) => {\n+   |              ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:40:17\n+   |\n+LL |     if let Some(x) = Some(1) {}\n+   |                 ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:32:9\n+   |\n+LL |     let x = 1;\n+   |         ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:41:20\n+   |\n+LL |     while let Some(x) = Some(1) {}\n+   |                    ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:32:9\n+   |\n+LL |     let x = 1;\n+   |         ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:42:15\n+   |\n+LL |     let _ = |[x]: [u32; 1]| {\n+   |               ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:32:9\n+   |\n+LL |     let x = 1;\n+   |         ^\n+\n+error: `x` shadows a previous, unrelated binding\n+  --> $DIR/shadow.rs:43:13\n+   |\n+LL |         let x = 1;\n+   |             ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:42:15\n+   |\n+LL |     let _ = |[x]: [u32; 1]| {\n+   |               ^\n+\n+error: aborting due to 19 previous errors\n "}]}