{"sha": "206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNmU3YjZmYzcwNGM1M2IyYTcxNzRlOGJlYzdiNWY1NzVkOWJjOTM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-15T17:52:38Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-29T18:27:40Z"}, "message": "Add some features to flock.", "tree": {"sha": "ac840e1e35bec3accc44fbc96d850ddca19cb874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac840e1e35bec3accc44fbc96d850ddca19cb874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "html_url": "https://github.com/rust-lang/rust/commit/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef8198406af9ba18787e0fd50ae2e25f78b7e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef8198406af9ba18787e0fd50ae2e25f78b7e4f", "html_url": "https://github.com/rust-lang/rust/commit/6ef8198406af9ba18787e0fd50ae2e25f78b7e4f"}], "stats": {"total": 128, "additions": 106, "deletions": 22}, "files": [{"sha": "adfeaae847537b6ed55b18f228d2af12a5f7ee41", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 105, "deletions": 21, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "patch": "@@ -15,6 +15,7 @@\n //! librustdoc, it is not production quality at all.\n \n #![allow(non_camel_case_types)]\n+use std::path::Path;\n \n pub use self::imp::Lock;\n \n@@ -41,6 +42,7 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n+        pub const F_RDLCK: libc::c_short = 0;\n         pub const F_WRLCK: libc::c_short = 1;\n         pub const F_UNLCK: libc::c_short = 2;\n         pub const F_SETLK: libc::c_int = 6;\n@@ -60,6 +62,7 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n+        pub const F_RDLCK: libc::c_short = 1;\n         pub const F_UNLCK: libc::c_short = 2;\n         pub const F_WRLCK: libc::c_short = 3;\n         pub const F_SETLK: libc::c_int = 12;\n@@ -84,6 +87,7 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n+        pub const F_RDLCK: libc::c_short = 1;\n         pub const F_UNLCK: libc::c_short = 2;\n         pub const F_WRLCK: libc::c_short = 3;\n         pub const F_SETLK: libc::c_int = 8;\n@@ -105,6 +109,7 @@ mod imp {\n             pub l_sysid: libc::c_int,\n         }\n \n+        pub const F_RDLCK: libc::c_short = 1;\n         pub const F_UNLCK: libc::c_short = 2;\n         pub const F_WRLCK: libc::c_short = 3;\n         pub const F_SETLK: libc::c_int = 8;\n@@ -124,6 +129,7 @@ mod imp {\n             pub l_pid: libc::pid_t,\n         }\n \n+        pub const F_RDLCK: libc::c_short = 1;\n         pub const F_WRLCK: libc::c_short = 2;\n         pub const F_UNLCK: libc::c_short = 3;\n         pub const F_SETLK: libc::c_int = 6;\n@@ -135,32 +141,53 @@ mod imp {\n     }\n \n     impl Lock {\n-        pub fn new(p: &Path) -> Lock {\n+        pub fn new(p: &Path,\n+                   wait: bool,\n+                   create: bool,\n+                   exclusive: bool)\n+                   -> io::Result<Lock> {\n             let os: &OsStr = p.as_ref();\n             let buf = CString::new(os.as_bytes()).unwrap();\n+            let open_flags = if create {\n+                libc::O_RDWR | libc::O_CREAT\n+            } else {\n+                libc::O_RDWR\n+            };\n+\n             let fd = unsafe {\n-                libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n+                libc::open(buf.as_ptr(), open_flags,\n                            libc::S_IRWXU as libc::c_int)\n             };\n-            assert!(fd > 0, \"failed to open lockfile: {}\",\n-                    io::Error::last_os_error());\n+\n+            if fd < 0 {\n+                return Err(io::Error::last_os_error());\n+            }\n+\n+            let lock_type = if exclusive {\n+                os::F_WRLCK\n+            } else {\n+                os::F_RDLCK\n+            };\n+\n             let flock = os::flock {\n                 l_start: 0,\n                 l_len: 0,\n                 l_pid: 0,\n                 l_whence: libc::SEEK_SET as libc::c_short,\n-                l_type: os::F_WRLCK,\n+                l_type: lock_type,\n                 l_sysid: 0,\n             };\n+            let cmd = if wait { os::F_SETLKW } else { os::F_SETLK };\n             let ret = unsafe {\n-                libc::fcntl(fd, os::F_SETLKW, &flock)\n+                libc::fcntl(fd, cmd, &flock)\n             };\n             if ret == -1 {\n                 let err = io::Error::last_os_error();\n                 unsafe { libc::close(fd); }\n-                panic!(\"could not lock `{}`: {}\", p.display(), err);\n+                Err(err)\n+            } else {\n+                Ok(Lock { fd: fd })\n             }\n-            Lock { fd: fd }\n         }\n     }\n \n@@ -191,18 +218,28 @@ mod imp {\n     use std::os::windows::raw::HANDLE;\n     use std::path::Path;\n     use std::fs::{File, OpenOptions};\n+    use std::os::raw::{c_ulong, c_ulonglong, c_int};\n+    use std::os::windows::fs::OpenOptionsExt;\n+\n+    pub type DWORD = c_ulong;\n+    pub type BOOL = c_int;\n+    pub type ULONG_PTR = c_ulonglong;\n \n-    type DWORD = u32;\n     type LPOVERLAPPED = *mut OVERLAPPED;\n-    type BOOL = i32;\n     const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x00000002;\n+    const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x00000001;\n+\n+    pub const FILE_SHARE_DELETE: DWORD = 0x4;\n+    pub const FILE_SHARE_READ: DWORD = 0x1;\n+    pub const FILE_SHARE_WRITE: DWORD = 0x2;\n \n     #[repr(C)]\n     struct OVERLAPPED {\n-        Internal: usize,\n-        InternalHigh: usize,\n-        Pointer: *mut u8,\n-        hEvent: *mut u8,\n+        Internal: ULONG_PTR,\n+        InternalHigh: ULONG_PTR,\n+        Offset: DWORD,\n+        OffsetHigh: DWORD,\n+        hEvent: HANDLE,\n     }\n \n     extern \"system\" {\n@@ -219,19 +256,66 @@ mod imp {\n     }\n \n     impl Lock {\n-        pub fn new(p: &Path) -> Lock {\n-            let f = OpenOptions::new().read(true).write(true).create(true)\n-                                      .open(p).unwrap();\n+        pub fn new(p: &Path,\n+                   wait: bool,\n+                   create: bool,\n+                   exclusive: bool)\n+                   -> io::Result<Lock> {\n+\n+            let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+            let f = {\n+                let mut open_options = OpenOptions::new().read(true)\n+                                                         .share_mode(share_mode);\n+                if create {\n+                    open_options.create(true);\n+                }\n+\n+                match open_options.open(p) {\n+                    Ok(file) => file,\n+                    Err(err) => return Err(err),\n+                }\n+            };\n+\n             let ret = unsafe {\n                 let mut overlapped: OVERLAPPED = mem::zeroed();\n-                LockFileEx(f.as_raw_handle(), LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n+\n+                let mut dwFlags = 0;\n+                if !wait {\n+                    dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+                }\n+\n+                if exclusive {\n+                    dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+                }\n+\n+                LockFileEx(f.as_raw_handle(),\n+                           dwFlags,\n+                           0,\n+                           0xFFFF_FFFF,\n+                           0xFFFF_FFFF,\n                            &mut overlapped)\n             };\n             if ret == 0 {\n-                let err = io::Error::last_os_error();\n-                panic!(\"could not lock `{}`: {}\", p.display(), err);\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(Lock { _file: f })\n             }\n-            Lock { _file: f }\n         }\n     }\n+\n+    // Note that we don't need a Drop impl on the Windows: The file is unlocked\n+    // automatically when it's closed.\n+}\n+\n+impl imp::Lock {\n+    pub fn panicking_new(p: &Path,\n+                         wait: bool,\n+                         create: bool,\n+                         exclusive: bool)\n+                         -> Lock {\n+        Lock::new(p, wait, create, exclusive).unwrap_or_else(|err| {\n+            panic!(\"could not lock `{}`: {}\", p.display(), err);\n+        })\n+    }\n }"}, {"sha": "6d523ff381556799d5715fdbcdaa18eb45fdf98b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206e7b6fc704c53b2a7174e8bec7b5f575d9bc93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=206e7b6fc704c53b2a7174e8bec7b5f575d9bc93", "patch": "@@ -652,7 +652,7 @@ fn write_shared(cx: &Context,\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n     try_err!(mkdir(&cx.dst), &cx.dst);\n-    let _lock = flock::Lock::new(&cx.dst.join(\".lock\"));\n+    let _lock = flock::Lock::panicking_new(&cx.dst.join(\".lock\"), true, true, true);\n \n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date."}]}