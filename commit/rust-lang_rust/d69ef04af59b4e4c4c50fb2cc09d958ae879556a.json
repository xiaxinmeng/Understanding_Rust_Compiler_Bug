{"sha": "d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OWVmMDRhZjU5YjRlNGM0YzUwZmIyY2MwOWQ5NThhZTg3OTU1NmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-22T01:47:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-22T01:47:31Z"}, "message": "Rollup merge of #60581 - hellow554:fix_60580, r=alexcrichton\n\nconvert custom try macro to `?`\n\nresolves #60580\n\nr? @frewsxcv", "tree": {"sha": "b7f70393520e8f4bef617b032ccccfd7c5eaa28b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7f70393520e8f4bef617b032ccccfd7c5eaa28b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc5KozCRBK7hj4Ov3rIwAAdHIIAAx/4XiFqa6tIUGQD0yG77k6\nVUtSyKRPyknaQSqJNdvqgr1DFvng41YZRytevqe2MN2/XJYQ3eL7TY1y24YTlBAE\nRt9RMBBkL70CF0+yRLh6B6g6X3aLwoLTdKlVvK6GCfSPYpfCdwXAJvJd7TA99ceT\n2iXh6zItutTpSro4q399Qaqj2YDo709+JTI3iJMklXSVQClHGthNNOs6BAf+YGf5\nXVYZj2K9gHRcsXBpVuY+Q/IZ3MDuCnYPQTX29WRmqhmd6/qLgJHNBbuxwUv8JLTk\niB9axLMynsxsmTyNBiE4lUQpdi1X2cl1z7jSnLfXI6wbZR5as4G84I6qN9l1duw=\n=vuko\n-----END PGP SIGNATURE-----\n", "payload": "tree b7f70393520e8f4bef617b032ccccfd7c5eaa28b\nparent a8d1b81ba40c0d2154ed6c09a9c625d1889814ac\nparent 5458b651b1ecad5cc334b494209352ac935360ce\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558489651 +0200\ncommitter GitHub <noreply@github.com> 1558489651 +0200\n\nRollup merge of #60581 - hellow554:fix_60580, r=alexcrichton\n\nconvert custom try macro to `?`\n\nresolves #60580\n\nr? @frewsxcv\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "html_url": "https://github.com/rust-lang/rust/commit/d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69ef04af59b4e4c4c50fb2cc09d958ae879556a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d1b81ba40c0d2154ed6c09a9c625d1889814ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d1b81ba40c0d2154ed6c09a9c625d1889814ac", "html_url": "https://github.com/rust-lang/rust/commit/a8d1b81ba40c0d2154ed6c09a9c625d1889814ac"}, {"sha": "5458b651b1ecad5cc334b494209352ac935360ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5458b651b1ecad5cc334b494209352ac935360ce", "html_url": "https://github.com/rust-lang/rust/commit/5458b651b1ecad5cc334b494209352ac935360ce"}], "stats": {"total": 103, "additions": 46, "deletions": 57}, "files": [{"sha": "2a553b2c93bd3939b0b270d534a85555de7783a3", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d69ef04af59b4e4c4c50fb2cc09d958ae879556a/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ef04af59b4e4c4c50fb2cc09d958ae879556a/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "patch": "@@ -150,7 +150,7 @@ impl Command {\n              match cvt(syscall::clone(0))? {\n                  0 => {\n                      drop(input);\n-                     let err = self.do_exec(theirs);\n+                     let Err(err) = self.do_exec(theirs);\n                      let errno = err.raw_os_error().unwrap_or(syscall::EINVAL) as u32;\n                      let bytes = [\n                          (errno >> 24) as u8,\n@@ -218,7 +218,10 @@ impl Command {\n         }\n \n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Ok((_, theirs)) => unsafe {\n+                let Err(e) = self.do_exec(theirs);\n+                e\n+            },\n             Err(e) => e,\n         }\n     }\n@@ -253,45 +256,38 @@ impl Command {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke syscall::exit)\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> Result<!, io::Error> {\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt(syscall::dup2(fd, 2, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(2, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 2, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(2, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(2, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(2, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt(syscall::dup2(fd, 1, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(1, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 1, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(1, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(1, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(1, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt(syscall::dup2(fd, 0, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(0, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 0, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(0, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(0, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(0, syscall::F_SETFD, flags))?;\n         }\n \n         if let Some(g) = self.gid {\n-            t!(cvt(syscall::setregid(g as usize, g as usize)));\n+            cvt(syscall::setregid(g as usize, g as usize))?;\n         }\n         if let Some(u) = self.uid {\n-            t!(cvt(syscall::setreuid(u as usize, u as usize)));\n+            cvt(syscall::setreuid(u as usize, u as usize))?;\n         }\n         if let Some(ref cwd) = self.cwd {\n-            t!(cvt(syscall::chdir(cwd)));\n+            cvt(syscall::chdir(cwd))?;\n         }\n \n         for callback in self.closures.iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         self.env.apply();\n@@ -313,9 +309,9 @@ impl Command {\n         };\n \n         let mut file = if let Some(program) = program {\n-            t!(File::open(program.as_os_str()))\n+            File::open(program.as_os_str())?\n         } else {\n-            return io::Error::from_raw_os_error(syscall::ENOENT);\n+            return Err(io::Error::from_raw_os_error(syscall::ENOENT));\n         };\n \n         // Push all the arguments\n@@ -327,7 +323,7 @@ impl Command {\n             let mut shebang = [0; 2];\n             let mut read = 0;\n             loop {\n-                match t!(reader.read(&mut shebang[read..])) {\n+                match reader.read(&mut shebang[read..])? {\n                     0 => break,\n                     n => read += n,\n                 }\n@@ -338,9 +334,9 @@ impl Command {\n                 // First of all, since we'll be passing another file to\n                 // fexec(), we need to manually check that we have permission\n                 // to execute this file:\n-                let uid = t!(cvt(syscall::getuid()));\n-                let gid = t!(cvt(syscall::getgid()));\n-                let meta = t!(file.metadata());\n+                let uid = cvt(syscall::getuid())?;\n+                let gid = cvt(syscall::getgid())?;\n+                let meta = file.metadata()?;\n \n                 let mode = if uid == meta.uid() as usize {\n                     meta.mode() >> 3*2 & 0o7\n@@ -350,12 +346,12 @@ impl Command {\n                     meta.mode() & 0o7\n                 };\n                 if mode & 1 == 0 {\n-                    return io::Error::from_raw_os_error(syscall::EPERM);\n+                    return Err(io::Error::from_raw_os_error(syscall::EPERM));\n                 }\n \n                 // Second of all, we need to actually read which interpreter it wants\n                 let mut interpreter = Vec::new();\n-                t!(reader.read_until(b'\\n', &mut interpreter));\n+                reader.read_until(b'\\n', &mut interpreter)?;\n                 // Pop one trailing newline, if any\n                 if interpreter.ends_with(&[b'\\n']) {\n                     interpreter.pop().unwrap();\n@@ -373,11 +369,11 @@ impl Command {\n         };\n         if let Some(ref interpreter) = interpreter {\n             let path: &OsStr = OsStr::from_bytes(&interpreter);\n-            file = t!(File::open(path));\n+            file = File::open(path)?;\n \n             args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n         } else {\n-            t!(file.seek(SeekFrom::Start(0)));\n+            file.seek(SeekFrom::Start(0))?;\n         }\n \n         args.push([self.program.as_ptr() as usize, self.program.len()]);\n@@ -396,13 +392,12 @@ impl Command {\n         }\n \n         if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n-            io::Error::from_raw_os_error(err.errno as i32)\n+            Err(io::Error::from_raw_os_error(err.errno as i32))\n         } else {\n             panic!(\"return from exec without err\");\n         }\n     }\n \n-\n     fn setup_io(&self, default: Stdio, needs_stdin: bool)\n                 -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;"}, {"sha": "80fe763aecc888266398d400e8ce0feb87895349", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d69ef04af59b4e4c4c50fb2cc09d958ae879556a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ef04af59b4e4c4c50fb2cc09d958ae879556a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=d69ef04af59b4e4c4c50fb2cc09d958ae879556a", "patch": "@@ -47,7 +47,7 @@ impl Command {\n             match result {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs, envp.as_ref());\n+                    let Err(err) = self.do_exec(theirs, envp.as_ref());\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -123,7 +123,8 @@ impl Command {\n                     // environment lock before we try to exec.\n                     let _lock = sys::os::env_lock();\n \n-                    self.do_exec(theirs, envp.as_ref())\n+                    let Err(e) = self.do_exec(theirs, envp.as_ref());\n+                    e\n                 }\n             }\n             Err(e) => e,\n@@ -164,29 +165,22 @@ impl Command {\n         &mut self,\n         stdio: ChildPipes,\n         maybe_envp: Option<&CStringArray>\n-    ) -> io::Error {\n+    ) -> Result<!, io::Error> {\n         use crate::sys::{self, cvt_r};\n \n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n         if cfg!(not(any(target_os = \"l4re\"))) {\n             if let Some(u) = self.get_gid() {\n-                t!(cvt(libc::setgid(u as gid_t)));\n+                cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n                 // When dropping privileges from root, the `setgroups` call\n@@ -198,11 +192,11 @@ impl Command {\n                 // privilege dropping function.\n                 let _ = libc::setgroups(0, ptr::null());\n \n-                t!(cvt(libc::setuid(u as uid_t)));\n+                cvt(libc::setuid(u as uid_t))?;\n             }\n         }\n         if let Some(ref cwd) = *self.get_cwd() {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n+            cvt(libc::chdir(cwd.as_ptr()))?;\n         }\n \n         // emscripten has no signal support.\n@@ -225,18 +219,18 @@ impl Command {\n                              0,\n                              mem::size_of::<libc::sigset_t>());\n             } else {\n-                t!(cvt(libc::sigemptyset(&mut set)));\n+                cvt(libc::sigemptyset(&mut set))?;\n             }\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                         ptr::null_mut())));\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                         ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n-                return io::Error::last_os_error()\n+                return Err(io::Error::last_os_error())\n             }\n         }\n \n         for callback in self.get_closures().iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         // Although we're performing an exec here we may also return with an\n@@ -261,7 +255,7 @@ impl Command {\n         }\n \n         libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n-        io::Error::last_os_error()\n+        Err(io::Error::last_os_error())\n     }\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"freebsd\","}]}