{"sha": "8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDNiMjhlNjRiMDJjMjI0NWY1ODY5YWQ5MGNhZmE2ZDg1YWIwZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T22:56:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T22:56:27Z"}, "message": "Auto merge of #65951 - estebank:type-inference-error, r=nikomatsakis\n\nPoint at method call when type annotations are needed\n\n- Point at method call instead of whole expression when type annotations are needed.\n- Suggest use of turbofish on function and methods.\n\nFix #49391, fix #46333, fix #48089. CC #58517, #63502, #63082.\n\nFixes https://github.com/rust-lang/rust/issues/40015\n\nr? @nikomatsakis", "tree": {"sha": "68fb411f9fd2c612fa9ea771d71dc81a14e0c1a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68fb411f9fd2c612fa9ea771d71dc81a14e0c1a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "html_url": "https://github.com/rust-lang/rust/commit/8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff15e9670843f8bd6b54ab1b042d2095b4c0aa6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff15e9670843f8bd6b54ab1b042d2095b4c0aa6d", "html_url": "https://github.com/rust-lang/rust/commit/ff15e9670843f8bd6b54ab1b042d2095b4c0aa6d"}, {"sha": "da023c0c6f3cdc72d72ef047c2dadb1a59c646df", "url": "https://api.github.com/repos/rust-lang/rust/commits/da023c0c6f3cdc72d72ef047c2dadb1a59c646df", "html_url": "https://github.com/rust-lang/rust/commit/da023c0c6f3cdc72d72ef047c2dadb1a59c646df"}], "stats": {"total": 605, "additions": 470, "deletions": 135}, "files": [{"sha": "c9d57706d55ea3064701966cad9747dedcce2390", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -70,6 +70,7 @@ use std::{cmp, fmt};\n mod note;\n \n mod need_type_info;\n+pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n "}, {"sha": "8878683f3a7a43857d1f354386b3822b6d78f4bd", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 152, "deletions": 25, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,13 +1,15 @@\n-use crate::hir::def::Namespace;\n+use crate::hir::def::{DefKind, Namespace};\n use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n+use syntax::symbol::kw;\n use syntax_pos::Span;\n use errors::{Applicability, DiagnosticBuilder};\n+use std::borrow::Cow;\n \n use rustc_error_codes::*;\n \n@@ -19,6 +21,7 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n     found_closure: Option<&'tcx ExprKind>,\n+    found_method_call: Option<&'tcx Expr>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n@@ -35,6 +38,7 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n             found_arg_pattern: None,\n             found_ty: None,\n             found_closure: None,\n+            found_method_call: None,\n         }\n     }\n \n@@ -93,11 +97,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n-            &expr.kind,\n-            self.node_matches_type(expr.hir_id),\n-        ) {\n-            self.found_closure = Some(&expr.kind);\n+        if self.node_matches_type(expr.hir_id).is_some() {\n+            match expr.kind {\n+                ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n+                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n+                _ => {}\n+            }\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -109,6 +114,7 @@ fn closure_return_type_suggestion(\n     err: &mut DiagnosticBuilder<'_>,\n     output: &FunctionRetTy,\n     body: &Body,\n+    descr: &str,\n     name: &str,\n     ret: &str,\n ) {\n@@ -132,7 +138,7 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+    err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -147,17 +153,42 @@ fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n         .unwrap_or_default()\n }\n \n+pub enum TypeAnnotationNeeded {\n+    E0282,\n+    E0283,\n+    E0284,\n+}\n+\n+impl Into<errors::DiagnosticId> for TypeAnnotationNeeded {\n+    fn into(self) -> errors::DiagnosticId {\n+        syntax::diagnostic_used!(E0282);\n+        syntax::diagnostic_used!(E0283);\n+        syntax::diagnostic_used!(E0284);\n+        errors::DiagnosticId::Error(match self {\n+            Self::E0282 => \"E0282\".to_string(),\n+            Self::E0283 => \"E0283\".to_string(),\n+            Self::E0284 => \"E0284\".to_string(),\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_type_name(\n         &self,\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> (String, Option<Span>) {\n+    ) -> (String, Option<Span>, Cow<'static, str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n             let ty_vars = self.type_variables.borrow();\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n-                return (name.to_string(), Some(var_origin.span));\n+                if name != kw::SelfUpper {\n+                    return (\n+                        name.to_string(),\n+                        Some(var_origin.span),\n+                        \"type parameter\".into(),\n+                    );\n+                }\n             }\n         }\n \n@@ -167,26 +198,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             printer.region_highlight_mode = highlight;\n         }\n         let _ = ty.print(printer);\n-        (s, None)\n+        (s, None, ty.prefix_string())\n     }\n \n     pub fn need_type_info_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n         ty: Ty<'tcx>,\n+        error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp) = self.extract_type_name(&ty, None);\n+        let (name, name_sp, descr) = self.extract_type_name(&ty, None);\n \n         let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n             let ty_vars = self.type_variables.borrow();\n             let getter = move |ty_vid| {\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name) =\n-                    ty_vars.var_origin(ty_vid).kind {\n+                let var_origin = ty_vars.var_origin(ty_vid);\n+                if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n                     return Some(name.to_string());\n                 }\n                 None\n@@ -210,6 +242,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // 3 |     let _ = x.sum() as f64;\n             //   |               ^^^ cannot infer type for `S`\n             span\n+        } else if let Some(\n+            ExprKind::MethodCall(_, call_span, _),\n+        ) = local_visitor.found_method_call.map(|e| &e.kind) {\n+            // Point at the call instead of the whole expression:\n+            // error[E0284]: type annotations needed\n+            //  --> file.rs:2:5\n+            //   |\n+            // 2 |     vec![Ok(2)].into_iter().collect()?;\n+            //   |                             ^^^^^^^ cannot infer type\n+            //   |\n+            //   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n+            if span.contains(*call_span) {\n+                *call_span\n+            } else {\n+                span\n+            }\n         } else {\n             span\n         };\n@@ -247,12 +295,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n+        let error_code = error_code.into();\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n             err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n+            &format!(\"type annotations needed{}\", ty_msg),\n+            error_code,\n         );\n \n         let suffix = match local_visitor.found_ty {\n@@ -267,6 +314,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             &mut err,\n                             &decl.output,\n                             &body,\n+                            &descr,\n                             &name,\n                             &ret,\n                         );\n@@ -334,6 +382,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\"consider giving this pattern {}\", suffix)\n             };\n             err.span_label(pattern.span, msg);\n+        } else if let Some(e) = local_visitor.found_method_call {\n+            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n+                // Suggest specifiying type params or point out the return type of the call:\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n+                //    |\n+                // LL |     let _ = x.into_iter().sum() as f64;\n+                //    |                           ^^^\n+                //    |                           |\n+                //    |                           cannot infer type for `S`\n+                //    |                           help: consider specifying the type argument in\n+                //    |                           the method call: `sum::<S>`\n+                //    |\n+                //    = note: type must be known at this point\n+                //\n+                // or\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/issue-65611.rs:59:20\n+                //    |\n+                // LL |     let x = buffer.last().unwrap().0.clone();\n+                //    |             -------^^^^--\n+                //    |             |      |\n+                //    |             |      cannot infer type for `T`\n+                //    |             this method call resolves to `std::option::Option<&T>`\n+                //    |\n+                //    = note: type must be known at this point\n+                self.annotate_method_call(segment, e, &mut err);\n+            }\n         }\n         // Instead of the following:\n         // error[E0282]: type annotations needed\n@@ -351,37 +429,86 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |               ^^^ cannot infer type for `S`\n         //   |\n         //   = note: type must be known at this point\n-        let span = name_sp.unwrap_or(span);\n+        let span = name_sp.unwrap_or(err_span);\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()\n         { // Avoid multiple labels pointing at `span`.\n-            err.span_label(span, InferCtxt::missing_type_msg(&name));\n+            err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n         }\n \n         err\n     }\n \n+    /// If the `FnSig` for the method call can be found and type arguments are identified as\n+    /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n+    fn annotate_method_call(\n+        &self,\n+        segment: &hir::ptr::P<hir::PathSegment>,\n+        e: &Expr,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if let (Ok(snippet), Some(tables), None) = (\n+            self.tcx.sess.source_map().span_to_snippet(segment.ident.span),\n+            self.in_progress_tables,\n+            &segment.args,\n+        ) {\n+            let borrow = tables.borrow();\n+            if let Some((DefKind::Method, did)) = borrow.type_dependent_def(e.hir_id) {\n+                let generics = self.tcx.generics_of(did);\n+                if !generics.params.is_empty() {\n+                    err.span_suggestion(\n+                        segment.ident.span,\n+                        &format!(\n+                            \"consider specifying the type argument{} in the method call\",\n+                            if generics.params.len() > 1 {\n+                                \"s\"\n+                            } else {\n+                                \"\"\n+                            },\n+                        ),\n+                        format!(\"{}::<{}>\", snippet, generics.params.iter()\n+                            .map(|p| p.name.to_string())\n+                            .collect::<Vec<String>>()\n+                            .join(\", \")),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                } else {\n+                    let sig = self.tcx.fn_sig(did);\n+                    let bound_output = sig.output();\n+                    let output = bound_output.skip_binder();\n+                    err.span_label(e.span, &format!(\"this method call resolves to `{:?}`\", output));\n+                    let kind = &output.kind;\n+                    if let ty::Projection(proj) | ty::UnnormalizedProjection(proj) = kind {\n+                        if let Some(span) = self.tcx.hir().span_if_local(proj.item_def_id) {\n+                            err.span_label(span, &format!(\"`{:?}` defined here\", output));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn need_type_info_err_in_generator(\n         &self,\n         kind: hir::GeneratorKind,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None).0;\n+        let (name, _, descr) = self.extract_type_name(&ty, None);\n         let mut err = struct_span_err!(\n             self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n         );\n-        err.span_label(span, InferCtxt::missing_type_msg(&name));\n+        err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n         err\n     }\n \n-    fn missing_type_msg(type_name: &str) -> String {\n+    fn missing_type_msg(type_name: &str, descr: &str) -> Cow<'static, str>{\n         if type_name == \"_\" {\n-            \"cannot infer type\".to_owned()\n+            \"cannot infer type\".into()\n         } else {\n-            format!(\"cannot infer type for `{}`\", type_name)\n+            format!(\"cannot infer type for {} `{}`\", descr, type_name).into()\n         }\n     }\n }"}, {"sha": "da36b31038de76c5b41956eca712d88b14cd8319", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 85, "deletions": 34, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -22,6 +22,7 @@ use crate::hir;\n use crate::hir::Node;\n use crate::hir::def_id::DefId;\n use crate::infer::{self, InferCtxt};\n+use crate::infer::error_reporting::TypeAnnotationNeeded as ErrorCode;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::session::DiagnosticMessageId;\n use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n@@ -1952,7 +1953,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        match predicate {\n+        let mut err = match predicate {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n@@ -1986,59 +1987,109 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // avoid inundating the user with unnecessary errors, but we now\n                 // check upstream for type errors and dont add the obligations to\n                 // begin with in those cases.\n-                if\n-                    self.tcx.lang_items().sized_trait()\n+                if self.tcx.lang_items().sized_trait()\n                     .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                 {\n-                    self.need_type_info_err(body_id, span, self_ty).emit();\n-                } else {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0283,\n-                        \"type annotations needed: cannot resolve `{}`\",\n-                        predicate,\n-                    );\n-                    self.note_obligation_cause(&mut err, obligation);\n-                    err.emit();\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let (Ok(ref snippet), ObligationCauseCode::BindingObligation(ref def_id, _)) = (\n+                    self.tcx.sess.source_map().span_to_snippet(span),\n+                    &obligation.cause.code,\n+                ) {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>'){\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 {\n+                                    \"s\"\n+                                } else {\n+                                    \"\"\n+                                },\n+                            ),\n+                            format!(\"{}::<{}>\", snippet, generics.params.iter()\n+                                .map(|p| p.name.to_string())\n+                                .collect::<Vec<String>>()\n+                                .join(\", \")),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n                 }\n+                err\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n-                if !ty.references_error() && !self.tcx.sess.has_errors() {\n-                    self.need_type_info_err(body_id, span, ty).emit();\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n                 }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n             }\n \n             ty::Predicate::Subtype(ref data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n-                } else {\n-                    let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n-                    // both must be type variables, or the other would've been instantiated\n-                    assert!(a.is_ty_var() && b.is_ty_var());\n-                    self.need_type_info_err(body_id,\n-                                            obligation.cause.span,\n-                                            a).emit();\n+                    return\n                 }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n             }\n \n             _ => {\n-                if !self.tcx.sess.has_errors() {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        obligation.cause.span,\n-                        E0284,\n-                        \"type annotations needed: cannot resolve `{}`\",\n-                        predicate,\n-                    );\n-                    self.note_obligation_cause(&mut err, obligation);\n-                    err.emit();\n+                if self.tcx.sess.has_errors() {\n+                    return;\n                 }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n             }\n-        }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n     }\n \n     /// Returns `true` if the trait predicate may apply for *some* assignment"}, {"sha": "fc7d19766373a2383676ce8ebd9b3778300b66a5", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -871,6 +871,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n+                // We could add a \"consider `foo::<params>`\" suggestion here, but I wasn't able to\n+                // trigger this codepath causing `structuraly_resolved_type` to emit an error.\n+\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }"}, {"sha": "43e7bbcf0c0dcf5a63ae2972dca215862ebbbf96", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -103,6 +103,7 @@ use rustc_index::vec::Idx;\n use rustc_target::spec::abi::Abi;\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n@@ -5359,7 +5360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.need_type_info_err((**self).body_id, sp, ty)\n+                self.need_type_info_err((**self).body_id, sp, ty, E0282)\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }"}, {"sha": "35f25b322e053fa3cf11cabecce552d51c793683", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -8,6 +8,7 @@ use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::InferCtxt;\n+use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -717,7 +718,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t)\n+                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t, E0282)\n                 .emit();\n         }\n     }"}, {"sha": "f9f663af5e2655bce0d3f39d8880e299e11654f9", "filename": "src/test/ui/associated-const/issue-63496.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,8 +2,8 @@ trait A {\n     const C: usize;\n \n     fn f() -> ([u8; A::C], [u8; A::C]);\n-    //~^ ERROR: type annotations needed: cannot resolve\n-    //~| ERROR: type annotations needed: cannot resolve\n+    //~^ ERROR: type annotations needed\n+    //~| ERROR: type annotations needed\n }\n \n fn main() {}"}, {"sha": "23916a3ba440c0919623229701881fea5b416ece", "filename": "src/test/ui/associated-const/issue-63496.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fissue-63496.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,20 +1,24 @@\n-error[E0283]: type annotations needed: cannot resolve `_: A`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-63496.rs:4:21\n    |\n LL |     const C: usize;\n    |     --------------- required by `A::C`\n LL | \n LL |     fn f() -> ([u8; A::C], [u8; A::C]);\n-   |                     ^^^^\n+   |                     ^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: A`\n \n-error[E0283]: type annotations needed: cannot resolve `_: A`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-63496.rs:4:33\n    |\n LL |     const C: usize;\n    |     --------------- required by `A::C`\n LL | \n LL |     fn f() -> ([u8; A::C], [u8; A::C]);\n-   |                                 ^^^^\n+   |                                 ^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: A`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9c825d593d3e499ef64f9460c2c25d67b613121c", "filename": "src/test/ui/associated-item/issue-48027.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-48027.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -7,13 +7,15 @@ LL |     const X: usize;\n LL | impl dyn Bar {}\n    |      ^^^^^^^ the trait `Bar` cannot be made into an object\n \n-error[E0283]: type annotations needed: cannot resolve `_: Bar`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-48027.rs:3:32\n    |\n LL |     const X: usize;\n    |     --------------- required by `Bar::X`\n LL |     fn return_n(&self) -> [u8; Bar::X];\n-   |                                ^^^^^^\n+   |                                ^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: Bar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "069da955b674e02c3327af377fd25d3c2832f9c3", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,18 +1,23 @@\n-error[E0284]: type annotations needed: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-overridden-binding.rs:4:1\n    |\n LL | trait Foo: Iterator<Item = i32> {}\n    | ------------------------------- required by `Foo`\n LL | trait Bar: Foo<Item = u32> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `Self`\n+   |\n+   = note: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n \n-error[E0282]: type annotations needed\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-overridden-binding.rs:7:1\n    |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   | ----------------------------------------- required by `I32Iterator`\n LL | trait U32Iterator = I32Iterator<Item = u32>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `Self`\n+   |\n+   = note: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0282, E0284.\n-For more information about an error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "14ce4836f97f8253f5f33b89d4991431116d4f26", "filename": "src/test/ui/associated-types/associated-types-unconstrained.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,8 +1,10 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as Foo>::A == _`\n+error[E0284]: type annotations needed\n   --> $DIR/associated-types-unconstrained.rs:14:20\n    |\n LL |     let x: isize = Foo::bar();\n-   |                    ^^^^^^^^\n+   |                    ^^^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `<_ as Foo>::A == _`\n \n error: aborting due to previous error\n "}, {"sha": "79c043b701ddb249c69a3bea60a09c1a2eca3527", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -8,7 +8,7 @@ async fn bar<T>() -> () {}\n async fn foo() {\n     bar().await;\n     //~^ ERROR type inside `async fn` body must be known in this context\n-    //~| NOTE cannot infer type for `T`\n+    //~| NOTE cannot infer type for type parameter `T`\n     //~| NOTE the type is part of the `async fn` body because of this `await`\n     //~| NOTE in this expansion of desugaring of `await`\n }"}, {"sha": "b9b4f5133b9a7e5cd20904e5b3975187419d2dc5", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0698]: type inside `async fn` body must be known in this context\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;\n-   |     ^^^ cannot infer type for `T`\n+   |     ^^^ cannot infer type for type parameter `T`\n    |\n note: the type is part of the `async fn` body because of this `await`\n   --> $DIR/unresolved_type_param.rs:9:5"}, {"sha": "8379cbd4908e95fa51f7bf81f674ad999695813f", "filename": "src/test/ui/const-generics/cannot-infer-const-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -10,7 +10,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:9:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for `fn() -> usize {foo::<_: usize>}`\n+   |     ^^^ cannot infer type for fn item `fn() -> usize {foo::<_: usize>}`\n \n error: aborting due to previous error\n "}, {"sha": "9ccad7bcdd7e6173253efe60ec48d0fd2f0271ff", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -30,7 +30,7 @@ error[E0282]: type annotations needed\n   --> $DIR/fn-const-param-infer.rs:22:23\n    |\n LL |     let _ = Checked::<generic>;\n-   |                       ^^^^^^^ cannot infer type for `T`\n+   |                       ^^^^^^^ cannot infer type for type parameter `T`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:25:40"}, {"sha": "b3c673ec027ef76124cbddaf4b7ca01fa84a4e31", "filename": "src/test/ui/consts/issue-64662.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,13 +2,13 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:2:9\n    |\n LL |     A = foo(),\n-   |         ^^^ cannot infer type for `T`\n+   |         ^^^ cannot infer type for type parameter `T`\n \n error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:3:9\n    |\n LL |     B = foo(),\n-   |         ^^^ cannot infer type for `T`\n+   |         ^^^ cannot infer type for type parameter `T`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ae5b7c3ae8f67a3e462d9a5e7ec6e0b48b7eb3fc", "filename": "src/test/ui/error-codes/E0283.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,11 +1,13 @@\n-error[E0283]: type annotations needed: cannot resolve `_: Generator`\n+error[E0283]: type annotations needed\n   --> $DIR/E0283.rs:18:21\n    |\n LL |     fn create() -> u32;\n    |     ------------------- required by `Generator::create`\n ...\n LL |     let cont: u32 = Generator::create();\n-   |                     ^^^^^^^^^^^^^^^^^\n+   |                     ^^^^^^^^^^^^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: Generator`\n \n error: aborting due to previous error\n "}, {"sha": "0adf982d71c908c3c1ef8b7a25a61edc253ab5cb", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -36,7 +36,7 @@ error[E0282]: type annotations needed\n   --> $DIR/E0401.rs:11:5\n    |\n LL |     bfnr(x);\n-   |     ^^^^ cannot infer type for `U`\n+   |     ^^^^ cannot infer type for type parameter `U`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "5f2dd729c739f5cd1693ead7b9b02b4c3cb3ac70", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,8 +1,10 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n+error[E0284]: type annotations needed\n   --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);\n-   |              ^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^ cannot infer type for type parameter `H`\n+   |\n+   = note: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n \n error: aborting due to previous error\n "}, {"sha": "0d565af79b5defeea133f3ff6a0eac4fd226f4b9", "filename": "src/test/ui/issues/issue-16966.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-16966.rs:2:5\n    |\n LL |     panic!(std::default::Default::default());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for `M`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `M`\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n "}, {"sha": "5468268e7de947227a50f8835aef9d3afbb3b34b", "filename": "src/test/ui/issues/issue-17551.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `B<T>`\n   --> $DIR/issue-17551.rs:6:15\n    |\n LL |     let foo = B(marker::PhantomData);\n-   |         ---   ^ cannot infer type for `T`\n+   |         ---   ^ cannot infer type for type parameter `T`\n    |         |\n    |         consider giving `foo` the explicit type `B<T>`, where the type parameter `T` is specified\n "}, {"sha": "b1536bd8ddb0a5d52af1b1fc220aa513a7914066", "filename": "src/test/ui/issues/issue-21974.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations needed: cannot resolve `&'a T: Foo`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-21974.rs:10:1\n    |\n LL |   trait Foo {\n@@ -11,7 +11,9 @@ LL | | {\n LL | |     x.foo();\n LL | |     y.foo();\n LL | | }\n-   | |_^\n+   | |_^ cannot infer type for reference `&'a T`\n+   |\n+   = note: cannot resolve `&'a T: Foo`\n \n error: aborting due to previous error\n "}, {"sha": "22bf513afe89129dd5719c7700da3c2327c0a449", "filename": "src/test/ui/issues/issue-24424.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,6 +2,6 @@ trait Trait1<'l0, T0> {}\n trait Trait0<'l0>  {}\n \n impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n-//~^ ERROR type annotations needed: cannot resolve `T0: Trait0<'l0>`\n+//~^ ERROR type annotations needed\n \n fn main() {}"}, {"sha": "8f0850328b44671bd45a323d49a8ccfa6148a756", "filename": "src/test/ui/issues/issue-24424.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,11 +1,13 @@\n-error[E0283]: type annotations needed: cannot resolve `T0: Trait0<'l0>`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-24424.rs:4:1\n    |\n LL | trait Trait0<'l0>  {}\n    | ----------------- required by `Trait0`\n LL | \n LL | impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T0`\n+   |\n+   = note: cannot resolve `T0: Trait0<'l0>`\n \n error: aborting due to previous error\n "}, {"sha": "de020d4b56ba1b428bc8a77c07a58bcf41b51b1e", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -5,7 +5,7 @@ LL |     let (tx, rx) = channel();\n    |         -------- consider giving this pattern the explicit type `(std::sync::mpsc::Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`, where the type parameter `T` is specified\n ...\n LL |         tx.send(Foo{ foo: PhantomData });\n-   |                 ^^^ cannot infer type for `T`\n+   |                 ^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n "}, {"sha": "271bc526033d412c97a9ce07602ec94200a41321", "filename": "src/test/ui/issues/issue-29147.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-29147.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-29147.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29147.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -18,5 +18,5 @@ impl Foo for S5<u32> { fn xxx(&self) {} }\n impl Foo for S5<u64> { fn xxx(&self) {} }\n \n fn main() {\n-    let _ = <S5<_>>::xxx; //~ ERROR cannot resolve `S5<_>: Foo`\n+    let _ = <S5<_>>::xxx; //~ ERROR type annotations needed\n }"}, {"sha": "1efedb45cace7944d07f5fcc6918401406b3896b", "filename": "src/test/ui/issues/issue-29147.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29147.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,11 +1,13 @@\n-error[E0283]: type annotations needed: cannot resolve `S5<_>: Foo`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-29147.rs:21:13\n    |\n LL | trait Foo { fn xxx(&self); }\n    |             -------------- required by `Foo::xxx`\n ...\n LL |     let _ = <S5<_>>::xxx;\n-   |             ^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^ cannot infer type for struct `S5<_>`\n+   |\n+   = note: cannot resolve `S5<_>: Foo`\n \n error: aborting due to previous error\n "}, {"sha": "a20118d69117050783f86ce541ab42a737683e70", "filename": "src/test/ui/issues/issue-5062.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-5062.rs:1:29\n    |\n LL | fn main() { format!(\"{:?}\", None); }\n-   |                             ^^^^ cannot infer type for `T`\n+   |                             ^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n "}, {"sha": "d99a5772e8a4c7c64098118338b18729b8f0edce", "filename": "src/test/ui/issues/issue-54954.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54954.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -4,14 +4,16 @@ error[E0379]: trait fns cannot be declared const\n LL |     const fn const_val<T: Sized>() -> usize {\n    |     ^^^^^ trait fns cannot be const\n \n-error[E0283]: type annotations needed: cannot resolve `_: Tt`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-54954.rs:3:24\n    |\n LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n ...\n LL |     const fn const_val<T: Sized>() -> usize {\n    |              --------- - required by this bound in `Tt::const_val`\n+   |\n+   = note: cannot resolve `_: Tt`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-54954.rs:13:15"}, {"sha": "e4b9b3b53a69e1d897bd891b08d23035825b3d8d", "filename": "src/test/ui/issues/issue-58022.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58022.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ pub trait Foo: Sized {\n     const SIZE: usize;\n \n     fn new(slice: &[u8; Foo::SIZE]) -> Self;\n-    //~^ ERROR: type annotations needed: cannot resolve `_: Foo`\n+    //~^ ERROR: type annotations needed\n }\n \n pub struct Bar<T: ?Sized>(T);"}, {"sha": "ef0d66d7ad6d122437262c25e0d8902ba486a8fe", "filename": "src/test/ui/issues/issue-58022.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58022.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -4,14 +4,16 @@ error[E0423]: expected function, tuple struct or tuple variant, found trait `Foo\n LL |         Foo(Box::new(*slice))\n    |         ^^^ not a function, tuple struct or tuple variant\n \n-error[E0283]: type annotations needed: cannot resolve `_: Foo`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-58022.rs:4:25\n    |\n LL |     const SIZE: usize;\n    |     ------------------ required by `Foo::SIZE`\n LL | \n LL |     fn new(slice: &[u8; Foo::SIZE]) -> Self;\n-   |                         ^^^^^^^^^\n+   |                         ^^^^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: Foo`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d538a69045f325696dfb26152ac176072c2107cf", "filename": "src/test/ui/issues/issue-6458-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-2.rs:3:21\n    |\n LL |     format!(\"{:?}\", None);\n-   |                     ^^^^ cannot infer type for `T`\n+   |                     ^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n "}, {"sha": "6b3f469ee3789efe852de9397c705483555a5035", "filename": "src/test/ui/issues/issue-6458-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-3.rs:4:5\n    |\n LL |     mem::transmute(0);\n-   |     ^^^^^^^^^^^^^^ cannot infer type for `U`\n+   |     ^^^^^^^^^^^^^^ cannot infer type for type parameter `U`\n \n error: aborting due to previous error\n "}, {"sha": "de315659b6df928e84a5c8b52ee5fa961226e027", "filename": "src/test/ui/issues/issue-6458.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458.rs:9:4\n    |\n LL |    foo(TypeWithState(marker::PhantomData));\n-   |    ^^^ cannot infer type for `State`\n+   |    ^^^ cannot infer type for type parameter `State`\n \n error: aborting due to previous error\n "}, {"sha": "20e2ba144d92636e359de3919603bda17285d07f", "filename": "src/test/ui/issues/issue-65611.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65611.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-65611.rs:59:20\n    |\n LL |     let x = buffer.last().unwrap().0.clone();\n-   |                    ^^^^ cannot infer type for `T`\n+   |             -------^^^^--\n+   |             |      |\n+   |             |      cannot infer type for type parameter `T`\n+   |             this method call resolves to `std::option::Option<&T>`\n    |\n    = note: type must be known at this point\n "}, {"sha": "f3f3c4768095c0c621e63da16b986a92c9e1373f", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `std::vec::Vec<T>`\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:24:17\n    |\n LL |     let mut x = Vec::new();\n-   |         -----   ^^^^^^^^ cannot infer type for `T`\n+   |         -----   ^^^^^^^^ cannot infer type for type parameter `T`\n    |         |\n    |         consider giving `x` the explicit type `std::vec::Vec<T>`, where the type parameter `T` is specified\n "}, {"sha": "be97f2373c31337283ea0773818d5f507bf3166f", "filename": "src/test/ui/missing/missing-items/missing-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/missing-type-parameter.rs:4:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for `X`\n+   |     ^^^ cannot infer type for type parameter `X`\n \n error: aborting due to previous error\n "}, {"sha": "2ef8618192f6b8d14570544c74ab45db51e2aead", "filename": "src/test/ui/question-mark-type-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -9,7 +9,7 @@ fn f(x: &i32) -> Result<i32, ()> {\n \n fn g() -> Result<Vec<i32>, ()> {\n     let l = [1, 2, 3, 4];\n-    l.iter().map(f).collect()? //~ ERROR type annotations needed: cannot resolve\n+    l.iter().map(f).collect()? //~ ERROR type annotations needed\n }\n \n fn main() {"}, {"sha": "7911701946cd3db3723e6372177ca6732a3181c4", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,8 +1,13 @@\n-error[E0284]: type annotations needed: cannot resolve `<_ as std::ops::Try>::Ok == _`\n-  --> $DIR/question-mark-type-infer.rs:12:5\n+error[E0284]: type annotations needed\n+  --> $DIR/question-mark-type-infer.rs:12:21\n    |\n LL |     l.iter().map(f).collect()?\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^^^^^\n+   |                     |\n+   |                     cannot infer type\n+   |                     help: consider specifying the type argument in the method call: `collect::<B>`\n+   |\n+   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n \n error: aborting due to previous error\n "}, {"sha": "d3292bbecbaaa4974e23fb1e2222d1d36fa6af98", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -9,8 +9,8 @@ fn shines_a_beacon_through_the_darkness() {\n }\n \n fn courier_to_des_moines_and_points_west(data: &[u32]) -> String {\n-    data.iter() //~ ERROR type annotations needed\n-        .sum::<_>()\n+    data.iter()\n+        .sum::<_>() //~ ERROR type annotations needed\n         .to_string()\n }\n "}, {"sha": "9824d879dbdd28125751a56a6cbb2c502d20c97f", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -4,16 +4,15 @@ error[E0282]: type annotations needed for `std::option::Option<_>`\n LL |     let x: Option<_> = None;\n    |         - consider giving `x` the explicit type `std::option::Option<_>`, where the type parameter `T` is specified\n LL |     x.unwrap().method_that_could_exist_on_some_type();\n-   |       ^^^^^^ cannot infer type for `T`\n+   |       ^^^^^^ cannot infer type for type parameter `T`\n    |\n    = note: type must be known at this point\n \n error[E0282]: type annotations needed\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:12:5\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:13:10\n    |\n-LL | /     data.iter()\n-LL | |         .sum::<_>()\n-   | |___________________^ cannot infer type\n+LL |         .sum::<_>()\n+   |          ^^^ cannot infer type\n    |\n    = note: type must be known at this point\n "}, {"sha": "8366285edcda8d31c14c99072e922b497713f459", "filename": "src/test/ui/span/type-annotations-needed-expr.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/type-annotations-needed-expr.rs:2:39\n    |\n LL |     let _ = (vec![1,2,3]).into_iter().sum() as f64;\n-   |                                       ^^^ cannot infer type for `S`\n+   |                                       ^^^\n+   |                                       |\n+   |                                       cannot infer type for type parameter `S`\n+   |                                       help: consider specifying the type argument in the method call: `sum::<S>`\n    |\n    = note: type must be known at this point\n "}, {"sha": "f9718dac3547d79ac4538dc96c96e6f607a3c90a", "filename": "src/test/ui/traits/trait-static-method-generic-inference.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-static-method-generic-inference.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,11 +1,13 @@\n-error[E0283]: type annotations needed: cannot resolve `_: base::HasNew<base::Foo>`\n+error[E0283]: type annotations needed\n   --> $DIR/trait-static-method-generic-inference.rs:24:25\n    |\n LL |         fn new() -> T;\n    |         -------------- required by `base::HasNew::new`\n ...\n LL |     let _f: base::Foo = base::HasNew::new();\n-   |                         ^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^^^^^^^^^^^^^ cannot infer type\n+   |\n+   = note: cannot resolve `_: base::HasNew<base::Foo>`\n \n error: aborting due to previous error\n "}, {"sha": "7bcda234c4b0d109a9413fac27cb8776ebbdb778", "filename": "src/test/ui/traits/traits-multidispatch-convert-ambig-dest.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/traits-multidispatch-convert-ambig-dest.rs:26:5\n    |\n LL |     test(22, std::default::Default::default());\n-   |     ^^^^ cannot infer type for `U`\n+   |     ^^^^ cannot infer type for type parameter `U`\n \n error: aborting due to previous error\n "}, {"sha": "b15de2a4559d5b030c317a52afc22218736bbb2f", "filename": "src/test/ui/type-inference/or_else-multiple-type-params.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,10 @@\n+use std::process::{Command, Stdio};\n+\n+fn main() {\n+    let process = Command::new(\"wc\")\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .or_else(|err| { //~ ERROR type annotations needed\n+            panic!(\"oh no: {:?}\", err);\n+        }).unwrap();\n+}"}, {"sha": "141cc25ffe22d37cb5a959240f6cab7ddf995543", "filename": "src/test/ui/type-inference/or_else-multiple-type-params.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,12 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/or_else-multiple-type-params.rs:7:10\n+   |\n+LL |         .or_else(|err| {\n+   |          ^^^^^^^\n+   |          |\n+   |          cannot infer type for type parameter `F`\n+   |          help: consider specifying the type arguments in the method call: `or_else::<F, O>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "afc4d90b8650f3d263c003b99107ce20eb5848ea", "filename": "src/test/ui/type-inference/sort_by_key.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let mut lst: [([i32; 10], bool); 10] = [([0; 10], false); 10];\n+    lst.sort_by_key(|&(v, _)| v.iter().sum()); //~ ERROR type annotations needed\n+    println!(\"{:?}\", lst);\n+}"}, {"sha": "1d386bd1f42c9cc9de938b34fc668adb45bbcf37", "filename": "src/test/ui/type-inference/sort_by_key.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/sort_by_key.rs:3:9\n+   |\n+LL |     lst.sort_by_key(|&(v, _)| v.iter().sum());\n+   |         ^^^^^^^^^^^                    --- help: consider specifying the type argument in the method call: `sum::<S>`\n+   |         |\n+   |         cannot infer type for type parameter `K`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "0167e943612d06cb9be04ccb0431f1e026353e68", "filename": "src/test/ui/type-inference/unbounded-associated-type.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,16 @@\n+trait T {\n+    type A;\n+    fn foo(&self) -> Self::A {\n+        panic!()\n+    }\n+}\n+\n+struct S<X>(std::marker::PhantomData<X>);\n+\n+impl<X> T for S<X> {\n+   type A = X;\n+}\n+\n+fn main() {\n+    S(std::marker::PhantomData).foo(); //~ ERROR type annotations needed\n+}"}, {"sha": "726dd4b4758176b0e51e4ba191b33cbbf467124e", "filename": "src/test/ui/type-inference/unbounded-associated-type.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/unbounded-associated-type.rs:15:5\n+   |\n+LL |     type A;\n+   |     ------- `<Self as T>::A` defined here\n+...\n+LL |     S(std::marker::PhantomData).foo();\n+   |     ^--------------------------------\n+   |     |\n+   |     this method call resolves to `<Self as T>::A`\n+   |     cannot infer type for type parameter `X`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "81d054b3a1e078ceadedcff341c4d21a93bebd44", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn-with-assoc-type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,9 @@\n+#[allow(invalid_type_param_default)]\n+\n+fn foo<T, U = u64>() -> (T, U) {\n+    panic!()\n+}\n+\n+fn main() {\n+    foo(); //~ ERROR type annotations needed\n+}"}, {"sha": "52039d0e934e6332f72c9785da7878c59b34b0a6", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn-with-assoc-type.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/unbounded-type-param-in-fn-with-assoc-type.rs:8:5\n+   |\n+LL |     foo();\n+   |     ^^^ cannot infer type for type parameter `T`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "1f336ed59a6ddb6ee7a87ae4fe804ebc4f4978d4", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,7 @@\n+fn foo<T>() -> T {\n+    panic!()\n+}\n+\n+fn main() {\n+    foo(); //~ ERROR type annotations needed\n+}"}, {"sha": "8d317df6ce95a860f0c82c3b42c143b9cbc1ddd5", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/unbounded-type-param-in-fn.rs:6:5\n+   |\n+LL |     foo();\n+   |     ^^^ cannot infer type for type parameter `T`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "a420515be496d2545fa99d85a91ebe8e68673324", "filename": "src/test/ui/type/type-annotation-needed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.rs?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -5,4 +5,6 @@ fn foo<T: Into<String>>(x: i32) {}\n fn main() {\n     foo(42);\n     //~^ ERROR type annotations needed\n+    //~| NOTE cannot infer type\n+    //~| NOTE cannot resolve\n }"}, {"sha": "94425440d333c2f90fe70c2e783f12fb85bc1631", "filename": "src/test/ui/type/type-annotation-needed.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,11 +1,16 @@\n-error[E0283]: type annotations needed: cannot resolve `_: std::convert::Into<std::string::String>`\n+error[E0283]: type annotations needed\n   --> $DIR/type-annotation-needed.rs:6:5\n    |\n LL | fn foo<T: Into<String>>(x: i32) {}\n    |    ---    ------------ required by this bound in `foo`\n ...\n LL |     foo(42);\n    |     ^^^\n+   |     |\n+   |     cannot infer type for type parameter `T`\n+   |     help: consider specifying the type argument in the function call: `foo::<T>`\n+   |\n+   = note: cannot resolve `_: std::convert::Into<std::string::String>`\n \n error: aborting due to previous error\n "}, {"sha": "53cc769bae3cf9336ab3485ad111e38ee4b7116b", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_vec.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `std::vec::Vec<T>`\n   --> $DIR/cannot_infer_local_or_vec.rs:2:13\n    |\n LL |     let x = vec![];\n-   |         -   ^^^^^^ cannot infer type for `T`\n+   |         -   ^^^^^^ cannot infer type for type parameter `T`\n    |         |\n    |         consider giving `x` the explicit type `std::vec::Vec<T>`, where the type parameter `T` is specified\n    |"}, {"sha": "df7228ce9f2a84ffe3e04f00b5ef872b8db71ce5", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_vec_in_tuples.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `(std::vec::Vec<T>,)`\n   --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:18\n    |\n LL |     let (x, ) = (vec![], );\n-   |         -----    ^^^^^^ cannot infer type for `T`\n+   |         -----    ^^^^^^ cannot infer type for type parameter `T`\n    |         |\n    |         consider giving this pattern the explicit type `(std::vec::Vec<T>,)`, where the type parameter `T` is specified\n    |"}, {"sha": "fae7b79269bec77caa595ea1b63506e1a0c73530", "filename": "src/test/ui/type/type-check/issue-22897.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-22897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-22897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-22897.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-22897.rs:4:5\n    |\n LL |     [];\n-   |     ^^ cannot infer type for `[_; 0]`\n+   |     ^^ cannot infer type for array `[_; 0]`\n \n error: aborting due to previous error\n "}, {"sha": "4fc028550914943daa6154ec4b1ad5446daf8315", "filename": "src/test/ui/type/type-check/issue-40294.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -1,4 +1,4 @@\n-error[E0283]: type annotations needed: cannot resolve `&'a T: Foo`\n+error[E0283]: type annotations needed\n   --> $DIR/issue-40294.rs:5:1\n    |\n LL |   trait Foo: Sized {\n@@ -11,7 +11,9 @@ LL | | {\n LL | |     x.foo();\n LL | |     y.foo();\n LL | | }\n-   | |_^\n+   | |_^ cannot infer type for reference `&'a T`\n+   |\n+   = note: cannot resolve `&'a T: Foo`\n \n error: aborting due to previous error\n "}, {"sha": "6c4fde94a61997c31f2cbfc3f5041e0d58b594c7", "filename": "src/test/ui/unconstrained-none.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Funconstrained-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Funconstrained-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-none.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-none.rs:4:5\n    |\n LL |     None;\n-   |     ^^^^ cannot infer type for `T`\n+   |     ^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n "}, {"sha": "d6985a61daf0b133733bdad895291f0f9c17042d", "filename": "src/test/ui/unconstrained-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-ref.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-ref.rs:6:5\n    |\n LL |     S { o: &None };\n-   |     ^ cannot infer type for `T`\n+   |     ^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n "}, {"sha": "62fc42fbae4636d6ebad9e81fd77e69d9944a825", "filename": "src/test/ui/vector-no-ann.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fvector-no-ann.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8843b28e64b02c2245f5869ad90cafa6d85ab0d9/src%2Ftest%2Fui%2Fvector-no-ann.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvector-no-ann.stderr?ref=8843b28e64b02c2245f5869ad90cafa6d85ab0d9", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `std::vec::Vec<T>`\n   --> $DIR/vector-no-ann.rs:2:16\n    |\n LL |     let _foo = Vec::new();\n-   |         ----   ^^^^^^^^ cannot infer type for `T`\n+   |         ----   ^^^^^^^^ cannot infer type for type parameter `T`\n    |         |\n    |         consider giving `_foo` the explicit type `std::vec::Vec<T>`, where the type parameter `T` is specified\n "}]}