{"sha": "f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MWEyNmYyMDQwZGZhNzUyODI1YTdkMWZkZmJkNWE4YWUzMzEwY2Y=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-03-16T14:37:17Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-03-16T14:39:53Z"}, "message": "Add sort_by_cached_key method", "tree": {"sha": "74de6e2fac1769a77270b322bd17f48c59b0567b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74de6e2fac1769a77270b322bd17f48c59b0567b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "html_url": "https://github.com/rust-lang/rust/commit/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdcc6f939a10bc23a434b2ef301238650841dec9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcc6f939a10bc23a434b2ef301238650841dec9", "html_url": "https://github.com/rust-lang/rust/commit/bdcc6f939a10bc23a434b2ef301238650841dec9"}], "stats": {"total": 70, "additions": 56, "deletions": 14}, "files": [{"sha": "306c467f048cb52145b7700a17fc715c96540c79", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "patch": "@@ -1301,33 +1301,76 @@ impl<T> [T] {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n+    /// Sorts the slice with a key extraction function.\n+    ///\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log m n)`\n+    /// worst-case, where the key function is `O(m)`.\n+    ///\n+    /// For expensive key functions (e.g. functions that are not simple property accesses or\n+    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n+    /// significantly faster, as it does not recompute element keys.\n+    ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is an adaptive, iterative merge sort inspired by\n+    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n+    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n+    /// two or more sorted sequences concatenated one after another.\n+    ///\n+    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n+    /// non-allocating insertion sort is used instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [-5i32, 4, 1, -3, 2];\n+    ///\n+    /// v.sort_by_key(|k| k.abs());\n+    /// assert!(v == [1, 2, -3, 4, -5]);\n+    /// ```\n+    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n+    #[inline]\n+    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        merge_sort(self, |a, b| f(a).lt(&f(b)));\n+    }\n+\n     /// Sorts the slice with a key extraction function.\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n+    /// For simple key functions (e.g. functions that are property accesses or\n+    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// faster.\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n     /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n     /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n     /// two or more sorted sequences concatenated one after another.\n     ///\n-    /// The algorithm allocates temporary storage in a `Vec<(K, usize)` the length of the slice.\n+    /// The algorithm allocates temporary storage in a `Vec<(K, usize)>` the length of the slice.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n-    /// v.sort_by_key(|k| k.abs());\n+    /// v.sort_by_cached_key(|k| k.abs());\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n-    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n+    #[unstable(feature = \"slice_sort_by_uncached_key\", issue = \"34447\")]\n     #[inline]\n-    pub fn sort_by_key<K, F>(&mut self, f: F)\n+    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n         where F: FnMut(&T) -> K, K: Ord\n     {\n         // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n@@ -1432,9 +1475,6 @@ impl<T> [T] {\n     /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n     /// elements.\n     ///\n-    /// Note that, currently, the key function for [`sort_unstable_by_key`] is called multiple times\n-    /// per element, unlike [`sort_by_key`].\n-    ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n     /// and `O(m n log m n)` worst-case, where the key function is `O(m)`.\n     ///\n@@ -1446,8 +1486,9 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// Due to its key calling strategy, [`sort_unstable_by_key`] is likely to be slower than\n-    /// [`sort_by_key`] in cases where the key function is expensive.\n+    /// Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key)\n+    /// is likely to be slower than [`sort_by_cached_key`](#method.sort_by_uncached_key) in\n+    /// cases where the key function is expensive.\n     ///\n     /// # Examples\n     ///\n@@ -1458,8 +1499,6 @@ impl<T> [T] {\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n     ///\n-    /// [`sort_by_key`]: #method.sort_by_key\n-    /// [`sort_unstable_by_key`]: #method.sort_unstable_by_key\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]"}, {"sha": "7d4dac1c5ec996a4a7891d808a5329c82aa0d41d", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=f41a26f2040dfa752825a7d1fdfbd5a8ae3310cf", "patch": "@@ -426,9 +426,12 @@ fn test_sort() {\n                 assert!(v.windows(2).all(|w| w[0] >= w[1]));\n \n                 // Sort in lexicographic order.\n-                let mut v = orig.clone();\n-                v.sort_by_key(|x| x.to_string());\n-                assert!(v.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n \n                 // Sort with many pre-sorted runs.\n                 let mut v = orig.clone();"}]}