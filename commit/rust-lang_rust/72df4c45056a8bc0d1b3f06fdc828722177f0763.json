{"sha": "72df4c45056a8bc0d1b3f06fdc828722177f0763", "node_id": "C_kwDOAAsO6NoAKDcyZGY0YzQ1MDU2YThiYzBkMWIzZjA2ZmRjODI4NzIyMTc3ZjA3NjM", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2022-03-12T23:34:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-12T23:34:58Z"}, "message": "portable-simd#261: Rename horizontal_* to reduce_*", "tree": {"sha": "37ec853c9d53c045adae5d5d9bbac86002565792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37ec853c9d53c045adae5d5d9bbac86002565792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72df4c45056a8bc0d1b3f06fdc828722177f0763", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiLS4iCRBK7hj4Ov3rIwAAd+wIAJrG0zqV80Vnh/r08DxuF6aZ\nZBOR5raGJq++cZfKrOx/4wW836HcNnAvQ0+ol7c6RnSfU2H+Wf9+4H8uyQcqxbVW\nJXAgFOFhCyqzKlfNT5GVMrkU2SR44uGxreIW8kZ1qy1H6U0KCLYLcUQ3OfaC/b1K\nqCvXA7GPvmBRgvr0ULUHGM43PsYTDH4wTYX9EFgCmLITyfW0zivpuKBr0c9jCGt9\nimyf2nDGu1x/Bv6zqpG/jnlWBOMT86F/2/thitU2sderBYsytTLXMoItaT/vEajj\ntPcGoRS0X7rIM+na4nMf9kp96/ABWD/5OBcs93fWGyO9FA090YwLK/oD0uNAUVk=\n=E8pv\n-----END PGP SIGNATURE-----\n", "payload": "tree 37ec853c9d53c045adae5d5d9bbac86002565792\nparent 49043f4434b02d0a8a68c87d7672cc2e944a3deb\nparent b6e03f58864dde979dbe97b7d983d0ba29b16227\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1647128098 -0800\ncommitter GitHub <noreply@github.com> 1647128098 -0800\n\nportable-simd#261: Rename horizontal_* to reduce_*\n\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72df4c45056a8bc0d1b3f06fdc828722177f0763", "html_url": "https://github.com/rust-lang/rust/commit/72df4c45056a8bc0d1b3f06fdc828722177f0763", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72df4c45056a8bc0d1b3f06fdc828722177f0763/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49043f4434b02d0a8a68c87d7672cc2e944a3deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/49043f4434b02d0a8a68c87d7672cc2e944a3deb", "html_url": "https://github.com/rust-lang/rust/commit/49043f4434b02d0a8a68c87d7672cc2e944a3deb"}, {"sha": "b6e03f58864dde979dbe97b7d983d0ba29b16227", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e03f58864dde979dbe97b7d983d0ba29b16227", "html_url": "https://github.com/rust-lang/rust/commit/b6e03f58864dde979dbe97b7d983d0ba29b16227"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "75158e5aa855017f4e4289bc4be21305ba2edd30", "filename": "beginners-guide.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/beginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/beginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/beginners-guide.md?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -33,7 +33,7 @@ SIMD has a few special vocabulary terms you should know:\n \n * **Vertical:** When an operation is \"vertical\", each lane processes individually without regard to the other lanes in the same vector. For example, a \"vertical add\" between two vectors would add lane 0 in `a` with lane 0 in `b`, with the total in lane 0 of `out`, and then the same thing for lanes 1, 2, etc. Most SIMD operations are vertical operations, so if your problem is a vertical problem then you can probably solve it with SIMD.\n \n-* **Horizontal:** When an operation is \"horizontal\", the lanes within a single vector interact in some way. A \"horizontal add\" might add up lane 0 of `a` with lane 1 of `a`, with the total in lane 0 of `out`.\n+* **Reducing/Reduce:** When an operation is \"reducing\" (functions named `reduce_*`), the lanes within a single vector are merged using some operation such as addition, returning the merged value as a scalar. For instance, a reducing add would return the sum of all the lanes' values.\n \n * **Target Feature:** Rust calls a CPU architecture extension a `target_feature`. Proper SIMD requires various CPU extensions to be enabled (details below). Don't confuse this with `feature`, which is a Cargo crate concept.\n \n@@ -83,4 +83,4 @@ Fortunately, most SIMD types have a fairly predictable size. `i32x4` is bit-equi\n However, this is not the same as alignment. Computer architectures generally prefer aligned accesses, especially when moving data between memory and vector registers, and while some support specialized operations that can bend the rules to help with this, unaligned access is still typically slow, or even undefined behavior. In addition, different architectures can require different alignments when interacting with their native SIMD types. For this reason, any `#[repr(simd)]` type has a non-portable alignment. If it is necessary to directly interact with the alignment of these types, it should be via [`mem::align_of`].\n \n [`mem::transmute`]: https://doc.rust-lang.org/core/mem/fn.transmute.html\n-[`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html\n\\ No newline at end of file\n+[`mem::align_of`]: https://doc.rust-lang.org/core/mem/fn.align_of.html"}, {"sha": "39f530f68f57a3bb241eb95e1771bf0a5aabe88a", "filename": "crates/core_simd/examples/matrix_inversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -233,7 +233,7 @@ pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n     let det = det.rotate_lanes_right::<2>() + det;\n     let det = det.reverse().rotate_lanes_right::<2>() + det;\n \n-    if det.horizontal_sum() == 0. {\n+    if det.reduce_sum() == 0. {\n         return None;\n     }\n     // calculate the reciprocal"}, {"sha": "664a0454bbd09522948db8abbdc4cefbe5cec876", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -107,10 +107,10 @@ mod nbody {\n         let mut e = 0.;\n         for i in 0..N_BODIES {\n             let bi = &bodies[i];\n-            e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n+            e += bi.mass * (bi.v * bi.v).reduce_sum() * 0.5;\n             for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n                 let dx = bi.x - bj.x;\n-                e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+                e -= bi.mass * bj.mass / (dx * dx).reduce_sum().sqrt()\n             }\n         }\n         e\n@@ -134,8 +134,8 @@ mod nbody {\n         let mut mag = [0.0; N];\n         for i in (0..N).step_by(2) {\n             let d2s = f64x2::from_array([\n-                (r[i] * r[i]).horizontal_sum(),\n-                (r[i + 1] * r[i + 1]).horizontal_sum(),\n+                (r[i] * r[i]).reduce_sum(),\n+                (r[i + 1] * r[i + 1]).reduce_sum(),\n             ]);\n             let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n             mag[i] = dmags[0];"}, {"sha": "012182e090b9f1b2ab3bef92a654a6bfd7ec0837", "filename": "crates/core_simd/examples/spectral_norm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -20,7 +20,7 @@ fn mult_av(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n \n@@ -38,7 +38,7 @@ fn mult_atv(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n "}, {"sha": "3177fd167fc44bcf2ad168503d1b6d7fd96190ef", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -11,30 +11,30 @@ macro_rules! impl_integer_reductions {\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n-            /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            /// Reducing wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -60,9 +60,9 @@ macro_rules! impl_float_reductions {\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n \n-            /// Horizontal add.  Returns the sum of the lanes of the vector.\n+            /// Reducing add.  Returns the sum of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n@@ -72,9 +72,9 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal multiply.  Returns the product of the lanes of the vector.\n+            /// Reducing multiply.  Returns the product of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n@@ -84,22 +84,22 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -116,10 +116,10 @@ where\n     T: SimdElement + BitAnd<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_and(self) -> T {\n+    pub fn reduce_and(self) -> T {\n         unsafe { simd_reduce_and(self) }\n     }\n }\n@@ -130,10 +130,10 @@ where\n     T: SimdElement + BitOr<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_or(self) -> T {\n+    pub fn reduce_or(self) -> T {\n         unsafe { simd_reduce_or(self) }\n     }\n }\n@@ -144,10 +144,10 @@ where\n     T: SimdElement + BitXor<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_xor(self) -> T {\n+    pub fn reduce_xor(self) -> T {\n         unsafe { simd_reduce_xor(self) }\n     }\n }"}, {"sha": "7c9b17673efe3e4d18989ce5132114e71f9371c0", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72df4c45056a8bc0d1b3f06fdc828722177f0763/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=72df4c45056a8bc0d1b3f06fdc828722177f0763", "patch": "@@ -94,70 +94,70 @@ macro_rules! impl_binary_checked_op_test {\n macro_rules! impl_common_integer_tests {\n     { $vector:ident, $scalar:ident } => {\n         test_helpers::test_lanes! {\n-            fn horizontal_sum<const LANES: usize>() {\n+            fn reduce_sum<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_sum(),\n+                        $vector::<LANES>::from_array(x).reduce_sum(),\n                         x.iter().copied().fold(0 as $scalar, $scalar::wrapping_add),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_product<const LANES: usize>() {\n+            fn reduce_product<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_product(),\n+                        $vector::<LANES>::from_array(x).reduce_product(),\n                         x.iter().copied().fold(1 as $scalar, $scalar::wrapping_mul),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_and<const LANES: usize>() {\n+            fn reduce_and<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_and(),\n+                        $vector::<LANES>::from_array(x).reduce_and(),\n                         x.iter().copied().fold(-1i8 as $scalar, <$scalar as core::ops::BitAnd>::bitand),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_or<const LANES: usize>() {\n+            fn reduce_or<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_or(),\n+                        $vector::<LANES>::from_array(x).reduce_or(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitOr>::bitor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_xor<const LANES: usize>() {\n+            fn reduce_xor<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_xor(),\n+                        $vector::<LANES>::from_array(x).reduce_xor(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitXor>::bitxor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_max<const LANES: usize>() {\n+            fn reduce_max<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_max(),\n+                        $vector::<LANES>::from_array(x).reduce_max(),\n                         x.iter().copied().max().unwrap(),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_min<const LANES: usize>() {\n+            fn reduce_min<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_min(),\n+                        $vector::<LANES>::from_array(x).reduce_min(),\n                         x.iter().copied().min().unwrap(),\n                     );\n                     Ok(())\n@@ -528,29 +528,29 @@ macro_rules! impl_float_tests {\n                     })\n                 }\n \n-                fn horizontal_sum<const LANES: usize>() {\n+                fn reduce_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_sum(),\n+                            Vector::<LANES>::from_array(x).reduce_sum(),\n                             x.iter().sum(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_product<const LANES: usize>() {\n+                fn reduce_product<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_product(),\n+                            Vector::<LANES>::from_array(x).reduce_product(),\n                             x.iter().product(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_max<const LANES: usize>() {\n+                fn reduce_max<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_max();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::max);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n@@ -560,9 +560,9 @@ macro_rules! impl_float_tests {\n                     });\n                 }\n \n-                fn horizontal_min<const LANES: usize>() {\n+                fn reduce_min<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_min();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_min();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::min);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {"}]}