{"sha": "4560fe2abffde05e6ceb084e6d42207e0ce84b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NjBmZTJhYmZmZGUwNWU2Y2ViMDg0ZTZkNDIyMDdlMGNlODRiNjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T13:53:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "Generate only minimal set of ineresting tokens", "tree": {"sha": "9aa66654c1c3918e112b47246a29f197ea5b233a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aa66654c1c3918e112b47246a29f197ea5b233a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4560fe2abffde05e6ceb084e6d42207e0ce84b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4560fe2abffde05e6ceb084e6d42207e0ce84b68", "html_url": "https://github.com/rust-lang/rust/commit/4560fe2abffde05e6ceb084e6d42207e0ce84b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4560fe2abffde05e6ceb084e6d42207e0ce84b68/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d71a6bf0ca51ae099a5b470afdb957bca321441", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d71a6bf0ca51ae099a5b470afdb957bca321441", "html_url": "https://github.com/rust-lang/rust/commit/8d71a6bf0ca51ae099a5b470afdb957bca321441"}], "stats": {"total": 1367, "additions": 61, "deletions": 1306}, "files": [{"sha": "1437a38c9681594675cb96fe9f84d56b84c106cf", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -80,7 +80,7 @@ impl<N: AstNode> Iterator for AstChildren<N> {\n }\n \n mod support {\n-    use super::{AstChildren, AstNode, AstToken, SyntaxKind, SyntaxNode, SyntaxToken};\n+    use super::{AstChildren, AstNode, SyntaxKind, SyntaxNode, SyntaxToken};\n \n     pub(super) fn child<N: AstNode>(parent: &SyntaxNode) -> Option<N> {\n         parent.children().find_map(N::cast)\n@@ -90,10 +90,6 @@ mod support {\n         AstChildren::new(parent)\n     }\n \n-    pub(super) fn token<T: AstToken>(parent: &SyntaxNode) -> Option<T> {\n-        parent.children_with_tokens().filter_map(|it| it.into_token()).find_map(T::cast)\n-    }\n-\n     pub(super) fn token2(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n         parent.children_with_tokens().filter_map(|it| it.into_token()).find(|it| it.kind() == kind)\n     }"}, {"sha": "9e5411ee58a65643ca3f7970bc6fd518449f8ec1", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -189,15 +189,15 @@ impl ast::RecordFieldList {\n impl ast::TypeParam {\n     #[must_use]\n     pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon() {\n+        let colon = match self.colon_token() {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n         let end = match self.type_bound_list() {\n             Some(it) => it.syntax().clone().into(),\n-            None => colon.syntax().clone().into(),\n+            None => colon.clone().into(),\n         };\n-        self.replace_children(colon.syntax().clone().into()..=end, iter::empty())\n+        self.replace_children(colon.into()..=end, iter::empty())\n     }\n }\n "}, {"sha": "d91275b531f4e71a6e222e98d9642c802e2c8aaa", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n use ra_parser::SyntaxKind;\n \n use crate::{\n-    ast::{self, support, AstNode, AstToken, AttrInput, NameOwner, SyntaxNode},\n+    ast::{self, support, AstNode, AttrInput, NameOwner, SyntaxNode},\n     SmolStr, SyntaxElement, SyntaxToken, T,\n };\n \n@@ -327,23 +327,23 @@ impl ast::TypeBound {\n         }\n     }\n \n-    pub fn const_question_token(&self) -> Option<ast::Question> {\n+    pub fn const_question_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n             .take_while(|it| it.kind() != T![const])\n-            .find_map(ast::Question::cast)\n+            .find(|it| it.kind() == T![?])\n     }\n \n-    pub fn question_token(&self) -> Option<ast::Question> {\n+    pub fn question_token(&self) -> Option<SyntaxToken> {\n         if self.const_token().is_some() {\n             self.syntax()\n                 .children_with_tokens()\n                 .filter_map(|it| it.into_token())\n                 .skip_while(|it| it.kind() != T![const])\n-                .find_map(ast::Question::cast)\n+                .find(|it| it.kind() == T![?])\n         } else {\n-            support::token(&self.syntax)\n+            support::token2(&self.syntax, T![?])\n         }\n     }\n }\n@@ -384,12 +384,12 @@ impl ast::MacroCall {\n }\n \n impl ast::LifetimeParam {\n-    pub fn lifetime_bounds(&self) -> impl Iterator<Item = ast::Lifetime> {\n+    pub fn lifetime_bounds(&self) -> impl Iterator<Item = SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n             .skip_while(|x| x.kind() != T![:])\n-            .filter_map(ast::Lifetime::cast)\n+            .filter(|it| it.kind() == T![lifetime])\n     }\n }\n "}, {"sha": "3950e2b7f36db10aacc5fd9f81c3151b50ba7529", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 8, "deletions": 1288, "changes": 1296, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -6,1246 +6,6 @@ use crate::{\n     SyntaxToken,\n };\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Semi {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Semi {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Semi {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SEMI }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Comma {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Comma {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Comma {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == COMMA }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LParen {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for LParen {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for LParen {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == L_PAREN }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RParen {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RParen {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RParen {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == R_PAREN }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LCurly {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for LCurly {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for LCurly {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == L_CURLY }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RCurly {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RCurly {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RCurly {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == R_CURLY }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LBrack {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for LBrack {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for LBrack {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == L_BRACK }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RBrack {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RBrack {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RBrack {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == R_BRACK }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LAngle {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for LAngle {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for LAngle {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == L_ANGLE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RAngle {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RAngle {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RAngle {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == R_ANGLE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct At {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for At {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for At {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pound {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Pound {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Pound {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == POUND }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Tilde {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Tilde {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Tilde {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TILDE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Question {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Question {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Question {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == QUESTION }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Dollar {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Dollar {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Dollar {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOLLAR }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Amp {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Amp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Amp {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AMP }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pipe {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Pipe {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Pipe {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Plus {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Plus {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Plus {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUS }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Star {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Star {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Star {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STAR }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Slash {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Slash {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Slash {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASH }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Caret {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Caret {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Caret {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CARET }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Percent {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Percent {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Percent {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Underscore {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Underscore {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Underscore {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == UNDERSCORE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Dot {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Dot {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Dot {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Dotdot {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Dotdot {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Dotdot {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Dotdotdot {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Dotdotdot {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Dotdotdot {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTDOT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Dotdoteq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Dotdoteq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Dotdoteq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Colon {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Colon {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Colon {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == COLON }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Coloncolon {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Coloncolon {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Coloncolon {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == COLONCOLON }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Eq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Eq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Eq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Eqeq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Eqeq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Eqeq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EQEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FatArrow {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for FatArrow {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for FatArrow {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FAT_ARROW }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Excl {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Excl {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Excl {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXCL }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Neq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Neq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Neq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Minus {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Minus {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Minus {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUS }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ThinArrow {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for ThinArrow {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for ThinArrow {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == THIN_ARROW }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Lteq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Lteq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Lteq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LTEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Gteq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Gteq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Gteq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == GTEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pluseq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Pluseq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Pluseq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUSEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Minuseq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Minuseq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Minuseq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUSEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pipeeq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Pipeeq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Pipeeq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Ampeq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Ampeq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Ampeq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Careteq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Careteq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Careteq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CARETEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Slasheq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Slasheq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Slasheq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASHEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Stareq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Stareq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Stareq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STAREQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Percenteq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Percenteq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Percenteq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENTEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Ampamp {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Ampamp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Ampamp {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPAMP }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pipepipe {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Pipepipe {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Pipepipe {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEPIPE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Shl {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Shl {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Shl {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SHL }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Shr {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Shr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Shr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SHR }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Shleq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Shleq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Shleq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SHLEQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Shreq {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Shreq {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Shreq {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SHREQ }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct IntNumber {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for IntNumber {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for IntNumber {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == INT_NUMBER }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FloatNumber {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for FloatNumber {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for FloatNumber {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FLOAT_NUMBER }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Char {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Char {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Char {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CHAR }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Byte {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Byte {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Byte {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct String {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for String {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for String {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STRING }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RawString {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RawString {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RawString {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_STRING }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ByteString {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for ByteString {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for ByteString {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE_STRING }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RawByteString {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for RawByteString {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for RawByteString {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_BYTE_STRING }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Error {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Error {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Error {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ERROR }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Ident {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Ident {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Whitespace {\n     pub(crate) syntax: SyntaxToken,\n }\n@@ -1266,26 +26,6 @@ impl AstToken for Whitespace {\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Lifetime {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Lifetime {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Lifetime {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Comment {\n     pub(crate) syntax: SyntaxToken,\n }\n@@ -1306,36 +46,16 @@ impl AstToken for Comment {\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Shebang {\n-    pub(crate) syntax: SyntaxToken,\n-}\n-impl std::fmt::Display for Shebang {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(&self.syntax, f)\n-    }\n-}\n-impl AstToken for Shebang {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SHEBANG }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LDollar {\n+pub struct String {\n     pub(crate) syntax: SyntaxToken,\n }\n-impl std::fmt::Display for LDollar {\n+impl std::fmt::Display for String {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }\n-impl AstToken for LDollar {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == L_DOLLAR }\n+impl AstToken for String {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRING }\n     fn cast(syntax: SyntaxToken) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1346,16 +66,16 @@ impl AstToken for LDollar {\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RDollar {\n+pub struct RawString {\n     pub(crate) syntax: SyntaxToken,\n }\n-impl std::fmt::Display for RDollar {\n+impl std::fmt::Display for RawString {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }\n-impl AstToken for RDollar {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == R_DOLLAR }\n+impl AstToken for RawString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_STRING }\n     fn cast(syntax: SyntaxToken) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })"}, {"sha": "4d1a290c2857f180471b3501aa6127e2fdd5f86c", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -6,6 +6,7 @@ use stdx::SepBy;\n use crate::{\n     ast::{self, support, AstChildren, AstNode, AstToken},\n     syntax_node::SyntaxElementChildren,\n+    SyntaxToken, T,\n };\n \n pub trait TypeAscriptionOwner: AstNode {\n@@ -63,8 +64,8 @@ pub trait TypeBoundsOwner: AstNode {\n         support::child(self.syntax())\n     }\n \n-    fn colon(&self) -> Option<ast::Colon> {\n-        support::token(self.syntax())\n+    fn colon_token(&self) -> Option<SyntaxToken> {\n+        support::token2(self.syntax(), T![:])\n     }\n }\n "}, {"sha": "7a20d9991b86d9ad84ffae4ef4c2b169bf130b13", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -225,6 +225,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n };\n \n pub(crate) struct AstSrc<'a> {\n+    pub(crate) tokens: &'a [&'a str],\n     pub(crate) nodes: &'a [AstNodeSrc<'a>],\n     pub(crate) enums: &'a [AstEnumSrc<'a>],\n }\n@@ -303,6 +304,7 @@ macro_rules! ast_enums {\n }\n \n pub(crate) const AST_SRC: AstSrc = AstSrc {\n+    tokens: &[\"Whitespace\", \"Comment\", \"String\", \"RawString\"],\n     nodes: &ast_nodes! {\n         struct SourceFile: ModuleItemOwner, AttrsOwner {\n             modules: [Module],"}, {"sha": "678b40133b0c9244f7deaf2b93b59b37e0e177bf", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -24,6 +24,7 @@ const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\n \n const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n const AST_NODES: &str = \"crates/ra_syntax/src/ast/generated/nodes.rs\";\n+const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/doc_tests/generated.rs\";"}, {"sha": "fa48853d20b42e6e6d5deb5241987f00ba5d144d", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560fe2abffde05e6ceb084e6d42207e0ce84b68/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=4560fe2abffde05e6ceb084e6d42207e0ce84b68", "patch": "@@ -19,6 +19,10 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n+    let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n+    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n+    update(ast_tokens_file.as_path(), &contents, mode)?;\n+\n     let ast_nodes_file = project_root().join(codegen::AST_NODES);\n     let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n     update(ast_nodes_file.as_path(), &contents, mode)?;\n@@ -33,6 +37,37 @@ struct ElementKinds {\n     has_tokens: bool,\n }\n \n+fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let tokens = grammar.tokens.iter().map(|token| {\n+        let name = format_ident!(\"{}\", token);\n+        let kind = format_ident!(\"{}\", to_upper_snake_case(token));\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub struct #name {\n+                pub(crate) syntax: SyntaxToken,\n+            }\n+            impl std::fmt::Display for #name {\n+                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                    std::fmt::Display::fmt(&self.syntax, f)\n+                }\n+            }\n+            impl AstToken for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool { kind == #kind }\n+                fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                }\n+                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+            }\n+        }\n+    });\n+\n+    let pretty = crate::reformat(quote! {\n+        use crate::{SyntaxKind::{self, *}, SyntaxToken, ast::AstToken};\n+        #(#tokens)*\n+    })?;\n+    Ok(pretty)\n+}\n+\n fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);"}]}