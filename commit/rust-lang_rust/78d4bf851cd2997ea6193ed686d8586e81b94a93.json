{"sha": "78d4bf851cd2997ea6193ed686d8586e81b94a93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZDRiZjg1MWNkMjk5N2VhNjE5M2VkNjg2ZDg1ODZlODFiOTRhOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T19:41:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T19:41:51Z"}, "message": "auto merge of #12253 : pcwalton/rust/more-vec-ng, r=alexcrichton\n\nr? @brson", "tree": {"sha": "421b65a5dcecb51e63e6ed92faf1f1690d963f7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/421b65a5dcecb51e63e6ed92faf1f1690d963f7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78d4bf851cd2997ea6193ed686d8586e81b94a93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78d4bf851cd2997ea6193ed686d8586e81b94a93", "html_url": "https://github.com/rust-lang/rust/commit/78d4bf851cd2997ea6193ed686d8586e81b94a93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78d4bf851cd2997ea6193ed686d8586e81b94a93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5995b4e93237fe0d1c0ea76e33eb2429f654487", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5995b4e93237fe0d1c0ea76e33eb2429f654487", "html_url": "https://github.com/rust-lang/rust/commit/b5995b4e93237fe0d1c0ea76e33eb2429f654487"}, {"sha": "03b791095d6f6a0b4900ca9ad2e17fb4eb590fb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b791095d6f6a0b4900ca9ad2e17fb4eb590fb7", "html_url": "https://github.com/rust-lang/rust/commit/03b791095d6f6a0b4900ca9ad2e17fb4eb590fb7"}], "stats": {"total": 230, "additions": 221, "deletions": 9}, "files": [{"sha": "e57e7adcf8ddbe68ae33b2d4cd2321cbc4a2d1fa", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=78d4bf851cd2997ea6193ed686d8586e81b94a93", "patch": "@@ -18,6 +18,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::rc::Rc;\n use std::trie::{TrieMap, TrieSet};\n use std::vec;\n+use std::vec_ng::Vec;\n \n pub trait Encoder {\n     // Primitive types:\n@@ -435,6 +436,26 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Vec<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Vec<T> {\n+    fn decode(d: &mut D) -> Vec<T> {\n+        d.read_seq(|d, len| {\n+            Vec::from_fn(len, |i| {\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n+            })\n+        })\n+    }\n+}\n+\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n         s.emit_option(|s| {"}, {"sha": "490f2c9b198d28d8a4b9536c00544848584d0190", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=78d4bf851cd2997ea6193ed686d8586e81b94a93", "patch": "@@ -358,3 +358,13 @@ macro_rules! local_data_key(\n macro_rules! try(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n )\n+\n+#[macro_export]\n+macro_rules! vec(\n+    ($($e:expr),*) => ({\n+        let mut temp = ::std::vec_ng::Vec::new();\n+        $(temp.push($e);)*\n+        temp\n+    })\n+)\n+"}, {"sha": "123b4957599f59d94a47e0af61480052d2db0c08", "filename": "src/libstd/str.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=78d4bf851cd2997ea6193ed686d8586e81b94a93", "patch": "@@ -101,6 +101,7 @@ use to_str::ToStr;\n use from_str::FromStr;\n use vec;\n use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n+use vec_ng::Vec;\n use default::Default;\n use to_bytes::{IterBytes, Cb};\n use unstable::raw::Repr;\n@@ -222,6 +223,18 @@ impl<'a, S: Str> StrVector for &'a [S] {\n     }\n }\n \n+impl<'a, S: Str> StrVector for Vec<S> {\n+    #[inline]\n+    fn concat(&self) -> ~str {\n+        self.as_slice().concat()\n+    }\n+\n+    #[inline]\n+    fn connect(&self, sep: &str) -> ~str {\n+        self.as_slice().connect(sep)\n+    }\n+}\n+\n /// Something that can be used to compare against a character\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character"}, {"sha": "5518fa11684add9cf5397c6c17f62d4463e6d4f0", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=78d4bf851cd2997ea6193ed686d8586e81b94a93", "patch": "@@ -21,6 +21,7 @@ use option::{None, Option, Some};\n use rc::Rc;\n use str::{Str, StrSlice};\n use vec::{Vector, ImmutableVector};\n+use vec_ng::Vec;\n \n pub type Cb<'a> = 'a |buf: &[u8]| -> bool;\n \n@@ -266,6 +267,13 @@ impl<A:IterBytes> IterBytes for ~[A] {\n     }\n }\n \n+impl<A:IterBytes> IterBytes for Vec<A> {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.as_slice().iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl<'a> IterBytes for &'a str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {"}, {"sha": "114f34963e2c7fdd969ef6ea8f89459b74c0f638", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 169, "deletions": 9, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78d4bf851cd2997ea6193ed686d8586e81b94a93/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=78d4bf851cd2997ea6193ed686d8586e81b94a93", "patch": "@@ -11,20 +11,21 @@\n // Migrate documentation over from `std::vec` when it is removed.\n #[doc(hidden)];\n \n-use ops::Drop;\n-use option::{None, Option, Some};\n+use cast::{forget, transmute};\n use clone::Clone;\n-use iter::{DoubleEndedIterator, Iterator};\n-use num::CheckedMul;\n+use cmp::{Eq, Ordering, TotalEq, TotalOrd};\n use container::Container;\n+use iter::{DoubleEndedIterator, FromIterator, Iterator};\n+use libc::{free, c_void};\n use mem::{size_of, move_val_init};\n-use cast::{forget, transmute};\n+use num::CheckedMul;\n+use ops::Drop;\n+use option::{None, Option, Some};\n+use ptr::RawPtr;\n+use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n-use vec::{ImmutableVector, Items, MutableVector};\n use unstable::raw::Slice;\n-use ptr;\n-use ptr::RawPtr;\n-use libc::{free, c_void};\n+use vec::{ImmutableVector, Items, MutItems, MutableVector, RevItems};\n \n pub struct Vec<T> {\n     priv len: uint,\n@@ -71,6 +72,55 @@ impl<T: Clone> Vec<T> {\n             xs\n         }\n     }\n+\n+    #[inline]\n+    pub fn push_all(&mut self, other: &[T]) {\n+        for element in other.iter() {\n+            self.push((*element).clone())\n+        }\n+    }\n+}\n+\n+impl<T:Clone> Clone for Vec<T> {\n+    fn clone(&self) -> Vec<T> {\n+        let mut vector = Vec::with_capacity(self.len());\n+        for element in self.iter() {\n+            vector.push((*element).clone())\n+        }\n+        vector\n+    }\n+}\n+\n+impl<T> FromIterator<T> for Vec<T> {\n+    fn from_iterator<I:Iterator<T>>(iterator: &mut I) -> Vec<T> {\n+        let (lower, _) = iterator.size_hint();\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in *iterator {\n+            vector.push(element)\n+        }\n+        vector\n+    }\n+}\n+\n+impl<T:Eq> Eq for Vec<T> {\n+    #[inline]\n+    fn eq(&self, other: &Vec<T>) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl<T:TotalEq> TotalEq for Vec<T> {\n+    #[inline]\n+    fn equals(&self, other: &Vec<T>) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<T:TotalOrd> TotalOrd for Vec<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n }\n \n impl<T> Container for Vec<T> {\n@@ -180,8 +230,117 @@ impl<T> Vec<T> {\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+        &self.as_slice()[index]\n+    }\n+\n+    #[inline]\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[index]\n+    }\n+\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+        self.as_slice().iter()\n+    }\n+\n+    #[inline]\n+    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> {\n+        self.as_mut_slice().mut_iter()\n+    }\n+\n+    #[inline]\n+    pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n+        self.as_mut_slice().sort_by(compare)\n+    }\n+\n+    #[inline]\n+    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        self.as_slice().slice(start, end)\n+    }\n+\n+    #[inline]\n+    pub fn tail<'a>(&'a self) -> &'a [T] {\n+        self.as_slice().tail()\n+    }\n+\n+    #[inline]\n+    pub fn last<'a>(&'a self) -> Option<&'a T> {\n+        self.as_slice().last()\n+    }\n+\n+    #[inline]\n+    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n+        self.as_mut_slice().mut_last()\n+    }\n+\n+    #[inline]\n+    pub fn swap_remove(&mut self, index: uint) -> T {\n+        let length = self.len();\n+        if index >= length {\n+            fail!(\"Vec::swap_remove - index {} >= length {}\", index, length);\n+        }\n+        if index < length - 1 {\n+            self.as_mut_slice().swap(index, length - 1);\n+        }\n+        self.pop().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn unshift(&mut self, element: T) {\n+        self.insert(0, element)\n+    }\n+\n+    pub fn insert(&mut self, index: uint, element: T) {\n+        let len = self.len();\n+        assert!(index <= len);\n+        // space for the new element\n+        self.reserve_exact(len + 1);\n+\n+        unsafe { // infallible\n+            // The spot to put the new value\n+            {\n+                let slice = self.as_mut_slice();\n+                let p = slice.as_mut_ptr().offset(index as int);\n+                // Shift everything over to make space. (Duplicating the\n+                // `index`th element into two consecutive places.)\n+                ptr::copy_memory(p.offset(1), &*p, len - index);\n+                // Write it in, overwriting the first copy of the `index`th\n+                // element.\n+                move_val_init(&mut *p, element);\n+            }\n+            self.set_len(len + 1);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn rev_iter<'a>(&'a self) -> RevItems<'a,T> {\n+        self.as_slice().rev_iter()\n+    }\n+\n+    #[inline]\n+    pub fn map<U>(&self, f: |t: &T| -> U) -> Vec<U> {\n+        self.iter().map(f).collect()\n+    }\n+\n+    pub fn push_all_move(&mut self, other: Vec<T>) {\n+        for element in other.move_iter() {\n+            self.push(element)\n+        }\n+    }\n+\n+    pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        self.as_slice().slice_from(start)\n+    }\n }\n \n+#[inline]\n+pub fn append<T:Clone>(mut first: Vec<T>, second: &[T]) -> Vec<T> {\n+    first.push_all(second);\n+    first\n+}\n \n #[unsafe_destructor]\n impl<T> Drop for Vec<T> {\n@@ -233,3 +392,4 @@ impl<T> Drop for MoveItems<T> {\n         }\n     }\n }\n+"}]}