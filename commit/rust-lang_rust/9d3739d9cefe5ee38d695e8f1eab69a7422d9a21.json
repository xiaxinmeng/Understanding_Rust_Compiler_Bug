{"sha": "9d3739d9cefe5ee38d695e8f1eab69a7422d9a21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMzczOWQ5Y2VmZTVlZTM4ZDY5NWU4ZjFlYWI2OWE3NDIyZDlhMjE=", "commit": {"author": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-02-18T19:27:37Z"}, "committer": {"name": "Wesley Wiser", "email": "wesleywiser@microsoft.com", "date": "2021-02-25T23:33:09Z"}, "message": "Set codegen thread names\n\nFor example, gdb:\n\n```\n(gdb) info threads\n  Id   Target Id                                          Frame\n  1    Thread 0x7fffefa7ec40 (LWP 2905) \"rustc\"           __pthread_clockjoin_ex (threadid=140737214134016, thread_return=0x0, clockid=<optimized out>, abstime=<optimized out>, block=<optimized out>)\n    at pthread_join_common.c:145\n  2    Thread 0x7fffefa7b700 (LWP 2957) \"rustc\"           0x00007ffff125eaa8 in llvm::X86_MC::initLLVMToSEHAndCVRegMapping(llvm::MCRegisterInfo*) ()\n   from /home/wesley/.rustup/toolchains/stage1/lib/librustc_driver-f866439e29074957.so\n  3    Thread 0x7fffeef0f700 (LWP 3116) \"rustc\"           futex_wait_cancelable (private=0, expected=0, futex_word=0x7fffe8602ac8) at ../sysdeps/nptl/futex-internal.h:183\n* 4    Thread 0x7fffeed0e700 (LWP 3123) \"rustc\"           rustc_codegen_ssa::back::write::spawn_work (cgcx=..., work=...) at /home/wesley/code/rust/rust/compiler/rustc_codegen_ssa/src/back/write.rs:1573\n  6    Thread 0x7fffe113b700 (LWP 3150) \"opt foof.7rcbfp\" 0x00007ffff2940e62 in llvm::CallGraph::populateCallGraphNode(llvm::CallGraphNode*) ()\n   from /home/wesley/.rustup/toolchains/stage1/lib/librustc_driver-f866439e29074957.so\n  8    Thread 0x7fffe0d39700 (LWP 3158) \"opt foof.7rcbfp\" 0x00007fffefe8998e in malloc_consolidate (av=av@entry=0x7ffe2c000020) at malloc.c:4492\n  9    Thread 0x7fffe0f3a700 (LWP 3162) \"opt foof.7rcbfp\" 0x00007fffefef27c4 in __libc_open64 (file=0x7fffe0f38608 \"foof.foof.7rcbfp3g-cgu.6.rcgu.o\", oflag=524865) at ../sysdeps/unix/sysv/linux/open64.c:48\n(gdb)\n```", "tree": {"sha": "597c67f08513bd286cb59ade4b77d3d8004453f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/597c67f08513bd286cb59ade4b77d3d8004453f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21", "html_url": "https://github.com/rust-lang/rust/commit/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c", "html_url": "https://github.com/rust-lang/rust/commit/0ab7c1d56f92ebc3c456a0c7c502ba1593e76f8c"}], "stats": {"total": 124, "additions": 77, "deletions": 47}, "files": [{"sha": "7b8ce157fc2b43d30c3c5f702274d7cb84e275b3", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 77, "deletions": 47, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3739d9cefe5ee38d695e8f1eab69a7422d9a21/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=9d3739d9cefe5ee38d695e8f1eab69a7422d9a21", "patch": "@@ -712,6 +712,33 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n             }\n         }\n     }\n+\n+    /// Generate a short description of this work item suitable for use as a thread name.\n+    fn short_description(&self) -> String {\n+        // `pthread_setname()` on *nix is limited to 15 characters and longer names are ignored.\n+        // Use very short descriptions in this case to maximize the space available for the module name.\n+        // Windows does not have that limitation so use slightly more descriptive names there.\n+        match self {\n+            WorkItem::Optimize(m) => {\n+                #[cfg(windows)]\n+                return format!(\"optimize module {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"opt {}\", m.name);\n+            }\n+            WorkItem::CopyPostLtoArtifacts(m) => {\n+                #[cfg(windows)]\n+                return format!(\"copy LTO artifacts for {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"copy {}\", m.name);\n+            }\n+            WorkItem::LTO(m) => {\n+                #[cfg(windows)]\n+                return format!(\"LTO module {}\", m.name());\n+                #[cfg(not(windows))]\n+                return format!(\"LTO {}\", m.name());\n+            }\n+        }\n+    }\n }\n \n enum WorkItemResult<B: WriteBackendMethods> {\n@@ -1609,56 +1636,59 @@ fn start_executing_work<B: ExtraBackendMethods>(\n pub struct WorkerFatalError;\n \n fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>) {\n-    thread::spawn(move || {\n-        // Set up a destructor which will fire off a message that we're done as\n-        // we exit.\n-        struct Bomb<B: ExtraBackendMethods> {\n-            coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<Result<WorkItemResult<B>, FatalError>>,\n-            worker_id: usize,\n-        }\n-        impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n-            fn drop(&mut self) {\n-                let worker_id = self.worker_id;\n-                let msg = match self.result.take() {\n-                    Some(Ok(WorkItemResult::Compiled(m))) => {\n-                        Message::Done::<B> { result: Ok(m), worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n-                        Message::NeedsLink::<B> { module: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n-                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n-                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n-                    }\n-                    Some(Err(FatalError)) => {\n-                        Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n-                    }\n-                    None => Message::Done::<B> { result: Err(None), worker_id },\n-                };\n-                drop(self.coordinator_send.send(Box::new(msg)));\n+    let builder = thread::Builder::new().name(work.short_description());\n+    builder\n+        .spawn(move || {\n+            // Set up a destructor which will fire off a message that we're done as\n+            // we exit.\n+            struct Bomb<B: ExtraBackendMethods> {\n+                coordinator_send: Sender<Box<dyn Any + Send>>,\n+                result: Option<Result<WorkItemResult<B>, FatalError>>,\n+                worker_id: usize,\n+            }\n+            impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n+                fn drop(&mut self) {\n+                    let worker_id = self.worker_id;\n+                    let msg = match self.result.take() {\n+                        Some(Ok(WorkItemResult::Compiled(m))) => {\n+                            Message::Done::<B> { result: Ok(m), worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                            Message::NeedsLink::<B> { module: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n+                            Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n+                            Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n+                        }\n+                        Some(Err(FatalError)) => {\n+                            Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n+                        }\n+                        None => Message::Done::<B> { result: Err(None), worker_id },\n+                    };\n+                    drop(self.coordinator_send.send(Box::new(msg)));\n+                }\n             }\n-        }\n \n-        let mut bomb = Bomb::<B> {\n-            coordinator_send: cgcx.coordinator_send.clone(),\n-            result: None,\n-            worker_id: cgcx.worker,\n-        };\n+            let mut bomb = Bomb::<B> {\n+                coordinator_send: cgcx.coordinator_send.clone(),\n+                result: None,\n+                worker_id: cgcx.worker,\n+            };\n \n-        // Execute the work itself, and if it finishes successfully then flag\n-        // ourselves as a success as well.\n-        //\n-        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n-        // as a diagnostic was already sent off to the main thread - just\n-        // surface that there was an error in this worker.\n-        bomb.result = {\n-            let _prof_timer = work.start_profiling(&cgcx);\n-            Some(execute_work_item(&cgcx, work))\n-        };\n-    });\n+            // Execute the work itself, and if it finishes successfully then flag\n+            // ourselves as a success as well.\n+            //\n+            // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n+            // as a diagnostic was already sent off to the main thread - just\n+            // surface that there was an error in this worker.\n+            bomb.result = {\n+                let _prof_timer = work.start_profiling(&cgcx);\n+                Some(execute_work_item(&cgcx, work))\n+            };\n+        })\n+        .expect(\"failed to spawn thread\");\n }\n \n enum SharedEmitterMessage {"}]}