{"sha": "bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOWVmNmNmNzJiYTdmOGY3MGRjYTE4ZDUwZTFhYjI0OTJlZmEzMWE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-15T12:40:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-15T12:40:01Z"}, "message": "Rollup merge of #79041 - jyn514:inner-to-kind, r=petrochenkov\n\nRename clean::{ItemEnum -> ItemKind}, clean::Item::{inner -> kind}\n\nr? ````@petrochenkov````\ncc ````@GuillaumeGomez````\n\nFollow-up to https://github.com/rust-lang/rust/pull/77820#discussion_r502931757.", "tree": {"sha": "e4993613f5cd8bcf9e1e92fab248fcaafcd68fab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4993613f5cd8bcf9e1e92fab248fcaafcd68fab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsSGiCRBK7hj4Ov3rIwAAdHIIAKwYe5GIWXe/3aX75D5ywt0l\n4iSoy7A1k+WIiH51dTfiXSQ/G2zICg7BF8PQzW5I3p3r83YsFeIriXw/G4S124qR\nXfX/VHXDh8fynbUCMrC/5myxuMqy7wiBdn9HTwYe8GksUOg5umwTLSITurQ2GbGT\nxpWrYkNVFWjJz6pToJUMORi/xPX1WMKwmcfWC+UbZW2dKGToyAuGOOn/IxX3XCbj\nADHG0gEGa1FlLmYSIW7d9rHblLW25yhF90ZrXeS9Q/VD/YU2vCFYW6TYooG+kPOR\nwYKiUzfSC4H1QX2udcIQfvSdahrBt18XYBZhHv0j7DK1I/ejZBehHopp80JnYIU=\n=wX4u\n-----END PGP SIGNATURE-----\n", "payload": "tree e4993613f5cd8bcf9e1e92fab248fcaafcd68fab\nparent ce775bc4f68149461aed1789987a0ab90caf8cd7\nparent 03cbee84afebef7b4bb6e3e76161ca715c7367fd\nauthor Jonas Schievink <jonasschievink@gmail.com> 1605444001 +0100\ncommitter GitHub <noreply@github.com> 1605444001 +0100\n\nRollup merge of #79041 - jyn514:inner-to-kind, r=petrochenkov\n\nRename clean::{ItemEnum -> ItemKind}, clean::Item::{inner -> kind}\n\nr? ````@petrochenkov````\ncc ````@GuillaumeGomez````\n\nFollow-up to https://github.com/rust-lang/rust/pull/77820#discussion_r502931757.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "html_url": "https://github.com/rust-lang/rust/commit/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce775bc4f68149461aed1789987a0ab90caf8cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce775bc4f68149461aed1789987a0ab90caf8cd7", "html_url": "https://github.com/rust-lang/rust/commit/ce775bc4f68149461aed1789987a0ab90caf8cd7"}, {"sha": "03cbee84afebef7b4bb6e3e76161ca715c7367fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/03cbee84afebef7b4bb6e3e76161ca715c7367fd", "html_url": "https://github.com/rust-lang/rust/commit/03cbee84afebef7b4bb6e3e76161ca715c7367fd"}], "stats": {"total": 260, "additions": 129, "deletions": 131}, "files": [{"sha": "a07d6b73f06c1a434ff441312fc93ffa0bea944a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     def_id: self.cx.next_def_id(param_env_def_id.krate),\n                     stability: None,\n                     deprecation: None,\n-                    inner: ImplItem(Impl {\n+                    kind: ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: new_generics,\n                         provided_trait_methods: Default::default(),"}, {"sha": "f15142f4983d62d8abeea01d87ec830e28c7d379", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     def_id: self.cx.next_def_id(impl_def_id.krate),\n                     stability: None,\n                     deprecation: None,\n-                    inner: ImplItem(Impl {\n+                    kind: ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),"}, {"sha": "d6f8870c859f5388cd234b6bcf1cc7bf4e03fb93", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -54,7 +54,7 @@ crate fn try_inline(\n     debug!(\"attrs={:?}\", attrs);\n     let attrs_clone = attrs;\n \n-    let inner = match res {\n+    let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n             ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n@@ -128,7 +128,7 @@ crate fn try_inline(\n         source: cx.tcx.def_span(did).clean(cx),\n         name: Some(name.clean(cx)),\n         attrs,\n-        inner,\n+        kind,\n         visibility: clean::Public,\n         stability: cx.tcx.lookup_stability(did).cloned(),\n         deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n@@ -446,7 +446,7 @@ crate fn build_impl(\n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n     ret.push(clean::Item {\n-        inner: clean::ImplItem(clean::Impl {\n+        kind: clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             provided_trait_methods: provided,\n@@ -498,7 +498,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                         visibility: clean::Public,\n                         stability: None,\n                         deprecation: None,\n-                        inner: clean::ImportItem(clean::Import::new_simple(\n+                        kind: clean::ImportItem(clean::Import::new_simple(\n                             item.ident.to_string(),\n                             clean::ImportSource {\n                                 path: clean::Path {\n@@ -555,7 +555,7 @@ fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static\n     }\n }\n \n-fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemKind {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {"}, {"sha": "56ce0bae8bb7b969d956455763b32a1760462311", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -42,7 +42,7 @@ use utils::*;\n pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n pub use self::types::FnRetTy::*;\n-pub use self::types::ItemEnum::*;\n+pub use self::types::ItemKind::*;\n pub use self::types::SelfTy::*;\n pub use self::types::Type::*;\n pub use self::types::Visibility::{Inherited, Public};\n@@ -276,7 +276,7 @@ impl Clean<Item> for doctree::Module<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: ModuleItem(Module { is_crate: self.is_crate, items }),\n+            kind: ModuleItem(Module { is_crate: self.is_crate, items }),\n         }\n     }\n }\n@@ -916,7 +916,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: did.to_def_id(),\n-            inner: FunctionItem(Function {\n+            kind: FunctionItem(Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n@@ -1023,7 +1023,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TraitItem(Trait {\n+            kind: TraitItem(Trait {\n                 auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n@@ -1047,7 +1047,7 @@ impl Clean<Item> for doctree::TraitAlias<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TraitAliasItem(TraitAlias {\n+            kind: TraitAliasItem(TraitAlias {\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n             }),\n@@ -1102,7 +1102,7 @@ impl Clean<TypeKind> for hir::def::DefKind {\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n@@ -1140,15 +1140,15 @@ impl Clean<Item> for hir::TraitItem<'_> {\n             visibility: Visibility::Inherited,\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            inner,\n+            kind,\n         }\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n@@ -1175,14 +1175,14 @@ impl Clean<Item> for hir::ImplItem<'_> {\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            inner,\n+            kind,\n         }\n     }\n }\n \n impl Clean<Item> for ty::AssocItem {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             ty::AssocKind::Const => {\n                 let ty = cx.tcx.type_of(self.def_id);\n                 let default = if self.defaultness.has_value() {\n@@ -1343,7 +1343,7 @@ impl Clean<Item> for ty::AssocItem {\n             def_id: self.def_id,\n             attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n-            inner,\n+            kind,\n         }\n     }\n }\n@@ -1784,7 +1784,7 @@ impl Clean<Item> for hir::StructField<'_> {\n             stability: get_stability(cx, local_did.to_def_id()),\n             deprecation: get_deprecation(cx, local_did.to_def_id()),\n             def_id: local_did.to_def_id(),\n-            inner: StructFieldItem(self.ty.clean(cx)),\n+            kind: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n }\n@@ -1799,7 +1799,7 @@ impl Clean<Item> for ty::FieldDef {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n+            kind: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n         }\n     }\n }\n@@ -1835,7 +1835,7 @@ impl Clean<Item> for doctree::Struct<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: StructItem(Struct {\n+            kind: StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n@@ -1855,7 +1855,7 @@ impl Clean<Item> for doctree::Union<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: UnionItem(Union {\n+            kind: UnionItem(Union {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n@@ -1885,7 +1885,7 @@ impl Clean<Item> for doctree::Enum<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: EnumItem(Enum {\n+            kind: EnumItem(Enum {\n                 variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n@@ -1904,7 +1904,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: VariantItem(Variant { kind: self.def.clean(cx) }),\n+            kind: VariantItem(Variant { kind: self.def.clean(cx) }),\n         }\n     }\n }\n@@ -1930,7 +1930,7 @@ impl Clean<Item> for ty::VariantDef {\n                         def_id: field.did,\n                         stability: get_stability(cx, field.did),\n                         deprecation: get_deprecation(cx, field.did),\n-                        inner: StructFieldItem(cx.tcx.type_of(field.did).clean(cx)),\n+                        kind: StructFieldItem(cx.tcx.type_of(field.did).clean(cx)),\n                     })\n                     .collect(),\n             }),\n@@ -1941,7 +1941,7 @@ impl Clean<Item> for ty::VariantDef {\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n             visibility: Inherited,\n             def_id: self.def_id,\n-            inner: VariantItem(Variant { kind }),\n+            kind: VariantItem(Variant { kind }),\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n         }\n@@ -2057,7 +2057,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n+            kind: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n     }\n }\n@@ -2072,7 +2072,7 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: OpaqueTyItem(OpaqueTy {\n+            kind: OpaqueTyItem(OpaqueTy {\n                 bounds: self.opaque_ty.bounds.clean(cx),\n                 generics: self.opaque_ty.generics.clean(cx),\n             }),\n@@ -2100,7 +2100,7 @@ impl Clean<Item> for doctree::Static<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: StaticItem(Static {\n+            kind: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability,\n                 expr: print_const_expr(cx, self.expr),\n@@ -2121,7 +2121,7 @@ impl Clean<Item> for doctree::Constant<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: ConstantItem(Constant {\n+            kind: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n                 value: print_evaluated_const(cx, def_id.to_def_id()),\n@@ -2175,7 +2175,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: ImplItem(Impl {\n+            kind: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n                 provided_trait_methods: provided.clone(),\n@@ -2231,7 +2231,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n-            inner: ExternCrateItem(self.name.clean(cx), self.path.clone()),\n+            kind: ExternCrateItem(self.name.clean(cx), self.path.clone()),\n         }]\n     }\n }\n@@ -2302,7 +2302,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n                         visibility: self.vis.clean(cx),\n                         stability: None,\n                         deprecation: None,\n-                        inner: ImportItem(Import::new_simple(\n+                        kind: ImportItem(Import::new_simple(\n                             self.name.clean(cx),\n                             resolve_use_source(cx, path),\n                             false,\n@@ -2322,14 +2322,14 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n-            inner: ImportItem(inner),\n+            kind: ImportItem(inner),\n         }]\n     }\n }\n \n impl Clean<Item> for doctree::ForeignItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.kind {\n+        let kind = match self.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let abi = cx.tcx.hir().get_foreign_abi(self.id);\n                 let (generics, decl) =\n@@ -2364,7 +2364,7 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner,\n+            kind,\n         }\n     }\n }\n@@ -2380,7 +2380,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n             stability: cx.stability(self.hid),\n             deprecation: cx.deprecation(self.hid).clean(cx),\n             def_id: self.def_id,\n-            inner: MacroItem(Macro {\n+            kind: MacroItem(Macro {\n                 source: format!(\n                     \"macro_rules! {} {{\\n{}}}\",\n                     name,\n@@ -2405,7 +2405,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            inner: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n+            kind: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n         }\n     }\n }"}, {"sha": "3060cf79cd57ac19ad11a8e21e64fc2d276ca07c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -41,7 +41,7 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n \n use self::FnRetTy::*;\n-use self::ItemEnum::*;\n+use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n@@ -81,7 +81,7 @@ pub struct Item {\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n     pub attrs: Attributes,\n-    pub inner: ItemEnum,\n+    pub kind: ItemKind,\n     pub visibility: Visibility,\n     pub def_id: DefId,\n     pub stability: Option<Stability>,\n@@ -90,14 +90,13 @@ pub struct Item {\n \n impl fmt::Debug for Item {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let fake = self.is_fake();\n-        let def_id: &dyn fmt::Debug = if fake { &\"**FAKE**\" } else { &self.def_id };\n+        let def_id: &dyn fmt::Debug = if self.is_fake() { &\"**FAKE**\" } else { &self.def_id };\n \n         fmt.debug_struct(\"Item\")\n             .field(\"source\", &self.source)\n             .field(\"name\", &self.name)\n             .field(\"attrs\", &self.attrs)\n-            .field(\"inner\", &self.inner)\n+            .field(\"kind\", &self.kind)\n             .field(\"visibility\", &self.visibility)\n             .field(\"def_id\", def_id)\n             .field(\"stability\", &self.stability)\n@@ -124,7 +123,7 @@ impl Item {\n     }\n \n     pub fn is_crate(&self) -> bool {\n-        match self.inner {\n+        match self.kind {\n             StrippedItem(box ModuleItem(Module { is_crate: true, .. }))\n             | ModuleItem(Module { is_crate: true, .. }) => true,\n             _ => false,\n@@ -176,14 +175,14 @@ impl Item {\n         self.type_() == ItemType::Keyword\n     }\n     pub fn is_stripped(&self) -> bool {\n-        match self.inner {\n+        match self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n     pub fn has_stripped_fields(&self) -> Option<bool> {\n-        match self.inner {\n+        match self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n             VariantItem(Variant { kind: VariantKind::Struct(ref vstruct) }) => {\n@@ -227,8 +226,8 @@ impl Item {\n     }\n \n     pub fn is_default(&self) -> bool {\n-        match self.inner {\n-            ItemEnum::MethodItem(ref meth) => {\n+        match self.kind {\n+            ItemKind::MethodItem(ref meth) => {\n                 if let Some(defaultness) = meth.defaultness {\n                     defaultness.has_value() && !defaultness.is_final()\n                 } else {\n@@ -248,7 +247,7 @@ impl Item {\n }\n \n #[derive(Clone, Debug)]\n-pub enum ItemEnum {\n+pub enum ItemKind {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n     StructItem(Struct),\n@@ -282,23 +281,23 @@ pub enum ItemEnum {\n     AssocConstItem(Type, Option<String>),\n     AssocTypeItem(Vec<GenericBound>, Option<Type>),\n     /// An item that has been stripped by a rustdoc pass\n-    StrippedItem(Box<ItemEnum>),\n+    StrippedItem(Box<ItemKind>),\n     KeywordItem(String),\n }\n \n-impl ItemEnum {\n+impl ItemKind {\n     pub fn is_type_alias(&self) -> bool {\n         match *self {\n-            ItemEnum::TypedefItem(_, _) | ItemEnum::AssocTypeItem(_, _) => true,\n+            ItemKind::TypedefItem(_, _) | ItemKind::AssocTypeItem(_, _) => true,\n             _ => false,\n         }\n     }\n \n     pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n         match *self {\n-            ItemEnum::AssocConstItem(..) => Some(AssocKind::Const),\n-            ItemEnum::AssocTypeItem(..) => Some(AssocKind::Type),\n-            ItemEnum::TyMethodItem(..) | ItemEnum::MethodItem(..) => Some(AssocKind::Fn),\n+            ItemKind::AssocConstItem(..) => Some(AssocKind::Const),\n+            ItemKind::AssocTypeItem(..) => Some(AssocKind::Type),\n+            ItemKind::TyMethodItem(..) | ItemKind::MethodItem(..) => Some(AssocKind::Fn),\n             _ => None,\n         }\n     }"}, {"sha": "e5fb656cbb9167087194ecd9977b590299dd8c3b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -2,7 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Deprecation, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg,\n-    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, Lifetime,\n+    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemKind, Lifetime,\n     MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Type, TypeBinding,\n     TypeKind, Visibility, WherePredicate,\n };\n@@ -44,8 +44,8 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     let mut module = module.clean(cx);\n     let mut masked_crates = FxHashSet::default();\n \n-    match module.inner {\n-        ItemEnum::ModuleItem(ref module) => {\n+    match module.kind {\n+        ItemKind::ModuleItem(ref module) => {\n             for it in &module.items {\n                 // `compiler_builtins` should be masked too, but we can't apply\n                 // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n@@ -62,8 +62,8 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n \n     let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n     {\n-        let m = match module.inner {\n-            ItemEnum::ModuleItem(ref mut m) => m,\n+        let m = match module.kind {\n+            ItemKind::ModuleItem(ref mut m) => m,\n             _ => unreachable!(),\n         };\n         m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| Item {\n@@ -74,7 +74,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n             stability: get_stability(cx, def_id),\n             deprecation: get_deprecation(cx, def_id),\n             def_id,\n-            inner: ItemEnum::PrimitiveItem(prim),\n+            kind: ItemKind::PrimitiveItem(prim),\n         }));\n         m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| Item {\n             source: Span::empty(),\n@@ -84,7 +84,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n             stability: get_stability(cx, def_id),\n             deprecation: get_deprecation(cx, def_id),\n             def_id,\n-            inner: ItemEnum::KeywordItem(kw),\n+            kind: ItemKind::KeywordItem(kw),\n         }));\n     }\n \n@@ -355,8 +355,8 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n     let tcx = cx.tcx;\n \n     for item in items {\n-        let target = match item.inner {\n-            ItemEnum::TypedefItem(ref t, true) => &t.type_,\n+        let target = match item.kind {\n+            ItemKind::TypedefItem(ref t, true) => &t.type_,\n             _ => continue,\n         };\n         let primitive = match *target {"}, {"sha": "694051aa54f4d416bd0504d38257d5b24110f209", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -5,9 +5,9 @@ pub struct StripItem(pub Item);\n impl StripItem {\n     pub fn strip(self) -> Option<Item> {\n         match self.0 {\n-            Item { inner: StrippedItem(..), .. } => Some(self.0),\n+            Item { kind: StrippedItem(..), .. } => Some(self.0),\n             mut i => {\n-                i.inner = StrippedItem(box i.inner);\n+                i.kind = StrippedItem(box i.kind);\n                 Some(i)\n             }\n         }\n@@ -20,8 +20,8 @@ pub trait DocFolder: Sized {\n     }\n \n     /// don't override!\n-    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n-        match inner {\n+    fn fold_inner_recur(&mut self, kind: ItemKind) -> ItemKind {\n+        match kind {\n             StrippedItem(..) => unreachable!(),\n             ModuleItem(i) => ModuleItem(self.fold_mod(i)),\n             StructItem(mut i) => {\n@@ -72,14 +72,14 @@ pub trait DocFolder: Sized {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+        let Item { attrs, name, source, visibility, def_id, kind, stability, deprecation } = item;\n \n-        let inner = match inner {\n+        let kind = match kind {\n             StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n-            _ => self.fold_inner_recur(inner),\n+            _ => self.fold_inner_recur(kind),\n         };\n \n-        Some(Item { attrs, name, source, inner, visibility, stability, deprecation, def_id })\n+        Some(Item { attrs, name, source, kind, visibility, stability, deprecation, def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "277571b11f51b0de385beb0d4706207a9079d255", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -218,7 +218,7 @@ impl DocFolder for Cache {\n \n         // If this is a stripped module,\n         // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n+        let orig_stripped_mod = match item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n                 mem::replace(&mut self.stripped_mod, true)\n             }\n@@ -227,7 +227,7 @@ impl DocFolder for Cache {\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n+        if let clean::ImplItem(ref i) = item.kind {\n             if self.masked_crates.contains(&item.def_id.krate)\n                 || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n                 || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n@@ -238,12 +238,12 @@ impl DocFolder for Cache {\n \n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n+        if let clean::TraitItem(ref t) = item.kind {\n             self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n+        if let clean::ImplItem(ref i) = item.kind {\n             if let Some(did) = i.trait_.def_id() {\n                 if i.blanket_impl.is_none() {\n                     self.implementors\n@@ -256,7 +256,7 @@ impl DocFolder for Cache {\n \n         // Index this method for searching later on.\n         if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n+            let (parent, is_inherent_impl_item) = match item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n                     if self.parent_is_trait_impl =>\n@@ -345,7 +345,7 @@ impl DocFolder for Cache {\n             _ => false,\n         };\n \n-        match item.inner {\n+        match item.kind {\n             clean::StructItem(..)\n             | clean::EnumItem(..)\n             | clean::TypedefItem(..)\n@@ -384,7 +384,7 @@ impl DocFolder for Cache {\n \n         // Maintain the parent stack\n         let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n+        let parent_pushed = match item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n@@ -422,12 +422,12 @@ impl DocFolder for Cache {\n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n         let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+            if let clean::Item { kind: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n                 // Note: matching twice to restrict the lifetime of the `i` borrow.\n                 let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                if let clean::Item { kind: clean::ImplItem(ref i), .. } = item {\n                     match i.for_ {\n                         clean::ResolvedPath { did, .. }\n                         | clean::BorrowedRef {"}, {"sha": "a0f4502f750f1968389c51fac41f0b20881e0cc1", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -60,12 +60,12 @@ impl Serialize for ItemType {\n \n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n-        let inner = match item.inner {\n+        let kind = match item.kind {\n             clean::StrippedItem(box ref item) => item,\n-            ref inner => inner,\n+            ref kind => kind,\n         };\n \n-        match *inner {\n+        match *kind {\n             clean::ModuleItem(..) => ItemType::Module,\n             clean::ExternCrateItem(..) => ItemType::ExternCrate,\n             clean::ImportItem(..) => ItemType::Import,"}, {"sha": "b893d6c64ec9446b95db8aaa9675e77710a4bacd", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -32,7 +32,7 @@ pub struct Impl {\n \n impl Impl {\n     pub fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.inner {\n+        match self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }"}, {"sha": "273e281925742a43fa6cbc5d30d01f1773de867f", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -86,7 +86,7 @@ pub fn run_format<T: FormatRenderer>(\n             }\n \n             cx.mod_item_in(&item, &name, &cache)?;\n-            let module = match item.inner {\n+            let module = match item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n                 _ => unreachable!(),\n             };"}, {"sha": "0541bf118e14f2876c1a608c3333720c9d60a88d", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -165,7 +165,7 @@ pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n }\n \n crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.inner {\n+    let (all_types, ret_types) = match item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n         clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "eebb07f0476c083fa1f73e083ea08b94fce84979", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -618,7 +618,7 @@ impl FormatRenderer for Context {\n \n         // Render sidebar-items.js used throughout this module.\n         if !self.render_redirect_pages {\n-            let module = match item.inner {\n+            let module = match item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n                 _ => unreachable!(),\n             };\n@@ -1717,7 +1717,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     write!(buf, \"</span>\"); // out-of-band\n     write!(buf, \"<span class=\\\"in-band\\\">\");\n-    let name = match item.inner {\n+    let name = match item.kind {\n         clean::ModuleItem(ref m) => {\n             if m.is_crate {\n                 \"Crate \"\n@@ -1766,7 +1766,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     write!(buf, \"</span></h1>\"); // in-band\n \n-    match item.inner {\n+    match item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n@@ -2133,7 +2133,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n             );\n         }\n \n-        match myitem.inner {\n+        match myitem.kind {\n             clean::ExternCrateItem(ref name, ref src) => {\n                 use crate::html::format::anchor;\n \n@@ -2169,7 +2169,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                     continue;\n                 }\n \n-                let unsafety_flag = match myitem.inner {\n+                let unsafety_flag = match myitem.kind {\n                     clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n                         if func.header.unsafety == hir::Unsafety::Unsafe =>\n                     {\n@@ -2582,7 +2582,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             }\n             for (pos, m) in provided.iter().enumerate() {\n                 render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n-                match m.inner {\n+                match m.kind {\n                     clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n                         write!(w, \",\\n    {{ ... }}\\n\");\n                     }\n@@ -2958,7 +2958,7 @@ fn render_assoc_item(\n             where_clause = WhereClause { gens: g, indent, end_newline }\n         )\n     }\n-    match item.inner {\n+    match item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n         clean::MethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n@@ -2994,7 +2994,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.inner {\n+        .filter_map(|f| match f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3044,7 +3044,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union,\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.inner {\n+        .filter_map(|f| match f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3097,7 +3097,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n             for v in &e.variants {\n                 write!(w, \"    \");\n                 let name = v.name.as_ref().unwrap();\n-                match v.inner {\n+                match v.kind {\n                     clean::VariantItem(ref var) => match var.kind {\n                         clean::VariantKind::CLike => write!(w, \"{}\", name),\n                         clean::VariantKind::Tuple(ref tys) => {\n@@ -3147,7 +3147,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                 id = id,\n                 name = variant.name.as_ref().unwrap()\n             );\n-            if let clean::VariantItem(ref var) = variant.inner {\n+            if let clean::VariantItem(ref var) = variant.kind {\n                 if let clean::VariantKind::Tuple(ref tys) = var.kind {\n                     write!(w, \"(\");\n                     for (i, ty) in tys.iter().enumerate() {\n@@ -3164,8 +3164,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n             document_non_exhaustive(w, variant);\n \n             use crate::clean::{Variant, VariantKind};\n-            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = variant.inner\n-            {\n+            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = variant.kind {\n                 let variant_id = cx.derive_id(format!(\n                     \"{}.{}.fields\",\n                     ItemType::Variant,\n@@ -3179,7 +3178,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, ca\n                 );\n                 for field in &s.fields {\n                     use crate::clean::StructFieldItem;\n-                    if let StructFieldItem(ref ty) = field.inner {\n+                    if let StructFieldItem(ref ty) = field.kind {\n                         let id = cx.derive_id(format!(\n                             \"variant.{}.field.{}\",\n                             variant.name.as_ref().unwrap(),\n@@ -3275,7 +3274,7 @@ fn render_struct(\n             let mut has_visible_fields = false;\n             write!(w, \" {{\");\n             for field in fields {\n-                if let clean::StructFieldItem(ref ty) = field.inner {\n+                if let clean::StructFieldItem(ref ty) = field.kind {\n                     write!(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n@@ -3306,7 +3305,7 @@ fn render_struct(\n                 if i > 0 {\n                     write!(w, \", \");\n                 }\n-                match field.inner {\n+                match field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n@@ -3352,7 +3351,7 @@ fn render_union(\n \n     write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n-        if let clean::StructFieldItem(ref ty) = field.inner {\n+        if let clean::StructFieldItem(ref ty) = field.kind {\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n@@ -3516,7 +3515,7 @@ fn render_deref_methods(\n         .inner_impl()\n         .items\n         .iter()\n-        .find_map(|item| match item.inner {\n+        .find_map(|item| match item.kind {\n             clean::TypedefItem(ref t, true) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n@@ -3538,7 +3537,7 @@ fn render_deref_methods(\n }\n \n fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n-    let self_type_opt = match item.inner {\n+    let self_type_opt = match item.kind {\n         clean::MethodItem(ref method) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n         _ => None,\n@@ -3589,7 +3588,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                     ));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = it.inner {\n+                        if let clean::TypedefItem(ref tydef, _) = it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                             assoc_type(\n                                 &mut out,\n@@ -3657,7 +3656,7 @@ fn render_impl(\n             fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n-                    if let clean::TypedefItem(ref tydef, _) = it.inner {\n+                    if let clean::TypedefItem(ref tydef, _) = it.kind {\n                         write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n                         assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\");\n                         write!(w, \";</span>\");\n@@ -3728,14 +3727,14 @@ fn render_impl(\n         };\n \n         let (is_hidden, extra_class) =\n-            if (trait_.is_none() || item.doc_value().is_some() || item.inner.is_type_alias())\n+            if (trait_.is_none() || item.doc_value().is_some() || item.kind.is_type_alias())\n                 && !is_default_item\n             {\n                 (false, \"\")\n             } else {\n                 (true, \" hidden\")\n             };\n-        match item.inner {\n+        match item.kind {\n             clean::MethodItem(clean::Method { .. })\n             | clean::TyMethodItem(clean::TyMethod { .. }) => {\n                 // Only render when the method is not static or we allow static methods\n@@ -4000,7 +3999,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Ca\n         write!(\n             buffer,\n             \"<p class=\\\"location\\\">{}{}</p>\",\n-            match it.inner {\n+            match it.kind {\n                 clean::StructItem(..) => \"Struct \",\n                 clean::TraitItem(..) => \"Trait \",\n                 clean::PrimitiveItem(..) => \"Primitive Type \",\n@@ -4040,7 +4039,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Ca\n             it.name.as_ref().expect(\"crates always have a name\")\n         );\n     }\n-    match it.inner {\n+    match it.kind {\n         clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n         clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n         clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n@@ -4180,7 +4179,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n                 if let Some((target, real_target)) =\n-                    impl_.inner_impl().items.iter().find_map(|item| match item.inner {\n+                    impl_.inner_impl().items.iter().find_map(|item| match item.kind {\n                         clean::TypedefItem(ref t, true) => Some(match *t {\n                             clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                             _ => (&t.type_, &t.type_),\n@@ -4319,8 +4318,8 @@ fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) ->\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n-    match item.inner {\n-        clean::ItemEnum::ImplItem(ref i) => {\n+    match item.kind {\n+        clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n                 Some((\n                     format!(\"{:#}\", i.for_.print()),\n@@ -4470,7 +4469,7 @@ fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n     let mut fields = fields\n         .iter()\n-        .filter(|f| if let clean::StructFieldItem(..) = f.inner { true } else { false })\n+        .filter(|f| if let clean::StructFieldItem(..) = f.kind { true } else { false })\n         .filter_map(|f| match f.name {\n             Some(ref name) => {\n                 Some(format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))"}, {"sha": "ef68bae10782db3632dc7f191fd5b9d55979a657", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n \n impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n     fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n-        match i.inner {\n+        match i.kind {\n             _ if !i.def_id.is_local() => {\n                 // non-local items are skipped because they can be out of the users control,\n                 // especially in the case of trait impls, which rustdoc eagerly inlines"}, {"sha": "fd0dd339abdc22be4fef80cdb5104cef4c776e89", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -671,7 +671,7 @@ fn resolve_associated_trait_item(\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n     let mut candidates: Vec<_> = implicit_impls\n         .flat_map(|impl_outer| {\n-            match impl_outer.inner {\n+            match impl_outer.kind {\n                 clean::ImplItem(impl_) => {\n                     debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n                     // Give precedence to methods that were overridden\n@@ -681,14 +681,14 @@ fn resolve_associated_trait_item(\n                                 return None;\n                             }\n                             let kind = assoc\n-                                .inner\n+                                .kind\n                                 .as_assoc_kind()\n                                 .expect(\"inner items for a trait should be associated items\");\n                             if kind.namespace() != ns {\n                                 return None;\n                             }\n \n-                            trace!(\"considering associated item {:?}\", assoc.inner);\n+                            trace!(\"considering associated item {:?}\", assoc.kind);\n                             // We have a slight issue: normal methods come from `clean` types,\n                             // but provided methods come directly from `tcx`.\n                             // Fortunately, we don't need the whole method, we just need to know\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        let current_item = match item.inner {\n+        let current_item = match item.kind {\n             clean::ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n                     if item.def_id.is_top_level_module() { item.name.clone() } else { None }"}, {"sha": "81de07302478b0dce045e5d266be9c04d60ed489", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -55,11 +55,11 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.inner {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.kind {\n             if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n                 let target = items\n                     .iter()\n-                    .find_map(|item| match item.inner {\n+                    .find_map(|item| match item.kind {\n                         TypedefItem(ref t, true) => Some(&t.type_),\n                         _ => None,\n                     })\n@@ -75,7 +75,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.inner {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.kind {\n             cleaner.keep_item(for_)\n                 || trait_.as_ref().map_or(false, |t| cleaner.keep_item(t))\n                 || blanket_impl.is_some()\n@@ -96,7 +96,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     if let Some(ref mut it) = krate.module {\n-        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n+        if let ModuleItem(Module { ref mut items, .. }) = it.kind {\n             items.extend(synth.impls);\n             items.extend(new_items);\n         } else {"}, {"sha": "094f85f2ccb06630bc7d2cdbf6c16fe90f858403", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -58,7 +58,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if matches!(item.inner,\n+    if matches!(item.kind,\n         clean::StructFieldItem(_)\n         | clean::VariantItem(_)\n         | clean::AssocConstItem(_, _)"}, {"sha": "4b9e150eb1e30b43f4a451c485500cc2524d6578", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -41,7 +41,7 @@ impl<'a> DocFolder for Stripper<'a> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n-            match i.inner {\n+            match i.kind {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n                     // We need to recurse into stripped modules to\n                     // strip things like impl methods but when doing so"}, {"sha": "4250c2b48fc5017c7c88d39a857688d1da0abecb", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=bc9ef6cf72ba7f8f70dca18d50e1ab2492efa31a", "patch": "@@ -13,7 +13,7 @@ pub struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n+        match i.kind {\n             clean::StrippedItem(..) => {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n@@ -86,7 +86,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             clean::KeywordItem(..) => {}\n         }\n \n-        let fastreturn = match i.inner {\n+        let fastreturn = match i.kind {\n             // nothing left to do for traits (don't want to filter their\n             // methods out, visibility controlled by the trait)\n             clean::TraitItem(..) => true,\n@@ -123,7 +123,7 @@ pub struct ImplStripper<'a> {\n \n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n+        if let clean::ImplItem(ref imp) = i.kind {\n             // emptied none trait impls can be stripped\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n@@ -162,7 +162,7 @@ pub struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n+        match i.kind {\n             clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n                 None\n             }"}]}