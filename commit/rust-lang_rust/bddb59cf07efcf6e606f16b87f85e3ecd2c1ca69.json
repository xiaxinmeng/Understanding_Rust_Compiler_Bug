{"sha": "bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZGI1OWNmMDdlZmNmNmU2MDZmMTZiODdmODVlM2VjZDJjMWNhNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T17:17:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-24T17:17:39Z"}, "message": "Auto merge of #87434 - Manishearth:rollup-b09njin, r=Manishearth\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #87348 (Fix span when suggesting to add an associated type bound)\n - #87359 (Remove detection of rustup and cargo in 'missing extern crate' diagnostics)\n - #87370 (Add support for powerpc-unknown-freebsd)\n - #87389 (Rename `known_attrs` to `expanded_inert_attrs` and move to rustc_expand)\n - #87395 (Clear up std::env::set_var panic section.)\n - #87403 (Implement `AssignToDroppingUnionField` in THIR unsafeck)\n - #87410 (Mark `format_args_nl` as `#[doc(hidden)]`)\n - #87419 (IEEE 754 is not an RFC)\n - #87422 (DOC: remove unnecessary feature crate attribute from example code)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "cc383acd5cf79e1b84b757bad894ebeb979246a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc383acd5cf79e1b84b757bad894ebeb979246a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "html_url": "https://github.com/rust-lang/rust/commit/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f", "html_url": "https://github.com/rust-lang/rust/commit/18840b0719aa766a1bc49ea2eb5dc2e4cde7da3f"}, {"sha": "acfa3ac4052dfe127eee3fe8d352a48918bc2d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/acfa3ac4052dfe127eee3fe8d352a48918bc2d9d", "html_url": "https://github.com/rust-lang/rust/commit/acfa3ac4052dfe127eee3fe8d352a48918bc2d9d"}], "stats": {"total": 555, "additions": 493, "deletions": 62}, "files": [{"sha": "6eb70dee3952f526b03482cf48b284e252817891", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -44,7 +44,7 @@ Libraries\n - [`leading_zeros`, and `trailing_zeros` are now available on all\n   `NonZero` integer types.][84082]\n - [`{f32, f64}::from_str` now parse and print special values\n-  (`NaN`, `-0`) according to IEEE RFC 754.][78618]\n+  (`NaN`, `-0`) according to IEEE 754.][78618]\n - [You can now index into slices using `(Bound<usize>, Bound<usize>)`.][77704]\n - [Add the `BITS` associated constant to all numeric types.][82565]\n "}, {"sha": "3d5bc770c4fb0e6965f613f4772d502850438f79", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1,6 +1,7 @@\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n+use rustc_ast::attr::MarkedAttrs;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n@@ -951,6 +952,10 @@ pub struct ExtCtxt<'a> {\n     ///\n     /// `Ident` is the module name.\n     pub(super) extern_mod_loaded: OnExternModLoaded<'a>,\n+    /// When we 'expand' an inert attribute, we leave it\n+    /// in the AST, but insert it here so that we know\n+    /// not to expand it again.\n+    pub(super) expanded_inert_attrs: MarkedAttrs,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -977,6 +982,7 @@ impl<'a> ExtCtxt<'a> {\n             },\n             force_mode: false,\n             expansions: FxHashMap::default(),\n+            expanded_inert_attrs: MarkedAttrs::new(),\n         }\n     }\n "}, {"sha": "c72b1b33dbc85996583df71bb4efcb95bf06ab92", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -754,7 +754,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n                 }\n                 SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n-                    self.cx.sess.mark_attr_known(&attr);\n+                    self.cx.expanded_inert_attrs.mark(&attr);\n                     if *mark_used {\n                         self.cx.sess.mark_attr_used(&attr);\n                     }\n@@ -1040,7 +1040,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         item.visit_attrs(|attrs| {\n             attr = attrs\n                 .iter()\n-                .position(|a| !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a))\n+                .position(|a| !self.cx.expanded_inert_attrs.is_marked(a) && !is_builtin_attr(a))\n                 .map(|attr_pos| {\n                     let attr = attrs.remove(attr_pos);\n                     let following_derives = attrs[attr_pos..]"}, {"sha": "4936b22c7b983010e15e699bda1f5ed370ba793e", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1080,7 +1080,10 @@ impl CrateError {\n                                 locator.triple\n                             ));\n                         }\n-                        if missing_core && std::env::var(\"RUSTUP_HOME\").is_ok() {\n+                        // NOTE: this suggests using rustup, even though the user may not have it installed.\n+                        // That's because they could choose to install it; or this may give them a hint which\n+                        // target they need to install from their distro.\n+                        if missing_core {\n                             err.help(&format!(\n                                 \"consider downloading the target with `rustup target add {}`\",\n                                 locator.triple\n@@ -1097,7 +1100,7 @@ impl CrateError {\n                                 current_crate\n                             ));\n                         }\n-                        if sess.is_nightly_build() && std::env::var(\"CARGO\").is_ok() {\n+                        if sess.is_nightly_build() {\n                             err.help(\"consider building the standard library from source with `cargo build -Zbuild-std`\");\n                         }\n                     } else if Some(crate_name)"}, {"sha": "f1c7c1ea852a285e08c3f12dbbf24aedcc47e0e9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -628,6 +628,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         ) {\n                             return true;\n                         }\n@@ -646,6 +647,7 @@ impl<T> Trait<T> for X {\n                             assoc_substs,\n                             ty,\n                             msg,\n+                            false,\n                         );\n                     }\n                 }\n@@ -771,13 +773,24 @@ fn foo(&self) -> Self::T { String::new() }\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n         if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n-            self.constrain_associated_type_structured_suggestion(\n+            let opaque_local_def_id = def_id.expect_local();\n+            let opaque_hir_id = self.hir().local_def_id_to_hir_id(opaque_local_def_id);\n+            let opaque_hir_ty = match &self.hir().expect_item(opaque_hir_id).kind {\n+                hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n                 db,\n-                self.def_span(def_id),\n-                &assoc,\n-                proj_ty.trait_ref_and_own_substs(self).1,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n                 ty,\n-                &msg,\n+                msg,\n+                true,\n             )\n         } else {\n             false\n@@ -899,6 +912,11 @@ fn foo(&self) -> Self::T { String::new() }\n \n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n         db: &mut DiagnosticBuilder<'_>,\n@@ -908,23 +926,30 @@ fn foo(&self) -> Self::T { String::new() }\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n+        is_bound_surely_present: bool,\n     ) -> bool {\n         // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-        bounds.iter().any(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => {\n-                // Relate the type param against `T` in `<A as T>::Foo`.\n-                ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id)\n-                    && self.constrain_associated_type_structured_suggestion(\n-                        db,\n-                        ptr.span,\n-                        assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                    )\n-            }\n-            _ => false,\n-        })\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(db, span, assoc, assoc_substs, ty, msg)\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an"}, {"sha": "21534290d129193acd58c14935790cb5a16a7d6f", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -27,7 +27,9 @@ struct UnsafetyVisitor<'a, 'tcx> {\n     /// The `#[target_feature]` attributes of the body. Used for checking\n     /// calls to functions with `#[target_feature]` (RFC 2396).\n     body_target_features: &'tcx Vec<Symbol>,\n-    in_possible_lhs_union_assign: bool,\n+    /// When inside the LHS of an assignment to a field, this is the type\n+    /// of the LHS and the span of the assignment expression.\n+    assignment_info: Option<(Ty<'tcx>, Span)>,\n     in_union_destructure: bool,\n     param_env: ParamEnv<'tcx>,\n     inside_adt: bool,\n@@ -287,7 +289,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &Expr<'tcx>) {\n-        // could we be in a the LHS of an assignment of a union?\n+        // could we be in the LHS of an assignment to a field?\n         match expr.kind {\n             ExprKind::Field { .. }\n             | ExprKind::VarRef { .. }\n@@ -329,7 +331,12 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::LlvmInlineAsm { .. }\n             | ExprKind::LogicalOp { .. }\n-            | ExprKind::Use { .. } => self.in_possible_lhs_union_assign = false,\n+            | ExprKind::Use { .. } => {\n+                // We don't need to save the old value and restore it\n+                // because all the place expressions can't have more\n+                // than one child.\n+                self.assignment_info = None;\n+            }\n         };\n         match expr.kind {\n             ExprKind::Scope { value, lint_level: LintLevel::Explicit(hir_id), region_scope: _ } => {\n@@ -409,32 +416,42 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 self.safety_context = closure_visitor.safety_context;\n             }\n             ExprKind::Field { lhs, .. } => {\n-                // assigning to union field is okay for AccessToUnionField\n-                if let ty::Adt(adt_def, _) = &self.thir[lhs].ty.kind() {\n+                let lhs = &self.thir[lhs];\n+                if let ty::Adt(adt_def, _) = lhs.ty.kind() {\n                     if adt_def.is_union() {\n-                        if self.in_possible_lhs_union_assign {\n-                            // FIXME: trigger AssignToDroppingUnionField unsafety if needed\n+                        if let Some((assigned_ty, assignment_span)) = self.assignment_info {\n+                            // To avoid semver hazard, we only consider `Copy` and `ManuallyDrop` non-dropping.\n+                            if !(assigned_ty\n+                                .ty_adt_def()\n+                                .map_or(false, |adt| adt.is_manually_drop())\n+                                || assigned_ty\n+                                    .is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env))\n+                            {\n+                                self.requires_unsafe(assignment_span, AssignToDroppingUnionField);\n+                            } else {\n+                                // write to non-drop union field, safe\n+                            }\n                         } else {\n                             self.requires_unsafe(expr.span, AccessToUnionField);\n                         }\n                     }\n                 }\n             }\n             ExprKind::Assign { lhs, rhs } | ExprKind::AssignOp { lhs, rhs, .. } => {\n+                let lhs = &self.thir[lhs];\n                 // First, check whether we are mutating a layout constrained field\n                 let mut visitor = LayoutConstrainedPlaceVisitor::new(self.thir, self.tcx);\n-                visit::walk_expr(&mut visitor, &self.thir[lhs]);\n+                visit::walk_expr(&mut visitor, lhs);\n                 if visitor.found {\n                     self.requires_unsafe(expr.span, MutationOfLayoutConstrainedField);\n                 }\n \n                 // Second, check for accesses to union fields\n                 // don't have any special handling for AssignOp since it causes a read *and* write to lhs\n                 if matches!(expr.kind, ExprKind::Assign { .. }) {\n-                    // assigning to a union is safe, check here so it doesn't get treated as a read later\n-                    self.in_possible_lhs_union_assign = true;\n-                    visit::walk_expr(self, &self.thir()[lhs]);\n-                    self.in_possible_lhs_union_assign = false;\n+                    self.assignment_info = Some((lhs.ty, expr.span));\n+                    visit::walk_expr(self, lhs);\n+                    self.assignment_info = None;\n                     visit::walk_expr(self, &self.thir()[rhs]);\n                     return; // we have already visited everything by now\n                 }\n@@ -506,12 +523,9 @@ enum UnsafeOpKind {\n     UseOfMutableStatic,\n     UseOfExternStatic,\n     DerefOfRawPointer,\n-    #[allow(dead_code)] // FIXME\n     AssignToDroppingUnionField,\n     AccessToUnionField,\n-    #[allow(dead_code)] // FIXME\n     MutationOfLayoutConstrainedField,\n-    #[allow(dead_code)] // FIXME\n     BorrowOfLayoutConstrainedField,\n     CallToFunctionWith,\n }\n@@ -619,7 +633,7 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n         hir_context: hir_id,\n         body_unsafety,\n         body_target_features,\n-        in_possible_lhs_union_assign: false,\n+        assignment_info: None,\n         in_union_destructure: false,\n         param_env: tcx.param_env(def.did),\n         inside_adt: false,"}, {"sha": "369af437c43841ce3090ce8a9af1e429bf9ed15c", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -219,7 +219,6 @@ pub struct Session {\n     /// Set of enabled features for the current target.\n     pub target_features: FxHashSet<Symbol>,\n \n-    known_attrs: Lock<MarkedAttrs>,\n     used_attrs: Lock<MarkedAttrs>,\n \n     /// `Span`s for `if` conditions that we have suggested turning into `if let`.\n@@ -1076,14 +1075,6 @@ impl Session {\n             == config::InstrumentCoverage::ExceptUnusedFunctions\n     }\n \n-    pub fn mark_attr_known(&self, attr: &Attribute) {\n-        self.known_attrs.lock().mark(attr)\n-    }\n-\n-    pub fn is_attr_known(&self, attr: &Attribute) -> bool {\n-        self.known_attrs.lock().is_marked(attr)\n-    }\n-\n     pub fn mark_attr_used(&self, attr: &Attribute) {\n         self.used_attrs.lock().mark(attr)\n     }\n@@ -1389,7 +1380,6 @@ pub fn build_session(\n         miri_unleashed_features: Lock::new(Default::default()),\n         asm_arch,\n         target_features: FxHashSet::default(),\n-        known_attrs: Lock::new(MarkedAttrs::new()),\n         used_attrs: Lock::new(MarkedAttrs::new()),\n         if_let_suggestions: Default::default(),\n     };"}, {"sha": "ad84e07edfba620ce90423e76861f287734f817e", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -802,6 +802,7 @@ supported_targets! {\n     (\"armv6-unknown-freebsd\", armv6_unknown_freebsd),\n     (\"armv7-unknown-freebsd\", armv7_unknown_freebsd),\n     (\"i686-unknown-freebsd\", i686_unknown_freebsd),\n+    (\"powerpc-unknown-freebsd\", powerpc_unknown_freebsd),\n     (\"powerpc64-unknown-freebsd\", powerpc64_unknown_freebsd),\n     (\"powerpc64le-unknown-freebsd\", powerpc64le_unknown_freebsd),\n     (\"x86_64-unknown-freebsd\", x86_64_unknown_freebsd),"}, {"sha": "e11318027d5e863a007d08f8b966408247886aa6", "filename": "compiler/rustc_target/src/spec/powerpc_unknown_freebsd.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc_unknown_freebsd.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -0,0 +1,27 @@\n+use crate::abi::Endian;\n+use crate::spec::{LinkerFlavor, RelocModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let mut base = super::freebsd_base::opts();\n+    base.pre_link_args.entry(LinkerFlavor::Gcc).or_default().push(\"-m32\".to_string());\n+    // Extra hint to linker that we are generating secure-PLT code.\n+    base.pre_link_args\n+        .entry(LinkerFlavor::Gcc)\n+        .or_default()\n+        .push(\"--target=powerpc-unknown-freebsd13.0\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Target {\n+        llvm_target: \"powerpc-unknown-freebsd13.0\".to_string(),\n+        pointer_width: 32,\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        options: TargetOptions {\n+            endian: Endian::Big,\n+            features: \"+secure-plt\".to_string(),\n+            relocation_model: RelocModel::Pic,\n+            mcount: \"_mcount\".to_string(),\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "07ee589e29f562fa9d95e7721d9d4c5707974984", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -845,6 +845,7 @@ pub(crate) mod builtin {\n                   language use and is subject to change\"\n     )]\n     #[allow_internal_unstable(fmt_internals)]\n+    #[doc(hidden)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args_nl {"}, {"sha": "d3ebc1cebb67bf6913e5f5b6fc86716779177cc1", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -461,7 +461,6 @@ impl<T> MaybeUninit<T> {\n     /// With `write`, we can avoid the need to write through a raw pointer:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use core::pin::Pin;\n     /// use core::mem::MaybeUninit;\n     ///"}, {"sha": "5709d97d6430f6209e154c1f78ad564cc2338dd2", "filename": "library/std/src/env.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -294,7 +294,7 @@ impl Error for VarError {\n     }\n }\n \n-/// Sets the environment variable `k` to the value `v` for the currently running\n+/// Sets the environment variable `key` to the value `value` for the currently running\n /// process.\n ///\n /// Note that while concurrent access to environment variables is safe in Rust,\n@@ -310,9 +310,8 @@ impl Error for VarError {\n ///\n /// # Panics\n ///\n-/// This function may panic if `key` is empty, contains an ASCII equals sign\n-/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n-/// character.\n+/// This function may panic if `key` is empty, contains an ASCII equals sign `'='`\n+/// or the NUL character `'\\0'`, or when `value` contains the NUL character.\n ///\n /// # Examples\n ///"}, {"sha": "b8a1513f2a696a810928343df5c63b4315363611", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -118,6 +118,10 @@ impl Step for Llvm {\n             let idx = target.triple.find('-').unwrap();\n \n             format!(\"riscv{}{}\", &target.triple[5..7], &target.triple[idx..])\n+        } else if self.target.starts_with(\"powerpc\") && self.target.ends_with(\"freebsd\") {\n+            // FreeBSD 13 had incompatible ABI changes on all PowerPC platforms.\n+            // Set the version suffix to 13.0 so the correct target details are used.\n+            format!(\"{}{}\", self.target, \"13.0\")\n         } else {\n             target.to_string()\n         };\n@@ -277,6 +281,11 @@ impl Step for Llvm {\n             }\n         }\n \n+        // Workaround for ppc32 lld limitation\n+        if target == \"powerpc-unknown-freebsd\" {\n+            cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-fuse-ld=bfd\");\n+        }\n+\n         // https://llvm.org/docs/HowToCrossCompileLLVM.html\n         if target != builder.config.build {\n             builder.ensure(Llvm { target: builder.config.build });"}, {"sha": "90ef48798ddabc7ad465fdd91326a90e55f6a085", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -249,6 +249,7 @@ target | std | host | notes\n `powerpc-wrs-vxworks` | ? |  |\n `powerpc64-unknown-freebsd` | \u2713 | \u2713 | PPC64 FreeBSD (ELFv1 and ELFv2)\n `powerpc64le-unknown-freebsd` |   |   | PPC64LE FreeBSD\n+`powerpc-unknown-freebsd` |   |   | PowerPC FreeBSD\n `powerpc64-unknown-linux-musl` | ? |  |\n `powerpc64-wrs-vxworks` | ? |  |\n `powerpc64le-unknown-linux-musl` | ? |  |"}, {"sha": "a70f771e4826f14c33b4900ecbb8a76765e0df21", "filename": "src/test/ui/associated-types/issue-87261.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -0,0 +1,99 @@\n+trait Foo {}\n+\n+trait Trait {\n+    type Associated;\n+}\n+trait DerivedTrait: Trait {}\n+trait GenericTrait<A> {\n+    type Associated;\n+}\n+\n+struct Impl;\n+impl Foo for Impl {}\n+impl Trait for Impl {\n+    type Associated = ();\n+}\n+impl DerivedTrait for Impl {}\n+impl<A> GenericTrait<A> for Impl {\n+    type Associated = ();\n+}\n+\n+fn returns_opaque() -> impl Trait + 'static {\n+    Impl\n+}\n+fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n+    Impl\n+}\n+fn returns_opaque_foo() -> impl Trait + Foo {\n+    Impl\n+}\n+fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n+    Impl\n+}\n+fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n+    Impl\n+}\n+fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n+    Impl\n+}\n+fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n+    Impl\n+}\n+\n+fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+\n+fn check_generics<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G)\n+where\n+    A: Trait + 'static,\n+    B: DerivedTrait + 'static,\n+    C: Trait + Foo,\n+    D: DerivedTrait + Foo,\n+    E: GenericTrait<()> + 'static,\n+    F: GenericTrait<()> + Foo,\n+    G: GenericTrait<()> + GenericTrait<u8>,\n+{\n+    accepts_trait(a);\n+    //~^ ERROR type mismatch resolving `<A as Trait>::Associated == ()`\n+\n+    accepts_trait(b);\n+    //~^ ERROR type mismatch resolving `<B as Trait>::Associated == ()`\n+\n+    accepts_trait(c);\n+    //~^ ERROR type mismatch resolving `<C as Trait>::Associated == ()`\n+\n+    accepts_trait(d);\n+    //~^ ERROR type mismatch resolving `<D as Trait>::Associated == ()`\n+\n+    accepts_generic_trait(e);\n+    //~^ ERROR type mismatch resolving `<E as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(f);\n+    //~^ ERROR type mismatch resolving `<F as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(g);\n+    //~^ ERROR type mismatch resolving `<G as GenericTrait<()>>::Associated == ()`\n+}\n+\n+fn main() {\n+    accepts_trait(returns_opaque());\n+    //~^ ERROR type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_derived());\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_foo());\n+    //~^ ERROR type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+\n+    accepts_trait(returns_opaque_derived_foo());\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic_foo());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+\n+    accepts_generic_trait(returns_opaque_generic_duplicate());\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+}"}, {"sha": "0725acfe537dbb5022373d594bca2e4c91eff7af", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -0,0 +1,238 @@\n+error[E0271]: type mismatch resolving `<A as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:56:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(a);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<A as Trait>::Associated`\n+help: consider constraining the associated type `<A as Trait>::Associated` to `()`\n+   |\n+LL |     A: Trait<Associated = ()> + 'static,\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<B as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:59:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(b);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<B as Trait>::Associated`\n+   = help: consider constraining the associated type `<B as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<C as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:62:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(c);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<C as Trait>::Associated`\n+help: consider constraining the associated type `<C as Trait>::Associated` to `()`\n+   |\n+LL |     C: Trait<Associated = ()> + Foo,\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<D as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:65:5\n+   |\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(d);\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<D as Trait>::Associated`\n+   = help: consider constraining the associated type `<D as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<E as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:68:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(e);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<E as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<E as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL |     E: GenericTrait<(), Associated = ()> + 'static,\n+   |                       ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<F as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:71:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(f);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<F as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<F as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL |     F: GenericTrait<(), Associated = ()> + Foo,\n+   |                       ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<G as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:74:5\n+   |\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(g);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<G as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<G as GenericTrait<()>>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:79:5\n+   |\n+LL | fn returns_opaque() -> impl Trait + 'static {\n+   |                        -------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl Trait as Trait>::Associated`\n+help: consider constraining the associated type `<impl Trait as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque() -> impl Trait<Associated = ()> + 'static {\n+   |                                  ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:82:5\n+   |\n+LL | fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n+   |                                --------------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_derived());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl DerivedTrait as Trait>::Associated`\n+help: consider constraining the associated type `<impl DerivedTrait as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static {\n+   |                                                 ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:85:5\n+   |\n+LL | fn returns_opaque_foo() -> impl Trait + Foo {\n+   |                            ---------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_foo());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl Trait+Foo as Trait>::Associated`\n+help: consider constraining the associated type `<impl Trait+Foo as Trait>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_foo() -> impl Trait<Associated = ()> + Foo {\n+   |                                      ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+  --> $DIR/issue-87261.rs:88:5\n+   |\n+LL | fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n+   |                                    ----------------------- the found opaque type\n+...\n+LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n+   |                           --------------- required by this bound in `accepts_trait`\n+...\n+LL |     accepts_trait(returns_opaque_derived_foo());\n+   |     ^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl DerivedTrait+Foo as Trait>::Associated`\n+   = help: consider constraining the associated type `<impl DerivedTrait+Foo as Trait>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:91:5\n+   |\n+LL | fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n+   |                                ------------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'static {\n+   |                                                    ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:94:5\n+   |\n+LL | fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n+   |                                    --------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic_foo());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated`\n+help: consider constraining the associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated` to `()`\n+   |\n+LL | fn returns_opaque_generic_foo() -> impl GenericTrait<(), Associated = ()> + Foo {\n+   |                                                        ^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+  --> $DIR/issue-87261.rs:97:5\n+   |\n+LL | fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n+   |                                          ---------------------------------------- the found opaque type\n+...\n+LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n+   |                                              --------------- required by this bound in `accepts_generic_trait`\n+...\n+LL |     accepts_generic_trait(returns_opaque_generic_duplicate());\n+   |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |\n+   = note:    expected unit type `()`\n+           found associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated` to `()`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "1a34c21ba541370129ee2d367550506a06ec9f14", "filename": "src/test/ui/crate-loading/missing-std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1,7 +1,6 @@\n // compile-flags: --target x86_64-unknown-uefi\n // needs-llvm-components: x86\n // rustc-env:CARGO=/usr/bin/cargo\n-// rustc-env:RUSTUP_HOME=/home/bors/.rustup\n #![no_core]\n extern crate core;\n //~^ ERROR can't find crate for `core`"}, {"sha": "25808efdfa6993e94c45af96bfd0878e1598f4ad", "filename": "src/test/ui/crate-loading/missing-std.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcrate-loading%2Fmissing-std.stderr?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1,5 +1,5 @@\n error[E0463]: can't find crate for `core`\n-  --> $DIR/missing-std.rs:6:1\n+  --> $DIR/missing-std.rs:5:1\n    |\n LL | extern crate core;\n    | ^^^^^^^^^^^^^^^^^^ can't find crate"}, {"sha": "b45574f0c49af80d563b5a5404b2a12f6728939f", "filename": "src/test/ui/issues/issue-37131.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fissues%2Fissue-37131.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fissues%2Fissue-37131.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37131.stderr?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1,6 +1,8 @@\n error[E0463]: can't find crate for `std`\n    |\n    = note: the `thumbv6m-none-eabi` target may not be installed\n+   = help: consider downloading the target with `rustup target add thumbv6m-none-eabi`\n+   = help: consider building the standard library from source with `cargo build -Zbuild-std`\n \n error: aborting due to previous error\n "}, {"sha": "d963c07ea91750ac12704dc65c4af389233d6d91", "filename": "src/test/ui/issues/issue-49851/compiler-builtins-error.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49851%2Fcompiler-builtins-error.stderr?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -1,6 +1,8 @@\n error[E0463]: can't find crate for `core`\n    |\n    = note: the `thumbv7em-none-eabihf` target may not be installed\n+   = help: consider downloading the target with `rustup target add thumbv7em-none-eabihf`\n+   = help: consider building the standard library from source with `cargo build -Zbuild-std`\n \n error: aborting due to previous error\n "}, {"sha": "3cb3a18cb7544cbfdab377adba0842e91d1ecfb1", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -36,8 +36,8 @@ fn deref_union_field(mut u: URef) {\n \n fn assign_noncopy_union_field(mut u: URefCell) {\n     // FIXME(thir-unsafeck)\n-    u.a = (RefCell::new(0), 1); //[mir]~ ERROR assignment to union field that might need dropping\n-    u.a.0 = RefCell::new(0); //[mir]~ ERROR assignment to union field that might need dropping\n+    u.a = (RefCell::new(0), 1); //~ ERROR assignment to union field that might need dropping\n+    u.a.0 = RefCell::new(0); //~ ERROR assignment to union field that might need dropping\n     u.a.1 = 1; // OK\n }\n "}, {"sha": "e88642b0ff7adbc8ef7894468689e74c90d6bf92", "filename": "src/test/ui/union/union-unsafe.thir.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.thir.stderr?ref=bddb59cf07efcf6e606f16b87f85e3ecd2c1ca69", "patch": "@@ -6,6 +6,22 @@ LL |     *(u.p) = 13;\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n+error[E0133]: assignment to union field that might need dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:39:5\n+   |\n+LL |     u.a = (RefCell::new(0), 1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that might need dropping\n+   |\n+   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n+\n+error[E0133]: assignment to union field that might need dropping is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:40:5\n+   |\n+LL |     u.a.0 = RefCell::new(0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ assignment to union field that might need dropping\n+   |\n+   = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n+\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/union-unsafe.rs:47:6\n    |\n@@ -70,6 +86,6 @@ LL |     *u3.a = String::from(\"new\");\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}]}