{"sha": "1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZGJmY2RiZDBhNmE2MzMxNzg3MmZlZjI0MjIyNTMzYmJjOGNmYWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-26T16:33:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:49:25Z"}, "message": "only emit `^` at the start of a multi-line error\n\nas a result, simplify elision code", "tree": {"sha": "04324599ec73e5e956fba78413b61d50c3be0405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04324599ec73e5e956fba78413b61d50c3be0405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "html_url": "https://github.com/rust-lang/rust/commit/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24f4b151b11b22b66ac0128f76c1e12cca45b178", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f4b151b11b22b66ac0128f76c1e12cca45b178", "html_url": "https://github.com/rust-lang/rust/commit/24f4b151b11b22b66ac0128f76c1e12cca45b178"}], "stats": {"total": 210, "additions": 67, "deletions": 143}, "files": [{"sha": "eaa973db2b8c7ad08fac2f71df6bfe51b25e7754", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "patch": "@@ -543,7 +543,7 @@ mod test {\n         dreizehn\n         \";\n         let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n-        let start = file.lines.borrow()[7];\n+        let start = file.lines.borrow()[10];\n         let end = file.lines.borrow()[11];\n         let sp = mk_sp(start, end);\n         let lvl = Level::Error;\n@@ -555,12 +555,9 @@ mod test {\n         let str = from_utf8(vec).unwrap();\n         println!(\"r#\\\"\\n{}\\\"#\", str);\n         assert_eq!(str, &r#\"\n-   --> dummy.txt:8:1\n-8   |>         line8\n-    |> ^^^^^^^^^^^^^\n-...\n+   --> dummy.txt:11:1\n 11  |>         e-l\u00e4-v\u00e4n\n-    |> ^^^^^^^^^^^^^^^^\n+    |> ^\n \"#[1..]);\n     }\n \n@@ -696,9 +693,8 @@ mod test {\n         let expect0 = &r#\"\n    --> dummy.txt:5:1\n 5   |> ccccc\n-    |> ^^^^^\n+    |> ^\n ...\n-8   |> _____\n 9   |> ddd__eee_\n     |> ^^^  ^^^\n 10  |> elided\n@@ -709,9 +705,8 @@ mod test {\n         let expect = &r#\"\n    --> dummy.txt:1:1\n 1   |> aaaaa\n-    |> ^^^^^\n+    |> ^\n ...\n-8   |> _____\n 9   |> ddd__eee_\n     |> ^^^  ^^^\n 10  |> elided"}, {"sha": "643b5c3c5f23690be71a5fdd91a41038ab3bf747", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "modified", "additions": 59, "deletions": 125, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "patch": "@@ -49,7 +49,7 @@ struct Annotation {\n     /// column.\n     start_col: usize,\n \n-    /// End column within the line.\n+    /// End column within the line (exclusive)\n     end_col: usize,\n \n     /// Is this annotation derived from primary span\n@@ -349,24 +349,40 @@ impl FileInfo {\n                   label: Option<String>) {\n         assert!(lines.len() > 0);\n \n-        // If a span covers multiple lines, just put the label on the\n-        // first one. This is a sort of arbitrary choice and not\n-        // obviously correct.\n-        let (line0, remaining_lines) = lines.split_first().unwrap();\n-        let index = self.ensure_source_line(line0.line_index);\n-        self.lines[index].push_annotation(line0.start_col,\n-                                          line0.end_col,\n+        // If a span covers multiple lines, we reduce it to a single\n+        // point at the start of the span. This means that instead\n+        // of producing output like this:\n+        //\n+        // ```\n+        // --> foo.rs:2:1\n+        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n+        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+        // 3   |>                               -> Set<LR0Item<'grammar>>\n+        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+        // (and so on)\n+        // ```\n+        //\n+        // we produce:\n+        //\n+        // ```\n+        // --> foo.rs:2:1\n+        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n+        //        ^\n+        // ```\n+        //\n+        // Basically, although this loses information, multi-line spans just\n+        // never look good.\n+\n+        let (line, start_col, end_col) = if lines.len() == 1 {\n+            (lines[0].line_index, lines[0].start_col, lines[0].end_col)\n+        } else {\n+            (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1))\n+        };\n+        let index = self.ensure_source_line(line);\n+        self.lines[index].push_annotation(start_col,\n+                                          end_col,\n                                           is_primary,\n                                           label);\n-        for line in remaining_lines {\n-            if line.end_col > line.start_col {\n-                let index = self.ensure_source_line(line.line_index);\n-                self.lines[index].push_annotation(line.start_col,\n-                                                  line.end_col,\n-                                                  is_primary,\n-                                                  None);\n-            }\n-        }\n     }\n \n     /// Ensure that we have a `Line` struct corresponding to\n@@ -414,57 +430,10 @@ impl FileInfo {\n     }\n \n     fn render_file_lines(&self, codemap: &Rc<CodeMap>) -> Vec<RenderedLine> {\n-        // Group our lines by those with annotations and those without\n-        let mut lines_iter = self.lines.iter().peekable();\n-\n-        let mut line_groups = vec![];\n-\n-        loop {\n-            match lines_iter.next() {\n-                None => break,\n-                Some(line) if line.annotations.is_empty() => {\n-                    // Collect unannotated group\n-                    let mut unannotated_group : Vec<&Line> = vec![];\n-\n-                    unannotated_group.push(line);\n-\n-                    loop {\n-                        let next_line =\n-                            match lines_iter.peek() {\n-                                None => break,\n-                                Some(x) if !x.annotations.is_empty() => break,\n-                                Some(x) => x.clone()\n-                            };\n-\n-                        unannotated_group.push(next_line);\n-                        lines_iter.next();\n-                    }\n-\n-                    line_groups.push((false, unannotated_group));\n-                }\n-                Some(line) => {\n-                    // Collect annotated group\n-                    let mut annotated_group : Vec<&Line> = vec![];\n-\n-                    annotated_group.push(line);\n-\n-                    loop {\n-                        let next_line =\n-                            match lines_iter.peek() {\n-                                None => break,\n-                                Some(x) if x.annotations.is_empty() => break,\n-                                Some(x) => x.clone()\n-                            };\n-\n-                        annotated_group.push(next_line);\n-                        lines_iter.next();\n-                    }\n-\n-                    line_groups.push((true, annotated_group));\n-                }\n-            }\n-        }\n+        // As a first step, we elide any instance of more than one\n+        // continuous unannotated line.\n \n+        let mut lines_iter = self.lines.iter();\n         let mut output = vec![];\n \n         // First insert the name of the file.\n@@ -493,65 +462,30 @@ impl FileInfo {\n             }\n         }\n \n-        for &(is_annotated, ref group) in line_groups.iter() {\n-            if is_annotated {\n-                let mut annotation_ends_at_eol = false;\n-                let mut prev_ends_at_eol = false;\n-                let mut elide_unlabeled_region = false;\n-\n-                for group_line in group.iter() {\n-                    let source_string_len =\n-                        self.file.get_line(group_line.line_index)\n-                                 .map(|s| s.len())\n-                                 .unwrap_or(0);\n-\n-                    for annotation in &group_line.annotations {\n-                        if annotation.end_col == source_string_len {\n-                            annotation_ends_at_eol = true;\n-                        }\n-                    }\n-\n-                    let is_single_unlabeled_annotated_line =\n-                        if group_line.annotations.len() == 1 {\n-                            if let Some(annotation) = group_line.annotations.first() {\n-                                match annotation.label {\n-                                    Some(_) => false,\n-                                    None => annotation.start_col == 0 &&\n-                                            annotation.end_col == source_string_len\n-                                }\n-                            } else {\n-                                false\n-                            }\n-                        } else {\n-                            false\n-                        };\n-\n-                    if prev_ends_at_eol && is_single_unlabeled_annotated_line {\n-                        if !elide_unlabeled_region {\n-                            output.push(RenderedLine::from((String::new(),\n-                                                            Style::NoStyle,\n-                                                            RenderedLineKind::Elision)));\n-                            elide_unlabeled_region = true;\n-                            prev_ends_at_eol = true;\n-                        }\n-                        continue;\n-                    }\n-\n-                    let mut v = self.render_line(group_line);\n-                    output.append(&mut v);\n+        let mut next_line = lines_iter.next();\n+        while next_line.is_some() {\n+            // Consume lines with annotations.\n+            while let Some(line) = next_line {\n+                if line.annotations.is_empty() { break; }\n+                output.append(&mut self.render_line(line));\n+                next_line = lines_iter.next();\n+            }\n \n-                    prev_ends_at_eol = annotation_ends_at_eol;\n-                }\n-            } else {\n-                if group.len() > 1 {\n-                    output.push(RenderedLine::from((String::new(),\n-                                                    Style::NoStyle,\n-                                                    RenderedLineKind::Elision)));\n-                } else {\n-                    let mut v: Vec<RenderedLine> =\n-                        group.iter().flat_map(|line| self.render_line(line)).collect();\n-                    output.append(&mut v);\n-                }\n+            // Emit lines without annotations, but only if they are\n+            // followed by a line with an annotation.\n+            let unannotated_line = next_line;\n+            let mut unannotated_lines = 0;\n+            while let Some(line) = next_line {\n+                if !line.annotations.is_empty() { break; }\n+                unannotated_lines += 1;\n+                next_line = lines_iter.next();\n+            }\n+            if unannotated_lines > 1 {\n+                output.push(RenderedLine::from((String::new(),\n+                                                Style::NoStyle,\n+                                                RenderedLineKind::Elision)));\n+            } else if let Some(line) = unannotated_line {\n+                output.append(&mut self.render_line(line));\n             }\n         }\n "}, {"sha": "d995d828bc7270e4ad85cab53aaa120049b87cea", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdbfcdbd0a6a63317872fef24222533bbc8cfaf/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=1fdbfcdbd0a6a63317872fef24222533bbc8cfaf", "patch": "@@ -406,8 +406,7 @@ impl SomeTrait for () {\n     assert_eq!(text, &r#\"\n >>>>>> foo.rs\n 3   |>     fn foo(x: u32) {\n-    |>     ----------------\n-...\n+    |>     -\n \"#[1..]);\n }\n \n@@ -515,12 +514,8 @@ fn span_overlap_label3() {\n     assert_eq!(text, &r#\"\n >>>> foo.rs\n 3 |>        let closure = || {\n-  |>                      ---- foo\n+  |>                      - foo\n 4 |>            inner\n-  |> ----------------\n-  |>            |\n-  |>            bar\n-5 |>        };\n-  |> --------\n+  |>            ---- bar\n \"#[1..]);\n }"}]}