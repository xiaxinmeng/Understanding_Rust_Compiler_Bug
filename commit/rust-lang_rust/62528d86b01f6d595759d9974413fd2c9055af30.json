{"sha": "62528d86b01f6d595759d9974413fd2c9055af30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNTI4ZDg2YjAxZjZkNTk1NzU5ZDk5NzQ0MTNmZDJjOTA1NWFmMzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-06T22:26:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-06T22:26:55Z"}, "message": "Rollup merge of #66841 - SimonSapin:float_round_unchecked_to, r=rkruppe\n\nAdd `{f32,f64}::approx_unchecked_to<Int>` unsafe methods\n\nAs discussed in https://github.com/rust-lang/rust/issues/10184\n\nCurrently, casting a floating point number to an integer with `as` is Undefined Behavior if the value is out of range. `-Z saturating-float-casts` fixes this soundness hole by making `as` \u201csaturate\u201d to the maximum or minimum value of the integer type (or zero for `NaN`), but has measurable negative performance impact in some benchmarks. There is some consensus in that thread for enabling saturation by default anyway, but provide an `unsafe fn` alternative for users who know through some other mean that their values are in range.\n\n<del>The \u201cfit\u201d wording is copied from https://llvm.org/docs/LangRef.html#fptoui-to-instruction, but I\u2019m not certain what it means exactly. Presumably this is after rounding towards zero, and the doc-test with `i8::MIN` seems to confirm this.</del> Clang presumably uses those LLVM intrinsics to implement C and C++ casts, whose respective standard specify that the value *after truncating to keep its integral part* must be representable in the target type.", "tree": {"sha": "f82c3a048db52021b8d2294a8ff011d59643b122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f82c3a048db52021b8d2294a8ff011d59643b122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62528d86b01f6d595759d9974413fd2c9055af30", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6tWwCRBK7hj4Ov3rIwAAdHIIAEp4KnuO/h1iRC2opFEgIO8f\nUXvqF86YTAjHUAzKZdZ5Mbn1Ys6kkDrgn9iWOnC8Ecre/qkHwA8J96+/MEkhQktH\nWxa+vIB9AY7zX0NZ8zo6Xn+1R7HzxujHcQwPzgHoIh0Yv8fqbwD3C7Q4gxlNpr0h\n4GucFgyD9BaCBhk6FW8nvNuhCt2Dy4jmcTgeqpdwFmL5jFDSHhS/BdExgSR02pdS\n/a9uF8I+j7cpSuzde8evE7gq7CpYUdhk4Ww4j9nKdl85rV1P19bjN2GnZQfOQJ+I\nn1iZWM4KZLb7PNLlpbsay5O5DHwLSs8R4N+R+qhXvYE+EbbIyMc7hpZcbK0aZc0=\n=gKzl\n-----END PGP SIGNATURE-----\n", "payload": "tree f82c3a048db52021b8d2294a8ff011d59643b122\nparent 2bd35c065cb097d1ea6480c372ab9b5eea358cee\nparent a213ff82998ef91fa793883c2f2ebbc574967500\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575671215 +0100\ncommitter GitHub <noreply@github.com> 1575671215 +0100\n\nRollup merge of #66841 - SimonSapin:float_round_unchecked_to, r=rkruppe\n\nAdd `{f32,f64}::approx_unchecked_to<Int>` unsafe methods\n\nAs discussed in https://github.com/rust-lang/rust/issues/10184\n\nCurrently, casting a floating point number to an integer with `as` is Undefined Behavior if the value is out of range. `-Z saturating-float-casts` fixes this soundness hole by making `as` \u201csaturate\u201d to the maximum or minimum value of the integer type (or zero for `NaN`), but has measurable negative performance impact in some benchmarks. There is some consensus in that thread for enabling saturation by default anyway, but provide an `unsafe fn` alternative for users who know through some other mean that their values are in range.\n\n<del>The \u201cfit\u201d wording is copied from https://llvm.org/docs/LangRef.html#fptoui-to-instruction, but I\u2019m not certain what it means exactly. Presumably this is after rounding towards zero, and the doc-test with `i8::MIN` seems to confirm this.</del> Clang presumably uses those LLVM intrinsics to implement C and C++ casts, whose respective standard specify that the value *after truncating to keep its integral part* must be representable in the target type.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62528d86b01f6d595759d9974413fd2c9055af30", "html_url": "https://github.com/rust-lang/rust/commit/62528d86b01f6d595759d9974413fd2c9055af30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62528d86b01f6d595759d9974413fd2c9055af30/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd35c065cb097d1ea6480c372ab9b5eea358cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd35c065cb097d1ea6480c372ab9b5eea358cee", "html_url": "https://github.com/rust-lang/rust/commit/2bd35c065cb097d1ea6480c372ab9b5eea358cee"}, {"sha": "a213ff82998ef91fa793883c2f2ebbc574967500", "url": "https://api.github.com/repos/rust-lang/rust/commits/a213ff82998ef91fa793883c2f2ebbc574967500", "html_url": "https://github.com/rust-lang/rust/commit/a213ff82998ef91fa793883c2f2ebbc574967500"}], "stats": {"total": 804, "additions": 471, "deletions": 333}, "files": [{"sha": "16d5375059feebd663c6bc563c96aa750375bd7c", "filename": "src/libcore/convert/mod.rs", "status": "renamed", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -40,6 +40,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod num;\n+\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub use num::FloatToInt;\n+\n /// The identity function.\n ///\n /// Two things are important to note about this function:", "previous_filename": "src/libcore/convert.rs"}, {"sha": "0877dacb38dd2ee80662e021f02219274f9a7997", "filename": "src/libcore/convert/num.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -0,0 +1,369 @@\n+use super::{From, TryFrom};\n+use crate::num::TryFromIntError;\n+\n+mod private {\n+    /// This trait being unreachable from outside the crate\n+    /// prevents other implementations of the `FloatToInt` trait,\n+    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n+    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+    pub trait Sealed {}\n+}\n+\n+/// Supporting trait for inherent methods of `f32` and `f64` such as `round_unchecked_to`.\n+/// Typically doesn\u2019t need to be used directly.\n+#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+pub trait FloatToInt<Int>: private::Sealed + Sized {\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[doc(hidden)]\n+    unsafe fn approx_unchecked(self) -> Int;\n+}\n+\n+macro_rules! impl_float_to_int {\n+    ( $Float: ident => $( $Int: ident )+ ) => {\n+        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+        impl private::Sealed for $Float {}\n+        $(\n+            #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n+            impl FloatToInt<$Int> for $Float {\n+                #[cfg(not(bootstrap))]\n+                #[doc(hidden)]\n+                #[inline]\n+                unsafe fn approx_unchecked(self) -> $Int {\n+                    crate::intrinsics::float_to_int_approx_unchecked(self)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+impl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n+\n+// Conversion traits for primitive integer and float types\n+// Conversions T -> T are covered by a blanket impl and therefore excluded\n+// Some conversions from and to usize/isize are not implemented due to portability concerns\n+macro_rules! impl_from {\n+    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n+        #[$attr]\n+        #[doc = $doc]\n+        impl From<$Small> for $Large {\n+            #[inline]\n+            fn from(small: $Small) -> $Large {\n+                small as $Large\n+            }\n+        }\n+    };\n+    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n+        impl_from!($Small,\n+                   $Large,\n+                   #[$attr],\n+                   concat!(\"Converts `\",\n+                           stringify!($Small),\n+                           \"` to `\",\n+                           stringify!($Large),\n+                           \"` losslessly.\"));\n+    }\n+}\n+\n+macro_rules! impl_from_bool {\n+    ($target: ty, #[$attr:meta]) => {\n+        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n+            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n+values.\n+\n+# Examples\n+\n+```\n+assert_eq!(\", stringify!($target), \"::from(true), 1);\n+assert_eq!(\", stringify!($target), \"::from(false), 0);\n+```\"));\n+    };\n+}\n+\n+// Bool -> Any\n+impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n+\n+// Unsigned -> Unsigned\n+impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Signed -> Signed\n+impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// Unsigned -> Signed\n+impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// Float -> Float\n+impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// only negative bounds\n+macro_rules! try_from_lower_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u >= 0 {\n+                    Ok(u as $target)\n+                } else {\n+                    Err(TryFromIntError(()))\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+macro_rules! try_from_upper_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                if u > (<$target>::max_value() as $source) {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+// all other cases\n+macro_rules! try_from_both_bounded {\n+    ($source:ty, $($target:ty),*) => {$(\n+        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Error = TryFromIntError;\n+\n+            /// Try to create the target number type from a source\n+            /// number type. This returns an error if the source value\n+            /// is outside of the range of the target type.\n+            #[inline]\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target>::min_value() as $source;\n+                let max = <$target>::max_value() as $source;\n+                if u < min || u > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+macro_rules! rev {\n+    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n+        $mac!($target, $source);\n+    )*}\n+}\n+\n+// intra-sign conversions\n+try_from_upper_bounded!(u16, u8);\n+try_from_upper_bounded!(u32, u16, u8);\n+try_from_upper_bounded!(u64, u32, u16, u8);\n+try_from_upper_bounded!(u128, u64, u32, u16, u8);\n+\n+try_from_both_bounded!(i16, i8);\n+try_from_both_bounded!(i32, i16, i8);\n+try_from_both_bounded!(i64, i32, i16, i8);\n+try_from_both_bounded!(i128, i64, i32, i16, i8);\n+\n+// unsigned-to-signed\n+try_from_upper_bounded!(u8, i8);\n+try_from_upper_bounded!(u16, i8, i16);\n+try_from_upper_bounded!(u32, i8, i16, i32);\n+try_from_upper_bounded!(u64, i8, i16, i32, i64);\n+try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n+\n+// signed-to-unsigned\n+try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n+try_from_lower_bounded!(i16, u16, u32, u64, u128);\n+try_from_lower_bounded!(i32, u32, u64, u128);\n+try_from_lower_bounded!(i64, u64, u128);\n+try_from_lower_bounded!(i128, u128);\n+try_from_both_bounded!(i16, u8);\n+try_from_both_bounded!(i32, u16, u8);\n+try_from_both_bounded!(i64, u32, u16, u8);\n+try_from_both_bounded!(i128, u64, u32, u16, u8);\n+\n+// usize/isize\n+try_from_upper_bounded!(usize, isize);\n+try_from_lower_bounded!(isize, usize);\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8);\n+    try_from_unbounded!(usize, u16, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16);\n+    try_from_unbounded!(usize, i32, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8);\n+    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8);\n+    try_from_unbounded!(isize, i16, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16);\n+    rev!(try_from_both_bounded, usize, i32, i64, i128);\n+\n+    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n+    rev!(try_from_both_bounded, isize, i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16);\n+    try_from_unbounded!(usize, u32, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32);\n+    try_from_unbounded!(usize, i64, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16);\n+    try_from_lower_bounded!(isize, u32, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16);\n+    try_from_unbounded!(isize, i32, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32);\n+    rev!(try_from_upper_bounded, usize, u64, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n+    rev!(try_from_both_bounded, usize, i64, i128);\n+\n+    rev!(try_from_unbounded, isize, u16);\n+    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n+    rev!(try_from_unbounded, isize, i32);\n+    rev!(try_from_both_bounded, isize, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::TryFromIntError;\n+    use crate::convert::TryFrom;\n+\n+    try_from_upper_bounded!(usize, u8, u16, u32);\n+    try_from_unbounded!(usize, u64, u128);\n+    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n+    try_from_unbounded!(usize, i128);\n+\n+    try_from_both_bounded!(isize, u8, u16, u32);\n+    try_from_lower_bounded!(isize, u64, u128);\n+    try_from_both_bounded!(isize, i8, i16, i32);\n+    try_from_unbounded!(isize, i64, i128);\n+\n+    rev!(try_from_unbounded, usize, u32, u64);\n+    rev!(try_from_upper_bounded, usize, u128);\n+    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n+    rev!(try_from_both_bounded, usize, i128);\n+\n+    rev!(try_from_unbounded, isize, u16, u32);\n+    rev!(try_from_upper_bounded, isize, u64, u128);\n+    rev!(try_from_unbounded, isize, i32, i64);\n+    rev!(try_from_both_bounded, isize, i128);\n+}"}, {"sha": "18aae59573d7d56a0707f586617bf86570a816ad", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -1144,6 +1144,11 @@ extern \"rust-intrinsic\" {\n     /// May assume inputs are finite.\n     pub fn frem_fast<T>(a: T, b: T) -> T;\n \n+    /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n+    /// https://github.com/rust-lang/rust/issues/10184\n+    #[cfg(not(bootstrap))]\n+    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n+\n \n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;"}, {"sha": "ac06f95e244b6f97c407804b0812dac9d151fa12", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -400,6 +401,35 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u32`.\n     ///\n     /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms."}, {"sha": "794f77fcfc1be379e879214ee5a4cd2672ac9ae8", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -7,9 +7,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(bootstrap))]\n+use crate::convert::FloatToInt;\n #[cfg(not(test))]\n use crate::intrinsics;\n-\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -413,6 +414,35 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Rounds toward zero and converts to any primitive integer type,\n+    /// assuming that the value is finite and fits in that type.\n+    ///\n+    /// ```\n+    /// #![feature(float_approx_unchecked_to)]\n+    ///\n+    /// let value = 4.6_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n+    /// assert_eq!(rounded, 4);\n+    ///\n+    /// let value = -128.9_f32;\n+    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n+    /// assert_eq!(rounded, std::i8::MIN);\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The value must:\n+    ///\n+    /// * Not be `NaN`\n+    /// * Not be infinite\n+    /// * Be representable in the return type `Int`, after truncating off its fractional part\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n+    #[inline]\n+    pub unsafe fn approx_unchecked_to<Int>(self) -> Int where Self: FloatToInt<Int> {\n+        FloatToInt::<Int>::approx_unchecked(self)\n+    }\n+\n     /// Raw transmutation to `u64`.\n     ///\n     /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms."}, {"sha": "585f144cf8a9f3b76ce64f2851c47a03409acc48", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 330, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -4,7 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::TryFrom;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n@@ -4701,7 +4700,7 @@ from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n /// The error type returned when a checked integral type conversion fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(());\n+pub struct TryFromIntError(pub(crate) ());\n \n impl TryFromIntError {\n     #[unstable(feature = \"int_error_internals\",\n@@ -4728,206 +4727,6 @@ impl From<!> for TryFromIntError {\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n-// only negative bounds\n-macro_rules! try_from_lower_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u >= 0 {\n-                    Ok(u as $target)\n-                } else {\n-                    Err(TryFromIntError(()))\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// unsigned to signed (only positive bound)\n-macro_rules! try_from_upper_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                if u > (<$target>::max_value() as $source) {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-// all other cases\n-macro_rules! try_from_both_bounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n-\n-            /// Try to create the target number type from a source\n-            /// number type. This returns an error if the source value\n-            /// is outside of the range of the target type.\n-            #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                let min = <$target>::min_value() as $source;\n-                let max = <$target>::max_value() as $source;\n-                if u < min || u > max {\n-                    Err(TryFromIntError(()))\n-                } else {\n-                    Ok(u as $target)\n-                }\n-            }\n-        }\n-    )*}\n-}\n-\n-macro_rules! rev {\n-    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n-        $mac!($target, $source);\n-    )*}\n-}\n-\n-// intra-sign conversions\n-try_from_upper_bounded!(u16, u8);\n-try_from_upper_bounded!(u32, u16, u8);\n-try_from_upper_bounded!(u64, u32, u16, u8);\n-try_from_upper_bounded!(u128, u64, u32, u16, u8);\n-\n-try_from_both_bounded!(i16, i8);\n-try_from_both_bounded!(i32, i16, i8);\n-try_from_both_bounded!(i64, i32, i16, i8);\n-try_from_both_bounded!(i128, i64, i32, i16, i8);\n-\n-// unsigned-to-signed\n-try_from_upper_bounded!(u8, i8);\n-try_from_upper_bounded!(u16, i8, i16);\n-try_from_upper_bounded!(u32, i8, i16, i32);\n-try_from_upper_bounded!(u64, i8, i16, i32, i64);\n-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n-\n-// signed-to-unsigned\n-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n-try_from_lower_bounded!(i16, u16, u32, u64, u128);\n-try_from_lower_bounded!(i32, u32, u64, u128);\n-try_from_lower_bounded!(i64, u64, u128);\n-try_from_lower_bounded!(i128, u128);\n-try_from_both_bounded!(i16, u8);\n-try_from_both_bounded!(i32, u16, u8);\n-try_from_both_bounded!(i64, u32, u16, u8);\n-try_from_both_bounded!(i128, u64, u32, u16, u8);\n-\n-// usize/isize\n-try_from_upper_bounded!(usize, isize);\n-try_from_lower_bounded!(isize, usize);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8);\n-    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16);\n-    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16);\n-    try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n-    rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-mod ptr_try_from_impls {\n-    use super::TryFromIntError;\n-    use crate::convert::TryFrom;\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n-\n-    try_from_both_bounded!(isize, u8, u16, u32);\n-    try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n-    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n-    rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n-}\n-\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -5110,131 +4909,3 @@ impl fmt::Display for ParseIntError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::num::dec2flt::ParseFloatError;\n-\n-// Conversion traits for primitive integer and float types\n-// Conversions T -> T are covered by a blanket impl and therefore excluded\n-// Some conversions from and to usize/isize are not implemented due to portability concerns\n-macro_rules! impl_from {\n-    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n-        #[$attr]\n-        #[doc = $doc]\n-        impl From<$Small> for $Large {\n-            #[inline]\n-            fn from(small: $Small) -> $Large {\n-                small as $Large\n-            }\n-        }\n-    };\n-    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n-        impl_from!($Small,\n-                   $Large,\n-                   #[$attr],\n-                   concat!(\"Converts `\",\n-                           stringify!($Small),\n-                           \"` to `\",\n-                           stringify!($Large),\n-                           \"` losslessly.\"));\n-    }\n-}\n-\n-macro_rules! impl_from_bool {\n-    ($target: ty, #[$attr:meta]) => {\n-        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n-            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\n-values.\n-\n-# Examples\n-\n-```\n-assert_eq!(\", stringify!($target), \"::from(true), 1);\n-assert_eq!(\", stringify!($target), \"::from(false), 0);\n-```\"));\n-    };\n-}\n-\n-// Bool -> Any\n-impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n-\n-// Unsigned -> Unsigned\n-impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Signed -> Signed\n-impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// Unsigned -> Signed\n-impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n-\n-// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n-// which imply that pointer-sized integers must be at least 16 bits:\n-// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n-impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n-\n-// RISC-V defines the possibility of a 128-bit address space (RV128).\n-\n-// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n-// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n-// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n-\n-\n-// Note: integers can only be represented with full precision in a float if\n-// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n-// Lossy float conversions are not implemented at this time.\n-\n-// Signed -> Float\n-impl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Unsigned -> Float\n-impl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-// Float -> Float\n-impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }"}, {"sha": "1767ad118e7c0912bd706b9527caabbbdbdaaeee", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -516,9 +516,36 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         return;\n                     }\n                 }\n-\n             },\n \n+            \"float_to_int_approx_unchecked\" => {\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        tcx.sess, span,\n+                        &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                  intrinsic: expected basic float type, \\\n+                                  found `{}`\", arg_tys[0]));\n+                    return;\n+                }\n+                match int_type_width_signed(ret_ty, self.cx) {\n+                    Some((width, signed)) => {\n+                        if signed {\n+                            self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n+                        } else {\n+                            self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n+                        }\n+                    }\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `float_to_int_approx_unchecked` \\\n+                                      intrinsic:  expected basic integer type, \\\n+                                      found `{}`\", ret_ty));\n+                        return;\n+                    }\n+                }\n+            }\n+\n             \"discriminant_value\" => {\n                 args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n             }"}, {"sha": "b967c6e36e35ebc209ba4f7d73e69a42254e1655", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62528d86b01f6d595759d9974413fd2c9055af30/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=62528d86b01f6d595759d9974413fd2c9055af30", "patch": "@@ -336,6 +336,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)], param(0)),\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n+            \"float_to_int_approx_unchecked\" => (2, vec![ param(0) ], param(1)),\n \n             \"assume\" => (0, vec![tcx.types.bool], tcx.mk_unit()),\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),"}]}