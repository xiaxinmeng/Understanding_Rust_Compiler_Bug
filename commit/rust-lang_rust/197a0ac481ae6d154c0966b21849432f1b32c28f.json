{"sha": "197a0ac481ae6d154c0966b21849432f1b32c28f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5N2EwYWM0ODFhZTZkMTU0YzA5NjZiMjE4NDk0MzJmMWIzMmMyOGY=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2014-11-17T09:35:18Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2014-11-17T09:35:18Z"}, "message": "change return type of slice_shift_char\n\n`slice_shift_char` splits a `str` into it's leading `char` and the remainder\nof the `str`. Currently, it returns a `(Option<char>, &str)` such that:\n\n    \"bar\".slice_shift_char() => (Some('b'), \"ar\")\n    \"ar\".slice_shift_char()  => (Some('a'), \"r\")\n    \"r\".slice_shift_char()   => (Some('r'), \"\")\n    \"\".slice_shift_char()    => (None,      \"\")\n\nThis is a little odd. Either a `str` can be split into both a head and a\ntail or it cannot. So the return type should be `Option<(char, &str)>`.\nWith the current behaviour, in the case of the empty string, the `str`\nreturned is meaningless - it is always the empty string.\n\nThis commit changes slice_shift_char so that:\n\n    \"bar\".slice_shift_char() => Some(('b', \"ar\"))\n    \"ar\".slice_shift_char()  => Some(('a', \"r\"))\n    \"r\".slice_shift_char()   => Some(('r', \"\"))\n    \"\".slice_shift_char()    => None\n\n[breaking-change]", "tree": {"sha": "05eaeb29b0d0a3dcff43b96f869d13a5b7fc9094", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05eaeb29b0d0a3dcff43b96f869d13a5b7fc9094"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/197a0ac481ae6d154c0966b21849432f1b32c28f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/197a0ac481ae6d154c0966b21849432f1b32c28f", "html_url": "https://github.com/rust-lang/rust/commit/197a0ac481ae6d154c0966b21849432f1b32c28f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/197a0ac481ae6d154c0966b21849432f1b32c28f/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803aacd5aef78f90fdd06ae7653fc20eec224992", "url": "https://api.github.com/repos/rust-lang/rust/commits/803aacd5aef78f90fdd06ae7653fc20eec224992", "html_url": "https://github.com/rust-lang/rust/commit/803aacd5aef78f90fdd06ae7653fc20eec224992"}], "stats": {"total": 50, "additions": 25, "deletions": 25}, "files": [{"sha": "45e08fed8b2f495f3f38af526b995fe8fd22d678", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=197a0ac481ae6d154c0966b21849432f1b32c28f", "patch": "@@ -1254,13 +1254,13 @@ mod tests {\n     #[test]\n     fn test_slice_shift_char() {\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        assert_eq!(data.slice_shift_char(), (Some('\u0e1b'), \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\"));\n+        assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n     }\n \n     #[test]\n     fn test_slice_shift_char_2() {\n         let empty = \"\";\n-        assert_eq!(empty.slice_shift_char(), (None, \"\"));\n+        assert_eq!(empty.slice_shift_char(), None);\n     }\n \n     #[test]"}, {"sha": "cf07db97c8c6af20db4b8539449e29d72c2909a2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=197a0ac481ae6d154c0966b21849432f1b32c28f", "patch": "@@ -1455,10 +1455,10 @@ macro_rules! from_str_radix_float_impl {\n                 }\n \n                 let (is_positive, src) =  match src.slice_shift_char() {\n-                    (None, _)        => return None,\n-                    (Some('-'), \"\")  => return None,\n-                    (Some('-'), src) => (false, src),\n-                    (Some(_), _)     => (true,  src),\n+                    None             => return None,\n+                    Some(('-', \"\"))  => return None,\n+                    Some(('-', src)) => (false, src),\n+                    Some((_, _))     => (true,  src),\n                 };\n \n                 // The significand to accumulate\n@@ -1561,10 +1561,10 @@ macro_rules! from_str_radix_float_impl {\n                         // Parse the exponent as decimal integer\n                         let src = src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n-                            (Some('-'), src) => (false, from_str::<uint>(src)),\n-                            (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                            (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                            (None, _)        => return None,\n+                            Some(('-', src)) => (false, from_str::<uint>(src)),\n+                            Some(('+', src)) => (true,  from_str::<uint>(src)),\n+                            Some((_, _))     => (true,  from_str::<uint>(src)),\n+                            None             => return None,\n                         };\n \n                         match (is_positive, exp) {\n@@ -1604,7 +1604,7 @@ macro_rules! from_str_radix_int_impl {\n                 let is_signed_ty = (0 as $T) > Int::min_value();\n \n                 match src.slice_shift_char() {\n-                    (Some('-'), src) if is_signed_ty => {\n+                    Some(('-', src)) if is_signed_ty => {\n                         // The number is negative\n                         let mut result = 0;\n                         for c in src.chars() {\n@@ -1623,7 +1623,7 @@ macro_rules! from_str_radix_int_impl {\n                         }\n                         Some(result)\n                     },\n-                    (Some(_), _) => {\n+                    Some((_, _)) => {\n                         // The number is signed\n                         let mut result = 0;\n                         for c in src.chars() {\n@@ -1642,7 +1642,7 @@ macro_rules! from_str_radix_int_impl {\n                         }\n                         Some(result)\n                     },\n-                    (None, _) => None,\n+                    None => None,\n                 }\n             }\n         }"}, {"sha": "4d62c76a54436f6514ca8a750eb103972c5632aa", "filename": "src/libcore/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=197a0ac481ae6d154c0966b21849432f1b32c28f", "patch": "@@ -1808,21 +1808,21 @@ pub trait StrPrelude for Sized? {\n     /// it. This does not allocate a new string; instead, it returns a\n     /// slice that point one character beyond the character that was\n     /// shifted. If the string does not contain any characters,\n-    /// a tuple of None and an empty string is returned instead.\n+    /// None is returned instead.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char();\n-    /// assert_eq!(c, Some('L'));\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n+    /// assert_eq!(c, 'L');\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n-    /// let (c, s2) = s1.slice_shift_char();\n-    /// assert_eq!(c, Some('\u00f6'));\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    fn slice_shift_char<'a>(&'a self) -> (Option<char>, &'a str);\n+    fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n@@ -2194,13 +2194,13 @@ impl StrPrelude for str {\n     }\n \n     #[inline]\n-    fn slice_shift_char(&self) -> (Option<char>, &str) {\n+    fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {\n-            return (None, self);\n+            None\n         } else {\n             let CharRange {ch, next} = self.char_range_at(0u);\n             let next_s = unsafe { raw::slice_bytes(self, next, self.len()) };\n-            return (Some(ch), next_s);\n+            Some((ch, next_s))\n         }\n     }\n "}, {"sha": "dc9e62cabfff47b027de6a2f865881357e107953", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=197a0ac481ae6d154c0966b21849432f1b32c28f", "patch": "@@ -96,8 +96,8 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n                     let output = match constraint.get().slice_shift_char() {\n-                        (Some('='), _) => None,\n-                        (Some('+'), operand) => {\n+                        Some(('=', _)) => None,\n+                        Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(format!(\n                                         \"={}\",\n                                         operand).as_slice()))"}, {"sha": "a78b7b10de8b5643e42e1fb56c14e6b153afa132", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197a0ac481ae6d154c0966b21849432f1b32c28f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=197a0ac481ae6d154c0966b21849432f1b32c28f", "patch": "@@ -1853,7 +1853,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, a.outputs.as_slice(),\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.get().slice_shift_char() {\n-                        (Some('='), operand) if is_rw => {\n+                        Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(format!(\"+{}\", operand).as_slice(),\n                                                 ast::CookedStr))\n                         }"}]}