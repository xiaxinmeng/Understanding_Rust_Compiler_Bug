{"sha": "9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "node_id": "C_kwDOAAsO6NoAKDlhNzY3YjZiOWUxZTUzYzNjZmMyNTEwM2VkN2M4OGQ3N2VlNjVkNWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T20:54:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T20:54:31Z"}, "message": "Auto merge of #110820 - cjgillot:faster-dcp, r=oli-obk\n\nOptimize dataflow-const-prop place-tracking infra\n\nOptimization opportunities found while investigating https://github.com/rust-lang/rust/pull/110719\n\nComputing places breadth-first ensures that we create short projections before deep projections, since the former are more likely to be propagated.\n\nThe most relevant is the pre-computation of flooded places. Callgrind showed `flood_*` methods and especially `preorder_preinvoke` were especially hot. This PR attempts to pre-compute the set of `ValueIndex` that `preorder_invoke` would visit.\n\nUsing this information, we make some `PlaceIndex` inaccessible when they contain no `ValueIndex`, allowing to skip computations for those places.\n\ncc `@jachris` as original author", "tree": {"sha": "98c9f7d991e6cf7503a1476aab221fa3beb088cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c9f7d991e6cf7503a1476aab221fa3beb088cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "html_url": "https://github.com/rust-lang/rust/commit/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba14074bb4cc12bfe918eabd0d52a3999b2a461", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba14074bb4cc12bfe918eabd0d52a3999b2a461", "html_url": "https://github.com/rust-lang/rust/commit/cba14074bb4cc12bfe918eabd0d52a3999b2a461"}, {"sha": "ccc1da247bf3be7e71932844484847da6e35f185", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1da247bf3be7e71932844484847da6e35f185", "html_url": "https://github.com/rust-lang/rust/commit/ccc1da247bf3be7e71932844484847da6e35f185"}], "stats": {"total": 324, "additions": 183, "deletions": 141}, "files": [{"sha": "3952f44ad489dfb0f4bd01158ad218de56b5fec4", "filename": "compiler/rustc_mir_dataflow/src/framework/lattice.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs?ref=9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "patch": "@@ -75,12 +75,12 @@ pub trait MeetSemiLattice: Eq {\n \n /// A set that has a \"bottom\" element, which is less than or equal to any other element.\n pub trait HasBottom {\n-    fn bottom() -> Self;\n+    const BOTTOM: Self;\n }\n \n /// A set that has a \"top\" element, which is greater than or equal to any other element.\n pub trait HasTop {\n-    fn top() -> Self;\n+    const TOP: Self;\n }\n \n /// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom:\n@@ -113,15 +113,11 @@ impl MeetSemiLattice for bool {\n }\n \n impl HasBottom for bool {\n-    fn bottom() -> Self {\n-        false\n-    }\n+    const BOTTOM: Self = false;\n }\n \n impl HasTop for bool {\n-    fn top() -> Self {\n-        true\n-    }\n+    const TOP: Self = true;\n }\n \n /// A tuple (or list) of lattices is itself a lattice whose least upper bound is the concatenation\n@@ -274,13 +270,9 @@ impl<T: Clone + Eq> MeetSemiLattice for FlatSet<T> {\n }\n \n impl<T> HasBottom for FlatSet<T> {\n-    fn bottom() -> Self {\n-        Self::Bottom\n-    }\n+    const BOTTOM: Self = Self::Bottom;\n }\n \n impl<T> HasTop for FlatSet<T> {\n-    fn top() -> Self {\n-        Self::Top\n-    }\n+    const TOP: Self = Self::Top;\n }"}, {"sha": "b74d06e5ae8dd0b02635bcae5f775db179e9e3e1", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 160, "deletions": 110, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "patch": "@@ -32,9 +32,12 @@\n //! Because of that, we can assume that the only way to change the value behind a tracked place is\n //! by direct assignment.\n \n+use std::collections::VecDeque;\n use std::fmt::{Debug, Formatter};\n+use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_index::bit_set::BitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n@@ -65,20 +68,20 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Assign(box (place, rvalue)) => {\n                 self.handle_assign(*place, rvalue, state);\n             }\n-            StatementKind::SetDiscriminant { box ref place, .. } => {\n-                state.flood_discr(place.as_ref(), self.map());\n+            StatementKind::SetDiscriminant { box place, variant_index } => {\n+                self.handle_set_discriminant(*place, *variant_index, state);\n             }\n             StatementKind::Intrinsic(box intrinsic) => {\n                 self.handle_intrinsic(intrinsic, state);\n             }\n             StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n                 // StorageLive leaves the local in an uninitialized state.\n                 // StorageDead makes it UB to access the local afterwards.\n-                state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             StatementKind::Deinit(box place) => {\n                 // Deinit makes the place uninitialized.\n-                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             StatementKind::Retag(..) => {\n                 // We don't track references.\n@@ -92,6 +95,24 @@ pub trait ValueAnalysis<'tcx> {\n         }\n     }\n \n+    fn handle_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_set_discriminant(place, variant_index, state)\n+    }\n+\n+    fn super_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        _variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        state.flood_discr(place.as_ref(), self.map());\n+    }\n+\n     fn handle_intrinsic(\n         &self,\n         intrinsic: &NonDivergingIntrinsic<'tcx>,\n@@ -103,16 +124,18 @@ pub trait ValueAnalysis<'tcx> {\n     fn super_intrinsic(\n         &self,\n         intrinsic: &NonDivergingIntrinsic<'tcx>,\n-        state: &mut State<Self::Value>,\n+        _state: &mut State<Self::Value>,\n     ) {\n         match intrinsic {\n             NonDivergingIntrinsic::Assume(..) => {\n                 // Could use this, but ignoring it is sound.\n             }\n-            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping { dst, .. }) => {\n-                if let Some(place) = dst.place() {\n-                    state.flood(place.as_ref(), self.map());\n-                }\n+            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping {\n+                dst: _,\n+                src: _,\n+                count: _,\n+            }) => {\n+                // This statement represents `*dst = *src`, `count` times.\n             }\n         }\n     }\n@@ -154,7 +177,7 @@ pub trait ValueAnalysis<'tcx> {\n             Rvalue::CopyForDeref(place) => self.handle_operand(&Operand::Copy(*place), state),\n             Rvalue::Ref(..) | Rvalue::AddressOf(..) => {\n                 // We don't track such places.\n-                ValueOrPlace::top()\n+                ValueOrPlace::TOP\n             }\n             Rvalue::Repeat(..)\n             | Rvalue::ThreadLocalRef(..)\n@@ -168,7 +191,7 @@ pub trait ValueAnalysis<'tcx> {\n             | Rvalue::Aggregate(..)\n             | Rvalue::ShallowInitBox(..) => {\n                 // No modification is possible through these r-values.\n-                ValueOrPlace::top()\n+                ValueOrPlace::TOP\n             }\n         }\n     }\n@@ -196,7 +219,7 @@ pub trait ValueAnalysis<'tcx> {\n                 self.map()\n                     .find(place.as_ref())\n                     .map(ValueOrPlace::Place)\n-                    .unwrap_or(ValueOrPlace::top())\n+                    .unwrap_or(ValueOrPlace::TOP)\n             }\n         }\n     }\n@@ -214,7 +237,7 @@ pub trait ValueAnalysis<'tcx> {\n         _constant: &Constant<'tcx>,\n         _state: &mut State<Self::Value>,\n     ) -> Self::Value {\n-        Self::Value::top()\n+        Self::Value::TOP\n     }\n \n     /// The effect of a successful function call return should not be\n@@ -229,7 +252,7 @@ pub trait ValueAnalysis<'tcx> {\n                 // Effect is applied by `handle_call_return`.\n             }\n             TerminatorKind::Drop { place, .. } => {\n-                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase.\n@@ -307,7 +330,7 @@ impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper\n     fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n         // The initial state maps all tracked places of argument projections to \u22a4 and the rest to \u22a5.\n         assert!(matches!(state.0, StateData::Unreachable));\n-        let values = IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count);\n+        let values = IndexVec::from_elem_n(T::Value::BOTTOM, self.0.map().value_count);\n         *state = State(StateData::Reachable(values));\n         for arg in body.args_iter() {\n             state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map());\n@@ -437,7 +460,7 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     }\n \n     pub fn flood_all(&mut self) {\n-        self.flood_all_with(V::top())\n+        self.flood_all_with(V::TOP)\n     }\n \n     pub fn flood_all_with(&mut self, value: V) {\n@@ -447,28 +470,24 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, None, &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, None, &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n     pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n-        self.flood_with(place, map, V::top())\n+        self.flood_with(place, map, V::TOP)\n     }\n \n     pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n     pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map) {\n-        self.flood_discr_with(place, map, V::top())\n+        self.flood_discr_with(place, map, V::TOP)\n     }\n \n     /// Low-level method that assigns to a place.\n@@ -538,26 +557,26 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n     pub fn get(&self, place: PlaceRef<'_>, map: &Map) -> V {\n-        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n+        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::TOP)\n     }\n \n     /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n     pub fn get_discr(&self, place: PlaceRef<'_>, map: &Map) -> V {\n         match map.find_discr(place) {\n             Some(place) => self.get_idx(place, map),\n-            None => V::top(),\n+            None => V::TOP,\n         }\n     }\n \n     /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n             StateData::Reachable(values) => {\n-                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::top())\n+                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::TOP)\n             }\n             StateData::Unreachable => {\n                 // Because this is unreachable, we can return any value we want.\n-                V::bottom()\n+                V::BOTTOM\n             }\n         }\n     }\n@@ -588,6 +607,9 @@ pub struct Map {\n     projections: FxHashMap<(PlaceIndex, TrackElem), PlaceIndex>,\n     places: IndexVec<PlaceIndex, PlaceInfo>,\n     value_count: usize,\n+    // The Range corresponds to a slice into `inner_values_buffer`.\n+    inner_values: IndexVec<PlaceIndex, Range<usize>>,\n+    inner_values_buffer: Vec<ValueIndex>,\n }\n \n impl Map {\n@@ -597,6 +619,8 @@ impl Map {\n             projections: FxHashMap::default(),\n             places: IndexVec::new(),\n             value_count: 0,\n+            inner_values: IndexVec::new(),\n+            inner_values_buffer: Vec::new(),\n         }\n     }\n \n@@ -608,12 +632,12 @@ impl Map {\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        filter: impl FnMut(Ty<'tcx>) -> bool,\n-        place_limit: Option<usize>,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n+        value_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n         let exclude = excluded_locals(body);\n-        map.register_with_filter(tcx, body, filter, exclude, place_limit);\n+        map.register_with_filter(tcx, body, filter, exclude, value_limit);\n         debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n@@ -623,51 +647,90 @@ impl Map {\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        mut filter: impl FnMut(Ty<'tcx>) -> bool,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n         exclude: BitSet<Local>,\n-        place_limit: Option<usize>,\n+        value_limit: Option<usize>,\n     ) {\n-        // We use this vector as stack, pushing and popping projections.\n-        let mut projection = Vec::new();\n+        let mut worklist = VecDeque::with_capacity(value_limit.unwrap_or(body.local_decls.len()));\n+\n+        // Start by constructing the places for each bare local.\n+        self.locals = IndexVec::from_elem(None, &body.local_decls);\n         for (local, decl) in body.local_decls.iter_enumerated() {\n-            if !exclude.contains(local) {\n-                self.register_with_filter_rec(\n-                    tcx,\n-                    local,\n-                    &mut projection,\n-                    decl.ty,\n-                    &mut filter,\n-                    place_limit,\n-                );\n+            if exclude.contains(local) {\n+                continue;\n             }\n+\n+            // Create a place for the local.\n+            debug_assert!(self.locals[local].is_none());\n+            let place = self.places.push(PlaceInfo::new(None));\n+            self.locals[local] = Some(place);\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, decl.ty, &filter, &mut worklist);\n         }\n+\n+        // `place.elem1.elem2` with type `ty`.\n+        // `elem1` is either `Some(Variant(i))` or `None`.\n+        while let Some((mut place, elem1, elem2, ty)) = worklist.pop_front() {\n+            // The user requires a bound on the number of created values.\n+            if let Some(value_limit) = value_limit && self.value_count >= value_limit {\n+                break\n+            }\n+\n+            // Create a place for this projection.\n+            for elem in [elem1, Some(elem2)].into_iter().flatten() {\n+                place = *self.projections.entry((place, elem)).or_insert_with(|| {\n+                    // Prepend new child to the linked list.\n+                    let next = self.places.push(PlaceInfo::new(Some(elem)));\n+                    self.places[next].next_sibling = self.places[place].first_child;\n+                    self.places[place].first_child = Some(next);\n+                    next\n+                });\n+            }\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, ty, &filter, &mut worklist);\n+        }\n+\n+        // Pre-compute the tree of ValueIndex nested in each PlaceIndex.\n+        // `inner_values_buffer[inner_values[place]]` is the set of all the values\n+        // reachable by projecting `place`.\n+        self.inner_values_buffer = Vec::with_capacity(self.value_count);\n+        self.inner_values = IndexVec::from_elem(0..0, &self.places);\n+        for local in body.local_decls.indices() {\n+            if let Some(place) = self.locals[local] {\n+                self.cache_preorder_invoke(place);\n+            }\n+        }\n+\n+        // Trim useless places.\n+        for opt_place in self.locals.iter_mut() {\n+            if let Some(place) = *opt_place && self.inner_values[place].is_empty() {\n+                *opt_place = None;\n+            }\n+        }\n+        #[allow(rustc::potential_query_instability)]\n+        self.projections.retain(|_, child| !self.inner_values[*child].is_empty());\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n     /// Invariant: The projection must only contain trackable elements.\n-    fn register_with_filter_rec<'tcx>(\n+    fn register_children<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        local: Local,\n-        projection: &mut Vec<PlaceElem<'tcx>>,\n+        place: PlaceIndex,\n         ty: Ty<'tcx>,\n-        filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n-        place_limit: Option<usize>,\n+        filter: &impl Fn(Ty<'tcx>) -> bool,\n+        worklist: &mut VecDeque<(PlaceIndex, Option<TrackElem>, TrackElem, Ty<'tcx>)>,\n     ) {\n-        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n-            return\n-        }\n-\n-        // We know that the projection only contains trackable elements.\n-        let place = self.make_place(local, projection).unwrap();\n-\n         // Allocate a value slot if it doesn't have one, and the user requested one.\n         if self.places[place].value_index.is_none() && filter(ty) {\n             self.places[place].value_index = Some(self.value_count.into());\n             self.value_count += 1;\n         }\n \n+        // For enums, directly create the `Discriminant`, as that's their main use.\n         if ty.is_enum() {\n             let discr_ty = ty.discriminant_ty(tcx);\n             if filter(discr_ty) {\n@@ -692,46 +755,32 @@ impl Map {\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, ty::ParamEnv::reveal_all(), |variant, field, ty| {\n-            if let Some(variant) = variant {\n-                projection.push(PlaceElem::Downcast(None, variant));\n-                let _ = self.make_place(local, projection);\n-                projection.push(PlaceElem::Field(field, ty));\n-                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-                projection.pop();\n-                projection.pop();\n-                return;\n-            }\n-            projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-            projection.pop();\n+            worklist.push_back((\n+                place,\n+                variant.map(TrackElem::Variant),\n+                TrackElem::Field(field),\n+                ty,\n+            ))\n         });\n     }\n \n-    /// Tries to add the place to the map, without allocating a value slot.\n-    ///\n-    /// Can fail if the projection contains non-trackable elements.\n-    fn make_place<'tcx>(\n-        &mut self,\n-        local: Local,\n-        projection: &[PlaceElem<'tcx>],\n-    ) -> Result<PlaceIndex, ()> {\n-        // Get the base index of the local.\n-        let mut index =\n-            *self.locals.get_or_insert_with(local, || self.places.push(PlaceInfo::new(None)));\n-\n-        // Apply the projection.\n-        for &elem in projection {\n-            let elem = elem.try_into()?;\n-            index = *self.projections.entry((index, elem)).or_insert_with(|| {\n-                // Prepend new child to the linked list.\n-                let next = self.places.push(PlaceInfo::new(Some(elem)));\n-                self.places[next].next_sibling = self.places[index].first_child;\n-                self.places[index].first_child = Some(next);\n-                next\n-            });\n+    /// Precompute the list of values inside `root` and store it inside\n+    /// as a slice within `inner_values_buffer`.\n+    fn cache_preorder_invoke(&mut self, root: PlaceIndex) {\n+        let start = self.inner_values_buffer.len();\n+        if let Some(vi) = self.places[root].value_index {\n+            self.inner_values_buffer.push(vi);\n+        }\n+\n+        // We manually iterate instead of using `children` as we need to mutate `self`.\n+        let mut next_child = self.places[root].first_child;\n+        while let Some(child) = next_child {\n+            ensure_sufficient_stack(|| self.cache_preorder_invoke(child));\n+            next_child = self.places[child].next_sibling;\n         }\n \n-        Ok(index)\n+        let end = self.inner_values_buffer.len();\n+        self.inner_values[root] = start..end;\n     }\n \n     /// Returns the number of tracked places, i.e., those for which a value can be stored.\n@@ -750,7 +799,7 @@ impl Map {\n         place: PlaceRef<'_>,\n         extra: impl IntoIterator<Item = TrackElem>,\n     ) -> Option<PlaceIndex> {\n-        let mut index = *self.locals.get(place.local)?.as_ref()?;\n+        let mut index = *self.locals[place.local].as_ref()?;\n \n         for &elem in place.projection {\n             index = self.apply(index, elem.try_into().ok()?)?;\n@@ -784,17 +833,17 @@ impl Map {\n     ///\n     /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n     /// as such.\n-    pub fn for_each_aliasing_place(\n+    fn for_each_aliasing_place(\n         &self,\n         place: PlaceRef<'_>,\n         tail_elem: Option<TrackElem>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n-        if place.is_indirect() {\n+        if place.has_deref() {\n             // We do not track indirect places.\n             return;\n         }\n-        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+        let Some(mut index) = self.locals[place.local] else {\n             // The local is not tracked at all, so it does not alias anything.\n             return;\n         };\n@@ -805,7 +854,9 @@ impl Map {\n             .chain(tail_elem.map(Ok).into_iter());\n         for elem in elems {\n             // A field aliases the parent place.\n-            f(index);\n+            if let Some(vi) = self.places[index].value_index {\n+                f(vi);\n+            }\n \n             let Ok(elem) = elem else { return };\n             let sub = self.apply(index, elem);\n@@ -819,15 +870,15 @@ impl Map {\n                 return;\n             }\n         }\n-        self.preorder_invoke(index, f);\n+        self.for_each_value_inside(index, f);\n     }\n \n     /// Invoke the given function on all the descendants of the given place, except one branch.\n     fn for_each_variant_sibling(\n         &self,\n         parent: PlaceIndex,\n         preserved_child: Option<PlaceIndex>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n         for sibling in self.children(parent) {\n             let elem = self.places[sibling].proj_elem;\n@@ -837,16 +888,17 @@ impl Map {\n                 // Only invalidate the other variants, the current one is fine.\n                 && Some(sibling) != preserved_child\n             {\n-                self.preorder_invoke(sibling, f);\n+                self.for_each_value_inside(sibling, f);\n             }\n         }\n     }\n \n-    /// Invoke a function on the given place and all descendants.\n-    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n-        f(root);\n-        for child in self.children(root) {\n-            self.preorder_invoke(child, f);\n+    /// Invoke a function on each value in the given place and all descendants.\n+    fn for_each_value_inside(&self, root: PlaceIndex, f: &mut impl FnMut(ValueIndex)) {\n+        let range = self.inner_values[root].clone();\n+        let values = &self.inner_values_buffer[range];\n+        for &v in values {\n+            f(v)\n         }\n     }\n }\n@@ -909,9 +961,7 @@ pub enum ValueOrPlace<V> {\n }\n \n impl<V: HasTop> ValueOrPlace<V> {\n-    pub fn top() -> Self {\n-        ValueOrPlace::Value(V::top())\n-    }\n+    pub const TOP: Self = ValueOrPlace::Value(V::TOP);\n }\n \n /// The set of projection elements that can be used by a tracked place."}, {"sha": "7adfc9dff2ae9f5bb93474d6e28cfe5b53cedc86", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "patch": "@@ -79,22 +79,22 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n         &self.map\n     }\n \n-    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n-        match statement.kind {\n-            StatementKind::SetDiscriminant { box ref place, variant_index } => {\n-                state.flood_discr(place.as_ref(), &self.map);\n-                if self.map.find_discr(place.as_ref()).is_some() {\n-                    let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n-                    if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n-                        state.assign_discr(\n-                            place.as_ref(),\n-                            ValueOrPlace::Value(FlatSet::Elem(discr)),\n-                            &self.map,\n-                        );\n-                    }\n-                }\n+    fn handle_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        state.flood_discr(place.as_ref(), &self.map);\n+        if self.map.find_discr(place.as_ref()).is_some() {\n+            let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n+            if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n+                state.assign_discr(\n+                    place.as_ref(),\n+                    ValueOrPlace::Value(FlatSet::Elem(discr)),\n+                    &self.map,\n+                );\n             }\n-            _ => self.super_statement(statement, state),\n         }\n     }\n \n@@ -208,8 +208,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                     _ => unreachable!(),\n                 }\n                 .map(|result| ValueOrPlace::Value(self.wrap_immediate(result, *ty)))\n-                .unwrap_or(ValueOrPlace::top()),\n-                _ => ValueOrPlace::top(),\n+                .unwrap_or(ValueOrPlace::TOP),\n+                _ => ValueOrPlace::TOP,\n             },\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 // Overflows must be ignored here."}]}