{"sha": "adff46250ed9e9b3c31da65b2997a5458e41305a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZmY0NjI1MGVkOWU5YjNjMzFkYTY1YjI5OTdhNTQ1OGU0MTMwNWE=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-17T15:42:05Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-17T15:42:05Z"}, "message": "Fixed rebase fallout .", "tree": {"sha": "bff151218e17bf8409b8a40750af48a192328eb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bff151218e17bf8409b8a40750af48a192328eb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adff46250ed9e9b3c31da65b2997a5458e41305a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adff46250ed9e9b3c31da65b2997a5458e41305a", "html_url": "https://github.com/rust-lang/rust/commit/adff46250ed9e9b3c31da65b2997a5458e41305a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adff46250ed9e9b3c31da65b2997a5458e41305a/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e682e29eb8f5ddaf36e6374f46d8d8ac364d824", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e682e29eb8f5ddaf36e6374f46d8d8ac364d824", "html_url": "https://github.com/rust-lang/rust/commit/1e682e29eb8f5ddaf36e6374f46d8d8ac364d824"}], "stats": {"total": 252, "additions": 122, "deletions": 130}, "files": [{"sha": "835dd55711b5739d181e65f1f1f02b5419a9a9ed", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=adff46250ed9e9b3c31da65b2997a5458e41305a", "patch": "@@ -294,8 +294,6 @@ pub mod llvm {\n         pub unsafe fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n-        #[fast_ffi]\n-        pub unsafe fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n \n         /** Data layout. See Module::getDataLayout. */\n         #[fast_ffi]"}, {"sha": "55fc22a8fcc02856c9af1169c782c084b5b40aa6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=adff46250ed9e9b3c31da65b2997a5458e41305a", "patch": "@@ -3080,7 +3080,6 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.name.to_owned() + \".rc\";\n \n-            Some(debuginfo::mk_ctxt(llmod, copy llmod_id))\n     // FIXME(#6511): get LLVM building with --enable-threads so this\n     //               function can be called\n     // if !llvm::LLVMRustStartMultithreading() {\n@@ -3109,9 +3108,9 @@ pub fn trans_crate(sess: session::Session,\n     fill_crate_map(ccx, ccx.crate_map);\n     glue::emit_tydescs(ccx);\n     write_abi_version(ccx);\n-        if ccx.sess.opts.debuginfo {\n-            debuginfo::finalize(ccx);\n-        }\n+    if ccx.sess.opts.debuginfo {\n+        debuginfo::finalize(ccx);\n+    }\n \n     // Translate the metadata.\n     write_metadata(ccx, crate);"}, {"sha": "7aab1d0239e6f0ee469fde14b86a0235e6bcb5c2", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=adff46250ed9e9b3c31da65b2997a5458e41305a", "patch": "@@ -148,7 +148,7 @@ impl CrateContext {\n             lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n-                Some(debuginfo::mk_ctxt(name.to_owned()))\n+                Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n             } else {\n                 None\n             };"}, {"sha": "91e3276d8aa644b83a1afce655e7ae97ed761a32", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 115, "deletions": 122, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=adff46250ed9e9b3c31da65b2997a5458e41305a", "patch": "@@ -58,9 +58,7 @@ static DW_ATE_unsigned_char: int = 0x08;\n \n ////////////////\n \n-pub type DebugContext = @mut _DebugContext;\n-\n-struct _DebugContext {\n+pub struct DebugContext {\n     names: namegen,\n     crate_file: ~str,\n     llcontext: ContextRef,\n@@ -72,39 +70,43 @@ struct _DebugContext {\n     created_types: HashMap<uint, DIType>\n }\n \n-/// Create new DebugContext\n-pub fn mk_ctxt(llmod: ModuleRef, crate: ~str) -> DebugContext {\n-    debug!(\"mk_ctxt\");\n-    let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n-    // DIBuilder inherits context from the module, so we'd better use the same one\n-    let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n-    let dcx = @mut _DebugContext {\n-        names: new_namegen(),\n-        crate_file: crate,\n-        llcontext: llcontext,\n-        builder: builder,\n-        curr_loc: (0, 0),\n-        created_files: HashMap::new(),\n-        created_functions: HashMap::new(),\n-        created_blocks: HashMap::new(),\n-        created_types: HashMap::new(),\n-    };\n-    return dcx;\n+impl DebugContext {\n+    pub fn new(llmod: ModuleRef, crate: ~str) -> DebugContext {\n+        debug!(\"DebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return DebugContext {\n+            names: new_namegen(),\n+            crate_file: crate,\n+            llcontext: llcontext,\n+            builder: builder,\n+            curr_loc: (0, 0),\n+            created_files: HashMap::new(),\n+            created_functions: HashMap::new(),\n+            created_blocks: HashMap::new(),\n+            created_types: HashMap::new(),\n+        };\n+    }\n }\n \n-#[inline(always)]\n-fn dbg_cx(cx: &CrateContext) -> DebugContext {\n-    return cx.dbg_cx.get();\n+#[inline]\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+    cx.dbg_cx.get_mut_ref()\n+}\n+\n+#[inline]\n+fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx.get_ref().builder\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: @CrateContext) {\n+pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n     create_compile_unit(cx);\n-    let dcx = dbg_cx(cx);\n     unsafe {\n-        llvm::LLVMDIBuilderFinalize(dcx.builder);\n-        llvm::LLVMDIBuilderDispose(dcx.builder);\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n     };\n }\n \n@@ -114,8 +116,9 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn create_compile_unit(cx: @CrateContext) {\n-    let crate_name: &str = dbg_cx(cx).crate_file;\n+fn create_compile_unit(cx: @mut CrateContext) {\n+    let dcx = dbg_cx(cx);\n+    let crate_name: &str = dcx.crate_file;\n     let work_dir = cx.sess.working_dir.to_str();\n     let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n \n@@ -124,17 +127,15 @@ fn create_compile_unit(cx: @CrateContext) {\n     do as_c_str(producer) |producer| {\n     do as_c_str(\"\") |flags| {\n     do as_c_str(\"\") |split_name| { unsafe {\n-        llvm::LLVMDIBuilderCreateCompileUnit(dbg_cx(cx).builder,\n+        llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n             DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n             cx.sess.opts.optimize != session::No,\n             flags, 0, split_name);\n     }}}}}};\n }\n \n-fn create_file(cx: @CrateContext, full_path: &str) -> DIFile {\n-    let dcx = dbg_cx(cx);\n-\n-    match dcx.created_files.find_equiv(&full_path) {\n+fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n+    match dbg_cx(cx).created_files.find_equiv(&full_path) {\n         Some(file_md) => return *file_md,\n         None => ()\n     }\n@@ -152,22 +153,21 @@ fn create_file(cx: @CrateContext, full_path: &str) -> DIFile {\n     let file_md =\n         do as_c_str(file_name) |file_name| {\n         do as_c_str(work_dir) |work_dir| { unsafe {\n-            llvm::LLVMDIBuilderCreateFile(dcx.builder, file_name, work_dir)\n+            llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n         }}};\n \n-    dcx.created_files.insert(full_path.to_owned(), file_md);\n+    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_md);\n     return file_md;\n }\n \n /// Return codemap::Loc corresponding to the beginning of the span\n-fn span_start(cx: @CrateContext, span: span) -> codemap::Loc {\n+fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n     return cx.sess.codemap.lookup_char_pos(span.lo);\n }\n \n fn create_block(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n     let cx = bcx.ccx();\n-    let dcx = dbg_cx(cx);\n \n     while bcx.node_info.is_none() {\n         match bcx.parent {\n@@ -178,7 +178,7 @@ fn create_block(bcx: block) -> DILexicalBlock {\n     let span = bcx.node_info.get().span;\n     let id = bcx.node_info.get().id;\n \n-    match dcx.created_blocks.find(&id) {\n+    match dbg_cx(cx).created_blocks.find(&id) {\n         Some(block) => return *block,\n         None => ()\n     }\n@@ -195,25 +195,24 @@ fn create_block(bcx: block) -> DILexicalBlock {\n \n     let block_md = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n-            dcx.builder,\n+            DIB(cx),\n             parent, file_md,\n             loc.line as c_uint, loc.col.to_uint() as c_uint)\n     };\n \n-    dcx.created_blocks.insert(id, block_md);\n+    dbg_cx(cx).created_blocks.insert(id, block_md);\n \n     return block_md;\n }\n \n-fn size_and_align_of(cx: @CrateContext, t: ty::t) -> (uint, uint) {\n+fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n     (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n }\n \n-fn create_basic_type(cx: @CrateContext, t: ty::t, _span: span) -> DIType{\n-    let dcx = dbg_cx(cx);\n+fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n-    match dcx.created_types.find(&ty_id) {\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n         None => ()\n     }\n@@ -249,26 +248,26 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, _span: span) -> DIType{\n     let (size, align) = size_and_align_of(cx, t);\n     let ty_md = do as_c_str(name) |name| { unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n-                dcx.builder, name,\n+                DIB(cx), name,\n                 size * 8 as u64, align * 8 as u64, encoding as c_uint)\n         }};\n \n-    dcx.created_types.insert(ty_id, ty_md);\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n \n-fn create_pointer_type(cx: @CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n+fn create_pointer_type(cx: @mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n     let name = ty_to_str(cx.tcx, t);\n     let ptr_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder,\n+        llvm::LLVMDIBuilderCreatePointerType(DIB(cx),\n                 pointee, size * 8 as u64, align * 8 as u64, name)\n     }};\n     return ptr_md;\n }\n \n struct StructContext {\n-    cx: @CrateContext,\n+    builder: DIBuilderRef,\n     file: DIFile,\n     name: ~str,\n     line: uint,\n@@ -278,10 +277,10 @@ struct StructContext {\n }\n \n impl StructContext {\n-    fn create(cx: @CrateContext, file: DIFile, name: ~str, line: uint) -> ~StructContext {\n+    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> ~StructContext {\n         debug!(\"StructContext::create: %s\", name);\n         let scx = ~StructContext {\n-            cx: cx,\n+            builder: DIB(cx),\n             file: file,\n             name: name,\n             line: line,\n@@ -297,8 +296,8 @@ impl StructContext {\n                 self.name, name, size, align);\n         let offset = roundup(self.total_size, align);\n         let mem_t = do as_c_str(name) |name| { unsafe {\n-            llvm::LLVMDIBuilderCreateMemberType(dbg_cx(self.cx).builder,\n-                ptr::null(), name, self.file, line as c_uint,\n+            llvm::LLVMDIBuilderCreateMemberType(\n+                self.builder, ptr::null(), name, self.file, line as c_uint,\n                 size * 8 as u64, align * 8 as u64, offset * 8 as u64,\n                 0, ty)\n             }};\n@@ -311,13 +310,12 @@ impl StructContext {\n     fn finalize(&self) -> DICompositeType {\n         debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n                 self.name, self.total_size, self.align);\n-        let dcx = dbg_cx(self.cx);\n-        let members_md = create_DIArray(dcx.builder, self.members);\n+        let members_md = create_DIArray(self.builder, self.members);\n \n         let struct_md =\n             do as_c_str(self.name) |name| { unsafe {\n                 llvm::LLVMDIBuilderCreateStructType(\n-                    dcx.builder, self.file, name,\n+                    self.builder, self.file, name,\n                     self.file, self.line as c_uint,\n                     self.total_size * 8 as u64, self.align * 8 as u64, 0, ptr::null(),\n                     members_md, 0, ptr::null())\n@@ -326,45 +324,44 @@ impl StructContext {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn roundup(x: uint, a: uint) -> uint {\n     ((x + (a - 1)) / a) * a\n }\n \n-fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field], span: span) -> DICompositeType {\n+fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n+                -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n-    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, t), loc.line);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        scx.add_member(cx.sess.str_of(field.ident),\n-                   loc.line, size, align, ty_md);\n+        scx.add_member(cx.sess.str_of(field.ident), loc.line, size, align, ty_md);\n     }\n     return scx.finalize();\n }\n \n // returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr(cx: @CrateContext) -> (DIDerivedType, uint, uint) {\n+fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n     let size = sys::size_of::<ValueRef>();\n     let align = sys::min_align_of::<ValueRef>();\n     let vp = do as_c_str(\"*void\") |name| { unsafe {\n-            llvm::LLVMDIBuilderCreatePointerType(dbg_cx(cx).builder, ptr::null(),\n+            llvm::LLVMDIBuilderCreatePointerType(DIB(cx), ptr::null(),\n                 size*8 as u64, align*8 as u64, name)\n         }};\n     return (vp, size, align);\n }\n \n-fn create_tuple(cx: @CrateContext, _t: ty::t, elements: &[ty::t], span: span) -> DICompositeType {\n-    let dcx = dbg_cx(cx);\n+fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span)\n+                -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n-    let name = (cx.sess.str_of((dcx.names)(\"tuple\"))).to_owned();\n-    let mut scx = StructContext::create(cx, file_md, name, loc.line);\n-\n+    let name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n+    let mut scx = StructContext::new(cx, name, file_md, loc.line);\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n@@ -373,15 +370,15 @@ fn create_tuple(cx: @CrateContext, _t: ty::t, elements: &[ty::t], span: span) ->\n     return scx.finalize();\n }\n \n-fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n+fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n                      span: span, boxed: DIType) -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n \n-    let mut scx = StructContext::create(cx, file_md, fmt!(\"box<%s>\", name), 0);\n+    let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n     scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n                sys::min_align_of::<uint>(), refcount_type);\n     // the tydesc and other pointers should be irrelevant to the\n@@ -395,48 +392,50 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n     return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: @CrateContext, _vec_t: ty::t, elem_t: ty::t,\n+fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n-    let dcx = dbg_cx(cx);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n \n     let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(dcx.builder, 0_i64, len as i64) };\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, len as i64)\n+    };\n \n-    let subscripts = create_DIArray(dcx.builder, [subrange]);\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n     return unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(dcx.builder,\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n             size * len * 8 as u64, align * 8 as u64, elem_ty_md, subscripts)\n     };\n }\n \n-fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     vec_ty_span: span) -> DICompositeType {\n-    let dcx = dbg_cx(cx);\n     let loc = span_start(cx, vec_ty_span);\n     let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n \n-    let mut vec_scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n-\n+    let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n     vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n                sys::min_align_of::<libc::size_t>(), size_t_type);\n     vec_scx.add_member(\"alloc\", 0, sys::size_of::<libc::size_t>(),\n                sys::min_align_of::<libc::size_t>(), size_t_type);\n-    let subrange = unsafe { llvm::LLVMDIBuilderGetOrCreateSubrange(dcx.builder, 0_i64, 0_i64) };\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n+    };\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n \n-    let subscripts = create_DIArray(dcx.builder, [subrange]);\n-    let data_ptr = unsafe { llvm::LLVMDIBuilderCreateArrayType(dcx.builder,\n-                arr_size * 8 as u64, arr_align * 8 as u64, elem_ty_md, subscripts) };\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    let data_ptr = unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n+            arr_size * 8 as u64, arr_align * 8 as u64, elem_ty_md, subscripts)\n+    };\n     vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>(), data_ptr);\n     let vec_md = vec_scx.finalize();\n \n-    let mut box_scx = StructContext::create(cx, file_md, fmt!(\"box<%s>\", name), 0);\n+    let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n     box_scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n@@ -452,24 +451,24 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     return mdval;\n }\n \n-fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span) -> DICompositeType {\n+fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+                    -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n \n-    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let (_, ptr_size, ptr_align) = voidptr(cx);\n     scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n     scx.add_member(\"length\", 0, sys::size_of::<uint>(),\n-               sys::min_align_of::<uint>(), uint_type);\n+                    sys::min_align_of::<uint>(), uint_type);\n     return scx.finalize();\n }\n \n-fn create_fn_ty(cx: @CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> DICompositeType {\n-    let dcx = dbg_cx(cx);\n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n     let (vp, _, _) = voidptr(cx);\n@@ -479,26 +478,24 @@ fn create_fn_ty(cx: @CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::\n     let members = ~[output_ptr_md, vp] + inputs_vals;\n \n     return unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(dcx.builder, file_md,\n-            create_DIArray(dcx.builder, members))\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_md,\n+            create_DIArray(DIB(cx), members))\n     };\n }\n \n-fn create_unimpl_ty(cx: @CrateContext, t: ty::t) -> DIType {\n-    let dcx = dbg_cx(cx);\n+fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n     let name = ty_to_str(cx.tcx, t);\n     let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateBasicType(\n-            dcx.builder, name,\n+            DIB(cx), name,\n             0_u64, 8_u64, DW_ATE_unsigned as c_uint)\n         }};\n     return md;\n }\n \n-fn create_ty(cx: @CrateContext, t: ty::t, span: span) -> DIType {\n-    let dcx = dbg_cx(cx);\n+fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n-    match dcx.created_types.find(&ty_id) {\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n         None => ()\n     }\n@@ -578,13 +575,12 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span) -> DIType {\n         _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n     };\n \n-    dcx.created_types.insert(ty_id, ty_md);\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n     return ty_md;\n }\n \n pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n-    let dcx = dbg_cx(cx);\n \n     let ident = match local.node.pat.node {\n       ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n@@ -608,7 +604,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n \n     let var_md = do as_c_str(name) |name| { unsafe {\n         llvm::LLVMDIBuilderCreateLocalVariable(\n-            dcx.builder, AutoVariableTag as u32,\n+            DIB(cx), AutoVariableTag as u32,\n             context, name, filemd,\n             loc.line as c_uint, tymd, false, 0, 0)\n         }};\n@@ -625,7 +621,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n \n     set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(dcx.builder, llptr, var_md, bcx.llbb);\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n     }\n \n@@ -641,8 +637,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     }\n \n     let fcx = bcx.fcx;\n-    let cx = *fcx.ccx;\n-    let dcx = dbg_cx(cx);\n+    let cx = fcx.ccx;\n \n     let loc = span_start(cx, span);\n     if \"<intrinsic>\" == loc.file.name {\n@@ -652,15 +647,15 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n     let filemd = create_file(cx, loc.file.name);\n-    let context = create_function(bcx.fcx);\n+    let context = create_function(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n             let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder,\n+                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n                     ArgVariableTag as u32, context, name,\n                     filemd, loc.line as c_uint, tymd, false, 0, 0)\n                     // XXX need to pass in a real argument number\n@@ -670,7 +665,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n             set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        dcx.builder, llptr, mdnode, bcx.llbb);\n+                        DIB(cx), llptr, mdnode, bcx.llbb);\n                 llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n             }\n             return Some(mdnode);\n@@ -681,18 +676,17 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     }\n }\n \n-fn set_debug_location(cx: @CrateContext, scope: DIScope, line: uint, col: uint) {\n-    let dcx = dbg_cx(cx);\n-    if dcx.curr_loc == (line, col) {\n+fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n+    if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n     }\n     debug!(\"setting debug location to %u %u\", line, col);\n-    dcx.curr_loc = (line, col);\n+    dbg_cx(cx).curr_loc = (line, col);\n \n     let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n     unsafe {\n         let dbg_loc = llvm::LLVMMDNodeInContext(\n-                dcx.llcontext, vec::raw::to_ptr(elems),\n+                dbg_cx(cx).llcontext, vec::raw::to_ptr(elems),\n                 elems.len() as libc::c_uint);\n         llvm::LLVMSetCurrentDebugLocation(cx.builder.B, dbg_loc);\n     }\n@@ -709,8 +703,7 @@ pub fn update_source_pos(bcx: block, span: span) {\n }\n \n pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n-    let cx = *fcx.ccx;\n-    let dcx = dbg_cx(cx);\n+    let cx = fcx.ccx;\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n@@ -729,7 +722,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n-            ((dcx.names)(\"fn\"), decl.output, expr.id)\n+            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")\n@@ -738,7 +731,7 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n       _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n-    match dcx.created_functions.find(&id) {\n+    match dbg_cx(cx).created_functions.find(&id) {\n         Some(fn_md) => return *fn_md,\n         None => ()\n     }\n@@ -759,15 +752,15 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     };\n \n     let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(dcx.builder,\n-            file_md, create_DIArray(dcx.builder, [ret_ty_md]))\n-        };\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n+            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n+    };\n \n     let fn_md =\n         do as_c_str(cx.sess.str_of(ident)) |name| {\n         do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n             llvm::LLVMDIBuilderCreateFunction(\n-                dcx.builder,\n+                DIB(cx),\n                 file_md,\n                 name, linkage,\n                 file_md, loc.line as c_uint,\n@@ -778,6 +771,6 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n                 fcx.llfn, ptr::null(), ptr::null())\n             }}};\n \n-    dcx.created_functions.insert(id, fn_md);\n+    dbg_cx(cx).created_functions.insert(id, fn_md);\n     return fn_md;\n }"}, {"sha": "614c1723c5fb75c0710b326e0f6688e59290dcb7", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/adff46250ed9e9b3c31da65b2997a5458e41305a/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=adff46250ed9e9b3c31da65b2997a5458e41305a", "patch": "@@ -565,7 +565,9 @@ extern \"C\" bool LLVMRustStartMultithreading() {\n typedef DIBuilder* DIBuilderRef;\n \n template<typename DIT>\n-DIT unwrapDI(LLVMValueRef ref) { return DIT(ref ? unwrap<MDNode>(ref) : NULL); }\n+DIT unwrapDI(LLVMValueRef ref) { \n+    return DIT(ref ? unwrap<MDNode>(ref) : NULL); \n+}\n \n extern \"C\" DIBuilderRef LLVMDIBuilderCreate(LLVMModuleRef M) {\n     return new DIBuilder(*unwrap(M));"}]}