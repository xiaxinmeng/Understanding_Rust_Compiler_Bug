{"sha": "2f3296192bb5be5fcb02975395052ee8c3b2bd68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzI5NjE5MmJiNWJlNWZjYjAyOTc1Mzk1MDUyZWU4YzNiMmJkNjg=", "commit": {"author": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-15T14:37:19Z"}, "committer": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-18T01:44:11Z"}, "message": "Only visit types once when walking the type tree\n\nThis fixes #72408.\n\nNested closures were resulting in exponential compilation time.\n\nAs a performance optimization this change introduces MiniSet,\nwhich is a simple small storage optimized set.", "tree": {"sha": "01176084735b315f8535a3152fbf2ce41fe54e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01176084735b315f8535a3152fbf2ce41fe54e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3296192bb5be5fcb02975395052ee8c3b2bd68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3296192bb5be5fcb02975395052ee8c3b2bd68", "html_url": "https://github.com/rust-lang/rust/commit/2f3296192bb5be5fcb02975395052ee8c3b2bd68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3296192bb5be5fcb02975395052ee8c3b2bd68/comments", "author": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "255ceeb5ff9875b7f525aa101c8adc155f3e0ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/255ceeb5ff9875b7f525aa101c8adc155f3e0ef8", "html_url": "https://github.com/rust-lang/rust/commit/255ceeb5ff9875b7f525aa101c8adc155f3e0ef8"}], "stats": {"total": 232, "additions": 193, "deletions": 39}, "files": [{"sha": "05d3a9c56219c7f1fac4e7d260e87698b6883bb0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -3733,6 +3733,7 @@ dependencies = [\n name = \"rustc_middle\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"bitflags\",\n  \"chalk-ir\",\n  \"measureme\","}, {"sha": "e06bfb5958086f9ddc414b9fdc7ba4dba4501e46", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -3,6 +3,7 @@ use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc_middle::ty::walk::MiniSet;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n@@ -31,16 +32,23 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// Returns a \"verify bound\" that encodes what we know about\n     /// `generic` and the regions it outlives.\n     pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n+        let mut visited = MiniSet::new();\n         match generic {\n             GenericKind::Param(param_ty) => self.param_bound(param_ty),\n-            GenericKind::Projection(projection_ty) => self.projection_bound(projection_ty),\n+            GenericKind::Projection(projection_ty) => {\n+                self.projection_bound(projection_ty, &mut visited)\n+            }\n         }\n     }\n \n-    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+    fn type_bound(\n+        &self,\n+        ty: Ty<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         match *ty.kind() {\n             ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => self.projection_bound(data),\n+            ty::Projection(data) => self.projection_bound(data, visited),\n             ty::FnDef(_, substs) => {\n                 // HACK(eddyb) ignore lifetimes found shallowly in `substs`.\n                 // This is inconsistent with `ty::Adt` (including all substs),\n@@ -50,9 +58,9 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 let mut bounds = substs\n                     .iter()\n                     .filter_map(|child| match child.unpack() {\n-                        GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                        GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                         GenericArgKind::Lifetime(_) => None,\n-                        GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                        GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n                     })\n                     .filter(|bound| {\n                         // Remove bounds that must hold, since they are not interesting.\n@@ -66,7 +74,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     ),\n                 }\n             }\n-            _ => self.recursive_bound(ty.into()),\n+            _ => self.recursive_bound(ty.into(), visited),\n         }\n     }\n \n@@ -137,7 +145,11 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         self.declared_projection_bounds_from_trait(projection_ty)\n     }\n \n-    pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n+    pub fn projection_bound(\n+        &self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n         let projection_ty_as_ty =\n@@ -166,21 +178,25 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_bound(ty.into());\n+        let recursive_bound = self.recursive_bound(ty.into(), visited);\n \n         VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n-    fn recursive_bound(&self, parent: GenericArg<'tcx>) -> VerifyBound<'tcx> {\n+    fn recursive_bound(\n+        &self,\n+        parent: GenericArg<'tcx>,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n         let mut bounds = parent\n-            .walk_shallow()\n+            .walk_shallow(visited)\n             .filter_map(|child| match child.unpack() {\n-                GenericArgKind::Type(ty) => Some(self.type_bound(ty)),\n+                GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                 GenericArgKind::Lifetime(lt) => {\n                     // Ignore late-bound regions.\n                     if !lt.is_late_bound() { Some(VerifyBound::OutlivedBy(lt)) } else { None }\n                 }\n-                GenericArgKind::Const(_) => Some(self.recursive_bound(child)),\n+                GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n             })\n             .filter(|bound| {\n                 // Remove bounds that must hold, since they are not interesting."}, {"sha": "1d84ddad7f52dd0cdd39d2b1c496925f9375557d", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -28,5 +28,6 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n chalk-ir = \"0.21.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+arrayvec = { version = \"0.5.1\", default-features = false }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "01649f44c8861f4b6403e9b75f274c13107e5ca4", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -3,6 +3,7 @@\n // RFC for reference.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::walk::MiniSet;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use smallvec::SmallVec;\n \n@@ -50,12 +51,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(self, ty0: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-        compute_components(self, ty0, out);\n+        let mut visited = MiniSet::new();\n+        compute_components(self, ty0, out, &mut visited);\n         debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n }\n \n-fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n+fn compute_components(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut MiniSet<GenericArg<'tcx>>,\n+) {\n     // Descend through the types, looking for the various \"base\"\n     // components and collecting them into `out`. This is not written\n     // with `collect()` because of the need to sometimes skip subtrees\n@@ -73,31 +80,31 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 for child in substs {\n                     match child.unpack() {\n                         GenericArgKind::Type(ty) => {\n-                            compute_components(tcx, ty, out);\n+                            compute_components(tcx, ty, out, visited);\n                         }\n                         GenericArgKind::Lifetime(_) => {}\n                         GenericArgKind::Const(_) => {\n-                            compute_components_recursive(tcx, child, out);\n+                            compute_components_recursive(tcx, child, out, visited);\n                         }\n                     }\n                 }\n             }\n \n             ty::Array(element, _) => {\n                 // Don't look into the len const as it doesn't affect regions\n-                compute_components(tcx, element, out);\n+                compute_components(tcx, element, out, visited);\n             }\n \n             ty::Closure(_, ref substs) => {\n                 for upvar_ty in substs.as_closure().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.as_generator().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out);\n+                    compute_components(tcx, upvar_ty, out, visited);\n                 }\n \n                 // We ignore regions in the generator interior as we don't\n@@ -135,7 +142,8 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n-                    compute_components_recursive(tcx, ty.into(), &mut subcomponents);\n+                    let mut subvisited = MiniSet::new();\n+                    compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n                     out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n                 }\n             }\n@@ -177,7 +185,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n                 // the \"bound regions list\".  In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n-                compute_components_recursive(tcx, ty.into(), out);\n+                compute_components_recursive(tcx, ty.into(), out, visited);\n             }\n         }\n }\n@@ -186,11 +194,12 @@ fn compute_components_recursive(\n     tcx: TyCtxt<'tcx>,\n     parent: GenericArg<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n+    visited: &mut MiniSet<GenericArg<'tcx>>,\n ) {\n-    for child in parent.walk_shallow() {\n+    for child in parent.walk_shallow(visited) {\n         match child.unpack() {\n             GenericArgKind::Type(ty) => {\n-                compute_components(tcx, ty, out);\n+                compute_components(tcx, ty, out, visited);\n             }\n             GenericArgKind::Lifetime(lt) => {\n                 // Ignore late-bound regions.\n@@ -199,7 +208,7 @@ fn compute_components_recursive(\n                 }\n             }\n             GenericArgKind::Const(_) => {\n-                compute_components_recursive(tcx, child, out);\n+                compute_components_recursive(tcx, child, out, visited);\n             }\n         }\n     }"}, {"sha": "7afa6e6cc056d4f948e5dc0f8e4a9ca7a9fde3ba", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -3,7 +3,50 @@\n \n use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use arrayvec::ArrayVec;\n+use rustc_data_structures::fx::FxHashSet;\n use smallvec::{self, SmallVec};\n+use std::hash::Hash;\n+\n+/// Small-storage-optimized implementation of a set\n+/// made specifically for walking type tree.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashSet` when that length is exceeded.\n+pub enum MiniSet<T> {\n+    Array(ArrayVec<[T; 8]>),\n+    Set(FxHashSet<T>),\n+}\n+\n+impl<T: Eq + Hash + Copy> MiniSet<T> {\n+    /// Creates an empty `MiniSet`.\n+    pub fn new() -> Self {\n+        MiniSet::Array(ArrayVec::new())\n+    }\n+\n+    /// Adds a value to the set.\n+    ///\n+    /// If the set did not have this value present, true is returned.\n+    ///\n+    /// If the set did have this value present, false is returned.\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        match self {\n+            MiniSet::Array(array) => {\n+                if array.iter().any(|e| *e == elem) {\n+                    false\n+                } else {\n+                    if array.try_push(elem).is_err() {\n+                        let mut set: FxHashSet<T> = array.iter().copied().collect();\n+                        set.insert(elem);\n+                        *self = MiniSet::Set(set);\n+                    }\n+                    true\n+                }\n+            }\n+            MiniSet::Set(set) => set.insert(elem),\n+        }\n+    }\n+}\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n // avoid heap allocations.\n@@ -12,11 +55,20 @@ type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n+    visited: MiniSet<GenericArg<'tcx>>,\n }\n \n+/// An iterator for walking the type tree.\n+///\n+/// It's very easy to produce a deeply\n+/// nested type tree with a lot of\n+/// identical subtrees. In order to work efficiently\n+/// in this situation walker only visits each type once.\n+/// It maintains a set of visited types and\n+/// skips any types that are already there.\n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(root: GenericArg<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: smallvec![root], last_subtree: 1 }\n+    pub fn new(root: GenericArg<'tcx>) -> Self {\n+        Self { stack: smallvec![root], last_subtree: 1, visited: MiniSet::new() }\n     }\n \n     /// Skips the subtree corresponding to the last type\n@@ -41,11 +93,15 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n \n     fn next(&mut self) -> Option<GenericArg<'tcx>> {\n         debug!(\"next(): stack={:?}\", self.stack);\n-        let next = self.stack.pop()?;\n-        self.last_subtree = self.stack.len();\n-        push_inner(&mut self.stack, next);\n-        debug!(\"next: stack={:?}\", self.stack);\n-        Some(next)\n+        loop {\n+            let next = self.stack.pop()?;\n+            self.last_subtree = self.stack.len();\n+            if self.visited.insert(next) {\n+                push_inner(&mut self.stack, next);\n+                debug!(\"next: stack={:?}\", self.stack);\n+                return Some(next);\n+            }\n+        }\n     }\n }\n \n@@ -67,9 +123,17 @@ impl GenericArg<'tcx> {\n     /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(self) -> impl Iterator<Item = GenericArg<'tcx>> {\n+    ///\n+    /// Iterator only walks items once.\n+    /// It accepts visited set, updates it with all visited types\n+    /// and skips any types that are already there.\n+    pub fn walk_shallow(\n+        self,\n+        visited: &mut MiniSet<GenericArg<'tcx>>,\n+    ) -> impl Iterator<Item = GenericArg<'tcx>> {\n         let mut stack = SmallVec::new();\n         push_inner(&mut stack, self);\n+        stack.retain(|a| visited.insert(*a));\n         stack.into_iter()\n     }\n }"}, {"sha": "2d6ba936572d58385393c043f808eb67f4958c6d", "filename": "src/test/ui/closures/issue-72408-nested-closures-exponential.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-72408-nested-closures-exponential.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -0,0 +1,59 @@\n+// build-pass\n+\n+// Closures include captured types twice in a type tree.\n+//\n+// Wrapping one closure with another leads to doubling\n+// the amount of types in the type tree.\n+//\n+// This test ensures that rust can handle\n+// deeply nested type trees with a lot\n+// of duplicated subtrees.\n+\n+fn dup(f: impl Fn(i32) -> i32) -> impl Fn(i32) -> i32 {\n+    move |a| f(a * 2)\n+}\n+\n+fn main() {\n+    let f = |a| a;\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    // Compiler dies around here if it tries\n+    // to walk the tree exhaustively.\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+    let f = dup(f);\n+\n+    println!(\"Type size was at least {}\", f(1));\n+}"}, {"sha": "89137538425bfbdb948e30b78ccc7572e366aee5", "filename": "src/test/ui/issues/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -51,9 +51,9 @@ struct D (Box<A>);\n \n impl D {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the type-length limit while instantiating `D::matches::<[closure\n         let &D(ref a) = self;\n         a.matches(f)\n+        //~^ ERROR reached the recursion limit while instantiating `A::matches::<[closure\n     }\n }\n "}, {"sha": "c4255b95b704e4016bc4dc93f6a4e3356e82077a", "filename": "src/test/ui/issues/issue-22638.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -1,10 +1,14 @@\n-error: reached the type-length limit while instantiating `D::matches::$CLOSURE`\n-  --> $DIR/issue-22638.rs:53:5\n+error: reached the recursion limit while instantiating `A::matches::$CLOSURE`\n+  --> $DIR/issue-22638.rs:55:9\n+   |\n+LL |         a.matches(f)\n+   |         ^^^^^^^^^^^^\n+   |\n+note: `A::matches` defined here\n+  --> $DIR/issue-22638.rs:14:5\n    |\n LL |     pub fn matches<F: Fn()>(&self, f: &F) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: consider adding a `#![type_length_limit=\"30408681\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "921cded5037b67c3dcec87b9e8ababb67014e488", "filename": "src/test/ui/type_length_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Ftype_length_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Ftype_length_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.rs?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -4,7 +4,7 @@\n // Test that the type length limit can be changed.\n \n #![allow(dead_code)]\n-#![type_length_limit=\"256\"]\n+#![type_length_limit=\"4\"]\n \n macro_rules! link {\n     ($id:ident, $t:ty) => {"}, {"sha": "e8fddfd4ece153daec1e2f4b10ee541521672983", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f3296192bb5be5fcb02975395052ee8c3b2bd68/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=2f3296192bb5be5fcb02975395052ee8c3b2bd68", "patch": "@@ -4,7 +4,7 @@ error: reached the type-length limit while instantiating `std::mem::drop::<Optio\n LL | pub fn drop<T>(_x: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consider adding a `#![type_length_limit=\"1094\"]` attribute to your crate\n+   = note: consider adding a `#![type_length_limit=\"8\"]` attribute to your crate\n \n error: aborting due to previous error\n "}]}