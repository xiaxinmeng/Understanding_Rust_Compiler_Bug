{"sha": "764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NDc5MWI4M2U3ZjgyZjA3OGZkMWNlYjFiNTY1ZWM5ZTkyNDViYmY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-08T04:43:55Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-08T04:43:55Z"}, "message": "Merge pull request #440 from Manishearth/map_clone\n\nmatch .map(Clone::clone)", "tree": {"sha": "0f2c608f4676a6776ef19b1c058a8c7b6a5941bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f2c608f4676a6776ef19b1c058a8c7b6a5941bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "html_url": "https://github.com/rust-lang/rust/commit/764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7df4bd0008bb8aad4373457995f56dde861fb8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7df4bd0008bb8aad4373457995f56dde861fb8a", "html_url": "https://github.com/rust-lang/rust/commit/c7df4bd0008bb8aad4373457995f56dde861fb8a"}, {"sha": "a0cd8fc9437a9cc1ccb2a8d27f7c00c9fc9575c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cd8fc9437a9cc1ccb2a8d27f7c00c9fc9575c7", "html_url": "https://github.com/rust-lang/rust/commit/a0cd8fc9437a9cc1ccb2a8d27f7c00c9fc9575c7"}], "stats": {"total": 94, "additions": 56, "deletions": 38}, "files": [{"sha": "b9f677dd03d934aaab63ccaf24272c0429073f6a", "filename": "src/map_clone.rs", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ast::Ident;\n-use utils::OPTION_PATH;\n-use utils::{is_adjusted, match_trait_method, match_type, snippet, span_help_and_lint};\n+use utils::{CLONE_PATH, OPTION_PATH};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, snippet, span_help_and_lint};\n use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n \n declare_lint!(pub MAP_CLONE, Warn,\n@@ -14,43 +14,58 @@ pub struct MapClonePass;\n \n impl LateLintPass for MapClonePass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if_let_chain! {\n-            [\n-                // call to .map()\n-                let ExprMethodCall(name, _, ref args) = expr.node,\n-                name.node.as_str() == \"map\" && args.len() == 2,\n-                let ExprClosure(_, ref decl, ref blk) = args[1].node,\n-                // just one expression in the closure\n-                blk.stmts.is_empty(),\n-                let Some(ref closure_expr) = blk.expr,\n-                // nothing special in the argument, besides reference bindings\n-                // (e.g. .map(|&x| x) )\n-                let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n-                // the method is being called on a known type (option or iterator)\n-                let Some(type_name) = get_type_name(cx, expr, &args[0])\n-            ], {\n-                // look for derefs, for .map(|x| *x)\n-                if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                    // .cloned() only removes one level of indirection, don't lint on more\n-                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n-                {\n-                    span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                        \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                        using `.cloned()`\", type_name),\n-                        &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                }\n-                // explicit clone() calls ( .map(|x| x.clone()) )\n-                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                    if clone_call.node.as_str() == \"clone\" &&\n-                        clone_args.len() == 1 &&\n-                        match_trait_method(cx, closure_expr, &[\"core\", \"clone\", \"Clone\"]) &&\n-                        expr_eq_ident(&clone_args[0], arg_ident)\n-                    {\n-                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                            using `.cloned()`\", type_name),\n-                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+        // call to .map()\n+        if let ExprMethodCall(name, _, ref args) = expr.node {\n+            if name.node.as_str() == \"map\" && args.len() == 2 {\n+                match args[1].node {\n+                    ExprClosure(_, ref decl, ref blk) => {\n+                        if_let_chain! {\n+                            [\n+                            // just one expression in the closure\n+                            blk.stmts.is_empty(),\n+                            let Some(ref closure_expr) = blk.expr,\n+                            // nothing special in the argument, besides reference bindings\n+                            // (e.g. .map(|&x| x) )\n+                            let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n+                            // the method is being called on a known type (option or iterator)\n+                            let Some(type_name) = get_type_name(cx, expr, &args[0])\n+                            ], {\n+                                // look for derefs, for .map(|x| *x)\n+                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n+                                    // .cloned() only removes one level of indirection, don't lint on more\n+                                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                                {\n+                                    span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                        \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                        using `.cloned()`\", type_name),\n+                                        &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                                }\n+                                // explicit clone() calls ( .map(|x| x.clone()) )\n+                                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n+                                    if clone_call.node.as_str() == \"clone\" &&\n+                                        clone_args.len() == 1 &&\n+                                        match_trait_method(cx, closure_expr, &[\"core\", \"clone\", \"Clone\"]) &&\n+                                        expr_eq_ident(&clone_args[0], arg_ident)\n+                                    {\n+                                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                            using `.cloned()`\", type_name),\n+                                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    },\n+                    ExprPath(_, ref path) => {\n+                        if match_path(path, &CLONE_PATH) {\n+                            let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n+                            span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                using `.cloned()`\", type_name),\n+                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                        }\n                     }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "e56eab5ad28cc419f99343327e9278c5c05dd596", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "patch": "@@ -17,6 +17,7 @@ pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const MUTEX_PATH:  [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const CLONE_PATH:  [&'static str; 2] = [\"Clone\", \"clone\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///"}, {"sha": "2e60300afda7a750b601d1acb3c9564e142655de", "filename": "tests/compile-fail/map_clone.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/tests%2Fcompile-fail%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764791b83e7f82f078fd1ceb1b565ec9e9245bbf/tests%2Fcompile-fail%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmap_clone.rs?ref=764791b83e7f82f078fd1ceb1b565ec9e9245bbf", "patch": "@@ -15,6 +15,8 @@ fn map_clone_iter() {\n                           //~^ HELP try\n     x.iter().map(|y| *y); //~ ERROR you seem to be using .map()\n                           //~^ HELP try\n+    x.iter().map(Clone::clone); //~ ERROR you seem to be using .map()\n+                                //~^ HELP try\n }\n \n fn map_clone_option() {"}]}