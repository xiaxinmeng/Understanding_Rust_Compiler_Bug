{"sha": "a426fc37f2269093ef1a4dbb3e31b3247980fccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MjZmYzM3ZjIyNjkwOTNlZjFhNGRiYjNlMzFiMzI0Nzk4MGZjY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-20T00:55:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-20T00:55:27Z"}, "message": "Auto merge of #85391 - Mark-Simulacrum:opt-tostring, r=scottmcm\n\nAvoid zero-length memcpy in formatting\n\nThis has two separate and somewhat orthogonal commits. The first change adjusts the ToString general impl for all types that implement Display; it no longer uses the full format machinery, rather directly falling onto a `std::fmt::Display::fmt` call. The second change directly adjusts the general core::fmt::write function which handles the production of format_args! to avoid zero-length push_str calls.\n\nBoth changes target the fact that push_str will still call memmove internally (or a similar function), as it doesn't know the length of the passed string. For zero-length strings in particular, this is quite expensive, and even for very short (several bytes long) strings, this is also expensive. Future work in this area may wish to have us fallback to write_char or similar, which may be cheaper on the (typically) short strings between the interpolated pieces in format_args!.", "tree": {"sha": "1eb155def582f17b39868872390c1206d5129785", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eb155def582f17b39868872390c1206d5129785"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a426fc37f2269093ef1a4dbb3e31b3247980fccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a426fc37f2269093ef1a4dbb3e31b3247980fccc", "html_url": "https://github.com/rust-lang/rust/commit/a426fc37f2269093ef1a4dbb3e31b3247980fccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a426fc37f2269093ef1a4dbb3e31b3247980fccc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df70463ea5d701489d6f53dc780a2c16294d6143", "url": "https://api.github.com/repos/rust-lang/rust/commits/df70463ea5d701489d6f53dc780a2c16294d6143", "html_url": "https://github.com/rust-lang/rust/commit/df70463ea5d701489d6f53dc780a2c16294d6143"}, {"sha": "c7c93364697615edefccf281fa69b3f3af3dc67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7c93364697615edefccf281fa69b3f3af3dc67b", "html_url": "https://github.com/rust-lang/rust/commit/c7c93364697615edefccf281fa69b3f3af3dc67b"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "ec09595e357a637280098c56221279dd63ac0484", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a426fc37f2269093ef1a4dbb3e31b3247980fccc/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a426fc37f2269093ef1a4dbb3e31b3247980fccc/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=a426fc37f2269093ef1a4dbb3e31b3247980fccc", "patch": "@@ -2323,9 +2323,10 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     // to try to remove it.\n     #[inline]\n     default fn to_string(&self) -> String {\n-        use fmt::Write;\n         let mut buf = String::new();\n-        buf.write_fmt(format_args!(\"{}\", self))\n+        let mut formatter = core::fmt::Formatter::new(&mut buf);\n+        // Bypass format_args!() to avoid write_str with zero-length strs\n+        fmt::Display::fmt(self, &mut formatter)\n             .expect(\"a Display implementation returned an error unexpectedly\");\n         buf\n     }"}, {"sha": "afef790ca64ea3ae3a30d393e340aee062bd5331", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a426fc37f2269093ef1a4dbb3e31b3247980fccc/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a426fc37f2269093ef1a4dbb3e31b3247980fccc/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=a426fc37f2269093ef1a4dbb3e31b3247980fccc", "patch": "@@ -221,6 +221,28 @@ pub struct Formatter<'a> {\n     buf: &'a mut (dyn Write + 'a),\n }\n \n+impl<'a> Formatter<'a> {\n+    /// Creates a new formatter with default settings.\n+    ///\n+    /// This can be used as a micro-optimization in cases where a full `Arguments`\n+    /// structure (as created by `format_args!`) is not necessary; `Arguments`\n+    /// is a little more expensive to use in simple formatting scenarios.\n+    ///\n+    /// Currently not intended for use outside of the standard library.\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to standard library\", issue = \"none\")]\n+    #[doc(hidden)]\n+    pub fn new(buf: &'a mut (dyn Write + 'a)) -> Formatter<'a> {\n+        Formatter {\n+            flags: 0,\n+            fill: ' ',\n+            align: rt::v1::Alignment::Unknown,\n+            width: None,\n+            precision: None,\n+            buf,\n+        }\n+    }\n+}\n+\n // NB. Argument is essentially an optimized partially applied formatting function,\n // equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n \n@@ -1075,22 +1097,16 @@ pub trait UpperExp {\n /// [`write!`]: crate::write!\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: rt::v1::Alignment::Unknown,\n-        fill: ' ',\n-    };\n-\n+    let mut formatter = Formatter::new(output);\n     let mut idx = 0;\n \n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n             for (arg, piece) in iter::zip(args.args, args.pieces) {\n-                formatter.buf.write_str(*piece)?;\n+                if !piece.is_empty() {\n+                    formatter.buf.write_str(*piece)?;\n+                }\n                 (arg.formatter)(arg.value, &mut formatter)?;\n                 idx += 1;\n             }\n@@ -1099,7 +1115,9 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n             for (arg, piece) in iter::zip(fmt, args.pieces) {\n-                formatter.buf.write_str(*piece)?;\n+                if !piece.is_empty() {\n+                    formatter.buf.write_str(*piece)?;\n+                }\n                 // SAFETY: arg and args.args come from the same Arguments,\n                 // which guarantees the indexes are always within bounds.\n                 unsafe { run(&mut formatter, arg, &args.args) }?;"}]}