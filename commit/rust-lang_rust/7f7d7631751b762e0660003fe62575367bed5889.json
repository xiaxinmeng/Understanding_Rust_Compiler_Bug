{"sha": "7f7d7631751b762e0660003fe62575367bed5889", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmN2Q3NjMxNzUxYjc2MmUwNjYwMDAzZmU2MjU3NTM2N2JlZDU4ODk=", "commit": {"author": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-10-23T14:42:07Z"}, "committer": {"name": "Ravi Shankar", "email": "wafflespeanut@gmail.com", "date": "2015-10-24T09:52:45Z"}, "message": "tests for coverage mode", "tree": {"sha": "4dd73cb4f12e7c45a06fc8aee8dcc42f0231320e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dd73cb4f12e7c45a06fc8aee8dcc42f0231320e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f7d7631751b762e0660003fe62575367bed5889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d7631751b762e0660003fe62575367bed5889", "html_url": "https://github.com/rust-lang/rust/commit/7f7d7631751b762e0660003fe62575367bed5889", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d7631751b762e0660003fe62575367bed5889/comments", "author": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wafflespeanut", "id": 6691262, "node_id": "MDQ6VXNlcjY2OTEyNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6691262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wafflespeanut", "html_url": "https://github.com/wafflespeanut", "followers_url": "https://api.github.com/users/wafflespeanut/followers", "following_url": "https://api.github.com/users/wafflespeanut/following{/other_user}", "gists_url": "https://api.github.com/users/wafflespeanut/gists{/gist_id}", "starred_url": "https://api.github.com/users/wafflespeanut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wafflespeanut/subscriptions", "organizations_url": "https://api.github.com/users/wafflespeanut/orgs", "repos_url": "https://api.github.com/users/wafflespeanut/repos", "events_url": "https://api.github.com/users/wafflespeanut/events{/privacy}", "received_events_url": "https://api.github.com/users/wafflespeanut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d135217db26bd9a2643e57170c3f459aa42e08e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d135217db26bd9a2643e57170c3f459aa42e08e4", "html_url": "https://github.com/rust-lang/rust/commit/d135217db26bd9a2643e57170c3f459aa42e08e4"}], "stats": {"total": 58, "additions": 45, "deletions": 13}, "files": [{"sha": "379e8e5820e52af35a27f84d35f90c273817f46b", "filename": "tests/coverage-source/comments.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fcoverage-source%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fcoverage-source%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcoverage-source%2Fcomments.rs?ref=7f7d7631751b762e0660003fe62575367bed5889", "patch": "@@ -0,0 +1,6 @@\n+/// Here's a doc comment!\n+fn main() {\n+    // foo is bar\n+    let foo = \"bar\";\n+    // loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment!!!!!\n+}"}, {"sha": "74d17bffd15782f2c8566246241c400be03cacbf", "filename": "tests/coverage-target/comments.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fcoverage-target%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fcoverage-target%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcoverage-target%2Fcomments.rs?ref=7f7d7631751b762e0660003fe62575367bed5889", "patch": "@@ -0,0 +1,6 @@\n+/// Here's a doc comment!\n+fn main() {\n+    XX XXX XX XXX\n+    let foo = \"bar\";\n+    XX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXX\n+}"}, {"sha": "4a924c578337a5dfcec8185165fc8ed3a1f2b41d", "filename": "tests/system.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7d7631751b762e0660003fe62575367bed5889/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=7f7d7631751b762e0660003fe62575367bed5889", "patch": "@@ -43,13 +43,25 @@ fn system_tests() {\n     // Turn a DirEntry into a String that represents the relative path to the\n     // file.\n     let files = files.map(get_path_string);\n-    let (_reports, count, fails) = check_files(files);\n+    let (_reports, count, fails) = check_files(files, WriteMode::Return);\n \n     // Display results.\n     println!(\"Ran {} system tests.\", count);\n     assert!(fails == 0, \"{} system tests failed\", fails);\n }\n \n+// Do the same for tests/coverage-source directory\n+// the only difference is the coverage mode\n+#[test]\n+fn coverage_tests() {\n+    let files = fs::read_dir(\"tests/coverage-source\").ok().expect(\"Couldn't read source dir.\");\n+    let files = files.map(get_path_string);\n+    let (_reports, count, fails) = check_files(files, WriteMode::Coverage);\n+\n+    println!(\"Ran {} tests in coverage mode.\", count);\n+    assert!(fails == 0, \"{} tests failed\", fails);\n+}\n+\n // Idempotence tests. Files in tests/target are checked to be unaltered by\n // rustfmt.\n #[test]\n@@ -59,7 +71,7 @@ fn idempotence_tests() {\n                     .ok()\n                     .expect(\"Couldn't read target dir.\")\n                     .map(get_path_string);\n-    let (_reports, count, fails) = check_files(files);\n+    let (_reports, count, fails) = check_files(files, WriteMode::Return);\n \n     // Display results.\n     println!(\"Ran {} idempotent tests.\", count);\n@@ -78,7 +90,7 @@ fn self_tests() {\n     // Hack because there's no `IntoIterator` impl for `[T; N]`.\n     let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n-    let (reports, count, fails) = check_files(files);\n+    let (reports, count, fails) = check_files(files, WriteMode::Return);\n     let mut warnings = 0;\n \n     // Display results.\n@@ -97,7 +109,7 @@ fn self_tests() {\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n+fn check_files<I>(files: I, write_mode: WriteMode) -> (Vec<FormatReport>, u32, u32)\n     where I: Iterator<Item = String>\n {\n     let mut count = 0;\n@@ -107,7 +119,7 @@ fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n     for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n \n-        match idempotent_check(file_name) {\n+        match idempotent_check(file_name, write_mode) {\n             Ok(report) => reports.push(report),\n             Err(msg) => {\n                 print_mismatches(msg);\n@@ -132,7 +144,9 @@ fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n     assert!(t.reset().unwrap());\n }\n \n-pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n+pub fn idempotent_check(filename: String,\n+                        write_mode: WriteMode)\n+                        -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n     let sig_comments = read_significant_comments(&filename);\n     let mut config = get_config(sig_comments.get(\"config\").map(|x| &(*x)[..]));\n \n@@ -145,14 +159,14 @@ pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String\n     // Don't generate warnings for to-do items.\n     config.report_todo = ReportTactic::Never;\n \n-    let mut file_map = format(Path::new(&filename), &config, WriteMode::Return);\n+    let mut file_map = format(Path::new(&filename), &config, write_mode);\n     let format_report = fmt_lines(&mut file_map, &config);\n \n     // Won't panic, as we're not doing any IO.\n     let write_result = filemap::write_all_files(&file_map, WriteMode::Return, &config).unwrap();\n     let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n \n-    handle_result(write_result, target).map(|_| format_report)\n+    handle_result(write_result, target, write_mode).map(|_| format_report)\n }\n \n // Reads test config file from comments and reads its contents.\n@@ -205,13 +219,14 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n // Compare output to input.\n // TODO: needs a better name, more explanation.\n fn handle_result(result: HashMap<String, String>,\n-                 target: Option<&str>)\n+                 target: Option<&str>,\n+                 write_mode: WriteMode)\n                  -> Result<(), HashMap<String, Vec<Mismatch>>> {\n     let mut failures = HashMap::new();\n \n     for (file_name, fmt_text) in result {\n         // If file is in tests/source, compare to file with same name in tests/target.\n-        let target = get_target(&file_name, target);\n+        let target = get_target(&file_name, target, write_mode);\n         let mut f = fs::File::open(&target).ok().expect(\"Couldn't open target.\");\n \n         let mut text = String::new();\n@@ -231,9 +246,14 @@ fn handle_result(result: HashMap<String, String>,\n }\n \n // Map source file paths to their target paths.\n-fn get_target(file_name: &str, target: Option<&str>) -> String {\n+fn get_target(file_name: &str, target: Option<&str>, write_mode: WriteMode) -> String {\n     let file_path = Path::new(file_name);\n-    let source_path_prefix = Path::new(\"tests/source/\");\n+    let (source_path_prefix, target_path_prefix) = match write_mode {\n+        WriteMode::Coverage => (Path::new(\"tests/coverage-source/\"),\n+                                \"tests/coverage-target/\"),\n+        _ => (Path::new(\"tests/source/\"), \"tests/target/\"),\n+    };\n+\n     if file_path.starts_with(source_path_prefix) {\n         let mut components = file_path.components();\n         // Can't skip(2) as the resulting iterator can't as_path()\n@@ -246,7 +266,7 @@ fn get_target(file_name: &str, target: Option<&str>) -> String {\n         };\n         let base = target.unwrap_or(new_target);\n \n-        format!(\"tests/target/{}\", base)\n+        format!(\"{}{}\", target_path_prefix, base)\n     } else {\n         file_name.to_owned()\n     }"}]}