{"sha": "8b2bdfd453d196f4d108183efe1f5a58292d5f11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMmJkZmQ0NTNkMTk2ZjRkMTA4MTgzZWZlMWY1YTU4MjkyZDVmMTE=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-20T12:46:10Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-01T14:08:57Z"}, "message": "Improve std::sys::windows::compat.\n\n- Module name can now be any string, not just an ident.\n  (Not all Windows api modules are valid Rust identifiers.)\n- Adds c::FuncName::is_available() for checking if a function is really\n  available without having to do a duplicate lookup.\n- Add comment explaining the lack of locking.\n- Use `$_:block` to simplify the macro_rules.\n- Apply allow(unused_variables) only to the fallback instead of\n  everything.", "tree": {"sha": "cdaa1cc6ced4e0fa5f71847f12280cb5e575a3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdaa1cc6ced4e0fa5f71847f12280cb5e575a3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b2bdfd453d196f4d108183efe1f5a58292d5f11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b2bdfd453d196f4d108183efe1f5a58292d5f11", "html_url": "https://github.com/rust-lang/rust/commit/8b2bdfd453d196f4d108183efe1f5a58292d5f11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b2bdfd453d196f4d108183efe1f5a58292d5f11/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d92d28e523bf056ab4eb752510ec52fe4f1c6311", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92d28e523bf056ab4eb752510ec52fe4f1c6311", "html_url": "https://github.com/rust-lang/rust/commit/d92d28e523bf056ab4eb752510ec52fe4f1c6311"}], "stats": {"total": 63, "additions": 35, "deletions": 28}, "files": [{"sha": "559c4dc9c7cd8fc199f1f6ff38f15073ecd02db4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b2bdfd453d196f4d108183efe1f5a58292d5f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2bdfd453d196f4d108183efe1f5a58292d5f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=8b2bdfd453d196f4d108183efe1f5a58292d5f11", "patch": "@@ -1032,7 +1032,7 @@ extern \"system\" {\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {\n-    kernel32:\n+    \"kernel32\":\n \n     pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n                                _lpTargetFileName: LPCWSTR,"}, {"sha": "897f49445eefb59a1e43efc49d35bfbec5c1e3df", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8b2bdfd453d196f4d108183efe1f5a58292d5f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b2bdfd453d196f4d108183efe1f5a58292d5f11/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=8b2bdfd453d196f4d108183efe1f5a58292d5f11", "patch": "@@ -12,7 +12,6 @@\n //! function is available but afterwards it's just a load and a jump.\n \n use crate::ffi::CString;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n \n pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n@@ -28,45 +27,53 @@ pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     }\n }\n \n-pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str, fallback: usize) -> usize {\n-    let value = lookup(module, symbol).unwrap_or(fallback);\n-    ptr.store(value, Ordering::SeqCst);\n-    value\n-}\n-\n macro_rules! compat_fn {\n-    ($module:ident: $(\n+    ($module:literal: $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n-                                  -> $rettype:ty {\n-            $($body:expr);*\n-        }\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $body:block\n     )*) => ($(\n-        #[allow(unused_variables)]\n         $(#[$meta])*\n-        pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+        pub mod $symbol {\n+            use super::*;\n             use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;\n-            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n \n             static PTR: AtomicUsize = AtomicUsize::new(0);\n \n+            #[allow(unused_variables)]\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $body\n+\n+            #[cold]\n             fn load() -> usize {\n-                crate::sys::compat::store_func(&PTR,\n-                                          stringify!($module),\n-                                          stringify!($symbol),\n-                                          fallback as usize)\n+                // There is no locking here. It's okay if this is executed by multiple threads in\n+                // parallel. `lookup` will result in the same value, and it's okay if they overwrite\n+                // eachothers result as long as they do so atomically. We don't need any guarantees\n+                // about memory ordering, as this involves just a single atomic variable which is\n+                // not used to protect or order anything else.\n+                let addr = crate::sys::compat::lookup($module, stringify!($symbol))\n+                    .unwrap_or(fallback as usize);\n+                PTR.store(addr, Ordering::Relaxed);\n+                addr\n             }\n-            unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n-                                               -> $rettype {\n-                $($body);*\n+\n+            fn addr() -> usize {\n+                match PTR.load(Ordering::Relaxed) {\n+                    0 => load(),\n+                    addr => addr,\n+                }\n             }\n \n-            let addr = match PTR.load(Ordering::SeqCst) {\n-                0 => load(),\n-                n => n,\n-            };\n-            mem::transmute::<usize, F>(addr)($($argname),*)\n+            #[allow(dead_code)]\n+            pub fn is_available() -> bool {\n+                addr() != fallback as usize\n+            }\n+\n+            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n+                type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n+                mem::transmute::<usize, F>(addr())($($argname),*)\n+            }\n         }\n+\n+        pub use $symbol::call as $symbol;\n     )*)\n }"}]}