{"sha": "d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OTA3NGM4YWUxMWQ1MmIzYjkyZDczYmM2ODRmNWI5NjRhMDVjZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T04:25:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T20:24:50Z"}, "message": "std: Remove lots of allocations from log settings\n\nMost of these are unnecessary because we're only looking at static strings. This\nalso moves to Vec in a few places instead of ~[T].\n\nThis didn't end up getting much of a code size win (update_log_settings is the\nthird largest function in the executables I'm looking at), but this seems like a\ngenerally nice improvement regardless.", "tree": {"sha": "5af56a15fa353140c59a24d286133c67880c3a05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af56a15fa353140c59a24d286133c67880c3a05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "html_url": "https://github.com/rust-lang/rust/commit/d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d89074c8ae11d52b3b92d73bc684f5b964a05cf5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5aa795aa5f316bc5f43508df5bc41cba0a61ea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5aa795aa5f316bc5f43508df5bc41cba0a61ea8", "html_url": "https://github.com/rust-lang/rust/commit/d5aa795aa5f316bc5f43508df5bc41cba0a61ea8"}], "stats": {"total": 198, "additions": 96, "deletions": 102}, "files": [{"sha": "ff54a80ce997f9900bc9959a8be32729802ea534", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d89074c8ae11d52b3b92d73bc684f5b964a05cf5/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d89074c8ae11d52b3b92d73bc684f5b964a05cf5/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "patch": "@@ -123,7 +123,7 @@ fn version(crate_map: &CrateMap) -> i32 {\n \n fn do_iter_crate_map<'a>(\n                      crate_map: &'a CrateMap<'a>,\n-                     f: |&ModEntry|,\n+                     f: |&'a ModEntry<'a>|,\n                      visited: &mut ~[*CrateMap<'a>]) {\n     let raw = crate_map as *CrateMap<'a>;\n     if visited.bsearch(|a| (*a as uint).cmp(&(raw as uint))).is_some() {\n@@ -149,7 +149,7 @@ fn do_iter_crate_map<'a>(\n }\n \n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&ModEntry|) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&'a ModEntry<'a>|) {\n     let mut v = ~[];\n     do_iter_crate_map(crate_map, f, &mut v);\n }"}, {"sha": "aa024a53b89ecc812c12675d82d631cb74cff306", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 94, "deletions": 100, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/d89074c8ae11d52b3b92d73bc684f5b964a05cf5/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d89074c8ae11d52b3b92d73bc684f5b964a05cf5/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=d89074c8ae11d52b3b92d73bc684f5b964a05cf5", "patch": "@@ -13,13 +13,14 @@ use from_str::from_str;\n use iter::Iterator;\n use libc::exit;\n use option::{Some, None, Option};\n+use os;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n-use str::StrSlice;\n+use str::{Str, StrSlice};\n use vec::{ImmutableVector, MutableTotalOrdVector, OwnedVector};\n-#[cfg(test)] use cast::transmute;\n+use vec_ng::Vec;\n \n-struct LogDirective {\n-    name: Option<~str>,\n+struct LogDirective<'a> {\n+    name: Option<&'a str>,\n     level: u32\n }\n \n@@ -58,36 +59,39 @@ fn parse_log_level(level: &str) -> Option<u32> {\n /// and return a vector with log directives.\n /// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in std::).\n /// Also supports string log levels of error, warn, info, and debug\n-fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n-    let mut dirs = ~[];\n+fn parse_logging_spec<'a>(spec: &'a str) -> Vec<LogDirective<'a>> {\n+    let mut dirs = Vec::new();\n     for s in spec.split(',') {\n-        let parts: ~[&str] = s.split('=').collect();\n-        let mut log_level;\n-        let mut name = Some(parts[0].to_owned());\n-        match parts.len() {\n-            1 => {\n+        if s.len() == 0 { continue }\n+        let mut parts = s.split('=');\n+        let log_level;\n+        let name;\n+        match (parts.next(), parts.next(), parts.next()) {\n+            (Some(part0), None, None) => {\n                 //if the single argument is a log-level string or number,\n                 //treat that as a global fallback\n-                let possible_log_level = parse_log_level(parts[0]);\n+                let possible_log_level = parse_log_level(part0);\n                 match possible_log_level {\n                     Some(num) => {\n                         name = None;\n                         log_level = num;\n                     },\n-                    _ => {\n-                        log_level = MAX_LOG_LEVEL\n+                    None => {\n+                        log_level = MAX_LOG_LEVEL;\n+                        name = Some(part0);\n                     }\n                 }\n             }\n-            2 => {\n-                let possible_log_level = parse_log_level(parts[1]);\n+            (Some(part0), Some(part1), None) => {\n+                let possible_log_level = parse_log_level(part1);\n                 match possible_log_level {\n                     Some(num) => {\n+                        name = Some(part0);\n                         log_level = num;\n                     },\n                     _ => {\n                         rterrln!(\"warning: invalid logging spec '{}', \\\n-                                  ignoring it\", parts[1]);\n+                                  ignoring it\", part1);\n                         continue\n                     }\n                 }\n@@ -98,8 +102,7 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n                 continue\n             }\n         }\n-        let dir = LogDirective {name: name, level: log_level};\n-        dirs.push(dir);\n+        dirs.push(LogDirective { name: name, level: log_level });\n     }\n     return dirs;\n }\n@@ -134,27 +137,24 @@ fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n \n /// Set log level for every entry in crate_map according to the sepecification\n /// in settings\n-fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n-    let mut dirs = ~[];\n-    if settings.len() > 0 {\n-        if settings == ~\"::help\" || settings == ~\"?\" {\n-            rterrln!(\"\\nCrate log map:\\n\");\n+fn update_log_settings(crate_map: &CrateMap, settings: &str) {\n+    if settings == \"::help\" || settings == \"?\" {\n+        rterrln!(\"\\nCrate log map:\\n\");\n \n-            let mut entries = ~[];\n-            iter_crate_map(crate_map, |entry| entries.push(entry.name.to_owned()));\n-            entries.sort();\n+        let mut entries = Vec::new();\n+        iter_crate_map(crate_map, |entry| entries.push(entry.name));\n+        entries.as_mut_slice().sort();\n \n-            for name in entries.iter() {\n-                rterrln!(\" {}\", *name);\n-            }\n-            unsafe { exit(1); }\n+        for name in entries.iter() {\n+            rterrln!(\" {}\", *name);\n         }\n-        dirs = parse_logging_spec(settings);\n+        unsafe { exit(1); }\n     }\n+    let dirs = parse_logging_spec(settings);\n \n     let mut n_matches: u32 = 0;\n     iter_crate_map(crate_map, |entry| {\n-        let m = update_entry(dirs, entry);\n+        let m = update_entry(dirs.as_slice(), entry);\n         n_matches += m;\n     });\n \n@@ -169,18 +169,12 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init() {\n-    use os;\n-\n     let log_spec = os::getenv(\"RUST_LOG\");\n     match get_crate_map() {\n         Some(crate_map) => {\n             match log_spec {\n-                Some(spec) => {\n-                    update_log_settings(crate_map, spec);\n-                }\n-                None => {\n-                    update_log_settings(crate_map, ~\"\");\n-                }\n+                Some(spec) => update_log_settings(crate_map, spec.as_slice()),\n+                None => update_log_settings(crate_map, \"\"),\n             }\n         },\n         _ => {\n@@ -197,124 +191,124 @@ pub fn init() {\n // Tests for parse_logging_spec()\n #[test]\n fn parse_logging_spec_valid() {\n-    let dirs = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 3);\n-    assert!(dirs[0].name == Some(~\"crate1::mod1\"));\n+    assert_eq!(dirs[0].name, Some(\"crate1::mod1\"));\n     assert_eq!(dirs[0].level, 1);\n \n-    assert!(dirs[1].name == Some(~\"crate1::mod2\"));\n+    assert_eq!(dirs[1].name, Some(\"crate1::mod2\"));\n     assert_eq!(dirs[1].level, MAX_LOG_LEVEL);\n \n-    assert!(dirs[2].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[2].name, Some(\"crate2\"));\n     assert_eq!(dirs[2].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_crate() {\n     // test parse_logging_spec with multiple = in specification\n-    let dirs = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_log_level() {\n     // test parse_logging_spec with 'noNumber' as log level\n-    let dirs = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_string_log_level() {\n     // test parse_logging_spec with 'warn' as log level\n-    let dirs = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n+    let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].name, Some(\"crate2\"));\n     assert_eq!(dirs[0].level, 2);\n }\n \n #[test]\n fn parse_logging_spec_global() {\n     // test parse_logging_spec with no crate\n-    let dirs = parse_logging_spec(~\"warn,crate2=4\");\n+    let dirs = parse_logging_spec(\"warn,crate2=4\");\n+    let dirs = dirs.as_slice();\n     assert_eq!(dirs.len(), 2);\n-    assert!(dirs[0].name == None);\n+    assert_eq!(dirs[0].name, None);\n     assert_eq!(dirs[0].level, 2);\n-    assert!(dirs[1].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[1].name, Some(\"crate2\"));\n     assert_eq!(dirs[1].level, 4);\n }\n \n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name:\"crate1::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 2);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate1::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 2);\n }\n \n #[test]\n fn update_entry_no_match() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate3::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n-        assert!(m == 0);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate3::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 0);\n     }\n+    assert_eq!(level, DEFAULT_LOG_LEVEL);\n }\n \n #[test]\n fn update_entry_match_beginning() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate2::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 3);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry= &ModEntry {name: \"crate2::mod1\", log_level: &mut level};\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 3);\n }\n \n #[test]\n fn update_entry_match_beginning_longest_match() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: Some(~\"crate2\"), level: 3},\n-                 LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry = &ModEntry {name: \"crate2::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 4);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: Some(\"crate2\"), level: 3 },\n+                LogDirective { name: Some(\"crate2::mod\"), level: 4 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate2::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 4);\n }\n \n #[test]\n fn update_entry_match_default() {\n-    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n-                 LogDirective {name: None, level: 3}\n-                ];\n-    let level = &mut 0;\n-    unsafe {\n-        let entry= &ModEntry {name: \"crate1::mod1\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 2);\n-        assert!(m == 1);\n-        let entry= &ModEntry {name: \"crate2::mod2\", log_level: level};\n-        let m = update_entry(dirs, transmute(entry));\n-        assert!(*entry.log_level == 3);\n-        assert!(m == 1);\n+    let dirs = [LogDirective { name: Some(\"crate1::mod1\"), level: 2 },\n+                LogDirective { name: None, level: 3 }];\n+    let mut level = 0;\n+    {\n+        let entry = &ModEntry { name: \"crate1::mod1\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n+    }\n+    assert_eq!(level, 2);\n+    {\n+        let entry = &ModEntry { name: \"crate2::mod2\", log_level: &mut level };\n+        assert_eq!(update_entry(dirs, entry), 1);\n     }\n+    assert_eq!(level, 3);\n }"}]}