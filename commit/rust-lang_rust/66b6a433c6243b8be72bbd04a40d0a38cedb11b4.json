{"sha": "66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjZhNDMzYzYyNDNiOGJlNzJiYmQwNGE0MGQwYTM4Y2VkYjExYjQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-03T16:15:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-03T17:32:18Z"}, "message": "Unify naming of generating assists", "tree": {"sha": "ab31a657463daa426db793f335cb6bfcf7c8e41a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab31a657463daa426db793f335cb6bfcf7c8e41a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "html_url": "https://github.com/rust-lang/rust/commit/66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a434ecef51bc8cf20b626267ef90c2887aa5116a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a434ecef51bc8cf20b626267ef90c2887aa5116a", "html_url": "https://github.com/rust-lang/rust/commit/a434ecef51bc8cf20b626267ef90c2887aa5116a"}], "stats": {"total": 423, "additions": 216, "deletions": 207}, "files": [{"sha": "8fc522eef073bb3d15c7d996282f9caa1cd48076", "filename": "crates/ra_assists/src/handlers/generate_derive.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_derive\n+// Assist: generate_derive\n //\n // Adds a new `#[derive()]` clause to a struct or enum.\n //\n@@ -24,12 +24,12 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let cap = ctx.config.snippet_cap?;\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    acc.add(AssistId(\"add_derive\", AssistKind::None), \"Add `#[derive]`\", target, |builder| {\n+    acc.add(AssistId(\"generate_derive\", AssistKind::None), \"Add `#[derive]`\", target, |builder| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n@@ -70,12 +70,12 @@ mod tests {\n     #[test]\n     fn add_derive_new() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"struct Foo { a: i32, <|>}\",\n             \"#[derive($0)]\\nstruct Foo { a: i32, }\",\n         );\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"struct Foo { <|> a: i32, }\",\n             \"#[derive($0)]\\nstruct Foo {  a: i32, }\",\n         );\n@@ -84,7 +84,7 @@ mod tests {\n     #[test]\n     fn add_derive_existing() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n             \"#[derive(Clone$0)]\\nstruct Foo { a: i32, }\",\n         );\n@@ -93,7 +93,7 @@ mod tests {\n     #[test]\n     fn add_derive_new_with_doc_comment() {\n         check_assist(\n-            add_derive,\n+            generate_derive,\n             \"\n /// `Foo` is a pretty important struct.\n /// It does stuff.\n@@ -111,7 +111,7 @@ struct Foo { a: i32, }\n     #[test]\n     fn add_derive_target() {\n         check_assist_target(\n-            add_derive,\n+            generate_derive,\n             \"\n struct SomeThingIrrelevant;\n /// `Foo` is a pretty important struct.", "previous_filename": "crates/ra_assists/src/handlers/add_derive.rs"}, {"sha": "e781be61ecf7e9581cdca42eaf75425b7e9b40a0", "filename": "crates/ra_assists/src/handlers/generate_from_impl_for_enum.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -4,7 +4,7 @@ use test_utils::mark;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_from_impl_for_enum\n+// Assist: generate_from_impl_for_enum\n //\n // Adds a From impl for an enum variant with one tuple field.\n //\n@@ -21,7 +21,7 @@ use crate::{utils::FamousDefs, AssistContext, AssistId, AssistKind, Assists};\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n@@ -45,8 +45,8 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n \n     let target = variant.syntax().text_range();\n     acc.add(\n-        AssistId(\"add_from_impl_for_enum\", AssistKind::Refactor),\n-        \"Add From impl for this enum variant\",\n+        AssistId(\"generate_from_impl_for_enum\", AssistKind::Refactor),\n+        \"Generate `From` impl for this enum variant\",\n         target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n@@ -97,9 +97,9 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_add_from_impl_for_enum() {\n+    fn test_generate_from_impl_for_enum() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             \"enum A { <|>One(u32) }\",\n             r#\"enum A { One(u32) }\n \n@@ -112,9 +112,9 @@ impl From<u32> for A {\n     }\n \n     #[test]\n-    fn test_add_from_impl_for_enum_complicated_path() {\n+    fn test_generate_from_impl_for_enum_complicated_path() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             r#\"enum A { <|>One(foo::bar::baz::Boo) }\"#,\n             r#\"enum A { One(foo::bar::baz::Boo) }\n \n@@ -129,7 +129,7 @@ impl From<foo::bar::baz::Boo> for A {\n     fn check_not_applicable(ra_fixture: &str) {\n         let fixture =\n             format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n-        check_assist_not_applicable(add_from_impl_for_enum, &fixture)\n+        check_assist_not_applicable(generate_from_impl_for_enum, &fixture)\n     }\n \n     #[test]\n@@ -166,7 +166,7 @@ impl From<u32> for A {\n     #[test]\n     fn test_add_from_impl_different_variant_impl_exists() {\n         check_assist(\n-            add_from_impl_for_enum,\n+            generate_from_impl_for_enum,\n             r#\"enum A { <|>One(u32), Two(String), }\n \n impl From<String> for A {", "previous_filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs"}, {"sha": "35162791ee38772461d2340d4311c1038ffc6f23", "filename": "crates/ra_assists/src/handlers/generate_function.rs", "status": "renamed", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n-// Assist: add_function\n+// Assist: generate_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n //\n@@ -41,7 +41,7 @@ use crate::{\n // }\n //\n // ```\n-pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -62,15 +62,20 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    acc.add(AssistId(\"add_function\", AssistKind::None), \"Add function\", target, |builder| {\n-        let function_template = function_builder.render();\n-        builder.edit_file(function_template.file);\n-        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n-        match ctx.config.snippet_cap {\n-            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n-            None => builder.insert(function_template.insert_offset, new_fn),\n-        }\n-    })\n+    acc.add(\n+        AssistId(\"generate_function\", AssistKind::None),\n+        format!(\"Generate `{}` function\", function_builder.fn_name),\n+        target,\n+        |builder| {\n+            let function_template = function_builder.render();\n+            builder.edit_file(function_template.file);\n+            let new_fn = function_template.to_string(ctx.config.snippet_cap);\n+            match ctx.config.snippet_cap {\n+                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+                None => builder.insert(function_template.insert_offset, new_fn),\n+            }\n+        },\n+    )\n }\n \n struct FunctionTemplate {\n@@ -333,7 +338,7 @@ mod tests {\n     #[test]\n     fn add_function_with_no_args() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar<|>();\n@@ -356,7 +361,7 @@ fn bar() {\n         // This ensures that the function is correctly generated\n         // in the next outer mod or file\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n impl Foo {\n     fn foo() {\n@@ -382,7 +387,7 @@ fn bar() {\n     fn add_function_directly_after_current_block() {\n         // The new fn should not be created at the end of the file or module\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo1() {\n     bar<|>();\n@@ -407,7 +412,7 @@ fn foo2() {}\n     #[test]\n     fn add_function_with_no_args_in_same_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod baz {\n     fn foo() {\n@@ -432,7 +437,7 @@ mod baz {\n     #[test]\n     fn add_function_with_function_call_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { todo!() }\n@@ -457,7 +462,7 @@ fn bar(baz: Baz) {\n     #[test]\n     fn add_function_with_method_call_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n impl Baz {\n@@ -490,7 +495,7 @@ fn bar(baz: Baz) {\n     #[test]\n     fn add_function_with_string_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n fn foo() {\n     <|>bar(\"bar\")\n@@ -511,7 +516,7 @@ fn bar(arg: &str) {\n     #[test]\n     fn add_function_with_char_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n fn foo() {\n     <|>bar('x')\n@@ -532,7 +537,7 @@ fn bar(arg: char) {\n     #[test]\n     fn add_function_with_int_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(42)\n@@ -553,7 +558,7 @@ fn bar(arg: i32) {\n     #[test]\n     fn add_function_with_cast_int_literal_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(42 as u8)\n@@ -576,7 +581,7 @@ fn bar(arg: u8) {\n         // Ensures that the name of the cast type isn't used\n         // in the generated function signature.\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let x = 42;\n@@ -599,7 +604,7 @@ fn bar(x: u8) {\n     #[test]\n     fn add_function_with_variable_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let worble = ();\n@@ -622,7 +627,7 @@ fn bar(worble: ()) {\n     #[test]\n     fn add_function_with_impl_trait_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n trait Foo {}\n fn foo() -> impl Foo {\n@@ -651,7 +656,7 @@ fn bar(foo: impl Foo) {\n     #[test]\n     fn borrowed_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { todo!() }\n@@ -678,7 +683,7 @@ fn bar(baz: &Baz) {\n     #[test]\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod Baz {\n     pub struct Bof;\n@@ -709,7 +714,7 @@ fn bar(baz: Baz::Bof) {\n     // FIXME fix printing the generics of a `Ty` to make this test pass\n     fn add_function_with_generic_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo<T>(t: T) {\n     <|>bar(t)\n@@ -732,7 +737,7 @@ fn bar<T>(t: T) {\n     // FIXME Fix function type printing to make this test pass\n     fn add_function_with_fn_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n impl Baz {\n@@ -763,7 +768,7 @@ fn bar(arg: fn() -> Baz) {\n     // FIXME Fix closure type printing to make this test pass\n     fn add_function_with_closure_arg() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     let closure = |x: i64| x - 1;\n@@ -786,7 +791,7 @@ fn bar(closure: impl Fn(i64) -> i64) {\n     #[test]\n     fn unresolveable_types_default_to_unit() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     <|>bar(baz)\n@@ -807,7 +812,7 @@ fn bar(baz: ()) {\n     #[test]\n     fn arg_names_dont_overlap() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Baz;\n fn baz() -> Baz { Baz }\n@@ -832,7 +837,7 @@ fn bar(baz_1: Baz, baz_2: Baz) {\n     #[test]\n     fn arg_name_counters_start_at_1_per_name() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r#\"\n struct Baz;\n fn baz() -> Baz { Baz }\n@@ -857,7 +862,7 @@ fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n     #[test]\n     fn add_function_in_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {}\n \n@@ -885,7 +890,7 @@ fn foo() {\n     // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n     fn qualified_path_uses_correct_scope() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             \"\n mod foo {\n     pub struct Foo;\n@@ -916,7 +921,7 @@ fn baz(foo: foo::Foo) {\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {\n     fn something_else() {}\n@@ -945,7 +950,7 @@ fn foo() {\n     #[test]\n     fn add_function_in_nested_module() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n mod bar {\n     mod baz {}\n@@ -974,7 +979,7 @@ fn foo() {\n     #[test]\n     fn add_function_in_another_file() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n //- /main.rs\n mod foo;\n@@ -996,7 +1001,7 @@ pub(crate) fn bar() {\n     #[test]\n     fn add_function_not_applicable_if_function_already_exists() {\n         check_assist_not_applicable(\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar<|>();\n@@ -1013,7 +1018,7 @@ fn bar() {}\n             // bar is resolved, but baz isn't.\n             // The assist is only active if the cursor is on an unresolved path,\n             // but the assist should only be offered if the path is a function call.\n-            add_function,\n+            generate_function,\n             r\"\n fn foo() {\n     bar(b<|>az);\n@@ -1028,7 +1033,7 @@ fn bar(baz: ()) {}\n     #[ignore]\n     fn create_method_with_no_args() {\n         check_assist(\n-            add_function,\n+            generate_function,\n             r\"\n struct Foo;\n impl Foo {", "previous_filename": "crates/ra_assists/src/handlers/add_function.rs"}, {"sha": "5f287afb6d75d071a079ad0cd259646304ff75a8", "filename": "crates/ra_assists/src/handlers/generate_impl.rs", "status": "renamed", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -3,7 +3,7 @@ use stdx::{format_to, SepBy};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_impl\n+// Assist: generate_impl\n //\n // Adds a new inherent impl for a type.\n //\n@@ -22,13 +22,13 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     $0\n // }\n // ```\n-pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();\n     acc.add(\n-        AssistId(\"add_impl\", AssistKind::Refactor),\n-        format!(\"Implement {}\", name.text().as_str()),\n+        AssistId(\"generate_impl\", AssistKind::Refactor),\n+        format!(\"Generate impl for `{}`\", name),\n         target,\n         |edit| {\n             let type_params = nominal.type_param_list();\n@@ -75,14 +75,18 @@ mod tests {\n \n     #[test]\n     fn test_add_impl() {\n-        check_assist(add_impl, \"struct Foo {<|>}\\n\", \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\");\n         check_assist(\n-            add_impl,\n+            generate_impl,\n+            \"struct Foo {<|>}\\n\",\n+            \"struct Foo {}\\n\\nimpl Foo {\\n    $0\\n}\\n\",\n+        );\n+        check_assist(\n+            generate_impl,\n             \"struct Foo<T: Clone> {<|>}\",\n             \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n    $0\\n}\",\n         );\n         check_assist(\n-            add_impl,\n+            generate_impl,\n             \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n             \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n    $0\\n}\",\n         );\n@@ -91,7 +95,7 @@ mod tests {\n     #[test]\n     fn add_impl_target() {\n         check_assist_target(\n-            add_impl,\n+            generate_impl,\n             \"\n struct SomeThingIrrelevant;\n /// Has a lifetime parameter", "previous_filename": "crates/ra_assists/src/handlers/add_impl.rs"}, {"sha": "b37bba7619d059324ecc627d66e4ba8c6173ff88", "filename": "crates/ra_assists/src/handlers/generate_new.rs", "status": "renamed", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -9,7 +9,7 @@ use stdx::{format_to, SepBy};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-// Assist: add_new\n+// Assist: generate_new\n //\n // Adds a new inherent impl for a type.\n //\n@@ -29,7 +29,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n //\n // ```\n-pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -42,7 +42,7 @@ pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    acc.add(AssistId(\"add_new\", AssistKind::None), \"Add default constructor\", target, |builder| {\n+    acc.add(AssistId(\"generate_new\", AssistKind::None), \"Generate `new`\", target, |builder| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n@@ -181,10 +181,10 @@ mod tests {\n \n     #[test]\n     #[rustfmt::skip]\n-    fn test_add_new() {\n+    fn test_generate_new() {\n         // Check output of generation\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\",\n \"struct Foo {}\n \n@@ -194,7 +194,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo<T: Clone> {<|>}\",\n \"struct Foo<T: Clone> {}\n \n@@ -204,7 +204,7 @@ impl<T: Clone> Foo<T> {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n \"struct Foo<'a, T: Foo<'a>> {}\n \n@@ -214,7 +214,7 @@ impl<'a, T: Foo<'a>> Foo<'a, T> {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { baz: String <|>}\",\n \"struct Foo { baz: String }\n \n@@ -224,7 +224,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { baz: String, qux: Vec<i32> <|>}\",\n \"struct Foo { baz: String, qux: Vec<i32> }\n \n@@ -236,7 +236,7 @@ impl Foo {\n \n         // Check that visibility modifiers don't get brought in for fields\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo { pub baz: String, pub qux: Vec<i32> <|>}\",\n \"struct Foo { pub baz: String, pub qux: Vec<i32> }\n \n@@ -248,7 +248,7 @@ impl Foo {\n \n         // Check that it reuses existing impls\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {}\n@@ -261,7 +261,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {\n@@ -279,7 +279,7 @@ impl Foo {\n         );\n \n         check_assist(\n-            add_new,\n+            generate_new,\n \"struct Foo {<|>}\n \n impl Foo {\n@@ -304,7 +304,7 @@ impl Foo {\n \n         // Check visibility of new fn based on struct\n         check_assist(\n-            add_new,\n+            generate_new,\n \"pub struct Foo {<|>}\",\n \"pub struct Foo {}\n \n@@ -314,7 +314,7 @@ impl Foo {\n \",\n         );\n         check_assist(\n-            add_new,\n+            generate_new,\n \"pub(crate) struct Foo {<|>}\",\n \"pub(crate) struct Foo {}\n \n@@ -326,9 +326,9 @@ impl Foo {\n     }\n \n     #[test]\n-    fn add_new_not_applicable_if_fn_exists() {\n+    fn generate_new_not_applicable_if_fn_exists() {\n         check_assist_not_applicable(\n-            add_new,\n+            generate_new,\n             \"\n struct Foo {<|>}\n \n@@ -340,7 +340,7 @@ impl Foo {\n         );\n \n         check_assist_not_applicable(\n-            add_new,\n+            generate_new,\n             \"\n struct Foo {<|>}\n \n@@ -353,9 +353,9 @@ impl Foo {\n     }\n \n     #[test]\n-    fn add_new_target() {\n+    fn generate_new_target() {\n         check_assist_target(\n-            add_new,\n+            generate_new,\n             \"\n struct SomeThingIrrelevant;\n /// Has a lifetime parameter\n@@ -370,7 +370,7 @@ struct Foo<'a, T: Foo<'a>> {}\",\n     #[test]\n     fn test_unrelated_new() {\n         check_assist(\n-            add_new,\n+            generate_new,\n             r##\"\n pub struct AstId<N: AstNode> {\n     file_id: HirFileId,", "previous_filename": "crates/ra_assists/src/handlers/add_new.rs"}, {"sha": "5b9def052f4df23aafbf9ea9bc0e1ac1afb2edc6", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -112,13 +112,8 @@ mod handlers {\n     pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n-    mod add_derive;\n     mod add_explicit_type;\n-    mod add_from_impl_for_enum;\n-    mod add_function;\n-    mod add_impl;\n     mod add_missing_impl_members;\n-    mod add_new;\n     mod add_turbo_fish;\n     mod apply_demorgan;\n     mod auto_import;\n@@ -132,6 +127,11 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod generate_derive;\n+    mod generate_from_impl_for_enum;\n+    mod generate_function;\n+    mod generate_impl;\n+    mod generate_new;\n     mod inline_local_variable;\n     mod introduce_named_lifetime;\n     mod invert_if;\n@@ -154,12 +154,7 @@ mod handlers {\n         &[\n             // These are alphabetic for the foolish consistency\n             add_custom_impl::add_custom_impl,\n-            add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n-            add_from_impl_for_enum::add_from_impl_for_enum,\n-            add_function::add_function,\n-            add_impl::add_impl,\n-            add_new::add_new,\n             add_turbo_fish::add_turbo_fish,\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n@@ -173,6 +168,11 @@ mod handlers {\n             flip_binexpr::flip_binexpr,\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,\n+            generate_derive::generate_derive,\n+            generate_from_impl_for_enum::generate_from_impl_for_enum,\n+            generate_function::generate_function,\n+            generate_impl::generate_impl,\n+            generate_new::generate_new,\n             inline_local_variable::inline_local_variable,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "eff7feded6221504b8741f1b4c5fc0ece0c435e7", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -21,26 +21,6 @@ impl Debug for S {\n     )\n }\n \n-#[test]\n-fn doctest_add_derive() {\n-    check_doc_test(\n-        \"add_derive\",\n-        r#####\"\n-struct Point {\n-    x: u32,\n-    y: u32,<|>\n-}\n-\"#####,\n-        r#####\"\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_explicit_type() {\n     check_doc_test(\n@@ -58,52 +38,6 @@ fn main() {\n     )\n }\n \n-#[test]\n-fn doctest_add_from_impl_for_enum() {\n-    check_doc_test(\n-        \"add_from_impl_for_enum\",\n-        r#####\"\n-enum A { <|>One(u32) }\n-\"#####,\n-        r#####\"\n-enum A { One(u32) }\n-\n-impl From<u32> for A {\n-    fn from(v: u32) -> Self {\n-        A::One(v)\n-    }\n-}\n-\"#####,\n-    )\n-}\n-\n-#[test]\n-fn doctest_add_function() {\n-    check_doc_test(\n-        \"add_function\",\n-        r#####\"\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar<|>(\"\", baz());\n-}\n-\n-\"#####,\n-        r#####\"\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_hash() {\n     check_doc_test(\n@@ -121,27 +55,6 @@ fn main() {\n     )\n }\n \n-#[test]\n-fn doctest_add_impl() {\n-    check_doc_test(\n-        \"add_impl\",\n-        r#####\"\n-struct Ctx<T: Clone> {\n-    data: T,<|>\n-}\n-\"#####,\n-        r#####\"\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_impl_default_members() {\n     check_doc_test(\n@@ -208,28 +121,6 @@ impl Trait<u32> for () {\n     )\n }\n \n-#[test]\n-fn doctest_add_new() {\n-    check_doc_test(\n-        \"add_new\",\n-        r#####\"\n-struct Ctx<T: Clone> {\n-     data: T,<|>\n-}\n-\"#####,\n-        r#####\"\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_turbo_fish() {\n     check_doc_test(\n@@ -466,6 +357,115 @@ fn foo<T: Copy + Clone>() { }\n     )\n }\n \n+#[test]\n+fn doctest_generate_derive() {\n+    check_doc_test(\n+        \"generate_derive\",\n+        r#####\"\n+struct Point {\n+    x: u32,\n+    y: u32,<|>\n+}\n+\"#####,\n+        r#####\"\n+#[derive($0)]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_from_impl_for_enum() {\n+    check_doc_test(\n+        \"generate_from_impl_for_enum\",\n+        r#####\"\n+enum A { <|>One(u32) }\n+\"#####,\n+        r#####\"\n+enum A { One(u32) }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_function() {\n+    check_doc_test(\n+        \"generate_function\",\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar<|>(\"\", baz());\n+}\n+\n+\"#####,\n+        r#####\"\n+struct Baz;\n+fn baz() -> Baz { Baz }\n+fn foo() {\n+    bar(\"\", baz());\n+}\n+\n+fn bar(arg: &str, baz: Baz) {\n+    ${0:todo!()}\n+}\n+\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_impl() {\n+    check_doc_test(\n+        \"generate_impl\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+    data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+    data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    $0\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_generate_new() {\n+    check_doc_test(\n+        \"generate_new\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    fn $0new(data: T) -> Self { Self { data } }\n+}\n+\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_inline_local_variable() {\n     check_doc_test("}, {"sha": "f9993517068ca18b9def72278de148dbde1da91c", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b6a433c6243b8be72bbd04a40d0a38cedb11b4/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=66b6a433c6243b8be72bbd04a40d0a38cedb11b4", "patch": "@@ -56,8 +56,8 @@ fn check_todo(path: &Path, text: &str) {\n         // Some of our assists generate `todo!()` so those files are whitelisted.\n         \"tests/generated.rs\",\n         \"handlers/add_missing_impl_members.rs\",\n-        \"handlers/add_function.rs\",\n         \"handlers/add_turbo_fish.rs\",\n+        \"handlers/generate_function.rs\",\n         // To support generating `todo!()` in assists, we have `expr_todo()` in ast::make.\n         \"ast/make.rs\",\n     ];"}]}