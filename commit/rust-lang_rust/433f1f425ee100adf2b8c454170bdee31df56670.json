{"sha": "433f1f425ee100adf2b8c454170bdee31df56670", "node_id": "C_kwDOAAsO6NoAKDQzM2YxZjQyNWVlMTAwYWRmMmI4YzQ1NDE3MGJkZWUzMWRmNTY2NzA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-24T22:11:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-24T22:11:02Z"}, "message": "Rollup merge of #96215 - nikic:legacy-pm-removal, r=nagisa\n\nDrop support for legacy PM with LLVM 15\n\nLLVM 15 already removes some of the legacy PM APIs we're using. This patch forces use of NewPM with LLVM 15 (with `-Z new-llvm-pass-manager=no` throwing a warning) and stubs out various FFI methods with a report_fatal_error on LLVM 15.\n\nFor LLVMPassManagerBuilderPopulateLTOPassManager() I went with adding our own wrapper, as the alternative would be to muck about with weak symbols, which seems to be non-trivial as far as cross-platform support is concerned (std has `weak!` for this purpose, but only as an internal utility.)\n\nFixes #96072.\nFixes #96362.", "tree": {"sha": "59966c93769486757fb4cccfbfc9167cacd894bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59966c93769486757fb4cccfbfc9167cacd894bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433f1f425ee100adf2b8c454170bdee31df56670", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZcr2CRBK7hj4Ov3rIwAA9J4IAA9DxNT+SP9dr8ode5zEdKg4\n+E6Ojo7L3ABMn9fGWoZl7aRi3OEl0IWzOh9sde6PgKHl1HbMNJOZbjmXGzKtzPMF\nY+em5JXjmMeznjv0MuvVgDHAzKZ4AuD0xOn5tYzCtaMfpgOgT/R1qMniNxLIpW2T\nImEzFpinJ5cl75Qw3DDgIphlbCFH7rWbERxqvaZqHHwZRUyjbDffIdLkUjiaI1mH\nx8i/9/6oiON+9r6SJg3fSdClpf7RymzqR115QAyk/shOxRSN8Gs6HxO+TAYZPf1d\nFXHssM9buXTHTIdfNxStW8CM7gDaF9QbAw25jTehN07eRmcTHWB4wUHUPbCJgUs=\n=e6pU\n-----END PGP SIGNATURE-----\n", "payload": "tree 59966c93769486757fb4cccfbfc9167cacd894bd\nparent 50294f69cd48e4c9b3ba080632263e2cbb7eb5af\nparent 6dc0bcc5db00524af73eb7dd2f6e24f38736f1aa\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1650838262 +0200\ncommitter GitHub <noreply@github.com> 1650838262 +0200\n\nRollup merge of #96215 - nikic:legacy-pm-removal, r=nagisa\n\nDrop support for legacy PM with LLVM 15\n\nLLVM 15 already removes some of the legacy PM APIs we're using. This patch forces use of NewPM with LLVM 15 (with `-Z new-llvm-pass-manager=no` throwing a warning) and stubs out various FFI methods with a report_fatal_error on LLVM 15.\n\nFor LLVMPassManagerBuilderPopulateLTOPassManager() I went with adding our own wrapper, as the alternative would be to muck about with weak symbols, which seems to be non-trivial as far as cross-platform support is concerned (std has `weak!` for this purpose, but only as an internal utility.)\n\nFixes #96072.\nFixes #96362.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433f1f425ee100adf2b8c454170bdee31df56670", "html_url": "https://github.com/rust-lang/rust/commit/433f1f425ee100adf2b8c454170bdee31df56670", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433f1f425ee100adf2b8c454170bdee31df56670/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50294f69cd48e4c9b3ba080632263e2cbb7eb5af", "url": "https://api.github.com/repos/rust-lang/rust/commits/50294f69cd48e4c9b3ba080632263e2cbb7eb5af", "html_url": "https://github.com/rust-lang/rust/commit/50294f69cd48e4c9b3ba080632263e2cbb7eb5af"}, {"sha": "6dc0bcc5db00524af73eb7dd2f6e24f38736f1aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc0bcc5db00524af73eb7dd2f6e24f38736f1aa", "html_url": "https://github.com/rust-lang/rust/commit/6dc0bcc5db00524af73eb7dd2f6e24f38736f1aa"}], "stats": {"total": 163, "additions": 131, "deletions": 32}, "files": [{"sha": "3f5957bdb6e8f2ede7e2ae34b00c5b15abc4ec18", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -625,7 +625,7 @@ pub(crate) fn run_pass_manager(\n             if thin {\n                 llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n             } else {\n-                llvm::LLVMPassManagerBuilderPopulateLTOPassManager(\n+                llvm::LLVMRustPassManagerBuilderPopulateLTOPassManager(\n                     b, pm, /* Internalize = */ False, /* RunInliner = */ True,\n                 );\n             }"}, {"sha": "99e30531c226f0aa5d3dd08c6d8b05943f311887", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -523,6 +523,12 @@ pub(crate) unsafe fn optimize(\n     let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n+    if let Some(false) = config.new_llvm_pass_manager && llvm_util::get_version() >= (15, 0, 0) {\n+        diag_handler.warn(\n+            \"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported with LLVM 15\",\n+        );\n+    }\n+\n     if config.emit_no_opt_bc {\n         let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path_to_c_string(&out);\n@@ -628,8 +634,8 @@ pub(crate) unsafe fn optimize(\n                         extra_passes.as_ptr(),\n                         extra_passes.len() as size_t,\n                     );\n-                    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                    llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n+                    llvm::LLVMRustPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n+                    llvm::LLVMRustPassManagerBuilderPopulateModulePassManager(b, mpm);\n                 });\n \n                 have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n@@ -1085,7 +1091,7 @@ pub unsafe fn with_llvm_pmb(\n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n-    let builder = llvm::LLVMPassManagerBuilderCreate();\n+    let builder = llvm::LLVMRustPassManagerBuilderCreate();\n     let opt_size = config.opt_size.map_or(llvm::CodeGenOptSizeNone, |x| to_llvm_opt_settings(x).1);\n     let inline_threshold = config.inline_threshold;\n     let pgo_gen_path = get_pgo_gen_path(config);\n@@ -1102,14 +1108,9 @@ pub unsafe fn with_llvm_pmb(\n         pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n         pgo_sample_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n+        opt_size as c_int,\n     );\n \n-    llvm::LLVMPassManagerBuilderSetSizeLevel(builder, opt_size as u32);\n-\n-    if opt_size != llvm::CodeGenOptSizeNone {\n-        llvm::LLVMPassManagerBuilderSetDisableUnrollLoops(builder, 1);\n-    }\n-\n     llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n \n     // Here we match what clang does (kinda). For O0 we only inline\n@@ -1118,16 +1119,16 @@ pub unsafe fn with_llvm_pmb(\n     // thresholds copied from clang.\n     match (opt_level, opt_size, inline_threshold) {\n         (.., Some(t)) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t);\n+            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, t);\n         }\n         (llvm::CodeGenOptLevel::Aggressive, ..) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n+            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n         }\n         (_, llvm::CodeGenOptSizeDefault, _) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n+            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n         }\n         (_, llvm::CodeGenOptSizeAggressive, _) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n+            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n         }\n         (llvm::CodeGenOptLevel::None, ..) => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n@@ -1136,12 +1137,12 @@ pub unsafe fn with_llvm_pmb(\n             llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n         }\n         (llvm::CodeGenOptLevel::Default, ..) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n+            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n     }\n \n     f(builder);\n-    llvm::LLVMPassManagerBuilderDispose(builder);\n+    llvm::LLVMRustPassManagerBuilderDispose(builder);\n }\n \n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`."}, {"sha": "13baaddccd4df5be8bf9d37d83b2ed37c5489fe2", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -1825,24 +1825,22 @@ extern \"C\" {\n \n     pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n-    pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n-    pub fn LLVMPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n-    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: &PassManagerBuilder, Value: Bool);\n-    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: &PassManagerBuilder, Value: Bool);\n-    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+    pub fn LLVMRustPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n+    pub fn LLVMRustPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n+    pub fn LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n         PMB: &PassManagerBuilder,\n         threshold: c_uint,\n     );\n-    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n+    pub fn LLVMRustPassManagerBuilderPopulateModulePassManager(\n         PMB: &PassManagerBuilder,\n         PM: &PassManager<'_>,\n     );\n \n-    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+    pub fn LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n         PMB: &PassManagerBuilder,\n         PM: &PassManager<'_>,\n     );\n-    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+    pub fn LLVMRustPassManagerBuilderPopulateLTOPassManager(\n         PMB: &PassManagerBuilder,\n         PM: &PassManager<'_>,\n         Internalize: Bool,\n@@ -2308,6 +2306,7 @@ extern \"C\" {\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,\n         PGOSampleUsePath: *const c_char,\n+        SizeLevel: c_int,\n     );\n     pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,"}, {"sha": "7b407c94e7b066e8e9c6b30aa98b42b29ba3451d", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -542,6 +542,11 @@ pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_a\n     // The new pass manager is enabled by default for LLVM >= 13.\n     // This matches Clang, which also enables it since Clang 13.\n \n+    // Since LLVM 15, the legacy pass manager is no longer supported.\n+    if llvm_util::get_version() >= (15, 0, 0) {\n+        return true;\n+    }\n+\n     // There are some perf issues with the new pass manager when targeting\n     // s390x with LLVM 13, so enable the new pass manager only with LLVM 14.\n     // See https://github.com/rust-lang/rust/issues/89609."}, {"sha": "38fddbdba54ddf9a04a22a7b52c7fe05065a6161", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -107,6 +107,7 @@ static LLVMRustPassKind toRust(PassKind Kind) {\n }\n \n extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n+#if LLVM_VERSION_LT(15, 0)\n   StringRef SR(PassName);\n   PassRegistry *PR = PassRegistry::getPassRegistry();\n \n@@ -115,36 +116,59 @@ extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n     return wrap(PI->createPass());\n   }\n   return nullptr;\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateAddressSanitizerFunctionPass(bool Recover) {\n+#if LLVM_VERSION_LT(15, 0)\n   const bool CompileKernel = false;\n   const bool UseAfterScope = true;\n \n   return wrap(createAddressSanitizerFunctionPass(CompileKernel, Recover, UseAfterScope));\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateModuleAddressSanitizerPass(bool Recover) {\n+#if LLVM_VERSION_LT(15, 0)\n   const bool CompileKernel = false;\n \n   return wrap(createModuleAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateMemorySanitizerPass(int TrackOrigins, bool Recover) {\n+#if LLVM_VERSION_LT(15, 0)\n   const bool CompileKernel = false;\n \n   return wrap(createMemorySanitizerLegacyPassPass(\n       MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel}));\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateThreadSanitizerPass() {\n+#if LLVM_VERSION_LT(15, 0)\n   return wrap(createThreadSanitizerLegacyPassPass());\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMPassRef LLVMRustCreateHWAddressSanitizerPass(bool Recover) {\n+#if LLVM_VERSION_LT(15, 0)\n   const bool CompileKernel = false;\n \n   return wrap(createHWAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef RustPass) {\n@@ -154,23 +178,84 @@ extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef RustPass) {\n }\n \n extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n+#if LLVM_VERSION_LT(15, 0)\n   assert(RustPass);\n   Pass *Pass = unwrap(RustPass);\n   PassManagerBase *PMB = unwrap(PMR);\n   PMB->add(Pass);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" LLVMPassManagerBuilderRef LLVMRustPassManagerBuilderCreate() {\n+#if LLVM_VERSION_LT(15, 0)\n+  return LLVMPassManagerBuilderCreate();\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" void LLVMRustPassManagerBuilderDispose(LLVMPassManagerBuilderRef PMB) {\n+#if LLVM_VERSION_LT(15, 0)\n+  LLVMPassManagerBuilderDispose(PMB);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" void LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n+  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n+#if LLVM_VERSION_LT(15, 0)\n+  LLVMPassManagerBuilderPopulateFunctionPassManager(PMB, PM);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" void LLVMRustPassManagerBuilderPopulateModulePassManager(\n+  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n+#if LLVM_VERSION_LT(15, 0)\n+  LLVMPassManagerBuilderPopulateModulePassManager(PMB, PM);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" void LLVMRustPassManagerBuilderPopulateLTOPassManager(\n+  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM, bool Internalize, bool RunInliner) {\n+#if LLVM_VERSION_LT(15, 0)\n+  LLVMPassManagerBuilderPopulateLTOPassManager(PMB, PM, Internalize, RunInliner);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\"\n void LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n   LLVMPassManagerBuilderRef PMBR,\n   LLVMPassManagerRef PMR\n ) {\n+#if LLVM_VERSION_LT(15, 0)\n   unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n+}\n+\n+extern \"C\" void LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n+  LLVMPassManagerBuilderRef PMB, unsigned Threshold) {\n+#if LLVM_VERSION_LT(15, 0)\n+  LLVMPassManagerBuilderUseInlinerWithThreshold(PMB, Threshold);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n extern \"C\"\n void LLVMRustAddLastExtensionPasses(\n     LLVMPassManagerBuilderRef PMBR, LLVMPassRef *Passes, size_t NumPasses) {\n+#if LLVM_VERSION_LT(15, 0)\n   auto AddExtensionPasses = [Passes, NumPasses](\n       const PassManagerBuilder &Builder, PassManagerBase &PM) {\n     for (size_t I = 0; I < NumPasses; I++) {\n@@ -183,6 +268,9 @@ void LLVMRustAddLastExtensionPasses(\n                              AddExtensionPasses);\n   unwrap(PMBR)->addExtension(PassManagerBuilder::EP_EnabledOnOptLevel0,\n                              AddExtensionPasses);\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -533,12 +621,16 @@ extern \"C\" void LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n     LLVMPassManagerBuilderRef PMBR, LLVMRustCodeGenOptLevel OptLevel,\n     bool MergeFunctions, bool SLPVectorize, bool LoopVectorize, bool PrepareForThinLTO,\n-    const char* PGOGenPath, const char* PGOUsePath, const char* PGOSampleUsePath) {\n+    const char* PGOGenPath, const char* PGOUsePath, const char* PGOSampleUsePath,\n+    int SizeLevel) {\n+#if LLVM_VERSION_LT(15, 0)\n   unwrap(PMBR)->MergeFunctions = MergeFunctions;\n   unwrap(PMBR)->SLPVectorize = SLPVectorize;\n   unwrap(PMBR)->OptLevel = fromRust(OptLevel);\n   unwrap(PMBR)->LoopVectorize = LoopVectorize;\n   unwrap(PMBR)->PrepareForThinLTO = PrepareForThinLTO;\n+  unwrap(PMBR)->SizeLevel = SizeLevel;\n+  unwrap(PMBR)->DisableUnrollLoops = SizeLevel != 0;\n \n   if (PGOGenPath) {\n     assert(!PGOUsePath && !PGOSampleUsePath);\n@@ -550,6 +642,9 @@ extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n   } else if (PGOSampleUsePath) {\n     unwrap(PMBR)->PGOSampleUse = PGOSampleUsePath;\n   }\n+#else\n+  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n+#endif\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`"}, {"sha": "850b80e42801bfe31074df388103e21e87a66317", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -6,6 +6,7 @@\n #include \"llvm/IR/GlobalVariable.h\"\n #include \"llvm/IR/Instructions.h\"\n #include \"llvm/IR/Intrinsics.h\"\n+#include \"llvm/IR/Mangler.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/COFFImportFile.h\"\n #include \"llvm/Object/ObjectFile.h\""}, {"sha": "7a84484c41996906a75af3073afb4f81be5e17ec", "filename": "src/test/codegen/panic-in-drop-abort.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/433f1f425ee100adf2b8c454170bdee31df56670/src%2Ftest%2Fcodegen%2Fpanic-in-drop-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433f1f425ee100adf2b8c454170bdee31df56670/src%2Ftest%2Fcodegen%2Fpanic-in-drop-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpanic-in-drop-abort.rs?ref=433f1f425ee100adf2b8c454170bdee31df56670", "patch": "@@ -1,14 +1,12 @@\n-// compile-flags: -Z panic-in-drop=abort -O -Z new-llvm-pass-manager=no\n+// compile-flags: -Z panic-in-drop=abort -O\n+// ignore-msvc\n \n // Ensure that unwinding code paths are eliminated from the output after\n // optimization.\n \n-// This test uses -Z new-llvm-pass-manager=no, because the expected optimization does not happen\n-// on targets using SEH exceptions (i.e. MSVC) anymore. The core issue is that Rust promises that\n-// the drop_in_place() function can't unwind, but implements it in a way that *can*, because we\n-// currently go out of our way to allow longjmps, which also use the unwinding mechanism on MSVC\n-// targets. We should either forbid longjmps, or not assume nounwind, making this optimization\n-// incompatible with the current behavior of running cleanuppads on longjmp unwinding.\n+// This test uses ignore-msvc, because the expected optimization does not happen on targets using\n+// SEH exceptions with the new LLVM pass manager anymore, see\n+// https://github.com/llvm/llvm-project/issues/51311.\n \n // CHECK-NOT: {{(call|invoke).*}}should_not_appear_in_output\n "}]}