{"sha": "72ecd79a6c92bd946362e7696ee86a51f337e12f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZWNkNzlhNmM5MmJkOTQ2MzYyZTc2OTZlZTg2YTUxZjMzN2UxMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-02T18:16:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-02T18:16:09Z"}, "message": "Auto merge of #40919 - GuillaumeGomez:fix-new-rustdoc, r=frewsxcv,steveklabnik\n\nAdd support for image, rules and footnotes\n\nPart of #40912.\n\nr? @rust-lang/docs\n\nPS: the footnotes are waiting for https://github.com/google/pulldown-cmark/pull/21 to be merged to be fully working.", "tree": {"sha": "9cb7668def0556da844069189441f2e761d3a4ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb7668def0556da844069189441f2e761d3a4ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72ecd79a6c92bd946362e7696ee86a51f337e12f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72ecd79a6c92bd946362e7696ee86a51f337e12f", "html_url": "https://github.com/rust-lang/rust/commit/72ecd79a6c92bd946362e7696ee86a51f337e12f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72ecd79a6c92bd946362e7696ee86a51f337e12f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e122f59ba23494d460466cca53c71646d99c767", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e122f59ba23494d460466cca53c71646d99c767", "html_url": "https://github.com/rust-lang/rust/commit/5e122f59ba23494d460466cca53c71646d99c767"}, {"sha": "ef01ae7fe0652c050ec9af8f70990bb01309ffbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef01ae7fe0652c050ec9af8f70990bb01309ffbc", "html_url": "https://github.com/rust-lang/rust/commit/ef01ae7fe0652c050ec9af8f70990bb01309ffbc"}], "stats": {"total": 264, "additions": 232, "deletions": 32}, "files": [{"sha": "0b098fb14f1904c2f43a8879ab061d8a8cbe10d3", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 159, "deletions": 30, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=72ecd79a6c92bd946362e7696ee86a51f337e12f", "patch": "@@ -27,6 +27,7 @@\n \n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n+use std::collections::HashMap;\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::str;\n@@ -115,15 +116,19 @@ macro_rules! event_loop_break {\n             match event {\n                 $($end_event)|* => break,\n                 Event::Text(ref s) => {\n+                    debug!(\"Text\");\n                     inner($id, s);\n                     if $escape {\n                         $buf.push_str(&format!(\"{}\", Escape(s)));\n                     } else {\n                         $buf.push_str(s);\n                     }\n                 }\n-                Event::SoftBreak | Event::HardBreak if !$buf.is_empty() => {\n-                    $buf.push(' ');\n+                Event::SoftBreak => {\n+                    debug!(\"SoftBreak\");\n+                    if !$buf.is_empty() {\n+                        $buf.push(' ');\n+                    }\n                 }\n                 x => {\n                     looper($parser, &mut $buf, Some(x), $toc_builder, $shorter, $id);\n@@ -133,11 +138,38 @@ macro_rules! event_loop_break {\n     }}\n }\n \n+struct ParserWrapper<'a> {\n+    parser: Parser<'a>,\n+    // The key is the footnote reference. The value is the footnote definition and the id.\n+    footnotes: HashMap<String, (String, u16)>,\n+}\n+\n+impl<'a> ParserWrapper<'a> {\n+    pub fn new(s: &'a str) -> ParserWrapper<'a> {\n+        ParserWrapper {\n+            parser: Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES |\n+                                       pulldown_cmark::OPTION_ENABLE_FOOTNOTES),\n+            footnotes: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn next(&mut self) -> Option<Event<'a>> {\n+        self.parser.next()\n+    }\n+\n+    pub fn get_entry(&mut self, key: &str) -> &mut (String, u16) {\n+        let new_id = self.footnotes.keys().count() + 1;\n+        let key = key.to_owned();\n+        self.footnotes.entry(key).or_insert((String::new(), new_id as u16))\n+    }\n+}\n+\n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n               shorter: MarkdownOutputStyle) -> fmt::Result {\n-    fn code_block(parser: &mut Parser, buffer: &mut String, lang: &str) {\n+    fn code_block(parser: &mut ParserWrapper, buffer: &mut String, lang: &str) {\n+        debug!(\"CodeBlock\");\n         let mut origtext = String::new();\n         while let Some(event) = parser.next() {\n             match event {\n@@ -215,8 +247,9 @@ pub fn render(w: &mut fmt::Formatter,\n         });\n     }\n \n-    fn heading(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-               shorter: MarkdownOutputStyle, level: i32) {\n+    fn heading(parser: &mut ParserWrapper, buffer: &mut String,\n+               toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle, level: i32) {\n+        debug!(\"Heading\");\n         let mut ret = String::new();\n         let mut id = String::new();\n         event_loop_break!(parser, toc_builder, shorter, ret, true, &mut Some(&mut id),\n@@ -249,32 +282,53 @@ pub fn render(w: &mut fmt::Formatter,\n                                  ret, lvl = level, id = id, sec = sec));\n     }\n \n-    fn inline_code(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                   shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+    fn inline_code(parser: &mut ParserWrapper, buffer: &mut String,\n+                   toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n+                   id: &mut Option<&mut String>) {\n+        debug!(\"InlineCode\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, false, id, Event::End(Tag::Code));\n         buffer.push_str(&format!(\"<code>{}</code>\",\n                                  Escape(&collapse_whitespace(content.trim_right()))));\n     }\n \n-    fn link(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+    fn link(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle, url: &str, title: &str,\n+            id: &mut Option<&mut String>) {\n+        debug!(\"Link\");\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n+                          Event::End(Tag::Link(_, _)));\n+        if title.is_empty() {\n+            buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, content));\n+        } else {\n+            buffer.push_str(&format!(\"<a href=\\\"{}\\\" title=\\\"{}\\\">{}</a>\",\n+                                     url, Escape(title), content));\n+        }\n+    }\n+\n+    fn image(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n             shorter: MarkdownOutputStyle, url: &str, mut title: String,\n             id: &mut Option<&mut String>) {\n+        debug!(\"Image\");\n         event_loop_break!(parser, toc_builder, shorter, title, true, id,\n-                          Event::End(Tag::Link(_, _)));\n-        buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n+                          Event::End(Tag::Image(_, _)));\n+        buffer.push_str(&format!(\"<img src=\\\"{}\\\" alt=\\\"{}\\\">\", url, title));\n     }\n \n-    fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+    fn paragraph(parser: &mut ParserWrapper, buffer: &mut String,\n+                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n+                 id: &mut Option<&mut String>) {\n+        debug!(\"Paragraph\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, true, id,\n                           Event::End(Tag::Paragraph));\n         buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n     }\n \n-    fn table_cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n+    fn table_cell(parser: &mut ParserWrapper, buffer: &mut String,\n+                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n+        debug!(\"TableCell\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n                           Event::End(Tag::TableHead) |\n@@ -284,8 +338,9 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n     }\n \n-    fn table_row(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle) {\n+    fn table_row(parser: &mut ParserWrapper, buffer: &mut String,\n+                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n+        debug!(\"TableRow\");\n         let mut content = String::new();\n         while let Some(event) = parser.next() {\n             match event {\n@@ -303,8 +358,9 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n     }\n \n-    fn table_head(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n+    fn table_head(parser: &mut ParserWrapper, buffer: &mut String,\n+                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n+        debug!(\"TableHead\");\n         let mut content = String::new();\n         while let Some(event) = parser.next() {\n             match event {\n@@ -322,8 +378,9 @@ pub fn render(w: &mut fmt::Formatter,\n         }\n     }\n \n-    fn table(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+    fn table(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n              shorter: MarkdownOutputStyle) {\n+        debug!(\"Table\");\n         let mut content = String::new();\n         let mut rows = String::new();\n         while let Some(event) = parser.next() {\n@@ -347,16 +404,18 @@ pub fn render(w: &mut fmt::Formatter,\n                                  }));\n     }\n \n-    fn blockquote(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                  shorter: MarkdownOutputStyle) {\n+    fn blockquote(parser: &mut ParserWrapper, buffer: &mut String,\n+                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n+        debug!(\"BlockQuote\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n                           Event::End(Tag::BlockQuote));\n         buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n     }\n \n-    fn list_item(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: MarkdownOutputStyle) {\n+    fn list_item(parser: &mut ParserWrapper, buffer: &mut String,\n+                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n+        debug!(\"ListItem\");\n         let mut content = String::new();\n         while let Some(event) = parser.next() {\n             match event {\n@@ -372,8 +431,9 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<li>{}</li>\", content));\n     }\n \n-    fn list(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+    fn list(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n             shorter: MarkdownOutputStyle) {\n+        debug!(\"List\");\n         let mut content = String::new();\n         while let Some(event) = parser.next() {\n             match event {\n@@ -389,23 +449,45 @@ pub fn render(w: &mut fmt::Formatter,\n         buffer.push_str(&format!(\"<ul>{}</ul>\", content));\n     }\n \n-    fn emphasis(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+    fn emphasis(parser: &mut ParserWrapper, buffer: &mut String,\n+                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n+                id: &mut Option<&mut String>) {\n+        debug!(\"Emphasis\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, false, id,\n                           Event::End(Tag::Emphasis));\n         buffer.push_str(&format!(\"<em>{}</em>\", content));\n     }\n \n-    fn strong(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+    fn strong(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n               shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        debug!(\"Strong\");\n         let mut content = String::new();\n         event_loop_break!(parser, toc_builder, shorter, content, false, id,\n                           Event::End(Tag::Strong));\n         buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n     }\n \n-    fn looper<'a>(parser: &'a mut Parser, buffer: &mut String, next_event: Option<Event<'a>>,\n+    fn footnote(parser: &mut ParserWrapper, buffer: &mut String,\n+                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n+                id: &mut Option<&mut String>) {\n+        debug!(\"FootnoteDefinition\");\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n+                          Event::End(Tag::FootnoteDefinition(_)));\n+        buffer.push_str(&content);\n+    }\n+\n+    fn rule(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n+        debug!(\"Rule\");\n+        let mut content = String::new();\n+        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n+                          Event::End(Tag::Rule));\n+        buffer.push_str(\"<hr>\");\n+    }\n+\n+    fn looper<'a>(parser: &'a mut ParserWrapper, buffer: &mut String, next_event: Option<Event<'a>>,\n                   toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n                   id: &mut Option<&mut String>) -> bool {\n         if let Some(event) = next_event {\n@@ -423,7 +505,10 @@ pub fn render(w: &mut fmt::Formatter,\n                     paragraph(parser, buffer, toc_builder, shorter, id);\n                 }\n                 Event::Start(Tag::Link(ref url, ref t)) => {\n-                    link(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n+                    link(parser, buffer, toc_builder, shorter, url, t.as_ref(), id);\n+                }\n+                Event::Start(Tag::Image(ref url, ref t)) => {\n+                    image(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n                 }\n                 Event::Start(Tag::Table(_)) => {\n                     table(parser, buffer, toc_builder, shorter);\n@@ -440,7 +525,42 @@ pub fn render(w: &mut fmt::Formatter,\n                 Event::Start(Tag::Strong) => {\n                     strong(parser, buffer, toc_builder, shorter, id);\n                 }\n+                Event::Start(Tag::Rule) => {\n+                    rule(parser, buffer, toc_builder, shorter, id);\n+                }\n+                Event::Start(Tag::FootnoteDefinition(ref def)) => {\n+                    debug!(\"FootnoteDefinition\");\n+                    let mut content = String::new();\n+                    let def = def.as_ref();\n+                    footnote(parser, &mut content, toc_builder, shorter, id);\n+                    let entry = parser.get_entry(def);\n+                    let cur_id = (*entry).1;\n+                    (*entry).0.push_str(&format!(\"<li id=\\\"ref{}\\\">{}&nbsp;<a href=\\\"#supref{0}\\\" \\\n+                                                  rev=\\\"footnote\\\">\u21a9</a></p></li>\",\n+                                                 cur_id,\n+                                                 if content.ends_with(\"</p>\") {\n+                                                     &content[..content.len() - 4]\n+                                                 } else {\n+                                                     &content\n+                                                 }));\n+                }\n+                Event::FootnoteReference(ref reference) => {\n+                    debug!(\"FootnoteReference\");\n+                    let entry = parser.get_entry(reference.as_ref());\n+                    buffer.push_str(&format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}</a>\\\n+                                              </sup>\",\n+                                             (*entry).1));\n+                }\n+                Event::HardBreak => {\n+                    debug!(\"HardBreak\");\n+                    if shorter.is_fancy() {\n+                        buffer.push_str(\"<br>\");\n+                    } else if !buffer.is_empty() {\n+                        buffer.push(' ');\n+                    }\n+                }\n                 Event::Html(h) | Event::InlineHtml(h) => {\n+                    debug!(\"Html/InlineHtml\");\n                     buffer.push_str(&*h);\n                 }\n                 _ => {}\n@@ -457,13 +577,22 @@ pub fn render(w: &mut fmt::Formatter,\n         None\n     };\n     let mut buffer = String::new();\n-    let mut parser = Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES);\n+    let mut parser = ParserWrapper::new(s);\n     loop {\n         let next_event = parser.next();\n         if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter, &mut None) {\n             break\n         }\n     }\n+    if !parser.footnotes.is_empty() {\n+        let mut v: Vec<_> = parser.footnotes.values().collect();\n+        v.sort_by(|a, b| a.1.cmp(&b.1));\n+        buffer.push_str(&format!(\"<div class=\\\"footnotes\\\"><hr><ol>{}</ol></div>\",\n+                                 v.iter()\n+                                  .map(|s| s.0.as_str())\n+                                  .collect::<Vec<_>>()\n+                                  .join(\"\")));\n+    }\n     let mut ret = toc_builder.map_or(Ok(()), |builder| {\n         write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n     });"}, {"sha": "59fef8d20271bf83e23d8122406f93a18a14feac", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=72ecd79a6c92bd946362e7696ee86a51f337e12f", "patch": "@@ -82,7 +82,7 @@ fn unindent(s: &str) -> String {\n     });\n \n     if !lines.is_empty() {\n-        let mut unindented = vec![ lines[0].trim().to_string() ];\n+        let mut unindented = vec![ lines[0].trim_left().to_string() ];\n         unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n             if line.chars().all(|c| c.is_whitespace()) {\n                 line.to_string()\n@@ -160,4 +160,15 @@ mod unindent_tests {\n         let r = unindent(&s);\n         assert_eq!(r, \"line1\\nline2\");\n     }\n+\n+    #[test]\n+    fn should_not_trim() {\n+        let s = \"\\t    line1  \\n\\t    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1  \\nline2\");\n+\n+        let s = \"    \\tline1  \\n    \\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1  \\nline2\");\n+    }\n }"}, {"sha": "5c5e3f8136c7311f717f642a8f1abf2791b72dc8", "filename": "src/test/rustdoc/check-hard-break.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs?ref=72ecd79a6c92bd946362e7696ee86a51f337e12f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-end-whitespace\n+\n+// @has foo/fn.f.html\n+// @has - '<p>hard break:<br>after hard break</p>'\n+/// hard break:  \n+/// after hard break\n+pub fn f() {}"}, {"sha": "4d3bea20ba89586bc1664c8155cb06786159ed57", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=72ecd79a6c92bd946362e7696ee86a51f337e12f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-linelength\n+\n+// @has foo/fn.f.html\n+// @has - '<p>markdown test</p><p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p><p>hard break: after hard break</p><hr><p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p><p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p><p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\"></p><div class=\"footnotes\"><hr><ol><li id=\"ref1\"><p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\"><p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n+/// markdown test\n+///\n+/// this is a [link].\n+///\n+/// [link]: https://example.com \"this is a title\"\n+///\n+/// hard break:\n+/// after hard break\n+///\n+/// -----------\n+///\n+/// a footnote[^footnote].\n+///\n+/// another footnote[^footnotebis].\n+///\n+/// [^footnote]: Thing\n+///\n+///\n+/// [^footnotebis]: Another Thing\n+///\n+///\n+/// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n+#[deprecated(note = \"Struct<T>\")]\n+pub fn f() {}"}, {"sha": "012301299e0c54029a72cf35de4663bab803ff87", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ecd79a6c92bd946362e7696ee86a51f337e12f/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=72ecd79a6c92bd946362e7696ee86a51f337e12f", "patch": "@@ -110,6 +110,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let skip_cr = contents.contains(\"ignore-tidy-cr\");\n         let skip_tab = contents.contains(\"ignore-tidy-tab\");\n         let skip_length = contents.contains(\"ignore-tidy-linelength\");\n+        let skip_end_whitespace = contents.contains(\"ignore-tidy-end-whitespace\");\n         for (i, line) in contents.split(\"\\n\").enumerate() {\n             let mut err = |msg: &str| {\n                 println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n@@ -122,7 +123,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n             if line.contains(\"\\t\") && !skip_tab {\n                 err(\"tab character\");\n             }\n-            if line.ends_with(\" \") || line.ends_with(\"\\t\") {\n+            if !skip_end_whitespace && (line.ends_with(\" \") || line.ends_with(\"\\t\")) {\n                 err(\"trailing whitespace\");\n             }\n             if line.contains(\"\\r\") && !skip_cr {"}]}