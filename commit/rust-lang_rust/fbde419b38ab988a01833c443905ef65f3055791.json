{"sha": "fbde419b38ab988a01833c443905ef65f3055791", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZGU0MTliMzhhYjk4OGEwMTgzM2M0NDM5MDVlZjY1ZjMwNTU3OTE=", "commit": {"author": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-07T18:34:20Z"}, "committer": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-07T18:34:20Z"}, "message": "Addressed style concerns in btree.rs and added it to the lib file.\nAdded documentation within btree.rs.", "tree": {"sha": "60f1a76c8bdd1b8ede9965bbb7a9e8d064ea6bf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60f1a76c8bdd1b8ede9965bbb7a9e8d064ea6bf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbde419b38ab988a01833c443905ef65f3055791", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbde419b38ab988a01833c443905ef65f3055791", "html_url": "https://github.com/rust-lang/rust/commit/fbde419b38ab988a01833c443905ef65f3055791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbde419b38ab988a01833c443905ef65f3055791/comments", "author": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "058d785369e3fc27f7f67b9ea019dae68603f4af", "url": "https://api.github.com/repos/rust-lang/rust/commits/058d785369e3fc27f7f67b9ea019dae68603f4af", "html_url": "https://github.com/rust-lang/rust/commit/058d785369e3fc27f7f67b9ea019dae68603f4af"}], "stats": {"total": 185, "additions": 125, "deletions": 60}, "files": [{"sha": "e3382cb6c191113e1244affa44adbe384244377f", "filename": "src/libextra/btree.rs", "status": "modified", "additions": 124, "deletions": 60, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/fbde419b38ab988a01833c443905ef65f3055791/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbde419b38ab988a01833c443905ef65f3055791/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=fbde419b38ab988a01833c443905ef65f3055791", "patch": "@@ -7,28 +7,35 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n //\n // btree.rs\n-// Nif Ward\n-// 10/24/13\n //\n // starting implementation of a btree for rust\n // inspired by github user davidhalperin's gist\n \n \n-//What's in a BTree?\n+use std::util::replace;\n+\n+\n+///A B-tree contains a root node (which contains a vector of elements),\n+///a length (the height of the tree), and lower and upper bounds on the\n+///number of elements that a given node can contain.\n+#[allow(missing_doc)]\n pub struct BTree<K, V>{\n     root: Node<K, V>,\n     len: uint,\n     lower_bound: uint,\n     upper_bound: uint\n }\n \n-\n+//We would probably want to remove the dependence on the Clone trait in the future.\n+//It is here as a crutch to ensure values can be passed around through the tree's nodes\n+//especially during insertions and deletions.\n+//Using the swap or replace methods is one option for replacing dependence on Clone, or\n+//changing the way in which the BTree is stored could also potentially work.\n impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n \n-    //Returns new BTree with root node (leaf) and user-supplied lower bound\n+    ///Returns new BTree with root node (leaf) and user-supplied lower bound\n     fn new(k: K, v: V, lb: uint) -> BTree<K, V>{\n         BTree{\n             root: Node::new_leaf(~[LeafElt::new(k, v)]),\n@@ -38,7 +45,8 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n         }\n     }\n \n-    //Helper function for clone\n+    ///Helper function for clone: returns new BTree with supplied root node,\n+    ///length, and lower bound.  For use when the length is known already.\n     fn new_with_node_len(n: Node<K, V>, length: uint, lb: uint) -> BTree<K, V>{\n         BTree{\n             root: n,\n@@ -48,21 +56,25 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n         }\n     }\n \n-\n+    ///Implements the Clone trait for the BTree.\n+    ///Uses a helper function/constructor to produce a new BTree.\n     fn clone(&self) -> BTree<K, V>{\n         return BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound);\n     }\n \n+    ///Returns the value of a given key, which may not exist in the tree.\n+    ///Calls the root node's get method.\n     fn get(self, k: K) -> Option<V>{\n         return self.root.get(k);\n     }\n \n-\n+    ///Checks to see if the key already exists in the tree, and if it is not,\n+    ///the key-value pair is added to the tree by calling add on the root node.\n     fn add(self, k: K, v: V) -> bool{\n         let is_get = &self.clone().get(k.clone());\n         if is_get.is_some(){ return false; }\n         else{\n-            std::util::replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n+            replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n             return true;\n         }\n \n@@ -73,15 +85,19 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n }\n \n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n-    //Returns a string representation of the BTree\n+    ///Returns a string representation of the BTree\n     fn to_str(&self) -> ~str{\n-        let ret=self.root.to_str();\n-        return ret;\n+        let ret = self.root.to_str();\n+        ret\n     }\n }\n \n \n //Node types\n+//A node is either a LeafNode or a BranchNode, which contain either a Leaf or a Branch.\n+//Branches contain BranchElts, which contain a left child (another node) and a key-value\n+//pair.  Branches also contain the rightmost child of the elements in the array.\n+//Leaves contain LeafElts, which do not have children.\n enum Node<K, V>{\n     LeafNode(Leaf<K, V>),\n     BranchNode(Branch<K, V>)\n@@ -90,120 +106,139 @@ enum Node<K, V>{\n \n //Node functions/methods\n impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n-    //differentiates between leaf and branch nodes\n+\n+    ///Differentiates between leaf and branch nodes.\n     fn is_leaf(&self) -> bool{\n         match self{\n             &LeafNode(*) => true,\n             &BranchNode(*) => false\n         }\n     }\n \n-    //Creates a new leaf or branch node\n+    ///Creates a new leaf node given a vector of elements.\n     fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V>{\n-         LeafNode(Leaf::new(vec))\n+        LeafNode(Leaf::new(vec))\n     }\n+\n+    ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n     fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V>{\n         BranchNode(Branch::new(vec, right))\n     }\n \n+\n+    ///Returns the corresponding value to the provided key.\n+    ///get() is called in different ways on a branch or a leaf.\n     fn get(&self, k: K) -> Option<V>{\n         match *self{\n             LeafNode(ref leaf) => return leaf.get(k),\n             BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n \n-    //A placeholder for add\n-    //Currently returns a leaf node with a single value (the added one)\n+    ///A placeholder for add\n+    ///Currently returns a leaf node with a single value (the added one)\n     fn add(self, k: K, v: V) -> Node<K, V>{\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n }\n \n-\n+//Again, this might not be necessary in the future.\n impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V>{\n+\n+    ///Returns a new node based on whether or not it is a branch or a leaf.\n     fn clone(&self) -> Node<K, V>{\n         match *self{\n             LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n             BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(),\n-                                      branch.rightmost_child.clone())\n+                                                              branch.rightmost_child.clone())\n         }\n     }\n }\n \n+//The following impl is unfinished.  Old iterations of code are left in for\n+//future reference when implementing this trait (commented-out).\n impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n+\n+    ///Placeholder for an implementation of TotalOrd for Nodes.\n     #[allow(unused_variable)]\n     fn cmp(&self, other: &Node<K, V>) -> Ordering{\n         //Requires a match statement--defer these procs to branch and leaf.\n         /* if self.elts[0].less_than(other.elts[0]) { return Less}\n         if self.elts[0].greater_than(other.elts[0]) {return Greater}\n-        else {return Equal}\n-        */\n+            else {return Equal}\n+         */\n         return Equal;\n     }\n }\n \n+//The following impl is unfinished.  Old iterations of code are left in for\n+//future reference when implementing this trait (commented-out).\n impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n-    //Making sure Nodes have TotalEq\n+\n+    ///Placeholder for an implementation of TotalEq for Nodes.\n     #[allow(unused_variable)]\n     fn equals(&self, other: &Node<K, V>) -> bool{\n-    /* put in a match and defer this stuff to branch and leaf\n+        /* put in a match and defer this stuff to branch and leaf\n \n         let mut shorter = 0;\n         if self.elts.len() <= other.elts.len(){\n-            shorter = self.elts.len();\n-        }\n-        else{\n-            shorter = other.elts.len();\n-        }\n+        shorter = self.elts.len();\n+    }\n+            else{\n+        shorter = other.elts.len();\n+    }\n         let mut i = 0;\n         while i < shorter{\n-            if !self.elts[i].has_key(other.elts[i].key){\n-                return false;\n-            }\n-            i +=1;\n-        }\n+        if !self.elts[i].has_key(other.elts[i].key){\n+        return false;\n+    }\n+        i +=1;\n+    }\n+        return true;\n+         */\n         return true;\n-    */\n-    return true;\n     }\n }\n \n \n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n+    ///Returns a string representation of a Node.\n+    ///The Branch's to_str() is not implemented yet.\n     fn to_str(&self) -> ~str{\n-       match *self{\n-           LeafNode(ref leaf) => leaf.to_str(),\n-           BranchNode(*) => ~\"\"\n-       }\n+        match *self{\n+            LeafNode(ref leaf) => leaf.to_str(),\n+            BranchNode(*) => ~\"\"\n+        }\n     }\n }\n \n \n-//Array with no children\n+//A leaf is a vector with elements that contain no children.  A leaf also\n+//does not contain a rightmost child.\n struct Leaf<K, V>{\n     elts: ~[LeafElt<K, V>]\n }\n \n-//Array of values with children, plus a rightmost child (greater than all)\n+//Vector of values with children, plus a rightmost child (greater than all)\n struct Branch<K, V>{\n     elts: ~[BranchElt<K,V>],\n     rightmost_child: ~Node<K, V>\n }\n \n \n impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n-    //Constructor takes in a vector of leaves\n+\n+    ///Creates a new Leaf from a vector of LeafElts.\n     fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V>{\n         Leaf{\n             elts: vec\n         }\n     }\n \n-\n+    ///Returns the corresponding value to the supplied key.\n     fn get(&self, k: K) -> Option<V>{\n         for s in self.elts.iter(){\n-            let order=s.key.cmp(&k);\n+            let order = s.key.cmp(&k);\n             match order{\n                 Equal => return Some(s.value.clone()),\n                 _ => {}\n@@ -212,34 +247,40 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n         return None;\n     }\n \n-    //Add method in progress\n+    ///Placeholder for add method in progress.\n+    ///Currently returns a new Leaf containing a single LeafElt.\n     fn add(&self, k: K, v: V) -> Node<K, V>{\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n \n }\n \n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V>{\n+\n+    ///Returns a string representation of a Leaf.\n     fn to_str(&self) -> ~str{\n-       let mut ret=~\"\";\n-       for s in self.elts.iter(){\n-           ret = ret+\" // \"+ s.to_str();\n-       }\n-       return ret;\n+        let mut ret = ~\"\";\n+        for s in self.elts.iter(){\n+            ret = ret + \" // \" + s.to_str();\n+        }\n+        ret\n     }\n \n }\n \n \n impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n-    //constructor takes a branch vector and a rightmost child\n+\n+    ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n     fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V>{\n         Branch{\n             elts: vec,\n             rightmost_child: right\n         }\n     }\n \n+    ///Returns the corresponding value to the supplied key.\n+    ///If the key is not there, find the child that might hold it.\n     fn get(&self, k: K) -> Option<V>{\n         for s in self.elts.iter(){\n             let order = s.key.cmp(&k);\n@@ -250,36 +291,40 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n             }\n         }\n         return self.rightmost_child.get(k);\n-     }\n+    }\n \n \n-    //Add method in progress\n+    ///Placeholder for add method in progress\n     fn add(&self, k: K, v: V) -> Node<K, V>{\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n }\n \n-//No left child\n+//A LeafElt containts no left child, but a key-value pair.\n struct LeafElt<K, V>{\n     key: K,\n     value: V\n }\n \n-//Has a left child\n+//A BranchElt has a left child in addition to a key-value pair.\n struct BranchElt<K, V>{\n     left: Node<K, V>,\n     key: K,\n     value: V\n }\n \n impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n+\n+    ///Creates a new LeafElt from a supplied key-value pair.\n     fn new(k: K, v: V) -> LeafElt<K, V>{\n         LeafElt{\n             key: k,\n             value: v\n         }\n     }\n \n+    ///Compares another LeafElt against itself and determines whether\n+    ///the original LeafElt's key is less than the other one's key.\n     fn less_than(&self, other: LeafElt<K, V>) -> bool{\n         let order = self.key.cmp(&other.key);\n         match order{\n@@ -288,6 +333,8 @@ impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n         }\n     }\n \n+    ///Compares another LeafElt against itself and determines whether\n+    ///the original LeafElt's key is greater than the other one's key.\n     fn greater_than(&self, other: LeafElt<K, V>) -> bool{\n         let order = self.key.cmp(&other.key);\n         match order{\n@@ -296,7 +343,8 @@ impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n         }\n     }\n \n-\n+    ///Takes a key and determines whether its own key and the supplied key\n+    ///are the same.\n     fn has_key(&self, other: K) -> bool{\n         let order = self.key.cmp(&other);\n         match order{\n@@ -307,20 +355,28 @@ impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n \n }\n \n+//This may be eliminated in the future to perserve efficiency by adjusting the way\n+//the BTree as a whole is stored in memory.\n impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V>{\n+\n+    ///Returns a new LeafElt by cloning the key and value.\n     fn clone(&self) -> LeafElt<K, V>{\n         return LeafElt::new(self.key.clone(), self.value.clone());\n     }\n }\n \n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V>{\n+\n+    ///Returns a string representation of a LeafElt.\n     fn to_str(&self) -> ~str{\n-        return \"Key: \"+self.key.to_str()+\", value: \"+self.value.to_str()+\"; \";\n+        return \"Key: \" + self.key.to_str() + \", value: \"+ self.value.to_str() + \"; \";\n     }\n \n }\n \n impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n+\n+    ///Creates a new BranchElt from a supplied key, value, and left child.\n     fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V>{\n         BranchElt{\n             left: n,\n@@ -329,13 +385,16 @@ impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n         }\n     }\n \n-    //Add method in progress.  Should it return a branch or a leaf elt?\n+    ///Placeholder for add method in progress.\n+    ///Overall implementation will determine the actual return value of this method.\n     fn add(&self, k: K, v: V) -> LeafElt<K, V>{\n         return LeafElt::new(k, v);\n     }\n }\n \n impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V>{\n+\n+    ///Returns a new BranchElt by cloning the key, value, and left child.\n     fn clone(&self) -> BranchElt<K, V>{\n         return BranchElt::new(self.key.clone(), self.value.clone(), self.left.clone());\n     }\n@@ -346,35 +405,40 @@ mod test_btree{\n \n     use super::*;\n \n+    ///Tests the functionality of the add methods (which are unfinished).\n     #[test]\n     fn add_test(){\n         let b = BTree::new(1, ~\"abc\", 2);\n         let is_add = b.add(2, ~\"xyz\");\n         assert!(is_add);\n     }\n \n+    ///Tests the functionality of the get method.\n     #[test]\n     fn get_test(){\n         let b = BTree::new(1, ~\"abc\", 2);\n         let val = b.get(1);\n         assert_eq!(val, Some(~\"abc\"));\n     }\n \n-    //Testing LeafElt<K, V> functions (less_than, greater_than, and has_key)\n+    ///Tests the LeafElt's less_than() method.\n     #[test]\n     fn leaf_lt(){\n         let l1 = LeafElt::new(1, ~\"abc\");\n         let l2 = LeafElt::new(2, ~\"xyz\");\n         assert!(l1.less_than(l2));\n     }\n \n+\n+    ///Tests the LeafElt's greater_than() method.\n     #[test]\n     fn leaf_gt(){\n         let l1 = LeafElt::new(1, ~\"abc\");\n         let l2 = LeafElt::new(2, ~\"xyz\");\n         assert!(l2.greater_than(l1));\n     }\n \n+    ///Tests the LeafElt's has_key() method.\n     #[test]\n     fn leaf_hk(){\n         let l1 = LeafElt::new(1, ~\"abc\");"}, {"sha": "8bb996172743ab21769ba9eb7f62435757a80938", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbde419b38ab988a01833c443905ef65f3055791/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbde419b38ab988a01833c443905ef65f3055791/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=fbde419b38ab988a01833c443905ef65f3055791", "patch": "@@ -67,6 +67,7 @@ pub mod sort;\n \n pub mod dlist;\n pub mod treemap;\n+pub mod btree;\n \n // And ... other stuff\n "}]}