{"sha": "459eaa6baea4127b37769d0b7944fa00c175e770", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OWVhYTZiYWVhNDEyN2IzNzc2OWQwYjc5NDRmYTAwYzE3NWU3NzA=", "commit": {"author": {"name": "ivmarkov", "email": "ivan.markov@gmail.com", "date": "2021-07-29T17:18:22Z"}, "committer": {"name": "ivmarkov", "email": "imarkov@vmware.com", "date": "2021-08-10T09:09:00Z"}, "message": "STD support for the ESP-IDF framework", "tree": {"sha": "100c65b39f217096a01f3c0f256a672bfeaacd42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/100c65b39f217096a01f3c0f256a672bfeaacd42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/459eaa6baea4127b37769d0b7944fa00c175e770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/459eaa6baea4127b37769d0b7944fa00c175e770", "html_url": "https://github.com/rust-lang/rust/commit/459eaa6baea4127b37769d0b7944fa00c175e770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/459eaa6baea4127b37769d0b7944fa00c175e770/comments", "author": {"login": "ivmarkov", "id": 2607589, "node_id": "MDQ6VXNlcjI2MDc1ODk=", "avatar_url": "https://avatars.githubusercontent.com/u/2607589?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivmarkov", "html_url": "https://github.com/ivmarkov", "followers_url": "https://api.github.com/users/ivmarkov/followers", "following_url": "https://api.github.com/users/ivmarkov/following{/other_user}", "gists_url": "https://api.github.com/users/ivmarkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivmarkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivmarkov/subscriptions", "organizations_url": "https://api.github.com/users/ivmarkov/orgs", "repos_url": "https://api.github.com/users/ivmarkov/repos", "events_url": "https://api.github.com/users/ivmarkov/events{/privacy}", "received_events_url": "https://api.github.com/users/ivmarkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae90dcf0207c57c3034f00b07048d63f8b2363c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae90dcf0207c57c3034f00b07048d63f8b2363c8", "html_url": "https://github.com/rust-lang/rust/commit/ae90dcf0207c57c3034f00b07048d63f8b2363c8"}], "stats": {"total": 628, "additions": 581, "deletions": 47}, "files": [{"sha": "42368bf2ca887d1cbc664212345385d316122ab1", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -1880,9 +1880,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"a7f823d141fe0a24df1e23b4af4e3c7ba9e5966ec514ea068c93024aa7deb765\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "218fa0344b6a7bb7e4fb40aa59e4cf7b79791798", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -903,6 +903,7 @@ supported_targets! {\n \n     (\"riscv32i-unknown-none-elf\", riscv32i_unknown_none_elf),\n     (\"riscv32imc-unknown-none-elf\", riscv32imc_unknown_none_elf),\n+    (\"riscv32imc-esp-espidf\", riscv32imc_esp_espidf),\n     (\"riscv32imac-unknown-none-elf\", riscv32imac_unknown_none_elf),\n     (\"riscv32gc-unknown-linux-gnu\", riscv32gc_unknown_linux_gnu),\n     (\"riscv32gc-unknown-linux-musl\", riscv32gc_unknown_linux_musl),"}, {"sha": "fb084afe960de8d478130f801a6dfea4e50049de", "filename": "compiler/rustc_target/src/spec/riscv32imc_esp_espidf.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -0,0 +1,37 @@\n+use crate::spec::{LinkerFlavor, PanicStrategy, RelocModel};\n+use crate::spec::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-m:e-p:32:32-i64:64-n32-S128\".to_string(),\n+        llvm_target: \"riscv32\".to_string(),\n+        pointer_width: 32,\n+        arch: \"riscv32\".to_string(),\n+\n+        options: TargetOptions {\n+            families: vec![\"unix\".to_string()],\n+            os: \"espidf\".to_string(),\n+            env: \"newlib\".to_string(),\n+            vendor: \"espressif\".to_string(),\n+            linker_flavor: LinkerFlavor::Gcc,\n+            linker: Some(\"riscv32-esp-elf-gcc\".to_string()),\n+            cpu: \"generic-rv32\".to_string(),\n+\n+            // While the RiscV32IMC architecture does not natively support atomics, ESP-IDF does support\n+            // the __atomic* and __sync* GCC builtins, so setting `max_atomic_width` to `Some(32)`\n+            // and `atomic_cas` to `true` will cause the compiler to emit libcalls to these builtins.\n+            //\n+            // Support for atomics is necessary for the Rust STD library, which is supported by the ESP-IDF framework.\n+            max_atomic_width: Some(32),\n+            atomic_cas: true,\n+\n+            features: \"+m,+c\".to_string(),\n+            executables: true,\n+            panic_strategy: PanicStrategy::Abort,\n+            relocation_model: RelocModel::Static,\n+            emit_debug_gdb_scripts: false,\n+            eh_frame_header: false,\n+            ..Default::default()\n+        },\n+    }\n+}"}, {"sha": "ac7d8c18e3e029282473c1f695ea1ef1d993eb2c", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -45,7 +45,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         all(target_family = \"windows\", target_env = \"gnu\"),\n         target_os = \"psp\",\n-        target_family = \"unix\",\n+        all(target_family = \"unix\", not(target_os = \"espidf\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n@@ -58,6 +58,7 @@ cfg_if::cfg_if! {\n         // - arch=wasm32\n         // - os=none (\"bare metal\" targets)\n         // - os=uefi\n+        // - os=espidf\n         // - nvptx64-nvidia-cuda\n         // - arch=avr\n         #[path = \"dummy.rs\"]"}, {"sha": "64f413acd9709383b9850eedc7cea835272502d0", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.98\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.99\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.44\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "726157c1f1a41a9e1dd301264f825dfaeadba2c4", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -26,6 +26,7 @@ fn main() {\n         || target.contains(\"vxworks\")\n         || target.contains(\"wasm32\")\n         || target.contains(\"asmjs\")\n+        || target.contains(\"espidf\")\n     {\n         // These platforms don't have any special requirements.\n     } else {"}, {"sha": "93dc2c0cab7eee510e3f821eb0b27dd08923e484", "filename": "library/std/src/os/espidf/fs.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -0,0 +1,117 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use crate::os::espidf::raw;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: crate::fs::Metadata\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_spare4(&self) -> [u32; 2];\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+    fn st_spare4(&self) -> [u32; 2] {\n+        let spare4 = self.as_inner().as_inner().st_spare4;\n+        [spare4[0] as u32, spare4[1] as u32]\n+    }\n+}"}, {"sha": "a9cef970930823f4a588820d352a3962495961be", "filename": "library/std/src/os/espidf/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -0,0 +1,6 @@\n+//! Definitions for the ESP-IDF framework.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod fs;\n+pub mod raw;"}, {"sha": "fb18ec6f6f82abf2bdb72c4391a9c40a6b809140", "filename": "library/std/src/os/espidf/raw.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -0,0 +1,69 @@\n+//! Raw type definitions for the ESP-IDF framework.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n+\n+use crate::os::raw::c_long;\n+use crate::os::unix::raw::{gid_t, uid_t};\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = libc::pthread_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = libc::blkcnt_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = libc::blksize_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = libc::dev_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = libc::ino_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = libc::mode_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = libc::nlink_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = libc::off_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = libc::time_t;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub struct stat {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_dev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ino: ino_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mode: mode_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_nlink: nlink_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_uid: uid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_gid: gid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_rdev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_size: off_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blksize: blksize_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blocks: blkcnt_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_spare4: [c_long; 2usize],\n+}"}, {"sha": "4c9814919cdfa5e2aee68672909ff60b4c054c22", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -80,6 +80,8 @@ mod imp {\n     pub mod dragonfly;\n     #[cfg(target_os = \"emscripten\")]\n     pub mod emscripten;\n+    #[cfg(target_os = \"espidf\")]\n+    pub mod espidf;\n     #[cfg(target_os = \"freebsd\")]\n     pub mod freebsd;\n     #[cfg(target_os = \"fuchsia\")]"}, {"sha": "6c73d4b21dd3dbc71f51e289316825df9409031c", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -40,6 +40,8 @@ mod platform {\n     pub use crate::os::dragonfly::*;\n     #[cfg(target_os = \"emscripten\")]\n     pub use crate::os::emscripten::*;\n+    #[cfg(target_os = \"espidf\")]\n+    pub use crate::os::espidf::*;\n     #[cfg(target_os = \"freebsd\")]\n     pub use crate::os::freebsd::*;\n     #[cfg(target_os = \"fuchsia\")]"}, {"sha": "576667c017392054ff825cfdde82b1dc7be202ba", "filename": "library/std/src/sys/common/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -14,7 +14,8 @@ use crate::ptr;\n     target_arch = \"asmjs\",\n     target_arch = \"wasm32\",\n     target_arch = \"hexagon\",\n-    target_arch = \"riscv32\"\n+    target_arch = \"riscv32\",\n+    target_arch = \"xtensa\"\n )))]\n pub const MIN_ALIGN: usize = 8;\n #[cfg(all(any("}, {"sha": "7c3d9573940ae500d53b3638ffc0fe9257689221", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -57,7 +57,8 @@ cfg_if::cfg_if! {\n         target_os = \"android\",\n         target_os = \"illumos\",\n         target_os = \"redox\",\n-        target_os = \"solaris\"\n+        target_os = \"solaris\",\n+        target_os = \"espidf\"\n     ))] {\n         #[inline]\n         unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {"}, {"sha": "ee5e3983ac26ae4bc53377aa071cbc9cd70d30de", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -246,3 +246,15 @@ mod imp {\n         Args { iter: res.into_iter() }\n     }\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+mod imp {\n+    use super::Args;\n+\n+    #[inline(always)]\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n+\n+    pub fn args() -> Args {\n+        Args { iter: Vec::new().into_iter() }\n+    }\n+}"}, {"sha": "61261c0aa84e3e084aca6bc5a7f46698b8f91b3e", "filename": "library/std/src/sys/unix/condvar.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -34,12 +34,23 @@ impl Condvar {\n     ))]\n     pub unsafe fn init(&mut self) {}\n \n+    // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n+    // So on that platform, init() should always be called\n+    // Moreover, that platform does not have pthread_condattr_setclock support,\n+    // hence that initialization should be skipped as well\n+    #[cfg(target_os = \"espidf\")]\n+    pub unsafe fn init(&mut self) {\n+        let r = libc::pthread_cond_init(self.inner.get(), crate::ptr::null());\n+        assert_eq!(r, 0);\n+    }\n+\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n         target_os = \"l4re\",\n         target_os = \"android\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"espidf\"\n     )))]\n     pub unsafe fn init(&mut self) {\n         use crate::mem::MaybeUninit;\n@@ -76,7 +87,12 @@ impl Condvar {\n     // where we configure condition variable to use monotonic clock (instead of\n     // default system clock). This approach avoids all problems that result\n     // from changes made to the system time.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n+    #[cfg(not(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"android\",\n+        target_os = \"espidf\"\n+    )))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -103,7 +119,12 @@ impl Condvar {\n     // This implementation is modeled after libcxx's condition_variable\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n+    #[cfg(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"android\",\n+        target_os = \"espidf\"\n+    ))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use crate::ptr;\n         use crate::time::Instant;"}, {"sha": "60551aeb3e73e5f1c0ee92452c48cd146908dbef", "filename": "library/std/src/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -184,3 +184,14 @@ pub mod os {\n     pub const EXE_SUFFIX: &str = \"\";\n     pub const EXE_EXTENSION: &str = \"\";\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"espidf\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "28e32681e15b3d3624d1ba3c7ab935600e7ccad0", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -91,6 +91,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::readv(\n@@ -102,9 +103,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        return crate::io::default_read_vectored(|b| self.read(b), bufs);\n+    }\n+\n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        true\n+        cfg!(not(target_os = \"espidf\"))\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -148,6 +154,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::writev(\n@@ -159,9 +166,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        return crate::io::default_write_vectored(|b| self.write(b), bufs);\n+    }\n+\n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        true\n+        cfg!(not(target_os = \"espidf\"))\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n@@ -217,7 +229,7 @@ impl FileDesc {\n         }\n     }\n     #[cfg(any(\n-        target_env = \"newlib\",\n+        all(target_env = \"newlib\", not(target_os = \"espidf\")),\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"emscripten\",\n@@ -238,6 +250,12 @@ impl FileDesc {\n             Ok(())\n         }\n     }\n+    #[cfg(target_os = \"espidf\")]\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        // FD_CLOEXEC is not supported in ESP-IDF but there's no need to,\n+        // because ESP-IDF does not support spawning processes either.\n+        Ok(())\n+    }\n \n     #[cfg(target_os = \"linux\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -268,7 +286,17 @@ impl FileDesc {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n         // is a POSIX flag that was added to Linux in 2.6.24.\n-        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n+        #[cfg(not(target_os = \"espidf\"))]\n+        let cmd = libc::F_DUPFD_CLOEXEC;\n+\n+        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n+        // will never be supported, as this is a bare metal framework with\n+        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // not supported yet, it might be (currently it returns ENOSYS).\n+        #[cfg(target_os = \"espidf\")]\n+        let cmd = libc::F_DUPFD;\n+\n+        let fd = cvt(unsafe { libc::fcntl(self.raw(), cmd, 0) })?;\n         Ok(FileDesc::new(fd))\n     }\n }"}, {"sha": "fd4defd72eb4736b5f6389265820a78e5848be89", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -312,31 +312,31 @@ impl FileAttr {\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n-    #[cfg(not(target_os = \"vxworks\"))]\n+    #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: self.stat.st_mtime_nsec as _,\n         }))\n     }\n \n-    #[cfg(target_os = \"vxworks\")]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: 0,\n         }))\n     }\n \n-    #[cfg(not(target_os = \"vxworks\"))]\n+    #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n             tv_nsec: self.stat.st_atime_nsec as _,\n         }))\n     }\n \n-    #[cfg(target_os = \"vxworks\")]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n@@ -609,7 +609,8 @@ impl DirEntry {\n         target_os = \"l4re\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -648,7 +649,8 @@ impl DirEntry {\n         target_os = \"emscripten\",\n         target_os = \"l4re\",\n         target_os = \"haiku\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n@@ -1106,8 +1108,8 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n     let original = cstr(original)?;\n     let link = cstr(link)?;\n     cfg_if::cfg_if! {\n-        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n-            // VxWorks and Redox lack `linkat`, so use `link` instead. POSIX leaves\n+        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\"))] {\n+            // VxWorks, Redox and ESP-IDF lack `linkat`, so use `link` instead. POSIX leaves\n             // it implementation-defined whether `link` follows symlinks, so rely on the\n             // `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.\n             // Android has `linkat` on newer versions, but we happen to know `link`\n@@ -1199,6 +1201,18 @@ fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)>\n     Ok((reader, metadata))\n }\n \n+#[cfg(target_os = \"espidf\")]\n+fn open_to_and_set_permissions(\n+    to: &Path,\n+    reader_metadata: crate::fs::Metadata,\n+) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n+    use crate::fs::OpenOptions;\n+    let writer = OpenOptions::new().open(to)?;\n+    let writer_metadata = writer.metadata()?;\n+    Ok((writer, writer_metadata))\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n fn open_to_and_set_permissions(\n     to: &Path,\n     reader_metadata: crate::fs::Metadata,"}, {"sha": "f5424e3d282140abebd04d371147d56e9f4a715f", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -5,6 +5,7 @@ use crate::io::ErrorKind;\n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;\n \n+#[cfg(not(target_os = \"espidf\"))]\n #[macro_use]\n pub mod weak;\n \n@@ -43,6 +44,10 @@ pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod time;\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn init(argc: isize, argv: *const *const u8) {}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n // SAFETY: must be called only once during runtime initialization.\n // NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n@@ -304,3 +309,19 @@ cfg_if::cfg_if! {\n         extern \"C\" {}\n     }\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+mod unsupported {\n+    use crate::io;\n+\n+    pub fn unsupported<T>() -> io::Result<T> {\n+        Err(unsupported_err())\n+    }\n+\n+    pub fn unsupported_err() -> io::Error {\n+        io::Error::new_const(\n+            io::ErrorKind::Unsupported,\n+            &\"operation not supported on this platform\",\n+        )\n+    }\n+}"}, {"sha": "3f614fde08aca6482e0b8b1988266083f575aeb9", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -9,7 +9,7 @@ use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n \n-use libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n+use libc::{c_int, c_void, size_t, sockaddr, socklen_t, MSG_PEEK};\n \n pub use crate::sys::{cvt, cvt_r};\n \n@@ -30,13 +30,19 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n-    if err == EAI_SYSTEM {\n+    #[cfg(not(target_os = \"espidf\"))]\n+    if err == libc::EAI_SYSTEM {\n         return Err(io::Error::last_os_error());\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     let detail = unsafe {\n         str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n+\n+    #[cfg(target_os = \"espidf\")]\n+    let detail = \"\";\n+\n     Err(io::Error::new(\n         io::ErrorKind::Uncategorized,\n         &format!(\"failed to lookup address information: {}\", detail)[..],"}, {"sha": "1d5ffb073211bcde9f40a679e2d296422bc45053", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -128,6 +128,12 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    Ok(PathBuf::from(\"/\"))\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n pub fn getcwd() -> io::Result<PathBuf> {\n     let mut buf = Vec::with_capacity(512);\n     loop {\n@@ -154,6 +160,12 @@ pub fn getcwd() -> io::Result<PathBuf> {\n     }\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    super::unsupported::unsupported()\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let p: &OsStr = p.as_ref();\n     let p = CString::new(p.as_bytes())?;\n@@ -432,6 +444,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     path.canonicalize()\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    super::unsupported::unsupported()\n+}\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n }\n@@ -541,6 +558,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     }\n }\n \n+#[cfg(not(target_os = \"espidf\"))]\n pub fn page_size() -> usize {\n     unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n }\n@@ -563,7 +581,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -573,7 +592,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "0165ece849ee5034aba41becf2552fe03b61c139", "filename": "library/std/src/sys/unix/process/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -13,6 +13,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"vxworks\")] {\n         #[path = \"process_vxworks.rs\"]\n         mod process_inner;\n+    } else if #[cfg(target_os = \"espidf\")] {\n+        #[path = \"process_unsupported.rs\"]\n+        mod process_inner;\n     } else {\n         #[path = \"process_unix.rs\"]\n         mod process_inner;"}, {"sha": "7d549d060fd88cfafbf877b4ad28394509c9deee", "filename": "library/std/src/sys/unix/process/process_unsupported.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -0,0 +1,122 @@\n+use crate::convert::{TryFrom, TryInto};\n+use crate::fmt;\n+use crate::io;\n+use crate::io::ErrorKind;\n+use crate::num::NonZeroI32;\n+use crate::os::raw::NonZero_c_int;\n+use crate::sys;\n+use crate::sys::cvt;\n+use crate::sys::pipe::AnonPipe;\n+use crate::sys::process::process_common::*;\n+use crate::sys::unix::unsupported::*;\n+\n+use libc::{c_int, pid_t};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(\n+        &mut self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        unsupported_err()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Process {\n+    handle: pid_t,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        0\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        unsupported()\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        unsupported()\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        unsupported()\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        Err(ExitStatusError(1.try_into().unwrap()))\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn core_dumped(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn stopped_signal(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn continued(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn into_raw(&self) -> c_int {\n+        0\n+    }\n+}\n+\n+/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a as i32)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"exit code: {}\", self.0)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZero_c_int);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}"}, {"sha": "7a3f6b0d95a09aace1cdba7529287315eeb6655a", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -44,12 +44,17 @@ mod imp {\n         unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n     }\n \n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    #[cfg(target_os = \"espidf\")]\n+    fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n+        unsafe { libc::getrandom(buf.as_mut_ptr().cast(), buf.len(), 0) }\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\", target_os = \"espidf\")))]\n     fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n         false\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"espidf\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n         use crate::sync::atomic::{AtomicBool, Ordering};\n         use crate::sys::os::errno;"}, {"sha": "133ad3ea420b83b6bceb81d63020619154eb42d5", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -9,12 +9,14 @@ use crate::time::Duration;\n \n #[cfg(any(target_os = \"linux\", target_os = \"solaris\", target_os = \"illumos\"))]\n use crate::sys::weak::weak;\n-#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\n+#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\", target_os = \"espidf\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n #[cfg(target_os = \"vxworks\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n+#[cfg(target_os = \"espidf\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 0; // 0 indicates that the stack size configured in the ESP-IDF menuconfig system should be used\n \n #[cfg(target_os = \"fuchsia\")]\n mod zircon {\n@@ -50,22 +52,35 @@ impl Thread {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n-        let stack_size = cmp::max(stack, min_stack_size(&attr));\n-\n-        match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n-            0 => {}\n-            n => {\n-                assert_eq!(n, libc::EINVAL);\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = os::page_size();\n-                let stack_size =\n-                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n-            }\n-        };\n+        #[cfg(target_os = \"espidf\")]\n+        if stack > 0 {\n+            // Only set the stack if a non-zero value is passed\n+            // 0 is used as an indication that the default stack size configured in the ESP-IDF menuconfig system should be used\n+            assert_eq!(\n+                libc::pthread_attr_setstacksize(&mut attr, cmp::max(stack, min_stack_size(&attr))),\n+                0\n+            );\n+        }\n+\n+        #[cfg(not(target_os = \"espidf\"))]\n+        {\n+            let stack_size = cmp::max(stack, min_stack_size(&attr));\n+\n+            match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n+                0 => {}\n+                n => {\n+                    assert_eq!(n, libc::EINVAL);\n+                    // EINVAL means |stack_size| is either too small or not a\n+                    // multiple of the system page size.  Because it's definitely\n+                    // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+                    // Round up to the nearest page and try again.\n+                    let page_size = os::page_size();\n+                    let stack_size =\n+                        (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                    assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+                }\n+            };\n+        }\n \n         let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n         // Note: if the thread creation fails and this assert fails, then p will\n@@ -183,6 +198,7 @@ impl Thread {\n         // Newlib, Emscripten, and VxWorks have no way to set a thread name.\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn sleep(dur: Duration) {\n         let mut secs = dur.as_secs();\n         let mut nsecs = dur.subsec_nanos() as _;\n@@ -208,6 +224,19 @@ impl Thread {\n         }\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn sleep(dur: Duration) {\n+        let mut micros = dur.as_micros();\n+        unsafe {\n+            while micros > 0 {\n+                let st = if micros > u32::MAX as u128 { u32::MAX } else { micros as u32 };\n+                libc::usleep(st);\n+\n+                micros -= st as u128;\n+            }\n+        }\n+    }\n+\n     pub fn join(self) {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());"}, {"sha": "7dc09add27fd717c7487bd2af781a4c9dc1f7131", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -361,9 +361,9 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"espidf\")))]\n     pub type clock_t = libc::c_int;\n-    #[cfg(target_os = \"dragonfly\")]\n+    #[cfg(any(target_os = \"dragonfly\", target_os = \"espidf\"))]\n     pub type clock_t = libc::c_ulong;\n \n     fn now(clock: clock_t) -> Timespec {"}, {"sha": "ea9108f17133af8491544944727c7fc2a4f46a72", "filename": "library/std/src/sys_common/io.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -1,4 +1,6 @@\n-pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+// Bare metal platforms usually have very small amounts of RAM\n+// (in the order of hundreds of KB)\n+pub const DEFAULT_BUF_SIZE: usize = if cfg!(target_os = \"espidf\") { 512 } else { 8 * 1024 };\n \n #[cfg(test)]\n #[allow(dead_code)] // not used on emscripten"}, {"sha": "53b13b9043b3a2e9fef7fe26e318e2f8a83303e4", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -13,6 +13,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"l4re\",\n         target_os = \"none\",\n+        target_os = \"espidf\",\n     ))] {\n         // These \"unix\" family members do not have unwinder.\n         // Note this also matches x86_64-unknown-none-linuxkernel."}, {"sha": "9397ae0559c3799cd247e0bd7fb0c3ddb98e1599", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/459eaa6baea4127b37769d0b7944fa00c175e770/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/459eaa6baea4127b37769d0b7944fa00c175e770/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=459eaa6baea4127b37769d0b7944fa00c175e770", "patch": "@@ -256,6 +256,7 @@ target | std | host | notes\n `powerpc64le-unknown-linux-musl` | ? |  |\n `riscv32gc-unknown-linux-gnu` |   |   | RISC-V Linux (kernel 5.4, glibc 2.33)\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n+`riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 2.6.32, MUSL)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux"}]}