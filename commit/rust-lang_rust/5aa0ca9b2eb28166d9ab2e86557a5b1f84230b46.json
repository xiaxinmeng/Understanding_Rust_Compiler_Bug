{"sha": "5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTBjYTliMmViMjgxNjZkOWFiMmU4NjU1N2E1YjFmODQyMzBiNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T17:22:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T17:22:37Z"}, "message": "auto merge of #7528 : indutny/rust/feature/memory-api, r=cmr\n\n@cmr this is still WIP and I haven't tested it on windows, but anyway.", "tree": {"sha": "f88c94ac5cc9fd7750813c589013829017ec72fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f88c94ac5cc9fd7750813c589013829017ec72fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "html_url": "https://github.com/rust-lang/rust/commit/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a1fc4561ca37163b6bb29aaa1715b2264df40b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fc4561ca37163b6bb29aaa1715b2264df40b7", "html_url": "https://github.com/rust-lang/rust/commit/0a1fc4561ca37163b6bb29aaa1715b2264df40b7"}, {"sha": "db24ee9db02acf0912a89626e09801665bbb365a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db24ee9db02acf0912a89626e09801665bbb365a", "html_url": "https://github.com/rust-lang/rust/commit/db24ee9db02acf0912a89626e09801665bbb365a"}], "stats": {"total": 838, "additions": 829, "deletions": 9}, "files": [{"sha": "2518ba1a73d9a7c35d0ce1ceb41f67928275f5dc", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 476, "deletions": 9, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "patch": "@@ -633,8 +633,9 @@ pub mod types {\n             pub mod bsd44 {\n             }\n             pub mod extra {\n+                use ptr;\n                 use libc::types::common::c95::c_void;\n-                use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n+                use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n                 use libc::types::os::arch::c95::{c_long, c_ulong};\n                 use libc::types::os::arch::c95::{wchar_t};\n                 use libc::types::os::arch::c99::{c_ulonglong};\n@@ -665,6 +666,7 @@ pub mod types {\n                 pub type LPSECURITY_ATTRIBUTES = LPVOID;\n \n                 pub type LPVOID = *mut c_void;\n+                pub type LPCVOID = *c_void;\n                 pub type LPBYTE = *mut BYTE;\n                 pub type LPWORD = *mut WORD;\n                 pub type LPDWORD = *mut DWORD;\n@@ -674,6 +676,7 @@ pub mod types {\n                 pub type PBOOL = *mut BOOL;\n                 pub type WCHAR = wchar_t;\n                 pub type WORD = u16;\n+                pub type SIZE_T = size_t;\n \n                 pub type time64_t = i64;\n                 pub type int64 = i64;\n@@ -707,6 +710,50 @@ pub mod types {\n                     dwThreadId: DWORD\n                 }\n                 pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n+\n+                pub struct SYSTEM_INFO {\n+                    wProcessorArchitecture: WORD,\n+                    wReserved: WORD,\n+                    dwPageSize: DWORD,\n+                    lpMinimumApplicationAddress: LPVOID,\n+                    lpMaximumApplicationAddress: LPVOID,\n+                    dwActiveProcessorMask: DWORD,\n+                    dwNumberOfProcessors: DWORD,\n+                    dwProcessorType: DWORD,\n+                    dwAllocationGranularity: DWORD,\n+                    wProcessorLevel: WORD,\n+                    wProcessorRevision: WORD\n+                }\n+                pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n+\n+                impl SYSTEM_INFO {\n+                    pub fn new() -> SYSTEM_INFO {\n+                        SYSTEM_INFO {\n+                            wProcessorArchitecture: 0,\n+                            wReserved: 0,\n+                            dwPageSize: 0,\n+                            lpMinimumApplicationAddress: ptr::mut_null(),\n+                            lpMaximumApplicationAddress: ptr::mut_null(),\n+                            dwActiveProcessorMask: 0,\n+                            dwNumberOfProcessors: 0,\n+                            dwProcessorType: 0,\n+                            dwAllocationGranularity: 0,\n+                            wProcessorLevel: 0,\n+                            wProcessorRevision: 0\n+                        }\n+                    }\n+                }\n+\n+                pub struct MEMORY_BASIC_INFORMATION {\n+                    BaseAddress: LPVOID,\n+                    AllocationBase: LPVOID,\n+                    AllocationProtect: DWORD,\n+                    RegionSize: SIZE_T,\n+                    State: DWORD,\n+                    Protect: DWORD,\n+                    Type: DWORD\n+                }\n+                pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n             }\n         }\n     }\n@@ -964,7 +1011,7 @@ pub mod consts {\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n-            use libc::types::os::arch::extra::{DWORD, BOOL};\n+            use libc::types::os::arch::extra::{WORD, DWORD, BOOL};\n \n             pub static TRUE : BOOL = 1;\n             pub static FALSE : BOOL = 0;\n@@ -974,7 +1021,12 @@ pub mod consts {\n             pub static O_NOINHERIT: c_int = 128;\n \n             pub static ERROR_SUCCESS : c_int = 0;\n+            pub static ERROR_INVALID_HANDLE : c_int = 6;\n+            pub static ERROR_DISK_FULL : c_int = 112;\n             pub static ERROR_INSUFFICIENT_BUFFER : c_int = 122;\n+            pub static ERROR_ALREADY_EXISTS : c_int = 183;\n+            pub static ERROR_INVALID_ADDRESS : c_int = 487;\n+            pub static ERROR_FILE_INVALID : c_int = 1006;\n             pub static INVALID_HANDLE_VALUE: c_int = -1;\n \n             pub static DELETE : DWORD = 0x00010000;\n@@ -1020,6 +1072,49 @@ pub mod consts {\n \n             pub static INFINITE : DWORD = -1;\n             pub static STILL_ACTIVE : DWORD = 259;\n+\n+            pub static MEM_COMMIT : DWORD = 0x00001000;\n+            pub static MEM_RESERVE : DWORD = 0x00002000;\n+            pub static MEM_DECOMMIT : DWORD = 0x00004000;\n+            pub static MEM_RELEASE : DWORD = 0x00008000;\n+            pub static MEM_RESET : DWORD = 0x00080000;\n+            pub static MEM_RESET_UNDO : DWORD = 0x1000000;\n+            pub static MEM_LARGE_PAGES : DWORD = 0x20000000;\n+            pub static MEM_PHYSICAL : DWORD = 0x00400000;\n+            pub static MEM_TOP_DOWN : DWORD = 0x00100000;\n+            pub static MEM_WRITE_WATCH : DWORD = 0x00200000;\n+\n+            pub static PAGE_EXECUTE : DWORD = 0x10;\n+            pub static PAGE_EXECUTE_READ : DWORD = 0x20;\n+            pub static PAGE_EXECUTE_READWRITE : DWORD = 0x40;\n+            pub static PAGE_EXECUTE_WRITECOPY : DWORD = 0x80;\n+            pub static PAGE_NOACCESS : DWORD = 0x01;\n+            pub static PAGE_READONLY : DWORD = 0x02;\n+            pub static PAGE_READWRITE : DWORD = 0x04;\n+            pub static PAGE_WRITECOPY : DWORD = 0x08;\n+            pub static PAGE_GUARD : DWORD = 0x100;\n+            pub static PAGE_NOCACHE : DWORD = 0x200;\n+            pub static PAGE_WRITECOMBINE : DWORD = 0x400;\n+\n+            pub static SEC_COMMIT : DWORD = 0x8000000;\n+            pub static SEC_IMAGE : DWORD = 0x1000000;\n+            pub static SEC_IMAGE_NO_EXECUTE : DWORD = 0x11000000;\n+            pub static SEC_LARGE_PAGES : DWORD = 0x80000000;\n+            pub static SEC_NOCACHE : DWORD = 0x10000000;\n+            pub static SEC_RESERVE : DWORD = 0x4000000;\n+            pub static SEC_WRITECOMBINE : DWORD = 0x40000000;\n+\n+            pub static FILE_MAP_ALL_ACCESS : DWORD = 0xf001f;\n+            pub static FILE_MAP_READ : DWORD = 0x4;\n+            pub static FILE_MAP_WRITE : DWORD = 0x2;\n+            pub static FILE_MAP_COPY : DWORD = 0x1;\n+            pub static FILE_MAP_EXECUTE : DWORD = 0x20;\n+\n+            pub static PROCESSOR_ARCHITECTURE_INTEL : WORD = 0;\n+            pub static PROCESSOR_ARCHITECTURE_ARM : WORD = 5;\n+            pub static PROCESSOR_ARCHITECTURE_IA64 : WORD = 6;\n+            pub static PROCESSOR_ARCHITECTURE_AMD64 : WORD = 9;\n+            pub static PROCESSOR_ARCHITECTURE_UNKNOWN : WORD = 0xffff;\n         }\n     }\n \n@@ -1107,7 +1202,7 @@ pub mod consts {\n             pub static MAP_SHARED : c_int = 0x0001;\n             pub static MAP_PRIVATE : c_int = 0x0002;\n             pub static MAP_FIXED : c_int = 0x0010;\n-            pub static MAP_ANON : c_int = 0x1000;\n+            pub static MAP_ANON : c_int = 0x0020;\n \n             pub static MAP_FAILED : *c_void = -1 as *c_void;\n \n@@ -1117,6 +1212,98 @@ pub mod consts {\n             pub static MS_ASYNC : c_int = 0x0001;\n             pub static MS_INVALIDATE : c_int = 0x0002;\n             pub static MS_SYNC : c_int = 0x0004;\n+\n+            pub static _SC_ARG_MAX : c_int = 0;\n+            pub static _SC_CHILD_MAX : c_int = 1;\n+            pub static _SC_CLK_TCK : c_int = 2;\n+            pub static _SC_NGROUPS_MAX : c_int = 3;\n+            pub static _SC_OPEN_MAX : c_int = 4;\n+            pub static _SC_STREAM_MAX : c_int = 5;\n+            pub static _SC_TZNAME_MAX : c_int = 6;\n+            pub static _SC_JOB_CONTROL : c_int = 7;\n+            pub static _SC_SAVED_IDS : c_int = 8;\n+            pub static _SC_REALTIME_SIGNALS : c_int = 9;\n+            pub static _SC_PRIORITY_SCHEDULING : c_int = 10;\n+            pub static _SC_TIMERS : c_int = 11;\n+            pub static _SC_ASYNCHRONOUS_IO : c_int = 12;\n+            pub static _SC_PRIORITIZED_IO : c_int = 13;\n+            pub static _SC_SYNCHRONIZED_IO : c_int = 14;\n+            pub static _SC_FSYNC : c_int = 15;\n+            pub static _SC_MAPPED_FILES : c_int = 16;\n+            pub static _SC_MEMLOCK : c_int = 17;\n+            pub static _SC_MEMLOCK_RANGE : c_int = 18;\n+            pub static _SC_MEMORY_PROTECTION : c_int = 19;\n+            pub static _SC_MESSAGE_PASSING : c_int = 20;\n+            pub static _SC_SEMAPHORES : c_int = 21;\n+            pub static _SC_SHARED_MEMORY_OBJECTS : c_int = 22;\n+            pub static _SC_AIO_LISTIO_MAX : c_int = 23;\n+            pub static _SC_AIO_MAX : c_int = 24;\n+            pub static _SC_AIO_PRIO_DELTA_MAX : c_int = 25;\n+            pub static _SC_DELAYTIMER_MAX : c_int = 26;\n+            pub static _SC_MQ_OPEN_MAX : c_int = 27;\n+            pub static _SC_VERSION : c_int = 29;\n+            pub static _SC_PAGESIZE : c_int = 30;\n+            pub static _SC_RTSIG_MAX : c_int = 31;\n+            pub static _SC_SEM_NSEMS_MAX : c_int = 32;\n+            pub static _SC_SEM_VALUE_MAX : c_int = 33;\n+            pub static _SC_SIGQUEUE_MAX : c_int = 34;\n+            pub static _SC_TIMER_MAX : c_int = 35;\n+            pub static _SC_BC_BASE_MAX : c_int = 36;\n+            pub static _SC_BC_DIM_MAX : c_int = 37;\n+            pub static _SC_BC_SCALE_MAX : c_int = 38;\n+            pub static _SC_BC_STRING_MAX : c_int = 39;\n+            pub static _SC_COLL_WEIGHTS_MAX : c_int = 40;\n+            pub static _SC_EXPR_NEST_MAX : c_int = 42;\n+            pub static _SC_LINE_MAX : c_int = 43;\n+            pub static _SC_RE_DUP_MAX : c_int = 44;\n+            pub static _SC_2_VERSION : c_int = 46;\n+            pub static _SC_2_C_BIND : c_int = 47;\n+            pub static _SC_2_C_DEV : c_int = 48;\n+            pub static _SC_2_FORT_DEV : c_int = 49;\n+            pub static _SC_2_FORT_RUN : c_int = 50;\n+            pub static _SC_2_SW_DEV : c_int = 51;\n+            pub static _SC_2_LOCALEDEF : c_int = 52;\n+            pub static _SC_2_CHAR_TERM : c_int = 95;\n+            pub static _SC_2_C_VERSION : c_int = 96;\n+            pub static _SC_2_UPE : c_int = 97;\n+            pub static _SC_XBS5_ILP32_OFF32 : c_int = 125;\n+            pub static _SC_XBS5_ILP32_OFFBIG : c_int = 126;\n+            pub static _SC_XBS5_LPBIG_OFFBIG : c_int = 128;\n+\n+            pub static EPERM : c_int = 1;\n+            pub static ENOENT : c_int = 2;\n+            pub static ESRCH : c_int = 3;\n+            pub static EINTR : c_int = 4;\n+            pub static EIO : c_int = 5;\n+            pub static ENXIO : c_int = 6;\n+            pub static E2BIG : c_int = 7;\n+            pub static ENOEXEC : c_int = 8;\n+            pub static EBADF : c_int = 9;\n+            pub static ECHILD : c_int = 10;\n+            pub static EAGAIN : c_int = 11;\n+            pub static ENOMEM : c_int = 12;\n+            pub static EACCES : c_int = 13;\n+            pub static EFAULT : c_int = 14;\n+            pub static ENOTBLK : c_int = 15;\n+            pub static EBUSY : c_int = 16;\n+            pub static EEXIST : c_int = 17;\n+            pub static EXDEV : c_int = 18;\n+            pub static ENODEV : c_int = 19;\n+            pub static ENOTDIR : c_int = 20;\n+            pub static EISDIR : c_int = 21;\n+            pub static EINVAL : c_int = 22;\n+            pub static ENFILE : c_int = 23;\n+            pub static EMFILE : c_int = 24;\n+            pub static ENOTTY : c_int = 25;\n+            pub static ETXTBSY : c_int = 26;\n+            pub static EFBIG : c_int = 27;\n+            pub static ENOSPC : c_int = 28;\n+            pub static ESPIPE : c_int = 29;\n+            pub static EROFS : c_int = 30;\n+            pub static EMLINK : c_int = 31;\n+            pub static EPIPE : c_int = 32;\n+            pub static EDOM : c_int = 33;\n+            pub static ERANGE : c_int = 34;\n         }\n         #[cfg(target_arch = \"mips\")]\n         pub mod posix88 {\n@@ -1175,7 +1362,7 @@ pub mod consts {\n             pub static MAP_SHARED : c_int = 0x0001;\n             pub static MAP_PRIVATE : c_int = 0x0002;\n             pub static MAP_FIXED : c_int = 0x0010;\n-            pub static MAP_ANON : c_int = 0x1000;\n+            pub static MAP_ANON : c_int = 0x0020;\n \n             pub static MAP_FAILED : *c_void = -1 as *c_void;\n \n@@ -1242,6 +1429,41 @@ pub mod consts {\n             pub static _SC_XBS5_ILP32_OFF32 : c_int = 125;\n             pub static _SC_XBS5_ILP32_OFFBIG : c_int = 126;\n             pub static _SC_XBS5_LPBIG_OFFBIG : c_int = 128;\n+\n+            pub static EPERM : c_int = 1;\n+            pub static ENOENT : c_int = 2;\n+            pub static ESRCH : c_int = 3;\n+            pub static EINTR : c_int = 4;\n+            pub static EIO : c_int = 5;\n+            pub static ENXIO : c_int = 6;\n+            pub static E2BIG : c_int = 7;\n+            pub static ENOEXEC : c_int = 8;\n+            pub static EBADF : c_int = 9;\n+            pub static ECHILD : c_int = 10;\n+            pub static EAGAIN : c_int = 11;\n+            pub static ENOMEM : c_int = 12;\n+            pub static EACCES : c_int = 13;\n+            pub static EFAULT : c_int = 14;\n+            pub static ENOTBLK : c_int = 15;\n+            pub static EBUSY : c_int = 16;\n+            pub static EEXIST : c_int = 17;\n+            pub static EXDEV : c_int = 18;\n+            pub static ENODEV : c_int = 19;\n+            pub static ENOTDIR : c_int = 20;\n+            pub static EISDIR : c_int = 21;\n+            pub static EINVAL : c_int = 22;\n+            pub static ENFILE : c_int = 23;\n+            pub static EMFILE : c_int = 24;\n+            pub static ENOTTY : c_int = 25;\n+            pub static ETXTBSY : c_int = 26;\n+            pub static EFBIG : c_int = 27;\n+            pub static ENOSPC : c_int = 28;\n+            pub static ESPIPE : c_int = 29;\n+            pub static EROFS : c_int = 30;\n+            pub static EMLINK : c_int = 31;\n+            pub static EPIPE : c_int = 32;\n+            pub static EDOM : c_int = 33;\n+            pub static ERANGE : c_int = 34;\n         }\n         pub mod posix01 {\n             use libc::types::os::arch::c95::c_int;\n@@ -1326,7 +1548,7 @@ pub mod consts {\n             pub static PROT_GROWSUP : c_int = 0x020000000;\n \n             pub static MAP_TYPE : c_int = 0x000f;\n-            pub static MAP_ANONONYMOUS : c_int = 0x1000;\n+            pub static MAP_ANONONYMOUS : c_int = 0x0020;\n             pub static MAP_32BIT : c_int = 0x0040;\n             pub static MAP_GROWSDOWN : c_int = 0x0100;\n             pub static MAP_DENYWRITE : c_int = 0x0800;\n@@ -1349,7 +1571,7 @@ pub mod consts {\n             pub static PROT_GROWSUP : c_int = 0x020000000;\n \n             pub static MAP_TYPE : c_int = 0x000f;\n-            pub static MAP_ANONONYMOUS : c_int = 0x1000;\n+            pub static MAP_ANONONYMOUS : c_int = 0x0020;\n             pub static MAP_32BIT : c_int = 0x0040;\n             pub static MAP_GROWSDOWN : c_int = 0x0100;\n             pub static MAP_DENYWRITE : c_int = 0x0800;\n@@ -1504,6 +1726,108 @@ pub mod consts {\n             pub static _SC_SEM_VALUE_MAX : c_int = 50;\n             pub static _SC_SIGQUEUE_MAX : c_int = 51;\n             pub static _SC_TIMER_MAX : c_int = 52;\n+\n+            pub static EPERM : c_int = 1;\n+            pub static ENOENT : c_int = 2;\n+            pub static ESRCH : c_int = 3;\n+            pub static EINTR : c_int = 4;\n+            pub static EIO : c_int = 5;\n+            pub static ENXIO : c_int = 6;\n+            pub static E2BIG : c_int = 7;\n+            pub static ENOEXEC : c_int = 8;\n+            pub static EBADF : c_int = 9;\n+            pub static ECHILD : c_int = 10;\n+            pub static EDEADLK : c_int = 11;\n+            pub static ENOMEM : c_int = 12;\n+            pub static EACCES : c_int = 13;\n+            pub static EFAULT : c_int = 14;\n+            pub static ENOTBLK : c_int = 15;\n+            pub static EBUSY : c_int = 16;\n+            pub static EEXIST : c_int = 17;\n+            pub static EXDEV : c_int = 18;\n+            pub static ENODEV : c_int = 19;\n+            pub static ENOTDIR : c_int = 20;\n+            pub static EISDIR : c_int = 21;\n+            pub static EINVAL : c_int = 22;\n+            pub static ENFILE : c_int = 23;\n+            pub static EMFILE : c_int = 24;\n+            pub static ENOTTY : c_int = 25;\n+            pub static ETXTBSY : c_int = 26;\n+            pub static EFBIG : c_int = 27;\n+            pub static ENOSPC : c_int = 28;\n+            pub static ESPIPE : c_int = 29;\n+            pub static EROFS : c_int = 30;\n+            pub static EMLINK : c_int = 31;\n+            pub static EPIPE : c_int = 32;\n+            pub static EDOM : c_int = 33;\n+            pub static ERANGE : c_int = 34;\n+            pub static EAGAIN : c_int = 35;\n+            pub static EWOULDBLOCK : c_int = 35;\n+            pub static EINPROGRESS : c_int = 36;\n+            pub static EALREADY : c_int = 37;\n+            pub static ENOTSOCK : c_int = 38;\n+            pub static EDESTADDRREQ : c_int = 39;\n+            pub static EMSGSIZE : c_int = 40;\n+            pub static EPROTOTYPE : c_int = 41;\n+            pub static ENOPROTOOPT : c_int = 42;\n+            pub static EPROTONOSUPPORT : c_int = 43;\n+            pub static ESOCKTNOSUPPORT : c_int = 44;\n+            pub static EOPNOTSUPP : c_int = 45;\n+            pub static EPFNOSUPPORT : c_int = 46;\n+            pub static EAFNOSUPPORT : c_int = 47;\n+            pub static EADDRINUSE : c_int = 48;\n+            pub static EADDRNOTAVAIL : c_int = 49;\n+            pub static ENETDOWN : c_int = 50;\n+            pub static ENETUNREACH : c_int = 51;\n+            pub static ENETRESET : c_int = 52;\n+            pub static ECONNABORTED : c_int = 53;\n+            pub static ECONNRESET : c_int = 54;\n+            pub static ENOBUFS : c_int = 55;\n+            pub static EISCONN : c_int = 56;\n+            pub static ENOTCONN : c_int = 57;\n+            pub static ESHUTDOWN : c_int = 58;\n+            pub static ETOOMANYREFS : c_int = 59;\n+            pub static ETIMEDOUT : c_int = 60;\n+            pub static ECONNREFUSED : c_int = 61;\n+            pub static ELOOP : c_int = 62;\n+            pub static ENAMETOOLONG : c_int = 63;\n+            pub static EHOSTDOWN : c_int = 64;\n+            pub static EHOSTUNREACH : c_int = 65;\n+            pub static ENOTEMPTY : c_int = 66;\n+            pub static EPROCLIM : c_int = 67;\n+            pub static EUSERS : c_int = 68;\n+            pub static EDQUOT : c_int = 69;\n+            pub static ESTALE : c_int = 70;\n+            pub static EREMOTE : c_int = 71;\n+            pub static EBADRPC : c_int = 72;\n+            pub static ERPCMISMATCH : c_int = 73;\n+            pub static EPROGUNAVAIL : c_int = 74;\n+            pub static EPROGMISMATCH : c_int = 75;\n+            pub static EPROCUNAVAIL : c_int = 76;\n+            pub static ENOLCK : c_int = 77;\n+            pub static ENOSYS : c_int = 78;\n+            pub static EFTYPE : c_int = 79;\n+            pub static EAUTH : c_int = 80;\n+            pub static ENEEDAUTH : c_int = 81;\n+            pub static EIDRM : c_int = 82;\n+            pub static ENOMSG : c_int = 83;\n+            pub static EOVERFLOW : c_int = 84;\n+            pub static ECANCELED : c_int = 85;\n+            pub static EILSEQ : c_int = 86;\n+            pub static ENOATTR : c_int = 87;\n+            pub static EDOOFUS : c_int = 88;\n+            pub static EBADMSG : c_int = 89;\n+            pub static EMULTIHOP : c_int = 90;\n+            pub static ENOLINK : c_int = 91;\n+            pub static EPROTO : c_int = 92;\n+            pub static ENOMEDIUM : c_int = 93;\n+            pub static EUNUSED94 : c_int = 94;\n+            pub static EUNUSED95 : c_int = 95;\n+            pub static EUNUSED96 : c_int = 96;\n+            pub static EUNUSED97 : c_int = 97;\n+            pub static EUNUSED98 : c_int = 98;\n+            pub static EASYNC : c_int = 99;\n+            pub static ELAST : c_int = 99;\n         }\n         pub mod posix01 {\n             use libc::types::os::arch::c95::c_int;\n@@ -1748,6 +2072,115 @@ pub mod consts {\n             pub static _SC_XBS5_ILP32_OFFBIG : c_int = 123;\n             pub static _SC_XBS5_LP64_OFF64 : c_int = 124;\n             pub static _SC_XBS5_LPBIG_OFFBIG : c_int = 125;\n+\n+            pub static EPERM : c_int = 1;\n+            pub static ENOENT : c_int = 2;\n+            pub static ESRCH : c_int = 3;\n+            pub static EINTR : c_int = 4;\n+            pub static EIO : c_int = 5;\n+            pub static ENXIO : c_int = 6;\n+            pub static E2BIG : c_int = 7;\n+            pub static ENOEXEC : c_int = 8;\n+            pub static EBADF : c_int = 9;\n+            pub static ECHILD : c_int = 10;\n+            pub static EDEADLK : c_int = 11;\n+            pub static ENOMEM : c_int = 12;\n+            pub static EACCES : c_int = 13;\n+            pub static EFAULT : c_int = 14;\n+            pub static ENOTBLK : c_int = 15;\n+            pub static EBUSY : c_int = 16;\n+            pub static EEXIST : c_int = 17;\n+            pub static EXDEV : c_int = 18;\n+            pub static ENODEV : c_int = 19;\n+            pub static ENOTDIR : c_int = 20;\n+            pub static EISDIR : c_int = 21;\n+            pub static EINVAL : c_int = 22;\n+            pub static ENFILE : c_int = 23;\n+            pub static EMFILE : c_int = 24;\n+            pub static ENOTTY : c_int = 25;\n+            pub static ETXTBSY : c_int = 26;\n+            pub static EFBIG : c_int = 27;\n+            pub static ENOSPC : c_int = 28;\n+            pub static ESPIPE : c_int = 29;\n+            pub static EROFS : c_int = 30;\n+            pub static EMLINK : c_int = 31;\n+            pub static EPIPE : c_int = 32;\n+            pub static EDOM : c_int = 33;\n+            pub static ERANGE : c_int = 34;\n+            pub static EAGAIN : c_int = 35;\n+            pub static EWOULDBLOCK : c_int = EAGAIN;\n+            pub static EINPROGRESS : c_int = 36;\n+            pub static EALREADY : c_int = 37;\n+            pub static ENOTSOCK : c_int = 38;\n+            pub static EDESTADDRREQ : c_int = 39;\n+            pub static EMSGSIZE : c_int = 40;\n+            pub static EPROTOTYPE : c_int = 41;\n+            pub static ENOPROTOOPT : c_int = 42;\n+            pub static EPROTONOSUPPORT : c_int = 43;\n+            pub static ESOCKTNOSUPPORT : c_int = 44;\n+            pub static ENOTSUP : c_int = 45;\n+            pub static EPFNOSUPPORT : c_int = 46;\n+            pub static EAFNOSUPPORT : c_int = 47;\n+            pub static EADDRINUSE : c_int = 48;\n+            pub static EADDRNOTAVAIL : c_int = 49;\n+            pub static ENETDOWN : c_int = 50;\n+            pub static ENETUNREACH : c_int = 51;\n+            pub static ENETRESET : c_int = 52;\n+            pub static ECONNABORTED : c_int = 53;\n+            pub static ECONNRESET : c_int = 54;\n+            pub static ENOBUFS : c_int = 55;\n+            pub static EISCONN : c_int = 56;\n+            pub static ENOTCONN : c_int = 57;\n+            pub static ESHUTDOWN : c_int = 58;\n+            pub static ETOOMANYREFS : c_int = 59;\n+            pub static ETIMEDOUT : c_int = 60;\n+            pub static ECONNREFUSED : c_int = 61;\n+            pub static ELOOP : c_int = 62;\n+            pub static ENAMETOOLONG : c_int = 63;\n+            pub static EHOSTDOWN : c_int = 64;\n+            pub static EHOSTUNREACH : c_int = 65;\n+            pub static ENOTEMPTY : c_int = 66;\n+            pub static EPROCLIM : c_int = 67;\n+            pub static EUSERS : c_int = 68;\n+            pub static EDQUOT : c_int = 69;\n+            pub static ESTALE : c_int = 70;\n+            pub static EREMOTE : c_int = 71;\n+            pub static EBADRPC : c_int = 72;\n+            pub static ERPCMISMATCH : c_int = 73;\n+            pub static EPROGUNAVAIL : c_int = 74;\n+            pub static EPROGMISMATCH : c_int = 75;\n+            pub static EPROCUNAVAIL : c_int = 76;\n+            pub static ENOLCK : c_int = 77;\n+            pub static ENOSYS : c_int = 78;\n+            pub static EFTYPE : c_int = 79;\n+            pub static EAUTH : c_int = 80;\n+            pub static ENEEDAUTH : c_int = 81;\n+            pub static EPWROFF : c_int = 82;\n+            pub static EDEVERR : c_int = 83;\n+            pub static EOVERFLOW : c_int = 84;\n+            pub static EBADEXEC : c_int = 85;\n+            pub static EBADARCH : c_int = 86;\n+            pub static ESHLIBVERS : c_int = 87;\n+            pub static EBADMACHO : c_int = 88;\n+            pub static ECANCELED : c_int = 89;\n+            pub static EIDRM : c_int = 90;\n+            pub static ENOMSG : c_int = 91;\n+            pub static EILSEQ : c_int = 92;\n+            pub static ENOATTR : c_int = 93;\n+            pub static EBADMSG : c_int = 94;\n+            pub static EMULTIHOP : c_int = 95;\n+            pub static ENODATA : c_int = 96;\n+            pub static ENOLINK : c_int = 97;\n+            pub static ENOSR : c_int = 98;\n+            pub static ENOSTR : c_int = 99;\n+            pub static EPROTO : c_int = 100;\n+            pub static ETIME : c_int = 101;\n+            pub static EOPNOTSUPP : c_int = 102;\n+            pub static ENOPOLICY : c_int = 103;\n+            pub static ENOTRECOVERABLE : c_int = 104;\n+            pub static EOWNERDEAD : c_int = 105;\n+            pub static EQFULL : c_int = 106;\n+            pub static ELAST : c_int = 106;\n         }\n         pub mod posix01 {\n             use libc::types::os::arch::c95::c_int;\n@@ -2563,11 +2996,14 @@ pub mod funcs {\n \n         pub mod kernel32 {\n             use libc::types::os::arch::c95::{c_uint};\n-            use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n+            use libc::types::os::arch::extra::{BOOL, DWORD, SIZE_T, HMODULE};\n             use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPCTSTR,\n-                                               LPTSTR, LPTCH, LPDWORD, LPVOID};\n+                                               LPTSTR, LPTCH, LPDWORD, LPVOID,\n+                                               LPCVOID};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, LPSTARTUPINFO,\n-                                               LPPROCESS_INFORMATION};\n+                                               LPPROCESS_INFORMATION,\n+                                               LPMEMORY_BASIC_INFORMATION,\n+                                               LPSYSTEM_INFO};\n             use libc::types::os::arch::extra::{HANDLE, LPHANDLE};\n \n             #[abi = \"stdcall\"]\n@@ -2630,6 +3066,37 @@ pub mod funcs {\n                 unsafe fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n                 unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n                 unsafe fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n+\n+                unsafe fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);\n+                unsafe fn VirtualAlloc(lpAddress: LPVOID,\n+                                       dwSize: SIZE_T,\n+                                       flAllocationType: DWORD,\n+                                       flProtect: DWORD) -> LPVOID;\n+                unsafe fn VirtualFree(lpAddress: LPVOID,\n+                                      dwSize: SIZE_T,\n+                                      dwFreeType: DWORD) -> BOOL;\n+                unsafe fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;\n+                unsafe fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;\n+                unsafe fn VirtualProtect(lpAddress: LPVOID,\n+                                         dwSize: SIZE_T,\n+                                         flNewProtect: DWORD,\n+                                         lpflOldProtect: LPDWORD) -> BOOL;\n+                unsafe fn VirtualQuery(lpAddress: LPCVOID,\n+                                       lpBuffer: LPMEMORY_BASIC_INFORMATION,\n+                                       dwLength: SIZE_T) -> SIZE_T;\n+\n+                unsafe fn CreateFileMappingW(hFile: HANDLE,\n+                                             lpAttributes: LPSECURITY_ATTRIBUTES,\n+                                             flProtect: DWORD,\n+                                             dwMaximumSizeHigh: DWORD,\n+                                             dwMaximumSizeLow: DWORD,\n+                                             lpName: LPCTSTR) -> HANDLE;\n+                unsafe fn MapViewOfFile(hFileMappingObject: HANDLE,\n+                                        dwDesiredAccess: DWORD,\n+                                        dwFileOffsetHigh: DWORD,\n+                                        dwFileOffsetLow: DWORD,\n+                                        dwNumberOfBytesToMap: SIZE_T) -> LPVOID;\n+                unsafe fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;\n             }\n         }\n "}, {"sha": "50acbee697f2b5ccd3eacd9f508a84aef28a1196", "filename": "src/libstd/os.rs", "status": "modified", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5aa0ca9b2eb28166d9ab2e86557a5b1f84230b46", "patch": "@@ -41,6 +41,7 @@ use os;\n use prelude::*;\n use ptr;\n use str;\n+use to_str;\n use uint;\n use unstable::finally::Finally;\n use vec;\n@@ -1335,6 +1336,288 @@ extern {\n     pub fn _NSGetArgv() -> ***c_char;\n }\n \n+// Round up `from` to be divisible by `to`\n+fn round_up(from: uint, to: uint) -> uint {\n+    let r = if from % to == 0 {\n+        from\n+    } else {\n+        from + to - (from % to)\n+    };\n+    if r == 0 {\n+        to\n+    } else {\n+        r\n+    }\n+}\n+\n+#[cfg(unix)]\n+pub fn page_size() -> uint {\n+    unsafe {\n+        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub fn page_size() -> uint {\n+  unsafe {\n+    let mut info = libc::SYSTEM_INFO::new();\n+    libc::GetSystemInfo(&mut info);\n+\n+    return info.dwPageSize as uint;\n+  }\n+}\n+\n+pub struct MemoryMap {\n+    data: *mut u8,\n+    len: size_t,\n+    kind: MemoryMapKind\n+}\n+\n+pub enum MemoryMapKind {\n+    MapFile(*c_void),\n+    MapVirtual\n+}\n+\n+pub enum MapOption {\n+    MapReadable,\n+    MapWritable,\n+    MapExecutable,\n+    MapAddr(*c_void),\n+    MapFd(c_int),\n+    MapOffset(uint)\n+}\n+\n+pub enum MapError {\n+    // Linux-specific errors\n+    ErrFdNotAvail,\n+    ErrInvalidFd,\n+    ErrUnaligned,\n+    ErrNoMapSupport,\n+    ErrNoMem,\n+    ErrUnknown(libc::c_int),\n+\n+    // Windows-specific errors\n+    ErrUnsupProt,\n+    ErrUnsupOffset,\n+    ErrNeedRW,\n+    ErrAlreadyExists,\n+    ErrVirtualAlloc(uint),\n+    ErrCreateFileMappingW(uint),\n+    ErrMapViewOfFile(uint)\n+}\n+\n+impl to_str::ToStr for MapError {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ErrFdNotAvail => ~\"fd not available for reading or writing\",\n+            ErrInvalidFd => ~\"Invalid fd\",\n+            ErrUnaligned => ~\"Unaligned address, invalid flags, \\\n+                              negative length or unaligned offset\",\n+            ErrNoMapSupport=> ~\"File doesn't support mapping\",\n+            ErrNoMem => ~\"Invalid address, or not enough available memory\",\n+            ErrUnknown(code) => fmt!(\"Unknown error=%?\", code),\n+            ErrUnsupProt => ~\"Protection mode unsupported\",\n+            ErrUnsupOffset => ~\"Offset in virtual memory mode is unsupported\",\n+            ErrNeedRW => ~\"File mapping should be at least readable/writable\",\n+            ErrAlreadyExists => ~\"File mapping for specified file already exists\",\n+            ErrVirtualAlloc(code) => fmt!(\"VirtualAlloc failure=%?\", code),\n+            ErrCreateFileMappingW(code) => fmt!(\"CreateFileMappingW failure=%?\", code),\n+            ErrMapViewOfFile(code) => fmt!(\"MapViewOfFile failure=%?\", code)\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl MemoryMap {\n+    pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        use libc::off_t;\n+\n+        let mut addr: *c_void = ptr::null();\n+        let mut prot: c_int = 0;\n+        let mut flags: c_int = libc::MAP_PRIVATE;\n+        let mut fd: c_int = -1;\n+        let mut offset: off_t = 0;\n+        let len = round_up(min_len, page_size()) as size_t;\n+\n+        for options.iter().advance |&o| {\n+            match o {\n+                MapReadable => { prot |= libc::PROT_READ; },\n+                MapWritable => { prot |= libc::PROT_WRITE; },\n+                MapExecutable => { prot |= libc::PROT_EXEC; },\n+                MapAddr(addr_) => {\n+                    flags |= libc::MAP_FIXED;\n+                    addr = addr_;\n+                },\n+                MapFd(fd_) => {\n+                    flags |= libc::MAP_FILE;\n+                    fd = fd_;\n+                },\n+                MapOffset(offset_) => { offset = offset_ as off_t; }\n+            }\n+        }\n+        if fd == -1 { flags |= libc::MAP_ANON; }\n+\n+        let r = unsafe {\n+            libc::mmap(addr, len, prot, flags, fd, offset)\n+        };\n+        if r == libc::MAP_FAILED {\n+            Err(match errno() as c_int {\n+                libc::EACCES => ErrFdNotAvail,\n+                libc::EBADF => ErrInvalidFd,\n+                libc::EINVAL => ErrUnaligned,\n+                libc::ENODEV => ErrNoMapSupport,\n+                libc::ENOMEM => ErrNoMem,\n+                code => ErrUnknown(code)\n+            })\n+        } else {\n+            Ok(~MemoryMap {\n+               data: r as *mut u8,\n+               len: len,\n+               kind: if fd == -1 {\n+                   MapVirtual\n+               } else {\n+                   MapFile(ptr::null())\n+               }\n+            })\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl Drop for MemoryMap {\n+    fn drop(&self) {\n+        unsafe {\n+            match libc::munmap(self.data as *c_void, self.len) {\n+                0 => (),\n+                -1 => error!(match errno() as c_int {\n+                    libc::EINVAL => ~\"invalid addr or len\",\n+                    e => fmt!(\"unknown errno=%?\", e)\n+                }),\n+                r => error!(fmt!(\"Unexpected result %?\", r))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl MemoryMap {\n+    pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n+\n+        let mut lpAddress: LPVOID = ptr::mut_null();\n+        let mut readable = false;\n+        let mut writable = false;\n+        let mut executable = false;\n+        let mut fd: c_int = -1;\n+        let mut offset: uint = 0;\n+        let len = round_up(min_len, page_size()) as SIZE_T;\n+\n+        for options.iter().advance |&o| {\n+            match o {\n+                MapReadable => { readable = true; },\n+                MapWritable => { writable = true; },\n+                MapExecutable => { executable = true; }\n+                MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n+                MapFd(fd_) => { fd = fd_; },\n+                MapOffset(offset_) => { offset = offset_; }\n+            }\n+        }\n+\n+        let flProtect = match (executable, readable, writable) {\n+            (false, false, false) if fd == -1 => libc::PAGE_NOACCESS,\n+            (false, true, false) => libc::PAGE_READONLY,\n+            (false, true, true) => libc::PAGE_READWRITE,\n+            (true, false, false) if fd == -1 => libc::PAGE_EXECUTE,\n+            (true, true, false) => libc::PAGE_EXECUTE_READ,\n+            (true, true, true) => libc::PAGE_EXECUTE_READWRITE,\n+            _ => return Err(ErrUnsupProt)\n+        };\n+\n+        if fd == -1 {\n+            if offset != 0 {\n+                return Err(ErrUnsupOffset);\n+            }\n+            let r = unsafe {\n+                libc::VirtualAlloc(lpAddress,\n+                                   len,\n+                                   libc::MEM_COMMIT | libc::MEM_RESERVE,\n+                                   flProtect)\n+            };\n+            match r as uint {\n+                0 => Err(ErrVirtualAlloc(errno())),\n+                _ => Ok(~MemoryMap {\n+                   data: r as *mut u8,\n+                   len: len,\n+                   kind: MapVirtual\n+                })\n+            }\n+        } else {\n+            let dwDesiredAccess = match (readable, writable) {\n+                (true, true) => libc::FILE_MAP_ALL_ACCESS,\n+                (true, false) => libc::FILE_MAP_READ,\n+                (false, true) => libc::FILE_MAP_WRITE,\n+                _ => {\n+                    return Err(ErrNeedRW);\n+                }\n+            };\n+            unsafe {\n+                let hFile = libc::get_osfhandle(fd) as HANDLE;\n+                let mapping = libc::CreateFileMappingW(hFile,\n+                                                       ptr::mut_null(),\n+                                                       flProtect,\n+                                                       (len >> 32) as DWORD,\n+                                                       (len & 0xffff_ffff) as DWORD,\n+                                                       ptr::null());\n+                if mapping == ptr::mut_null() {\n+                    return Err(ErrCreateFileMappingW(errno()));\n+                }\n+                if errno() as c_int == libc::ERROR_ALREADY_EXISTS {\n+                    return Err(ErrAlreadyExists);\n+                }\n+                let r = libc::MapViewOfFile(mapping,\n+                                            dwDesiredAccess,\n+                                            (offset >> 32) as DWORD,\n+                                            (offset & 0xffff_ffff) as DWORD,\n+                                            0);\n+                match r as uint {\n+                    0 => Err(ErrMapViewOfFile(errno())),\n+                    _ => Ok(~MemoryMap {\n+                       data: r as *mut u8,\n+                       len: len,\n+                       kind: MapFile(mapping as *c_void)\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl Drop for MemoryMap {\n+    fn drop(&self) {\n+        use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n+\n+        unsafe {\n+            match self.kind {\n+                MapVirtual => match libc::VirtualFree(self.data as *mut c_void,\n+                                                      self.len,\n+                                                      libc::MEM_RELEASE) {\n+                    0 => error!(fmt!(\"VirtualFree failed: %?\", errno())),\n+                    _ => ()\n+                },\n+                MapFile(mapping) => {\n+                    if libc::UnmapViewOfFile(self.data as LPCVOID) != 0 {\n+                        error!(fmt!(\"UnmapViewOfFile failed: %?\", errno()));\n+                    }\n+                    if libc::CloseHandle(mapping as HANDLE) != 0 {\n+                        error!(fmt!(\"CloseHandle failed: %?\", errno()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub mod consts {\n \n     #[cfg(unix)]\n@@ -1715,5 +1998,75 @@ mod tests {\n         assert!(!os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n \n+    #[test]\n+    fn memory_map_rw() {\n+        use result::{Ok, Err};\n+\n+        let chunk = match os::MemoryMap::new(16, ~[\n+            os::MapReadable,\n+            os::MapWritable\n+        ]) {\n+            Ok(chunk) => chunk,\n+            Err(msg) => fail!(msg.to_str())\n+        };\n+        assert!(chunk.len >= 16);\n+\n+        unsafe {\n+            *chunk.data = 0xBE;\n+            assert!(*chunk.data == 0xBE);\n+        }\n+    }\n+\n+    #[test]\n+    fn memory_map_file() {\n+        use result::{Ok, Err};\n+        use os::*;\n+        use libc::*;\n+\n+        #[cfg(unix)]\n+        fn lseek_(fd: c_int, size: uint) {\n+            unsafe {\n+                assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n+            }\n+        }\n+        #[cfg(windows)]\n+        fn lseek_(fd: c_int, size: uint) {\n+           unsafe {\n+               assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);\n+           }\n+        }\n+\n+        let p = tmpdir().push(\"mmap_file.tmp\");\n+        let size = page_size() * 2;\n+        remove_file(&p);\n+\n+        let fd = unsafe {\n+            let fd = do as_c_charp(p.to_str()) |path| {\n+                open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n+            };\n+            lseek_(fd, size);\n+            do as_c_charp(\"x\") |x| {\n+                assert!(write(fd, x as *c_void, 1) == 1);\n+            }\n+            fd\n+        };\n+        let chunk = match MemoryMap::new(size / 2, ~[\n+            MapReadable,\n+            MapWritable,\n+            MapFd(fd),\n+            MapOffset(size / 2)\n+        ]) {\n+            Ok(chunk) => chunk,\n+            Err(msg) => fail!(msg.to_str())\n+        };\n+        assert!(chunk.len > 0);\n+\n+        unsafe {\n+            *chunk.data = 0xbe;\n+            assert!(*chunk.data == 0xbe);\n+            close(fd);\n+        }\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}]}