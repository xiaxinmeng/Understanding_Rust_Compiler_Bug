{"sha": "c5d58de665819f7330b3d64bdd084d25a412830a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZDU4ZGU2NjU4MTlmNzMzMGIzZDY0YmRkMDg0ZDI1YTQxMjgzMGE=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-01-13T21:48:58Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-02-27T07:01:41Z"}, "message": "core: add inclusive ranges to core::ops\n\nSince it removes the old iter::{range_inclusive, RangeInclusive} which\nwere unstable and deprecated, this is a [breaking-change] on nightly.", "tree": {"sha": "7f2398ba1ced3c723e75f7b93f07b4c6724f150e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f2398ba1ced3c723e75f7b93f07b4c6724f150e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5d58de665819f7330b3d64bdd084d25a412830a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d58de665819f7330b3d64bdd084d25a412830a", "html_url": "https://github.com/rust-lang/rust/commit/c5d58de665819f7330b3d64bdd084d25a412830a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5d58de665819f7330b3d64bdd084d25a412830a/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1e191c0b959111aef19f3aa06b7f1743419470c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e191c0b959111aef19f3aa06b7f1743419470c", "html_url": "https://github.com/rust-lang/rust/commit/f1e191c0b959111aef19f3aa06b7f1743419470c"}], "stats": {"total": 258, "additions": 167, "deletions": 91}, "files": [{"sha": "1f5ef6be0bc44e7eedc33b7b2c9f10efbab28a96", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 96, "deletions": 89, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c5d58de665819f7330b3d64bdd084d25a412830a", "patch": "@@ -4375,95 +4375,6 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     }\n }\n \n-/// An iterator over the range [start, stop]\n-#[derive(Clone)]\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-pub struct RangeInclusive<A> {\n-    range: ops::Range<A>,\n-    done: bool,\n-}\n-\n-/// Returns an iterator over the range [start, stop].\n-#[inline]\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n-    where A: Step + One + Clone\n-{\n-    RangeInclusive {\n-        range: start..stop,\n-        done: false,\n-    }\n-}\n-\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-impl<A> Iterator for RangeInclusive<A> where\n-    A: PartialEq + Step + One + Clone,\n-    for<'a> &'a A: Add<&'a A, Output = A>\n-{\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        self.range.next().or_else(|| {\n-            if !self.done && self.range.start == self.range.end {\n-                self.done = true;\n-                Some(self.range.end.clone())\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lo, hi) = self.range.size_hint();\n-        if self.done {\n-            (lo, hi)\n-        } else {\n-            let lo = lo.saturating_add(1);\n-            let hi = hi.and_then(|x| x.checked_add(1));\n-            (lo, hi)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"range_inclusive\",\n-           reason = \"likely to be replaced by range notation and adapters\",\n-           issue = \"27777\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with ... syntax\")]\n-#[allow(deprecated)]\n-impl<A> DoubleEndedIterator for RangeInclusive<A> where\n-    A: PartialEq + Step + One + Clone,\n-    for<'a> &'a A: Add<&'a A, Output = A>,\n-    for<'a> &'a A: Sub<Output=A>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        if self.range.end > self.range.start {\n-            let result = self.range.end.clone();\n-            self.range.end = &self.range.end - &A::one();\n-            Some(result)\n-        } else if !self.done && self.range.start == self.range.end {\n-            self.done = true;\n-            Some(self.range.end.clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n@@ -4505,6 +4416,9 @@ macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl ExactSizeIterator for ops::Range<$t> { }\n+\n+        #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n     )*)\n }\n \n@@ -4568,6 +4482,99 @@ impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self, so borrows of self.start and self.end need to end early\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => (None, None), // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let one = A::one();\n+                if start <= end {\n+                    let mut n = &*start + &one;\n+                    mem::swap(&mut n, start);\n+\n+                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n+                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n+                    // (they are equal now, so it doesn't matter which)\n+                    // to pull out end, we need to swap something back in -- use the previously\n+                    // created A::one() as a dummy value\n+\n+                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    // ^ are we done yet?\n+                    Some(n)) // < the value to output\n+                } else {\n+                    (Some(mem::replace(start, one)), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if this is the last value\n+        if let Some(end) = finishing {\n+            *self = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start, end, &A::one()) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None => (0, None),\n+                }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // see Iterator::next for comments\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => return None,\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let one = A::one();\n+                let mut n = &*end - &one;\n+                mem::swap(&mut n, end);\n+\n+                (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                 n)\n+            }\n+        };\n+\n+        if let Some(start) = finishing {\n+            *self = Empty { at: start };\n+        }\n+\n+        Some(n)\n+    }\n+}\n+\n /// An iterator that repeats an element endlessly.\n ///\n /// This `struct` is created by the [`repeat()`] function. See its documentation for more."}, {"sha": "cf8f4279a1d010d52a1a49568bd0d6030b2631eb", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c5d58de665819f7330b3d64bdd084d25a412830a", "patch": "@@ -67,8 +67,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use marker::{Sized, Unsize};\n+use cmp::PartialOrd;\n use fmt;\n+use convert::From;\n+use marker::{Sized, Unsize};\n+use num::One;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -1530,6 +1533,73 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n+/// An inclusive range which is bounded at both ends.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub enum RangeInclusive<Idx> {\n+    /// Empty range (iteration has finished)\n+    Empty {\n+        /// The point at which iteration finished\n+        at: Idx\n+    },\n+    /// Non-empty range (iteration will yield value(s))\n+    NonEmpty {\n+        /// The lower bound of the range (inclusive).\n+        start: Idx,\n+        /// The upper bound of the range (inclusive).\n+        end: Idx,\n+    },\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use self::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { ref at } => write!(fmt, \"[empty range @ {:?}]\", at),\n+            NonEmpty { ref start, ref end } => write!(fmt, \"{:?}...{:?}\", start, end),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusive<Idx> {\n+    fn from(range: Range<Idx>) -> RangeInclusive<Idx> {\n+        use self::RangeInclusive::*;\n+\n+        if range.start < range.end {\n+            NonEmpty {\n+                start: range.start,\n+                end: range.end - Idx::one() // can't underflow because end > start >= MIN\n+            }\n+        } else {\n+            Empty {\n+                at: range.start\n+            }\n+        }\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeToInclusive<Idx> {\n+    /// The upper bound of the range (inclusive)\n+    #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"...{:?}\", self.end)\n+    }\n+}\n+\n+// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n+// because underflow would be possible with (..0).into()\n+\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations, like `*v`.\n ///"}, {"sha": "dd84cba370c281f2fcdb015a42f984c3aef7a5fc", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d58de665819f7330b3d64bdd084d25a412830a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c5d58de665819f7330b3d64bdd084d25a412830a", "patch": "@@ -247,7 +247,6 @@\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(range_inclusive)]\n #![feature(raw)]\n #![feature(repr_simd)]\n #![feature(reflect_marker)]"}]}