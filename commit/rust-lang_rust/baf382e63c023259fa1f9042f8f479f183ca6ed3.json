{"sha": "baf382e63c023259fa1f9042f8f479f183ca6ed3", "node_id": "C_kwDOAAsO6NoAKGJhZjM4MmU2M2MwMjMyNTlmYTFmOTA0MmY4ZjQ3OWYxODNjYTZlZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T09:48:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T09:48:18Z"}, "message": "Auto merge of #98396 - cjgillot:iwfchir, r=petrochenkov\n\nDo not access HIR to check impl wf.\n\nr? `@ghost`", "tree": {"sha": "a920eaac003cb1ccc5775ba5eabaaad0f890c993", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a920eaac003cb1ccc5775ba5eabaaad0f890c993"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baf382e63c023259fa1f9042f8f479f183ca6ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baf382e63c023259fa1f9042f8f479f183ca6ed3", "html_url": "https://github.com/rust-lang/rust/commit/baf382e63c023259fa1f9042f8f479f183ca6ed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baf382e63c023259fa1f9042f8f479f183ca6ed3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "html_url": "https://github.com/rust-lang/rust/commit/64eb9ab869bc3f9ef3645302fbf22e706eea16cf"}, {"sha": "8242aa839e741ac25825f89eff392cae1b2e8347", "url": "https://api.github.com/repos/rust-lang/rust/commits/8242aa839e741ac25825f89eff392cae1b2e8347", "html_url": "https://github.com/rust-lang/rust/commit/8242aa839e741ac25825f89eff392cae1b2e8347"}], "stats": {"total": 123, "additions": 49, "deletions": 74}, "files": [{"sha": "981c35e184bece0d744a4a8e979eaa0dd718d3bd", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -13,7 +13,6 @@ use min_specialization::check_min_specialization;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n@@ -59,13 +58,10 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n         if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-            let item = tcx.hir().item(id);\n-            if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-                enforce_impl_params_are_constrained(tcx, item.def_id, impl_.items);\n-                enforce_impl_items_are_distinct(tcx, impl_.items);\n-                if min_specialization {\n-                    check_min_specialization(tcx, item.def_id.to_def_id(), item.span);\n-                }\n+            enforce_impl_params_are_constrained(tcx, id.def_id);\n+            enforce_impl_items_are_distinct(tcx, id.def_id);\n+            if min_specialization {\n+                check_min_specialization(tcx, id.def_id);\n             }\n         }\n     }\n@@ -75,11 +71,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_impl_wf, ..*providers };\n }\n \n-fn enforce_impl_params_are_constrained(\n-    tcx: TyCtxt<'_>,\n-    impl_def_id: LocalDefId,\n-    impl_item_refs: &[hir::ImplItemRef],\n-) {\n+fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n     if impl_self_ty.references_error() {\n@@ -107,9 +99,9 @@ fn enforce_impl_params_are_constrained(\n     );\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n-    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs\n+    let lifetimes_in_associated_types: FxHashSet<_> = tcx\n+        .associated_item_def_ids(impl_def_id)\n         .iter()\n-        .map(|item_ref| item_ref.id.def_id)\n         .flat_map(|def_id| {\n             let item = tcx.associated_item(def_id);\n             match item.kind {\n@@ -209,33 +201,32 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef]) {\n+fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n-    for impl_item_ref in impl_item_refs {\n-        let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n+    for &impl_item_ref in tcx.associated_item_def_ids(impl_def_id) {\n+        let impl_item = tcx.associated_item(impl_item_ref);\n         let seen_items = match impl_item.kind {\n-            hir::ImplItemKind::TyAlias(_) => &mut seen_type_items,\n+            ty::AssocKind::Type => &mut seen_type_items,\n             _ => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.ident.normalize_to_macros_2_0()) {\n+        let span = tcx.def_span(impl_item_ref);\n+        let ident = impl_item.ident(tcx);\n+        match seen_items.entry(ident.normalize_to_macros_2_0()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(\n                     tcx.sess,\n-                    impl_item.span,\n+                    span,\n                     E0201,\n                     \"duplicate definitions with name `{}`:\",\n-                    impl_item.ident\n-                );\n-                err.span_label(\n-                    *entry.get(),\n-                    format!(\"previous definition of `{}` here\", impl_item.ident),\n+                    ident\n                 );\n-                err.span_label(impl_item.span, \"duplicate definition\");\n+                err.span_label(*entry.get(), format!(\"previous definition of `{}` here\", ident));\n+                err.span_label(span, \"duplicate definition\");\n                 err.emit();\n             }\n             Vacant(entry) => {\n-                entry.insert(impl_item.span);\n+                entry.insert(span);\n             }\n         }\n     }"}, {"sha": "f07396ce74ffb2aa3881be836d9b6615de337b0b", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -79,19 +79,19 @@ use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::{self, translate_substs, wf};\n \n-pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: DefId, span: Span) {\n+pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n         tcx.infer_ctxt().enter(|infcx| {\n-            check_always_applicable(&infcx, impl_def_id, node, span);\n+            check_always_applicable(&infcx, impl_def_id, node);\n         });\n     }\n }\n \n-fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: DefId) -> Option<Node> {\n+fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Option<Node> {\n     let trait_ref = tcx.impl_trait_ref(impl1_def_id)?;\n     let trait_def = tcx.trait_def(trait_ref.def_id);\n \n-    let impl2_node = trait_def.ancestors(tcx, impl1_def_id).ok()?.nth(1)?;\n+    let impl2_node = trait_def.ancestors(tcx, impl1_def_id.to_def_id()).ok()?.nth(1)?;\n \n     let always_applicable_trait =\n         matches!(trait_def.specialization_kind, TraitSpecializationKind::AlwaysApplicable);\n@@ -103,15 +103,8 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: DefId) -> Option<No\n }\n \n /// Check that `impl1` is a sound specialization\n-fn check_always_applicable(\n-    infcx: &InferCtxt<'_, '_>,\n-    impl1_def_id: DefId,\n-    impl2_node: Node,\n-    span: Span,\n-) {\n-    if let Some((impl1_substs, impl2_substs)) =\n-        get_impl_substs(infcx, impl1_def_id, impl2_node, span)\n-    {\n+fn check_always_applicable(infcx: &InferCtxt<'_, '_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n+    if let Some((impl1_substs, impl2_substs)) = get_impl_substs(infcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n         debug!(\n             \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n@@ -126,17 +119,10 @@ fn check_always_applicable(\n             unconstrained_parent_impl_substs(tcx, impl2_def_id, impl2_substs)\n         };\n \n+        let span = tcx.def_span(impl1_def_id);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n-\n-        check_predicates(\n-            infcx,\n-            impl1_def_id.expect_local(),\n-            impl1_substs,\n-            impl2_node,\n-            impl2_substs,\n-            span,\n-        );\n+        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n@@ -152,20 +138,21 @@ fn check_always_applicable(\n /// Would return `S1 = [C]` and `S2 = [Vec<C>, C]`.\n fn get_impl_substs<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    impl1_def_id: DefId,\n+    impl1_def_id: LocalDefId,\n     impl2_node: Node,\n-    span: Span,\n ) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(impl1_def_id);\n \n-    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n-    let impl2_substs = translate_substs(infcx, param_env, impl1_def_id, impl1_substs, impl2_node);\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id.to_def_id());\n+    let impl2_substs =\n+        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n \n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-    infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n+    infcx.resolve_regions_and_report_errors(impl1_def_id.to_def_id(), &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+        let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });\n         return None;\n     };"}, {"sha": "ad21b38d07eb98813ad0ded877fd1b1aaf48dbd1", "filename": "src/test/ui/associated-item/associated-item-duplicate-names-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-2.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -4,7 +4,7 @@ error[E0201]: duplicate definitions with name `bar`:\n LL |     const bar: bool = true;\n    |     ----------------------- previous definition of `bar` here\n LL |     fn bar() {}\n-   |     ^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^ duplicate definition\n \n error: aborting due to previous error\n "}, {"sha": "af029603fa17a4988a67d221be9f85975dba85ba", "filename": "src/test/ui/error-codes/E0201.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Ferror-codes%2FE0201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Ferror-codes%2FE0201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0201.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -2,17 +2,17 @@ error[E0201]: duplicate definitions with name `bar`:\n   --> $DIR/E0201.rs:5:5\n    |\n LL |     fn bar(&self) -> bool { self.0 > 5 }\n-   |     ------------------------------------ previous definition of `bar` here\n+   |     --------------------- previous definition of `bar` here\n LL |     fn bar() {}\n-   |     ^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^ duplicate definition\n \n error[E0201]: duplicate definitions with name `baz`:\n   --> $DIR/E0201.rs:17:5\n    |\n LL |     fn baz(&self) -> bool { true }\n-   |     ------------------------------ previous definition of `baz` here\n+   |     --------------------- previous definition of `baz` here\n LL |     fn baz(&self) -> bool { self.0 > 5 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^^^^^^^^^^^^^^ duplicate definition\n \n error[E0201]: duplicate definitions with name `Quux`:\n   --> $DIR/E0201.rs:18:5"}, {"sha": "c19702a5bf0cf26c13e7d27e6bbcfd24a0b3312b", "filename": "src/test/ui/impl-duplicate-methods.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fimpl-duplicate-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fimpl-duplicate-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-duplicate-methods.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -2,9 +2,9 @@ error[E0201]: duplicate definitions with name `orange`:\n   --> $DIR/impl-duplicate-methods.rs:5:5\n    |\n LL |     fn orange(&self) {}\n-   |     ------------------- previous definition of `orange` here\n+   |     ---------------- previous definition of `orange` here\n LL |     fn orange(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^^^^^^^^^ duplicate definition\n \n error: aborting due to previous error\n "}, {"sha": "27e83d495749371618a6a7277556147a0246af92", "filename": "src/test/ui/issues/issue-4265.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fissues%2Fissue-4265.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fissues%2Fissue-4265.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4265.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -1,14 +1,11 @@\n error[E0201]: duplicate definitions with name `bar`:\n   --> $DIR/issue-4265.rs:10:5\n    |\n-LL | /     fn bar() {\n-LL | |         Foo { baz: 0 }.bar();\n-LL | |     }\n-   | |_____- previous definition of `bar` here\n-LL |\n-LL | /     fn bar() {\n-LL | |     }\n-   | |_____^ duplicate definition\n+LL |     fn bar() {\n+   |     -------- previous definition of `bar` here\n+...\n+LL |     fn bar() {\n+   |     ^^^^^^^^ duplicate definition\n \n error: aborting due to previous error\n "}, {"sha": "7ae00835c965d3b74680aa969ced7252c2364698", "filename": "src/test/ui/methods/method-macro-backtrace.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmethods%2Fmethod-macro-backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Fmethods%2Fmethod-macro-backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-macro-backtrace.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -2,9 +2,9 @@ error[E0201]: duplicate definitions with name `bar`:\n   --> $DIR/method-macro-backtrace.rs:22:5\n    |\n LL |     fn bar(&self) { }\n-   |     ----------------- previous definition of `bar` here\n+   |     ------------- previous definition of `bar` here\n LL |     fn bar(&self) { }\n-   |     ^^^^^^^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^^^^^^ duplicate definition\n \n error: aborting due to previous error\n "}, {"sha": "b76bbc0235fde49ea047997505c603416c53ed21", "filename": "src/test/ui/traits/issue-8153.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Ftraits%2Fissue-8153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baf382e63c023259fa1f9042f8f479f183ca6ed3/src%2Ftest%2Fui%2Ftraits%2Fissue-8153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-8153.stderr?ref=baf382e63c023259fa1f9042f8f479f183ca6ed3", "patch": "@@ -2,9 +2,9 @@ error[E0201]: duplicate definitions with name `bar`:\n   --> $DIR/issue-8153.rs:11:5\n    |\n LL |     fn bar(&self) -> isize {1}\n-   |     -------------------------- previous definition of `bar` here\n+   |     ---------------------- previous definition of `bar` here\n LL |     fn bar(&self) -> isize {2}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definition\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ duplicate definition\n \n error: aborting due to previous error\n "}]}