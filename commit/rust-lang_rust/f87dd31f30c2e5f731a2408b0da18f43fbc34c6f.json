{"sha": "f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4N2RkMzFmMzBjMmU1ZjczMWEyNDA4YjBkYTE4ZjQzZmJjMzRjNmY=", "commit": {"author": {"name": "Nathan Weston", "email": "nweston@fastmail.com", "date": "2015-08-23T17:25:45Z"}, "committer": {"name": "Nathan Weston", "email": "nweston@fastmail.com", "date": "2015-09-15T13:41:25Z"}, "message": "New lint: loop with explicit counter variable (fixes #159)\n\nAvoiding false positives here turns out to be fairly complicated.", "tree": {"sha": "c9bacc3d6d1cd34edf3b86433dd84b8ceef6484d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9bacc3d6d1cd34edf3b86433dd84b8ceef6484d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "html_url": "https://github.com/rust-lang/rust/commit/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/comments", "author": {"login": "nweston", "id": 1608259, "node_id": "MDQ6VXNlcjE2MDgyNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1608259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nweston", "html_url": "https://github.com/nweston", "followers_url": "https://api.github.com/users/nweston/followers", "following_url": "https://api.github.com/users/nweston/following{/other_user}", "gists_url": "https://api.github.com/users/nweston/gists{/gist_id}", "starred_url": "https://api.github.com/users/nweston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nweston/subscriptions", "organizations_url": "https://api.github.com/users/nweston/orgs", "repos_url": "https://api.github.com/users/nweston/repos", "events_url": "https://api.github.com/users/nweston/events{/privacy}", "received_events_url": "https://api.github.com/users/nweston/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nweston", "id": 1608259, "node_id": "MDQ6VXNlcjE2MDgyNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1608259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nweston", "html_url": "https://github.com/nweston", "followers_url": "https://api.github.com/users/nweston/followers", "following_url": "https://api.github.com/users/nweston/following{/other_user}", "gists_url": "https://api.github.com/users/nweston/gists{/gist_id}", "starred_url": "https://api.github.com/users/nweston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nweston/subscriptions", "organizations_url": "https://api.github.com/users/nweston/orgs", "repos_url": "https://api.github.com/users/nweston/repos", "events_url": "https://api.github.com/users/nweston/events{/privacy}", "received_events_url": "https://api.github.com/users/nweston/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a10db7bcd642d035151949a3e2d24265387b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a10db7bcd642d035151949a3e2d24265387b98", "html_url": "https://github.com/rust-lang/rust/commit/d2a10db7bcd642d035151949a3e2d24265387b98"}], "stats": {"total": 297, "additions": 291, "deletions": 6}, "files": [{"sha": "011078c5407299325ec21013a03475c25ae9e002", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "patch": "@@ -6,7 +6,7 @@ A collection of lints that give helpful tips to newbies and catch oversights.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 57 lints included in this crate:\n+There are 58 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -21,6 +21,7 @@ name\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                 | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                       | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                         | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)         | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)               | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                 | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                             | warn    | using identity operations, e.g. `x + 0` or `y / 1`"}, {"sha": "b88d2c844b0f57fde7ae9cc37ac2313b12ddd49d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "patch": "@@ -119,6 +119,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n         lifetimes::NEEDLESS_LIFETIMES,\n+        loops::EXPLICIT_COUNTER_LOOP,\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,"}, {"sha": "a381737fe3b3d820248cbf67ec2869dcc199c542", "filename": "src/loops.rs", "status": "modified", "additions": 226, "deletions": 3, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "patch": "@@ -1,10 +1,12 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use reexport::*;\n-use rustc_front::visit::{Visitor, walk_expr};\n+use rustc_front::visit::{Visitor, walk_expr, walk_block, walk_decl};\n use rustc::middle::ty;\n+use rustc::middle::def::DefLocal;\n use consts::{constant_simple, Constant};\n-use std::collections::HashSet;\n+use rustc::front::map::Node::{NodeBlock};\n+use std::collections::{HashSet,HashMap};\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n             in_external_macro, expr_block, span_help_and_lint};\n@@ -29,13 +31,16 @@ declare_lint!{ pub UNUSED_COLLECT, Warn,\n declare_lint!{ pub REVERSE_RANGE_LOOP, Warn,\n                \"Iterating over an empty range, such as `10..0` or `5..5`\" }\n \n+declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n+               \"for-looping with an explicit counter when `_.enumerate()` would do\" }\n+\n #[derive(Copy, Clone)]\n pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n-                    WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP)\n+                    WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP, EXPLICIT_COUNTER_LOOP)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -120,6 +125,35 @@ impl LintPass for LoopsPass {\n                     }\n                 }\n             }\n+\n+            // Look for variables that are incremented once per loop iteration.\n+            let mut visitor = IncrementVisitor { cx: cx, states: HashMap::new(), depth: 0, done: false };\n+            walk_expr(&mut visitor, body);\n+\n+            // For each candidate, check the parent block to see if\n+            // it's initialized to zero at the start of the loop.\n+            let map = &cx.tcx.map;\n+            let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id) );\n+            if let Some(parent_id) = parent_scope {\n+                if let NodeBlock(block) = map.get(parent_id) {\n+                    for (id, _) in visitor.states.iter().filter( |&(_,v)| *v == VarState::IncrOnce) {\n+                        let mut visitor2 = InitializeVisitor { cx: cx, end_expr: expr, var_id: id.clone(),\n+                                                               state: VarState::IncrOnce, name: None,\n+                                                               depth: 0, done: false };\n+                        walk_block(&mut visitor2, block);\n+\n+                        if visitor2.state == VarState::Warn {\n+                            if let Some(name) = visitor2.name {\n+                                span_lint(cx, EXPLICIT_COUNTER_LOOP, expr.span,\n+                                          &format!(\"the variable `{0}` is used as a loop counter. Consider \\\n+                                                    using `for ({0}, item) in _.iter().enumerate()` \\\n+                                                    or similar iterators.\",\n+                                                   name));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n         }\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches explicit \"match\" instead of \"if let\")\n@@ -270,3 +304,192 @@ fn is_break_expr(expr: &Expr) -> bool {\n         _ => false,\n     }\n }\n+\n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n+#[derive(PartialEq)]\n+enum VarState {\n+    Initial,      // Not examined yet\n+    IncrOnce,     // Incremented exactly once, may be a loop counter\n+    Declared,     // Declared but not (yet) initialized to zero\n+    Warn,\n+    DontWarn\n+}\n+\n+// Scan a for loop for variables that are incremented exactly once.\n+struct IncrementVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>,      // context reference\n+    states: HashMap<NodeId, VarState>,  // incremented variables\n+    depth: u32,                         // depth of conditional expressions\n+    done: bool\n+}\n+\n+impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if self.done {\n+            return;\n+        }\n+\n+        // If node is a variable\n+        if let Some(def_id) = var_def_id(self.cx, expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                let state = self.states.entry(def_id).or_insert(VarState::Initial);\n+\n+                match parent.node {\n+                    ExprAssignOp(op, ref lhs, ref rhs) =>\n+                        if lhs.id == expr.id {\n+                            if op.node == BiAdd && is_lit_one(rhs) {\n+                                *state = match *state {\n+                                    VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n+                                    _ => VarState::DontWarn\n+                                };\n+                            }\n+                            else {\n+                                // Assigned some other value\n+                                *state = VarState::DontWarn;\n+                            }\n+                        },\n+                    ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    _ => ()\n+                }\n+            }\n+        }\n+        // Give up if there are nested loops\n+        else if is_loop(expr) {\n+            self.states.clear();\n+            self.done = true;\n+            return;\n+        }\n+        // Keep track of whether we're inside a conditional expression\n+        else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+// Check whether a variable is initialized to zero at the start of a loop.\n+struct InitializeVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>, // context reference\n+    end_expr: &'v Expr,      // the for loop. Stop scanning here.\n+    var_id: NodeId,\n+    state: VarState,\n+    name: Option<Name>,\n+    depth: u32,              // depth of conditional expressions\n+    done: bool\n+}\n+\n+impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n+    fn visit_decl(&mut self, decl: &'v Decl) {\n+        // Look for declarations of the variable\n+        if let DeclLocal(ref local) = decl.node {\n+            if local.pat.id == self.var_id {\n+                if let PatIdent(_, ref ident, _) = local.pat.node {\n+                    self.name = Some(ident.node.name);\n+\n+                    self.state = if let Some(ref init) = local.init {\n+                        if is_lit_zero(init) {\n+                            VarState::Warn\n+                        } else {\n+                            VarState::Declared\n+                        }\n+                    }\n+                    else {\n+                        VarState::Declared\n+                    }\n+                }\n+            }\n+        }\n+        walk_decl(self, decl);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if self.state == VarState::DontWarn || expr == self.end_expr {\n+            self.done = true;\n+        }\n+        // No need to visit expressions before the variable is\n+        // declared or after we've rejected it.\n+        if self.state == VarState::IncrOnce || self.done {\n+            return;\n+        }\n+\n+        // If node is the desired variable, see how it's used\n+        if var_def_id(self.cx, expr) == Some(self.var_id) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.node {\n+                    ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                        self.state = VarState::DontWarn;\n+                    },\n+                    ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                        self.state = if is_lit_zero(rhs) && self.depth == 0 {\n+                            VarState::Warn\n+                        } else {\n+                            VarState::DontWarn\n+                        }},\n+                    _ => ()\n+                }\n+            }\n+        }\n+        // If there are other loops between the declaration and the target loop, give up\n+        else if is_loop(expr) {\n+            self.state = VarState::DontWarn;\n+            self.done = true;\n+            return;\n+        }\n+        // Keep track of whether we're inside a conditional expression\n+        else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+fn var_def_id(cx: &Context, expr: &Expr) -> Option<NodeId> {\n+    if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n+        if let DefLocal(node_id) = path_res.base_def {\n+            return Some(node_id)\n+        }\n+    }\n+    None\n+}\n+\n+fn is_loop(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprLoop(..) | ExprWhile(..)  => true,\n+        _ => false\n+    }\n+}\n+\n+fn is_conditional(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprIf(..) | ExprMatch(..) => true,\n+        _ => false\n+    }\n+}\n+\n+// FIXME: copy/paste from misc.rs\n+fn is_lit_one(expr: &Expr) -> bool {\n+    if let ExprLit(ref spanned) = expr.node {\n+        if let LitInt(1, _) = spanned.node {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+// FIXME: copy/paste from ranges.rs\n+fn is_lit_zero(expr: &Expr) -> bool {\n+    if let ExprLit(ref spanned) = expr.node {\n+        if let LitInt(0, _) = spanned.node {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "3320e9acc1d049fb15563c548979d73228d5a78d", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "patch": "@@ -14,9 +14,9 @@ impl Unrelated {\n     }\n }\n \n-#[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop)]\n+#[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist)]\n+#[allow(linkedlist,shadow_unrelated)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n@@ -119,4 +119,64 @@ fn main() {\n     let mut out = vec![];\n     vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); //~ERROR you are collect()ing an iterator\n     let _y = vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n+\n+    // Loop with explicit counter variable\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+\n+    let mut _index = 1;\n+    _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+\n+    let mut _index;\n+    _index = 0;\n+    for _v in &vec { _index += 1 } //~ERROR the variable `_index` is used as a loop counter\n+    for _v in &vec { _index += 1 } // But this does not warn\n+\n+    // Potential false positives\n+    let mut _index = 0;\n+    _index = 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    _index += 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    if true { _index = 1 }\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    let mut _index = 1;\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index *= 2; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index = 1; _index += 1 }\n+\n+    let mut _index = 0;\n+\n+    for _v in &vec { let mut _index = 0; _index += 1 }\n+\n+    let mut _index = 0;\n+    for _v in &vec { _index += 1; _index = 0; }\n+\n+    let mut _index = 0;\n+    for _v in &vec { for _x in 0..1 { _index += 1; }; _index += 1 }\n+\n+    let mut _index = 0;\n+    for x in &vec { if *x == 1 { _index += 1 } }\n+\n+    let mut _index = 0;\n+    if true { _index = 1 };\n+    for _v in &vec { _index += 1 }\n+\n+    let mut _index = 1;\n+    if false { _index = 0 };\n+    for _v in &vec { _index += 1 }\n }"}]}