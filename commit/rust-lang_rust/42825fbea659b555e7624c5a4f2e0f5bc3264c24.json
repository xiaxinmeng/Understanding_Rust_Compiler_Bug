{"sha": "42825fbea659b555e7624c5a4f2e0f5bc3264c24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyODI1ZmJlYTY1OWI1NTVlNzYyNGM1YTRmMmUwZjViYzMyNjRjMjQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-10T22:20:03Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-11T00:53:09Z"}, "message": "Split libcore/arc.rs: arc -> std::arc; exclusive -> unsafe::exclusive", "tree": {"sha": "f47d59b917b8482267144b54b35fad7352f10505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f47d59b917b8482267144b54b35fad7352f10505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42825fbea659b555e7624c5a4f2e0f5bc3264c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42825fbea659b555e7624c5a4f2e0f5bc3264c24", "html_url": "https://github.com/rust-lang/rust/commit/42825fbea659b555e7624c5a4f2e0f5bc3264c24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42825fbea659b555e7624c5a4f2e0f5bc3264c24/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4808d59909b9350fcb557ec7e6f0ce21c505e803", "url": "https://api.github.com/repos/rust-lang/rust/commits/4808d59909b9350fcb557ec7e6f0ce21c505e803", "html_url": "https://github.com/rust-lang/rust/commit/4808d59909b9350fcb557ec7e6f0ce21c505e803"}], "stats": {"total": 591, "additions": 319, "deletions": 272}, "files": [{"sha": "fe359646868824400758dcb54a364d318afd80b1", "filename": "src/libcore/arc.rs", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/4808d59909b9350fcb557ec7e6f0ce21c505e803/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4808d59909b9350fcb557ec7e6f0ce21c505e803/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=4808d59909b9350fcb557ec7e6f0ce21c505e803", "patch": "@@ -1,219 +0,0 @@\n-/**\n- * An atomically reference counted wrapper that can be used to\n- * share immutable data between tasks.\n- */\n-\n-export arc, get, clone;\n-\n-export exclusive, methods;\n-\n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    #[rust_stack]\n-    fn rust_atomic_increment(p: &mut libc::intptr_t)\n-        -> libc::intptr_t;\n-\n-    #[rust_stack]\n-    fn rust_atomic_decrement(p: &mut libc::intptr_t)\n-        -> libc::intptr_t;\n-}\n-\n-type arc_data<T> = {\n-    mut count: libc::intptr_t,\n-    data: T\n-};\n-\n-class arc_destruct<T> {\n-  let data: *libc::c_void;\n-  new(data: *libc::c_void) { self.data = data; }\n-  drop unsafe {\n-     let data: ~arc_data<T> = unsafe::reinterpret_cast(self.data);\n-     let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n-     assert new_count >= 0;\n-     if new_count == 0 {\n-         // drop glue takes over.\n-     } else {\n-       unsafe::forget(data);\n-     }\n-  }\n-}\n-\n-type arc<T: const send> = arc_destruct<T>;\n-\n-/// Create an atomically reference counted wrapper.\n-fn arc<T: const send>(-data: T) -> arc<T> {\n-    let data = ~{mut count: 1, data: data};\n-    unsafe {\n-        let ptr = unsafe::transmute(data);\n-        arc_destruct(ptr)\n-    }\n-}\n-\n-/**\n- * Access the underlying data in an atomically reference counted\n- * wrapper.\n- */\n-fn get<T: const send>(rc: &arc<T>) -> &T {\n-    unsafe {\n-        let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n-        // Cast us back into the correct region\n-        let r = unsafe::reinterpret_cast(&ptr.data);\n-        unsafe::forget(ptr);\n-        return r;\n-    }\n-}\n-\n-/**\n- * Duplicate an atomically reference counted wrapper.\n- *\n- * The resulting two `arc` objects will point to the same underlying data\n- * object. However, one of the `arc` objects can be sent to another task,\n- * allowing them to share the underlying data.\n- */\n-fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n-    unsafe {\n-        let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n-        let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n-        assert new_count >= 2;\n-        unsafe::forget(ptr);\n-    }\n-    arc_destruct((*rc).data)\n-}\n-\n-// An arc over mutable data that is protected by a lock.\n-type ex_data<T: send> =\n-    {lock: sys::little_lock, mut failed: bool, mut data: T};\n-type exclusive<T: send> = arc_destruct<ex_data<T>>;\n-\n-fn exclusive<T:send >(-data: T) -> exclusive<T> {\n-    let data = ~{mut count: 1, data: {lock: sys::little_lock(), failed: false,\n-                                      data: data}};\n-    unsafe {\n-        let ptr = unsafe::reinterpret_cast(data);\n-        unsafe::forget(data);\n-        arc_destruct(ptr)\n-    }\n-}\n-\n-impl<T: send> exclusive<T> {\n-    /// Duplicate an exclusive ARC. See arc::clone.\n-    fn clone() -> exclusive<T> {\n-        unsafe {\n-            // this makes me nervous...\n-            let ptr: ~arc_data<ex_data<T>> =\n-                  unsafe::reinterpret_cast(self.data);\n-            let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n-            assert new_count > 1;\n-            unsafe::forget(ptr);\n-        }\n-        arc_destruct(self.data)\n-    }\n-\n-    /**\n-     * Access the underlying mutable data with mutual exclusion from other\n-     * tasks. The argument closure will be run with the mutex locked; all\n-     * other tasks wishing to access the data will block until the closure\n-     * finishes running.\n-     *\n-     * Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n-     * accessing the provided condition variable) are prohibited while inside\n-     * the exclusive. Supporting that is a work in progress.\n-     *\n-     * The reason this function is 'unsafe' is because it is possible to\n-     * construct a circular reference among multiple ARCs by mutating the\n-     * underlying data. This creates potential for deadlock, but worse, this\n-     * will guarantee a memory leak of all involved ARCs. Using exclusive\n-     * ARCs inside of other ARCs is safe in absence of circular references.\n-     */\n-    unsafe fn with<U>(f: fn(x: &mut T) -> U) -> U {\n-        let ptr: ~arc_data<ex_data<T>> =\n-            unsafe::reinterpret_cast(self.data);\n-        assert ptr.count > 0;\n-        let ptr2: &arc_data<ex_data<T>> = unsafe::reinterpret_cast(&*ptr);\n-        unsafe::forget(ptr);\n-        let rec: &ex_data<T> = &(*ptr2).data;\n-        do rec.lock.lock {\n-            if rec.failed {\n-                fail ~\"Poisoned arc::exclusive - another task failed inside!\";\n-            }\n-            rec.failed = true;\n-            let result = f(&mut rec.data);\n-            rec.failed = false;\n-            result\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    import comm::*;\n-\n-    #[test]\n-    fn manually_share_arc() {\n-        let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = arc::arc(v);\n-\n-        let p = port();\n-        let c = chan(p);\n-\n-        do task::spawn() {\n-            let p = port();\n-            c.send(chan(p));\n-\n-            let arc_v = p.recv();\n-\n-            let v = *arc::get::<~[int]>(&arc_v);\n-            assert v[3] == 4;\n-        };\n-\n-        let c = p.recv();\n-        c.send(arc::clone(&arc_v));\n-\n-        assert (*arc::get(&arc_v))[2] == 3;\n-\n-        log(info, arc_v);\n-    }\n-\n-    #[test]\n-    fn exclusive_arc() {\n-        let mut futures = ~[];\n-\n-        let num_tasks = 10u;\n-        let count = 10u;\n-\n-        let total = exclusive(~mut 0u);\n-\n-        for uint::range(0u, num_tasks) |_i| {\n-            let total = total.clone();\n-            futures += ~[future::spawn(|| {\n-                for uint::range(0u, count) |_i| {\n-                    do total.with |count| {\n-                        **count += 1u;\n-                    }\n-                }\n-            })];\n-        };\n-\n-        for futures.each |f| { f.get() }\n-\n-        do total.with |total| {\n-            assert **total == num_tasks * count\n-        };\n-    }\n-\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n-        // Tests that if one task fails inside of an exclusive, subsequent\n-        // accesses will also fail.\n-        let x = arc::exclusive(1);\n-        let x2 = x.clone();\n-        do task::try {\n-            do x2.with |one| {\n-                assert *one == 2;\n-            }\n-        };\n-        do x.with |one| {\n-            assert *one == 1;\n-        }\n-    }\n-}"}, {"sha": "a9950d2897e9b6c8efa386e30e37fe525868b59c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, at_vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, comm, task, future, pipes, sync;\n+export comm, task, future, pipes;\n export extfmt;\n // The test harness links against core, so don't include runtime in tests.\n // FIXME (#2861): Uncomment this after snapshot gets updated.\n@@ -199,12 +199,10 @@ mod dlist_iter {\n mod send_map;\n \n // Concurrency\n-mod arc;\n mod comm;\n mod task;\n mod future;\n mod pipes;\n-mod sync;\n \n // Runtime and language-primitive support\n "}, {"sha": "91338d70ac1ec2f7f9db146854b1a94d6bebf72b", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -1064,7 +1064,7 @@ impl<T: send> port<T>: selectable {\n }\n \n /// A channel that can be shared between many senders.\n-type shared_chan<T: send> = arc::exclusive<chan<T>>;\n+type shared_chan<T: send> = unsafe::exclusive<chan<T>>;\n \n impl<T: send> shared_chan<T>: channel<T> {\n     fn send(+x: T) {\n@@ -1088,7 +1088,7 @@ impl<T: send> shared_chan<T>: channel<T> {\n \n /// Converts a `chan` into a `shared_chan`.\n fn shared_chan<T:send>(+c: chan<T>) -> shared_chan<T> {\n-    arc::exclusive(c)\n+    unsafe::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints."}, {"sha": "1e77a1441ccedf50737daee7d70798da57eb1ec1", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -7,27 +7,17 @@ export min_align_of;\n export pref_align_of;\n export refcount;\n export log_str;\n-export little_lock, methods;\n export shape_eq, shape_lt, shape_le;\n \n-import task::atomically;\n-\n enum type_desc = {\n     size: uint,\n     align: uint\n     // Remaining fields not listed\n };\n \n-type rust_little_lock = *libc::c_void;\n-\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     pure fn shape_log_str(t: *sys::type_desc, data: *()) -> ~str;\n-\n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -98,30 +88,6 @@ pure fn log_str<T>(t: T) -> ~str {\n     }\n }\n \n-class little_lock {\n-    let l: rust_little_lock;\n-    new() {\n-        self.l = rustrt::rust_create_little_lock();\n-    }\n-    drop { rustrt::rust_destroy_little_lock(self.l); }\n-}\n-\n-impl little_lock {\n-    unsafe fn lock<T>(f: fn() -> T) -> T {\n-        class unlock {\n-            let l: rust_little_lock;\n-            new(l: rust_little_lock) { self.l = l; }\n-            drop { rustrt::rust_unlock_little_lock(self.l); }\n-        }\n-\n-        do atomically {\n-            rustrt::rust_lock_little_lock(self.l);\n-            let _r = unlock(self.l);\n-            f()\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n "}, {"sha": "e2767da0c3e0fab7f52d8bbade59529e88b03e82", "filename": "src/libcore/task.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -625,7 +625,7 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  * Several data structures are involved in task management to allow properly\n  * propagating failure across linked/supervised tasks.\n  *\n- * (1) The \"taskgroup_arc\" is an arc::exclusive which contains a hashset of\n+ * (1) The \"taskgroup_arc\" is an unsafe::exclusive which contains a hashset of\n  *     all tasks that are part of the group. Some tasks are 'members', which\n  *     means if they fail, they will kill everybody else in the taskgroup.\n  *     Other tasks are 'descendants', which means they will not kill tasks\n@@ -639,7 +639,7 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  *     whether it's part of the 'main'/'root' taskgroup, and an optionally\n  *     configured notification port. These are stored in TLS.\n  *\n- * (3) The \"ancestor_list\" is a cons-style list of arc::exclusives which\n+ * (3) The \"ancestor_list\" is a cons-style list of unsafe::exclusives which\n  *     tracks 'generations' of taskgroups -- a group's ancestors are groups\n  *     which (directly or transitively) spawn_supervised-ed them. Each task\n  *     is recorded in the 'descendants' of each of its ancestor groups.\n@@ -725,7 +725,7 @@ type taskgroup_data = {\n     // tasks in this group.\n     mut descendants: taskset,\n };\n-type taskgroup_arc = arc::exclusive<option<taskgroup_data>>;\n+type taskgroup_arc = unsafe::exclusive<option<taskgroup_data>>;\n \n type taskgroup_inner = &mut option<taskgroup_data>;\n \n@@ -754,15 +754,15 @@ type ancestor_node = {\n     // Recursive rest of the list.\n     mut ancestors:    ancestor_list,\n };\n-enum ancestor_list = option<arc::exclusive<ancestor_node>>;\n+enum ancestor_list = option<unsafe::exclusive<ancestor_node>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n fn access_group<U>(x: taskgroup_arc, blk: fn(taskgroup_inner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n #[inline(always)]\n-fn access_ancestors<U>(x: arc::exclusive<ancestor_node>,\n+fn access_ancestors<U>(x: unsafe::exclusive<ancestor_node>,\n                        blk: fn(x: &mut ancestor_node) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -1035,8 +1035,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             let mut members = new_taskset();\n             taskset_insert(&mut members, spawner);\n             let tasks =\n-                arc::exclusive(some({ mut members:     members,\n-                                      mut descendants: new_taskset() }));\n+                unsafe::exclusive(some({ mut members:     members,\n+                                         mut descendants: new_taskset() }));\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n                 @tcb(spawner, tasks, ancestor_list(none), true, none);\n@@ -1057,8 +1057,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         (g, a, spawner_group.is_main)\n     } else {\n         // Child is in a separate group from spawner.\n-        let g = arc::exclusive(some({ mut members:     new_taskset(),\n-                                      mut descendants: new_taskset() }));\n+        let g = unsafe::exclusive(some({ mut members:     new_taskset(),\n+                                         mut descendants: new_taskset() }));\n         let a = if supervised {\n             // Child's ancestors start with the spawner.\n             let old_ancestors = share_ancestors(&mut spawner_group.ancestors);\n@@ -1072,7 +1072,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 };\n             assert new_generation < uint::max_value;\n             // Build a new node in the ancestor list.\n-            ancestor_list(some(arc::exclusive(\n+            ancestor_list(some(unsafe::exclusive(\n                 { generation:       new_generation,\n                   mut parent_group: some(spawner_group.tasks.clone()),\n                   mut ancestors:    old_ancestors })))"}, {"sha": "e8a6cd075a5e693a868e891bd3428a967b6ad083", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -2,6 +2,12 @@\n \n export reinterpret_cast, forget, bump_box_refcount, transmute;\n \n+export shared_mutable_state, clone_shared_mutable_state;\n+export get_shared_mutable_state, get_shared_immutable_state;\n+export exclusive;\n+\n+import task::atomically;\n+\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     fn forget<T>(-x: T);\n@@ -47,6 +53,167 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n     return newthing;\n }\n \n+/****************************************************************************\n+ * Shared state & exclusive ARC\n+ ****************************************************************************/\n+\n+type arc_data<T> = {\n+    mut count: libc::intptr_t,\n+    data: T\n+};\n+\n+class arc_destruct<T> {\n+   let data: *libc::c_void;\n+   new(data: *libc::c_void) { self.data = data; }\n+   drop unsafe {\n+      let data: ~arc_data<T> = unsafe::reinterpret_cast(self.data);\n+      let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n+      assert new_count >= 0;\n+      if new_count == 0 {\n+          // drop glue takes over.\n+      } else {\n+        unsafe::forget(data);\n+      }\n+   }\n+}\n+\n+/**\n+ * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n+ *\n+ * Data races between tasks can result in crashes and, with sufficient\n+ * cleverness, arbitrary type coercion.\n+ */\n+type shared_mutable_state<T: send> = arc_destruct<T>;\n+\n+unsafe fn shared_mutable_state<T: send>(+data: T) -> shared_mutable_state<T> {\n+    let data = ~{mut count: 1, data: data};\n+    unsafe {\n+        let ptr = unsafe::transmute(data);\n+        arc_destruct(ptr)\n+    }\n+}\n+\n+unsafe fn get_shared_mutable_state<T: send>(rc: &shared_mutable_state<T>)\n+        -> &mut T {\n+    unsafe {\n+        let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n+        assert ptr.count > 0;\n+        // Cast us back into the correct region\n+        let r = unsafe::reinterpret_cast(&ptr.data);\n+        unsafe::forget(ptr);\n+        return r;\n+    }\n+}\n+unsafe fn get_shared_immutable_state<T: send>(rc: &shared_mutable_state<T>)\n+        -> &T {\n+    unsafe {\n+        let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n+        assert ptr.count > 0;\n+        // Cast us back into the correct region\n+        let r = unsafe::reinterpret_cast(&ptr.data);\n+        unsafe::forget(ptr);\n+        return r;\n+    }\n+}\n+\n+unsafe fn clone_shared_mutable_state<T: send>(rc: &shared_mutable_state<T>)\n+        -> shared_mutable_state<T> {\n+    unsafe {\n+        let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n+        let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+        assert new_count >= 2;\n+        unsafe::forget(ptr);\n+    }\n+    arc_destruct((*rc).data)\n+}\n+\n+/****************************************************************************/\n+\n+type rust_little_lock = *libc::c_void;\n+\n+#[abi = \"cdecl\"]\n+extern mod rustrt {\n+    #[rust_stack]\n+    fn rust_atomic_increment(p: &mut libc::intptr_t)\n+        -> libc::intptr_t;\n+\n+    #[rust_stack]\n+    fn rust_atomic_decrement(p: &mut libc::intptr_t)\n+        -> libc::intptr_t;\n+\n+    fn rust_create_little_lock() -> rust_little_lock;\n+    fn rust_destroy_little_lock(lock: rust_little_lock);\n+    fn rust_lock_little_lock(lock: rust_little_lock);\n+    fn rust_unlock_little_lock(lock: rust_little_lock);\n+}\n+\n+class little_lock {\n+    let l: rust_little_lock;\n+    new() {\n+        self.l = rustrt::rust_create_little_lock();\n+    }\n+    drop { rustrt::rust_destroy_little_lock(self.l); }\n+}\n+\n+impl little_lock {\n+    unsafe fn lock<T>(f: fn() -> T) -> T {\n+        class unlock {\n+            let l: rust_little_lock;\n+            new(l: rust_little_lock) { self.l = l; }\n+            drop { rustrt::rust_unlock_little_lock(self.l); }\n+        }\n+\n+        do atomically {\n+            rustrt::rust_lock_little_lock(self.l);\n+            let _r = unlock(self.l);\n+            f()\n+        }\n+    }\n+}\n+\n+struct ex_data<T: send> { lock: little_lock; mut failed: bool; mut data: T; }\n+/**\n+ * An arc over mutable data that is protected by a lock. For library use only.\n+ */\n+struct exclusive<T: send> { x: shared_mutable_state<ex_data<T>>; }\n+\n+fn exclusive<T:send >(+user_data: T) -> exclusive<T> {\n+    let data = ex_data {\n+        lock: little_lock(), mut failed: false, mut data: user_data\n+    };\n+    exclusive { x: unsafe { shared_mutable_state(data) } }\n+}\n+\n+impl<T: send> exclusive<T> {\n+    // Duplicate an exclusive ARC, as std::arc::clone.\n+    fn clone() -> exclusive<T> {\n+        exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+    }\n+\n+    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n+    // instead of a proper mutex. Same reason for being unsafe.\n+    //\n+    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n+    // accessing the provided condition variable) are prohibited while inside\n+    // the exclusive. Supporting that is a work in progress.\n+    unsafe fn with<U>(f: fn(x: &mut T) -> U) -> U {\n+        let rec = unsafe { get_shared_mutable_state(&self.x) };\n+        do rec.lock.lock {\n+            if rec.failed {\n+                fail ~\"Poisoned exclusive - another task failed inside!\";\n+            }\n+            rec.failed = true;\n+            let result = f(&mut rec.data);\n+            rec.failed = false;\n+            result\n+        }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Tests\n+ ****************************************************************************/\n+\n #[cfg(test)]\n mod tests {\n \n@@ -86,4 +253,47 @@ mod tests {\n             assert transmute(~\"L\") == ~[76u8, 0u8];\n         }\n     }\n+\n+    #[test]\n+    fn exclusive_arc() {\n+        let mut futures = ~[];\n+\n+        let num_tasks = 10u;\n+        let count = 10u;\n+\n+        let total = exclusive(~mut 0u);\n+\n+        for uint::range(0u, num_tasks) |_i| {\n+            let total = total.clone();\n+            futures += ~[future::spawn(|| {\n+                for uint::range(0u, count) |_i| {\n+                    do total.with |count| {\n+                        **count += 1u;\n+                    }\n+                }\n+            })];\n+        };\n+\n+        for futures.each |f| { f.get() }\n+\n+        do total.with |total| {\n+            assert **total == num_tasks * count\n+        };\n+    }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn exclusive_poison() {\n+        // Tests that if one task fails inside of an exclusive, subsequent\n+        // accesses will also fail.\n+        let x = exclusive(1);\n+        let x2 = x.clone();\n+        do task::try {\n+            do x2.with |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do x.with |one| {\n+            assert *one == 1;\n+        }\n+    }\n }"}, {"sha": "6ce3481a05326612128a62e3cd49f898da00f3aa", "filename": "src/libstd/arc.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -0,0 +1,83 @@\n+/**\n+ * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n+ * between tasks.\n+ */\n+\n+import unsafe::{shared_mutable_state, clone_shared_mutable_state,\n+                get_shared_mutable_state, get_shared_immutable_state};\n+\n+export arc, clone, get;\n+\n+/****************************************************************************\n+ * Immutable ARC\n+ ****************************************************************************/\n+\n+/// An atomically reference counted wrapper for shared immutable state.\n+struct arc<T: const send> { x: shared_mutable_state<T>; }\n+\n+/// Create an atomically reference counted wrapper.\n+fn arc<T: const send>(+data: T) -> arc<T> {\n+    arc { x: unsafe { shared_mutable_state(data) } }\n+}\n+\n+/**\n+ * Access the underlying data in an atomically reference counted\n+ * wrapper.\n+ */\n+fn get<T: const send>(rc: &arc<T>) -> &T {\n+    unsafe { get_shared_immutable_state(&rc.x) }\n+}\n+\n+/**\n+ * Duplicate an atomically reference counted wrapper.\n+ *\n+ * The resulting two `arc` objects will point to the same underlying data\n+ * object. However, one of the `arc` objects can be sent to another task,\n+ * allowing them to share the underlying data.\n+ */\n+fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n+    arc { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n+}\n+\n+/****************************************************************************\n+ * Mutex protected ARC (unsafe)\n+ ****************************************************************************/\n+\n+/****************************************************************************\n+ * R/W lock protected ARC\n+ ****************************************************************************/\n+\n+/****************************************************************************\n+ * Tests\n+ ****************************************************************************/\n+\n+#[cfg(test)]\n+mod tests {\n+    import comm::*;\n+\n+    #[test]\n+    fn manually_share_arc() {\n+        let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let arc_v = arc::arc(v);\n+\n+        let p = port();\n+        let c = chan(p);\n+\n+        do task::spawn() {\n+            let p = port();\n+            c.send(chan(p));\n+\n+            let arc_v = p.recv();\n+\n+            let v = *arc::get::<~[int]>(&arc_v);\n+            assert v[3] == 4;\n+        };\n+\n+        let c = p.recv();\n+        c.send(arc::clone(&arc_v));\n+\n+        assert (*arc::get(&arc_v))[2] == 3;\n+\n+        log(info, arc_v);\n+    }\n+}"}, {"sha": "bc3c6fb65133cb38f641a9cd4bb9566cee9946b9", "filename": "src/libstd/std.rc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -45,6 +45,10 @@ mod uv_global_loop;\n mod c_vec;\n mod timer;\n \n+// Concurrency\n+\n+mod sync;\n+mod arc;\n \n // Collections\n "}, {"sha": "575412825e1923c3326d285864249f23ed2f304b", "filename": "src/libstd/sync.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -8,7 +8,7 @@\n export condvar, semaphore, mutex, rwlock;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n-import arc::exclusive;\n+import unsafe::exclusive;\n \n /****************************************************************************\n  * Internals\n@@ -292,14 +292,14 @@ struct rwlock_inner {\n struct rwlock {\n     /* priv */ order_lock:  semaphore;\n     /* priv */ access_lock: sem<waitqueue>;\n-    /* priv */ state:       arc::exclusive<rwlock_inner>;\n+    /* priv */ state:       exclusive<rwlock_inner>;\n }\n \n /// Create a new rwlock.\n fn rwlock() -> rwlock {\n     rwlock { order_lock: semaphore(1), access_lock: new_sem_and_signal(1),\n-             state: arc::exclusive(rwlock_inner { read_mode:  false,\n-                                                  read_count: 0 }) }\n+             state: exclusive(rwlock_inner { read_mode:  false,\n+                                             read_count: 0 }) }\n }\n \n impl &rwlock {", "previous_filename": "src/libcore/sync.rs"}, {"sha": "487fa3d6cdf1d0bb19342b80f396e36d3003edc4", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -1,5 +1,6 @@\n // error-pattern: copying a noncopyable value\n \n+use std;\n import comm::*;\n \n fn main() {"}, {"sha": "83a2662435e9160d4d28b56da85ad1e159d62098", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -1,3 +1,4 @@\n+use std;\n import comm::*;\n \n fn main() {"}, {"sha": "8f206ba8912c54b9b0e5cd09fa2567b86b63a1e8", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42825fbea659b555e7624c5a4f2e0f5bc3264c24/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=42825fbea659b555e7624c5a4f2e0f5bc3264c24", "patch": "@@ -1,5 +1,8 @@\n // error-pattern:explicit failure\n \n+use std;\n+import std::arc;\n+\n enum e<T: const send> { e(arc::arc<T>) }\n \n fn foo() -> e<int> {fail;}"}]}