{"sha": "eb194621044253fae32649511d76515a64009a53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTk0NjIxMDQ0MjUzZmFlMzI2NDk1MTFkNzY1MTVhNjQwMDlhNTM=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-01-24T20:47:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-03T23:37:24Z"}, "message": "Converted libcore/uint-template.rs to the new string functions.\n\n- Moved ToStr implementation of unsigned integers to uint-template.rs.\n- Marked the `str()` function as deprecated.\n- Forwarded all conversion functions to `core::num::to_str_common()`\n  and `core::num::from_str_common()`.\n- Fixed most places in the codebase where `to_str()` is being used.\n- Added uint-template to_str and from_str overflow tests.", "tree": {"sha": "a23632e8039ccea8f82d6e1ca2c09f8b82193494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a23632e8039ccea8f82d6e1ca2c09f8b82193494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb194621044253fae32649511d76515a64009a53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb194621044253fae32649511d76515a64009a53", "html_url": "https://github.com/rust-lang/rust/commit/eb194621044253fae32649511d76515a64009a53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb194621044253fae32649511d76515a64009a53/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e72bf92bb0f9cf4d10a5edb07dbbd5c09f0e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e72bf92bb0f9cf4d10a5edb07dbbd5c09f0e24", "html_url": "https://github.com/rust-lang/rust/commit/26e72bf92bb0f9cf4d10a5edb07dbbd5c09f0e24"}], "stats": {"total": 310, "additions": 155, "deletions": 155}, "files": [{"sha": "2fcd233203288a915fe196185656de1f4243814a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -200,7 +200,7 @@ pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n pub pure fn escape_unicode(c: char) -> ~str {\n-    let s = u32::to_str(c as u32, 16u);\n+    let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });"}, {"sha": "4627c04801539bc2c31049add6938661feeeffef", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -596,7 +596,7 @@ pub mod rt {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n-                let s = uint::to_str(num, radix);\n+                let s = uint::to_str_radix(num, radix);\n                 let len = str::char_len(s);\n                 if len < prec {\n                     let diff = prec - len;"}, {"sha": "d676570e1e6cb9df3fb8ab1144a1907873e1d901", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -354,7 +354,7 @@ impl &SipState : Streaming {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for vec::each(r) |b| {\n-            s += uint::to_str(*b as uint, 16u);\n+            s += uint::to_str_radix(*b as uint, 16u);\n         }\n         move s\n     }\n@@ -449,7 +449,7 @@ pub fn test_siphash() {\n     fn to_hex_str(r:  &[u8 * 8]) -> ~str {\n         let mut s = ~\"\";\n         for vec::each(*r) |b| {\n-            s += uint::to_str(*b as uint, 16u);\n+            s += uint::to_str_radix(*b as uint, 16u);\n         }\n         move s\n     }"}, {"sha": "b726cf62cfe52647f7f68996eda2bb90281ec559", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -910,7 +910,7 @@ impl<T: Writer> T : WriterUtil {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_uint(&self, n: uint) {\n-        uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_le_uint(&self, n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))"}, {"sha": "6263a9d887bb29e5f1db4f086f6cf650ffd80241", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -353,25 +353,25 @@ fn test_to_str() {\n fn test_int_to_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n     assert (i8::to_str(i8_val) == ~\"127\");\n-    \n+\n     i8_val += 1 as i8;\n     assert (i8::to_str(i8_val) == ~\"-128\");\n \n     let mut i16_val: i16 = 32_767_i16;\n     assert (i16::to_str(i16_val) == ~\"32767\");\n-    \n+\n     i16_val += 1 as i16;\n     assert (i16::to_str(i16_val) == ~\"-32768\");\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n     assert (i32::to_str(i32_val) == ~\"2147483647\");\n-    \n+\n     i32_val += 1 as i32;\n     assert (i32::to_str(i32_val) == ~\"-2147483648\");\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n     assert (i64::to_str(i64_val) == ~\"9223372036854775807\");\n-    \n+\n     i64_val += 1 as i64;\n     assert (i64::to_str(i64_val) == ~\"-9223372036854775808\");\n }\n@@ -380,25 +380,25 @@ fn test_int_to_str_overflow() {\n fn test_int_from_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n     assert (i8::from_str(~\"127\") == Some(i8_val));\n-    \n+\n     i8_val += 1 as i8;\n     assert (i8::from_str(~\"-128\") == Some(i8_val));\n \n     let mut i16_val: i16 = 32_767_i16;\n     assert (i16::from_str(~\"32767\") == Some(i16_val));\n-    \n+\n     i16_val += 1 as i16;\n     assert (i16::from_str(~\"-32768\") == Some(i16_val));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n     assert (i32::from_str(~\"2147483647\") == Some(i32_val));\n-    \n+\n     i32_val += 1 as i32;\n     assert (i32::from_str(~\"-2147483648\") == Some(i32_val));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n     assert (i64::from_str(~\"9223372036854775807\") == Some(i64_val));\n-    \n+\n     i64_val += 1 as i64;\n     assert (i64::from_str(~\"-9223372036854775808\") == Some(i64_val));\n }"}, {"sha": "0c39186824a722e250c22668d84c1a6f12f6d315", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 129, "deletions": 109, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -17,9 +17,13 @@ use T_SIGNED = self::inst::T_SIGNED;\n \n use char;\n use cmp::{Eq, Ord};\n+use cmp;\n+use to_str::ToStr;\n use from_str::FromStr;\n+use num::{ToStrRadix, FromStrRadix};\n use num;\n use option::{None, Option, Some};\n+use prelude::*;\n use str;\n use uint;\n use vec;\n@@ -172,135 +176,97 @@ impl T: num::Round {\n     pure fn fract(&self) -> T { 0 }\n }\n \n-/**\n- * Parse a buffer of bytes\n- *\n- * # Arguments\n- *\n- * * buf - A byte buffer\n- * * radix - The base of the number\n- *\n- * # Failure\n- *\n- * `buf` must not be empty\n- */\n-pub pure fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n-    if vec::len(buf) == 0u { return None; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut power = 1u as T;\n-    let mut n = 0u as T;\n-    loop {\n-        match char::to_digit(buf[i] as char, radix) {\n-          Some(d) => n += d as T * power,\n-          None => return None\n-        }\n-        power *= radix as T;\n-        if i == 0u { return Some(n); }\n-        i -= 1u;\n-    };\n-}\n+// String conversion functions and impl str -> num\n \n-/// Parse a string to an int\n+/// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T>\n-{\n-    parse_bytes(str::to_bytes(s), 10u)\n+pub pure fn from_str(s: &str) -> Option<T> {\n+    num::from_str_common(s, 10u, false, false, false,\n+                         num::ExpNone, false)\n }\n \n-impl T : FromStr {\n-    #[inline(always)]\n-    static pure fn from_str(s: &str) -> Option<T> { from_str(s) }\n+/// Parse a string as a number in the given base.\n+#[inline(always)]\n+pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    num::from_str_common(s, radix, false, false, false,\n+                         num::ExpNone, false)\n }\n \n-/// Parse a string as an unsigned integer.\n-pub fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n-    if str::len(buf) == 0u { return None; }\n-    let mut i = str::len(buf) - 1u;\n-    let mut power = 1u64, n = 0u64;\n-    loop {\n-        match char::to_digit(buf[i] as char, radix as uint) {\n-          Some(d) => n += d as u64 * power,\n-          None => return None\n-        }\n-        power *= radix;\n-        if i == 0u { return Some(n); }\n-        i -= 1u;\n-    };\n+/// Parse a byte slice as a number in the given base.\n+#[inline(always)]\n+pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+    num::from_str_bytes_common(buf, radix, false, false, false,\n+                               num::ExpNone, false)\n }\n \n-/**\n- * Convert to a string in a given base\n- *\n- * # Failure\n- *\n- * Fails if `radix` < 2 or `radix` > 16\n- */\n-#[inline(always)]\n-pub pure fn to_str(num: T, radix: uint) -> ~str {\n-    do to_str_bytes(false, num, radix) |slice| {\n-        do vec::as_imm_buf(slice) |p, len| {\n-            unsafe { str::raw::from_buf_len(p, len) }\n-        }\n+impl T : FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(s: &str) -> Option<T> {\n+        from_str(s)\n     }\n }\n \n-/// Low-level helper routine for string conversion.\n-pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n-                   f: fn(v: &[u8]) -> U) -> U {\n-\n+impl T : FromStrRadix {\n     #[inline(always)]\n-    pure fn digit(n: T) -> u8 {\n-        if n <= 9u as T {\n-            n as u8 + '0' as u8\n-        } else if n <= 15u as T {\n-            (n - 10 as T) as u8 + 'a' as u8\n-        } else {\n-            die!();\n-        }\n+    static pure fn from_str_radix(&self, s: &str, radix: uint) -> Option<T> {\n+        from_str_radix(s, radix)\n     }\n+}\n \n-    assert (1u < radix && radix <= 16u);\n-\n-    // Enough room to hold any number in any radix.\n-    // Worst case: 64-bit number, binary-radix, with\n-    // a leading negative sign = 65 bytes.\n-    let buf : [mut u8 * 65] = [mut 0u8, ..65];\n-    let len = buf.len();\n-\n-    let mut i = len;\n-    let mut n = num;\n-    let radix = radix as T;\n-    loop {\n-        i -= 1u;\n-        assert 0u < i && i < len;\n-        buf[i] = digit(n % radix);\n-        n /= radix;\n-        if n == 0 as T { break; }\n-    }\n+// String conversion functions and impl num -> str\n \n-    assert 0u < i && i < len;\n+/// Convert to a string as a byte slice in a given base.\n+#[inline(always)]\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+    let (buf, _) = num::to_str_bytes_common(&n, radix, false, false,\n+                                            num::SignNeg, num::DigAll);\n+    f(buf)\n+}\n \n-    if neg {\n-        i -= 1u;\n-        buf[i] = '-' as u8;\n-    }\n+/// Convert to a string in base 10.\n+#[inline(always)]\n+pub pure fn to_str(num: T) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, 10u, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n+}\n \n-    f(vec::view(buf, i, len))\n+/// Convert to a string in a given base.\n+#[inline(always)]\n+pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, radix, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n }\n \n-/// Convert to a string\n+/// Convert to a string.\n+/// *Deprecated*, use to_str() instead.\n #[inline(always)]\n-pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub pure fn str(i: T) -> ~str { to_str(i) }\n+\n+impl T : ToStr {\n+    #[inline(always)]\n+    pure fn to_str() -> ~str {\n+        to_str(self)\n+    }\n+}\n+\n+impl T : ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        to_str_radix(*self, radix)\n+    }\n+}\n \n #[test]\n pub fn test_to_str() {\n-    assert to_str(0 as T, 10u) == ~\"0\";\n-    assert to_str(1 as T, 10u) == ~\"1\";\n-    assert to_str(2 as T, 10u) == ~\"2\";\n-    assert to_str(11 as T, 10u) == ~\"11\";\n-    assert to_str(11 as T, 16u) == ~\"b\";\n-    assert to_str(255 as T, 16u) == ~\"ff\";\n-    assert to_str(0xff as T, 10u) == ~\"255\";\n+    assert to_str_radix(0 as T, 10u) == ~\"0\";\n+    assert to_str_radix(1 as T, 10u) == ~\"1\";\n+    assert to_str_radix(2 as T, 10u) == ~\"2\";\n+    assert to_str_radix(11 as T, 10u) == ~\"11\";\n+    assert to_str_radix(11 as T, 16u) == ~\"b\";\n+    assert to_str_radix(255 as T, 16u) == ~\"ff\";\n+    assert to_str_radix(0xff as T, 10u) == ~\"255\";\n }\n \n #[test]\n@@ -330,18 +296,72 @@ pub fn test_parse_bytes() {\n     assert parse_bytes(to_bytes(~\"_\"), 2u).is_none();\n }\n \n+#[test]\n+fn test_uint_to_str_overflow() {\n+    let mut u8_val: u8 = 255_u8;\n+    assert (u8::to_str(u8_val) == ~\"255\");\n+\n+    u8_val += 1 as u8;\n+    assert (u8::to_str(u8_val) == ~\"0\");\n+\n+    let mut u16_val: u16 = 65_535_u16;\n+    assert (u16::to_str(u16_val) == ~\"65535\");\n+\n+    u16_val += 1 as u16;\n+    assert (u16::to_str(u16_val) == ~\"0\");\n+\n+    let mut u32_val: u32 = 4_294_967_295_u32;\n+    assert (u32::to_str(u32_val) == ~\"4294967295\");\n+\n+    u32_val += 1 as u32;\n+    assert (u32::to_str(u32_val) == ~\"0\");\n+\n+    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+    assert (u64::to_str(u64_val) == ~\"18446744073709551615\");\n+\n+    u64_val += 1 as u64;\n+    assert (u64::to_str(u64_val) == ~\"0\");\n+}\n+\n+#[test]\n+fn test_uint_from_str_overflow() {\n+    let mut u8_val: u8 = 255_u8;\n+    assert (u8::from_str(~\"255\") == Some(u8_val));\n+\n+    u8_val += 1 as u8;\n+    assert (u8::from_str(~\"0\") == Some(u8_val));\n+\n+    let mut u16_val: u16 = 65_535_u16;\n+    assert (u16::from_str(~\"65535\") == Some(u16_val));\n+\n+    u16_val += 1 as u16;\n+    assert (u16::from_str(~\"0\") == Some(u16_val));\n+\n+    let mut u32_val: u32 = 4_294_967_295_u32;\n+    assert (u32::from_str(~\"4294967295\") == Some(u32_val));\n+\n+    u32_val += 1 as u32;\n+    assert (u32::from_str(~\"0\") == Some(u32_val));\n+\n+    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+    assert (u64::from_str(~\"18446744073709551615\") == Some(u64_val));\n+\n+    u64_val += 1 as u64;\n+    assert (u64::from_str(~\"0\") == Some(u64_val));\n+}\n+\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n pub fn to_str_radix1() {\n-    uint::to_str(100u, 1u);\n+    uint::to_str_radix(100u, 1u);\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-pub fn to_str_radix17() {\n-    uint::to_str(100u, 17u);\n+pub fn to_str_radix37() {\n+    uint::to_str_radix(100u, 37u);\n }\n \n use io;"}, {"sha": "13b09590b448009c9614661c4292c559584b85a8", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -24,26 +24,6 @@ use vec;\n \n pub trait ToStr { pub pure fn to_str() -> ~str; }\n \n-impl uint: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::uint::str(self) }\n-}\n-impl u8: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u8::str(self) }\n-}\n-impl u16: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u16::str(self) }\n-}\n-impl u32: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u32::str(self) }\n-}\n-impl u64: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u64::str(self) }\n-}\n impl float: ToStr {\n     #[inline(always)]\n     pure fn to_str() -> ~str { ::float::to_str(self, 4u) }"}, {"sha": "f02f187c629a0edec50ea830d2998dabd8c6dce3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -98,8 +98,8 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n             let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n             if abbrev_len < len {\n                 // I.e. it's actually an abbreviation.\n-                let s = ~\"#\" + uint::to_str(pos, 16u) + ~\":\" +\n-                    uint::to_str(len, 16u) + ~\"#\";\n+                let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n+                    uint::to_str_radix(len, 16u) + ~\"#\";\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }"}, {"sha": "57e05926173d1a0f57331c09f02494e515ad431b", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -88,7 +88,7 @@ pub impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n           Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n-                               uint::to_str(rk, 10u))\n+                               uint::to_str_radix(rk, 10u))\n         }\n     }\n }"}, {"sha": "64126ea918fc0d0966532c3ff74b2eeb8ab5da8b", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -456,7 +456,7 @@ pub impl BigUint {\n         pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n-                let s = uint::to_str(*n as uint, radix);\n+                let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             })), ['0'])\n         }"}, {"sha": "e1e2bb2697f8cdc73a180b98c118800be0c699a2", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -109,7 +109,7 @@ pub pure fn md4_str(msg: &[u8]) -> ~str {\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n             if byte <= 16u8 { result += ~\"0\"; }\n-            result += uint::to_str(byte as uint, 16u);\n+            result += uint::to_str_radix(byte as uint, 16u);\n             i += 1u32;\n         }\n     }"}, {"sha": "a5c740c343cfcb0600d8b9ccc0c82360d39bb9f3", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -253,7 +253,7 @@ pub fn sha1() -> Sha1 {\n             let rr = mk_result(&self);\n             let mut s = ~\"\";\n             for vec::each(rr) |b| {\n-                s += uint::to_str(*b as uint, 16u);\n+                s += uint::to_str_radix(*b as uint, 16u);\n             }\n             return s;\n         }"}, {"sha": "381183e736cf76e5f3287b0f49e1abca7f4f67ab", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -417,7 +417,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str_radix(num_str, base as u64).get();\n+        let parsed = u64::from_str_radix(num_str, base as uint).get();\n         match tp {\n           either::Left(t) => return token::LIT_INT(parsed as i64, t),\n           either::Right(t) => return token::LIT_UINT(parsed, t)\n@@ -471,7 +471,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str_radix(num_str, base as u64).get();\n+        let parsed = u64::from_str_radix(num_str, base as uint).get();\n \n         debug!(\"lexing %s as an unsuffixed integer literal\",\n                num_str);"}, {"sha": "5079766239b00b98900b7d3164c198542c2f32ff", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb194621044253fae32649511d76515a64009a53/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb194621044253fae32649511d76515a64009a53/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=eb194621044253fae32649511d76515a64009a53", "patch": "@@ -2006,24 +2006,24 @@ pub fn print_literal(s: ps, &&lit: @ast::lit) {\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {\n             word(s.s,\n-                 ~\"-\" + u64::to_str(-i as u64, 10u)\n+                 ~\"-\" + u64::to_str_radix(-i as u64, 10u)\n                  + ast_util::int_ty_to_str(t));\n         } else {\n             word(s.s,\n-                 u64::to_str(i as u64, 10u)\n+                 u64::to_str_radix(i as u64, 10u)\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n       ast::lit_uint(u, t) => {\n         word(s.s,\n-             u64::to_str(u, 10u)\n+             u64::to_str_radix(u, 10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n       ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n-            word(s.s, ~\"-\" + u64::to_str(-i as u64, 10u));\n+            word(s.s, ~\"-\" + u64::to_str_radix(-i as u64, 10u));\n         } else {\n-            word(s.s, u64::to_str(i as u64, 10u));\n+            word(s.s, u64::to_str_radix(i as u64, 10u));\n         }\n       }\n       ast::lit_float(f, t) => {"}]}