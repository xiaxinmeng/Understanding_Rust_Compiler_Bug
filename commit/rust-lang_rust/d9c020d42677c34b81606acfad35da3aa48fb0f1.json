{"sha": "d9c020d42677c34b81606acfad35da3aa48fb0f1", "node_id": "C_kwDOAAsO6NoAKGQ5YzAyMGQ0MjY3N2MzNGI4MTYwNmFjZmFkMzVkYTNhYTQ4ZmIwZjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T15:44:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T15:44:04Z"}, "message": "Auto merge of #14120 - Veykril:castable, r=Veykril\n\ninternal: Revert castable expectation and simplify\n\nUnfixes https://github.com/rust-lang/rust-analyzer/issues/11571, the PR for that introduced some regressions (tried fixing them but doing what rustc does there specifically does not help, probably because something else affects it as well there)", "tree": {"sha": "4795bbf5cc7f5552f4ce5a10f94c120ec592768a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4795bbf5cc7f5552f4ce5a10f94c120ec592768a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9c020d42677c34b81606acfad35da3aa48fb0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c020d42677c34b81606acfad35da3aa48fb0f1", "html_url": "https://github.com/rust-lang/rust/commit/d9c020d42677c34b81606acfad35da3aa48fb0f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9c020d42677c34b81606acfad35da3aa48fb0f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a28f53646de01a6ef0e128489ad6cd9281a2b909", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28f53646de01a6ef0e128489ad6cd9281a2b909", "html_url": "https://github.com/rust-lang/rust/commit/a28f53646de01a6ef0e128489ad6cd9281a2b909"}, {"sha": "7677f41f4128e4941fe48052364834f63ada4c02", "url": "https://api.github.com/repos/rust-lang/rust/commits/7677f41f4128e4941fe48052364834f63ada4c02", "html_url": "https://github.com/rust-lang/rust/commit/7677f41f4128e4941fe48052364834f63ada4c02"}], "stats": {"total": 144, "additions": 101, "deletions": 43}, "files": [{"sha": "767afdf9eb4e835b29e09cc0ce888d6a8f4953ba", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=d9c020d42677c34b81606acfad35da3aa48fb0f1", "patch": "@@ -219,6 +219,7 @@ struct InternedStandardTypes {\n     unknown: Ty,\n     bool_: Ty,\n     unit: Ty,\n+    never: Ty,\n }\n \n impl Default for InternedStandardTypes {\n@@ -227,6 +228,7 @@ impl Default for InternedStandardTypes {\n             unknown: TyKind::Error.intern(Interner),\n             bool_: TyKind::Scalar(Scalar::Bool).intern(Interner),\n             unit: TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner),\n+            never: TyKind::Never.intern(Interner),\n         }\n     }\n }\n@@ -1024,6 +1026,7 @@ impl<'a> InferenceContext<'a> {\n pub(crate) enum Expectation {\n     None,\n     HasType(Ty),\n+    #[allow(dead_code)]\n     Castable(Ty),\n     RValueLikeUnsized(Ty),\n }\n@@ -1102,6 +1105,10 @@ impl Expectation {\n         }\n     }\n \n+    fn coercion_target_type(&self, table: &mut unify::InferenceTable<'_>) -> Ty {\n+        self.only_has_type(table).unwrap_or_else(|| table.new_type_var())\n+    }\n+\n     /// Comment copied from rustc:\n     /// Disregard \"castable to\" expectations because they\n     /// can lead us astray. Consider for example `if cond"}, {"sha": "a6449d019ff6a07dcaf185d62f80c72f3dee3edc", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=d9c020d42677c34b81606acfad35da3aa48fb0f1", "patch": "@@ -51,7 +51,7 @@ impl InferenceContext<'_> {\n                 .map(to_chalk_trait_id)\n                 .collect();\n \n-        let self_ty = TyKind::Error.intern(Interner);\n+        let self_ty = self.result.standard_types.unknown.clone();\n         let bounds = dyn_ty.bounds.clone().substitute(Interner, &[self_ty.cast(Interner)]);\n         for bound in bounds.iter(Interner) {\n             // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`\n@@ -67,7 +67,7 @@ impl InferenceContext<'_> {\n                 let arg = projection.substitution.as_slice(Interner).get(1)?;\n                 if let Some(subst) = arg.ty(Interner)?.as_tuple() {\n                     let generic_args = subst.as_slice(Interner);\n-                    let mut sig_tys = Vec::new();\n+                    let mut sig_tys = Vec::with_capacity(generic_args.len() + 1);\n                     for arg in generic_args {\n                         sig_tys.push(arg.ty(Interner)?.clone());\n                     }"}, {"sha": "175fded8ccae10882528093fcb4ea25e6afdb200", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=d9c020d42677c34b81606acfad35da3aa48fb0f1", "patch": "@@ -87,16 +87,15 @@ impl<'a> InferenceContext<'a> {\n                 let expected = &expected.adjust_for_branches(&mut self.table);\n                 self.infer_expr(\n                     condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n-                let result_ty = self.table.new_type_var();\n                 let then_ty = self.infer_expr_inner(then_branch, expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n-                let mut coerce = CoerceMany::new(result_ty);\n+                let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n@@ -113,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n                 self.infer_pat(pat, &input_ty, BindingMode::default());\n-                TyKind::Scalar(Scalar::Bool).intern(Interner)\n+                self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -188,27 +187,29 @@ impl<'a> InferenceContext<'a> {\n                     .intern(Interner)\n             }\n             &Expr::Loop { body, label } => {\n+                // FIXME: should be:\n+                // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n                     self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n-                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                        this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n                 match breaks {\n                     Some(breaks) => {\n                         self.diverges = Diverges::Maybe;\n                         breaks\n                     }\n-                    None => TyKind::Never.intern(Interner),\n+                    None => self.result.standard_types.never.clone(),\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(\n                         condition,\n-                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                        &Expectation::HasType(this.result.standard_types.bool_.clone()),\n                     );\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -224,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -234,7 +235,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n-                let mut sig_tys = Vec::new();\n+                let mut sig_tys = Vec::with_capacity(arg_types.len() + 1);\n \n                 // collect explicitly written argument types\n                 for arg_type in arg_types.iter() {\n@@ -255,7 +256,8 @@ impl<'a> InferenceContext<'a> {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n                     substitution: FnSubst(\n-                        Substitution::from_iter(Interner, sig_tys.clone()).shifted_in(Interner),\n+                        Substitution::from_iter(Interner, sig_tys.iter().cloned())\n+                            .shifted_in(Interner),\n                     ),\n                 })\n                 .intern(Interner);\n@@ -317,16 +319,16 @@ impl<'a> InferenceContext<'a> {\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n-                let mut res = None;\n-                let mut derefed_callee = callee_ty.clone();\n-                // manual loop to be able to access `derefs.table`\n-                while let Some((callee_deref_ty, _)) = derefs.next() {\n-                    res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n-                    if res.is_some() {\n-                        derefed_callee = callee_deref_ty;\n-                        break;\n+                let (res, derefed_callee) = 'b: {\n+                    // manual loop to be able to access `derefs.table`\n+                    while let Some((callee_deref_ty, _)) = derefs.next() {\n+                        let res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n+                        if res.is_some() {\n+                            break 'b (res, callee_deref_ty);\n+                        }\n                     }\n-                }\n+                    (None, callee_ty.clone())\n+                };\n                 // if the function is unresolved, we use is_varargs=true to\n                 // suppress the arg count diagnostic here\n                 let is_varargs =\n@@ -382,12 +384,9 @@ impl<'a> InferenceContext<'a> {\n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n                 let result_ty = if arms.is_empty() {\n-                    TyKind::Never.intern(Interner)\n+                    self.result.standard_types.never.clone()\n                 } else {\n-                    match &expected {\n-                        Expectation::HasType(ty) => ty.clone(),\n-                        _ => self.table.new_type_var(),\n-                    }\n+                    expected.coercion_target_type(&mut self.table)\n                 };\n                 let mut coerce = CoerceMany::new(result_ty);\n \n@@ -400,7 +399,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                            &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                         );\n                     }\n \n@@ -425,7 +424,7 @@ impl<'a> InferenceContext<'a> {\n                         is_break: false,\n                     });\n                 };\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n@@ -439,7 +438,7 @@ impl<'a> InferenceContext<'a> {\n                         // avoiding the borrowck\n                         let mut coerce = mem::replace(\n                             &mut ctxt.coerce,\n-                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n                         );\n \n                         // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n@@ -457,7 +456,7 @@ impl<'a> InferenceContext<'a> {\n                         });\n                     }\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -466,7 +465,7 @@ impl<'a> InferenceContext<'a> {\n                     let unit = TyBuilder::unit();\n                     let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n@@ -479,14 +478,14 @@ impl<'a> InferenceContext<'a> {\n                     resume_ty\n                 } else {\n                     // FIXME: report error (yield expr in non-generator)\n-                    TyKind::Error.intern(Interner)\n+                    self.result.standard_types.unknown.clone()\n                 }\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n                     self.infer_expr_inner(expr, &Expectation::None);\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -611,8 +610,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n-                let _inner_ty =\n-                    self.infer_expr_inner(*expr, &Expectation::Castable(cast_ty.clone()));\n+                // FIXME: propagate the \"castable to\" expectation\n+                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -829,7 +828,7 @@ impl<'a> InferenceContext<'a> {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n                         self.infer_expr(\n                             repeat,\n-                            &Expectation::has_type(\n+                            &Expectation::HasType(\n                                 TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n                             ),\n                         );\n@@ -852,7 +851,7 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Array(coerce.complete(), len).intern(Interner)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n+                Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n                     TyKind::Ref(Mutability::Not, static_lifetime(), TyKind::Str.intern(Interner))\n                         .intern(Interner)\n@@ -1148,7 +1147,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(expr) = else_branch {\n                         self.infer_expr_coerce(\n                             *expr,\n-                            &Expectation::has_type(Ty::new(Interner, TyKind::Never)),\n+                            &Expectation::HasType(self.result.standard_types.never.clone()),\n                         );\n                     }\n "}, {"sha": "0a8527afbd0430bf0baa9c4431594cf9b9f20d07", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=d9c020d42677c34b81606acfad35da3aa48fb0f1", "patch": "@@ -112,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n+                    ParamKind::Type => self.result.standard_types.unknown.clone().cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })"}, {"sha": "2e5787b701cae3e29023c779dc02e33868fd3ef3", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c020d42677c34b81606acfad35da3aa48fb0f1/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=d9c020d42677c34b81606acfad35da3aa48fb0f1", "patch": "@@ -3200,6 +3200,8 @@ fn func() {\n     \"#,\n     );\n }\n+\n+// FIXME\n #[test]\n fn castable_to() {\n     check_infer(\n@@ -3224,10 +3226,60 @@ fn func() {\n             120..122 '{}': ()\n             138..184 '{     ...0]>; }': ()\n             148..149 'x': Box<[i32; 0]>\n-            152..160 'Box::new': fn new<[i32; 0]>([i32; 0]) -> Box<[i32; 0]>\n-            152..164 'Box::new([])': Box<[i32; 0]>\n+            152..160 'Box::new': fn new<[{unknown}; 0]>([{unknown}; 0]) -> Box<[{unknown}; 0]>\n+            152..164 'Box::new([])': Box<[{unknown}; 0]>\n             152..181 'Box::n...2; 0]>': Box<[i32; 0]>\n-            161..163 '[]': [i32; 0]\n+            161..163 '[]': [{unknown}; 0]\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn castable_to1() {\n+    check_infer(\n+        r#\"\n+struct Ark<T>(T);\n+impl<T> Ark<T> {\n+    fn foo(&self) -> *const T {\n+        &self.0\n+    }\n+}\n+fn f<T>(t: Ark<T>) {\n+    Ark::foo(&t) as *const ();\n+}\n+\"#,\n+        expect![[r#\"\n+            47..51 'self': &Ark<T>\n+            65..88 '{     ...     }': *const T\n+            75..82 '&self.0': &T\n+            76..80 'self': &Ark<T>\n+            76..82 'self.0': T\n+            99..100 't': Ark<T>\n+            110..144 '{     ... (); }': ()\n+            116..124 'Ark::foo': fn foo<T>(&Ark<T>) -> *const T\n+            116..128 'Ark::foo(&t)': *const T\n+            116..141 'Ark::f...nst ()': *const ()\n+            125..127 '&t': &Ark<T>\n+            126..127 't': Ark<T>\n+        \"#]],\n+    );\n+}\n+\n+// FIXME\n+#[test]\n+fn castable_to2() {\n+    check_infer(\n+        r#\"\n+fn func() {\n+    let x = &0u32 as *const _;\n+}\n+\"#,\n+        expect![[r#\"\n+            10..44 '{     ...t _; }': ()\n+            20..21 'x': *const {unknown}\n+            24..29 '&0u32': &u32\n+            24..41 '&0u32 ...onst _': *const {unknown}\n+            25..29 '0u32': u32\n         \"#]],\n     );\n }"}]}