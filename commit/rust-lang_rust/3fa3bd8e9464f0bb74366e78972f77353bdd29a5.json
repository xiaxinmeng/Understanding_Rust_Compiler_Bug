{"sha": "3fa3bd8e9464f0bb74366e78972f77353bdd29a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYTNiZDhlOTQ2NGYwYmI3NDM2NmU3ODk3MmY3NzM1M2JkZDI5YTU=", "commit": {"author": {"name": "phil", "email": "uniphil@gmail.com", "date": "2019-02-18T05:53:30Z"}, "committer": {"name": "phil", "email": "uniphil@gmail.com", "date": "2019-02-18T16:39:40Z"}, "message": "Don't fail for raw string ending in \\n\n\nPass tests for #3778, {print,write}_with_newline false positive\n\nThis change guards the lint from checking newlines with a sort of complicated\ncheck to see if it's a raw string. Raw strings shouldn't be newline-checked,\nsince r\"\\n\" is literally \\-n, not a newline. I think it's ok not to check for\n_literal_ newlines at the end of raw strings, but maybe that's debatable.\n\nI... don't think this code is that great. I wanted to write the check after\n`check_tts`, but that was too late -- raw string type info is lost (or I\ncouldn't find it). Putting it inside `check_tts` feels heavy-duty and the check\nitself feels like a brittle reach possibly into places it shouldn't.\n\nMaybe someone can fix this up :)", "tree": {"sha": "077e6e0de60ff5e7647c30ad2ac8b0be89d4eafc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/077e6e0de60ff5e7647c30ad2ac8b0be89d4eafc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fa3bd8e9464f0bb74366e78972f77353bdd29a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa3bd8e9464f0bb74366e78972f77353bdd29a5", "html_url": "https://github.com/rust-lang/rust/commit/3fa3bd8e9464f0bb74366e78972f77353bdd29a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fa3bd8e9464f0bb74366e78972f77353bdd29a5/comments", "author": {"login": "uniphil", "id": 205128, "node_id": "MDQ6VXNlcjIwNTEyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/205128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uniphil", "html_url": "https://github.com/uniphil", "followers_url": "https://api.github.com/users/uniphil/followers", "following_url": "https://api.github.com/users/uniphil/following{/other_user}", "gists_url": "https://api.github.com/users/uniphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/uniphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uniphil/subscriptions", "organizations_url": "https://api.github.com/users/uniphil/orgs", "repos_url": "https://api.github.com/users/uniphil/repos", "events_url": "https://api.github.com/users/uniphil/events{/privacy}", "received_events_url": "https://api.github.com/users/uniphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "uniphil", "id": 205128, "node_id": "MDQ6VXNlcjIwNTEyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/205128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uniphil", "html_url": "https://github.com/uniphil", "followers_url": "https://api.github.com/users/uniphil/followers", "following_url": "https://api.github.com/users/uniphil/following{/other_user}", "gists_url": "https://api.github.com/users/uniphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/uniphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uniphil/subscriptions", "organizations_url": "https://api.github.com/users/uniphil/orgs", "repos_url": "https://api.github.com/users/uniphil/repos", "events_url": "https://api.github.com/users/uniphil/events{/privacy}", "received_events_url": "https://api.github.com/users/uniphil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf5d4a1b45dbffad33c5236bfb9620bd9e2014b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5d4a1b45dbffad33c5236bfb9620bd9e2014b3", "html_url": "https://github.com/rust-lang/rust/commit/cf5d4a1b45dbffad33c5236bfb9620bd9e2014b3"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "4f771b2af552f1479e1eaa778291f31f23b19111", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3fa3bd8e9464f0bb74366e78972f77353bdd29a5/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa3bd8e9464f0bb74366e78972f77353bdd29a5/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=3fa3bd8e9464f0bb74366e78972f77353bdd29a5", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast::*;\n use syntax::parse::{parser, token};\n-use syntax::tokenstream::TokenStream;\n+use syntax::tokenstream::{TokenStream, TokenTree};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -200,8 +200,8 @@ impl EarlyLintPass for Pass {\n             }\n         } else if mac.node.path == \"print\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n-                if check_newlines(&fmtstr) {\n+            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, false) {\n+                if !is_raw && check_newlines(&fmtstr) {\n                     span_lint(\n                         cx,\n                         PRINT_WITH_NEWLINE,\n@@ -212,8 +212,8 @@ impl EarlyLintPass for Pass {\n                 }\n             }\n         } else if mac.node.path == \"write\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true).0 {\n-                if check_newlines(&fmtstr) {\n+            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, true) {\n+                if !is_raw && check_newlines(&fmtstr) {\n                     span_lint(\n                         cx,\n                         WRITE_WITH_NEWLINE,\n@@ -252,8 +252,9 @@ impl EarlyLintPass for Pass {\n }\n \n /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n-/// options. The first part of the tuple is `format_str` of the macros. The second part of the tuple\n-/// is in the `write[ln]!` case the expression the `format_str` should be written to.\n+/// options and a bool. The first part of the tuple is `format_str` of the macros. The second part\n+/// of the tuple is in the `write[ln]!` case the expression the `format_str` should be written to.\n+/// The final part is a boolean flag indicating if the string is a raw string.\n ///\n /// Example:\n ///\n@@ -263,34 +264,49 @@ impl EarlyLintPass for Pass {\n /// ```\n /// will return\n /// ```rust,ignore\n-/// (Some(\"string to write: {}\"), Some(buf))\n+/// (Some(\"string to write: {}\"), Some(buf), false)\n /// ```\n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<String>, Option<Expr>, bool) {\n     use fmt_macros::*;\n     let tts = tts.clone();\n+    let mut is_raw = false;\n+    if let TokenStream(Some(tokens)) = &tts {\n+        for token in tokens.iter() {\n+            if let (TokenTree::Token(_, token::Token::Literal(lit, _)), _) = token {\n+                match lit {\n+                    token::Lit::Str_(_) => break,\n+                    token::Lit::StrRaw(_, _) => {\n+                        is_raw = true;\n+                        break;\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n     let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false);\n     let mut expr: Option<Expr> = None;\n     if is_write {\n         expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n             Ok(p) => Some(p.into_inner()),\n-            Err(_) => return (None, None),\n+            Err(_) => return (None, None, is_raw),\n         };\n         // might be `writeln!(foo)`\n         if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-            return (None, expr);\n+            return (None, expr, is_raw);\n         }\n     }\n \n     let fmtstr = match parser.parse_str().map_err(|mut err| err.cancel()) {\n         Ok(token) => token.0.to_string(),\n-        Err(_) => return (None, expr),\n+        Err(_) => return (None, expr, is_raw),\n     };\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n     while let Some(piece) = fmt_parser.next() {\n         if !fmt_parser.errors.is_empty() {\n-            return (None, expr);\n+            return (None, expr, is_raw);\n         }\n         if let Piece::NextArgument(arg) = piece {\n             if arg.format.ty == \"?\" {\n@@ -312,11 +328,11 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n             ty: \"\",\n         };\n         if !parser.eat(&token::Comma) {\n-            return (Some(fmtstr), expr);\n+            return (Some(fmtstr), expr, is_raw);\n         }\n         let token_expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n             Ok(expr) => expr,\n-            Err(_) => return (Some(fmtstr), None),\n+            Err(_) => return (Some(fmtstr), None, is_raw),\n         };\n         match &token_expr.node {\n             ExprKind::Lit(_) => {"}]}