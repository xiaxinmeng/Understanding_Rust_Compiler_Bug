{"sha": "5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZGExMzZmNjIyZjljYmZlNzA2ZTc3NWZjYWEzYTAxNjlmZDRhZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T01:19:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T01:19:17Z"}, "message": "Auto merge of #55305 - nikomatsakis:universes-refactor-3, r=scalexm\n\nuniverses refactor 3\n\nSome more refactorings from my universe branch. These are getting a bit more \"invasive\" -- they start to plumb the universe information through the canonicalization process. As of yet though I don't **believe** this branch changes our behavior in any notable way, though I'm marking the branch as `WIP` to give myself a chance to verify this.\n\nr? @scalexm", "tree": {"sha": "745bb2d20c45b5d6ed67fdae9194b140caa2fb7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/745bb2d20c45b5d6ed67fdae9194b140caa2fb7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "html_url": "https://github.com/rust-lang/rust/commit/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d06210f88f3c8f2b04402838a23f5d8970c803ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d06210f88f3c8f2b04402838a23f5d8970c803ca", "html_url": "https://github.com/rust-lang/rust/commit/d06210f88f3c8f2b04402838a23f5d8970c803ca"}, {"sha": "c244fd79f22f7a78016f20fa252d93bae474f4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c244fd79f22f7a78016f20fa252d93bae474f4bd", "html_url": "https://github.com/rust-lang/rust/commit/c244fd79f22f7a78016f20fa252d93bae474f4bd"}], "stats": {"total": 1224, "additions": 667, "deletions": 557}, "files": [{"sha": "0c93b86ee4d11771778483c29142b54e369ac371", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -1229,7 +1229,7 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n \n impl_stable_hash_for!(\n     impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n-        variables, value\n+        max_universe, variables, value\n     }\n );\n \n@@ -1245,7 +1245,8 @@ impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n \n impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n     Ty(k),\n-    Region\n+    Region(ui),\n+    PlaceholderRegion(placeholder),\n });\n \n impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {"}, {"sha": "cc6e4df07103307c72730fb6865b1ad7ffffc944", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 107, "deletions": 9, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -107,6 +107,20 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         )\n     }\n \n+    pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'gcx, V>\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        let mut query_state = OriginalQueryValues::default();\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            &CanonicalizeUserTypeAnnotation,\n+            &mut query_state,\n+        )\n+    }\n+\n     /// A hacky variant of `canonicalize_query` that does not\n     /// canonicalize `'static`.  Unfortunately, the existing leak\n     /// check treaks `'static` differently in some cases (see also\n@@ -162,11 +176,26 @@ struct CanonicalizeQueryResponse;\n impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n     fn canonicalize_free_region(\n         &self,\n-        _canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n             ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n+                CanonicalVarInfo {\n+                    kind: CanonicalVarKind::PlaceholderRegion(*placeholder),\n+                },\n+                r,\n+            ),\n+            ty::ReVar(vid) => {\n+                let universe = canonicalizer.region_var_universe(*vid);\n+                canonicalizer.canonical_var_for_region(\n+                    CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region(universe),\n+                    },\n+                    r,\n+                )\n+            }\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -182,6 +211,29 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n     }\n }\n \n+struct CanonicalizeUserTypeAnnotation;\n+\n+impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n+    fn canonicalize_free_region(\n+        &self,\n+        canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        match r {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReEmpty | ty::ReStatic => r,\n+            ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n+            _ => {\n+                // We only expect region names that the user can type.\n+                bug!(\"unexpected region in query response: `{:?}`\", r)\n+            }\n+        }\n+    }\n+\n+    fn any(&self) -> bool {\n+        false\n+    }\n+}\n+\n struct CanonicalizeAllFreeRegions;\n \n impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n@@ -190,7 +242,7 @@ impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n         canonicalizer: &mut Canonicalizer<'_, '_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        canonicalizer.canonical_var_for_region(r)\n+        canonicalizer.canonical_var_for_region_in_root_universe(r)\n     }\n \n     fn any(&self) -> bool {\n@@ -209,7 +261,7 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n         if let ty::ReStatic = r {\n             r\n         } else {\n-            canonicalizer.canonical_var_for_region(r)\n+            canonicalizer.canonical_var_for_region_in_root_universe(r)\n         }\n     }\n \n@@ -252,7 +304,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n                      opportunistically resolved to {:?}\",\n                     vid, r\n                 );\n-                self.canonical_var_for_region(r)\n+                self.canonicalize_region_mode\n+                    .canonicalize_free_region(self, r)\n             }\n \n             ty::ReStatic\n@@ -261,7 +314,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             | ty::ReScope(_)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty\n-            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n+            | ty::ReErased => self.canonicalize_region_mode\n+                .canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n                 bug!(\"canonical region encountered during canonicalization\")\n@@ -353,6 +407,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         if !value.has_type_flags(needs_canonical_flags) {\n             let out_value = gcx.lift(value).unwrap();\n             let canon_value = Canonical {\n+                max_universe: ty::UniverseIndex::ROOT,\n                 variables: List::empty(),\n                 value: out_value,\n             };\n@@ -383,7 +438,14 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n \n         let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n \n+        let max_universe = canonical_variables\n+            .iter()\n+            .map(|cvar| cvar.universe())\n+            .max()\n+            .unwrap_or(ty::UniverseIndex::ROOT);\n+\n         Canonical {\n+            max_universe,\n             variables: canonical_variables,\n             value: out_value,\n         }\n@@ -450,10 +512,46 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn canonical_var_for_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let info = CanonicalVarInfo {\n-            kind: CanonicalVarKind::Region,\n-        };\n+    /// Shorthand helper that creates a canonical region variable for\n+    /// `r` (always in the root universe). The reason that we always\n+    /// put these variables into the root universe is because this\n+    /// method is used during **query construction:** in that case, we\n+    /// are taking all the regions and just putting them into the most\n+    /// generic context we can. This may generate solutions that don't\n+    /// fit (e.g., that equate some region variable with a placeholder\n+    /// it can't name) on the caller side, but that's ok, the caller\n+    /// can figure that out. In the meantime, it maximizes our\n+    /// caching.\n+    ///\n+    /// (This works because unification never fails -- and hence trait\n+    /// selection is never affected -- due to a universe mismatch.)\n+    fn canonical_var_for_region_in_root_universe(\n+        &mut self,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        self.canonical_var_for_region(\n+            CanonicalVarInfo {\n+                kind: CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+            },\n+            r,\n+        )\n+    }\n+\n+    /// Returns the universe in which `vid` is defined.\n+    fn region_var_universe(&self, vid: ty::RegionVid) -> ty::UniverseIndex {\n+        self.infcx\n+            .unwrap()\n+            .borrow_region_constraints()\n+            .var_universe(vid)\n+    }\n+\n+    /// Create a canonical variable (with the given `info`)\n+    /// representing the region `r`; return a region referencing it.\n+    fn canonical_var_for_region(\n+        &mut self,\n+        info: CanonicalVarInfo,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n         let b = self.canonical_var(info, r.into());\n         debug_assert_eq!(ty::INNERMOST, b.level);\n         self.tcx().mk_region(ty::ReCanonical(b.var))"}, {"sha": "f2b7c6e0d0d986760762fae0e4f42cf39f654ee6", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -33,14 +33,14 @@\n \n use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use smallvec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n+use smallvec::SmallVec;\n use std::ops::Index;\n use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n-use ty::{self, BoundTyIndex, Lift, Region, List, TyCtxt};\n+use ty::{self, BoundTyIndex, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -53,6 +53,7 @@ mod substitute;\n /// numbered starting from 0 in order of first appearance.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct Canonical<'gcx, V> {\n+    pub max_universe: ty::UniverseIndex,\n     pub variables: CanonicalVarInfos<'gcx>,\n     pub value: V,\n }\n@@ -79,13 +80,31 @@ pub struct CanonicalVarValues<'tcx> {\n /// various parts of it with canonical variables. This struct stores\n /// those replaced bits to remember for when we process the query\n /// result.\n-#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct OriginalQueryValues<'tcx> {\n+    /// Map from the universes that appear in the query to the\n+    /// universes in the caller context. For the time being, we only\n+    /// ever put ROOT values into the query, so this map is very\n+    /// simple.\n+    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n+\n     /// This is equivalent to `CanonicalVarValues`, but using a\n     /// `SmallVec` yields a significant performance win.\n     pub var_values: SmallVec<[Kind<'tcx>; 8]>,\n }\n \n+impl Default for OriginalQueryValues<'tcx> {\n+    fn default() -> Self {\n+        let mut universe_map = SmallVec::default();\n+        universe_map.push(ty::UniverseIndex::ROOT);\n+\n+        Self {\n+            universe_map,\n+            var_values: SmallVec::default(),\n+        }\n+    }\n+}\n+\n /// Information about a canonical variable that is included with the\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n@@ -95,6 +114,20 @@ pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n \n+impl CanonicalVarInfo {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n+        self.kind.universe()\n+    }\n+\n+    pub fn is_existential(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_) => true,\n+            CanonicalVarKind::Region(_) => true,\n+            CanonicalVarKind::PlaceholderRegion(..) => false,\n+        }\n+    }\n+}\n+\n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n@@ -104,7 +137,27 @@ pub enum CanonicalVarKind {\n     Ty(CanonicalTyVarKind),\n \n     /// Region variable `'?R`.\n-    Region,\n+    Region(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any region\". Created when you\n+    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n+    /// bound region `'a`.\n+    PlaceholderRegion(ty::Placeholder),\n+}\n+\n+impl CanonicalVarKind {\n+    pub fn universe(self) -> ty::UniverseIndex {\n+        match self {\n+            // At present, we don't support higher-ranked\n+            // quantification over types, so all type variables are in\n+            // the root universe.\n+            CanonicalVarKind::Ty(_) => ty::UniverseIndex::ROOT,\n+\n+            // Region variables can be created in sub-universes.\n+            CanonicalVarKind::Region(ui) => ui,\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n+        }\n+    }\n }\n \n /// Rust actually has more than one category of type variables;\n@@ -220,8 +273,16 @@ impl<'gcx, V> Canonical<'gcx, V> {\n     /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n     /// ```\n     pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'gcx, W> {\n-        let Canonical { variables, value } = self;\n-        Canonical { variables, value: map_op(value) }\n+        let Canonical {\n+            max_universe,\n+            variables,\n+            value,\n+        } = self;\n+        Canonical {\n+            max_universe,\n+            variables,\n+            value: map_op(value),\n+        }\n     }\n }\n \n@@ -249,35 +310,50 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        // For each universe that is referred to in the incoming\n+        // query, create a universe in our local inference context. In\n+        // practice, as of this writing, all queries have no universes\n+        // in them, so this code has no effect, but it is looking\n+        // forward to the day when we *do* want to carry universes\n+        // through into queries.\n+        let universes: IndexVec<ty::UniverseIndex, _> = std::iter::once(ty::UniverseIndex::ROOT)\n+            .chain((0..canonical.max_universe.as_u32()).map(|_| self.create_next_universe()))\n+            .collect();\n+\n         let canonical_inference_vars =\n-            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+            self.instantiate_canonical_vars(span, canonical.variables, |ui| universes[ui]);\n         let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n         (result, canonical_inference_vars)\n     }\n \n     /// Given the \"infos\" about the canonical variables from some\n-    /// canonical, creates fresh inference variables with the same\n-    /// characteristics. You can then use `substitute` to instantiate\n-    /// the canonical variable with these inference variables.\n-    fn fresh_inference_vars_for_canonical_vars(\n+    /// canonical, creates fresh variables with the same\n+    /// characteristics (see `instantiate_canonical_var` for\n+    /// details). You can then use `substitute` to instantiate the\n+    /// canonical variable with these inference variables.\n+    fn instantiate_canonical_vars(\n         &self,\n         span: Span,\n         variables: &List<CanonicalVarInfo>,\n+        universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<BoundTyIndex, Kind<'tcx>> = variables\n             .iter()\n-            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n             .collect();\n \n         CanonicalVarValues { var_values }\n     }\n \n     /// Given the \"info\" about a canonical variable, creates a fresh\n-    /// inference variable with the same characteristics.\n-    fn fresh_inference_var_for_canonical_var(\n+    /// variable for it. If this is an existentially quantified\n+    /// variable, then you'll get a new inference variable; if it is a\n+    /// universally quantified variable, you get a placeholder.\n+    fn instantiate_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo,\n+        universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> Kind<'tcx> {\n         match cv_info.kind {\n             CanonicalVarKind::Ty(ty_kind) => {\n@@ -293,9 +369,21 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 ty.into()\n             }\n \n-            CanonicalVarKind::Region => self\n-                .next_region_var(RegionVariableOrigin::MiscVariable(span))\n-                .into(),\n+            CanonicalVarKind::Region(ui) => self.next_region_var_in_universe(\n+                RegionVariableOrigin::MiscVariable(span),\n+                universe_map(ui),\n+            ).into(),\n+\n+            CanonicalVarKind::PlaceholderRegion(ty::Placeholder { universe, name }) => {\n+                let universe_mapped = universe_map(universe);\n+                let placeholder_mapped = ty::Placeholder {\n+                    universe: universe_mapped,\n+                    name,\n+                };\n+                self.tcx\n+                    .mk_region(ty::RePlaceholder(placeholder_mapped))\n+                    .into()\n+            }\n         }\n     }\n }\n@@ -314,6 +402,7 @@ CloneTypeFoldableImpls! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n+        max_universe,\n         variables,\n         value,\n     } where C: TypeFoldable<'tcx>\n@@ -322,7 +411,7 @@ BraceStructTypeFoldableImpl! {\n BraceStructLiftImpl! {\n     impl<'a, 'tcx, T> Lift<'tcx> for Canonical<'a, T> {\n         type Lifted = Canonical<'tcx, T::Lifted>;\n-        variables, value\n+        max_universe, variables, value\n     } where T: Lift<'tcx>\n }\n "}, {"sha": "b3ce5eb7e56c26dee4fac39f0f845186b99824e2", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -394,6 +394,21 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             original_values, query_response,\n         );\n \n+        // For each new universe created in the query result that did\n+        // not appear in the original query, create a local\n+        // superuniverse.\n+        let mut universe_map = original_values.universe_map.clone();\n+        let num_universes_in_query = original_values.universe_map.len();\n+        let num_universes_in_response = query_response.max_universe.as_usize() + 1;\n+        for _ in num_universes_in_query..num_universes_in_response {\n+            universe_map.push(self.create_next_universe());\n+        }\n+        assert!(universe_map.len() >= 1); // always have the root universe\n+        assert_eq!(\n+            universe_map[ty::UniverseIndex::ROOT.as_usize()],\n+            ty::UniverseIndex::ROOT\n+        );\n+\n         // Every canonical query result includes values for each of\n         // the inputs to the query. Therefore, we begin by unifying\n         // these values with the original inputs that were\n@@ -440,9 +455,20 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .variables\n                 .iter()\n                 .enumerate()\n-                .map(|(index, info)| opt_values[BoundTyIndex::new(index)].unwrap_or_else(||\n-                    self.fresh_inference_var_for_canonical_var(cause.span, *info)\n-                ))\n+                .map(|(index, info)| {\n+                    if info.is_existential() {\n+                        match opt_values[BoundTyIndex::new(index)] {\n+                            Some(k) => k,\n+                            None => self.instantiate_canonical_var(cause.span, *info, |u| {\n+                                universe_map[u.as_usize()]\n+                            }),\n+                        }\n+                    } else {\n+                        self.instantiate_canonical_var(cause.span, *info, |u| {\n+                            universe_map[u.as_usize()]\n+                        })\n+                    }\n+                })\n                 .collect(),\n         };\n "}, {"sha": "8968c5949b617b8ccb8c525e547d78e6826c5b7c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -15,7 +15,6 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n@@ -76,31 +75,12 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         where T: Relate<'tcx>\n     {\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n-        let was_error = self.infcx().probe(|_snapshot| {\n-            // Subtle: use a fresh combine-fields here because we recover\n-            // from Err. Doing otherwise could propagate obligations out\n-            // through our `self.obligations` field.\n-            self.infcx()\n-                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n-                .higher_ranked_glb(a, b, self.a_is_expected)\n-                .is_err()\n-        });\n-        debug!(\"binders: was_error={:?}\", was_error);\n \n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n-            Ok(_) => Ok(a.clone()),\n-            Err(err) => {\n-                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n-                if !was_error {\n-                    Err(TypeError::OldStyleLUB(Box::new(err)))\n-                } else {\n-                    Err(err)\n-                }\n-            }\n-        }\n+        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        Ok(a.clone())\n     }\n }\n "}, {"sha": "3e08a4e021aedb5660041fbed31271699adc7781", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -22,7 +22,6 @@ use super::region_constraints::{TaintDirections};\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use std::collections::BTreeMap;\n use syntax_pos::Span;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -202,261 +201,6 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             Ok(HrMatchResult { value: a_value })\n         });\n     }\n-\n-    pub fn higher_ranked_lub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace.cause.span;\n-            let (a_with_fresh, a_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    span, HigherRankedType, a);\n-            let (b_with_fresh, _) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    span, HigherRankedType, b);\n-\n-            // Collect constraints.\n-            let result0 =\n-                self.lub(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n-            let result0 =\n-                self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"lub result0 = {:?}\", result0);\n-\n-            // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.cause.span;\n-            let result1 =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &result0,\n-                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n-                                                    &new_vars, &a_map, r));\n-\n-            debug!(\"lub({:?},{:?}) = {:?}\",\n-                   a,\n-                   b,\n-                   result1);\n-\n-            Ok(ty::Binder::bind(result1))\n-        });\n-\n-        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             span: Span,\n-                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                                             debruijn: ty::DebruijnIndex,\n-                                             new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                             r0: ty::Region<'tcx>)\n-                                             -> ty::Region<'tcx> {\n-            // Regions that pre-dated the LUB computation stay as they are.\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_late_bound());\n-                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n-                return r0;\n-            }\n-\n-            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n-\n-            // Variables created during LUB computation which are\n-            // *related* to regions that pre-date the LUB computation\n-            // stay as they are.\n-            if !tainted.iter().all(|&r| is_var_in_set(new_vars, r)) {\n-                debug!(\"generalize_region(r0={:?}): \\\n-                        non-new-variables found in {:?}\",\n-                       r0, tainted);\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            }\n-\n-            // Otherwise, the variable must be associated with at\n-            // least one of the variables representing bound regions\n-            // in both A and B.  Replace the variable with the \"first\"\n-            // bound region from A that we find it to be associated\n-            // with.\n-            for (a_br, a_r) in a_map {\n-                if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={:?}): \\\n-                            replacing with {:?}, tainted={:?}\",\n-                           r0, *a_br, tainted);\n-                    return infcx.tcx.mk_region(ty::ReLateBound(debruijn, *a_br));\n-                }\n-            }\n-\n-            span_bug!(\n-                span,\n-                \"region {:?} is not associated with any bound region from A!\",\n-                r0)\n-        }\n-    }\n-\n-    pub fn higher_ranked_glb<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        debug!(\"higher_ranked_glb({:?}, {:?})\",\n-               a, b);\n-\n-        // Make a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // Instantiate each bound region with a fresh region variable.\n-            let (a_with_fresh, a_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.cause.span, HigherRankedType, a);\n-            let (b_with_fresh, b_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.cause.span, HigherRankedType, b);\n-            let a_vars = var_ids(self, &a_map);\n-            let b_vars = var_ids(self, &b_map);\n-\n-            // Collect constraints.\n-            let result0 =\n-                self.glb(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n-            let result0 =\n-                self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"glb result0 = {:?}\", result0);\n-\n-            // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.cause.span;\n-            let result1 =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &result0,\n-                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n-                                                    &new_vars,\n-                                                    &a_map, &a_vars, &b_vars,\n-                                                    r));\n-\n-            debug!(\"glb({:?},{:?}) = {:?}\",\n-                   a,\n-                   b,\n-                   result1);\n-\n-            Ok(ty::Binder::bind(result1))\n-        });\n-\n-        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             span: Span,\n-                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                                             debruijn: ty::DebruijnIndex,\n-                                             new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                             a_vars: &[ty::RegionVid],\n-                                             b_vars: &[ty::RegionVid],\n-                                             r0: ty::Region<'tcx>)\n-                                             -> ty::Region<'tcx> {\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            }\n-\n-            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n-\n-            let mut a_r = None;\n-            let mut b_r = None;\n-            let mut only_new_vars = true;\n-            for r in &tainted {\n-                if is_var_in_set(a_vars, *r) {\n-                    if a_r.is_some() {\n-                        return fresh_bound_variable(infcx, debruijn);\n-                    } else {\n-                        a_r = Some(*r);\n-                    }\n-                } else if is_var_in_set(b_vars, *r) {\n-                    if b_r.is_some() {\n-                        return fresh_bound_variable(infcx, debruijn);\n-                    } else {\n-                        b_r = Some(*r);\n-                    }\n-                } else if !is_var_in_set(new_vars, *r) {\n-                    only_new_vars = false;\n-                }\n-            }\n-\n-            // NB---I do not believe this algorithm computes\n-            // (necessarily) the GLB.  As written it can\n-            // spuriously fail. In particular, if there is a case\n-            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n-            // free, it will return fn(&c) where c = GLB(a,b).  If\n-            // however this GLB is not defined, then the result is\n-            // an error, even though something like\n-            // \"fn<X>(fn(&X))\" where X is bound would be a\n-            // subtype of both of those.\n-            //\n-            // The problem is that if we were to return a bound\n-            // variable, we'd be computing a lower-bound, but not\n-            // necessarily the *greatest* lower-bound.\n-            //\n-            // Unfortunately, this problem is non-trivial to solve,\n-            // because we do not know at the time of computing the GLB\n-            // whether a GLB(a,b) exists or not, because we haven't\n-            // run region inference (or indeed, even fully computed\n-            // the region hierarchy!). The current algorithm seems to\n-            // works ok in practice.\n-\n-            if a_r.is_some() && b_r.is_some() && only_new_vars {\n-                // Related to exactly one bound variable from each fn:\n-                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n-            } else if a_r.is_none() && b_r.is_none() {\n-                // Not related to bound variables from either fn:\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            } else {\n-                // Other:\n-                return fresh_bound_variable(infcx, debruijn);\n-            }\n-        }\n-\n-        fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                      span: Span,\n-                                      a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                      r: ty::Region<'tcx>) -> ty::Region<'tcx>\n-        {\n-            for (a_br, a_r) in a_map {\n-                if *a_r == r {\n-                    return infcx.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, *a_br));\n-                }\n-            }\n-            span_bug!(\n-                span,\n-                \"could not find original bound region for {:?}\",\n-                r);\n-        }\n-\n-        fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                debruijn: ty::DebruijnIndex)\n-                                                -> ty::Region<'tcx> {\n-            infcx.borrow_region_constraints().new_bound(infcx.tcx, debruijn)\n-        }\n-    }\n-}\n-\n-fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-                           -> Vec<ty::RegionVid> {\n-    map.iter()\n-       .map(|(_, &r)| match *r {\n-           ty::ReVar(r) => { r }\n-           _ => {\n-               span_bug!(\n-                   fields.trace.cause.span,\n-                   \"found non-region-vid: {:?}\",\n-                   r);\n-           }\n-       })\n-       .collect()\n-}\n-\n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region<'_>) -> bool {\n-    match *r {\n-        ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n-        _ => false\n-    }\n }\n \n fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "8875b4169dd6e796028916f558fc9ae009e3858d", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -15,7 +15,6 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n@@ -76,31 +75,12 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         where T: Relate<'tcx>\n     {\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n-        let was_error = self.infcx().probe(|_snapshot| {\n-            // Subtle: use a fresh combine-fields here because we recover\n-            // from Err. Doing otherwise could propagate obligations out\n-            // through our `self.obligations` field.\n-            self.infcx()\n-                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n-                .higher_ranked_lub(a, b, self.a_is_expected)\n-                .is_err()\n-        });\n-        debug!(\"binders: was_error={:?}\", was_error);\n \n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n-            Ok(_) => Ok(a.clone()),\n-            Err(err) => {\n-                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n-                if !was_error {\n-                    Err(TypeError::OldStyleLUB(Box::new(err)))\n-                } else {\n-                    Err(err)\n-                }\n-            }\n-        }\n+        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        Ok(a.clone())\n     }\n }\n "}, {"sha": "d5233851db8c6dcb2bdec7e3e74f9e6448687e2d", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -38,19 +38,13 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n-        // FIXME the query should take a `ImpliedOutlivesBounds`\n-        let Canonical {\n-            variables,\n-            value:\n-                ParamEnvAnd {\n-                    param_env,\n-                    value: ImpliedOutlivesBounds { ty },\n-                },\n-        } = canonicalized;\n-        let canonicalized = Canonical {\n-            variables,\n-            value: param_env.and(ty),\n-        };\n+        // FIXME this `unchecked_map` is only necessary because the\n+        // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n+        // take a `ImpliedOutlivesBounds` instead\n+        let canonicalized = canonicalized.unchecked_map(|ParamEnvAnd { param_env, value }| {\n+            let ImpliedOutlivesBounds { ty } = value;\n+            param_env.and(ty)\n+        });\n \n         tcx.implied_outlives_bounds(canonicalized)\n     }"}, {"sha": "cd7c6d76eab5782ce49dc647b3c48c5c5dae7c5e", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -59,18 +59,10 @@ where\n         // FIXME convert to the type expected by the `dropck_outlives`\n         // query. This should eventually be fixed by changing the\n         // *underlying query*.\n-        let Canonical {\n-            variables,\n-            value:\n-                ParamEnvAnd {\n-                    param_env,\n-                    value: DropckOutlives { dropped_ty },\n-                },\n-        } = canonicalized;\n-        let canonicalized = Canonical {\n-            variables,\n-            value: param_env.and(dropped_ty),\n-        };\n+        let canonicalized = canonicalized.unchecked_map(|ParamEnvAnd { param_env, value }| {\n+            let DropckOutlives { dropped_ty } = value;\n+            param_env.and(dropped_ty)\n+        });\n \n         tcx.dropck_outlives(canonicalized)\n     }"}, {"sha": "e2a5fdd36221776289d92ac235dfd4f171003404", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -1368,7 +1368,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // Winnow, but record the exact outcome of evaluation, which\n         // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates.into_iter()\n+        let mut candidates = candidates\n+            .into_iter()\n             .map(|c| match self.evaluate_candidate(stack, &c) {\n                 Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n@@ -1377,8 +1378,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(_) => Ok(None),\n                 Err(OverflowError) => Err(Overflow),\n             })\n-           .flat_map(Result::transpose)\n-           .collect::<Result<Vec<_>, _>>()?;\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n \n         debug!(\n             \"winnowed to {} candidates for {:?}: {:?}\",\n@@ -3004,9 +3005,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::Dynamic(ref data, ..) => {\n-                data.principal().with_self_ty(self.tcx(), self_ty)\n-            }\n+            ty::Dynamic(ref data, ..) => data.principal().with_self_ty(self.tcx(), self_ty),\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n \n@@ -3666,8 +3665,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         closure_def_id: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyTraitRef<'tcx> {\n+        debug!(\n+            \"closure_trait_ref_unnormalized(obligation={:?}, closure_def_id={:?}, substs={:?})\",\n+            obligation, closure_def_id, substs,\n+        );\n         let closure_type = self.infcx.closure_sig(closure_def_id, substs);\n \n+        debug!(\n+            \"closure_trait_ref_unnormalized: closure_type = {:?}\",\n+            closure_type\n+        );\n+\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n         // in fact unparameterized (or at least does not reference any"}, {"sha": "855983042c026cec3b38f9d37029e052c0b3c72b", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -53,8 +53,6 @@ pub enum TypeError<'tcx> {\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n-\n-    OldStyleLUB(Box<TypeError<'tcx>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -166,9 +164,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n                                        &format!(\"trait `{}`\", values.found))\n             }\n-            OldStyleLUB(ref err) => {\n-                write!(f, \"{}\", err)\n-            }\n         }\n     }\n }\n@@ -266,12 +261,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            OldStyleLUB(err) => {\n-                db.note(\"this was previously accepted by the compiler but has been phased out\");\n-                db.note(\"for more information, see https://github.com/rust-lang/rust/issues/45852\");\n-\n-                self.note_and_explain_type_err(db, &err, sp);\n-            }\n             CyclicTy(ty) => {\n                 // Watch out for various cases of cyclic types and try to explain.\n                 if ty.is_closure() || ty.is_generator() {"}, {"sha": "ad26383df6ac2d424f6a43288ba4dfe1b77eb41a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -1522,10 +1522,17 @@ impl UniverseIndex {\n \n     /// True if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n-    /// `other`.\n+    /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n+\n+    /// True if `self` cannot name some names from `other` -- in other\n+    /// words, if the set of names in `self` is a strict subset of\n+    /// those in `other` (`self < other`).\n+    pub fn cannot_name(self, other: UniverseIndex) -> bool {\n+        self.private < other.private\n+    }\n }\n \n /// The \"placeholder index\" fully defines a placeholder region.\n@@ -1540,6 +1547,8 @@ pub struct Placeholder {\n     pub name: BoundRegion,\n }\n \n+impl_stable_hash_for!(struct Placeholder { universe, name });\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}, {"sha": "05f5f923557ec7ea3dfcb1f07660dddb0971bb9f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -455,7 +455,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            OldStyleLUB(ref x) => return tcx.lift(x).map(OldStyleLUB),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n@@ -1003,7 +1002,6 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::ProjectionBoundsLength)(x),\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n-        (ty::error::TypeError::OldStyleLUB)(x),\n     }\n }\n "}, {"sha": "0c4140caee86f8e85542955b50e9cf4ccbb59127", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -107,7 +107,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // Run the MIR type-checker.\n     let MirTypeckResults {\n         constraints,\n-        placeholder_indices,\n         universal_region_relations,\n     } = type_check::type_check(\n         infcx,\n@@ -123,8 +122,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         elements,\n     );\n \n-    let placeholder_indices = Rc::new(placeholder_indices);\n-\n     if let Some(all_facts) = &mut all_facts {\n         all_facts\n             .universal_region\n@@ -136,11 +133,14 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // base constraints generated by the type-check.\n     let var_origins = infcx.take_region_var_origins();\n     let MirTypeckRegionConstraints {\n+        placeholder_indices,\n+        placeholder_index_to_region: _,\n         mut liveness_constraints,\n         outlives_constraints,\n         closure_bounds_mapping,\n         type_tests,\n     } = constraints;\n+    let placeholder_indices = Rc::new(placeholder_indices);\n \n     constraint_generation::generate_constraints(\n         infcx,"}, {"sha": "3358e5851f939d10c7da2d079c8ee0fc92839f47", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 240, "deletions": 120, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -8,23 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::ConstraintDescription;\n-use borrow_check::nll::constraints::{OutlivesConstraint};\n+use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::DefiningTy;\n-use util::borrowck_errors::{BorrowckErrors, Origin};\n+use borrow_check::nll::ConstraintDescription;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n+use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{ConstraintCategory, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n+use syntax::errors::Applicability;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use syntax::errors::Applicability;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n \n mod region_name;\n mod var_name;\n@@ -76,9 +77,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n \n         // Find all paths\n-        let (path, target_region) = self\n-            .find_constraint_paths_between_regions(from_region, target_test)\n-            .unwrap();\n+        let (path, target_region) =\n+            self.find_constraint_paths_between_regions(from_region, target_test)\n+                .unwrap();\n         debug!(\n             \"best_blame_constraint: path={:#?}\",\n             path.iter()\n@@ -92,8 +93,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n-            .iter()\n+        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path.iter()\n             .map(|constraint| {\n                 if constraint.category == ConstraintCategory::ClosureBounds {\n                     self.retrieve_closure_constraint_info(mir, &constraint)\n@@ -137,13 +137,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 | ConstraintCategory::Boring\n                 | ConstraintCategory::BoringNoLocation\n                 | ConstraintCategory::Internal => false,\n-                ConstraintCategory::TypeAnnotation\n-                | ConstraintCategory::Return => true,\n+                ConstraintCategory::TypeAnnotation | ConstraintCategory::Return => true,\n                 _ => constraint_sup_scc != target_scc,\n             }\n         });\n         if let Some(i) = best_choice {\n-            return categorized_path[i]\n+            return categorized_path[i];\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -179,6 +178,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         deque.push_back(from_region);\n \n         while let Some(r) = deque.pop_front() {\n+            debug!(\n+                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n+                from_region,\n+                r,\n+                self.region_value_str(r),\n+            );\n+\n             // Check if we reached the region we were looking for. If so,\n             // we can reconstruct the path that led to it and return it.\n             if target_test(r) {\n@@ -206,9 +212,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n             let fr_static = self.universal_regions.fr_static;\n-            for constraint in self.constraint_graph.outgoing_edges(r,\n-                                                                   &self.constraints,\n-                                                                   fr_static) {\n+            for constraint in self.constraint_graph\n+                .outgoing_edges(r, &self.constraints, fr_static)\n+            {\n                 assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -240,11 +246,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(\n-            mir,\n-            fr,\n-            |r| r == outlived_fr\n-        );\n+        let (category, _, span) = self.best_blame_constraint(mir, fr, |r| {\n+            self.provides_universal_region(r, fr, outlived_fr)\n+        });\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n@@ -260,23 +264,75 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.is_local_free_region(outlived_fr),\n         );\n \n-        debug!(\"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n-               fr_is_local, outlived_fr_is_local, category);\n+        debug!(\n+            \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n+            fr_is_local, outlived_fr_is_local, category\n+        );\n         match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) =>\n-                self.report_fnmut_error(mir, infcx, mir_def_id, fr, outlived_fr, span,\n-                                        errors_buffer),\n-            (ConstraintCategory::Assignment, true, false) |\n-            (ConstraintCategory::CallArgument, true, false) =>\n-                self.report_escaping_data_error(mir, infcx, mir_def_id, fr, outlived_fr,\n-                                                category, span, errors_buffer),\n-            _ =>\n-                self.report_general_error(mir, infcx, mir_def_id, fr, fr_is_local,\n-                                          outlived_fr, outlived_fr_is_local,\n-                                          category, span, errors_buffer),\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n+                self.report_fnmut_error(\n+                    mir,\n+                    infcx,\n+                    mir_def_id,\n+                    fr,\n+                    outlived_fr,\n+                    span,\n+                    errors_buffer,\n+                )\n+            }\n+            (ConstraintCategory::Assignment, true, false)\n+            | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n+            _ => self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                fr_is_local,\n+                outlived_fr,\n+                outlived_fr_is_local,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n         };\n     }\n \n+    /// We have a constraint `fr1: fr2` that is not satisfied, where\n+    /// `fr2` represents some universal region. Here, `r` is some\n+    /// region where we know that `fr1: r` and this function has the\n+    /// job of determining whether `r` is \"to blame\" for the fact that\n+    /// `fr1: fr2` is required.\n+    ///\n+    /// This is true under two conditions:\n+    ///\n+    /// - `r == fr2`\n+    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n+    ///   that cannot be named by `fr1`; in that case, we will require\n+    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n+    ///   be satisfied. (See `add_incompatible_universe`.)\n+    fn provides_universal_region(&self, r: RegionVid, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        debug!(\n+            \"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\",\n+            r, fr1, fr2\n+        );\n+        let result = {\n+            r == fr2 || {\n+                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n+            }\n+        };\n+        debug!(\"provides_universal_region: result = {:?}\", result);\n+        result\n+    }\n+\n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n     /// This function expects `fr` to be local and `outlived_fr` to not be local.\n     ///\n@@ -303,10 +359,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            span,\n-            \"captured variable cannot escape `FnMut` closure body\",\n-        );\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n@@ -318,27 +374,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"returns a reference to a captured variable which escapes the closure body\"\n         };\n \n-        diag.span_label(\n-            span,\n-            message,\n-        );\n+        diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1).source {\n-            RegionNameSource::NamedEarlyBoundRegion(fr_span) |\n-            RegionNameSource::NamedFreeRegion(fr_span) |\n-            RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _) |\n-            RegionNameSource::CannotMatchHirTy(fr_span, _) |\n-            RegionNameSource::MatchedHirTy(fr_span) |\n-            RegionNameSource::MatchedAdtAndSegment(fr_span) |\n-            RegionNameSource::AnonRegionFromUpvar(fr_span, _) |\n-            RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n+        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1)\n+            .source\n+        {\n+            RegionNameSource::NamedEarlyBoundRegion(fr_span)\n+            | RegionNameSource::NamedFreeRegion(fr_span)\n+            | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n+            | RegionNameSource::CannotMatchHirTy(fr_span, _)\n+            | RegionNameSource::MatchedHirTy(fr_span)\n+            | RegionNameSource::MatchedAdtAndSegment(fr_span)\n+            | RegionNameSource::AnonRegionFromUpvar(fr_span, _)\n+            | RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n                 diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n \n-        diag.note(\"`FnMut` closures only have access to their captured variables while they are \\\n-                   executing...\");\n+        diag.note(\n+            \"`FnMut` closures only have access to their captured variables while they are \\\n+             executing...\",\n+        );\n         diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n \n         diag.buffer(errors_buffer);\n@@ -375,7 +432,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\",\n-            DefiningTy::Const(..) => \"const\"\n+            DefiningTy::Const(..) => \"const\",\n         };\n \n         // Revert to the normal error in these cases.\n@@ -384,12 +441,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n-            return self.report_general_error(mir, infcx, mir_def_id,\n-                                             fr, true, outlived_fr, false,\n-                                             category, span, errors_buffer);\n+            return self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                true,\n+                outlived_fr,\n+                false,\n+                category,\n+                span,\n+                errors_buffer,\n+            );\n         }\n \n-        let mut diag = infcx.tcx.borrowed_data_escapes_closure(span, escapes_from, Origin::Mir);\n+        let mut diag = infcx\n+            .tcx\n+            .borrowed_data_escapes_closure(span, escapes_from, Origin::Mir);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -410,7 +478,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 ),\n             );\n \n-            diag.span_label(span, format!(\"`{}` escapes the {} body here\", fr_name, escapes_from));\n+            diag.span_label(\n+                span,\n+                format!(\"`{}` escapes the {} body here\", fr_name, escapes_from),\n+            );\n         }\n \n         diag.buffer(errors_buffer);\n@@ -452,31 +523,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let counter = &mut 1;\n         let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter);\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_fr, counter);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, counter);\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n-        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n+        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n+            \"closure\"\n+        } else {\n+            \"function\"\n+        };\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n             (ConstraintCategory::Return, true, _) => {\n-                diag.span_label(span, format!(\n-                    \"{} was supposed to return data with lifetime `{}` but it is returning \\\n-                    data with lifetime `{}`\",\n-                    mir_def_name, outlived_fr_name, fr_name\n-                ));\n-            },\n+                diag.span_label(\n+                    span,\n+                    format!(\n+                        \"{} was supposed to return data with lifetime `{}` but it is returning \\\n+                         data with lifetime `{}`\",\n+                        mir_def_name, outlived_fr_name, fr_name\n+                    ),\n+                );\n+            }\n             _ => {\n-                diag.span_label(span, format!(\n-                    \"{}requires that `{}` must outlive `{}`\",\n-                    category.description(), fr_name, outlived_fr_name,\n-                ));\n-            },\n+                diag.span_label(\n+                    span,\n+                    format!(\n+                        \"{}requires that `{}` must outlive `{}`\",\n+                        category.description(),\n+                        fr_name,\n+                        outlived_fr_name,\n+                    ),\n+                );\n+            }\n         }\n \n-        self.add_static_impl_trait_suggestion(\n-            infcx, &mut diag, fr, fr_name, outlived_fr,\n-        );\n+        self.add_static_impl_trait_suggestion(infcx, &mut diag, fr, fr_name, outlived_fr);\n \n         diag.buffer(errors_buffer);\n     }\n@@ -499,17 +580,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr_name: RegionName,\n         outlived_fr: RegionVid,\n     ) {\n-        if let (\n-            Some(f),\n-            Some(ty::RegionKind::ReStatic)\n-        ) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n+        if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n+            (self.to_error_region(fr), self.to_error_region(outlived_fr))\n+        {\n             if let Some(ty::TyS {\n                 sty: ty::TyKind::Opaque(did, substs),\n                 ..\n-            }) = infcx.tcx.is_suitable_region(f)\n-                    .map(|r| r.def_id)\n-                    .map(|id| infcx.tcx.return_type_impl_trait(id))\n-                    .unwrap_or(None)\n+            }) = infcx\n+                .tcx\n+                .is_suitable_region(f)\n+                .map(|r| r.def_id)\n+                .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                .unwrap_or(None)\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime.\n@@ -522,10 +604,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let mut found = false;\n                     for predicate in bounds.predicates {\n                         if let ty::Predicate::TypeOutlives(binder) = predicate {\n-                            if let ty::OutlivesPredicate(\n-                                _,\n-                                ty::RegionKind::ReStatic\n-                            ) = binder.skip_binder() {\n+                            if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n+                                binder.skip_binder()\n+                            {\n                                 found = true;\n                                 break;\n                             }\n@@ -535,18 +616,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     found\n                 };\n \n-                debug!(\"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n-                       has_static_predicate);\n+                debug!(\n+                    \"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n+                    has_static_predicate\n+                );\n                 let static_str = keywords::StaticLifetime.name();\n                 // If there is a static predicate, then the only sensible suggestion is to replace\n                 // fr with `'static`.\n                 if has_static_predicate {\n-                    diag.help(\n-                        &format!(\n-                            \"consider replacing `{}` with `{}`\",\n-                            fr_name, static_str,\n-                        ),\n-                    );\n+                    diag.help(&format!(\n+                        \"consider replacing `{}` with `{}`\",\n+                        fr_name, static_str,\n+                    ));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = infcx.tcx.def_span(*did);\n@@ -581,25 +662,48 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, RegionName) {\n-        let (category, from_closure, span) = self.best_blame_constraint(\n-            mir,\n-            borrow_region,\n-            |r| r == outlived_region\n-        );\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_region, &mut 1);\n+        let (category, from_closure, span) =\n+            self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx, mir, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n \n     // Finds some region R such that `fr1: R` and `R` is live at\n     // `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        // Find all paths\n-        let (_path, r) =\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.liveness_constraints.contains(r, elem)\n-            }).unwrap();\n-        r\n+        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        self.find_constraint_paths_between_regions(fr1, |r| {\n+            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n+            debug!(\n+                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n+                r,\n+                self.liveness_constraints.region_value_str(r),\n+            );\n+            self.liveness_constraints.contains(r, elem)\n+        }).or_else(|| {\n+                // If we fail to find that, we may find some `r` such that\n+                // `fr1: r` and `r` is a placeholder from some universe\n+                // `fr1` cannot name. This would force `fr1` to be\n+                // `'static`.\n+                self.find_constraint_paths_between_regions(fr1, |r| {\n+                    self.cannot_name_placeholder(fr1, r)\n+                })\n+            })\n+            .or_else(|| {\n+                // If we fail to find THAT, it may be that `fr1` is a\n+                // placeholder that cannot \"fit\" into its SCC. In that\n+                // case, there should be some `r` where `fr1: r`, both\n+                // `fr1` and `r` are in the same SCC, and `fr1` is a\n+                // placeholder that `r` cannot name. We can blame that\n+                // edge.\n+                self.find_constraint_paths_between_regions(fr1, |r| {\n+                    self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n+                        && self.cannot_name_placeholder(r, fr1)\n+                })\n+            })\n+            .map(|(_path, r)| r)\n+            .unwrap()\n     }\n \n     // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n@@ -609,34 +713,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n+        let (category, _, span) =\n+            self.best_blame_constraint(mir, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n         (category, span)\n     }\n \n     fn retrieve_closure_constraint_info(\n         &self,\n         mir: &Mir<'tcx>,\n-        constraint: &OutlivesConstraint\n+        constraint: &OutlivesConstraint,\n     ) -> (ConstraintCategory, bool, Span) {\n         let loc = match constraint.locations {\n             Locations::All(span) => return (constraint.category, false, span),\n             Locations::Single(loc) => loc,\n         };\n \n-        let opt_span_category = self\n-            .closure_bounds_mapping[&loc]\n-            .get(&(constraint.sup, constraint.sub));\n+        let opt_span_category =\n+            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n         opt_span_category\n             .map(|&(category, span)| (category, true, span))\n             .unwrap_or((constraint.category, false, mir.source_info(loc).span))\n     }\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(\n-        &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        fr: RegionVid,\n-    ) -> bool {\n+    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, '_, 'tcx>, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n@@ -648,4 +748,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         false\n     }\n+\n+    /// If `r2` represents a placeholder region, then this returns\n+    /// true if `r1` cannot name that placeholder in its\n+    /// value. Otherwise, returns false.\n+    fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n+\n+        match self.definitions[r2].origin {\n+            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                let universe1 = self.definitions[r1].universe;\n+                debug!(\n+                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n+                    universe1, placeholder\n+                );\n+                universe1.cannot_name(placeholder.universe)\n+            }\n+\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential => false,\n+        }\n+    }\n }"}, {"sha": "376f445924270b2bd130dae6f0a26cc50e3b998f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -345,6 +345,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     if scc_universe.can_name(placeholder.universe) {\n                         self.scc_values.add_element(scc, placeholder);\n                     } else {\n+                        debug!(\n+                            \"init_free_and_bound_regions: placeholder {:?} is \\\n+                             not compatible with universe {:?} of its SCC {:?}\",\n+                            placeholder,\n+                            scc_universe,\n+                            scc,\n+                        );\n                         self.add_incompatible_universe(scc);\n                     }\n                 }\n@@ -471,6 +478,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n+                .into_iter()\n+                .map(|c| (c, self.constraint_sccs.scc(c.sup), self.constraint_sccs.scc(c.sub)))\n+                .collect::<Vec<_>>()\n         });\n \n         // To propagate constraints, we walk the DAG induced by the\n@@ -560,6 +570,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `'a` with `'b` and not `'static`. But it will have to do for\n     /// now.\n     fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n+        debug!(\"add_incompatible_universe(scc={:?})\", scc);\n+\n         let fr_static = self.universal_regions.fr_static;\n         self.scc_values.add_all_points(scc);\n         self.scc_values.add_element(scc, fr_static);\n@@ -1226,6 +1238,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+        debug!(\n+            \"check_bound_universal_region: longer_fr_scc={:?}\",\n+            longer_fr_scc,\n+        );\n \n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n@@ -1242,6 +1258,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Some(v) => v,\n             None => return,\n         };\n+        debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n \n         // Find the region that introduced this `error_element`.\n         let error_region = match error_element {"}, {"sha": "5904138ef603ac03df58ffe06f7df786c5425cb1", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -8,54 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::region_infer::TypeTest;\n-use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n-use rustc::infer::{self, SubregionOrigin};\n+use rustc::infer::{self, InferCtxt, SubregionOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n-    outlives_constraints: &'a mut ConstraintSet,\n-    type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+    constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n-        outlives_constraints: &'a mut ConstraintSet,\n-        type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+        constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {\n-            tcx,\n+            infcx,\n+            tcx: infcx.tcx,\n             universal_regions,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n             locations,\n             category,\n-            outlives_constraints,\n-            type_tests,\n+            constraints,\n         }\n     }\n \n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n \n     fn verify_to_type_test(\n-        &self,\n+        &mut self,\n         generic_kind: GenericKind<'tcx>,\n         region: ty::Region<'tcx>,\n         verify_bound: VerifyBound<'tcx>,\n@@ -128,22 +128,30 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        self.universal_regions.to_region_vid(r)\n+    fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        if let ty::RePlaceholder(placeholder) = r {\n+            self.constraints\n+                .placeholder_region(self.infcx, *placeholder)\n+                .to_region_vid()\n+        } else {\n+            self.universal_regions.to_region_vid(r)\n+        }\n     }\n \n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n-        self.outlives_constraints.push(OutlivesConstraint {\n-            locations: self.locations,\n-            category: self.category,\n-            sub,\n-            sup,\n-        });\n+        self.constraints\n+            .outlives_constraints\n+            .push(OutlivesConstraint {\n+                locations: self.locations,\n+                category: self.category,\n+                sub,\n+                sup,\n+            });\n     }\n \n     fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n         debug!(\"add_type_test(type_test={:?})\", type_test);\n-        self.type_tests.push(type_test);\n+        self.constraints.type_tests.push(type_test);\n     }\n }\n \n@@ -156,8 +164,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx>\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        let b = self.universal_regions.to_region_vid(b);\n-        let a = self.universal_regions.to_region_vid(a);\n+        let b = self.to_region_vid(b);\n+        let a = self.to_region_vid(a);\n         self.add_outlives(b, a);\n     }\n "}, {"sha": "3d0f3d9fc7d8d1ee8cffb99c9f357a0f9f206b89", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -271,15 +271,14 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n \n         for data in constraint_sets {\n             constraint_conversion::ConstraintConversion::new(\n-                self.infcx.tcx,\n+                self.infcx,\n                 &self.universal_regions,\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 Locations::All(DUMMY_SP),\n                 ConstraintCategory::Internal,\n-                &mut self.constraints.outlives_constraints,\n-                &mut self.constraints.type_tests,\n+                &mut self.constraints,\n             ).convert_all(&data);\n         }\n "}, {"sha": "0a873cd84ff3d665461d486d34afa484249a8773", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -16,6 +16,7 @@ use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::LivenessValues;\n+use borrow_check::nll::region_infer::values::PlaceholderIndex;\n use borrow_check::nll::region_infer::values::PlaceholderIndices;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n@@ -28,11 +29,12 @@ use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n+use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n@@ -44,14 +46,13 @@ use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::rc::Rc;\n use std::{fmt, iter};\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n \n-use either::Either;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         $crate::borrow_check::nll::type_check::mirbug(\n@@ -126,12 +127,13 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n+        placeholder_indices: PlaceholderIndices::default(),\n+        placeholder_index_to_region: IndexVec::default(),\n         liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n     };\n-    let mut placeholder_indices = PlaceholderIndices::default();\n \n     let CreateResult {\n         universal_region_relations,\n@@ -151,7 +153,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         borrow_set,\n         all_facts,\n         constraints: &mut constraints,\n-        placeholder_indices: &mut placeholder_indices,\n     };\n \n     type_check_internal(\n@@ -175,7 +176,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n \n     MirTypeckResults {\n         constraints,\n-        placeholder_indices,\n         universal_region_relations,\n     }\n }\n@@ -730,18 +730,30 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n-    placeholder_indices: &'a mut PlaceholderIndices,\n }\n \n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n-    crate placeholder_indices: PlaceholderIndices,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n crate struct MirTypeckRegionConstraints<'tcx> {\n+    /// Maps from a `ty::Placeholder` to the corresponding\n+    /// `PlaceholderIndex` bit that we will use for it.\n+    ///\n+    /// To keep everything in sync, do not insert this set\n+    /// directly. Instead, use the `placeholder_region` helper.\n+    crate placeholder_indices: PlaceholderIndices,\n+\n+    /// Each time we add a placeholder to `placeholder_indices`, we\n+    /// also create a corresponding \"representative\" region vid for\n+    /// that wraps it. This vector tracks those. This way, when we\n+    /// convert the same `ty::RePlaceholder(p)` twice, we can map to\n+    /// the same underlying `RegionVid`.\n+    crate placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n+\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n@@ -759,6 +771,25 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n+impl MirTypeckRegionConstraints<'tcx> {\n+    fn placeholder_region(\n+        &mut self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        placeholder: ty::Placeholder,\n+    ) -> ty::Region<'tcx> {\n+        let placeholder_index = self.placeholder_indices.insert(placeholder);\n+        match self.placeholder_index_to_region.get(placeholder_index) {\n+            Some(&v) => v,\n+            None => {\n+                let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n+                let region = infcx.next_nll_region_var_in_universe(origin, placeholder.universe);\n+                self.placeholder_index_to_region.push(region);\n+                region\n+            }\n+        }\n+    }\n+}\n+\n /// The `Locations` type summarizes *where* region constraints are\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n@@ -888,15 +919,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         if let Some(ref mut borrowck_context) = self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n-                self.infcx.tcx,\n+                self.infcx,\n                 borrowck_context.universal_regions,\n                 self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n                 category,\n-                &mut borrowck_context.constraints.outlives_constraints,\n-                &mut borrowck_context.constraints.type_tests,\n+                &mut borrowck_context.constraints,\n             ).convert_all(&data);\n         }\n     }"}, {"sha": "b82efb29f6e56a8a0cf0bc2a1745f5f54cd6b4d6", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -76,16 +76,20 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n     }\n \n     fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n-        let origin = NLLRegionVariableOrigin::Existential;\n-        self.infcx.next_nll_region_var(origin)\n+        if let Some(_) = &mut self.borrowck_context {\n+            let origin = NLLRegionVariableOrigin::Existential;\n+            self.infcx.next_nll_region_var(origin)\n+        } else {\n+            self.infcx.tcx.types.re_erased\n+        }\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::Placeholder) -> ty::Region<'tcx> {\n-        let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n-            borrowck_context.placeholder_indices.insert(placeholder);\n+            borrowck_context.constraints.placeholder_region(self.infcx, placeholder)\n+        } else {\n+            self.infcx.tcx.types.re_erased\n         }\n-        self.infcx.next_nll_region_var(origin)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {"}, {"sha": "fb7c237a536bdd70cb1be8fae07dd5a82f67d452", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -13,10 +13,12 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use astconv::AstConv;\n+use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use rustc::traits::Obligation;\n use rustc::traits::error_reporting::ArgKind;\n use rustc::ty::{self, ToPolyTraitRef, Ty, GenericParamDefKind};\n use rustc::ty::fold::TypeFoldable;\n@@ -479,7 +481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our tables, which are then later used by the privacy\n         // check.\n-        match self.check_supplied_sig_against_expectation(expr_def_id, decl, &closure_sigs) {\n+        match self.check_supplied_sig_against_expectation(expr_def_id, decl, body, &closure_sigs) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n             Err(_) => return self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n         }\n@@ -523,6 +525,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n+        body: &hir::Body,\n         expected_sigs: &ClosureSignatures<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         // Get the signature S that the user gave.\n@@ -575,6 +578,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } = self.at(cause, self.param_env)\n                     .eq(*expected_ty, supplied_ty)?;\n                 all_obligations.extend(obligations);\n+\n+                // Also, require that the supplied type must outlive\n+                // the closure body.\n+                let closure_body_region = self.tcx.mk_region(\n+                    ty::ReScope(\n+                        region::Scope {\n+                            id: body.value.hir_id.local_id,\n+                            data: region::ScopeData::Node,\n+                        },\n+                    ),\n+                );\n+                all_obligations.push(\n+                    Obligation::new(\n+                        cause.clone(),\n+                        self.param_env,\n+                        ty::Predicate::TypeOutlives(\n+                            ty::Binder::dummy(\n+                                ty::OutlivesPredicate(\n+                                    supplied_ty,\n+                                    closure_body_region,\n+                                ),\n+                            ),\n+                        ),\n+                    ),\n+                );\n             }\n \n             let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var("}, {"sha": "9ac733b159ba66d6953810a70dc7915e1fd3e69f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                     o_ty\n                 };\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_response(&revealed_ty);\n+                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(&revealed_ty);\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                        ty.hir_id, o_ty, revealed_ty, c_ty);\n                 self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n@@ -2137,7 +2137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             method.substs[i]\n                         }\n                     });\n-                    self.infcx.canonicalize_response(&UserSubsts {\n+                    self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n                         substs: just_method_substs,\n                         user_self_ty: None, // not relevant here\n                     })\n@@ -2181,7 +2181,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         if !substs.is_noop() {\n-            let user_substs = self.infcx.canonicalize_response(&UserSubsts {\n+            let user_substs = self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n                 substs,\n                 user_self_ty,\n             });"}, {"sha": "75f19d133e0e92cde1234a13865389f6c7da5132", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -56,7 +56,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n+//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { max_universe: U0, variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "4182b5258884f55b8ef205d0640cd4d88f007a32", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -11,8 +11,6 @@ LL | |     };\n    |\n    = note: expected type `for<'r, 's> fn(&'r u8, &'s u8)`\n               found type `for<'a> fn(&'a u8, &'a u8)`\n-   = note: this was previously accepted by the compiler but has been phased out\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n \n error: aborting due to previous error\n "}, {"sha": "bb8cb45eec39711c88b4e2ba14365c712a537248", "filename": "src/test/ui/lub-glb/old-lub-glb-object.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -11,8 +11,6 @@ LL | |     };\n    |\n    = note: expected type `&dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n               found type `&dyn for<'a> Foo<&'a u8, &'a u8>`\n-   = note: this was previously accepted by the compiler but has been phased out\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n \n error: aborting due to previous error\n "}, {"sha": "88383190cbce6604e2d296397ce8748075f3ae1d", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -1,4 +1,4 @@\n-error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n   --> $DIR/dump-adt-brace-struct.rs:28:5\n    |\n LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]"}, {"sha": "3beb994a4e8a5731636422713a23c31d5959541a", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eda136f622f9cbfe706e775fcaa3a0169fd4ae1/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=5eda136f622f9cbfe706e775fcaa3a0169fd4ae1", "patch": "@@ -1,22 +1,22 @@\n-error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = foo::<u32>; //~ ERROR [u32]\n    |             ^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, u32, ?1], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, u32, ?1], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:42:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:46:13\n    |\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, ?1, u32], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, ?1, u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:54:5\n    |\n LL |     y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]"}]}