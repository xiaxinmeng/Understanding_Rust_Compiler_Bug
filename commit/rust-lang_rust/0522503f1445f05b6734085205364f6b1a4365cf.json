{"sha": "0522503f1445f05b6734085205364f6b1a4365cf", "node_id": "C_kwDOAAsO6NoAKDA1MjI1MDNmMTQ0NWYwNWI2NzM0MDg1MjA1MzY0ZjZiMWE0MzY1Y2Y", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-29T09:42:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-29T09:42:08Z"}, "message": "Thread global symbol interner through as if it was a local", "tree": {"sha": "a3e79f6aabe21c5fbedfb4d54875acfbdcc8d750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3e79f6aabe21c5fbedfb4d54875acfbdcc8d750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0522503f1445f05b6734085205364f6b1a4365cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0522503f1445f05b6734085205364f6b1a4365cf", "html_url": "https://github.com/rust-lang/rust/commit/0522503f1445f05b6734085205364f6b1a4365cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0522503f1445f05b6734085205364f6b1a4365cf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4582f6d183abed38684e669573c27ce40007ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4582f6d183abed38684e669573c27ce40007ea3", "html_url": "https://github.com/rust-lang/rust/commit/c4582f6d183abed38684e669573c27ce40007ea3"}], "stats": {"total": 65, "additions": 39, "deletions": 26}, "files": [{"sha": "3c6f320331928fbcf93147dccceccb7a77ea6422", "filename": "crates/proc-macro-srv/src/proc_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs?ref=0522503f1445f05b6734085205364f6b1a4365cf", "patch": "@@ -3,7 +3,7 @@\n use libloading::Library;\n use proc_macro_api::{ProcMacroKind, RustCInfo};\n \n-use crate::{dylib::LoadProcMacroDylibError, tt};\n+use crate::{dylib::LoadProcMacroDylibError, server::SYMBOL_INTERNER, tt};\n \n pub(crate) struct ProcMacros {\n     exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n@@ -59,7 +59,7 @@ impl ProcMacros {\n                 } if *trait_name == macro_name => {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        crate::server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_body,\n                         true,\n                     );\n@@ -70,7 +70,7 @@ impl ProcMacros {\n                 {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        crate::server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_body,\n                         true,\n                     );\n@@ -81,7 +81,7 @@ impl ProcMacros {\n                 {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        crate::server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_attributes,\n                         parsed_body,\n                         true,"}, {"sha": "5b659ab849816a9e9e26d1a3b30a5a05617d2c0b", "filename": "crates/proc-macro-srv/src/server.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs?ref=0522503f1445f05b6734085205364f6b1a4365cf", "patch": "@@ -14,7 +14,7 @@ use proc_macro::{\n };\n \n mod token_stream;\n-pub(crate) use token_stream::TokenStream;\n+pub use token_stream::TokenStream;\n use token_stream::TokenStreamBuilder;\n \n mod symbol;\n@@ -40,9 +40,9 @@ pub struct SourceFile {\n \n pub struct FreeFunctions;\n \n-#[derive(Default)]\n pub struct RustAnalyzer {\n     // FIXME: store span information here.\n+    pub(crate) interner: SymbolInternerRef,\n }\n \n impl server::Types for RustAnalyzer {\n@@ -67,7 +67,7 @@ impl server::FreeFunctions for RustAnalyzer {\n         // FIXME: keep track of LitKind and Suffix\n         Ok(bridge::Literal {\n             kind: bridge::LitKind::Err,\n-            symbol: Symbol::intern(s),\n+            symbol: Symbol::intern(self.interner, s),\n             suffix: None,\n             span: tt::TokenId::unspecified(),\n         })\n@@ -108,7 +108,7 @@ impl server::TokenStream for RustAnalyzer {\n             }\n \n             bridge::TokenTree::Ident(ident) => {\n-                let text = ident.sym.text();\n+                let text = ident.sym.text(self.interner);\n                 let text =\n                     if ident.is_raw { ::tt::SmolStr::from_iter([\"r#\", &text]) } else { text };\n                 let ident: tt::Ident = tt::Ident { text, span: ident.span };\n@@ -119,8 +119,9 @@ impl server::TokenStream for RustAnalyzer {\n \n             bridge::TokenTree::Literal(literal) => {\n                 let literal = LiteralFormatter(literal);\n-                let text = literal\n-                    .with_stringify_parts(|parts| ::tt::SmolStr::from_iter(parts.iter().copied()));\n+                let text = literal.with_stringify_parts(self.interner, |parts| {\n+                    ::tt::SmolStr::from_iter(parts.iter().copied())\n+                });\n \n                 let literal = tt::Literal { text, span: literal.0.span };\n                 let leaf = tt::Leaf::from(literal);\n@@ -184,7 +185,7 @@ impl server::TokenStream for RustAnalyzer {\n             .map(|tree| match tree {\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n                     bridge::TokenTree::Ident(bridge::Ident {\n-                        sym: Symbol::intern(ident.text.trim_start_matches(\"r#\")),\n+                        sym: Symbol::intern(self.interner, ident.text.trim_start_matches(\"r#\")),\n                         is_raw: ident.text.starts_with(\"r#\"),\n                         span: ident.span,\n                     })\n@@ -193,7 +194,7 @@ impl server::TokenStream for RustAnalyzer {\n                     bridge::TokenTree::Literal(bridge::Literal {\n                         // FIXME: handle literal kinds\n                         kind: bridge::LitKind::Err,\n-                        symbol: Symbol::intern(&lit.text),\n+                        symbol: Symbol::intern(self.interner, &lit.text),\n                         // FIXME: handle suffixes\n                         suffix: None,\n                         span: lit.span,\n@@ -351,11 +352,13 @@ impl server::Server for RustAnalyzer {\n     }\n \n     fn intern_symbol(ident: &str) -> Self::Symbol {\n-        Symbol::intern(&::tt::SmolStr::from(ident))\n+        // FIXME: should be self.interner once the proc-macro api allows is\n+        Symbol::intern(&SYMBOL_INTERNER, &::tt::SmolStr::from(ident))\n     }\n \n     fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n-        f(symbol.text().as_str())\n+        // FIXME: should be self.interner once the proc-macro api allows is\n+        f(symbol.text(&SYMBOL_INTERNER).as_str())\n     }\n }\n \n@@ -366,7 +369,11 @@ impl LiteralFormatter {\n     /// literal's representation. This is done to allow the `ToString` and\n     /// `Display` implementations to borrow references to symbol values, and\n     /// both be optimized to reduce overhead.\n-    fn with_stringify_parts<R>(&self, f: impl FnOnce(&[&str]) -> R) -> R {\n+    fn with_stringify_parts<R>(\n+        &self,\n+        interner: SymbolInternerRef,\n+        f: impl FnOnce(&[&str]) -> R,\n+    ) -> R {\n         /// Returns a string containing exactly `num` '#' characters.\n         /// Uses a 256-character source string literal which is always safe to\n         /// index with a `u8` index.\n@@ -381,7 +388,7 @@ impl LiteralFormatter {\n             &HASHES[..num as usize]\n         }\n \n-        self.with_symbol_and_suffix(|symbol, suffix| match self.0.kind {\n+        self.with_symbol_and_suffix(interner, |symbol, suffix| match self.0.kind {\n             bridge::LitKind::Byte => f(&[\"b'\", symbol, \"'\", suffix]),\n             bridge::LitKind::Char => f(&[\"'\", symbol, \"'\", suffix]),\n             bridge::LitKind::Str => f(&[\"\\\"\", symbol, \"\\\"\", suffix]),\n@@ -398,9 +405,13 @@ impl LiteralFormatter {\n         })\n     }\n \n-    fn with_symbol_and_suffix<R>(&self, f: impl FnOnce(&str, &str) -> R) -> R {\n-        let symbol = self.0.symbol.text();\n-        let suffix = self.0.suffix.map(|s| s.text()).unwrap_or_default();\n+    fn with_symbol_and_suffix<R>(\n+        &self,\n+        interner: SymbolInternerRef,\n+        f: impl FnOnce(&str, &str) -> R,\n+    ) -> R {\n+        let symbol = self.0.symbol.text(interner);\n+        let suffix = self.0.suffix.map(|s| s.text(interner)).unwrap_or_default();\n         f(symbol.as_str(), suffix.as_str())\n     }\n }"}, {"sha": "540d06457f2f39f8ea940e3f2a7d78c3dd50a407", "filename": "crates/proc-macro-srv/src/server/symbol.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0522503f1445f05b6734085205364f6b1a4365cf/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs?ref=0522503f1445f05b6734085205364f6b1a4365cf", "patch": "@@ -1,28 +1,30 @@\n //! Symbol interner for proc-macro-srv\n \n-use std::{cell::RefCell, collections::HashMap};\n+use std::{cell::RefCell, collections::HashMap, thread::LocalKey};\n use tt::SmolStr;\n \n thread_local! {\n-    static SYMBOL_INTERNER: RefCell<SymbolInterner> = Default::default();\n+    pub(crate) static SYMBOL_INTERNER: RefCell<SymbolInterner> = Default::default();\n }\n \n // ID for an interned symbol.\n #[derive(Hash, Eq, PartialEq, Copy, Clone)]\n pub struct Symbol(u32);\n \n+pub(crate) type SymbolInternerRef = &'static LocalKey<RefCell<SymbolInterner>>;\n+\n impl Symbol {\n-    pub(super) fn intern(data: &str) -> Symbol {\n-        SYMBOL_INTERNER.with(|i| i.borrow_mut().intern(data))\n+    pub(super) fn intern(interner: SymbolInternerRef, data: &str) -> Symbol {\n+        interner.with(|i| i.borrow_mut().intern(data))\n     }\n \n-    pub(super) fn text(&self) -> SmolStr {\n-        SYMBOL_INTERNER.with(|i| i.borrow().get(self).clone())\n+    pub(super) fn text(&self, interner: SymbolInternerRef) -> SmolStr {\n+        interner.with(|i| i.borrow().get(self).clone())\n     }\n }\n \n #[derive(Default)]\n-struct SymbolInterner {\n+pub(crate) struct SymbolInterner {\n     idents: HashMap<SmolStr, u32>,\n     ident_data: Vec<SmolStr>,\n }"}]}