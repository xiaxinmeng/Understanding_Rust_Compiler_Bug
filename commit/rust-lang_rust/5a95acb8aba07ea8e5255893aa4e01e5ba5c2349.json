{"sha": "5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOTVhY2I4YWJhMDdlYThlNTI1NTg5M2FhNGUwMWU1YmE1YzIzNDk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-14T11:55:56Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-14T11:55:56Z"}, "message": "split ty::util and ty::adjustment", "tree": {"sha": "8de85241c95662e8e6372029d72304642a6dce11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8de85241c95662e8e6372029d72304642a6dce11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "html_url": "https://github.com/rust-lang/rust/commit/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "html_url": "https://github.com/rust-lang/rust/commit/2ad5a61fe234e54c9385efac7fb4d04f34a137b1"}], "stats": {"total": 2707, "additions": 1387, "deletions": 1320}, "files": [{"sha": "e1cb9bd0e77cf60db4317ad998cae8d564355d64", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -247,9 +247,11 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_impl_polarity(&*cdata, def.node)\n }\n \n-pub fn get_custom_coerce_unsized_kind<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                            def: DefId)\n-                                            -> Option<ty::CustomCoerceUnsized> {\n+pub fn get_custom_coerce_unsized_kind<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    def: DefId)\n+    -> Option<ty::adjustment::CustomCoerceUnsized>\n+{\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)"}, {"sha": "e2cf50cf30ad0b4a768c510eb25bf12a150f62c6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -540,9 +540,11 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_custom_coerce_unsized_kind<'tcx>(cdata: Cmd,\n-                                            id: ast::NodeId)\n-                                            -> Option<ty::CustomCoerceUnsized> {\n+pub fn get_custom_coerce_unsized_kind<'tcx>(\n+    cdata: Cmd,\n+    id: ast::NodeId)\n+    -> Option<ty::adjustment::CustomCoerceUnsized>\n+{\n     let item_doc = cdata.lookup_item(id);\n     reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n         let mut decoder = reader::Decoder::new(kind_doc);"}, {"sha": "0bd4434857abd50ca1d6d989b05ad0d8c449e6fa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -27,6 +27,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n+use middle::ty::adjustment;\n use middle::ty::cast;\n use middle::check_const::ConstQualif;\n use middle::def;\n@@ -646,11 +647,11 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                                adj: &ty::AutoAdjustment<'tcx>);\n+                                adj: &adjustment::AutoAdjustment<'tcx>);\n     fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>);\n+                        autoref: &adjustment::AutoRef<'tcx>);\n     fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                               auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n+                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>);\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n@@ -771,22 +772,22 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                                adj: &ty::AutoAdjustment<'tcx>) {\n+                                adj: &adjustment::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AdjustReifyFnPointer=> {\n+                adjustment::AdjustReifyFnPointer=> {\n                     this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n                 }\n \n-                ty::AdjustUnsafeFnPointer => {\n+                adjustment::AdjustUnsafeFnPointer => {\n                     this.emit_enum_variant(\"AdjustUnsafeFnPointer\", 2, 0, |_| {\n                         Ok(())\n                     })\n                 }\n \n-                ty::AdjustDerefRef(ref auto_deref_ref) => {\n+                adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AdjustDerefRef\", 3, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n@@ -797,19 +798,19 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                        autoref: &ty::AutoRef<'tcx>) {\n+                        autoref: &adjustment::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n-                &ty::AutoPtr(r, m) => {\n+                &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_region(ecx, *r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n-                &ty::AutoUnsafe(m) => {\n+                &adjustment::AutoUnsafe(m) => {\n                     this.emit_enum_variant(\"AutoUnsafe\", 1, 1, |this| {\n                         this.emit_enum_variant_arg(0, |this| m.encode(this))\n                     })\n@@ -819,7 +820,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                               auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n+                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n@@ -974,7 +975,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n         match *adjustment {\n-            ty::AdjustDerefRef(ref adj) => {\n+            adjustment::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n@@ -1063,17 +1064,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n                           -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                    -> ty::AutoAdjustment<'tcx>;\n+                                    -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> cast::CastKind;\n     fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> ty::ClosureKind;\n     fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                -> ty::ClosureTy<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> ty::AutoDerefRef<'tcx>;\n+                                   -> adjustment::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                            -> ty::AutoRef<'tcx>;\n+                            -> adjustment::AutoRef<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n@@ -1246,30 +1247,30 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                    -> ty::AutoAdjustment<'tcx> {\n+                                    -> adjustment::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\", \"AdjustDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n-                    1 => ty::AdjustReifyFnPointer,\n-                    2 => ty::AdjustUnsafeFnPointer,\n+                    1 => adjustment::AdjustReifyFnPointer,\n+                    2 => adjustment::AdjustUnsafeFnPointer,\n                     3 => {\n-                        let auto_deref_ref: ty::AutoDerefRef =\n+                        let auto_deref_ref: adjustment::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n-                        ty::AdjustDerefRef(auto_deref_ref)\n+                        adjustment::AdjustDerefRef(auto_deref_ref)\n                     }\n-                    _ => panic!(\"bad enum variant for ty::AutoAdjustment\")\n+                    _ => panic!(\"bad enum variant for adjustment::AutoAdjustment\")\n                 })\n             })\n         }).unwrap()\n     }\n \n     fn read_auto_deref_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> ty::AutoDerefRef<'tcx> {\n+                                   -> adjustment::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n-            Ok(ty::AutoDerefRef {\n+            Ok(adjustment::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n                     Decodable::decode(this)\n                 }).unwrap(),\n@@ -1296,7 +1297,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_autoref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                            -> ty::AutoRef<'tcx> {\n+                            -> adjustment::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1311,15 +1312,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Decodable::decode(this)\n                             }).unwrap();\n \n-                        ty::AutoPtr(dcx.tcx.mk_region(r), m)\n+                        adjustment::AutoPtr(dcx.tcx.mk_region(r), m)\n                     }\n                     1 => {\n                         let m: hir::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoUnsafe(m)\n+                        adjustment::AutoUnsafe(m)\n                     }\n-                    _ => panic!(\"bad enum variant for ty::AutoRef\")\n+                    _ => panic!(\"bad enum variant for adjustment::AutoRef\")\n                 })\n             })\n         }).unwrap()\n@@ -1467,7 +1468,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n+                        let adj =\n+                            val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n                     c::tag_table_closure_tys => {"}, {"sha": "661299cd7f3fc0aec502bee21c5ae89e2a0331f9", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -798,8 +798,13 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     match v.tcx.tables.borrow().adjustments.get(&e.id) {\n-        None | Some(&ty::AdjustReifyFnPointer) | Some(&ty::AdjustUnsafeFnPointer) => {}\n-        Some(&ty::AdjustDerefRef(ty::AutoDerefRef { autoderefs, .. })) => {\n+        None |\n+        Some(&ty::adjustment::AdjustReifyFnPointer) |\n+        Some(&ty::adjustment::AdjustUnsafeFnPointer) => {}\n+\n+        Some(&ty::adjustment::AdjustDerefRef(\n+            ty::adjustment::AutoDerefRef { autoderefs, .. }\n+        )) => {\n             if (0..autoderefs as u32).any(|autoderef| {\n                     v.tcx.is_overloaded_autoderef(e.id, autoderef)\n             }) {"}, {"sha": "a8fed5eab16bef2d690c90f5ac9b3cd4d9b153ff", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -25,6 +25,7 @@ use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty;\n+use middle::ty::adjustment;\n \n use rustc_front::hir;\n \n@@ -726,16 +727,16 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment {\n-                ty::AdjustReifyFnPointer |\n-                ty::AdjustUnsafeFnPointer => {\n+                adjustment::AdjustReifyFnPointer |\n+                adjustment::AdjustUnsafeFnPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment(AdjustReifyFnPointer|AdjustUnsafeFnPointer)\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                ty::AdjustDerefRef(ref adj) => {\n+                adjustment::AdjustDerefRef(ref adj) => {\n                     self.walk_autoderefref(expr, adj);\n                 }\n             }\n@@ -778,7 +779,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn walk_autoderefref(&mut self,\n                          expr: &hir::Expr,\n-                         adj: &ty::AutoDerefRef<'tcx>) {\n+                         adj: &adjustment::AutoDerefRef<'tcx>) {\n         debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n                expr,\n                adj);\n@@ -809,7 +810,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<ty::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -828,7 +829,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         };\n \n         match *autoref {\n-            ty::AutoPtr(r, m) => {\n+            adjustment::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -837,7 +838,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                      AutoRef);\n             }\n \n-            ty::AutoUnsafe(m) => {\n+            adjustment::AutoUnsafe(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "ffb631e105b3a0bf05895ed4201ff67b4c76b6cb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -30,6 +30,7 @@ use middle::subst::Substs;\n use middle::subst::Subst;\n use middle::traits::{self, FulfillmentContext, Normalized,\n                      SelectionContext, ObligationCause};\n+use middle::ty::adjustment;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n                           expr: &hir::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n         let raw_ty = self.expr_ty(expr);\n@@ -1485,9 +1486,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n             &tables.adjustments\n         }\n "}, {"sha": "dd2f48d25b4b0c6cc00c69dbd56b508fa824e141", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -77,6 +77,7 @@ use front::map as ast_map;\n use middle::infer;\n use middle::check_const;\n use middle::def;\n+use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n \n use rustc_front::hir::{MutImmutable, MutMutable};\n@@ -421,16 +422,16 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustDerefRef(\n-                        ty::AutoDerefRef {\n+                    adjustment::AdjustDerefRef(\n+                        adjustment::AutoDerefRef {\n                             autoref: None, unsize: None, autoderefs, ..}) => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    ty::AdjustReifyFnPointer |\n-                    ty::AdjustUnsafeFnPointer |\n-                    ty::AdjustDerefRef(_) => {\n+                    adjustment::AdjustReifyFnPointer |\n+                    adjustment::AdjustUnsafeFnPointer |\n+                    adjustment::AdjustDerefRef(_) => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "cadab499c0765573225589f1b09f713ffc4e5b1e", "filename": "src/librustc/middle/ty/adjustment.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fadjustment.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::AutoAdjustment::*;\n+pub use self::AutoRef::*;\n+\n+use middle::ty::{self, Ty, TypeAndMut};\n+use middle::ty::HasTypeFlags;\n+use middle::ty::LvaluePreference::{NoPreference};\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+\n+#[derive(Copy, Clone)]\n+pub enum AutoAdjustment<'tcx> {\n+    AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n+    AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustDerefRef(AutoDerefRef<'tcx>),\n+}\n+\n+/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+///\n+/// We transform pointers by following the following steps in order:\n+/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+///    `&` or `*` pointer.\n+/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+///    which will do things like convert thin pointers to fat\n+///    pointers, or convert structs containing thin pointers to\n+///    structs containing fat pointers, or convert between fat\n+///    pointers.  We don't store the details of how the transform is\n+///    done (in fact, we don't know that, because it might depend on\n+///    the precise type parameters). We just store the target\n+///    type. Trans figures out what has to be done at monomorphization\n+///    time based on the precise source/target type at hand.\n+///\n+/// To make that more concrete, here are some common scenarios:\n+///\n+/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+/// Here the pointer will be dereferenced N times (where a dereference can\n+/// happen to to raw or borrowed pointers or any smart pointer which implements\n+/// Deref, including Box<_>). The number of dereferences is given by\n+/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+/// None.\n+///\n+/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// with a thin pointer, deref a number of times, unsize the underlying data,\n+/// then autoref. The 'unsize' phase may change a fixed length array to a\n+/// dynamically sized one, a concrete object to a trait object, or statically\n+/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+/// represented by:\n+///\n+/// ```\n+/// AutoDerefRef {\n+///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n+///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+/// }\n+/// ```\n+///\n+/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+/// The autoderef and -ref are the same as in the above example, but the type\n+/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+/// the underlying conversions from `[i32; 4]` to `[i32]`.\n+///\n+/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// that case, we have the pointer we need coming in, so there are no\n+/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+/// At some point, of course, `Box` should move out of the compiler, in which\n+/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// Box<[i32]> is represented by:\n+///\n+/// ```\n+/// AutoDerefRef {\n+///     autoderefs: 0,\n+///     autoref: None,\n+///     unsize: Some(Box<[i32]>),\n+/// }\n+/// ```\n+#[derive(Copy, Clone)]\n+pub struct AutoDerefRef<'tcx> {\n+    /// Step 1. Apply a number of dereferences, producing an lvalue.\n+    pub autoderefs: usize,\n+\n+    /// Step 2. Optionally produce a pointer/reference from the value.\n+    pub autoref: Option<AutoRef<'tcx>>,\n+\n+    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. The stored type is the target pointer type. Note that\n+    /// the source could be a thin or fat pointer.\n+    pub unsize: Option<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> AutoAdjustment<'tcx> {\n+    pub fn is_identity(&self) -> bool {\n+        match *self {\n+            AdjustReifyFnPointer |\n+            AdjustUnsafeFnPointer => false,\n+            AdjustDerefRef(ref r) => r.is_identity(),\n+        }\n+    }\n+}\n+impl<'tcx> AutoDerefRef<'tcx> {\n+    pub fn is_identity(&self) -> bool {\n+        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum AutoRef<'tcx> {\n+    /// Convert from T to &T.\n+    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+\n+    /// Convert from T to *T.\n+    /// Value to thin pointer.\n+    AutoUnsafe(hir::Mutability),\n+}\n+\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum CustomCoerceUnsized {\n+    /// Records the index of the field being coerced.\n+    Struct(usize)\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    /// See `expr_ty_adjusted`\n+    pub fn adjust<F>(&'tcx self, cx: &ty::ctxt<'tcx>,\n+                     span: Span,\n+                     expr_id: ast::NodeId,\n+                     adjustment: Option<&AutoAdjustment<'tcx>>,\n+                     mut method_type: F)\n+                     -> Ty<'tcx> where\n+        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n+    {\n+        if let ty::TyError = self.sty {\n+            return self;\n+        }\n+\n+        return match adjustment {\n+            Some(adjustment) => {\n+                match *adjustment {\n+                   AdjustReifyFnPointer => {\n+                        match self.sty {\n+                            ty::TyBareFn(Some(_), b) => {\n+                                cx.mk_fn(None, b)\n+                            }\n+                            _ => {\n+                                cx.sess.bug(\n+                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                              {:?}\", self));\n+                            }\n+                        }\n+                    }\n+\n+                   AdjustUnsafeFnPointer => {\n+                        match self.sty {\n+                            ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n+                            ref b => {\n+                                cx.sess.bug(\n+                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                             {:?}\",\n+                                            b));\n+                            }\n+                        }\n+                   }\n+\n+                    AdjustDerefRef(ref adj) => {\n+                        let mut adjusted_ty = self;\n+\n+                        if !adjusted_ty.references_error() {\n+                            for i in 0..adj.autoderefs {\n+                                adjusted_ty =\n+                                    adjusted_ty.adjust_for_autoderef(cx,\n+                                                                     expr_id,\n+                                                                     span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n+                            }\n+                        }\n+\n+                        if let Some(target) = adj.unsize {\n+                            target\n+                        } else {\n+                            adjusted_ty.adjust_for_autoref(cx, adj.autoref)\n+                        }\n+                    }\n+                }\n+            }\n+            None => self\n+        };\n+    }\n+\n+    pub fn adjust_for_autoderef<F>(&'tcx self,\n+                                   cx: &ty::ctxt<'tcx>,\n+                                   expr_id: ast::NodeId,\n+                                   expr_span: Span,\n+                                   autoderef: u32, // how many autoderefs so far?\n+                                   mut method_type: F)\n+                                   -> Ty<'tcx> where\n+        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n+    {\n+        let method_call = ty::MethodCall::autoderef(expr_id, autoderef);\n+        let mut adjusted_ty = self;\n+        if let Some(method_ty) = method_type(method_call) {\n+            // Method calls always have all late-bound regions\n+            // fully instantiated.\n+            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+            adjusted_ty = fn_ret.unwrap();\n+        }\n+        match adjusted_ty.builtin_deref(true, NoPreference) {\n+            Some(mt) => mt.ty,\n+            None => {\n+                cx.sess.span_bug(\n+                    expr_span,\n+                    &format!(\"the {}th autoderef failed: {}\",\n+                             autoderef,\n+                             adjusted_ty)\n+                        );\n+            }\n+        }\n+    }\n+\n+    pub fn adjust_for_autoref(&'tcx self, cx: &ty::ctxt<'tcx>,\n+                              autoref: Option<AutoRef<'tcx>>)\n+                              -> Ty<'tcx> {\n+        match autoref {\n+            None => self,\n+            Some(AutoPtr(r, m)) => {\n+                cx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n+            }\n+            Some(AutoUnsafe(m)) => {\n+                cx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n+            }\n+        }\n+    }\n+}"}, {"sha": "e3b6da56680da303b5657aec0a52ecfe4cd93a81", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -106,7 +106,7 @@ pub struct Tables<'tcx> {\n     /// other items.\n     pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::AutoAdjustment<'tcx>>,\n+    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n \n     pub method_map: ty::MethodMap<'tcx>,\n \n@@ -308,7 +308,7 @@ pub struct ctxt<'tcx> {\n     pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::CustomCoerceUnsized>>,\n+    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n \n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself."}, {"sha": "751bac28ce4c2aa7c0037bd897ef2a24c64bd03c", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -36,6 +36,7 @@\n \n use middle::region;\n use middle::subst;\n+use middle::ty::adjustment;\n use middle::ty::{self, Binder, Ty, HasTypeFlags, RegionEscape};\n \n use std::fmt;\n@@ -128,7 +129,8 @@ pub trait TypeFolder<'tcx> : Sized {\n         super_fold_existential_bounds(self, s)\n     }\n \n-    fn fold_autoref(&mut self, ar: &ty::AutoRef<'tcx>) -> ty::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n+                    -> adjustment::AutoRef<'tcx> {\n         super_fold_autoref(self, ar)\n     }\n \n@@ -296,15 +298,15 @@ pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n }\n \n pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                     autoref: &ty::AutoRef<'tcx>)\n-                                                     -> ty::AutoRef<'tcx>\n+                                                     autoref: &adjustment::AutoRef<'tcx>)\n+                                                     -> adjustment::AutoRef<'tcx>\n {\n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n+        adjustment::AutoPtr(r, m) => {\n             let r = r.fold_with(this);\n-            ty::AutoPtr(this.tcx().mk_region(r), m)\n+            adjustment::AutoPtr(this.tcx().mk_region(r), m)\n         }\n-        ty::AutoUnsafe(m) => ty::AutoUnsafe(m)\n+        adjustment::AutoUnsafe(m) => adjustment::AutoUnsafe(m)\n     }\n }\n "}, {"sha": "dff423b35dd0a59c5799a6aafdab8146c0adccc5", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 1198, "changes": 1203, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -11,30 +11,21 @@\n pub use self::ImplOrTraitItemId::*;\n pub use self::ClosureKind::*;\n pub use self::Variance::*;\n-pub use self::AutoAdjustment::*;\n-pub use self::Representability::*;\n-pub use self::AutoRef::*;\n pub use self::DtorKind::*;\n pub use self::ExplicitSelfCategory::*;\n pub use self::ImplOrTraitItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n-pub use self::CopyImplementationError::*;\n pub use self::LvaluePreference::*;\n \n-use back::svh::Svh;\n use front::map as ast_map;\n use front::map::LinkedPath;\n use metadata::csearch;\n use middle;\n-use middle::const_eval::{self, ConstVal, ErrKind};\n-use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def::{self, ExportMap};\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n-use middle::infer;\n-use middle::pat_util;\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n@@ -43,12 +34,10 @@ use middle::ty::walk::TypeWalker;\n use util::common::memoized;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n use util::nodemap::FnvHashMap;\n-use util::num::ToPrimitive;\n \n use std::borrow::{Borrow, Cow};\n use std::cell::{Cell, RefCell};\n-use std::cmp;\n-use std::hash::{Hash, SipHasher, Hasher};\n+use std::hash::{Hash, Hasher};\n use std::iter;\n use std::rc::Rc;\n use std::slice;\n@@ -61,7 +50,7 @@ use syntax::parse::token::{InternedString, special_idents};\n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait};\n use rustc_front::hir::{MutImmutable, MutMutable, Visibility};\n-use rustc_front::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n+use rustc_front::attr::{self, AttrMetaMethods};\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n@@ -86,6 +75,7 @@ pub use self::contents::TypeContents;\n pub use self::context::{ctxt, tls};\n pub use self::context::{CtxtArenas, Lift, Tables};\n \n+pub mod adjustment;\n pub mod cast;\n pub mod error;\n pub mod fast_reject;\n@@ -95,6 +85,7 @@ pub mod outlives;\n pub mod relate;\n pub mod walk;\n pub mod wf;\n+pub mod util;\n \n mod contents;\n mod context;\n@@ -104,7 +95,6 @@ mod structural_impls;\n mod sty;\n \n pub type Disr = u64;\n-\n pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n@@ -143,126 +133,6 @@ impl DtorKind {\n     }\n }\n \n-pub trait IntTypeExt {\n-    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n-    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n-    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n-    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n-    fn disr_string(&self, val: Disr) -> String;\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n-}\n-\n-impl IntTypeExt for attr::IntType {\n-    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            SignedInt(hir::TyI8)      => cx.types.i8,\n-            SignedInt(hir::TyI16)     => cx.types.i16,\n-            SignedInt(hir::TyI32)     => cx.types.i32,\n-            SignedInt(hir::TyI64)     => cx.types.i64,\n-            SignedInt(hir::TyIs)   => cx.types.isize,\n-            UnsignedInt(hir::TyU8)    => cx.types.u8,\n-            UnsignedInt(hir::TyU16)   => cx.types.u16,\n-            UnsignedInt(hir::TyU32)   => cx.types.u32,\n-            UnsignedInt(hir::TyU64)   => cx.types.u64,\n-            UnsignedInt(hir::TyUs) => cx.types.usize,\n-        }\n-    }\n-\n-    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n-        match *self {\n-            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n-        }\n-    }\n-\n-    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n-        match *self {\n-            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n-        }\n-    }\n-\n-    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n-        macro_rules! add1 {\n-            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n-        }\n-        match *self {\n-            // SignedInt repr means we *want* to reinterpret the bits\n-            // treating the highest bit of Disr as a sign-bit, so\n-            // cast to i64 before range-checking.\n-            SignedInt(hir::TyI8)    => add1!((val as i64).to_i8()),\n-            SignedInt(hir::TyI16)   => add1!((val as i64).to_i16()),\n-            SignedInt(hir::TyI32)   => add1!((val as i64).to_i32()),\n-            SignedInt(hir::TyI64)   => add1!(Some(val as i64)),\n-\n-            UnsignedInt(hir::TyU8)  => add1!(val.to_u8()),\n-            UnsignedInt(hir::TyU16) => add1!(val.to_u16()),\n-            UnsignedInt(hir::TyU32) => add1!(val.to_u32()),\n-            UnsignedInt(hir::TyU64) => add1!(Some(val)),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n-        }\n-    }\n-\n-    // This returns a String because (1.) it is only used for\n-    // rendering an error message and (2.) a string can represent the\n-    // full range from `i64::MIN` through `u64::MAX`.\n-    fn disr_string(&self, val: Disr) -> String {\n-        match *self {\n-            SignedInt(hir::TyI8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(hir::TyI16)   => format!(\"{}\", val as i16),\n-            SignedInt(hir::TyI32)   => format!(\"{}\", val as i32),\n-            SignedInt(hir::TyI64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(hir::TyU8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(hir::TyU16) => format!(\"{}\", val as u16),\n-            UnsignedInt(hir::TyU32) => format!(\"{}\", val as u32),\n-            UnsignedInt(hir::TyU64) => format!(\"{}\", val as u64),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n-        }\n-    }\n-\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n-        macro_rules! add1 {\n-            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n-        }\n-        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n-        match *self {\n-            SignedInt(hir::TyI8)    => add1!(val as i8 ),\n-            SignedInt(hir::TyI16)   => add1!(val as i16),\n-            SignedInt(hir::TyI32)   => add1!(val as i32),\n-            SignedInt(hir::TyI64)   => add1!(val as i64),\n-            UnsignedInt(hir::TyU8)  => add1!(val as u8 ),\n-            UnsignedInt(hir::TyU16) => add1!(val as u16),\n-            UnsignedInt(hir::TyU32) => add1!(val as u32),\n-            UnsignedInt(hir::TyU64) => add1!(val as u64),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(DefId),\n@@ -435,105 +305,6 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Copy, Clone)]\n-pub enum AutoAdjustment<'tcx> {\n-    AdjustReifyFnPointer,   // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,  // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>),\n-}\n-\n-/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-///\n-/// We transform pointers by following the following steps in order:\n-/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n-///\n-/// To make that more concrete, here are some common scenarios:\n-///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The number of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// None.\n-///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-/// }\n-/// ```\n-///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n-///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 0,\n-///     autoref: None,\n-///     unsize: Some(Box<[i32]>),\n-/// }\n-/// ```\n-#[derive(Copy, Clone)]\n-pub struct AutoDerefRef<'tcx> {\n-    /// Step 1. Apply a number of dereferences, producing an lvalue.\n-    pub autoderefs: usize,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoRef<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. The stored type is the target pointer type. Note that\n-    /// the source could be a thin or fat pointer.\n-    pub unsize: Option<Ty<'tcx>>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum AutoRef<'tcx> {\n-    /// Convert from T to &T.\n-    AutoPtr(&'tcx Region, hir::Mutability),\n-\n-    /// Convert from T to *T.\n-    /// Value to thin pointer.\n-    AutoUnsafe(hir::Mutability),\n-}\n-\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n-pub enum CustomCoerceUnsized {\n-    /// Records the index of the field being coerced.\n-    Struct(usize)\n-}\n-\n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n@@ -1502,52 +1273,6 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    pub fn can_type_implement_copy(&self, self_type: Ty<'tcx>, span: Span)\n-                                   -> Result<(),CopyImplementationError> {\n-        let tcx = self.tcx;\n-\n-        // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n-\n-        let adt = match self_type.sty {\n-            ty::TyStruct(struct_def, substs) => {\n-                for field in struct_def.all_fields() {\n-                    let field_ty = field.ty(tcx, substs);\n-                    if infcx.type_moves_by_default(field_ty, span) {\n-                        return Err(FieldDoesNotImplementCopy(field.name))\n-                    }\n-                }\n-                struct_def\n-            }\n-            ty::TyEnum(enum_def, substs) => {\n-                for variant in &enum_def.variants {\n-                    for field in &variant.fields {\n-                        let field_ty = field.ty(tcx, substs);\n-                        if infcx.type_moves_by_default(field_ty, span) {\n-                            return Err(VariantDoesNotImplementCopy(variant.name))\n-                        }\n-                    }\n-                }\n-                enum_def\n-            }\n-            _ => return Err(TypeIsStructural),\n-        };\n-\n-        if adt.has_dtor() {\n-            return Err(TypeHasDestructor)\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum CopyImplementationError {\n-    FieldDoesNotImplementCopy(Name),\n-    VariantDoesNotImplementCopy(Name),\n-    TypeIsStructural,\n-    TypeHasDestructor,\n }\n \n /// A \"type scheme\", in ML terminology, is a type combined with some\n@@ -2093,16 +1818,6 @@ impl ClosureKind {\n     }\n }\n \n-impl<'tcx> ctxt<'tcx> {\n-    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n-    }\n-\n-    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n-    }\n-}\n-\n impl<'tcx> TyS<'tcx> {\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n@@ -2125,63 +1840,6 @@ impl<'tcx> TyS<'tcx> {\n         walk::walk_shallow(self)\n     }\n \n-    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n-        match self.sty {\n-            ty::TyParam(ref d) => Some(d.clone()),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_param(&self, space: ParamSpace, index: u32) -> bool {\n-        match self.sty {\n-            ty::TyParam(ref data) => data.space == space && data.idx == index,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns the regions directly referenced from this type (but\n-    /// not types reachable from this type via `walk_tys`). This\n-    /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<ty::Region> {\n-        match self.sty {\n-            TyRef(region, _) => {\n-                vec![*region]\n-            }\n-            TyTrait(ref obj) => {\n-                let mut v = vec![obj.bounds.region_bound];\n-                v.push_all(obj.principal.skip_binder().substs.regions().as_slice());\n-                v\n-            }\n-            TyEnum(_, substs) |\n-            TyStruct(_, substs) => {\n-                substs.regions().as_slice().to_vec()\n-            }\n-            TyClosure(_, ref substs) => {\n-                substs.func_substs.regions().as_slice().to_vec()\n-            }\n-            TyProjection(ref data) => {\n-                data.trait_ref.substs.regions().as_slice().to_vec()\n-            }\n-            TyBareFn(..) |\n-            TyBool |\n-            TyChar |\n-            TyInt(_) |\n-            TyUint(_) |\n-            TyFloat(_) |\n-            TyBox(_) |\n-            TyStr |\n-            TyArray(_, _) |\n-            TySlice(_) |\n-            TyRawPtr(_) |\n-            TyTuple(_) |\n-            TyParam(_) |\n-            TyInfer(_) |\n-            TyError => {\n-                vec![]\n-            }\n-        }\n-    }\n-\n     /// Walks `ty` and any types appearing within `ty`, invoking the\n     /// callback `f` on each type. If the callback returns false, then the\n     /// children of the current type are ignored.\n@@ -2199,31 +1857,6 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl ParamTy {\n-    pub fn new(space: subst::ParamSpace,\n-               index: u32,\n-               name: Name)\n-               -> ParamTy {\n-        ParamTy { space: space, idx: index, name: name }\n-    }\n-\n-    pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n-    }\n-\n-    pub fn for_def(def: &TypeParameterDef) -> ParamTy {\n-        ParamTy::new(def.space, def.index, def.name)\n-    }\n-\n-    pub fn to_ty<'tcx>(self, tcx: &ctxt<'tcx>) -> Ty<'tcx> {\n-        tcx.mk_param(self.space, self.idx, self.name)\n-    }\n-\n-    pub fn is_self(&self) -> bool {\n-        self.space == subst::SelfSpace && self.idx == 0\n-    }\n-}\n-\n impl<'tcx> ItemSubsts<'tcx> {\n     pub fn empty() -> ItemSubsts<'tcx> {\n         ItemSubsts { substs: Substs::empty() }\n@@ -2234,99 +1867,6 @@ impl<'tcx> ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                       bound: ty::BuiltinBound,\n-                       span: Span)\n-                       -> bool\n-    {\n-        let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n-\n-        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n-                                                                self, bound, span);\n-\n-        debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n-               self, bound, is_impld);\n-\n-        is_impld\n-    }\n-\n-    // FIXME (@jroesch): I made this public to use it, not sure if should be private\n-    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                           span: Span) -> bool {\n-        if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n-        }\n-\n-        assert!(!self.needs_infer());\n-\n-        // Fast-path for primitive types\n-        let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeAndMut {\n-                mutbl: hir::MutImmutable, ..\n-            }) => Some(false),\n-\n-            TyStr | TyBox(..) | TyRef(_, TypeAndMut {\n-                mutbl: hir::MutMutable, ..\n-            }) => Some(true),\n-\n-            TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) |\n-            TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n-        }.unwrap_or_else(|| !self.impls_bound(param_env, ty::BoundCopy, span));\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n-            } else {\n-                TypeFlags::MOVENESS_CACHED\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    #[inline]\n-    pub fn is_sized<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                        span: Span) -> bool\n-    {\n-        if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::IS_SIZED);\n-        }\n-\n-        self.is_sized_uncached(param_env, span)\n-    }\n-\n-    fn is_sized_uncached<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                             span: Span) -> bool {\n-        assert!(!self.needs_infer());\n-\n-        // Fast-path for primitive types\n-        let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyBareFn(..) |\n-            TyArray(..) | TyTuple(..) | TyClosure(..) => Some(true),\n-\n-            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n-\n-            TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n-            TyInfer(..) | TyError => None\n-        }.unwrap_or_else(|| self.impls_bound(param_env, ty::BoundSized, span));\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n-            } else {\n-                TypeFlags::SIZEDNESS_CACHED\n-            });\n-        }\n-\n-        result\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n@@ -2342,283 +1882,6 @@ impl LvaluePreference {\n     }\n }\n \n-/// Describes whether a type is representable. For types that are not\n-/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n-/// distinguish between types that are recursive with themselves and types that\n-/// contain a different recursive type. These cases can therefore be treated\n-/// differently when reporting errors.\n-///\n-/// The ordering of the cases is significant. They are sorted so that cmp::max\n-/// will keep the \"more erroneous\" of two values.\n-#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n-pub enum Representability {\n-    Representable,\n-    ContainsRecursive,\n-    SelfRecursive,\n-}\n-\n-impl<'tcx> TyS<'tcx> {\n-    /// Check whether a type is representable. This means it cannot contain unboxed\n-    /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, cx: &ctxt<'tcx>, sp: Span) -> Representability {\n-\n-        // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &ctxt<'tcx>, sp: Span,\n-                                                                    seen: &mut Vec<Ty<'tcx>>,\n-                                                                    iter: It)\n-                                                                    -> Representability {\n-            iter.fold(Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n-        }\n-\n-        fn are_inner_types_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n-                                           seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n-                                           -> Representability {\n-            match ty.sty {\n-                TyTuple(ref ts) => {\n-                    find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n-                }\n-                // Fixed-length vectors.\n-                // FIXME(#11924) Behavior undecided for zero-length vectors.\n-                TyArray(ty, _) => {\n-                    is_type_structurally_recursive(cx, sp, seen, ty)\n-                }\n-                TyStruct(def, substs) | TyEnum(def, substs) => {\n-                    find_nonrepresentable(cx,\n-                                          sp,\n-                                          seen,\n-                                          def.all_fields().map(|f| f.ty(cx, substs)))\n-                }\n-                TyClosure(..) => {\n-                    // this check is run on type definitions, so we don't expect\n-                    // to see closure types\n-                    cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n-                }\n-                _ => Representable,\n-            }\n-        }\n-\n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: AdtDef<'tcx>) -> bool {\n-            match ty.sty {\n-                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n-                     ty_def == def\n-                }\n-                _ => false\n-            }\n-        }\n-\n-        fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-            match (&a.sty, &b.sty) {\n-                (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n-                (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n-                    if did_a != did_b {\n-                        return false;\n-                    }\n-\n-                    let types_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let types_b = substs_b.types.get_slice(subst::TypeSpace);\n-\n-                    let mut pairs = types_a.iter().zip(types_b);\n-\n-                    pairs.all(|(&a, &b)| same_type(a, b))\n-                }\n-                _ => {\n-                    a == b\n-                }\n-            }\n-        }\n-\n-        // Does the type `ty` directly (without indirection through a pointer)\n-        // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n-                                                seen: &mut Vec<Ty<'tcx>>,\n-                                                ty: Ty<'tcx>) -> Representability {\n-            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n-\n-            match ty.sty {\n-                TyStruct(def, _) | TyEnum(def, _) => {\n-                    {\n-                        // Iterate through stack of previously seen types.\n-                        let mut iter = seen.iter();\n-\n-                        // The first item in `seen` is the type we are actually curious about.\n-                        // We want to return SelfRecursive if this type contains itself.\n-                        // It is important that we DON'T take generic parameters into account\n-                        // for this check, so that Bar<T> in this example counts as SelfRecursive:\n-                        //\n-                        // struct Foo;\n-                        // struct Bar<T> { x: Bar<Foo> }\n-\n-                        match iter.next() {\n-                            Some(&seen_type) => {\n-                                if same_struct_or_enum(seen_type, def) {\n-                                    debug!(\"SelfRecursive: {:?} contains {:?}\",\n-                                           seen_type,\n-                                           ty);\n-                                    return SelfRecursive;\n-                                }\n-                            }\n-                            None => {}\n-                        }\n-\n-                        // We also need to know whether the first item contains other types\n-                        // that are structurally recursive. If we don't catch this case, we\n-                        // will recurse infinitely for some inputs.\n-                        //\n-                        // It is important that we DO take generic parameters into account\n-                        // here, so that code like this is considered SelfRecursive, not\n-                        // ContainsRecursive:\n-                        //\n-                        // struct Foo { Option<Option<Foo>> }\n-\n-                        for &seen_type in iter {\n-                            if same_type(ty, seen_type) {\n-                                debug!(\"ContainsRecursive: {:?} contains {:?}\",\n-                                       seen_type,\n-                                       ty);\n-                                return ContainsRecursive;\n-                            }\n-                        }\n-                    }\n-\n-                    // For structs and enums, track all previously seen types by pushing them\n-                    // onto the 'seen' stack.\n-                    seen.push(ty);\n-                    let out = are_inner_types_recursive(cx, sp, seen, ty);\n-                    seen.pop();\n-                    out\n-                }\n-                _ => {\n-                    // No need to push in other cases.\n-                    are_inner_types_recursive(cx, sp, seen, ty)\n-                }\n-            }\n-        }\n-\n-        debug!(\"is_type_representable: {:?}\", self);\n-\n-        // To avoid a stack overflow when checking an enum variant or struct that\n-        // contains a different, structurally recursive type, maintain a stack\n-        // of seen types and check recursion for each of them (issues #3008, #3779).\n-        let mut seen: Vec<Ty> = Vec::new();\n-        let r = is_type_structurally_recursive(cx, sp, &mut seen, self);\n-        debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n-        r\n-    }\n-\n-    /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self, cx: &ctxt<'tcx>,\n-                     span: Span,\n-                     expr_id: NodeId,\n-                     adjustment: Option<&AutoAdjustment<'tcx>>,\n-                     mut method_type: F)\n-                     -> Ty<'tcx> where\n-        F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        if let TyError = self.sty {\n-            return self;\n-        }\n-\n-        return match adjustment {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                   AdjustReifyFnPointer => {\n-                        match self.sty {\n-                            ty::TyBareFn(Some(_), b) => {\n-                                cx.mk_fn(None, b)\n-                            }\n-                            _ => {\n-                                cx.sess.bug(\n-                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                              {:?}\", self));\n-                            }\n-                        }\n-                    }\n-\n-                   AdjustUnsafeFnPointer => {\n-                        match self.sty {\n-                            ty::TyBareFn(None, b) => cx.safe_to_unsafe_fn_ty(b),\n-                            ref b => {\n-                                cx.sess.bug(\n-                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                             {:?}\",\n-                                            b));\n-                            }\n-                        }\n-                   }\n-\n-                    AdjustDerefRef(ref adj) => {\n-                        let mut adjusted_ty = self;\n-\n-                        if !adjusted_ty.references_error() {\n-                            for i in 0..adj.autoderefs {\n-                                adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(cx,\n-                                                                     expr_id,\n-                                                                     span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                            }\n-                        }\n-\n-                        if let Some(target) = adj.unsize {\n-                            target\n-                        } else {\n-                            adjusted_ty.adjust_for_autoref(cx, adj.autoref)\n-                        }\n-                    }\n-                }\n-            }\n-            None => self\n-        };\n-    }\n-\n-    pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   cx: &ctxt<'tcx>,\n-                                   expr_id: ast::NodeId,\n-                                   expr_span: Span,\n-                                   autoderef: u32, // how many autoderefs so far?\n-                                   mut method_type: F)\n-                                   -> Ty<'tcx> where\n-        F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        let method_call = MethodCall::autoderef(expr_id, autoderef);\n-        let mut adjusted_ty = self;\n-        if let Some(method_ty) = method_type(method_call) {\n-            // Method calls always have all late-bound regions\n-            // fully instantiated.\n-            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-            adjusted_ty = fn_ret.unwrap();\n-        }\n-        match adjusted_ty.builtin_deref(true, NoPreference) {\n-            Some(mt) => mt.ty,\n-            None => {\n-                cx.sess.span_bug(\n-                    expr_span,\n-                    &format!(\"the {}th autoderef failed: {}\",\n-                             autoderef,\n-                             adjusted_ty)\n-                        );\n-            }\n-        }\n-    }\n-\n-    pub fn adjust_for_autoref(&'tcx self, cx: &ctxt<'tcx>,\n-                              autoref: Option<AutoRef<'tcx>>)\n-                              -> Ty<'tcx> {\n-        match autoref {\n-            None => self,\n-            Some(AutoPtr(r, m)) => {\n-                cx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n-            }\n-            Some(AutoUnsafe(m)) => {\n-                cx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n-            }\n-        }\n-    }\n-\n-}\n-\n /// Helper for looking things up in the various maps that are populated during\n /// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n@@ -2679,45 +1942,6 @@ impl BorrowKind {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n-    /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n-    pub fn positional_element_ty(&self,\n-                                 ty: Ty<'tcx>,\n-                                 i: usize,\n-                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n-                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyEnum(def, substs), None) => {\n-                assert!(def.is_univariant());\n-                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns the type of element at field `n` in struct or struct-like type `t`.\n-    /// For an enum `t`, `variant` must be some def id.\n-    pub fn named_element_ty(&self,\n-                            ty: Ty<'tcx>,\n-                            n: Name,\n-                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n-                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            (&TyEnum(def, substs), Some(vid)) => {\n-                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            _ => return None\n-        }\n-    }\n-\n     pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n@@ -2992,7 +2216,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn custom_coerce_unsized_kind(&self, did: DefId) -> CustomCoerceUnsized {\n+    pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (csearch::get_custom_coerce_unsized_kind(self, did), \"external\")\n@@ -3071,35 +2295,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n-    /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n-    /// and `ty` is the original type (i.e. may include `isize` or\n-    /// `usize`).\n-    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>)\n-                          -> (attr::IntType, Ty<'tcx>) {\n-        let repr_type = match opt_hint {\n-            // Feed in the given type\n-            Some(&attr::ReprInt(_, int_t)) => int_t,\n-            // ... but provide sensible default if none provided\n-            //\n-            // NB. Historically `fn enum_variants` generate i64 here, while\n-            // rustc_typeck::check would generate isize.\n-            _ => SignedInt(hir::TyIs),\n-        };\n-\n-        let repr_type_ty = repr_type.to_ty(self);\n-        let repr_type = match repr_type {\n-            SignedInt(hir::TyIs) =>\n-                SignedInt(self.sess.target.int_type),\n-            UnsignedInt(hir::TyUs) =>\n-                UnsignedInt(self.sess.target.uint_type),\n-            other => other\n-        };\n-\n-        (repr_type, repr_type_ty)\n-    }\n-\n-\n     // Register a given item type\n     pub fn register_item_type(&self, did: DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n@@ -3195,155 +2390,6 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n-\n-    /// Returns the deeply last field of nested structures, or the same type,\n-    /// if not a structure at all. Corresponds to the only possible unsized\n-    /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyStruct(def, substs) = ty.sty {\n-            match def.struct_variant().fields.last() {\n-                Some(f) => ty = f.ty(self, substs),\n-                None => break\n-            }\n-        }\n-        ty\n-    }\n-\n-    /// Same as applying struct_tail on `source` and `target`, but only\n-    /// keeps going as long as the two types are instances of the same\n-    /// structure definitions.\n-    /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n-    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(&self,\n-                                 source: Ty<'tcx>,\n-                                 target: Ty<'tcx>)\n-                                 -> (Ty<'tcx>, Ty<'tcx>) {\n-        let (mut a, mut b) = (source, target);\n-        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def {\n-                break;\n-            }\n-            if let Some(f) = a_def.struct_variant().fields.last() {\n-                a = f.ty(self, a_substs);\n-                b = f.ty(self, b_substs);\n-            } else {\n-                break;\n-            }\n-        }\n-        (a, b)\n-    }\n-\n-    // Returns the repeat count for a repeating vector expression.\n-    pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n-        let hint = UncheckedExprHint(self.types.usize);\n-        match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n-            Ok(val) => {\n-                let found = match val {\n-                    ConstVal::Uint(count) => return count as usize,\n-                    ConstVal::Int(count) if count >= 0 => return count as usize,\n-                    const_val => const_val.description(),\n-                };\n-                span_err!(self.sess, count_expr.span, E0306,\n-                    \"expected positive integer for repeat count, found {}\",\n-                    found);\n-            }\n-            Err(err) => {\n-                let err_msg = match count_expr.node {\n-                    hir::ExprPath(None, hir::Path {\n-                        global: false,\n-                        ref segments,\n-                        ..\n-                    }) if segments.len() == 1 =>\n-                        format!(\"found variable\"),\n-                    _ => match err.kind {\n-                        ErrKind::MiscCatchAll => format!(\"but found {}\", err.description()),\n-                        _ => format!(\"but {}\", err.description())\n-                    }\n-                };\n-                span_err!(self.sess, count_expr.span, E0307,\n-                    \"expected constant integer for repeat count, {}\", err_msg);\n-            }\n-        }\n-        0\n-    }\n-\n-    // Iterate over a type parameter's bounded traits and any supertraits\n-    // of those traits, ignoring kinds.\n-    // Here, the supertraits are the transitive closure of the supertrait\n-    // relation on the supertraits from each bounded trait's constraint\n-    // list.\n-    pub fn each_bound_trait_and_supertraits<F>(&self,\n-                                               bounds: &[PolyTraitRef<'tcx>],\n-                                               mut f: F)\n-                                               -> bool where\n-        F: FnMut(PolyTraitRef<'tcx>) -> bool,\n-    {\n-        for bound_trait_ref in traits::transitive_bounds(self, bounds) {\n-            if !f(bound_trait_ref) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /// Given a set of predicates that apply to an object type, returns\n-    /// the region bounds that the (erased) `Self` type must\n-    /// outlive. Precisely *because* the `Self` type is erased, the\n-    /// parameter `erased_self_ty` must be supplied to indicate what type\n-    /// has been used to represent `Self` in the predicates\n-    /// themselves. This should really be a unique type; `FreshTy(0)` is a\n-    /// popular choice.\n-    ///\n-    /// NB: in some cases, particularly around higher-ranked bounds,\n-    /// this function returns a kind of conservative approximation.\n-    /// That is, all regions returned by this function are definitely\n-    /// required, but there may be other region bounds that are not\n-    /// returned, as well as requirements like `for<'a> T: 'a`.\n-    ///\n-    /// Requires that trait definitions have been processed so that we can\n-    /// elaborate predicates and walk supertraits.\n-    pub fn required_region_bounds(&self,\n-                                  erased_self_ty: Ty<'tcx>,\n-                                  predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<ty::Region>    {\n-        debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-               erased_self_ty,\n-               predicates);\n-\n-        assert!(!erased_self_ty.has_escaping_regions());\n-\n-        traits::elaborate_predicates(self, predicates)\n-            .filter_map(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::RegionOutlives(..) => {\n-                        None\n-                    }\n-                    ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n-                        // Search for a bound of the form `erased_self_ty\n-                        // : 'a`, but be wary of something like `for<'a>\n-                        // erased_self_ty : 'a` (we interpret a\n-                        // higher-ranked bound like that as 'static,\n-                        // though at present the code in `fulfill.rs`\n-                        // considers such bounds to be unsatisfiable, so\n-                        // it's kind of a moot point since you could never\n-                        // construct such an object, but this seems\n-                        // correct even if that code changes).\n-                        if t == erased_self_ty && !r.has_escaping_regions() {\n-                            Some(r)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n@@ -3527,148 +2573,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    /// Creates a hash of the type `Ty` which will be the same no matter what crate\n-    /// context it's calculated within. This is used by the `type_id` intrinsic.\n-    pub fn hash_crate_independent(&self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n-        let mut state = SipHasher::new();\n-        helper(self, ty, svh, &mut state);\n-        return state.finish();\n-\n-        fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n-                        state: &mut SipHasher) {\n-            macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n-            macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n-\n-            let region = |state: &mut SipHasher, r: Region| {\n-                match r {\n-                    ReStatic => {}\n-                    ReLateBound(db, BrAnon(i)) => {\n-                        db.hash(state);\n-                        i.hash(state);\n-                    }\n-                    ReEmpty |\n-                    ReEarlyBound(..) |\n-                    ReLateBound(..) |\n-                    ReFree(..) |\n-                    ReScope(..) |\n-                    ReVar(..) |\n-                    ReSkolemized(..) => {\n-                        tcx.sess.bug(\"unexpected region found when hashing a type\")\n-                    }\n-                }\n-            };\n-            let did = |state: &mut SipHasher, did: DefId| {\n-                let h = if did.is_local() {\n-                    svh.clone()\n-                } else {\n-                    tcx.sess.cstore.get_crate_hash(did.krate)\n-                };\n-                h.as_str().hash(state);\n-                did.node.hash(state);\n-            };\n-            let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n-                mt.mutbl.hash(state);\n-            };\n-            let fn_sig = |state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n-                let sig = tcx.anonymize_late_bound_regions(sig).0;\n-                for a in &sig.inputs { helper(tcx, *a, svh, state); }\n-                if let ty::FnConverging(output) = sig.output {\n-                    helper(tcx, output, svh, state);\n-                }\n-            };\n-            ty.maybe_walk(|ty| {\n-                match ty.sty {\n-                    TyBool => byte!(2),\n-                    TyChar => byte!(3),\n-                    TyInt(i) => {\n-                        byte!(4);\n-                        hash!(i);\n-                    }\n-                    TyUint(u) => {\n-                        byte!(5);\n-                        hash!(u);\n-                    }\n-                    TyFloat(f) => {\n-                        byte!(6);\n-                        hash!(f);\n-                    }\n-                    TyStr => {\n-                        byte!(7);\n-                    }\n-                    TyEnum(d, _) => {\n-                        byte!(8);\n-                        did(state, d.did);\n-                    }\n-                    TyBox(_) => {\n-                        byte!(9);\n-                    }\n-                    TyArray(_, n) => {\n-                        byte!(10);\n-                        n.hash(state);\n-                    }\n-                    TySlice(_) => {\n-                        byte!(11);\n-                    }\n-                    TyRawPtr(m) => {\n-                        byte!(12);\n-                        mt(state, m);\n-                    }\n-                    TyRef(r, m) => {\n-                        byte!(13);\n-                        region(state, *r);\n-                        mt(state, m);\n-                    }\n-                    TyBareFn(opt_def_id, ref b) => {\n-                        byte!(14);\n-                        hash!(opt_def_id);\n-                        hash!(b.unsafety);\n-                        hash!(b.abi);\n-                        fn_sig(state, &b.sig);\n-                        return false;\n-                    }\n-                    TyTrait(ref data) => {\n-                        byte!(17);\n-                        did(state, data.principal_def_id());\n-                        hash!(data.bounds);\n-\n-                        let principal = tcx.anonymize_late_bound_regions(&data.principal).0;\n-                        for subty in &principal.substs.types {\n-                            helper(tcx, subty, svh, state);\n-                        }\n-\n-                        return false;\n-                    }\n-                    TyStruct(d, _) => {\n-                        byte!(18);\n-                        did(state, d.did);\n-                    }\n-                    TyTuple(ref inner) => {\n-                        byte!(19);\n-                        hash!(inner.len());\n-                    }\n-                    TyParam(p) => {\n-                        byte!(20);\n-                        hash!(p.space);\n-                        hash!(p.idx);\n-                        hash!(p.name.as_str());\n-                    }\n-                    TyInfer(_) => unreachable!(),\n-                    TyError => byte!(21),\n-                    TyClosure(d, _) => {\n-                        byte!(22);\n-                        did(state, d);\n-                    }\n-                    TyProjection(ref data) => {\n-                        byte!(23);\n-                        did(state, data.trait_ref.def_id);\n-                        hash!(data.item_name.as_str());\n-                    }\n-                }\n-                true\n-            });\n-        }\n-    }\n-\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment<'a>(&'a self)\n@@ -3786,87 +2690,6 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n-\n-\n-    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n-    /// safe for destruction requires it to be alive\n-    fn is_adt_dtorck(&self, adt: AdtDef<'tcx>) -> bool {\n-        let dtor_method = match adt.destructor() {\n-            Some(dtor) => dtor,\n-            None => return false\n-        };\n-        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n-            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n-        });\n-        let generics = adt.type_scheme(self).generics;\n-\n-        // In `impl<'a> Drop ...`, we automatically assume\n-        // `'a` is meaningful and thus represents a bound\n-        // through which we could reach borrowed data.\n-        //\n-        // FIXME (pnkfelix): In the future it would be good to\n-        // extend the language to allow the user to express,\n-        // in the impl signature, that a lifetime is not\n-        // actually used (something like `where 'a: ?Live`).\n-        if generics.has_region_params(subst::TypeSpace) {\n-            debug!(\"typ: {:?} has interesting dtor due to region params\",\n-                   adt);\n-            return true;\n-        }\n-\n-        let mut seen_items = Vec::new();\n-        let mut items_to_inspect = vec![impl_did];\n-        while let Some(item_def_id) = items_to_inspect.pop() {\n-            if seen_items.contains(&item_def_id) {\n-                continue;\n-            }\n-\n-            for pred in self.lookup_predicates(item_def_id).predicates {\n-                let result = match pred {\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // For now, assume all these where-clauses\n-                        // may give drop implementation capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n-\n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        if self.trait_items(def_id).len() != 0 {\n-                            // If trait has items, assume it adds\n-                            // capability to access borrowed data.\n-                            true\n-                        } else {\n-                            // Trait without items is itself\n-                            // uninteresting from POV of dropck.\n-                            //\n-                            // However, may have parent w/ items;\n-                            // so schedule checking of predicates,\n-                            items_to_inspect.push(def_id);\n-                            // and say \"no capability found\" for now.\n-                            false\n-                        }\n-                    }\n-                };\n-\n-                if result {\n-                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                           adt, pred);\n-                    return true;\n-                }\n-            }\n-\n-            seen_items.push(item_def_id);\n-        }\n-\n-        debug!(\"typ: {:?} is dtorck-safe\", adt);\n-        false\n-    }\n }\n \n /// The category of explicit self.\n@@ -3899,22 +2722,6 @@ pub type TraitMap = NodeMap<Vec<DefId>>;\n // imported.\n pub type GlobMap = HashMap<NodeId, HashSet<Name>>;\n \n-impl<'tcx> AutoAdjustment<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        match *self {\n-            AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer => false,\n-            AdjustDerefRef(ref r) => r.is_identity(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> AutoDerefRef<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n-    }\n-}\n-\n impl<'tcx> ctxt<'tcx> {\n     pub fn with_freevars<T, F>(&self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[Freevar]) -> T,"}, {"sha": "0058ccbce3b19da27543afb5f50536069dbdd490", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -641,8 +641,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::adjustment::AutoRef<'tcx> {\n         folder.fold_autoref(self)\n     }\n }"}, {"sha": "3969738a22e86b94278bb4042612ff9065ddd506", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -24,6 +24,7 @@ use std::ops;\n use std::mem;\n use syntax::abi;\n use syntax::ast::{Name, NodeId};\n+use syntax::parse::token::special_idents;\n \n use rustc_front::hir;\n \n@@ -504,6 +505,31 @@ pub struct ParamTy {\n     pub name: Name,\n }\n \n+impl ParamTy {\n+    pub fn new(space: subst::ParamSpace,\n+               index: u32,\n+               name: Name)\n+               -> ParamTy {\n+        ParamTy { space: space, idx: index, name: name }\n+    }\n+\n+    pub fn for_self() -> ParamTy {\n+        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n+    }\n+\n+    pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n+        ParamTy::new(def.space, def.index, def.name)\n+    }\n+\n+    pub fn to_ty<'tcx>(self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        tcx.mk_param(self.space, self.idx, self.name)\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.space == subst::SelfSpace && self.idx == 0\n+    }\n+}\n+\n /// A [De Bruijn index][dbi] is a standard means of representing\n /// regions (and perhaps later types) in a higher-ranked setting. In\n /// particular, imagine a type like this:\n@@ -844,6 +870,13 @@ impl Region {\n \n // Type utilities\n impl<'tcx> TyS<'tcx> {\n+    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n+        match self.sty {\n+            ty::TyParam(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn is_nil(&self) -> bool {\n         match self.sty {\n             TyTuple(ref tys) => tys.is_empty(),\n@@ -868,6 +901,13 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_bool(&self) -> bool { self.sty == TyBool }\n \n+    pub fn is_param(&self, space: subst::ParamSpace, index: u32) -> bool {\n+        match self.sty {\n+            ty::TyParam(ref data) => data.space == space && data.idx == index,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_self(&self) -> bool {\n         match self.sty {\n             TyParam(ref p) => p.space == subst::SelfSpace,\n@@ -1126,4 +1166,47 @@ impl<'tcx> TyS<'tcx> {\n             _ => None\n         }\n     }\n+\n+    /// Returns the regions directly referenced from this type (but\n+    /// not types reachable from this type via `walk_tys`). This\n+    /// ignores late-bound regions binders.\n+    pub fn regions(&self) -> Vec<ty::Region> {\n+        match self.sty {\n+            TyRef(region, _) => {\n+                vec![*region]\n+            }\n+            TyTrait(ref obj) => {\n+                let mut v = vec![obj.bounds.region_bound];\n+                v.push_all(obj.principal.skip_binder().substs.regions().as_slice());\n+                v\n+            }\n+            TyEnum(_, substs) |\n+            TyStruct(_, substs) => {\n+                substs.regions().as_slice().to_vec()\n+            }\n+            TyClosure(_, ref substs) => {\n+                substs.func_substs.regions().as_slice().to_vec()\n+            }\n+            TyProjection(ref data) => {\n+                data.trait_ref.substs.regions().as_slice().to_vec()\n+            }\n+            TyBareFn(..) |\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyBox(_) |\n+            TyStr |\n+            TyArray(_, _) |\n+            TySlice(_) |\n+            TyRawPtr(_) |\n+            TyTuple(_) |\n+            TyParam(_) |\n+            TyInfer(_) |\n+            TyError => {\n+                vec![]\n+            }\n+        }\n+    }\n }"}, {"sha": "883146185357610d07635437095106548b24a59f", "filename": "src/librustc/middle/ty/util.rs", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -0,0 +1,891 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! misc. type-system utilities too small to deserve their own file\n+\n+use back::svh::Svh;\n+use middle::const_eval::{self, ConstVal, ErrKind};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n+use middle::def_id::DefId;\n+use middle::subst;\n+use middle::infer;\n+use middle::pat_util;\n+use middle::traits;\n+use middle::ty::{self, Ty, TypeAndMut, TypeFlags};\n+use middle::ty::{Disr, ParameterEnvironment};\n+use middle::ty::{HasTypeFlags, RegionEscape};\n+use middle::ty::TypeVariants::*;\n+use util::num::ToPrimitive;\n+\n+use std::cmp;\n+use std::hash::{Hash, SipHasher, Hasher};\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n+\n+pub trait IntTypeExt {\n+    fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n+    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_string(&self, val: Disr) -> String;\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+}\n+\n+impl IntTypeExt for attr::IntType {\n+    fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(hir::TyI8)      => cx.types.i8,\n+            SignedInt(hir::TyI16)     => cx.types.i16,\n+            SignedInt(hir::TyI32)     => cx.types.i32,\n+            SignedInt(hir::TyI64)     => cx.types.i64,\n+            SignedInt(hir::TyIs)   => cx.types.isize,\n+            UnsignedInt(hir::TyU8)    => cx.types.u8,\n+            UnsignedInt(hir::TyU16)   => cx.types.u16,\n+            UnsignedInt(hir::TyU32)   => cx.types.u32,\n+            UnsignedInt(hir::TyU64)   => cx.types.u64,\n+            UnsignedInt(hir::TyUs) => cx.types.usize,\n+        }\n+    }\n+\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n+        macro_rules! add1 {\n+            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n+        }\n+        match *self {\n+            // SignedInt repr means we *want* to reinterpret the bits\n+            // treating the highest bit of Disr as a sign-bit, so\n+            // cast to i64 before range-checking.\n+            SignedInt(hir::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(hir::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(hir::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(hir::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(hir::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(hir::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(hir::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(hir::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    // This returns a String because (1.) it is only used for\n+    // rendering an error message and (2.) a string can represent the\n+    // full range from `i64::MIN` through `u64::MAX`.\n+    fn disr_string(&self, val: Disr) -> String {\n+        match *self {\n+            SignedInt(hir::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(hir::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(hir::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(hir::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(hir::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(hir::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(hir::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(hir::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n+        }\n+        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n+        match *self {\n+            SignedInt(hir::TyI8)    => add1!(val as i8 ),\n+            SignedInt(hir::TyI16)   => add1!(val as i16),\n+            SignedInt(hir::TyI32)   => add1!(val as i32),\n+            SignedInt(hir::TyI64)   => add1!(val as i64),\n+            UnsignedInt(hir::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(hir::TyU16) => add1!(val as u16),\n+            UnsignedInt(hir::TyU32) => add1!(val as u32),\n+            UnsignedInt(hir::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(hir::TyUs) |\n+            SignedInt(hir::TyIs) => unreachable!(),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone)]\n+pub enum CopyImplementationError {\n+    InfrigingField(Name),\n+    InfrigingVariant(Name),\n+    NotAnAdt,\n+    HasDestructor\n+}\n+\n+/// Describes whether a type is representable. For types that are not\n+/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n+/// distinguish between types that are recursive with themselves and types that\n+/// contain a different recursive type. These cases can therefore be treated\n+/// differently when reporting errors.\n+///\n+/// The ordering of the cases is significant. They are sorted so that cmp::max\n+/// will keep the \"more erroneous\" of two values.\n+#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+pub enum Representability {\n+    Representable,\n+    ContainsRecursive,\n+    SelfRecursive,\n+}\n+\n+impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn can_type_implement_copy(&self, self_type: Ty<'tcx>, span: Span)\n+                                   -> Result<(),CopyImplementationError> {\n+        let tcx = self.tcx;\n+\n+        // FIXME: (@jroesch) float this code up\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n+\n+        let adt = match self_type.sty {\n+            ty::TyStruct(struct_def, substs) => {\n+                for field in struct_def.all_fields() {\n+                    let field_ty = field.ty(tcx, substs);\n+                    if infcx.type_moves_by_default(field_ty, span) {\n+                        return Err(CopyImplementationError::InfrigingField(\n+                            field.name))\n+                    }\n+                }\n+                struct_def\n+            }\n+            ty::TyEnum(enum_def, substs) => {\n+                for variant in &enum_def.variants {\n+                    for field in &variant.fields {\n+                        let field_ty = field.ty(tcx, substs);\n+                        if infcx.type_moves_by_default(field_ty, span) {\n+                            return Err(CopyImplementationError::InfrigingVariant(\n+                                variant.name))\n+                        }\n+                    }\n+                }\n+                enum_def\n+            }\n+            _ => return Err(CopyImplementationError::NotAnAdt),\n+        };\n+\n+        if adt.has_dtor() {\n+            return Err(CopyImplementationError::HasDestructor)\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n+        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+    }\n+\n+    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n+        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n+    }\n+\n+    /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n+    /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n+    pub fn positional_element_ty(&self,\n+                                 ty: Ty<'tcx>,\n+                                 i: usize,\n+                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n+        match (&ty.sty, variant) {\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), None) => {\n+                assert!(def.is_univariant());\n+                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyTuple(ref v), None) => v.get(i).cloned(),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns the type of element at field `n` in struct or struct-like type `t`.\n+    /// For an enum `t`, `variant` must be some def id.\n+    pub fn named_element_ty(&self,\n+                            ty: Ty<'tcx>,\n+                            n: Name,\n+                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n+        match (&ty.sty, variant) {\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            _ => return None\n+        }\n+    }\n+\n+    /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n+    /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n+    /// and `ty` is the original type (i.e. may include `isize` or\n+    /// `usize`).\n+    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>)\n+                          -> (attr::IntType, Ty<'tcx>) {\n+        let repr_type = match opt_hint {\n+            // Feed in the given type\n+            Some(&attr::ReprInt(_, int_t)) => int_t,\n+            // ... but provide sensible default if none provided\n+            //\n+            // NB. Historically `fn enum_variants` generate i64 here, while\n+            // rustc_typeck::check would generate isize.\n+            _ => SignedInt(hir::TyIs),\n+        };\n+\n+        let repr_type_ty = repr_type.to_ty(self);\n+        let repr_type = match repr_type {\n+            SignedInt(hir::TyIs) =>\n+                SignedInt(self.sess.target.int_type),\n+            UnsignedInt(hir::TyUs) =>\n+                UnsignedInt(self.sess.target.uint_type),\n+            other => other\n+        };\n+\n+        (repr_type, repr_type_ty)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type,\n+    /// if not a structure at all. Corresponds to the only possible unsized\n+    /// field, and its type can be used to determine unsizing strategy.\n+    pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        while let TyStruct(def, substs) = ty.sty {\n+            match def.struct_variant().fields.last() {\n+                Some(f) => ty = f.ty(self, substs),\n+                None => break\n+            }\n+        }\n+        ty\n+    }\n+\n+    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// keeps going as long as the two types are instances of the same\n+    /// structure definitions.\n+    /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n+    pub fn struct_lockstep_tails(&self,\n+                                 source: Ty<'tcx>,\n+                                 target: Ty<'tcx>)\n+                                 -> (Ty<'tcx>, Ty<'tcx>) {\n+        let (mut a, mut b) = (source, target);\n+        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def {\n+                break;\n+            }\n+            if let Some(f) = a_def.struct_variant().fields.last() {\n+                a = f.ty(self, a_substs);\n+                b = f.ty(self, b_substs);\n+            } else {\n+                break;\n+            }\n+        }\n+        (a, b)\n+    }\n+\n+    /// Returns the repeat count for a repeating vector expression.\n+    pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n+        let hint = UncheckedExprHint(self.types.usize);\n+        match const_eval::eval_const_expr_partial(self, count_expr, hint) {\n+            Ok(val) => {\n+                let found = match val {\n+                    ConstVal::Uint(count) => return count as usize,\n+                    ConstVal::Int(count) if count >= 0 => return count as usize,\n+                    const_val => const_val.description(),\n+                };\n+                span_err!(self.sess, count_expr.span, E0306,\n+                    \"expected positive integer for repeat count, found {}\",\n+                    found);\n+            }\n+            Err(err) => {\n+                let err_msg = match count_expr.node {\n+                    hir::ExprPath(None, hir::Path {\n+                        global: false,\n+                        ref segments,\n+                        ..\n+                    }) if segments.len() == 1 =>\n+                        format!(\"found variable\"),\n+                    _ => match err.kind {\n+                        ErrKind::MiscCatchAll => format!(\"but found {}\", err.description()),\n+                        _ => format!(\"but {}\", err.description())\n+                    }\n+                };\n+                span_err!(self.sess, count_expr.span, E0307,\n+                    \"expected constant integer for repeat count, {}\", err_msg);\n+            }\n+        }\n+        0\n+    }\n+\n+    /// Given a set of predicates that apply to an object type, returns\n+    /// the region bounds that the (erased) `Self` type must\n+    /// outlive. Precisely *because* the `Self` type is erased, the\n+    /// parameter `erased_self_ty` must be supplied to indicate what type\n+    /// has been used to represent `Self` in the predicates\n+    /// themselves. This should really be a unique type; `FreshTy(0)` is a\n+    /// popular choice.\n+    ///\n+    /// NB: in some cases, particularly around higher-ranked bounds,\n+    /// this function returns a kind of conservative approximation.\n+    /// That is, all regions returned by this function are definitely\n+    /// required, but there may be other region bounds that are not\n+    /// returned, as well as requirements like `for<'a> T: 'a`.\n+    ///\n+    /// Requires that trait definitions have been processed so that we can\n+    /// elaborate predicates and walk supertraits.\n+    pub fn required_region_bounds(&self,\n+                                  erased_self_ty: Ty<'tcx>,\n+                                  predicates: Vec<ty::Predicate<'tcx>>)\n+                                  -> Vec<ty::Region>    {\n+        debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n+               erased_self_ty,\n+               predicates);\n+\n+        assert!(!erased_self_ty.has_escaping_regions());\n+\n+        traits::elaborate_predicates(self, predicates)\n+            .filter_map(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::RegionOutlives(..) => {\n+                        None\n+                    }\n+                    ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n+                        // Search for a bound of the form `erased_self_ty\n+                        // : 'a`, but be wary of something like `for<'a>\n+                        // erased_self_ty : 'a` (we interpret a\n+                        // higher-ranked bound like that as 'static,\n+                        // though at present the code in `fulfill.rs`\n+                        // considers such bounds to be unsatisfiable, so\n+                        // it's kind of a moot point since you could never\n+                        // construct such an object, but this seems\n+                        // correct even if that code changes).\n+                        if t == erased_self_ty && !r.has_escaping_regions() {\n+                            Some(r)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    /// Creates a hash of the type `Ty` which will be the same no matter what crate\n+    /// context it's calculated within. This is used by the `type_id` intrinsic.\n+    pub fn hash_crate_independent(&self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n+        let mut state = SipHasher::new();\n+        helper(self, ty, svh, &mut state);\n+        return state.finish();\n+\n+        fn helper<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+                        state: &mut SipHasher) {\n+            macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n+            macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n+\n+            let region = |state: &mut SipHasher, r: ty::Region| {\n+                match r {\n+                    ty::ReStatic => {}\n+                    ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                        db.hash(state);\n+                        i.hash(state);\n+                    }\n+                    ty::ReEmpty |\n+                    ty::ReEarlyBound(..) |\n+                    ty::ReLateBound(..) |\n+                    ty::ReFree(..) |\n+                    ty::ReScope(..) |\n+                    ty::ReVar(..) |\n+                    ty::ReSkolemized(..) => {\n+                        tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                    }\n+                }\n+            };\n+            let did = |state: &mut SipHasher, did: DefId| {\n+                let h = if did.is_local() {\n+                    svh.clone()\n+                } else {\n+                    tcx.sess.cstore.get_crate_hash(did.krate)\n+                };\n+                h.as_str().hash(state);\n+                did.node.hash(state);\n+            };\n+            let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n+                mt.mutbl.hash(state);\n+            };\n+            let fn_sig = |state: &mut SipHasher, sig: &ty::Binder<ty::FnSig<'tcx>>| {\n+                let sig = tcx.anonymize_late_bound_regions(sig).0;\n+                for a in &sig.inputs { helper(tcx, *a, svh, state); }\n+                if let ty::FnConverging(output) = sig.output {\n+                    helper(tcx, output, svh, state);\n+                }\n+            };\n+            ty.maybe_walk(|ty| {\n+                match ty.sty {\n+                    TyBool => byte!(2),\n+                    TyChar => byte!(3),\n+                    TyInt(i) => {\n+                        byte!(4);\n+                        hash!(i);\n+                    }\n+                    TyUint(u) => {\n+                        byte!(5);\n+                        hash!(u);\n+                    }\n+                    TyFloat(f) => {\n+                        byte!(6);\n+                        hash!(f);\n+                    }\n+                    TyStr => {\n+                        byte!(7);\n+                    }\n+                    TyEnum(d, _) => {\n+                        byte!(8);\n+                        did(state, d.did);\n+                    }\n+                    TyBox(_) => {\n+                        byte!(9);\n+                    }\n+                    TyArray(_, n) => {\n+                        byte!(10);\n+                        n.hash(state);\n+                    }\n+                    TySlice(_) => {\n+                        byte!(11);\n+                    }\n+                    TyRawPtr(m) => {\n+                        byte!(12);\n+                        mt(state, m);\n+                    }\n+                    TyRef(r, m) => {\n+                        byte!(13);\n+                        region(state, *r);\n+                        mt(state, m);\n+                    }\n+                    TyBareFn(opt_def_id, ref b) => {\n+                        byte!(14);\n+                        hash!(opt_def_id);\n+                        hash!(b.unsafety);\n+                        hash!(b.abi);\n+                        fn_sig(state, &b.sig);\n+                        return false;\n+                    }\n+                    TyTrait(ref data) => {\n+                        byte!(17);\n+                        did(state, data.principal_def_id());\n+                        hash!(data.bounds);\n+\n+                        let principal = tcx.anonymize_late_bound_regions(&data.principal).0;\n+                        for subty in &principal.substs.types {\n+                            helper(tcx, subty, svh, state);\n+                        }\n+\n+                        return false;\n+                    }\n+                    TyStruct(d, _) => {\n+                        byte!(18);\n+                        did(state, d.did);\n+                    }\n+                    TyTuple(ref inner) => {\n+                        byte!(19);\n+                        hash!(inner.len());\n+                    }\n+                    TyParam(p) => {\n+                        byte!(20);\n+                        hash!(p.space);\n+                        hash!(p.idx);\n+                        hash!(p.name.as_str());\n+                    }\n+                    TyInfer(_) => unreachable!(),\n+                    TyError => byte!(21),\n+                    TyClosure(d, _) => {\n+                        byte!(22);\n+                        did(state, d);\n+                    }\n+                    TyProjection(ref data) => {\n+                        byte!(23);\n+                        did(state, data.trait_ref.def_id);\n+                        hash!(data.item_name.as_str());\n+                    }\n+                }\n+                true\n+            });\n+        }\n+    }\n+\n+    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n+    /// safe for destruction requires it to be alive\n+    pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n+        let dtor_method = match adt.destructor() {\n+            Some(dtor) => dtor,\n+            None => return false\n+        };\n+        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n+            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n+        });\n+        let generics = adt.type_scheme(self).generics;\n+\n+        // In `impl<'a> Drop ...`, we automatically assume\n+        // `'a` is meaningful and thus represents a bound\n+        // through which we could reach borrowed data.\n+        //\n+        // FIXME (pnkfelix): In the future it would be good to\n+        // extend the language to allow the user to express,\n+        // in the impl signature, that a lifetime is not\n+        // actually used (something like `where 'a: ?Live`).\n+        if generics.has_region_params(subst::TypeSpace) {\n+            debug!(\"typ: {:?} has interesting dtor due to region params\",\n+                   adt);\n+            return true;\n+        }\n+\n+        let mut seen_items = Vec::new();\n+        let mut items_to_inspect = vec![impl_did];\n+        while let Some(item_def_id) = items_to_inspect.pop() {\n+            if seen_items.contains(&item_def_id) {\n+                continue;\n+            }\n+\n+            for pred in self.lookup_predicates(item_def_id).predicates {\n+                let result = match pred {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // For now, assume all these where-clauses\n+                        // may give drop implementation capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        if self.trait_items(def_id).len() != 0 {\n+                            // If trait has items, assume it adds\n+                            // capability to access borrowed data.\n+                            true\n+                        } else {\n+                            // Trait without items is itself\n+                            // uninteresting from POV of dropck.\n+                            //\n+                            // However, may have parent w/ items;\n+                            // so schedule checking of predicates,\n+                            items_to_inspect.push(def_id);\n+                            // and say \"no capability found\" for now.\n+                            false\n+                        }\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                           adt, pred);\n+                    return true;\n+                }\n+            }\n+\n+            seen_items.push(item_def_id);\n+        }\n+\n+        debug!(\"typ: {:?} is dtorck-safe\", adt);\n+        false\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                       bound: ty::BuiltinBound,\n+                       span: Span)\n+                       -> bool\n+    {\n+        let tcx = param_env.tcx;\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n+\n+        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n+                                                                self, bound, span);\n+\n+        debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n+               self, bound, is_impld);\n+\n+        is_impld\n+    }\n+\n+    // FIXME (@jroesch): I made this public to use it, not sure if should be private\n+    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                           span: Span) -> bool {\n+        if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n+        }\n+\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyRawPtr(..) | TyBareFn(..) | TyRef(_, TypeAndMut {\n+                mutbl: hir::MutImmutable, ..\n+            }) => Some(false),\n+\n+            TyStr | TyBox(..) | TyRef(_, TypeAndMut {\n+                mutbl: hir::MutMutable, ..\n+            }) => Some(true),\n+\n+            TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n+            TyClosure(..) | TyEnum(..) | TyStruct(..) |\n+            TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n+        }.unwrap_or_else(|| !self.impls_bound(param_env, ty::BoundCopy, span));\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n+            } else {\n+                TypeFlags::MOVENESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    #[inline]\n+    pub fn is_sized<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                        span: Span) -> bool\n+    {\n+        if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::IS_SIZED);\n+        }\n+\n+        self.is_sized_uncached(param_env, span)\n+    }\n+\n+    fn is_sized_uncached<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n+                             span: Span) -> bool {\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyBareFn(..) |\n+            TyArray(..) | TyTuple(..) | TyClosure(..) => Some(true),\n+\n+            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n+\n+            TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n+            TyInfer(..) | TyError => None\n+        }.unwrap_or_else(|| self.impls_bound(param_env, ty::BoundSized, span));\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n+            } else {\n+                TypeFlags::SIZEDNESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+\n+    /// Check whether a type is representable. This means it cannot contain unboxed\n+    /// structural recursion. This check is needed for structs and enums.\n+    pub fn is_representable(&'tcx self, cx: &ty::ctxt<'tcx>, sp: Span) -> Representability {\n+\n+        // Iterate until something non-representable is found\n+        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &ty::ctxt<'tcx>,\n+                                                                    sp: Span,\n+                                                                    seen: &mut Vec<Ty<'tcx>>,\n+                                                                    iter: It)\n+                                                                    -> Representability {\n+            iter.fold(Representability::Representable,\n+                      |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n+        }\n+\n+        fn are_inner_types_recursive<'tcx>(cx: &ty::ctxt<'tcx>, sp: Span,\n+                                           seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n+                                           -> Representability {\n+            match ty.sty {\n+                TyTuple(ref ts) => {\n+                    find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n+                }\n+                // Fixed-length vectors.\n+                // FIXME(#11924) Behavior undecided for zero-length vectors.\n+                TyArray(ty, _) => {\n+                    is_type_structurally_recursive(cx, sp, seen, ty)\n+                }\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    find_nonrepresentable(cx,\n+                                          sp,\n+                                          seen,\n+                                          def.all_fields().map(|f| f.ty(cx, substs)))\n+                }\n+                TyClosure(..) => {\n+                    // this check is run on type definitions, so we don't expect\n+                    // to see closure types\n+                    cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n+                }\n+                _ => Representability::Representable,\n+            }\n+        }\n+\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+            match ty.sty {\n+                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                     ty_def == def\n+                }\n+                _ => false\n+            }\n+        }\n+\n+        fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+            match (&a.sty, &b.sty) {\n+                (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n+                (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n+                    if did_a != did_b {\n+                        return false;\n+                    }\n+\n+                    let types_a = substs_a.types.get_slice(subst::TypeSpace);\n+                    let types_b = substs_b.types.get_slice(subst::TypeSpace);\n+\n+                    let mut pairs = types_a.iter().zip(types_b);\n+\n+                    pairs.all(|(&a, &b)| same_type(a, b))\n+                }\n+                _ => {\n+                    a == b\n+                }\n+            }\n+        }\n+\n+        // Does the type `ty` directly (without indirection through a pointer)\n+        // contain any types on stack `seen`?\n+        fn is_type_structurally_recursive<'tcx>(cx: &ty::ctxt<'tcx>,\n+                                                sp: Span,\n+                                                seen: &mut Vec<Ty<'tcx>>,\n+                                                ty: Ty<'tcx>) -> Representability {\n+            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n+\n+            match ty.sty {\n+                TyStruct(def, _) | TyEnum(def, _) => {\n+                    {\n+                        // Iterate through stack of previously seen types.\n+                        let mut iter = seen.iter();\n+\n+                        // The first item in `seen` is the type we are actually curious about.\n+                        // We want to return SelfRecursive if this type contains itself.\n+                        // It is important that we DON'T take generic parameters into account\n+                        // for this check, so that Bar<T> in this example counts as SelfRecursive:\n+                        //\n+                        // struct Foo;\n+                        // struct Bar<T> { x: Bar<Foo> }\n+\n+                        match iter.next() {\n+                            Some(&seen_type) => {\n+                                if same_struct_or_enum(seen_type, def) {\n+                                    debug!(\"SelfRecursive: {:?} contains {:?}\",\n+                                           seen_type,\n+                                           ty);\n+                                    return Representability::SelfRecursive;\n+                                }\n+                            }\n+                            None => {}\n+                        }\n+\n+                        // We also need to know whether the first item contains other types\n+                        // that are structurally recursive. If we don't catch this case, we\n+                        // will recurse infinitely for some inputs.\n+                        //\n+                        // It is important that we DO take generic parameters into account\n+                        // here, so that code like this is considered SelfRecursive, not\n+                        // ContainsRecursive:\n+                        //\n+                        // struct Foo { Option<Option<Foo>> }\n+\n+                        for &seen_type in iter {\n+                            if same_type(ty, seen_type) {\n+                                debug!(\"ContainsRecursive: {:?} contains {:?}\",\n+                                       seen_type,\n+                                       ty);\n+                                return Representability::ContainsRecursive;\n+                            }\n+                        }\n+                    }\n+\n+                    // For structs and enums, track all previously seen types by pushing them\n+                    // onto the 'seen' stack.\n+                    seen.push(ty);\n+                    let out = are_inner_types_recursive(cx, sp, seen, ty);\n+                    seen.pop();\n+                    out\n+                }\n+                _ => {\n+                    // No need to push in other cases.\n+                    are_inner_types_recursive(cx, sp, seen, ty)\n+                }\n+            }\n+        }\n+\n+        debug!(\"is_type_representable: {:?}\", self);\n+\n+        // To avoid a stack overflow when checking an enum variant or struct that\n+        // contains a different, structurally recursive type, maintain a stack\n+        // of seen types and check recursion for each of them (issues #3008, #3779).\n+        let mut seen: Vec<Ty> = Vec::new();\n+        let r = is_type_structurally_recursive(cx, sp, &mut seen, self);\n+        debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n+        r\n+    }\n+}"}, {"sha": "fee60d46dc0019b7436f4986015124092c2e74d8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -388,23 +388,23 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::AutoAdjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ty::AdjustReifyFnPointer => {\n+            ty::adjustment::AdjustReifyFnPointer => {\n                 write!(f, \"AdjustReifyFnPointer\")\n             }\n-            ty::AdjustUnsafeFnPointer => {\n+            ty::adjustment::AdjustUnsafeFnPointer => {\n                 write!(f, \"AdjustUnsafeFnPointer\")\n             }\n-            ty::AdjustDerefRef(ref data) => {\n+            ty::adjustment::AdjustDerefRef(ref data) => {\n                 write!(f, \"{:?}\", data)\n             }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::AutoDerefRef<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n                self.autoderefs, self.unsize, self.autoref)"}, {"sha": "4084f13e818f226fe0b8d965f62f1340b7edefae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -33,6 +33,7 @@ use middle::{cfg, def, infer, pat_util, stability, traits};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n+use middle::ty::adjustment;\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n@@ -1722,13 +1723,15 @@ impl LintPass for UnusedAllocation {\n         }\n \n         if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                ref autoref, ..\n+            }) = *adjustment {\n                 match autoref {\n-                    &Some(ty::AutoPtr(_, hir::MutImmutable)) => {\n+                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(ty::AutoPtr(_, hir::MutMutable)) => {\n+                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }\n@@ -2297,7 +2300,7 @@ impl LintPass for UnconditionalRecursion {\n             }\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(&ty::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+            if let Some(&adjustment::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n                     if let Some(m) = tables.method_map.get(&method_call) {"}, {"sha": "f15470e7851d41b133e5470748154e94506888ab", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -320,7 +320,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n         // Now apply adjustments, if any.\n         match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n             None => { }\n-            Some(&ty::AdjustReifyFnPointer) => {\n+            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n@@ -329,7 +329,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::AdjustUnsafeFnPointer) => {\n+            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n@@ -338,7 +338,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::AdjustDerefRef(ref adj)) => {\n+            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n                 for i in 0..adj.autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n@@ -372,7 +372,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                 } else if let Some(autoref) = adj.autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoPtr(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -382,7 +382,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                                                          arg: expr.to_ref() }\n                             };\n                         }\n-                        ty::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoUnsafe(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression."}, {"sha": "a2d74635b5e1ce6f2a54ae350fde781565392256", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -34,6 +34,8 @@ use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::subst::Substs;\n+use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use middle::ty::adjustment::AdjustUnsafeFnPointer;\n use middle::ty::{self, Ty};\n use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n@@ -289,14 +291,14 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n     let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n-        Some(ty::AdjustReifyFnPointer) => {\n+        Some(AdjustReifyFnPointer) => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n         }\n-        Some(ty::AdjustUnsafeFnPointer) => {\n+        Some(AdjustUnsafeFnPointer) => {\n             // purely a type-level thing\n         }\n-        Some(ty::AdjustDerefRef(adj)) => {\n+        Some(AdjustDerefRef(adj)) => {\n             let mut ty = ety;\n             // Save the last autoderef in case we can avoid it.\n             if adj.autoderefs > 0 {"}, {"sha": "7d8996867c016ff4138ec8425502ad2d6f49aeab", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -71,7 +71,8 @@ use trans::machine;\n use trans::meth;\n use trans::tvec;\n use trans::type_of;\n-use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n+use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer, CustomCoerceUnsized};\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use middle::ty::cast::{CastKind, CastTy};\n@@ -514,7 +515,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let coerce_index = match kind {\n-                ty::CustomCoerceUnsized::Struct(i) => i\n+                CustomCoerceUnsized::Struct(i) => i\n             };\n             assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n "}, {"sha": "69efaa792fe053e7356d0ccddea67aeb8bcebdc0", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -65,7 +65,9 @@ use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n use middle::infer::{self, Coercion};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n-use middle::ty::{AutoDerefRef, AdjustDerefRef};\n+use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n+use middle::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n+use middle::ty::adjustment::{AdjustUnsafeFnPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use middle::ty::error::TypeError;\n use middle::ty::relate::RelateResult;\n@@ -81,7 +83,7 @@ struct Coerce<'a, 'tcx: 'a> {\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, Option<AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n@@ -186,7 +188,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let r_borrow = self.tcx().mk_region(r_borrow);\n-        let autoref = Some(ty::AutoPtr(r_borrow, mutbl_b));\n+        let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n         let mut first_error = None;\n@@ -264,11 +266,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                 let region = self.tcx().mk_region(r_borrow);\n-                (mt_a.ty, Some(ty::AutoPtr(region, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n-                (mt_a.ty, Some(ty::AutoUnsafe(mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n             }\n             _ => (source, None)\n         };\n@@ -360,7 +362,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                         let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n                         try!(self.subtype(unsafe_a, b));\n-                        return Ok(Some(ty::AdjustUnsafeFnPointer));\n+                        return Ok(Some(AdjustUnsafeFnPointer));\n                     }\n                     _ => {}\n                 }\n@@ -387,7 +389,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 ty::TyBareFn(None, _) => {\n                     let a_fn_pointer = self.tcx().mk_fn(None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n-                    Ok(Some(ty::AdjustReifyFnPointer))\n+                    Ok(Some(AdjustReifyFnPointer))\n                 }\n                 _ => self.subtype(a, b)\n             }\n@@ -422,7 +424,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         if is_ref {\n             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n-                autoref: Some(ty::AutoUnsafe(mutbl_b)),\n+                autoref: Some(AutoUnsafe(mutbl_b)),\n                 unsize: None\n             })))\n         } else {"}, {"sha": "572ba7a84871354ea543d78db2de580dfa62dc5b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -16,6 +16,7 @@ use middle::def_id::DefId;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, NoPreference, PreferMutLvalue, Ty};\n+use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use middle::ty::fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -136,7 +137,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n             let region = self.infcx().next_region_var(infer::Autoref(self.span));\n-            let autoref = ty::AutoPtr(self.tcx().mk_region(region), mutbl);\n+            let autoref = AutoPtr(self.tcx().mk_region(region), mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n                 target.adjust_for_autoref(self.tcx(), Some(autoref))\n             }))\n@@ -169,7 +170,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Write out the final adjustment.\n         self.fcx.write_adjustment(self.self_expr.id,\n-                                  ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                  AdjustDerefRef(AutoDerefRef {\n             autoderefs: pick.autoderefs,\n             autoref: autoref,\n             unsize: unsize\n@@ -488,7 +489,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                             .borrow()\n                                             .adjustments\n                                             .get(&expr.id) {\n-                Some(&ty::AdjustDerefRef(ref adj)) => adj.autoderefs,\n+                Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n             };\n \n@@ -527,12 +528,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n                                                                           .cloned();\n                         let (autoderefs, unsize) = match adj {\n-                            Some(ty::AdjustDerefRef(adr)) => match adr.autoref {\n+                            Some(AdjustDerefRef(adr)) => match adr.autoref {\n                                 None => {\n                                     assert!(adr.unsize.is_none());\n                                     (adr.autoderefs, None)\n                                 }\n-                                Some(ty::AutoPtr(_, _)) => {\n+                                Some(AutoPtr(_, _)) => {\n                                     (adr.autoderefs, adr.unsize.map(|target| {\n                                         target.builtin_deref(false, NoPreference)\n                                               .expect(\"fixup: AutoPtr is not &T\").ty\n@@ -557,7 +558,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                             (target, true)\n                         } else {\n                             (self.fcx.adjust_expr_ty(base_expr,\n-                                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                Some(&AdjustDerefRef(AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: None,\n                                     unsize: None"}, {"sha": "1cfb495b36ed75a9e6dfb1b2c5384728e870e8e7", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -18,6 +18,7 @@ use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef};\n+use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use middle::infer;\n \n use syntax::ast;\n@@ -282,9 +283,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     match transformed_self_ty.sty {\n                         ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n                             fcx.write_adjustment(self_expr.id,\n-                                ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                AdjustDerefRef(AutoDerefRef {\n                                     autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(region, mutbl)),\n+                                    autoref: Some(AutoPtr(region, mutbl)),\n                                     unsize: if unsize {\n                                         Some(transformed_self_ty)\n                                     } else {"}, {"sha": "656a740e9840e5f554cfe35ffbae2c57b57c52b6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -97,8 +97,10 @@ use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee};\n+use middle::ty::adjustment;\n use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::util::Representability;\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n@@ -1337,7 +1339,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       derefs: usize) {\n         self.write_adjustment(\n             node_id,\n-            ty::AdjustDerefRef(ty::AutoDerefRef {\n+            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n                 unsize: None\n@@ -1347,7 +1349,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: ty::AutoAdjustment<'tcx>) {\n+                            adj: adjustment::AutoAdjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1576,7 +1578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Apply `adjustment` to the type of `expr`\n     pub fn adjust_expr_ty(&self,\n                           expr: &hir::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n                           -> Ty<'tcx>\n     {\n         let raw_ty = self.expr_ty(expr);\n@@ -4170,12 +4172,13 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n-      ty::SelfRecursive => {\n-        span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation);\n-        tcx.sess.fileline_help(sp, \"wrap the inner value in a box to make it representable\");\n-        return false\n-      }\n-      ty::Representable | ty::ContainsRecursive => (),\n+        Representability::SelfRecursive => {\n+            span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation);\n+            tcx.sess.fileline_help(\n+                sp, \"wrap the inner value in a box to make it representable\");\n+            return false\n+        }\n+        Representability::Representable | Representability::ContainsRecursive => (),\n     }\n     return true\n }"}, {"sha": "155caaa8cb0fe2a7f4f1fac3b1d6bb3bde5540a2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -94,6 +94,7 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, VerifyBound};\n use middle::pat_util;\n+use middle::ty::adjustment;\n use middle::ty::wf::ImpliedBound;\n \n use std::mem;\n@@ -598,7 +599,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n     if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n         match adjustment {\n-            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, ref autoref, ..}) => {\n+            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                autoderefs, ref autoref, ..\n+            }) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n                 if let Some(ref autoref) = *autoref {\n@@ -614,7 +617,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                 }\n             }\n             /*\n-            ty::AutoObject(_, ref bounds, _, _) => {\n+            adjustment::AutoObject(_, ref bounds, _, _) => {\n                 // Determine if we are casting `expr` to a trait\n                 // instance. If so, we have to be sure that the type\n                 // of the source obeys the new region bound.\n@@ -1221,20 +1224,20 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n fn link_autoref(rcx: &Rcx,\n                 expr: &hir::Expr,\n                 autoderefs: usize,\n-                autoref: &ty::AutoRef)\n+                autoref: &adjustment::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n     match *autoref {\n-        ty::AutoPtr(r, m) => {\n+        adjustment::AutoPtr(r, m) => {\n             link_region(rcx, expr.span, r,\n                 ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(m) => {\n+        adjustment::AutoUnsafe(m) => {\n             let r = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n             link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }"}, {"sha": "6f8e064c9d8195c3e98c83affec70b55b00a031c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -18,6 +18,7 @@ use check::FnCtxt;\n use middle::def_id::DefId;\n use middle::pat_util;\n use middle::ty::{self, Ty, MethodCall, MethodCallee};\n+use middle::ty::adjustment;\n use middle::ty::fold::{TypeFolder,TypeFoldable};\n use middle::infer;\n use write_substs_to_tcx;\n@@ -268,19 +269,21 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             Some(adjustment) => {\n                 let resolved_adjustment = match adjustment {\n-                    ty::AdjustReifyFnPointer => ty::AdjustReifyFnPointer,\n+                    adjustment::AdjustReifyFnPointer => {\n+                        adjustment::AdjustReifyFnPointer\n+                    }\n \n-                    ty::AdjustUnsafeFnPointer => {\n-                        ty::AdjustUnsafeFnPointer\n+                    adjustment::AdjustUnsafeFnPointer => {\n+                        adjustment::AdjustUnsafeFnPointer\n                     }\n \n-                    ty::AdjustDerefRef(adj) => {\n+                    adjustment::AdjustDerefRef(adj) => {\n                         for autoderef in 0..adj.autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        ty::AdjustDerefRef(ty::AutoDerefRef {\n+                        adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                             unsize: self.resolve(&adj.unsize, reason),"}, {"sha": "9ba6f1398e47118fb84c708cbe83c80fcf12fde9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -20,6 +20,7 @@ use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n use middle::traits;\n+use middle::ty;\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n@@ -29,7 +30,7 @@ use middle::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use middle::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use middle::ty::{TyUint, TyClosure, TyBox, TyBareFn};\n use middle::ty::TyProjection;\n-use middle::ty;\n+use middle::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n use middle::infer::{self, InferCtxt, new_infer_ctxt};\n@@ -370,27 +371,27 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             match param_env.can_type_implement_copy(self_type, span) {\n                 Ok(()) => {}\n-                Err(ty::FieldDoesNotImplementCopy(name)) => {\n+                Err(CopyImplementationError::InfrigingField(name)) => {\n                        span_err!(tcx.sess, span, E0204,\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n                                          name)\n                 }\n-                Err(ty::VariantDoesNotImplementCopy(name)) => {\n+                Err(CopyImplementationError::InfrigingVariant(name)) => {\n                        span_err!(tcx.sess, span, E0205,\n                                  \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n                                          name)\n                 }\n-                Err(ty::TypeIsStructural) => {\n+                Err(CopyImplementationError::NotAnAdt) => {\n                        span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")\n                 }\n-                Err(ty::TypeHasDestructor) => {\n+                Err(CopyImplementationError::HasDestructor) => {\n                     span_err!(tcx.sess, span, E0184,\n                               \"the trait `Copy` may not be implemented for this type; \\\n                                the type has a destructor\");\n@@ -510,7 +511,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let (i, a, b) = diff_fields[0];\n-                    let kind = ty::CustomCoerceUnsized::Struct(i);\n+                    let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n                     (a, b, coerce_unsized_trait, Some(kind))\n                 }\n "}, {"sha": "f7520ed54b77e3f153d8782fb9c1c29ccf29a190", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a95acb8aba07ea8e5255893aa4e01e5ba5c2349/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5a95acb8aba07ea8e5255893aa4e01e5ba5c2349", "patch": "@@ -76,9 +76,10 @@ use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme, IntTypeExt};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n use middle::ty::{VariantKind};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::util::IntTypeExt;\n use middle::infer;\n use rscope::*;\n use rustc::front::map as hir_map;"}]}