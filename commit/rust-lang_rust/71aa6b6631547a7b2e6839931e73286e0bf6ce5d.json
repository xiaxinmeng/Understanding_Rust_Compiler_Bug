{"sha": "71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYWE2YjY2MzE1NDdhN2IyZTY4Mzk5MzFlNzMyODZlMGJmNmNlNWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-19T21:57:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-20T22:20:50Z"}, "message": "core::rt: Move more TLS functionality into local_ptr", "tree": {"sha": "21c28b6d94419c122466c6c81a9652b4d9b542b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c28b6d94419c122466c6c81a9652b4d9b542b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "html_url": "https://github.com/rust-lang/rust/commit/71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71aa6b6631547a7b2e6839931e73286e0bf6ce5d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c2fd1a965b3af037fa22c911dfb618f818c172", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c2fd1a965b3af037fa22c911dfb618f818c172", "html_url": "https://github.com/rust-lang/rust/commit/97c2fd1a965b3af037fa22c911dfb618f818c172"}], "stats": {"total": 152, "additions": 94, "deletions": 58}, "files": [{"sha": "80d797e8c65434ae89b0803ec0152a395734bfe5", "filename": "src/libcore/rt/local_ptr.rs", "status": "modified", "additions": 89, "deletions": 7, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/71aa6b6631547a7b2e6839931e73286e0bf6ce5d/src%2Flibcore%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71aa6b6631547a7b2e6839931e73286e0bf6ce5d/src%2Flibcore%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_ptr.rs?ref=71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "patch": "@@ -8,11 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Access to a single thread-local pointer\n+//! Access to a single thread-local pointer.\n+//!\n+//! The runtime will use this for storing ~Task.\n+//!\n+//! XXX: Add runtime checks for usage of inconsistent pointer types.\n+//! and for overwriting an existing pointer.\n \n use libc::c_void;\n use cast;\n+use ptr;\n+use cell::Cell;\n use option::{Option, Some, None};\n+use unstable::finally::Finally;\n use tls = rt::thread_local_storage;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n@@ -25,14 +33,87 @@ pub fn init_tls_key() {\n     }\n }\n \n-pub fn tls_key() -> tls::Key {\n+/// Give a pointer to thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn put<T>(sched: ~T) {\n+    let key = tls_key();\n+    let void_ptr: *mut c_void = cast::transmute(sched);\n+    tls::set(key, void_ptr);\n+}\n+\n+/// Take ownership of a pointer from thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn take<T>() -> ~T {\n+    let key = tls_key();\n+    let void_ptr: *mut c_void = tls::get(key);\n+    rtassert!(void_ptr.is_not_null());\n+    let ptr: ~T = cast::transmute(void_ptr);\n+    tls::set(key, ptr::mut_null());\n+    return ptr;\n+}\n+\n+/// Check whether there is a thread-local pointer installed.\n+pub fn exists() -> bool {\n+    unsafe {\n+        match maybe_tls_key() {\n+            Some(key) => tls::get(key).is_not_null(),\n+            None => false\n+        }\n+    }\n+}\n+\n+/// Borrow the thread-local scheduler from thread-local storage.\n+/// While the scheduler is borrowed it is not available in TLS.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n+    let mut value = take();\n+\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n+    let value_cell = Cell(value);\n+\n+    do (|| {\n+        f(unsafe_ptr);\n+    }).finally {\n+        put(value_cell.take());\n+    }\n+}\n+\n+/// Borrow a mutable reference to the thread-local Scheduler\n+///\n+/// # Safety Note\n+///\n+/// Because this leaves the Scheduler in thread-local storage it is possible\n+/// For the Scheduler pointer to be aliased\n+pub unsafe fn unsafe_borrow<T>() -> *mut T {\n+    let key = tls_key();\n+    let mut void_sched: *mut c_void = tls::get(key);\n+    rtassert!(void_sched.is_not_null());\n+    {\n+        let sched: *mut *mut c_void = &mut void_sched;\n+        let sched: *mut ~T = sched as *mut ~T;\n+        let sched: *mut T = &mut **sched;\n+        return sched;\n+    }\n+}\n+\n+fn tls_key() -> tls::Key {\n     match maybe_tls_key() {\n         Some(key) => key,\n         None => abort!(\"runtime tls key not initialized\")\n     }\n }\n \n-pub fn maybe_tls_key() -> Option<tls::Key> {\n+fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_rt_tls_key();\n         let key: &mut tls::Key = cast::transmute(key);\n@@ -55,9 +136,10 @@ pub fn maybe_tls_key() -> Option<tls::Key> {\n             return None;\n         }\n     }\n-}\n \n-extern {\n-    #[fast_ffi]\n-    fn rust_get_rt_tls_key() -> *mut c_void;\n+    extern {\n+        #[fast_ffi]\n+        fn rust_get_rt_tls_key() -> *mut c_void;\n+    }\n+\n }"}, {"sha": "e3c0b4c4e88471b801e34a8651a2f2139cff62b7", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71aa6b6631547a7b2e6839931e73286e0bf6ce5d/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71aa6b6631547a7b2e6839931e73286e0bf6ce5d/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=71aa6b6631547a7b2e6839931e73286e0bf6ce5d", "patch": "@@ -25,71 +25,25 @@ use tls = rt::thread_local_storage;\n #[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n /// Give the Scheduler to thread-local storage\n-pub fn put(sched: ~Scheduler) {\n-    unsafe {\n-        let key = local_ptr::tls_key();\n-        let void_sched: *mut c_void = cast::transmute(sched);\n-        tls::set(key, void_sched);\n-    }\n-}\n+pub fn put(sched: ~Scheduler) { unsafe { local_ptr::put(sched) } }\n \n /// Take ownership of the Scheduler from thread-local storage\n-pub fn take() -> ~Scheduler {\n-    unsafe {\n-        let key = local_ptr::tls_key();\n-        let void_sched: *mut c_void = tls::get(key);\n-        rtassert!(void_sched.is_not_null());\n-        let sched: ~Scheduler = cast::transmute(void_sched);\n-        tls::set(key, mut_null());\n-        return sched;\n-    }\n-}\n+pub fn take() -> ~Scheduler { unsafe { local_ptr::take() } }\n \n /// Check whether there is a thread-local Scheduler attached to the running thread\n-pub fn exists() -> bool {\n-    unsafe {\n-        match local_ptr::maybe_tls_key() {\n-            Some(key) => tls::get(key).is_not_null(),\n-            None => false\n-        }\n-    }\n-}\n+pub fn exists() -> bool { local_ptr::exists() }\n \n /// Borrow the thread-local scheduler from thread-local storage.\n /// While the scheduler is borrowed it is not available in TLS.\n-pub fn borrow(f: &fn(&mut Scheduler)) {\n-    let mut sched = take();\n-\n-    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n-    unsafe {\n-        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n-        let sched = Cell(sched);\n-\n-        do (|| {\n-            f(unsafe_sched);\n-        }).finally {\n-            put(sched.take());\n-        }\n-    }\n-}\n+pub fn borrow(f: &fn(&mut Scheduler)) { unsafe { local_ptr::borrow(f) } }\n \n /// Borrow a mutable reference to the thread-local Scheduler\n ///\n /// # Safety Note\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n-    let key = local_ptr::tls_key();\n-    let mut void_sched: *mut c_void = tls::get(key);\n-    rtassert!(void_sched.is_not_null());\n-    {\n-        let sched: *mut *mut c_void = &mut void_sched;\n-        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n-        let sched: *mut Scheduler = &mut **sched;\n-        return sched;\n-    }\n-}\n+pub unsafe fn unsafe_borrow() -> *mut Scheduler { local_ptr::unsafe_borrow() }\n \n pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n     let sched = unsafe_borrow();"}]}