{"sha": "5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTNkM2FhMDBlOGNmZGYxYTY0ZjU4ZjZjNjQ5NDYwNDAwMjMxYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-25T03:32:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-25T03:32:36Z"}, "message": "auto merge of #17378 : Gankro/rust/hashmap-entry, r=aturon\n\nDeprecates the `find_or_*` family of \"internal mutation\" methods on `HashMap` in\r\nfavour of the \"external mutation\" Entry API as part of RFC 60. Part of #17320,\r\nbut this still needs to be done on the rest of the maps. However they don't have\r\nany internal mutation methods defined, so they can be done without deprecating\r\nor breaking anything. Work on `BTree` is part of the complete rewrite in #17334.\r\n\r\nThe implemented API deviates from the API described in the RFC in two key places:\r\n\r\n* `VacantEntry.set` yields a mutable reference to the inserted element to avoid code\r\nduplication where complex logic needs to be done *regardless* of whether the entry\r\nwas vacant or not.\r\n* `OccupiedEntry.into_mut` was added so that it is possible to return a reference\r\ninto the map beyond the lifetime of the Entry itself, providing functional parity\r\nto `VacantEntry.set`.\r\n\r\nThis allows the full find_or_insert functionality to be implemented using this API.\r\nA PR will be submitted to the RFC to amend this.\r\n\r\n[breaking-change]", "tree": {"sha": "da2ed103b766692d01b7905b2ffc43e028bf8c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da2ed103b766692d01b7905b2ffc43e028bf8c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "html_url": "https://github.com/rust-lang/rust/commit/5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "html_url": "https://github.com/rust-lang/rust/commit/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7"}, {"sha": "fe8a413fc0f5d7d021ec42ac1a4149db662ca92c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8a413fc0f5d7d021ec42ac1a4149db662ca92c", "html_url": "https://github.com/rust-lang/rust/commit/fe8a413fc0f5d7d021ec42ac1a4149db662ca92c"}], "stats": {"total": 436, "additions": 386, "deletions": 50}, "files": [{"sha": "daa4a6ad75257937c8b42b0e91fdf453e4dcda5f", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -31,6 +31,7 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};\n@@ -804,8 +805,11 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(s) => s,\n             None => early_error(\"--extern value must be of the format `foo=bar`\"),\n         };\n-        let locs = externs.find_or_insert(name.to_string(), Vec::new());\n-        locs.push(location.to_string());\n+\n+        match externs.entry(name.to_string()) {\n+            Vacant(entry) => { entry.set(vec![location.to_string()]); },\n+            Occupied(mut entry) => { entry.get_mut().push(location.to_string()); },\n+        }\n     }\n \n     let crate_name = matches.opt_str(\"crate-name\");"}, {"sha": "b812073c3a82affb904beb9a843b168475fbafdc", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -36,6 +36,7 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::abi;\n@@ -1203,15 +1204,18 @@ impl UnusedMut {\n     fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n+\n         let mut mutables = HashMap::new();\n         for p in pats.iter() {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n-                            mutables.insert_or_update_with(ident.name.uint(),\n-                                vec!(id), |_, old| { old.push(id); });\n+                            match mutables.entry(ident.name.uint()) {\n+                                Vacant(entry) => { entry.set(vec![id]); },\n+                                Occupied(mut entry) => { entry.get_mut().push(id); },\n+                            }\n                         }\n                     }\n                     _ => {"}, {"sha": "e2d997a93fe0410b980c68d67c51c71a9fb0bdfe", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -24,6 +24,7 @@ use plugin::load::PluginMetadata;\n \n use std::rc::Rc;\n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -82,7 +83,10 @@ fn dump_crates(cstore: &CStore) {\n fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     let mut map = HashMap::new();\n     cstore.iter_crate_data(|cnum, data| {\n-        map.find_or_insert_with(data.name(), |_| Vec::new()).push(cnum);\n+        match map.entry(data.name()) {\n+            Vacant(entry) => { entry.set(vec![cnum]); },\n+            Occupied(mut entry) => { entry.get_mut().push(cnum); },\n+        }\n     });\n \n     for (name, dupes) in map.into_iter() {"}, {"sha": "dc97b6c0df8cce1f9220d0c92f412311ec953907", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -237,6 +237,7 @@ use std::slice;\n use std::string;\n \n use std::collections::{HashMap, HashSet};\n+use std::collections::hashmap::{Occupied, Vacant};\n use flate;\n use time;\n \n@@ -428,15 +429,18 @@ impl<'a> Context<'a> {\n                 return FileDoesntMatch\n             };\n             info!(\"lib candidate: {}\", path.display());\n-            let slot = candidates.find_or_insert_with(hash.to_string(), |_| {\n-                (HashSet::new(), HashSet::new())\n-            });\n+\n+            let slot = match candidates.entry(hash.to_string()) {\n+                Occupied(entry) => entry.into_mut(),\n+                Vacant(entry) => entry.set((HashSet::new(), HashSet::new())),\n+            };\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n                 rlibs.insert(fs::realpath(path).unwrap());\n             } else {\n                 dylibs.insert(fs::realpath(path).unwrap());\n             }\n+\n             FileMatches\n         });\n "}, {"sha": "98d2cefac0fcf55f7cc896d4cf54aa49882c2d0c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -28,6 +28,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n+use std::collections::hashmap::Vacant;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -321,7 +322,10 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n \n         ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow().get_copy(&callee.id);\n-            tcx.def_map.borrow_mut().find_or_insert(expr.id, def);\n+            match tcx.def_map.borrow_mut().entry(expr.id) {\n+              Vacant(entry) => { entry.set(def); }\n+              _ => {}\n+            };\n             let path = match def {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),"}, {"sha": "2c18c450eb6b525e64c10fa8793e163ad1807420", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -59,6 +59,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::cell::{Cell, RefCell};\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n@@ -2815,10 +2816,13 @@ impl<'a> Resolver<'a> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.find_or_insert_with(name, |_| {\n-            // Create a new import resolution from this child.\n-            ImportResolution::new(id, is_public)\n-        });\n+        let dest_import_resolution = match import_resolutions.entry(name) {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                // Create a new import resolution from this child.\n+                entry.set(ImportResolution::new(id, is_public))\n+            }\n+        };\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n@@ -6026,19 +6030,21 @@ impl<'a> Resolver<'a> {\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n-        self.def_map.borrow_mut().insert_or_update_with(node_id, def, |_, old_value| {\n+\n+        match self.def_map.borrow_mut().entry(node_id) {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n-            if def != *old_value {\n+            Occupied(entry) => if def != *entry.get() {\n                 self.session\n                     .bug(format!(\"node_id {:?} resolved first to {:?} and \\\n                                   then {:?}\",\n                                  node_id,\n-                                 *old_value,\n+                                 *entry.get(),\n                                  def).as_slice());\n-            }\n-        });\n+            },\n+            Vacant(entry) => { entry.set(def); },\n+        }\n     }\n \n     fn enforce_default_binding_mode(&mut self,"}, {"sha": "3014eb35e2240ec34399d9da5c950956ad4b56d3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -48,6 +48,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n+use std::collections::hashmap::{Occupied, Vacant};\n use arena::TypedArena;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n@@ -4566,9 +4567,10 @@ pub fn lookup_field_type(tcx: &ctxt,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        let pty = tcache.find_or_insert_with(id, |_| {\n-            csearch::get_field_type(tcx, struct_id, id)\n-        });\n+        let pty = match tcache.entry(id) {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.set(csearch::get_field_type(tcx, struct_id, id)),\n+        };\n         pty.ty\n     };\n     t.subst(tcx, substs)"}, {"sha": "8d6369bdbe1db258dbabaad3f3475eeaf4c9df83", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -121,6 +121,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::abi;\n@@ -1991,11 +1992,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          */\n \n         let mut region_obligations = self.inh.region_obligations.borrow_mut();\n-        let v = region_obligations.find_or_insert_with(self.body_id,\n-                                                       |_| Vec::new());\n-        v.push(RegionObligation { sub_region: r,\n+        let region_obligation = RegionObligation { sub_region: r,\n                                   sup_type: ty,\n-                                  origin: origin });\n+                                  origin: origin };\n+\n+        match region_obligations.entry(self.body_id) {\n+            Vacant(entry) => { entry.set(vec![region_obligation]); },\n+            Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n+        }\n     }\n \n     pub fn add_obligations_for_parameters(&self,"}, {"sha": "db9877698a3653c9f6af7f3b0aa1b08d9a3d8a1f", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -18,6 +18,7 @@ use middle::ty_fold::TypeFolder;\n use syntax::ast;\n \n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n@@ -35,7 +36,10 @@ pub fn replace_late_bound_regions_in_fn_sig(\n             debug!(\"region r={}\", r.to_string());\n             match r {\n                 ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n-                    *map.find_or_insert_with(br, |_| mapf(br))\n+                    * match map.entry(br) {\n+                        Vacant(entry) => entry.set(mapf(br)),\n+                        Occupied(entry) => entry.into_mut(),\n+                    }\n                 }\n                 _ => r\n             }"}, {"sha": "b2cef48af4ca70eafd1339fd9a6aedb9694be056", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -34,6 +34,7 @@\n //! both occur before the crate is rendered.\n \n use std::collections::{HashMap, HashSet};\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::fmt;\n use std::io::fs::PathExtensions;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n@@ -802,9 +803,10 @@ impl DocFolder for Cache {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n                     Some(clean::ResolvedPath{ did, .. }) => {\n-                        let v = self.implementors.find_or_insert_with(did, |_| {\n-                            Vec::new()\n-                        });\n+                        let v = match self.implementors.entry(did) {\n+                            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                            Occupied(entry) => entry.into_mut(),\n+                        };\n                         v.push(Implementor {\n                             def_id: item.def_id,\n                             generics: i.generics.clone(),\n@@ -999,9 +1001,10 @@ impl DocFolder for Cache {\n \n                         match did {\n                             Some(did) => {\n-                                let v = self.impls.find_or_insert_with(did, |_| {\n-                                    Vec::new()\n-                                });\n+                                let v = match self.impls.entry(did) {\n+                                    Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                                    Occupied(entry) => entry.into_mut(),\n+                                };\n                                 v.push(Impl {\n                                     impl_: i,\n                                     dox: dox,\n@@ -2143,7 +2146,10 @@ fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n             None => continue,\n             Some(ref s) => s.to_string(),\n         };\n-        let v = map.find_or_insert_with(short.to_string(), |_| Vec::new());\n+        let v = match map.entry(short.to_string()) {\n+            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+            Occupied(entry) => entry.into_mut(),\n+        };\n         v.push(myname);\n     }\n "}, {"sha": "237a88ded711b9626ab07876fe36290b78352913", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -31,6 +31,7 @@ extern crate time;\n use std::io;\n use std::io::{File, MemWriter};\n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n \n@@ -340,7 +341,10 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n                 return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n             }\n         };\n-        let locs = externs.find_or_insert(name.to_string(), Vec::new());\n+        let locs = match externs.entry(name.to_string()) {\n+            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+            Occupied(entry) => entry.into_mut(),\n+        };\n         locs.push(location.to_string());\n     }\n     Ok(externs)"}, {"sha": "6b9c76e1568d2cdf986fd13d73e29f77df345669", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 282, "deletions": 6, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -20,16 +20,19 @@ use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, FromIterator, Extendable};\n use iter;\n use mem::replace;\n+use mem;\n use num;\n use ops::{Deref, DerefMut};\n use option::{Some, None, Option};\n use result::{Ok, Err};\n use ops::Index;\n+use core::result::Result;\n \n use super::table;\n use super::table::{\n     Bucket,\n     Empty,\n+    EmptyBucket,\n     Full,\n     FullBucket,\n     FullBucketImm,\n@@ -328,11 +331,11 @@ fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &SafeHash,\n     search_hashed_generic(table, hash, |k_| *k == *k_)\n }\n \n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> V {\n-    let (empty, _k, retval) = starting_bucket.take();\n+fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n+    let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n         Some(b) => b,\n-        None => return retval\n+        None => return (retkey, retval)\n     };\n \n     while gap.full().distance() != 0 {\n@@ -343,7 +346,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> V {\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    return retval;\n+    return (retkey, retval);\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -567,7 +570,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n         self.make_some_room(potential_new_size);\n \n         self.search_mut(k).map(|bucket| {\n-            pop_internal(bucket)\n+            let (_k, val) = pop_internal(bucket);\n+            val\n         })\n     }\n }\n@@ -852,12 +856,28 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.insert_hashed_nocheck(hash, k, v)\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1i),\n+    ///     Occupied(entry) => entry.into_mut(),\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -867,16 +887,34 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Find the existing key\n     /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n+    #[allow(deprecated)]\n     pub fn find_or_insert(&mut self, k: K, v: V) -> &mut V {\n         self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1i),\n+    ///     Occupied(entry) => entry.into_mut(),\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -886,18 +924,39 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Find the existing key\n     /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n+    #[allow(deprecated)]\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1u),\n+    ///     Occupied(mut entry) => {\n+    ///         *entry.get_mut() += 1;\n+    ///         entry.into_mut()\n+    ///     }\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n     ///\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n@@ -908,6 +967,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n     /// assert_eq!(map[\"a\"], 7);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n                                  k: K,\n@@ -921,6 +981,24 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.insert_or_replace_with(hash, k, v, |kref, vref, _v| f(kref, vref))\n     }\n \n+    /// Deprecated: use `entry` as follows instead:\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hashmap::{Occupied, Vacant};\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// let result = match map.entry(\"a\") {\n+    ///     Vacant(entry) => entry.set(1u),\n+    ///     Occupied(mut entry) => {\n+    ///         *entry.get_mut() += 1;\n+    ///         entry.into_mut()\n+    ///     }\n+    /// };\n+    /// assert_eq!(*result, 1);\n+    /// ```\n+    ///\n     /// Modify and return the value corresponding to the key in the map, or\n     /// insert and return a new value if it doesn't exist.\n     ///\n@@ -934,6 +1012,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n     /// use std::collections::HashMap;\n     ///\n     /// // map some strings to vectors of strings\n@@ -965,6 +1044,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[\"b key\"], vec![\"new value\"]);\n     /// assert_eq!(map[\"z key\"], vec![\"new value\", \"value\"]);\n     /// ```\n+    #[deprecated = \"use entry instead\"]\n     pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n                                            k: K,\n                                            a: A,\n@@ -1124,7 +1204,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         match self.search_equiv_mut(k) {\n             Some(bucket) => {\n-                Some(pop_internal(bucket))\n+                let (_k, val) = pop_internal(bucket);\n+                Some(val)\n             }\n             _ => None\n         }\n@@ -1254,6 +1335,68 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n         }\n     }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation\n+    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+        // Gotta resize now, and we don't know which direction, so try both?\n+        let size = self.table.size();\n+        self.make_some_room(size + 1);\n+        if size > 0 {\n+            self.make_some_room(size - 1);\n+        }\n+\n+        let hash = self.make_hash(&key);\n+        search_entry_hashed(&mut self.table, hash, key)\n+    }\n+}\n+\n+fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n+        -> Entry<'a, K, V> {\n+    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, &hash);\n+    let ib = probe.index();\n+\n+    loop {\n+        let bucket = match probe.peek() {\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return Vacant(VacantEntry {\n+                    hash: hash,\n+                    key: k,\n+                    elem: NoElem(bucket),\n+                });\n+            },\n+            Full(bucket) => bucket\n+        };\n+\n+        if bucket.hash() == hash {\n+            let is_eq = {\n+                let (bucket_k, _) = bucket.read();\n+                k == *bucket_k\n+            };\n+\n+            if is_eq {\n+                return Occupied(OccupiedEntry{\n+                    elem: bucket,\n+                });\n+            }\n+        }\n+\n+        let robin_ib = bucket.index() as int - bucket.distance() as int;\n+\n+        if (ib as int) < robin_ib {\n+            // Found a luckier bucket than me. Better steal his spot.\n+            return Vacant(VacantEntry {\n+                hash: hash,\n+                key: k,\n+                elem: NeqElem(bucket, robin_ib as uint),\n+            });\n+        }\n+\n+        probe = bucket.next();\n+        assert!(probe.index() != ib + size + 1);\n+    }\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n@@ -1354,6 +1497,35 @@ pub struct MoveEntries<K, V> {\n     inner: iter::Map<'static, (SafeHash, K, V), (K, V), table::MoveEntries<K, V>>\n }\n \n+/// A view into a single occupied location in a HashMap\n+pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single empty location in a HashMap\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    hash: SafeHash,\n+    key: K,\n+    elem: VacantEntryState<K,V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single location in a map, which may be vacant or occupied\n+pub enum Entry<'a, K:'a, V:'a> {\n+    /// An occupied Entry\n+    Occupied(OccupiedEntry<'a, K, V>),\n+    /// A vacant Entry\n+    Vacant(VacantEntry<'a, K, V>),\n+}\n+\n+/// Possible states of a VacantEntry\n+enum VacantEntryState<K, V, M> {\n+    /// The index is occupied, but the key to insert has precedence,\n+    /// and will kick the current one out on insertion\n+    NeqElem(FullBucket<K, V, M>, uint),\n+    /// The index is genuinely vacant\n+    NoElem(EmptyBucket<K, V, M>),\n+}\n+\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n@@ -1387,6 +1559,57 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n     }\n }\n \n+impl<'a, K, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the value in the entry\n+    pub fn get(&self) -> &V {\n+        let (_, v) = self.elem.read();\n+        v\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry\n+    pub fn get_mut(&mut self) -> &mut V {\n+        let (_, v) = self.elem.read_mut();\n+        v\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// with a lifetime bound to the map itself\n+    pub fn into_mut(self) -> &'a mut V {\n+        let (_, v) = self.elem.into_mut_refs();\n+        v\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value\n+    pub fn set(&mut self, mut value: V) -> V {\n+        let old_value = self.get_mut();\n+        mem::swap(&mut value, old_value);\n+        value\n+    }\n+\n+    /// Takes the value out of the entry, and returns it\n+    pub fn take(self) -> V {\n+        let (_, _, v) = self.elem.take();\n+        v\n+    }\n+}\n+\n+impl<'a, K, V> VacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it\n+    pub fn set(self, value: V) -> &'a mut V {\n+        match self.elem {\n+            NeqElem(bucket, ib) => {\n+                robin_hood(bucket, ib, self.hash, self.key, value)\n+            }\n+            NoElem(bucket) => {\n+                let full = bucket.put(self.hash, self.key, value);\n+                let (_, v) = full.into_mut_refs();\n+                v\n+            }\n+        }\n+    }\n+}\n+\n /// HashMap keys iterator\n pub type Keys<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n@@ -1417,6 +1640,7 @@ mod test_map {\n     use prelude::*;\n \n     use super::HashMap;\n+    use super::{Occupied, Vacant};\n     use cmp::Equiv;\n     use hash;\n     use iter::{Iterator,range_inclusive,range_step_inclusive};\n@@ -2027,4 +2251,56 @@ mod test_map {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1i, 10i), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.set(100), 10);\n+            }\n+        }\n+        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                let new_v = (*v) * 10;\n+                *v = new_v;\n+            }\n+        }\n+        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.take(), 30);\n+            }\n+        }\n+        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.set(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n }"}, {"sha": "6508d4609f1475a68d525f586bc36ab48e14eb89", "filename": "src/libstd/collections/hashmap/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -14,6 +14,11 @@ pub use self::map::HashMap;\n pub use self::map::Entries;\n pub use self::map::MutEntries;\n pub use self::map::MoveEntries;\n+pub use self::map::Entry;\n+pub use self::map::Occupied;\n+pub use self::map::Vacant;\n+pub use self::map::OccupiedEntry;\n+pub use self::map::VacantEntry;\n pub use self::map::Keys;\n pub use self::map::Values;\n pub use self::map::INITIAL_CAPACITY;"}, {"sha": "6fe4f5b324c6e7af6111cbb6071e0b25b5f22a06", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -20,6 +20,7 @@ use ast::{Ident, Mrk, Name, SyntaxContext};\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n@@ -65,10 +66,10 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    let new_ctxt = |_: &(SyntaxContext, Mrk)|\n-                   idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt));\n-\n-    *table.mark_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n+    * match table.mark_memo.borrow_mut().entry(key) {\n+        Vacant(entry) => entry.set(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt))),\n+        Occupied(entry) => entry.into_mut(),\n+    }\n }\n \n /// Extend a syntax context with a given rename\n@@ -83,10 +84,11 @@ fn apply_rename_internal(id: Ident,\n                        ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, id, to);\n-    let new_ctxt = |_: &(SyntaxContext, Ident, Name)|\n-                   idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt));\n \n-    *table.rename_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n+    * match table.rename_memo.borrow_mut().entry(key) {\n+        Vacant(entry) => entry.set(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt))),\n+        Occupied(entry) => entry.into_mut(),\n+    }\n }\n \n /// Apply a list of renamings to a context"}, {"sha": "72c61f3afc7cdc2ad97894f08a7c56725a80a415", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -11,6 +11,7 @@\n #![allow(missing_doc)]\n \n use std::collections::hashmap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n@@ -442,7 +443,10 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n     let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n     for elem in iter {\n-        map.insert_or_update_with(elem, 1, |_, count| *count += 1);\n+        match map.entry(elem) {\n+            Occupied(mut entry) => { *entry.get_mut() += 1; },\n+            Vacant(entry) => { entry.set(1); },\n+        }\n     }\n     map\n }"}, {"sha": "0b227b68ca8968d0082bd777e2320f7ad926e283", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e13d3aa00e8cfdf1a64f58f6c649460400231c0/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "patch": "@@ -23,6 +23,7 @@\n #![feature(default_type_params)]\n \n use std::collections::HashMap;\n+use std::collections::hashmap::{Occupied, Vacant};\n use std::fmt;\n use std::from_str::FromStr;\n use std::hash;\n@@ -342,8 +343,10 @@ pub fn decode_form_urlencoded(s: &[u8])\n                         key: String,\n                         value: String) {\n         if key.len() > 0 && value.len() > 0 {\n-            let values = map.find_or_insert_with(key, |_| vec!());\n-            values.push(value);\n+            match map.entry(key) {\n+                Vacant(entry) => { entry.set(vec![value]); },\n+                Occupied(mut entry) => { entry.get_mut().push(value); },\n+            }\n         }\n     }\n "}]}