{"sha": "50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMjc3ZWM1NTVjY2MwYjcyYjk4MDI4YzZmY2MwYjg0NTExY2Y5ZWY=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2013-03-04T23:22:03Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2013-03-07T19:48:28Z"}, "message": "Permit casting region pointers to unsafe ones.", "tree": {"sha": "5a73a4d6c09dc159d191d18b46b0690649694513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a73a4d6c09dc159d191d18b46b0690649694513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "html_url": "https://github.com/rust-lang/rust/commit/50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bc301fd6821a76d91d7c121b2737c473a54897f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc301fd6821a76d91d7c121b2737c473a54897f", "html_url": "https://github.com/rust-lang/rust/commit/2bc301fd6821a76d91d7c121b2737c473a54897f"}], "stats": {"total": 145, "additions": 142, "deletions": 3}, "files": [{"sha": "2e528b4c0dfb4d453d20133fa27164edd364da49", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -107,7 +107,7 @@ pub fn check_expr(sess: Session,\n           expr_lit(_) => (),\n           expr_cast(_, _) => {\n             let ety = ty::expr_ty(tcx, e);\n-            if !ty::type_is_numeric(ety) {\n+            if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n                 sess.span_err(e.span, ~\"can not cast to `\" +\n                               ppaux::ty_to_str(tcx, ety) +\n                               ~\"` in a constant expression\");"}, {"sha": "0dca64ee8d374cf8578c2a3a4bca2cf626cc2913", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -110,7 +110,7 @@ pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n     let mut v1 = v;\n     loop {\n         // Only rptrs can be autoderef'ed in a const context.\n-        match ty::get(ty).sty {\n+        match ty::get(t1).sty {\n             ty::ty_rptr(_, mt) => {\n                 t1 = mt.ty;\n                 v1 = const_deref(cx, v1);\n@@ -338,6 +338,9 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                                        integral or float\")\n                 }\n               }\n+              (expr::cast_pointer, expr::cast_pointer) => {\n+                llvm::LLVMConstPointerCast(v, llty)\n+              }\n               _ => {\n                 cx.sess.impossible_case(e.span,\n                                         ~\"bad combination of types for cast\")"}, {"sha": "80b13341e54e195f5430a953bc8af011dcdf116d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -93,7 +93,7 @@ use middle::typeck::check::method::TransformTypeNormally;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n-use middle::typeck::infer::{resolve_type, force_tvar};\n+use middle::typeck::infer::{resolve_type, force_tvar, mk_eqty};\n use middle::typeck::infer;\n use middle::typeck::rscope::{binding_rscope, bound_self_region};\n use middle::typeck::rscope::{RegionError};\n@@ -2452,6 +2452,44 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n             if type_is_c_like_enum(fcx,expr.span,t_e) && t_1_is_scalar {\n                 /* this case is allowed */\n+            } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n+                      type_is_unsafe_ptr(fcx, expr.span, t_1) {\n+\n+                fn is_vec(t: ty::t) -> bool {\n+                    match ty::get(t).sty {\n+                      ty::ty_evec(_,_) => true,\n+                      _ => false\n+                    }\n+                }\n+                fn types_compatible(fcx: @mut FnCtxt, sp: span, t1: ty::t,\n+                                    t2: ty::t) -> bool {\n+                    if !is_vec(t1) {\n+                        false\n+                    } else {\n+                        let el = ty::sequence_element_type(fcx.tcx(), t1);\n+                        infer::mk_eqty(fcx.infcx(), false, sp, el, t2).is_ok()\n+                    }\n+                }\n+\n+                // Due to the limitations of LLVM global constants,\n+                // region pointers end up pointing at copies of\n+                // vector elements instead of the original values.\n+                // To allow unsafe pointers to work correctly, we\n+                // need to special-case obtaining an unsafe pointer\n+                // from a region pointer to a vector.\n+\n+                /* this cast is only allowed from &[T] to *T or\n+                   &T to *T. */\n+                let te = structurally_resolved_type(fcx, e.span, t_e);\n+                match (&ty::get(te).sty, &ty::get(t_1).sty) {\n+                  (&ty::ty_rptr(_, mt1), &ty::ty_ptr(mt2))\n+                    if types_compatible(fcx, e.span, mt1.ty, mt2.ty) => {\n+                      /* this case is allowed */\n+                  }\n+                  _ => {\n+                    demand::coerce(fcx, e.span, t_1, e);\n+                  }\n+                }\n             } else if !(type_is_scalar(fcx,expr.span,t_e) && t_1_is_scalar) {\n                 /*\n                 If more type combinations should be supported than are\n@@ -3081,6 +3119,16 @@ pub fn type_is_scalar(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n     return ty::type_is_scalar(typ_s);\n }\n \n+pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_unsafe_ptr(typ_s);\n+}\n+\n+pub fn type_is_region_ptr(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_region_ptr(typ_s);\n+}\n+\n pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);"}, {"sha": "a083757a0eb9a7fc732adf20bb096ba5f9badc90", "filename": "src/test/compile-fail/cast-vector-to-unsafe-nonstatic.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let foo = ['h' as u8, 'i' as u8, 0 as u8];\n+    let bar = &foo as *u8; //~ ERROR mismatched types\n+}\n\\ No newline at end of file"}, {"sha": "08fa6915106fe123493a2ea0a587d1dafe69d466", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const a: &static/str = &\"foo\";\n+const b: *u8 = a as *u8; //~ ERROR non-scalar cast\n+const c: *u8 = &a as *u8; //~ ERROR mismatched types\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "fe91056d47b6f847b909be3c39b989aea562345d", "filename": "src/test/compile-fail/const-cast-wrong-type.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const a: [u8 * 3] = ['h' as u8, 'i' as u8, 0 as u8];\n+const b: *i8 = &a as *i8; //~ ERROR mismatched types\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "9174b45d1000c1e17c3952433b0d89eaf6569e80", "filename": "src/test/run-pass/const-cast.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern fn foo() {}\n+\n+const x: *u8 = foo;\n+const y: *libc::c_void = x as *libc::c_void;\n+const a: &static/int = &10;\n+const b: *int = a as *int;\n+\n+fn main() {\n+    assert x as *libc::c_void == y;\n+    assert a as *int == b;\n+}\n\\ No newline at end of file"}, {"sha": "3438e65f05fad9d6227225029875eaf6c992bbda", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50277ec555ccc0b72b98028c6fcc0b84511cf9ef/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=50277ec555ccc0b72b98028c6fcc0b84511cf9ef", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const a: [u8 * 3] = ['h' as u8, 'i' as u8, 0 as u8];\n+const c: &static/[u8 * 3] = &a;\n+const b: *u8 = c as *u8;\n+\n+fn main() {\n+    let foo = &a as *u8;\n+    assert unsafe { str::raw::from_bytes(a) } == ~\"hi\\x00\";\n+    assert unsafe { str::raw::from_buf(foo) } == ~\"hi\";\n+    assert unsafe { str::raw::from_buf(b) } == ~\"hi\";\n+    assert unsafe { *b == a[0] };\n+    assert unsafe { *(&c[0] as *u8) == a[0] };\n+}\n\\ No newline at end of file"}]}