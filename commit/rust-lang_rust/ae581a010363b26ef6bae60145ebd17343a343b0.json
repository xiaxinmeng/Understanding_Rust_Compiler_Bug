{"sha": "ae581a010363b26ef6bae60145ebd17343a343b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNTgxYTAxMDM2M2IyNmVmNmJhZTYwMTQ1ZWJkMTczNDNhMzQzYjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T22:28:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:35Z"}, "message": "native: Require all results are used and fix fallout", "tree": {"sha": "a5fb5e0ddfb26e90129f9ca91ecbc21e4505e142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5fb5e0ddfb26e90129f9ca91ecbc21e4505e142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae581a010363b26ef6bae60145ebd17343a343b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae581a010363b26ef6bae60145ebd17343a343b0", "html_url": "https://github.com/rust-lang/rust/commit/ae581a010363b26ef6bae60145ebd17343a343b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae581a010363b26ef6bae60145ebd17343a343b0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41cde566bb81bdd5f9ffdefadc7c8256c65624dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/41cde566bb81bdd5f9ffdefadc7c8256c65624dc", "html_url": "https://github.com/rust-lang/rust/commit/41cde566bb81bdd5f9ffdefadc7c8256c65624dc"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "868586b36911e431ac6b83d227a5cbc9da7f857f", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -23,7 +23,7 @@ static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: Mutex = MUTEX_INIT;\n \n pub fn increment() {\n-    unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst); }\n+    let _ = unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst) };\n }\n \n pub fn decrement() {"}, {"sha": "e6bead60d1bec201e267a749815f38b879a88896", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -422,7 +422,7 @@ impl rtio::RtioFileStream for CFile {\n \n impl Drop for CFile {\n     fn drop(&mut self) {\n-        unsafe { libc::fclose(self.file); }\n+        unsafe { let _ = libc::fclose(self.file); }\n     }\n }\n \n@@ -512,7 +512,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                     paths.push(Path::new(cstr));\n                     entry_ptr = readdir(dir_ptr);\n                 }\n-                closedir(dir_ptr);\n+                assert_eq!(closedir(dir_ptr), 0);\n                 Ok(paths)\n             } else {\n                 Err(super::last_error())\n@@ -932,7 +932,7 @@ mod tests {\n             let mut reader = FileDesc::new(input, true);\n             let mut writer = FileDesc::new(out, true);\n \n-            writer.inner_write(bytes!(\"test\"));\n+            writer.inner_write(bytes!(\"test\")).unwrap();\n             let mut buf = [0u8, ..4];\n             match reader.inner_read(buf) {\n                 Ok(4) => {\n@@ -957,9 +957,9 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\"));\n+            file.write(bytes!(\"test\")).unwrap();\n             let mut buf = [0u8, ..4];\n-            file.seek(0, io::SeekSet);\n+            let _ = file.seek(0, io::SeekSet).unwrap();\n             match file.read(buf) {\n                 Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);"}, {"sha": "ac68b1523d7d995153b4af43be0183f6cbcc1d77", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -112,8 +112,8 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n     }\n }\n \n-#[cfg(windows)] unsafe fn close(sock: sock_t) { libc::closesocket(sock); }\n-#[cfg(unix)]    unsafe fn close(sock: sock_t) { libc::close(sock); }\n+#[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n+#[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n \n fn sockname(fd: sock_t,\n             f: extern \"system\" unsafe fn(sock_t, *mut libc::sockaddr,"}, {"sha": "c2522d551b6d586c327fd67c82f1daaa801e6bbb", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -102,9 +102,9 @@ impl Process {\n                                    cwd.as_ref(), in_fd, out_fd, err_fd);\n \n         unsafe {\n-            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in in_pipe.iter() { let _ = libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { let _ = libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { let _ = libc::close(pipe.out); }\n         }\n \n         match res {\n@@ -163,8 +163,8 @@ impl rtio::RtioProcess for Process {\n \n         #[cfg(not(windows))]\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            Ok(())\n+            let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            super::mkerr_libc(r)\n         }\n     }\n }\n@@ -445,24 +445,24 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         rustrt::rust_unset_sigprocmask();\n \n         if in_fd == -1 {\n-            libc::close(libc::STDIN_FILENO);\n+            let _ = libc::close(libc::STDIN_FILENO);\n         } else if retry(|| dup2(in_fd, 0)) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n         if out_fd == -1 {\n-            libc::close(libc::STDOUT_FILENO);\n+            let _ = libc::close(libc::STDOUT_FILENO);\n         } else if retry(|| dup2(out_fd, 1)) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n         if err_fd == -1 {\n-            libc::close(libc::STDERR_FILENO);\n+            let _ = libc::close(libc::STDERR_FILENO);\n         } else if retry(|| dup2(err_fd, 2)) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).rev() {\n             if fd != output.fd() {\n-                close(fd as c_int);\n+                let _ = close(fd as c_int);\n             }\n         }\n \n@@ -478,7 +478,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             }\n         });\n         with_argv(prog, args, |argv| {\n-            execvp(*argv, argv);\n+            let _ = execvp(*argv, argv);\n             let errno = os::errno();\n             let bytes = [\n                 (errno << 24) as u8,"}, {"sha": "cda239329dcc07ca571da85b1fa1bfe25a7771a7", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -187,7 +187,7 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                fd.inner_read(buf).unwrap();\n+                assert_eq!(fd.inner_read(buf).unwrap(), 1);\n             }\n \n             -1 if os::errno() == libc::EINTR as int => {}\n@@ -216,7 +216,8 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+        // FIXME: this can fail because of EINTR, what do do?\n+        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n     }\n \n     fn inner(&mut self) -> ~Inner {"}, {"sha": "1e4317af397588f86084594d6048bccaf0377e70", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -21,6 +21,7 @@\n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n+#[deny(unused_result, unused_must_use)];\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n@@ -61,9 +62,10 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);\n-    task::new((my_stack_bottom, my_stack_top)).run(|| {\n+    let t = task::new((my_stack_bottom, my_stack_top)).run(|| {\n         exit_code = Some(run(main.take_unwrap()));\n     });\n+    drop(t);\n     unsafe { rt::cleanup(); }\n     // If the exit code wasn't set, then the task block must have failed.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);"}, {"sha": "0def5cb4053386a7c04323c6137ec2c7918c9455", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae581a010363b26ef6bae60145ebd17343a343b0/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=ae581a010363b26ef6bae60145ebd17343a343b0", "patch": "@@ -103,7 +103,8 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n         let mut f = Some(f);\n         let mut task = task;\n         task.put_runtime(ops as ~rt::Runtime);\n-        task.run(|| { f.take_unwrap()() });\n+        let t = task.run(|| { f.take_unwrap()() });\n+        drop(t);\n         bookkeeping::decrement();\n     })\n }"}]}