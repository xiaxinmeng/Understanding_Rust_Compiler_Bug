{"sha": "b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjNkZGQ1OWUyYTA0MTY0NmY3YjMwMGFkNzI3YTVkNGY0OGE0ODg=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-12-31T07:08:15Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2018-01-03T03:51:22Z"}, "message": "Move static code outside of unciode.py.", "tree": {"sha": "fba5ba31c8811e1cdec7ca5efa28f2e1048bedea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fba5ba31c8811e1cdec7ca5efa28f2e1048bedea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "html_url": "https://github.com/rust-lang/rust/commit/b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d", "html_url": "https://github.com/rust-lang/rust/commit/b65f0bedd2f22d9661ecb7092f07746dc2ccfb0d"}], "stats": {"total": 368, "additions": 143, "deletions": 225}, "files": [{"sha": "3e45b08f399dca57d0fe3535f211b47a987130e6", "filename": "src/libstd_unicode/bool_trie.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fbool_trie.rs?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n+/// implemented with postfix compression (sharing of identical child nodes),\n+/// which gives both compact size and fast lookup.\n+///\n+/// The space of Unicode codepoints is divided into 3 subareas, each\n+/// represented by a trie with different depth. In the first (0..0x800), there\n+/// is no trie structure at all; each u64 entry corresponds to a bitvector\n+/// effectively holding 64 bool values.\n+///\n+/// In the second (0x800..0x10000), each child of the root node represents a\n+/// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n+/// the trie stores an 8-bit index into a shared table of leaf values. This\n+/// exploits the fact that in reasonable sets, many such leaves can be shared.\n+///\n+/// In the third (0x10000..0x110000), each child of the root node represents a\n+/// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n+/// of a child tree. Each of these 64 bytes represents an index into the table\n+/// of shared 64-bit leaf values. This exploits the sparse structure in the\n+/// non-BMP range of most Unicode sets.\n+pub struct BoolTrie {\n+    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n+    pub r1: [u64; 32],   // leaves\n+\n+    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n+    pub r2: [u8; 992],      // first level\n+    pub r3: &'static [u64],  // leaves\n+\n+    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n+    pub r4: [u8; 256],       // first level\n+    pub r5: &'static [u8],   // second level\n+    pub r6: &'static [u64],  // leaves\n+}\n+impl BoolTrie {\n+    pub fn lookup(&self, c: char) -> bool {\n+        let c = c as usize;\n+        if c < 0x800 {\n+            trie_range_leaf(c, self.r1[c >> 6])\n+        } else if c < 0x10000 {\n+            let child = self.r2[(c >> 6) - 0x20];\n+            trie_range_leaf(c, self.r3[child as usize])\n+        } else {\n+            let child = self.r4[(c >> 12) - 0x10];\n+            let leaf = self.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n+            trie_range_leaf(c, self.r6[leaf as usize])\n+        }\n+    }\n+}\n+\n+pub struct SmallBoolTrie {\n+    pub(crate) r1: &'static [u8],  // first level\n+    pub(crate) r2: &'static [u64],  // leaves\n+}\n+\n+impl SmallBoolTrie {\n+    pub fn lookup(&self, c: char) -> bool {\n+        let c = c as usize;\n+        match self.r1.get(c >> 6) {\n+            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n+            None => false,\n+        }\n+    }\n+}\n+\n+fn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n+    ((bitmap_chunk >> (c & 63)) & 1) != 0\n+}"}, {"sha": "c1daf6439868fe836d68f39e89dd5f263d086674", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -47,7 +47,9 @@ pub use core::char::CharTryFromError;\n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n pub use core::char::{DecodeUtf8, decode_utf8};\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n-pub use tables::{UnicodeVersion, UNICODE_VERSION};\n+pub use tables::{UNICODE_VERSION};\n+#[unstable(feature = \"unicode\", issue = \"27783\")]\n+pub use version::UnicodeVersion;\n \n /// Returns an iterator that yields the lowercase equivalent of a `char`.\n ///"}, {"sha": "dcae7d0af409543f18442109081f89be7a0a2e82", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -35,15 +35,18 @@\n #![feature(core_char_ext)]\n #![feature(str_internals)]\n #![feature(decode_utf8)]\n-#![feature(fused)]\n #![feature(fn_traits)]\n+#![feature(fused)]\n #![feature(lang_items)]\n+#![feature(non_exhaustive)]\n #![feature(staged_api)]\n #![feature(try_from)]\n #![feature(unboxed_closures)]\n \n+mod bool_trie;\n mod tables;\n mod u_str;\n+mod version;\n pub mod char;\n pub mod lossy;\n "}, {"sha": "b53953b62a7af97883e48ffdbedb6b7f5236bfa1", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 24, "deletions": 107, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -12,23 +12,8 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n-/// Represents a Unicode Version.\n-///\n-/// See also: <http://www.unicode.org/versions/>\n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-pub struct UnicodeVersion {\n-    /// Major version.\n-    pub major: u32,\n-\n-    /// Minor version.\n-    pub minor: u32,\n-\n-    /// Micro (or Update) version.\n-    pub micro: u32,\n-\n-    // Private field to keep struct expandable.\n-    _priv: (),\n-}\n+use version::UnicodeVersion;\n+use bool_trie::{BoolTrie, SmallBoolTrie};\n \n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n /// `CharExt` and `UnicodeStrPrelude` traits are based on.\n@@ -38,76 +23,8 @@ pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n     micro: 0,\n     _priv: (),\n };\n-\n-\n-// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n-// implemented with postfix compression (sharing of identical child nodes),\n-// which gives both compact size and fast lookup.\n-//\n-// The space of Unicode codepoints is divided into 3 subareas, each\n-// represented by a trie with different depth. In the first (0..0x800), there\n-// is no trie structure at all; each u64 entry corresponds to a bitvector\n-// effectively holding 64 bool values.\n-//\n-// In the second (0x800..0x10000), each child of the root node represents a\n-// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n-// the trie stores an 8-bit index into a shared table of leaf values. This\n-// exploits the fact that in reasonable sets, many such leaves can be shared.\n-//\n-// In the third (0x10000..0x110000), each child of the root node represents a\n-// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n-// of a child tree. Each of these 64 bytes represents an index into the table\n-// of shared 64-bit leaf values. This exploits the sparse structure in the\n-// non-BMP range of most Unicode sets.\n-pub struct BoolTrie {\n-    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    r1: [u64; 32],   // leaves\n-\n-    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n-    r2: [u8; 992],      // first level\n-    r3: &'static [u64],  // leaves\n-\n-    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    r4: [u8; 256],       // first level\n-    r5: &'static [u8],   // second level\n-    r6: &'static [u64],  // leaves\n-}\n-\n-fn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n-    ((bitmap_chunk >> (c & 63)) & 1) != 0\n-}\n-\n-fn trie_lookup_range_table(c: char, r: &'static BoolTrie) -> bool {\n-    let c = c as usize;\n-    if c < 0x800 {\n-        trie_range_leaf(c, r.r1[c >> 6])\n-    } else if c < 0x10000 {\n-        let child = r.r2[(c >> 6) - 0x20];\n-        trie_range_leaf(c, r.r3[child as usize])\n-    } else {\n-        let child = r.r4[(c >> 12) - 0x10];\n-        let leaf = r.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n-        trie_range_leaf(c, r.r6[leaf as usize])\n-    }\n-}\n-\n-pub struct SmallBoolTrie {\n-    r1: &'static [u8],  // first level\n-    r2: &'static [u64],  // leaves\n-}\n-\n-impl SmallBoolTrie {\n-    fn lookup(&self, c: char) -> bool {\n-        let c = c as usize;\n-        match self.r1.get(c >> 6) {\n-            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n-            None => false,\n-        }\n-    }\n-}\n-\n pub mod general_category {\n-    pub const Cc_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n+    pub const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 0\n         ],\n@@ -120,7 +37,7 @@ pub mod general_category {\n         Cc_table.lookup(c)\n     }\n \n-    pub const N_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const N_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -212,13 +129,13 @@ pub mod general_category {\n     };\n \n     pub fn N(c: char) -> bool {\n-        super::trie_lookup_range_table(c, N_table)\n+        N_table.lookup(c)\n     }\n \n }\n \n pub mod derived_property {\n-    pub const Alphabetic_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -397,10 +314,10 @@ pub mod derived_property {\n     };\n \n     pub fn Alphabetic(c: char) -> bool {\n-        super::trie_lookup_range_table(c, Alphabetic_table)\n+        Alphabetic_table.lookup(c)\n     }\n \n-    pub const Case_Ignorable_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -529,10 +446,10 @@ pub mod derived_property {\n     };\n \n     pub fn Case_Ignorable(c: char) -> bool {\n-        super::trie_lookup_range_table(c, Case_Ignorable_table)\n+        Case_Ignorable_table.lookup(c)\n     }\n \n-    pub const Cased_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const Cased_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xf7ffffffffffffff, 0xfffffffffffffff0,\n@@ -628,10 +545,10 @@ pub mod derived_property {\n     };\n \n     pub fn Cased(c: char) -> bool {\n-        super::trie_lookup_range_table(c, Cased_table)\n+        Cased_table.lookup(c)\n     }\n \n-    pub const Lowercase_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n             0x55aaaaaaaaaaaaaa, 0xd4aaaaaaaaaaab55, 0xe6512d2a4e243129, 0xaa29aaaab5555240,\n@@ -725,10 +642,10 @@ pub mod derived_property {\n     };\n \n     pub fn Lowercase(c: char) -> bool {\n-        super::trie_lookup_range_table(c, Lowercase_table)\n+        Lowercase_table.lookup(c)\n     }\n \n-    pub const Uppercase_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n             0xaa55555555555555, 0x2b555555555554aa, 0x11aed2d5b1dbced6, 0x55d255554aaaa490,\n@@ -823,10 +740,10 @@ pub mod derived_property {\n     };\n \n     pub fn Uppercase(c: char) -> bool {\n-        super::trie_lookup_range_table(c, Uppercase_table)\n+        Uppercase_table.lookup(c)\n     }\n \n-    pub const XID_Continue_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -998,10 +915,10 @@ pub mod derived_property {\n     };\n \n     pub fn XID_Continue(c: char) -> bool {\n-        super::trie_lookup_range_table(c, XID_Continue_table)\n+        XID_Continue_table.lookup(c)\n     }\n \n-    pub const XID_Start_table: &'static super::BoolTrie = &super::BoolTrie {\n+    pub const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -1175,13 +1092,13 @@ pub mod derived_property {\n     };\n \n     pub fn XID_Start(c: char) -> bool {\n-        super::trie_lookup_range_table(c, XID_Start_table)\n+        XID_Start_table.lookup(c)\n     }\n \n }\n \n pub mod property {\n-    pub const Pattern_White_Space_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n+    pub const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1198,7 +1115,7 @@ pub mod property {\n         Pattern_White_Space_table.lookup(c)\n     }\n \n-    pub const White_Space_table: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\n+    pub const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1238,11 +1155,11 @@ pub mod conversions {\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n+    fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n     }\n \n-    const to_lowercase_table: &'static [(char, [char; 3])] = &[\n+    const to_lowercase_table: &[(char, [char; 3])] = &[\n         ('\\u{41}', ['\\u{61}', '\\0', '\\0']), ('\\u{42}', ['\\u{62}', '\\0', '\\0']), ('\\u{43}',\n         ['\\u{63}', '\\0', '\\0']), ('\\u{44}', ['\\u{64}', '\\0', '\\0']), ('\\u{45}', ['\\u{65}', '\\0',\n         '\\0']), ('\\u{46}', ['\\u{66}', '\\0', '\\0']), ('\\u{47}', ['\\u{67}', '\\0', '\\0']), ('\\u{48}',\n@@ -1826,7 +1743,7 @@ pub mod conversions {\n         ('\\u{1e920}', ['\\u{1e942}', '\\0', '\\0']), ('\\u{1e921}', ['\\u{1e943}', '\\0', '\\0'])\n     ];\n \n-    const to_uppercase_table: &'static [(char, [char; 3])] = &[\n+    const to_uppercase_table: &[(char, [char; 3])] = &[\n         ('\\u{61}', ['\\u{41}', '\\0', '\\0']), ('\\u{62}', ['\\u{42}', '\\0', '\\0']), ('\\u{63}',\n         ['\\u{43}', '\\0', '\\0']), ('\\u{64}', ['\\u{44}', '\\0', '\\0']), ('\\u{65}', ['\\u{45}', '\\0',\n         '\\0']), ('\\u{66}', ['\\u{46}', '\\0', '\\0']), ('\\u{67}', ['\\u{47}', '\\0', '\\0']), ('\\u{68}',"}, {"sha": "a86294930861b8301d0e8f04f3bc466a762372ad", "filename": "src/libstd_unicode/unicode.py", "status": "modified", "additions": 9, "deletions": 116, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Funicode.py?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -38,6 +38,9 @@\n // NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n+\n+use version::UnicodeVersion;\n+use bool_trie::{BoolTrie, SmallBoolTrie};\n '''\n \n # Mapping taken from Table 12 from:\n@@ -274,24 +277,7 @@ def load_properties(f, interestingprops):\n def escape_char(c):\n     return \"'\\\\u{%x}'\" % c if c != 0 else \"'\\\\0'\"\n \n-def emit_bsearch_range_table(f):\n-    f.write(\"\"\"\n-fn bsearch_range_table(c: char, r: &'static [(char, char)]) -> bool {\n-    use core::cmp::Ordering::{Equal, Less, Greater};\n-    r.binary_search_by(|&(lo, hi)| {\n-         if c < lo {\n-             Greater\n-         } else if hi < c {\n-             Less\n-         } else {\n-             Equal\n-         }\n-     })\n-     .is_ok()\n-}\\n\n-\"\"\")\n-\n-def emit_table(f, name, t_data, t_type = \"&'static [(char, char)]\", is_pub=True,\n+def emit_table(f, name, t_data, t_type = \"&[(char, char)]\", is_pub=True,\n         pfun=lambda x: \"(%s,%s)\" % (escape_char(x[0]), escape_char(x[1]))):\n     pub_string = \"\"\n     if is_pub:\n@@ -307,77 +293,6 @@ def emit_table(f, name, t_data, t_type = \"&'static [(char, char)]\", is_pub=True,\n     format_table_content(f, data, 8)\n     f.write(\"\\n    ];\\n\\n\")\n \n-def emit_trie_lookup_range_table(f):\n-    f.write(\"\"\"\n-\n-// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n-// implemented with postfix compression (sharing of identical child nodes),\n-// which gives both compact size and fast lookup.\n-//\n-// The space of Unicode codepoints is divided into 3 subareas, each\n-// represented by a trie with different depth. In the first (0..0x800), there\n-// is no trie structure at all; each u64 entry corresponds to a bitvector\n-// effectively holding 64 bool values.\n-//\n-// In the second (0x800..0x10000), each child of the root node represents a\n-// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n-// the trie stores an 8-bit index into a shared table of leaf values. This\n-// exploits the fact that in reasonable sets, many such leaves can be shared.\n-//\n-// In the third (0x10000..0x110000), each child of the root node represents a\n-// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n-// of a child tree. Each of these 64 bytes represents an index into the table\n-// of shared 64-bit leaf values. This exploits the sparse structure in the\n-// non-BMP range of most Unicode sets.\n-pub struct BoolTrie {\n-    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    r1: [u64; 32],   // leaves\n-\n-    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n-    r2: [u8; 992],      // first level\n-    r3: &'static [u64],  // leaves\n-\n-    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    r4: [u8; 256],       // first level\n-    r5: &'static [u8],   // second level\n-    r6: &'static [u64],  // leaves\n-}\n-\n-fn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n-    ((bitmap_chunk >> (c & 63)) & 1) != 0\n-}\n-\n-fn trie_lookup_range_table(c: char, r: &'static BoolTrie) -> bool {\n-    let c = c as usize;\n-    if c < 0x800 {\n-        trie_range_leaf(c, r.r1[c >> 6])\n-    } else if c < 0x10000 {\n-        let child = r.r2[(c >> 6) - 0x20];\n-        trie_range_leaf(c, r.r3[child as usize])\n-    } else {\n-        let child = r.r4[(c >> 12) - 0x10];\n-        let leaf = r.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n-        trie_range_leaf(c, r.r6[leaf as usize])\n-    }\n-}\n-\n-pub struct SmallBoolTrie {\n-    r1: &'static [u8],  // first level\n-    r2: &'static [u64],  // leaves\n-}\n-\n-impl SmallBoolTrie {\n-    fn lookup(&self, c: char) -> bool {\n-        let c = c as usize;\n-        match self.r1.get(c >> 6) {\n-            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n-            None => false,\n-        }\n-    }\n-}\n-\n-\"\"\")\n-\n def compute_trie(rawdata, chunksize):\n     root = []\n     childmap = {}\n@@ -410,7 +325,7 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n-    f.write(\"    %sconst %s: &'static super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name))\n+    f.write(\"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name))\n     f.write(\"        r1: [\\n\")\n     data = ','.join('0x%016x' % chunk for chunk in chunks[0:0x800 // CHUNK])\n     format_table_content(f, data, 12)\n@@ -458,7 +373,7 @@ def emit_small_bool_trie(f, name, t_data, is_pub=True):\n     pub_string = \"\"\n     if is_pub:\n         pub_string = \"pub \"\n-    f.write(\"    %sconst %s: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n+    f.write(\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n             % (pub_string, name))\n \n     (r1, r2) = compute_trie(chunks, 1)\n@@ -486,7 +401,7 @@ def emit_property_module(f, mod, tbl, emit):\n         else:\n             emit_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n             f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-            f.write(\"        super::trie_lookup_range_table(c, %s_table)\\n\" % cat)\n+            f.write(\"        %s_table.lookup(c)\\n\" % cat)\n             f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\\n\")\n \n@@ -510,12 +425,12 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n+    fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n         table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n     }\n \n \"\"\")\n-    t_type = \"&'static [(char, [char; 3])]\"\n+    t_type = \"&[(char, [char; 3])]\"\n     pfun = lambda x: \"(%s,[%s,%s,%s])\" % (\n         escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2]))\n     emit_table(f, \"to_lowercase_table\",\n@@ -557,24 +472,6 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n             pattern = \"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n             unicode_version = re.search(pattern, readme.read()).groups()\n         rf.write(\"\"\"\n-/// Represents a Unicode Version.\n-///\n-/// See also: <http://www.unicode.org/versions/>\n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-pub struct UnicodeVersion {\n-    /// Major version.\n-    pub major: u32,\n-\n-    /// Minor version.\n-    pub minor: u32,\n-\n-    /// Micro (or Update) version.\n-    pub micro: u32,\n-\n-    // Private field to keep struct expandable.\n-    _priv: (),\n-}\n-\n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n /// `CharExt` and `UnicodeStrPrelude` traits are based on.\n pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n@@ -596,10 +493,6 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         norm_props = load_properties(\"DerivedNormalizationProps.txt\",\n                      [\"Full_Composition_Exclusion\"])\n \n-        # trie_lookup_table is used in all the property modules below\n-        emit_trie_lookup_range_table(rf)\n-        # emit_bsearch_range_table(rf)\n-\n         # category tables\n         for (name, cat, pfuns) in (\"general_category\", gencats, [\"N\", \"Cc\"]), \\\n                                   (\"derived_property\", derived, want_derived), \\"}, {"sha": "d82a749d91786fc41d2f77a5776154a0b39a5b5f", "filename": "src/libstd_unicode/version.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b3ddd59e2a041646f7b300ad727a5d4f48a488/src%2Flibstd_unicode%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fversion.rs?ref=b4b3ddd59e2a041646f7b300ad727a5d4f48a488", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Represents a Unicode Version.\n+///\n+/// See also: <http://www.unicode.org/versions/>\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+pub struct UnicodeVersion {\n+    /// Major version.\n+    pub major: u32,\n+\n+    /// Minor version.\n+    pub minor: u32,\n+\n+    /// Micro (or Update) version.\n+    pub micro: u32,\n+\n+    // Private field to keep struct expandable.\n+    pub(crate) _priv: (),\n+}"}]}