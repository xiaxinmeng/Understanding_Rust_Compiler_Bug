{"sha": "7ade4d49fc59ec939294897890375a8b86c743e2", "node_id": "C_kwDOAAsO6NoAKDdhZGU0ZDQ5ZmM1OWVjOTM5Mjk0ODk3ODkwMzc1YThiODZjNzQzZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T09:14:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-16T09:14:09Z"}, "message": "Auto merge of #12517 - xuhongxu96:master, r=Veykril\n\nfix methods in pub trait generated by macro cannot be completed\n\nFix #12483\n\nCheck if the container is trait and inherit the visibility to associate items during collection.", "tree": {"sha": "b830dfa6541f266682500727f9f4ec63637ab179", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b830dfa6541f266682500727f9f4ec63637ab179"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ade4d49fc59ec939294897890375a8b86c743e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ade4d49fc59ec939294897890375a8b86c743e2", "html_url": "https://github.com/rust-lang/rust/commit/7ade4d49fc59ec939294897890375a8b86c743e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ade4d49fc59ec939294897890375a8b86c743e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "519d7484f3b1beb25dec9f2249adeaaa21033433", "url": "https://api.github.com/repos/rust-lang/rust/commits/519d7484f3b1beb25dec9f2249adeaaa21033433", "html_url": "https://github.com/rust-lang/rust/commit/519d7484f3b1beb25dec9f2249adeaaa21033433"}, {"sha": "534d71a852264cced80290afb2f994b179ddb40a", "url": "https://api.github.com/repos/rust-lang/rust/commits/534d71a852264cced80290afb2f994b179ddb40a", "html_url": "https://github.com/rust-lang/rust/commit/534d71a852264cced80290afb2f994b179ddb40a"}], "stats": {"total": 336, "additions": 252, "deletions": 84}, "files": [{"sha": "7436f0100bddd086f267f29c475290db179285f7", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -40,6 +40,11 @@ impl FunctionData {\n         let cfg_options = &crate_graph[krate].cfg_options;\n         let item_tree = loc.id.item_tree(db);\n         let func = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[func.visibility].clone()\n+        };\n \n         let enabled_params = func\n             .params\n@@ -93,7 +98,7 @@ impl FunctionData {\n             ret_type: func.ret_type.clone(),\n             async_ret_type: func.async_ret_type.clone(),\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n-            visibility: item_tree[func.visibility].clone(),\n+            visibility,\n             abi: func.abi.clone(),\n             legacy_const_generics_indices,\n             flags,\n@@ -171,11 +176,16 @@ impl TypeAliasData {\n         let loc = typ.lookup(db);\n         let item_tree = loc.id.item_tree(db);\n         let typ = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[typ.visibility].clone()\n+        };\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n-            visibility: item_tree[typ.visibility].clone(),\n+            visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n             bounds: typ.bounds.to_vec(),\n         })\n@@ -385,11 +395,16 @@ impl ConstData {\n         let loc = konst.lookup(db);\n         let item_tree = loc.id.item_tree(db);\n         let konst = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[konst.visibility].clone()\n+        };\n \n         Arc::new(ConstData {\n             name: konst.name.clone(),\n             type_ref: konst.type_ref.clone(),\n-            visibility: item_tree[konst.visibility].clone(),\n+            visibility,\n         })\n     }\n }"}, {"sha": "7f2551e941871ffaaa47748906b7f9272bd154f2", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -1,6 +1,6 @@\n //! AST -> `ItemTree` lowering code.\n \n-use std::{collections::hash_map::Entry, mem, sync::Arc};\n+use std::{collections::hash_map::Entry, sync::Arc};\n \n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n use syntax::ast::{self, HasModuleItem};\n@@ -21,7 +21,6 @@ pub(super) struct Ctx<'a> {\n     tree: ItemTree,\n     source_ast_id_map: Arc<AstIdMap>,\n     body_ctx: crate::body::LowerCtx<'a>,\n-    forced_visibility: Option<RawVisibilityId>,\n }\n \n impl<'a> Ctx<'a> {\n@@ -31,7 +30,6 @@ impl<'a> Ctx<'a> {\n             tree: ItemTree::default(),\n             source_ast_id_map: db.ast_id_map(file),\n             body_ctx: crate::body::LowerCtx::new(db, file),\n-            forced_visibility: None,\n         }\n     }\n \n@@ -225,11 +223,10 @@ impl<'a> Ctx<'a> {\n         let visibility = self.lower_visibility(enum_);\n         let name = enum_.name()?.as_name();\n         let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n-        let variants =\n-            self.with_inherited_visibility(visibility, |this| match &enum_.variant_list() {\n-                Some(variant_list) => this.lower_variants(variant_list),\n-                None => IdxRange::new(this.next_variant_idx()..this.next_variant_idx()),\n-            });\n+        let variants = match &enum_.variant_list() {\n+            Some(variant_list) => self.lower_variants(variant_list),\n+            None => IdxRange::new(self.next_variant_idx()..self.next_variant_idx()),\n+        };\n         let ast_id = self.source_ast_id_map.ast_id(enum_);\n         let res = Enum { name, visibility, generic_params, variants, ast_id };\n         Some(id(self.data().enums.alloc(res)))\n@@ -440,18 +437,15 @@ impl<'a> Ctx<'a> {\n         let is_auto = trait_def.auto_token().is_some();\n         let is_unsafe = trait_def.unsafe_token().is_some();\n         let items = trait_def.assoc_item_list().map(|list| {\n-            let db = self.db;\n-            self.with_inherited_visibility(visibility, |this| {\n-                list.assoc_items()\n-                    .filter_map(|item| {\n-                        let attrs = RawAttrs::new(db, &item, this.hygiene());\n-                        this.lower_assoc_item(&item).map(|item| {\n-                            this.add_attrs(ModItem::from(item).into(), attrs);\n-                            item\n-                        })\n+            list.assoc_items()\n+                .filter_map(|item| {\n+                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    self.lower_assoc_item(&item).map(|item| {\n+                        self.add_attrs(ModItem::from(item).into(), attrs);\n+                        item\n                     })\n-                    .collect()\n-            })\n+                })\n+                .collect()\n         });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n         let res = Trait {\n@@ -622,13 +616,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_visibility(&mut self, item: &dyn ast::HasVisibility) -> RawVisibilityId {\n-        let vis = match self.forced_visibility {\n-            Some(vis) => return vis,\n-            None => {\n-                RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), self.hygiene())\n-            }\n-        };\n-\n+        let vis = RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), self.hygiene());\n         self.data().vis.alloc(vis)\n     }\n \n@@ -649,18 +637,6 @@ impl<'a> Ctx<'a> {\n         }\n     }\n \n-    /// Forces the visibility `vis` to be used for all items lowered during execution of `f`.\n-    fn with_inherited_visibility<R>(\n-        &mut self,\n-        vis: RawVisibilityId,\n-        f: impl FnOnce(&mut Self) -> R,\n-    ) -> R {\n-        let old = mem::replace(&mut self.forced_visibility, Some(vis));\n-        let res = f(self);\n-        self.forced_visibility = old;\n-        res\n-    }\n-\n     fn next_field_idx(&self) -> Idx<Field> {\n         Idx::from_raw(RawIdx::from(\n             self.tree.data.as_ref().map_or(0, |data| data.fields.len() as u32),"}, {"sha": "5cdf36cc61b83f2859b5149a8592b31fef9604da", "filename": "crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -358,40 +358,3 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n         \"#]],\n     )\n }\n-\n-#[test]\n-fn inherit_visibility() {\n-    check(\n-        r#\"\n-pub(crate) enum En {\n-    Var1(u8),\n-    Var2 {\n-        fld: u8,\n-    },\n-}\n-\n-pub(crate) trait Tr {\n-    fn f();\n-    fn method(&self) {}\n-}\n-        \"#,\n-        expect![[r#\"\n-            pub(crate) enum En {\n-                Var1(\n-                    pub(crate) 0: u8,\n-                ),\n-                Var2 {\n-                    pub(crate) fld: u8,\n-                },\n-            }\n-\n-            pub(crate) trait Tr<Self> {\n-                pub(crate) fn f() -> ();\n-\n-                pub(crate) fn method(\n-                    _: &Self,  // self\n-                ) -> () { ... }\n-            }\n-        \"#]],\n-    )\n-}"}, {"sha": "4eb1fccd7d32787c01f83d8b3d91a8fc8fe50650", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 107, "deletions": 5, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -117,13 +117,20 @@ fn complete_methods(\n mod tests {\n     use expect_test::{expect, Expect};\n \n-    use crate::tests::{check_edit, completion_list_no_kw};\n+    use crate::tests::{\n+        check_edit, completion_list_no_kw, completion_list_no_kw_with_private_editable,\n+    };\n \n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = completion_list_no_kw(ra_fixture);\n         expect.assert_eq(&actual);\n     }\n \n+    fn check_with_private_editable(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list_no_kw_with_private_editable(ra_fixture);\n+        expect.assert_eq(&actual);\n+    }\n+\n     #[test]\n     fn test_struct_field_and_method_completion() {\n         check(\n@@ -200,6 +207,101 @@ pub mod m {\n }\n //- /main.rs crate:main deps:lib new_source_root:local\n fn foo(a: lib::m::A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                fd pub_field u32\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib new_source_root:library\n+pub mod m {\n+    pub struct A {\n+        private_field: u32,\n+        pub pub_field: u32,\n+        pub(crate) crate_field: u32,\n+        pub(super) super_field: u32,\n+    }\n+}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo(a: lib::m::A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                fd pub_field u32\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib new_source_root:library\n+pub mod m {\n+    pub struct A(\n+        i32,\n+        pub f64,\n+    );\n+}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo(a: lib::m::A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                fd 1 f64\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib new_source_root:local\n+pub struct A {}\n+mod m {\n+    impl super::A {\n+        fn private_method(&self) {}\n+        pub(crate) fn crate_method(&self) {}\n+        pub fn pub_method(&self) {}\n+    }\n+}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo(a: lib::A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                me pub_method() fn(&self)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib new_source_root:library\n+pub struct A {}\n+mod m {\n+    impl super::A {\n+        fn private_method(&self) {}\n+        pub(crate) fn crate_method(&self) {}\n+        pub fn pub_method(&self) {}\n+    }\n+}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo(a: lib::A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                me pub_method() fn(&self)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_visibility_filtering_with_private_editable_enabled() {\n+        check_with_private_editable(\n+            r#\"\n+//- /lib.rs crate:lib new_source_root:local\n+pub mod m {\n+    pub struct A {\n+        private_field: u32,\n+        pub pub_field: u32,\n+        pub(crate) crate_field: u32,\n+        pub(super) super_field: u32,\n+    }\n+}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo(a: lib::m::A) { a.$0 }\n \"#,\n             expect![[r#\"\n                 fd crate_field   u32\n@@ -209,7 +311,7 @@ fn foo(a: lib::m::A) { a.$0 }\n             \"#]],\n         );\n \n-        check(\n+        check_with_private_editable(\n             r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub mod m {\n@@ -228,7 +330,7 @@ fn foo(a: lib::m::A) { a.$0 }\n             \"#]],\n         );\n \n-        check(\n+        check_with_private_editable(\n             r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub mod m {\n@@ -245,7 +347,7 @@ fn foo(a: lib::m::A) { a.$0 }\n             \"#]],\n         );\n \n-        check(\n+        check_with_private_editable(\n             r#\"\n //- /lib.rs crate:lib new_source_root:local\n pub struct A {}\n@@ -265,7 +367,7 @@ fn foo(a: lib::A) { a.$0 }\n                 me pub_method()     fn(&self)\n             \"#]],\n         );\n-        check(\n+        check_with_private_editable(\n             r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub struct A {}"}, {"sha": "4be6acbe8461eef57bb1ca6686ac4459ec4346fe", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -65,7 +65,7 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_postfix_completions: true,\n     enable_imports_on_the_fly: true,\n     enable_self_on_the_fly: true,\n-    enable_private_editable: true,\n+    enable_private_editable: false,\n     callable: Some(CallableSnippets::FillArguments),\n     snippet_cap: SnippetCap::new(true),\n     insert_use: InsertUseConfig {\n@@ -86,6 +86,12 @@ pub(crate) fn completion_list_no_kw(ra_fixture: &str) -> String {\n     completion_list_with_config(TEST_CONFIG, ra_fixture, false, None)\n }\n \n+pub(crate) fn completion_list_no_kw_with_private_editable(ra_fixture: &str) -> String {\n+    let mut config = TEST_CONFIG.clone();\n+    config.enable_private_editable = true;\n+    completion_list_with_config(config, ra_fixture, false, None)\n+}\n+\n pub(crate) fn completion_list_with_trigger_character(\n     ra_fixture: &str,\n     trigger_character: Option<char>,"}, {"sha": "4535923b28b5a97713c2edc9e765f00734d69963", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ade4d49fc59ec939294897890375a8b86c743e2/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=7ade4d49fc59ec939294897890375a8b86c743e2", "patch": "@@ -636,3 +636,109 @@ fn bar() -> Bar {\n             \"#]],\n     )\n }\n+\n+#[test]\n+fn completes_fn_in_pub_trait_generated_by_macro() {\n+    check(\n+        r#\"\n+mod other_mod {\n+    macro_rules! make_method {\n+        ($name:ident) => {\n+            fn $name(&self) {}\n+        };\n+    }\n+\n+    pub trait MyTrait {\n+        make_method! { by_macro }\n+        fn not_by_macro(&self) {}\n+    }\n+\n+    pub struct Foo {}\n+\n+    impl MyTrait for Foo {}\n+}\n+\n+fn main() {\n+    use other_mod::{Foo, MyTrait};\n+    let f = Foo {};\n+    f.$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me by_macro() (as MyTrait) fn(&self)\n+            me not_by_macro() (as MyTrait) fn(&self)\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_fn_in_pub_trait_generated_by_recursive_macro() {\n+    check(\n+        r#\"\n+mod other_mod {\n+    macro_rules! make_method {\n+        ($name:ident) => {\n+            fn $name(&self) {}\n+        };\n+    }\n+\n+    macro_rules! make_trait {\n+        () => {\n+            pub trait MyTrait {\n+                make_method! { by_macro }\n+                fn not_by_macro(&self) {}\n+            }\n+        }\n+    }\n+\n+    make_trait!();\n+\n+    pub struct Foo {}\n+\n+    impl MyTrait for Foo {}\n+}\n+\n+fn main() {\n+    use other_mod::{Foo, MyTrait};\n+    let f = Foo {};\n+    f.$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me by_macro() (as MyTrait) fn(&self)\n+            me not_by_macro() (as MyTrait) fn(&self)\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_const_in_pub_trait_generated_by_macro() {\n+    check(\n+        r#\"\n+mod other_mod {\n+    macro_rules! make_const {\n+        ($name:ident) => {\n+            const $name: u8 = 1;\n+        };\n+    }\n+\n+    pub trait MyTrait {\n+        make_const! { by_macro }\n+    }\n+\n+    pub struct Foo {}\n+\n+    impl MyTrait for Foo {}\n+}\n+\n+fn main() {\n+    use other_mod::{Foo, MyTrait};\n+    let f = Foo {};\n+    Foo::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            ct by_macro (as MyTrait) pub const by_macro: u8\n+        \"#]],\n+    )\n+}"}]}