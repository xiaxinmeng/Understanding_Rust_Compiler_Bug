{"sha": "1020784040894716670b2d187ad90f145f856900", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjA3ODQwNDA4OTQ3MTY2NzBiMmQxODdhZDkwZjE0NWY4NTY5MDA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-30T11:30:22Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-02-02T12:04:34Z"}, "message": "BTreeMap: make Ord bound explicit, compile-test its absence", "tree": {"sha": "f3f4306870b777d1326fb53d5a8e9329917cb5a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3f4306870b777d1326fb53d5a8e9329917cb5a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1020784040894716670b2d187ad90f145f856900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1020784040894716670b2d187ad90f145f856900", "html_url": "https://github.com/rust-lang/rust/commit/1020784040894716670b2d187ad90f145f856900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1020784040894716670b2d187ad90f145f856900/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "html_url": "https://github.com/rust-lang/rust/commit/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda"}], "stats": {"total": 245, "additions": 191, "deletions": 54}, "files": [{"sha": "6bd4e8d212ce8b31af3ba066694f17fd86241ccf", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=1020784040894716670b2d187ad90f145f856900", "patch": "@@ -460,7 +460,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-impl<K: Ord, V> BTreeMap<K, V> {\n+impl<K, V> BTreeMap<K, V> {\n     /// Makes a new, empty `BTreeMap`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -479,7 +479,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeMap<K, V> {\n+    pub const fn new() -> BTreeMap<K, V>\n+    where\n+        K: Ord,\n+    {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -498,7 +501,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        K: Ord,\n+    {\n         *self = BTreeMap::new();\n     }\n \n@@ -522,7 +528,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -550,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -578,7 +584,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n@@ -604,7 +613,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n@@ -631,7 +643,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+    pub fn pop_first(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -652,7 +667,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n@@ -678,7 +696,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n@@ -705,7 +726,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+    pub fn pop_last(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -729,7 +753,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.get(key).is_some()\n@@ -758,7 +782,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_mut()?.borrow_mut();\n@@ -795,7 +819,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V>\n+    where\n+        K: Ord,\n+    {\n         match self.entry(key) {\n             Occupied(mut entry) => Some(entry.insert(value)),\n             Vacant(entry) => {\n@@ -826,7 +853,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.remove_entry(key).map(|(_, v)| v)\n@@ -853,7 +880,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n@@ -885,6 +912,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         self.drain_filter(|k, v| !f(k, v));\n@@ -919,7 +947,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(a[&5], \"f\");\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        K: Ord,\n+    {\n         // Do we have to append anything at all?\n         if other.is_empty() {\n             return;\n@@ -970,7 +1001,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n@@ -1016,7 +1047,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n@@ -1047,7 +1078,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n@@ -1091,7 +1125,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n     {\n         if self.is_empty() {\n             return Self::new();\n@@ -1149,12 +1183,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n             let front = root.borrow_mut().first_leaf_edge();\n@@ -1187,7 +1225,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_keys(self) -> IntoKeys<K, V> {\n+    pub fn into_keys(self) -> IntoKeys<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoKeys { inner: self.into_iter() }\n     }\n \n@@ -1210,7 +1251,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_values(self) -> IntoValues<K, V> {\n+    pub fn into_values(self) -> IntoValues<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoValues { inner: self.into_iter() }\n     }\n }\n@@ -1967,9 +2011,9 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n+impl<K, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n where\n-    K: Borrow<Q>,\n+    K: Borrow<Q> + Ord,\n     Q: Ord,\n {\n     type Output = V;"}, {"sha": "f9a86f728adb2cbb429164d26aa318ac34ee8ff0", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=1020784040894716670b2d187ad90f145f856900", "patch": "@@ -1706,6 +1706,34 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn map<K>(mut map: BTreeMap<K, ()>) {\n+        map.is_empty();\n+        map.len();\n+        map.iter();\n+        map.iter_mut();\n+        map.keys();\n+        map.values();\n+        map.values_mut();\n+        map.into_iter();\n+    }\n+\n+    fn map_debug<K: Debug>(mut map: BTreeMap<K, ()>) {\n+        format!(\"{:?}\", map);\n+        format!(\"{:?}\", map.iter());\n+        format!(\"{:?}\", map.iter_mut());\n+        format!(\"{:?}\", map.keys());\n+        format!(\"{:?}\", map.values());\n+        format!(\"{:?}\", map.values_mut());\n+        format!(\"{:?}\", map.into_iter());\n+    }\n+\n+    fn map_clone<K: Clone>(mut map: BTreeMap<K, ()>) {\n+        map.clone_from(&map.clone());\n+    }\n+}\n+\n #[allow(dead_code)]\n fn test_const() {\n     const MAP: &'static BTreeMap<(), ()> = &BTreeMap::new();"}, {"sha": "09872e248a3545f737a7f5a83888a39b61dffd46", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=1020784040894716670b2d187ad90f145f856900", "patch": "@@ -222,7 +222,7 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n // and it's a power of two to make that division cheap.\n const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n \n-impl<T: Ord> BTreeSet<T> {\n+impl<T> BTreeSet<T> {\n     /// Makes a new, empty `BTreeSet`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -237,7 +237,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeSet<T> {\n+    pub const fn new() -> BTreeSet<T>\n+    where\n+        T: Ord,\n+    {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -267,7 +270,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n     where\n         K: Ord,\n-        T: Borrow<K>,\n+        T: Borrow<K> + Ord,\n         R: RangeBounds<K>,\n     {\n         Range { iter: self.map.range(range) }\n@@ -294,7 +297,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -352,10 +358,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(\n-        &'a self,\n-        other: &'a BTreeSet<T>,\n-    ) -> SymmetricDifference<'a, T> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>) -> SymmetricDifference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -380,7 +386,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -428,7 +437,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T>\n+    where\n+        T: Ord,\n+    {\n         Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -445,7 +457,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        T: Ord,\n+    {\n         self.map.clear()\n     }\n \n@@ -467,7 +482,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.contains_key(value)\n@@ -491,7 +506,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::get(&self.map, value)\n@@ -515,7 +530,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.intersection(other).next().is_none()\n     }\n \n@@ -537,7 +555,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         // Same result as self.difference(other).next().is_none()\n         // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n@@ -613,7 +634,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         other.is_subset(self)\n     }\n \n@@ -636,7 +660,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.first(), Some(&1));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first(&self) -> Option<&T> {\n+    pub fn first(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.first_key_value().map(|(k, _)| k)\n     }\n \n@@ -659,7 +686,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.last(), Some(&2));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last(&self) -> Option<&T> {\n+    pub fn last(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.last_key_value().map(|(k, _)| k)\n     }\n \n@@ -681,7 +711,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<T> {\n+    pub fn pop_first(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_first().map(|kv| kv.0)\n     }\n \n@@ -703,7 +736,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<T> {\n+    pub fn pop_last(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_last().map(|kv| kv.0)\n     }\n \n@@ -728,7 +764,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool {\n+    pub fn insert(&mut self, value: T) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.map.insert(value, ()).is_none()\n     }\n \n@@ -748,7 +787,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n     /// ```\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n-    pub fn replace(&mut self, value: T) -> Option<T> {\n+    pub fn replace(&mut self, value: T) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         Recover::replace(&mut self.map, value)\n     }\n \n@@ -773,7 +815,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.remove(value).is_some()\n@@ -797,7 +839,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::take(&mut self.map, value)\n@@ -822,6 +864,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        T: Ord,\n         F: FnMut(&T) -> bool,\n     {\n         self.drain_filter(|v| !f(v));\n@@ -856,7 +899,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(a.contains(&5));\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        T: Ord,\n+    {\n         self.map.append(&mut other.map);\n     }\n \n@@ -892,7 +938,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n@@ -927,13 +973,12 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n     where\n+        T: Ord,\n         F: 'a + FnMut(&T) -> bool,\n     {\n         DrainFilter { pred, inner: self.map.drain_filter_inner() }\n     }\n-}\n \n-impl<T> BTreeSet<T> {\n     /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n     ///\n     /// # Examples"}, {"sha": "79e469eb0db8b6e0878a261aa8dde2affba458c1", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1020784040894716670b2d187ad90f145f856900/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=1020784040894716670b2d187ad90f145f856900", "patch": "@@ -639,6 +639,26 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn set<K>(set: BTreeSet<K>) {\n+        set.is_empty();\n+        set.len();\n+        set.iter();\n+        set.into_iter();\n+    }\n+\n+    fn set_debug<K: Debug>(set: BTreeSet<K>) {\n+        format!(\"{:?}\", set);\n+        format!(\"{:?}\", set.iter());\n+        format!(\"{:?}\", set.into_iter());\n+    }\n+\n+    fn set_clone<K: Clone>(mut set: BTreeSet<K>) {\n+        set.clone_from(&set.clone());\n+    }\n+}\n+\n #[test]\n fn test_append() {\n     let mut a = BTreeSet::new();"}]}