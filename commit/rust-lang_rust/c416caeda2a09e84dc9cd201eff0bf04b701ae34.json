{"sha": "c416caeda2a09e84dc9cd201eff0bf04b701ae34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MTZjYWVkYTJhMDllODRkYzljZDIwMWVmZjBiZjA0YjcwMWFlMzQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T13:19:47Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T13:19:47Z"}, "message": "Merge #1194\n\n1194: Pr 1190 r=matklad a=matklad\n\n\n\nCo-authored-by: Andrea Pretto <eulerdisk@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "81e9db6106e5201955bbf58a54aa51503e144ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e9db6106e5201955bbf58a54aa51503e144ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c416caeda2a09e84dc9cd201eff0bf04b701ae34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c416caeda2a09e84dc9cd201eff0bf04b701ae34", "html_url": "https://github.com/rust-lang/rust/commit/c416caeda2a09e84dc9cd201eff0bf04b701ae34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c416caeda2a09e84dc9cd201eff0bf04b701ae34/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "6162278075df3d9e1d5ff77cf023dc2acaa6ee83", "url": "https://api.github.com/repos/rust-lang/rust/commits/6162278075df3d9e1d5ff77cf023dc2acaa6ee83", "html_url": "https://github.com/rust-lang/rust/commit/6162278075df3d9e1d5ff77cf023dc2acaa6ee83"}, {"sha": "aa1ef6ae9a9a61ab6ddc42d7987753df3aa67263", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1ef6ae9a9a61ab6ddc42d7987753df3aa67263", "html_url": "https://github.com/rust-lang/rust/commit/aa1ef6ae9a9a61ab6ddc42d7987753df3aa67263"}], "stats": {"total": 348, "additions": 271, "deletions": 77}, "files": [{"sha": "e744e82d00e5e4935991632ab941738d01f8b0bc", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -144,6 +144,10 @@ impl AssistBuilder {\n         self.replace(node.range(), replace_with)\n     }\n \n+    pub(crate) fn set_edit_builder(&mut self, edit: TextEditBuilder) {\n+        self.edit = edit;\n+    }\n+\n     #[allow(unused)]\n     pub(crate) fn delete(&mut self, range: TextRange) {\n         self.edit.delete(range)"}, {"sha": "7c856c19b61d735a6577fefe6ce2e40ee3b9976d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 134, "deletions": 69, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -1,20 +1,15 @@\n-use hir::db::HirDatabase;\n+use ra_text_edit::TextEditBuilder;\n+use hir::{ self, db::HirDatabase};\n \n use ra_syntax::{\n-    ast::{ self, NameOwner }, AstNode, SyntaxNode, Direction, TextRange,\n+    ast::{ self, NameOwner }, AstNode, SyntaxNode, Direction, TextRange, SmolStr,\n     SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n };\n use crate::{\n     AssistId,\n-    assist_ctx::{AssistCtx, Assist, AssistBuilder},\n+    assist_ctx::{AssistCtx, Assist},\n };\n \n-fn collect_path_segments(path: &ast::Path) -> Option<Vec<&ast::PathSegment>> {\n-    let mut v = Vec::new();\n-    collect_path_segments_raw(&mut v, path)?;\n-    return Some(v);\n-}\n-\n fn collect_path_segments_raw<'a>(\n     segments: &mut Vec<&'a ast::PathSegment>,\n     mut path: &'a ast::Path,\n@@ -45,59 +40,43 @@ fn collect_path_segments_raw<'a>(\n     return Some(segments.len() - oldlen);\n }\n \n-fn fmt_segments(segments: &[&ast::PathSegment]) -> String {\n+fn fmt_segments(segments: &[SmolStr]) -> String {\n     let mut buf = String::new();\n     fmt_segments_raw(segments, &mut buf);\n     return buf;\n }\n \n-fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n-    let mut first = true;\n-    for s in segments {\n-        if !first {\n-            buf.push_str(\"::\");\n-        }\n-        match s.kind() {\n-            Some(ast::PathSegmentKind::Name(nameref)) => buf.push_str(nameref.text()),\n-            Some(ast::PathSegmentKind::SelfKw) => buf.push_str(\"self\"),\n-            Some(ast::PathSegmentKind::SuperKw) => buf.push_str(\"super\"),\n-            Some(ast::PathSegmentKind::CrateKw) => buf.push_str(\"crate\"),\n-            None => {}\n-        }\n-        first = false;\n+fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n+    let mut iter = segments.iter();\n+    if let Some(s) = iter.next() {\n+        buf.push_str(s);\n+    }\n+    for s in iter {\n+        buf.push_str(\"::\");\n+        buf.push_str(s);\n     }\n }\n \n // Returns the numeber of common segments.\n-fn compare_path_segments(left: &[&ast::PathSegment], right: &[&ast::PathSegment]) -> usize {\n+fn compare_path_segments(left: &[SmolStr], right: &[&ast::PathSegment]) -> usize {\n     return left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count();\n }\n \n-fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n-    if let (Some(ka), Some(kb)) = (a.kind(), b.kind()) {\n-        match (ka, kb) {\n-            (ast::PathSegmentKind::Name(nameref_a), ast::PathSegmentKind::Name(nameref_b)) => {\n-                nameref_a.text() == nameref_b.text()\n-            }\n-            (ast::PathSegmentKind::SelfKw, ast::PathSegmentKind::SelfKw) => true,\n-            (ast::PathSegmentKind::SuperKw, ast::PathSegmentKind::SuperKw) => true,\n-            (ast::PathSegmentKind::CrateKw, ast::PathSegmentKind::CrateKw) => true,\n-            (_, _) => false,\n+fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n+    if let Some(kb) = b.kind() {\n+        match kb {\n+            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n+            ast::PathSegmentKind::SelfKw => a == \"self\",\n+            ast::PathSegmentKind::SuperKw => a == \"super\",\n+            ast::PathSegmentKind::CrateKw => a == \"crate\",\n         }\n     } else {\n         false\n     }\n }\n \n-fn compare_path_segment_with_name(a: &ast::PathSegment, b: &ast::Name) -> bool {\n-    if let Some(ka) = a.kind() {\n-        return match (ka, b) {\n-            (ast::PathSegmentKind::Name(nameref_a), _) => nameref_a.text() == b.text(),\n-            (_, _) => false,\n-        };\n-    } else {\n-        false\n-    }\n+fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n+    a == b.text()\n }\n \n #[derive(Copy, Clone)]\n@@ -189,7 +168,7 @@ fn walk_use_tree_for_best_action<'a>(\n     current_path_segments: &mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n     current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n     current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n-    target: &[&'a ast::PathSegment],    // the path we want to import\n+    target: &[SmolStr],                 // the path we want to import\n ) -> ImportAction<'a> {\n     // We save the number of segments in the buffer so we can restore the correct segments\n     // before returning. Recursive call will add segments so we need to delete them.\n@@ -215,7 +194,7 @@ fn walk_use_tree_for_best_action<'a>(\n \n     // This can happen only if current_use_tree is a direct child of a UseItem\n     if let Some(name) = alias.and_then(ast::NameOwner::name) {\n-        if compare_path_segment_with_name(target[0], name) {\n+        if compare_path_segment_with_name(&target[0], name) {\n             return ImportAction::Nothing;\n         }\n     }\n@@ -344,8 +323,8 @@ fn walk_use_tree_for_best_action<'a>(\n \n fn best_action_for_target<'b, 'a: 'b>(\n     container: &'a SyntaxNode,\n-    path: &'a ast::Path,\n-    target: &'b [&'a ast::PathSegment],\n+    anchor: &'a SyntaxNode,\n+    target: &'b [SmolStr],\n ) -> ImportAction<'a> {\n     let mut storage = Vec::with_capacity(16); // this should be the only allocation\n     let best_action = container\n@@ -362,19 +341,19 @@ fn best_action_for_target<'b, 'a: 'b>(\n         None => {\n             // We have no action and no UseItem was found in container so we find\n             // another item and we use it as anchor.\n-            // If there are no items, we choose the target path itself as anchor.\n+            // If there are no items above, we choose the target path itself as anchor.\n+            // todo: we should include even whitespace blocks as anchor candidates\n             let anchor = container\n                 .children()\n-                .find_map(ast::ModuleItem::cast)\n-                .map(AstNode::syntax)\n-                .or(Some(path.syntax()));\n+                .find(|n| n.range().start() < anchor.range().start())\n+                .or(Some(anchor));\n \n             return ImportAction::add_new_use(anchor, false);\n         }\n     }\n }\n \n-fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut AssistBuilder) {\n+fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n     match action {\n         ImportAction::AddNewUse { anchor, add_after_anchor } => {\n             make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n@@ -407,8 +386,8 @@ fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut A\n fn make_assist_add_new_use(\n     anchor: &Option<&SyntaxNode>,\n     after: bool,\n-    target: &[&ast::PathSegment],\n-    edit: &mut AssistBuilder,\n+    target: &[SmolStr],\n+    edit: &mut TextEditBuilder,\n ) {\n     if let Some(anchor) = anchor {\n         let indent = ra_fmt::leading_indent(anchor);\n@@ -435,9 +414,9 @@ fn make_assist_add_new_use(\n \n fn make_assist_add_in_tree_list(\n     tree_list: &ast::UseTreeList,\n-    target: &[&ast::PathSegment],\n+    target: &[SmolStr],\n     add_self: bool,\n-    edit: &mut AssistBuilder,\n+    edit: &mut TextEditBuilder,\n ) {\n     let last = tree_list.use_trees().last();\n     if let Some(last) = last {\n@@ -464,9 +443,9 @@ fn make_assist_add_in_tree_list(\n fn make_assist_add_nested_import(\n     path: &ast::Path,\n     first_segment_to_split: &Option<&ast::PathSegment>,\n-    target: &[&ast::PathSegment],\n+    target: &[SmolStr],\n     add_self: bool,\n-    edit: &mut AssistBuilder,\n+    edit: &mut TextEditBuilder,\n ) {\n     let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n     if let Some(use_tree) = use_tree {\n@@ -491,36 +470,77 @@ fn make_assist_add_nested_import(\n             buf.push_str(\", \");\n         }\n         edit.insert(start, buf);\n-        edit.insert(end, \"}\");\n+        edit.insert(end, \"}\".to_string());\n     }\n }\n \n-fn apply_auto_import<'a>(\n+fn apply_auto_import(\n     container: &SyntaxNode,\n     path: &ast::Path,\n-    target: &[&'a ast::PathSegment],\n-    edit: &mut AssistBuilder,\n+    target: &[SmolStr],\n+    edit: &mut TextEditBuilder,\n ) {\n-    let action = best_action_for_target(container, path, target);\n+    let action = best_action_for_target(container, path.syntax(), target);\n     make_assist(&action, target, edit);\n-    if let (Some(first), Some(last)) = (target.first(), target.last()) {\n+    if let Some(last) = path.segment() {\n         // Here we are assuming the assist will provide a  correct use statement\n         // so we can delete the path qualifier\n         edit.delete(TextRange::from_to(\n-            first.syntax().range().start(),\n+            path.syntax().range().start(),\n             last.syntax().range().start(),\n         ));\n     }\n }\n \n+pub fn collect_hir_path_segments(path: &hir::Path) -> Vec<SmolStr> {\n+    let mut ps = Vec::<SmolStr>::with_capacity(10);\n+    match path.kind {\n+        hir::PathKind::Abs => ps.push(\"\".into()),\n+        hir::PathKind::Crate => ps.push(\"crate\".into()),\n+        hir::PathKind::Plain => {}\n+        hir::PathKind::Self_ => ps.push(\"self\".into()),\n+        hir::PathKind::Super => ps.push(\"super\".into()),\n+    }\n+    for s in path.segments.iter() {\n+        ps.push(s.name.to_string().into());\n+    }\n+    ps\n+}\n+\n+// This function produces sequence of text edits into edit\n+// to import the target path in the most appropriate scope given\n+// the cursor position\n+pub fn auto_import_text_edit(\n+    // Ideally the position of the cursor, used to\n+    position: &SyntaxNode,\n+    // The statement to use as anchor (last resort)\n+    anchor: &SyntaxNode,\n+    // The path to import as a sequence of strings\n+    target: &[SmolStr],\n+    edit: &mut TextEditBuilder,\n+) {\n+    let container = position.ancestors().find_map(|n| {\n+        if let Some(module) = ast::Module::cast(n) {\n+            return module.item_list().map(ast::AstNode::syntax);\n+        }\n+        ast::SourceFile::cast(n).map(ast::AstNode::syntax)\n+    });\n+\n+    if let Some(container) = container {\n+        let action = best_action_for_target(container, anchor, target);\n+        make_assist(&action, target, edit);\n+    }\n+}\n+\n pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let path: &ast::Path = ctx.node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n         return None;\n     }\n \n-    let segments = collect_path_segments(path)?;\n+    let hir_path = hir::Path::from_ast(path)?;\n+    let segments = collect_hir_path_segments(&hir_path);\n     if segments.len() < 2 {\n         return None;\n     }\n@@ -531,7 +551,9 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n                 AssistId(\"auto_import\"),\n                 format!(\"import {} in mod {}\", fmt_segments(&segments), name.text()),\n                 |edit| {\n-                    apply_auto_import(item_list.syntax(), path, &segments, edit);\n+                    let mut text_edit = TextEditBuilder::default();\n+                    apply_auto_import(item_list.syntax(), path, &segments, &mut text_edit);\n+                    edit.set_edit_builder(text_edit);\n                 },\n             );\n         }\n@@ -541,7 +563,9 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n             AssistId(\"auto_import\"),\n             format!(\"import {} in the current file\", fmt_segments(&segments)),\n             |edit| {\n-                apply_auto_import(current_file.syntax(), path, &segments, edit);\n+                let mut text_edit = TextEditBuilder::default();\n+                apply_auto_import(current_file.syntax(), path, &segments, &mut text_edit);\n+                edit.set_edit_builder(text_edit);\n             },\n         );\n     }\n@@ -564,6 +588,47 @@ std::fmt::Debug<|>\n             \"\n use std::fmt::Debug;\n \n+Debug<|>\n+    \",\n+        );\n+    }\n+    #[test]\n+    fn test_auto_import_add_use_no_anchor_with_item_below() {\n+        check_assist(\n+            auto_import,\n+            \"\n+std::fmt::Debug<|>\n+\n+fn main() {\n+}\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+Debug<|>\n+\n+fn main() {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_add_use_no_anchor_with_item_above() {\n+        check_assist(\n+            auto_import,\n+            \"\n+fn main() {\n+}\n+\n+std::fmt::Debug<|>\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+fn main() {\n+}\n+\n Debug<|>\n     \",\n         );"}, {"sha": "4c330c90758ba63a548c100b3bc4fe2a039527b8", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -99,7 +99,7 @@ mod inline_local_variable;\n mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n-mod auto_import;\n+pub mod auto_import;\n mod add_missing_impl_members;\n \n fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {"}, {"sha": "9a999e66c7df35be52747788f23ab10065e4d825", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -46,6 +46,19 @@ impl Name {\n         Name::new(idx.to_string().into())\n     }\n \n+    // There's should be no way to extract a string out of `Name`: `Name` in the\n+    // future, `Name` will include hygiene information, and you can't encode\n+    // hygiene into a String.\n+    //\n+    // If you need to compare something with `Name`, compare `Name`s directly.\n+    //\n+    // If you need to render `Name` for the user, use the `Display` impl, but be\n+    // aware that it strips hygiene info.\n+    #[deprecated(note = \"use to_string instead\")]\n+    pub fn as_smolstr(&self) -> &SmolStr {\n+        &self.text\n+    }\n+\n     pub(crate) fn as_known_name(&self) -> Option<KnownName> {\n         let name = match self.text.as_str() {\n             \"isize\" => KnownName::Isize,"}, {"sha": "2959e3eca296b6f9ed795df4543436bf7f05b972", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     AsName, Module, HirFileId, Crate, Trait, Resolver, Ty,\n     expr::{BodySourceMap, scope::{ScopeId, ExprScopes}},\n     ids::LocationCtx,\n-    expr, AstId\n+    expr, AstId,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file."}, {"sha": "2473e58b405819b112e4f44c27bd5ae19fc04c85", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -1,12 +1,122 @@\n-use crate::completion::{Completions, CompletionContext};\n+use rustc_hash::FxHashMap;\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{SmolStr, ast, AstNode};\n+use ra_assists::auto_import;\n+\n+use crate::completion::{CompletionItem, Completions, CompletionKind, CompletionContext};\n \n pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n-        return;\n+    if ctx.is_trivial_path {\n+        let names = ctx.analyzer.all_names(ctx.db);\n+        names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n+\n+        // auto-import\n+        // We fetch ident from the original file, because we need to pre-filter auto-imports\n+        if ast::NameRef::cast(ctx.token.parent()).is_some() {\n+            let import_resolver = ImportResolver::new();\n+            let import_names = import_resolver.all_names(ctx.token.text());\n+            import_names.into_iter().for_each(|(name, path)| {\n+                let edit = {\n+                    let mut builder = TextEditBuilder::default();\n+                    builder.replace(ctx.source_range(), name.to_string());\n+                    auto_import::auto_import_text_edit(\n+                        ctx.token.parent(),\n+                        ctx.token.parent(),\n+                        &path,\n+                        &mut builder,\n+                    );\n+                    builder.finish()\n+                };\n+\n+                // Hack: copied this check form conv.rs beacause auto import can produce edits\n+                // that invalidate assert in conv_with.\n+                if edit\n+                    .as_atoms()\n+                    .iter()\n+                    .filter(|atom| !ctx.source_range().is_subrange(&atom.delete))\n+                    .all(|atom| ctx.source_range().intersection(&atom.delete).is_none())\n+                {\n+                    CompletionItem::new(\n+                        CompletionKind::Reference,\n+                        ctx.source_range(),\n+                        build_import_label(&name, &path),\n+                    )\n+                    .text_edit(edit)\n+                    .add_to(acc);\n+                }\n+            });\n+        }\n     }\n-    let names = ctx.analyzer.all_names(ctx.db);\n+}\n \n-    names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n+fn build_import_label(name: &str, path: &Vec<SmolStr>) -> String {\n+    let mut buf = String::with_capacity(64);\n+    buf.push_str(name);\n+    buf.push_str(\" (\");\n+    fmt_import_path(path, &mut buf);\n+    buf.push_str(\")\");\n+    buf\n+}\n+\n+fn fmt_import_path(path: &Vec<SmolStr>, buf: &mut String) {\n+    let mut segments = path.iter();\n+    if let Some(s) = segments.next() {\n+        buf.push_str(&s);\n+    }\n+    for s in segments {\n+        buf.push_str(\"::\");\n+        buf.push_str(&s);\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct ImportResolver {\n+    // todo: use fst crate or something like that\n+    dummy_names: Vec<(SmolStr, Vec<SmolStr>)>,\n+}\n+\n+impl ImportResolver {\n+    pub(crate) fn new() -> Self {\n+        let dummy_names = vec![\n+            (SmolStr::new(\"fmt\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\")]),\n+            (SmolStr::new(\"io\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"io\")]),\n+            (SmolStr::new(\"iter\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\")]),\n+            (SmolStr::new(\"hash\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\")]),\n+            (\n+                SmolStr::new(\"Debug\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Debug\")],\n+            ),\n+            (\n+                SmolStr::new(\"Display\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Display\")],\n+            ),\n+            (\n+                SmolStr::new(\"Hash\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hash\")],\n+            ),\n+            (\n+                SmolStr::new(\"Hasher\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hasher\")],\n+            ),\n+            (\n+                SmolStr::new(\"Iterator\"),\n+                vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\"), SmolStr::new(\"Iterator\")],\n+            ),\n+        ];\n+\n+        ImportResolver { dummy_names }\n+    }\n+\n+    // Returns a map of importable items filtered by name.\n+    // The map associates item name with its full path.\n+    // todo: should return Resolutions\n+    pub(crate) fn all_names(&self, name: &str) -> FxHashMap<SmolStr, Vec<SmolStr>> {\n+        if name.len() > 1 {\n+            self.dummy_names.iter().filter(|(n, _)| n.contains(name)).cloned().collect()\n+        } else {\n+            FxHashMap::default()\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "a8c8cc7b0470b469c616dedd6fa16edbffb4acdd", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c416caeda2a09e84dc9cd201eff0bf04b701ae34/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=c416caeda2a09e84dc9cd201eff0bf04b701ae34", "patch": "@@ -27,7 +27,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_pat_binding: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n-    /// If not a trivial, path, the prefix (qualifier).\n+    /// If not a trivial path, the prefix (qualifier).\n     pub(super) path_prefix: Option<hir::Path>,\n     pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n@@ -151,6 +151,7 @@ impl<'a> CompletionContext<'a> {\n             Some(it) => it,\n             None => return,\n         };\n+\n         if let Some(segment) = ast::PathSegment::cast(parent) {\n             let path = segment.parent_path();\n             self.is_call = path\n@@ -167,6 +168,7 @@ impl<'a> CompletionContext<'a> {\n                     return;\n                 }\n             }\n+\n             if path.qualifier().is_none() {\n                 self.is_trivial_path = true;\n "}]}