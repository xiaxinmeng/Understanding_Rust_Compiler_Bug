{"sha": "809bd3e5efa00a7a3f924bc3999568d67574e4e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOWJkM2U1ZWZhMDBhN2EzZjkyNGJjMzk5OTU2OGQ2NzU3NGU0ZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-21T06:36:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-21T07:01:43Z"}, "message": "rustdoc: More demoding", "tree": {"sha": "edf1229ef5017fc7c4226d603b103232fbdeb244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edf1229ef5017fc7c4226d603b103232fbdeb244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/809bd3e5efa00a7a3f924bc3999568d67574e4e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/809bd3e5efa00a7a3f924bc3999568d67574e4e7", "html_url": "https://github.com/rust-lang/rust/commit/809bd3e5efa00a7a3f924bc3999568d67574e4e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/809bd3e5efa00a7a3f924bc3999568d67574e4e7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451463ab39083e6aba5fc215a6f349236dff9872", "url": "https://api.github.com/repos/rust-lang/rust/commits/451463ab39083e6aba5fc215a6f349236dff9872", "html_url": "https://github.com/rust-lang/rust/commit/451463ab39083e6aba5fc215a6f349236dff9872"}], "stats": {"total": 218, "additions": 109, "deletions": 109}, "files": [{"sha": "1b1bb0139a208f27911e24ed5fa94f0c4385e4df", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -34,7 +34,7 @@ type Fold_<T> = {\n // This exists because fn types don't infer correctly as record\n // initializers, but they do as function arguments\n fn mk_fold<T:Copy>(\n-    ctxt: T,\n+    +ctxt: T,\n     +fold_doc: FoldDoc<T>,\n     +fold_crate: FoldCrate<T>,\n     +fold_item: FoldItem<T>,\n@@ -65,7 +65,7 @@ fn mk_fold<T:Copy>(\n     })\n }\n \n-pub fn default_any_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n+pub fn default_any_fold<T:Send Copy>(+ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -83,7 +83,7 @@ pub fn default_any_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_seq_fold<T:Copy>(ctxt: T) -> Fold<T> {\n+pub fn default_seq_fold<T:Copy>(+ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -101,7 +101,7 @@ pub fn default_seq_fold<T:Copy>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_par_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n+pub fn default_par_fold<T:Send Copy>(+ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),"}, {"sha": "42a222b8f5f7f55ccceaffdd9302ee9b056233ae", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -51,8 +51,8 @@ fn fold_nmod(\n }\n \n fn build_mod_index(\n-    doc: doc::ModDoc,\n-    config: config::Config\n+    +doc: doc::ModDoc,\n+    +config: config::Config\n ) -> doc::Index {\n     {\n         entries: par::map(doc.items, |doc| {\n@@ -62,8 +62,8 @@ fn build_mod_index(\n }\n \n fn build_nmod_index(\n-    doc: doc::NmodDoc,\n-    config: config::Config\n+    +doc: doc::NmodDoc,\n+    +config: config::Config\n ) -> doc::Index {\n     {\n         entries: par::map(doc.fns, |doc| {\n@@ -73,8 +73,8 @@ fn build_nmod_index(\n }\n \n fn item_to_entry(\n-    doc: doc::ItemTag,\n-    config: config::Config\n+    +doc: doc::ItemTag,\n+    +config: config::Config\n ) -> doc::IndexEntry {\n     let link = match doc {\n       doc::ModTag(_) | doc::NmodTag(_)\n@@ -94,7 +94,7 @@ fn item_to_entry(\n     }\n }\n \n-fn pandoc_header_id(header: ~str) -> ~str {\n+fn pandoc_header_id(header: &str) -> ~str {\n \n     // http://johnmacfarlane.net/pandoc/README.html#headers\n \n@@ -106,10 +106,10 @@ fn pandoc_header_id(header: ~str) -> ~str {\n     let header = maybe_use_section_id(header);\n     return header;\n \n-    fn remove_formatting(s: ~str) -> ~str {\n+    fn remove_formatting(s: &str) -> ~str {\n         str::replace(s, ~\"`\", ~\"\")\n     }\n-    fn remove_punctuation(s: ~str) -> ~str {\n+    fn remove_punctuation(s: &str) -> ~str {\n         let s = str::replace(s, ~\"<\", ~\"\");\n         let s = str::replace(s, ~\">\", ~\"\");\n         let s = str::replace(s, ~\"[\", ~\"\");\n@@ -124,17 +124,17 @@ fn pandoc_header_id(header: ~str) -> ~str {\n         let s = str::replace(s, ~\"^\", ~\"\");\n         return s;\n     }\n-    fn replace_with_hyphens(s: ~str) -> ~str {\n+    fn replace_with_hyphens(s: &str) -> ~str {\n         // Collapse sequences of whitespace to a single dash\n         // XXX: Hacky implementation here that only covers\n         // one or two spaces.\n         let s = str::replace(s, ~\"  \", ~\"-\");\n         let s = str::replace(s, ~\" \", ~\"-\");\n         return s;\n     }\n-    fn convert_to_lowercase(s: ~str) -> ~str { str::to_lower(s) }\n-    fn remove_up_to_first_letter(s: ~str) -> ~str { s }\n-    fn maybe_use_section_id(s: ~str) -> ~str { s }\n+    fn convert_to_lowercase(s: &str) -> ~str { str::to_lower(s) }\n+    fn remove_up_to_first_letter(s: &str) -> ~str { s.to_str() }\n+    fn maybe_use_section_id(s: &str) -> ~str { s.to_str() }\n }\n \n #[test]\n@@ -232,7 +232,7 @@ fn should_index_foreign_mod_contents() {\n #[cfg(test)]\n mod test {\n     #[legacy_exports];\n-    fn mk_doc(output_style: config::OutputStyle, source: ~str) -> doc::Doc {\n+    fn mk_doc(output_style: config::OutputStyle, +source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let config = {\n                 output_style: output_style,"}, {"sha": "52e3d654a2bf917571f133e2a9da8a518bdf6ac5", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -19,7 +19,7 @@ pub fn mk_pass(+writer_factory: WriterFactory) -> Pass {\n \n fn run(\n     srv: astsrv::Srv,\n-    doc: doc::Doc,\n+    +doc: doc::Doc,\n     +writer_factory: WriterFactory\n ) -> doc::Doc {\n \n@@ -79,7 +79,7 @@ type Ctxt = {\n };\n \n fn write_markdown(\n-    doc: doc::Doc,\n+    +doc: doc::Doc,\n     +writer_factory: WriterFactory\n ) {\n     // There is easy parallelism to be had here, but\n@@ -89,11 +89,11 @@ fn write_markdown(\n         let ctxt = {\n             w: writer_factory(*page)\n         };\n-        write_page(ctxt, page)\n+        write_page(&ctxt, page)\n     };\n }\n \n-fn write_page(ctxt: Ctxt, page: &doc::Page) {\n+fn write_page(ctxt: &Ctxt, page: &doc::Page) {\n     write_title(ctxt, *page);\n     match *page {\n       doc::CratePage(doc) => {\n@@ -123,12 +123,12 @@ fn should_request_new_writer_for_each_page() {\n     }\n }\n \n-fn write_title(ctxt: Ctxt, page: doc::Page) {\n+fn write_title(ctxt: &Ctxt, +page: doc::Page) {\n     ctxt.w.write_line(fmt!(\"%% %s\", make_title(page)));\n     ctxt.w.write_line(~\"\");\n }\n \n-fn make_title(page: doc::Page) -> ~str {\n+fn make_title(+page: doc::Page) -> ~str {\n     let item = match page {\n       doc::CratePage(CrateDoc) => {\n         doc::ModTag(CrateDoc.topmod)\n@@ -169,18 +169,18 @@ enum Hlvl {\n     H4 = 4\n }\n \n-fn write_header(ctxt: Ctxt, lvl: Hlvl, doc: doc::ItemTag) {\n+fn write_header(ctxt: &Ctxt, lvl: Hlvl, +doc: doc::ItemTag) {\n     let text = header_text(doc);\n     write_header_(ctxt, lvl, text);\n }\n \n-fn write_header_(ctxt: Ctxt, lvl: Hlvl, title: ~str) {\n+fn write_header_(ctxt: &Ctxt, lvl: Hlvl, +title: ~str) {\n     let hashes = str::from_chars(vec::from_elem(lvl as uint, '#'));\n     ctxt.w.write_line(fmt!(\"%s %s\", hashes, title));\n     ctxt.w.write_line(~\"\");\n }\n \n-pub fn header_kind(doc: doc::ItemTag) -> ~str {\n+pub fn header_kind(+doc: doc::ItemTag) -> ~str {\n     match doc {\n       doc::ModTag(_) => {\n         if doc.id() == syntax::ast::crate_node_id {\n@@ -216,7 +216,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n     }\n }\n \n-pub fn header_name(doc: doc::ItemTag) -> ~str {\n+pub fn header_name(+doc: doc::ItemTag) -> ~str {\n     let fullpath = str::connect(doc.path() + ~[doc.name()], ~\"::\");\n     match doc {\n       doc::ModTag(_) if doc.id() != syntax::ast::crate_node_id => {\n@@ -245,7 +245,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n     }\n }\n \n-pub fn header_text(doc: doc::ItemTag) -> ~str {\n+pub fn header_text(+doc: doc::ItemTag) -> ~str {\n     match doc {\n       doc::ImplTag(ImplDoc) => {\n         let header_kind = header_kind(doc);\n@@ -263,27 +263,27 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n     }\n }\n \n-fn header_text_(kind: ~str, name: ~str) -> ~str {\n+fn header_text_(kind: &str, name: &str) -> ~str {\n     fmt!(\"%s `%s`\", kind, name)\n }\n \n fn write_crate(\n-    ctxt: Ctxt,\n-    doc: doc::CrateDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::CrateDoc\n ) {\n     write_top_module(ctxt, doc.topmod);\n }\n \n fn write_top_module(\n-    ctxt: Ctxt,\n-    ModDoc: doc::ModDoc\n+    ctxt: &Ctxt,\n+    +ModDoc: doc::ModDoc\n ) {\n     write_mod_contents(ctxt, ModDoc);\n }\n \n fn write_mod(\n-    ctxt: Ctxt,\n-    ModDoc: doc::ModDoc\n+    ctxt: &Ctxt,\n+    +ModDoc: doc::ModDoc\n ) {\n     write_mod_contents(ctxt, ModDoc);\n }\n@@ -295,17 +295,17 @@ fn should_write_full_path_to_mod() {\n }\n \n fn write_common(\n-    ctxt: Ctxt,\n-    desc: Option<~str>,\n-    sections: ~[doc::Section]\n+    ctxt: &Ctxt,\n+    +desc: Option<~str>,\n+    sections: &[doc::Section]\n ) {\n     write_desc(ctxt, desc);\n     write_sections(ctxt, sections);\n }\n \n fn write_desc(\n-    ctxt: Ctxt,\n-    desc: Option<~str>\n+    ctxt: &Ctxt,\n+    +desc: Option<~str>\n ) {\n     match desc {\n         Some(desc) => {\n@@ -316,13 +316,13 @@ fn write_desc(\n     }\n }\n \n-fn write_sections(ctxt: Ctxt, sections: ~[doc::Section]) {\n+fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n     for vec::each(sections) |section| {\n         write_section(ctxt, *section);\n     }\n }\n \n-fn write_section(ctxt: Ctxt, section: doc::Section) {\n+fn write_section(ctxt: &Ctxt, +section: doc::Section) {\n     write_header_(ctxt, H4, section.header);\n     ctxt.w.write_line(section.body);\n     ctxt.w.write_line(~\"\");\n@@ -340,8 +340,8 @@ fn should_write_sections() {\n }\n \n fn write_mod_contents(\n-    ctxt: Ctxt,\n-    doc: doc::ModDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::ModDoc\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n@@ -353,15 +353,15 @@ fn write_mod_contents(\n     }\n }\n \n-fn write_item(ctxt: Ctxt, doc: doc::ItemTag) {\n+fn write_item(ctxt: &Ctxt, +doc: doc::ItemTag) {\n     write_item_(ctxt, doc, true);\n }\n \n-fn write_item_no_header(ctxt: Ctxt, doc: doc::ItemTag) {\n+fn write_item_no_header(ctxt: &Ctxt, +doc: doc::ItemTag) {\n     write_item_(ctxt, doc, false);\n }\n \n-fn write_item_(ctxt: Ctxt, doc: doc::ItemTag, write_header: bool) {\n+fn write_item_(ctxt: &Ctxt, +doc: doc::ItemTag, write_header: bool) {\n     if write_header {\n         write_item_header(ctxt, doc);\n     }\n@@ -379,11 +379,11 @@ fn write_item_(ctxt: Ctxt, doc: doc::ItemTag, write_header: bool) {\n     }\n }\n \n-fn write_item_header(ctxt: Ctxt, doc: doc::ItemTag) {\n+fn write_item_header(ctxt: &Ctxt, +doc: doc::ItemTag) {\n     write_header(ctxt, item_header_lvl(doc), doc);\n }\n \n-fn item_header_lvl(doc: doc::ItemTag) -> Hlvl {\n+fn item_header_lvl(+doc: doc::ItemTag) -> Hlvl {\n     match doc {\n       doc::ModTag(_) | doc::NmodTag(_) => H1,\n       _ => H2\n@@ -396,7 +396,7 @@ fn should_write_crate_description() {\n     assert str::contains(markdown, ~\"this is the crate\");\n }\n \n-fn write_index(ctxt: Ctxt, index: doc::Index) {\n+fn write_index(ctxt: &Ctxt, +index: doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n     }\n@@ -445,7 +445,7 @@ fn should_write_index_for_foreign_mods() {\n     );\n }\n \n-fn write_nmod(ctxt: Ctxt, doc: doc::NmodDoc) {\n+fn write_nmod(ctxt: &Ctxt, +doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n         write_index(ctxt, doc.index.get());\n@@ -479,8 +479,8 @@ fn should_write_foreign_fn_headers() {\n }\n \n fn write_fn(\n-    ctxt: Ctxt,\n-    doc: doc::FnDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::FnDoc\n ) {\n     write_fnlike(\n         ctxt,\n@@ -491,16 +491,16 @@ fn write_fn(\n }\n \n fn write_fnlike(\n-    ctxt: Ctxt,\n-    sig: Option<~str>,\n-    desc: Option<~str>,\n-    sections: ~[doc::Section]\n+    ctxt: &Ctxt,\n+    +sig: Option<~str>,\n+    +desc: Option<~str>,\n+    sections: &[doc::Section]\n ) {\n     write_sig(ctxt, sig);\n     write_common(ctxt, desc, sections);\n }\n \n-fn write_sig(ctxt: Ctxt, sig: Option<~str>) {\n+fn write_sig(ctxt: &Ctxt, +sig: Option<~str>) {\n     match sig {\n       Some(sig) => {\n         ctxt.w.write_line(code_block_indent(sig));\n@@ -510,7 +510,7 @@ fn write_sig(ctxt: Ctxt, sig: Option<~str>) {\n     }\n }\n \n-fn code_block_indent(s: ~str) -> ~str {\n+fn code_block_indent(+s: ~str) -> ~str {\n     let lines = str::lines_any(s);\n     let indented = vec::map(lines, |line| fmt!(\"    %s\", *line) );\n     str::connect(indented, ~\"\\n\")\n@@ -562,8 +562,8 @@ fn should_leave_blank_line_between_fn_header_and_sig() {\n }\n \n fn write_const(\n-    ctxt: Ctxt,\n-    doc: doc::ConstDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::ConstDoc\n ) {\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -584,8 +584,8 @@ fn should_write_const_description() {\n }\n \n fn write_enum(\n-    ctxt: Ctxt,\n-    doc: doc::EnumDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::EnumDoc\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_variants(ctxt, doc.variants);\n@@ -605,8 +605,8 @@ fn should_write_enum_description() {\n }\n \n fn write_variants(\n-    ctxt: Ctxt,\n-    docs: ~[doc::VariantDoc]\n+    ctxt: &Ctxt,\n+    docs: &[doc::VariantDoc]\n ) {\n     if vec::is_empty(docs) {\n         return;\n@@ -621,7 +621,7 @@ fn write_variants(\n     ctxt.w.write_line(~\"\");\n }\n \n-fn write_variant(ctxt: Ctxt, doc: doc::VariantDoc) {\n+fn write_variant(ctxt: &Ctxt, +doc: doc::VariantDoc) {\n     assert doc.sig.is_some();\n     let sig = doc.sig.get();\n     match doc.desc {\n@@ -667,18 +667,18 @@ fn should_write_variant_list_with_signatures() {\n          \\n* `c(int)` - a\\n\\n\");\n }\n \n-fn write_trait(ctxt: Ctxt, doc: doc::TraitDoc) {\n+fn write_trait(ctxt: &Ctxt, +doc: doc::TraitDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n-fn write_methods(ctxt: Ctxt, docs: ~[doc::MethodDoc]) {\n+fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n     for vec::each(docs) |doc| {\n         write_method(ctxt, *doc);\n     }\n }\n \n-fn write_method(ctxt: Ctxt, doc: doc::MethodDoc) {\n+fn write_method(ctxt: &Ctxt, +doc: doc::MethodDoc) {\n     write_header_(ctxt, H3, header_text_(~\"Method\", doc.name));\n     write_fnlike(\n         ctxt,\n@@ -715,7 +715,7 @@ fn should_write_trait_method_signature() {\n     assert str::contains(markdown, ~\"\\n    fn a()\");\n }\n \n-fn write_impl(ctxt: Ctxt, doc: doc::ImplDoc) {\n+fn write_impl(ctxt: &Ctxt, +doc: doc::ImplDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n@@ -754,8 +754,8 @@ fn should_write_impl_method_signature() {\n }\n \n fn write_type(\n-    ctxt: Ctxt,\n-    doc: doc::TyDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::TyDoc\n ) {\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -781,8 +781,8 @@ fn should_write_type_signature() {\n }\n \n fn write_struct(\n-    ctxt: Ctxt,\n-    doc: doc::StructDoc\n+    ctxt: &Ctxt,\n+    +doc: doc::StructDoc\n ) {\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -797,14 +797,14 @@ fn should_write_struct_header() {\n #[cfg(test)]\n mod test {\n     #[legacy_exports];\n-    fn render(source: ~str) -> ~str {\n+    fn render(+source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n         debug!(\"markdown: %s\", markdown);\n         markdown\n     }\n \n-    fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n+    fn create_doc_srv(+source: ~str) -> (astsrv::Srv, doc::Doc) {\n         do astsrv::from_str(source) |srv| {\n \n             let config = {\n@@ -834,13 +834,13 @@ mod test {\n         }\n     }\n \n-    fn create_doc(source: ~str) -> doc::Doc {\n+    fn create_doc(+source: ~str) -> doc::Doc {\n         let (_, doc) = create_doc_srv(source);\n         doc\n     }\n \n     fn write_markdown_str(\n-        doc: doc::Doc\n+        +doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, move writer_factory);\n@@ -849,7 +849,7 @@ mod test {\n \n     fn write_markdown_str_srv(\n         srv: astsrv::Srv,\n-        doc: doc::Doc\n+        +doc: doc::Doc\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         let pass = mk_pass(move writer_factory);"}, {"sha": "193cf7be95ed068a5ca0669e08053ad4911c08b1", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -8,20 +8,20 @@ pub enum WriteInstr {\n }\n \n pub type Writer = fn~(+v: WriteInstr);\n-pub type WriterFactory = fn~(page: doc::Page) -> Writer;\n+pub type WriterFactory = fn~(+page: doc::Page) -> Writer;\n \n pub trait WriterUtils {\n-    fn write_str(str: ~str);\n-    fn write_line(str: ~str);\n+    fn write_str(+str: ~str);\n+    fn write_line(+str: ~str);\n     fn write_done();\n }\n \n impl Writer: WriterUtils {\n-    fn write_str(str: ~str) {\n+    fn write_str(+str: ~str) {\n         self(Write(str));\n     }\n \n-    fn write_line(str: ~str) {\n+    fn write_line(+str: ~str) {\n         self.write_str(str + ~\"\\n\");\n     }\n \n@@ -30,7 +30,7 @@ impl Writer: WriterUtils {\n     }\n }\n \n-pub fn make_writer_factory(config: config::Config) -> WriterFactory {\n+pub fn make_writer_factory(+config: config::Config) -> WriterFactory {\n     match config.output_format {\n       config::Markdown => {\n         markdown_writer_factory(config)\n@@ -41,21 +41,21 @@ pub fn make_writer_factory(config: config::Config) -> WriterFactory {\n     }\n }\n \n-fn markdown_writer_factory(config: config::Config) -> WriterFactory {\n-    fn~(page: doc::Page) -> Writer {\n+fn markdown_writer_factory(+config: config::Config) -> WriterFactory {\n+    fn~(+page: doc::Page) -> Writer {\n         markdown_writer(config, page)\n     }\n }\n \n-fn pandoc_writer_factory(config: config::Config) -> WriterFactory {\n-    fn~(page: doc::Page) -> Writer {\n+fn pandoc_writer_factory(+config: config::Config) -> WriterFactory {\n+    fn~(+page: doc::Page) -> Writer {\n         pandoc_writer(config, page)\n     }\n }\n \n fn markdown_writer(\n-    config: config::Config,\n-    page: doc::Page\n+    +config: config::Config,\n+    +page: doc::Page\n ) -> Writer {\n     let filename = make_local_filename(config, page);\n     do generic_writer |markdown| {\n@@ -64,8 +64,8 @@ fn markdown_writer(\n }\n \n fn pandoc_writer(\n-    config: config::Config,\n-    page: doc::Page\n+    +config: config::Config,\n+    +page: doc::Page\n ) -> Writer {\n     assert config.pandoc_cmd.is_some();\n     let pandoc_cmd = config.pandoc_cmd.get();\n@@ -140,7 +140,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n     str::from_bytes(buf)\n }\n \n-fn generic_writer(+process: fn~(markdown: ~str)) -> Writer {\n+fn generic_writer(+process: fn~(+markdown: ~str)) -> Writer {\n     let ch = do task::spawn_listener\n         |move process, po: comm::Port<WriteInstr>| {\n         let mut markdown = ~\"\";\n@@ -160,16 +160,16 @@ fn generic_writer(+process: fn~(markdown: ~str)) -> Writer {\n }\n \n fn make_local_filename(\n-    config: config::Config,\n-    page: doc::Page\n+    +config: config::Config,\n+    +page: doc::Page\n ) -> Path {\n     let filename = make_filename(config, page);\n     config.output_dir.push_rel(&filename)\n }\n \n pub fn make_filename(\n-    config: config::Config,\n-    page: doc::Page\n+    +config: config::Config,\n+    +page: doc::Page\n ) -> Path {\n     let filename = {\n         match page {\n@@ -241,7 +241,7 @@ fn should_name_mod_file_names_by_path() {\n #[cfg(test)]\n mod test {\n     #[legacy_exports];\n-    fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n+    fn mk_doc(+name: ~str, +source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n             let doc = extract::from_srv(srv, name);\n             let doc = path_pass::mk_pass().f(srv, doc);\n@@ -250,7 +250,7 @@ mod test {\n     }\n }\n \n-fn write_file(path: &Path, s: ~str) {\n+fn write_file(path: &Path, +s: ~str) {\n     use io::WriterUtil;\n \n     match io::file_writer(path, ~[io::Create, io::Truncate]) {\n@@ -265,7 +265,7 @@ pub fn future_writer_factory(\n ) -> (WriterFactory, comm::Port<(doc::Page, ~str)>) {\n     let markdown_po = comm::Port();\n     let markdown_ch = comm::Chan(&markdown_po);\n-    let writer_factory = fn~(page: doc::Page) -> Writer {\n+    let writer_factory = fn~(+page: doc::Page) -> Writer {\n         let writer_po = comm::Port();\n         let writer_ch = comm::Chan(&writer_po);\n         do task::spawn {"}, {"sha": "232dc03253d1fd48d1aec37c4851c081ee4abfbe", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -25,7 +25,7 @@ fn run(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n         fold_item: fold_item,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n-        .. *fold::default_any_fold(ctxt)\n+        .. *fold::default_any_fold(move ctxt)\n     });\n     fold.fold_doc(&fold, doc)\n }"}, {"sha": "6f69623674b04091ec515747956a7dcb9efa2558", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -9,7 +9,7 @@ pub fn mk_pass(name: ~str, +lteq: ItemLtEq) -> Pass {\n     {\n         name: name,\n         f: fn~(move lteq, srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, lteq)\n+            run(srv, doc, copy lteq)\n         }\n     }\n }\n@@ -18,11 +18,11 @@ pub fn mk_pass(name: ~str, +lteq: ItemLtEq) -> Pass {\n fn run(\n     _srv: astsrv::Srv,\n     +doc: doc::Doc,\n-    lteq: ItemLtEq\n+    +lteq: ItemLtEq\n ) -> doc::Doc {\n     let fold = fold::Fold({\n         fold_mod: fold_mod,\n-        .. *fold::default_any_fold(lteq)\n+        .. *fold::default_any_fold(move lteq)\n     });\n     fold.fold_doc(&fold, doc)\n }"}, {"sha": "dd2e2956db4e38b7784c7158285a581c638e3277", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809bd3e5efa00a7a3f924bc3999568d67574e4e7/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=809bd3e5efa00a7a3f924bc3999568d67574e4e7", "patch": "@@ -6,7 +6,7 @@ pub fn mk_pass(name: ~str, +op: fn~(~str) -> ~str) -> Pass {\n     {\n         name: name,\n         f: fn~(move op, srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, op)\n+            run(srv, doc, copy op)\n         }\n     }\n }\n@@ -17,14 +17,14 @@ type Op = fn~(~str) -> ~str;\n fn run(\n     _srv: astsrv::Srv,\n     +doc: doc::Doc,\n-    op: Op\n+    +op: Op\n ) -> doc::Doc {\n     let fold = fold::Fold({\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n-        .. *fold::default_any_fold(op)\n+        .. *fold::default_any_fold(move op)\n     });\n     fold.fold_doc(&fold, doc)\n }"}]}