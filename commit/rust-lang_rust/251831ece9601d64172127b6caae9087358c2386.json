{"sha": "251831ece9601d64172127b6caae9087358c2386", "node_id": "C_kwDOAAsO6NoAKDI1MTgzMWVjZTk2MDFkNjQxNzIxMjdiNmNhYWU5MDg3MzU4YzIzODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T01:56:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T01:56:24Z"}, "message": "Auto merge of #103138 - nnethercote:merge-BBs, r=bjorn3\n\nMerge basic blocks where possible when generating LLVM IR.\n\nr? `@ghost`", "tree": {"sha": "a58e685881d672978e348dda71cd3e893a938096", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a58e685881d672978e348dda71cd3e893a938096"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/251831ece9601d64172127b6caae9087358c2386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/251831ece9601d64172127b6caae9087358c2386", "html_url": "https://github.com/rust-lang/rust/commit/251831ece9601d64172127b6caae9087358c2386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/251831ece9601d64172127b6caae9087358c2386/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bebd57a9602e48431c90274fbf7d96683b0708b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bebd57a9602e48431c90274fbf7d96683b0708b6", "html_url": "https://github.com/rust-lang/rust/commit/bebd57a9602e48431c90274fbf7d96683b0708b6"}, {"sha": "54082dd21695373b770bd11e042e564396598c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/54082dd21695373b770bd11e042e564396598c2a", "html_url": "https://github.com/rust-lang/rust/commit/54082dd21695373b770bd11e042e564396598c2a"}], "stats": {"total": 779, "additions": 427, "deletions": 352}, "files": [{"sha": "782f6856654a6f974f8043c72e6a4e543a8b9410", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -755,11 +755,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         OperandRef { val, layout: place.layout }\n     }\n \n-    fn write_operand_repeatedly(mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) -> Self {\n+    fn write_operand_repeatedly(&mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) {\n         let zero = self.const_usize(0);\n         let count = self.const_usize(count);\n-        let start = dest.project_index(&mut self, zero).llval;\n-        let end = dest.project_index(&mut self, count).llval;\n+        let start = dest.project_index(self, zero).llval;\n+        let end = dest.project_index(self, count).llval;\n \n         let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n         let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n@@ -778,14 +778,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n         self.switch_to_block(body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n-        cg_elem.val.store(&mut self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+        cg_elem.val.store(self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n         let next = self.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n         self.llbb().add_assignment(None, current, next);\n         self.br(header_bb);\n \n         self.switch_to_block(next_bb);\n-        self\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {"}, {"sha": "77dd15ef4d8078e8c37162776318f6068b272687", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -556,15 +556,15 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn write_operand_repeatedly(\n-        mut self,\n+        &mut self,\n         cg_elem: OperandRef<'tcx, &'ll Value>,\n         count: u64,\n         dest: PlaceRef<'tcx, &'ll Value>,\n-    ) -> Self {\n+    ) {\n         let zero = self.const_usize(0);\n         let count = self.const_usize(count);\n-        let start = dest.project_index(&mut self, zero).llval;\n-        let end = dest.project_index(&mut self, count).llval;\n+        let start = dest.project_index(self, zero).llval;\n+        let end = dest.project_index(self, count).llval;\n \n         let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n         let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n@@ -592,7 +592,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         body_bx.br(header_bb);\n         header_bx.add_incoming_to_phi(current, next, body_bb);\n \n-        Self::build(self.cx, next_bb)\n+        *self = Self::build(self.cx, next_bb);\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: WrappingRange) {"}, {"sha": "ade33b6c77728defec98a0e57bfc8d3e8b20c869", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -1,12 +1,13 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(box_patterns)]\n-#![feature(try_blocks)]\n-#![feature(once_cell)]\n #![feature(associated_type_bounds)]\n-#![feature(strict_provenance)]\n-#![feature(int_roundings)]\n+#![feature(box_patterns)]\n #![feature(if_let_guard)]\n+#![feature(int_roundings)]\n+#![feature(let_chains)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n+#![feature(strict_provenance)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "7822d924c01549c184cf83023b3893ce3d01c590", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 294, "deletions": 197, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -1,7 +1,7 @@\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Immediate, Pair, Ref};\n use super::place::PlaceRef;\n-use super::{FunctionCx, LocalRef};\n+use super::{CachedLlbb, FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n@@ -25,6 +25,15 @@ use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode, Reg};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n+// Indicates if we are in the middle of merging a BB's successor into it. This\n+// can happen when BB jumps directly to its successor and the successor has no\n+// other predecessors.\n+#[derive(Debug, PartialEq)]\n+enum MergingSucc {\n+    False,\n+    True,\n+}\n+\n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n /// e.g., creating a basic block, calling a function, etc.\n struct TerminatorCodegenHelper<'tcx> {\n@@ -64,39 +73,18 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    /// Get a basic block (creating it if necessary), possibly with a landing\n-    /// pad next to it.\n-    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n-        target: mir::BasicBlock,\n-    ) -> (Bx::BasicBlock, bool) {\n-        let span = self.terminator.source_info.span;\n-        let lltarget = fx.llbb(target);\n-        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n-        match (self.funclet_bb, target_funclet) {\n-            (None, None) => (lltarget, false),\n-            // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n-            (None, Some(_)) => (fx.landing_pad_for(target), false),\n-            (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(f), Some(t_f)) => {\n-                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n-                    (lltarget, false)\n-                } else {\n-                    (fx.landing_pad_for(target), true)\n-                }\n-            }\n-        }\n-    }\n-\n     /// Get a basic block (creating it if necessary), possibly with cleanup\n     /// stuff in it or next to it.\n     fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n+        let (needs_landing_pad, is_cleanupret) = self.llbb_characteristics(fx, target);\n+        let mut lltarget = fx.llbb(target);\n+        if needs_landing_pad {\n+            lltarget = fx.landing_pad_for(target);\n+        }\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n             debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n@@ -111,20 +99,54 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n+    fn llbb_characteristics<Bx: BuilderMethods<'a, 'tcx>>(\n+        &self,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n+        target: mir::BasicBlock,\n+    ) -> (bool, bool) {\n+        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n+        let (needs_landing_pad, is_cleanupret) = match (self.funclet_bb, target_funclet) {\n+            (None, None) => (false, false),\n+            (None, Some(_)) => (true, false),\n+            (Some(_), None) => {\n+                let span = self.terminator.source_info.span;\n+                span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator);\n+            }\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (false, false)\n+                } else {\n+                    (true, true)\n+                }\n+            }\n+        };\n+        (needs_landing_pad, is_cleanupret)\n+    }\n+\n     fn funclet_br<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n-    ) {\n-        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n-        if is_cleanupret {\n-            // MSVC micro-optimization: generate a `ret` rather than a jump\n-            // to a trampoline.\n-            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n-            bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n+        let (needs_landing_pad, is_cleanupret) = self.llbb_characteristics(fx, target);\n+        if mergeable_succ && !needs_landing_pad && !is_cleanupret {\n+            // We can merge the successor into this bb, so no need for a `br`.\n+            MergingSucc::True\n         } else {\n-            bx.br(lltarget);\n+            let mut lltarget = fx.llbb(target);\n+            if needs_landing_pad {\n+                lltarget = fx.landing_pad_for(target);\n+            }\n+            if is_cleanupret {\n+                // micro-optimization: generate a `ret` rather than a jump\n+                // to a trampoline.\n+                bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+            } else {\n+                bx.br(lltarget);\n+            }\n+            MergingSucc::False\n         }\n     }\n \n@@ -140,7 +162,8 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n         copied_constant_arguments: &[PlaceRef<'tcx, <Bx as BackendTypes>::Value>],\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n@@ -191,6 +214,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n+            MergingSucc::False\n         } else {\n             let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n@@ -206,9 +230,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                     bx.lifetime_end(tmp.llval, tmp.layout.size);\n                 }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, llret);\n-                self.funclet_br(fx, bx, target);\n+                self.funclet_br(fx, bx, target, mergeable_succ)\n             } else {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n         }\n     }\n@@ -225,7 +250,8 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         destination: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         instance: Instance<'_>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         if let Some(cleanup) = cleanup {\n             let ret_llbb = if let Some(target) = destination {\n                 fx.llbb(target)\n@@ -241,13 +267,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 instance,\n                 Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n+            MergingSucc::False\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n \n             if let Some(target) = destination {\n-                self.funclet_br(fx, bx, target);\n+                self.funclet_br(fx, bx, target, mergeable_succ)\n             } else {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n         }\n     }\n@@ -256,16 +284,16 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n /// Codegen implementations for some terminator variants.\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Generates code for a `Resume` terminator.\n-    fn codegen_resume_terminator(&mut self, helper: TerminatorCodegenHelper<'tcx>, mut bx: Bx) {\n+    fn codegen_resume_terminator(&mut self, helper: TerminatorCodegenHelper<'tcx>, bx: &mut Bx) {\n         if let Some(funclet) = helper.funclet(self) {\n             bx.cleanup_ret(funclet, None);\n         } else {\n-            let slot = self.get_personality_slot(&mut bx);\n-            let lp0 = slot.project_field(&mut bx, 0);\n+            let slot = self.get_personality_slot(bx);\n+            let lp0 = slot.project_field(bx, 0);\n             let lp0 = bx.load_operand(lp0).immediate();\n-            let lp1 = slot.project_field(&mut bx, 1);\n+            let lp1 = slot.project_field(bx, 1);\n             let lp1 = bx.load_operand(lp1).immediate();\n-            slot.storage_dead(&mut bx);\n+            slot.storage_dead(bx);\n \n             let mut lp = bx.const_undef(self.landing_pad_type());\n             lp = bx.insert_value(lp, lp0, 0);\n@@ -277,12 +305,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_switchint_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n         targets: &SwitchTargets,\n     ) {\n-        let discr = self.codegen_operand(&mut bx, &discr);\n+        let discr = self.codegen_operand(bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n         let mut target_iter = targets.iter();\n@@ -338,7 +366,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_return_terminator(&mut self, mut bx: Bx) {\n+    fn codegen_return_terminator(&mut self, bx: &mut Bx) {\n         // Call `va_end` if this is the definition of a C-variadic function.\n         if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n@@ -368,11 +396,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n-                let op = self.codegen_consume(&mut bx, mir::Place::return_place().as_ref());\n+                let op = self.codegen_consume(bx, mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(bx.backend_type(op.layout), llval, align)\n                 } else {\n-                    op.immediate_or_packed_pair(&mut bx)\n+                    op.immediate_or_packed_pair(bx)\n                 }\n             }\n \n@@ -388,8 +416,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n-                        let scratch = PlaceRef::alloca(&mut bx, self.fn_abi.ret.layout);\n-                        op.val.store(&mut bx, scratch);\n+                        let scratch = PlaceRef::alloca(bx, self.fn_abi.ret.layout);\n+                        op.val.store(bx, scratch);\n                         scratch.llval\n                     }\n                     Ref(llval, _, align) => {\n@@ -409,22 +437,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_drop_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.funclet_br(self, &mut bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n-        let place = self.codegen_place(&mut bx, location.as_ref());\n+        let place = self.codegen_place(bx, location.as_ref());\n         let (args1, args2);\n         let mut args = if let Some(llextra) = place.llextra {\n             args2 = [place.llval, llextra];\n@@ -462,7 +490,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args = &args[..1];\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n+                        .get_fn(bx, vtable, ty, &fn_abi),\n                     fn_abi,\n                 )\n             }\n@@ -507,37 +535,39 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 debug!(\"args' = {:?}\", args);\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n+                        .get_fn(bx, vtable, ty, &fn_abi),\n                     fn_abi,\n                 )\n             }\n             _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n         };\n         helper.do_call(\n             self,\n-            &mut bx,\n+            bx,\n             fn_abi,\n             drop_fn,\n             args,\n             Some((ReturnDest::Nothing, target)),\n             unwind,\n             &[],\n-        );\n+            mergeable_succ,\n+        )\n     }\n \n     fn codegen_assert_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         cond: &mir::Operand<'tcx>,\n         expected: bool,\n         msg: &mir::AssertMessage<'tcx>,\n         target: mir::BasicBlock,\n         cleanup: Option<mir::BasicBlock>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let span = terminator.source_info.span;\n-        let cond = self.codegen_operand(&mut bx, cond).immediate();\n+        let cond = self.codegen_operand(bx, cond).immediate();\n         let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n \n         // This case can currently arise only from functions marked\n@@ -555,8 +585,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.funclet_br(self, &mut bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n         // Pass the condition through llvm.expect for branch hinting.\n@@ -573,16 +602,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // After this point, bx is the block for the call to panic.\n         bx.switch_to_block(panic_block);\n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        self.set_debug_loc(bx, terminator.source_info);\n \n         // Get the location information.\n-        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n+        let location = self.get_caller_location(bx, terminator.source_info).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n             AssertKind::BoundsCheck { ref len, ref index } => {\n-                let len = self.codegen_operand(&mut bx, len).immediate();\n-                let index = self.codegen_operand(&mut bx, index).immediate();\n+                let len = self.codegen_operand(bx, len).immediate();\n+                let index = self.codegen_operand(bx, index).immediate();\n                 // It's `fn panic_bounds_check(index: usize, len: usize)`,\n                 // and `#[track_caller]` adds an implicit third argument.\n                 (LangItem::PanicBoundsCheck, vec![index, len, location])\n@@ -595,29 +624,32 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         };\n \n-        let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), lang_item);\n+        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), lang_item);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &args, None, cleanup, &[]);\n+        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &args, None, cleanup, &[], false);\n+        assert_eq!(merging_succ, MergingSucc::False);\n+        MergingSucc::False\n     }\n \n     fn codegen_abort_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n     ) {\n         let span = terminator.source_info.span;\n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        self.set_debug_loc(bx, terminator.source_info);\n \n         // Obtain the panic entry point.\n-        let (fn_abi, llfn) = common::build_langcall(&bx, Some(span), LangItem::PanicNoUnwind);\n+        let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicNoUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None, &[]);\n+        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[], false);\n+        assert_eq!(merging_succ, MergingSucc::False);\n     }\n \n-    /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n+    /// Returns `Some` if this is indeed a panic intrinsic and codegen is done.\n     fn codegen_panic_intrinsic(\n         &mut self,\n         helper: &TerminatorCodegenHelper<'tcx>,\n@@ -627,7 +659,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n-    ) -> bool {\n+        mergeable_succ: bool,\n+    ) -> Option<MergingSucc> {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n         // which mentions the offending type, even from a const context.\n@@ -653,7 +686,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 ZeroValid => !bx.tcx().permits_zero_init(layout),\n                 UninitValid => !bx.tcx().permits_uninit_init(layout),\n             };\n-            if do_panic {\n+            Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({\n                     with_no_trimmed_paths!({\n                         if layout.abi.is_uninhabited() {\n@@ -686,35 +719,36 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     target.as_ref().map(|bb| (ReturnDest::Nothing, *bb)),\n                     cleanup,\n                     &[],\n-                );\n+                    mergeable_succ,\n+                )\n             } else {\n                 // a NOP\n                 let target = target.unwrap();\n-                helper.funclet_br(self, bx, target)\n-            }\n-            true\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n+            })\n         } else {\n-            false\n+            None\n         }\n     }\n \n     fn codegen_call_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         destination: mir::Place<'tcx>,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         fn_span: Span,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let source_info = terminator.source_info;\n         let span = source_info.span;\n \n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-        let callee = self.codegen_operand(&mut bx, func);\n+        let callee = self.codegen_operand(bx, func);\n \n         let (instance, mut llfn) = match *callee.layout.ty.kind() {\n             ty::FnDef(def_id, substs) => (\n@@ -734,8 +768,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let target = target.unwrap();\n-            helper.funclet_br(self, &mut bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n         // FIXME(eddyb) avoid computing this if possible, when `instance` is\n@@ -762,9 +795,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if intrinsic == Some(sym::transmute) {\n-            if let Some(target) = target {\n-                self.codegen_transmute(&mut bx, &args[0], destination);\n-                helper.funclet_br(self, &mut bx, target);\n+            return if let Some(target) = target {\n+                self.codegen_transmute(bx, &args[0], destination);\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n                 // it is likely there is no allotted destination. In fact,\n@@ -774,20 +807,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // it must be unreachable.\n                 assert_eq!(fn_abi.ret.layout.abi, abi::Abi::Uninhabited);\n                 bx.unreachable();\n-            }\n-            return;\n+                MergingSucc::False\n+            };\n         }\n \n-        if self.codegen_panic_intrinsic(\n+        if let Some(merging_succ) = self.codegen_panic_intrinsic(\n             &helper,\n-            &mut bx,\n+            bx,\n             intrinsic,\n             instance,\n             source_info,\n             target,\n             cleanup,\n+            mergeable_succ,\n         ) {\n-            return;\n+            return merging_succ;\n         }\n \n         // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -797,23 +831,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Prepare the return value destination\n         let ret_dest = if target.is_some() {\n             let is_intrinsic = intrinsic.is_some();\n-            self.make_return_dest(&mut bx, destination, &fn_abi.ret, &mut llargs, is_intrinsic)\n+            self.make_return_dest(bx, destination, &fn_abi.ret, &mut llargs, is_intrinsic)\n         } else {\n             ReturnDest::Nothing\n         };\n \n         if intrinsic == Some(sym::caller_location) {\n-            if let Some(target) = target {\n-                let location = self\n-                    .get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n+            return if let Some(target) = target {\n+                let location =\n+                    self.get_caller_location(bx, mir::SourceInfo { span: fn_span, ..source_info });\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n-                    location.val.store(&mut bx, tmp);\n+                    location.val.store(bx, tmp);\n                 }\n-                self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n-                helper.funclet_br(self, &mut bx, target);\n-            }\n-            return;\n+                self.store_return(bx, ret_dest, &fn_abi.ret, location.immediate());\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n+            } else {\n+                MergingSucc::False\n+            };\n         }\n \n         match intrinsic {\n@@ -857,12 +892,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         }\n \n-                        self.codegen_operand(&mut bx, arg)\n+                        self.codegen_operand(bx, arg)\n                     })\n                     .collect();\n \n                 Self::codegen_intrinsic_call(\n-                    &mut bx,\n+                    bx,\n                     *instance.as_ref().unwrap(),\n                     &fn_abi,\n                     &args,\n@@ -871,16 +906,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n \n                 if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                    self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n+                    self.store_return(bx, ret_dest, &fn_abi.ret, dst.llval);\n                 }\n \n-                if let Some(target) = target {\n-                    helper.funclet_br(self, &mut bx, target);\n+                return if let Some(target) = target {\n+                    helper.funclet_br(self, bx, target, mergeable_succ)\n                 } else {\n                     bx.unreachable();\n-                }\n-\n-                return;\n+                    MergingSucc::False\n+                };\n             }\n         }\n \n@@ -894,7 +928,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let mut copied_constant_arguments = vec![];\n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n-            let mut op = self.codegen_operand(&mut bx, arg);\n+            let mut op = self.codegen_operand(bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                 match op.val {\n@@ -909,7 +943,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             && !op.layout.ty.is_region_ptr()\n                         {\n                             for i in 0..op.layout.fields.count() {\n-                                let field = op.extract_field(&mut bx, i);\n+                                let field = op.extract_field(bx, i);\n                                 if !field.layout.is_zst() {\n                                     // we found the one non-zero-sized field that is allowed\n                                     // now find *its* non-zero-sized field, or stop if it's a\n@@ -926,7 +960,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // data pointer and vtable. Look up the method in the vtable, and pass\n                         // the data pointer as the first argument\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta,\n                             op.layout.ty,\n                             &fn_abi,\n@@ -937,7 +971,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     Ref(data_ptr, Some(meta), _) => {\n                         // by-value dynamic dispatch\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta,\n                             op.layout.ty,\n                             &fn_abi,\n@@ -954,11 +988,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         // FIXME(dyn-star): Make sure this is done on a &dyn* receiver\n                         let place = op.deref(bx.cx());\n-                        let data_ptr = place.project_field(&mut bx, 0);\n-                        let meta_ptr = place.project_field(&mut bx, 1);\n+                        let data_ptr = place.project_field(bx, 0);\n+                        let meta_ptr = place.project_field(bx, 1);\n                         let meta = bx.load_operand(meta_ptr);\n                         llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                            &mut bx,\n+                            bx,\n                             meta.immediate(),\n                             op.layout.ty,\n                             &fn_abi,\n@@ -977,24 +1011,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _))\n                 | (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n+                    let tmp = PlaceRef::alloca(bx, op.layout);\n                     bx.lifetime_start(tmp.llval, tmp.layout.size);\n-                    op.val.store(&mut bx, tmp);\n+                    op.val.store(bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                     copied_constant_arguments.push(tmp);\n                 }\n                 _ => {}\n             }\n \n-            self.codegen_argument(&mut bx, op, &mut llargs, &fn_abi.args[i]);\n+            self.codegen_argument(bx, op, &mut llargs, &fn_abi.args[i]);\n         }\n         let num_untupled = untuple.map(|tup| {\n-            self.codegen_arguments_untupled(\n-                &mut bx,\n-                tup,\n-                &mut llargs,\n-                &fn_abi.args[first_args.len()..],\n-            )\n+            self.codegen_arguments_untupled(bx, tup, &mut llargs, &fn_abi.args[first_args.len()..])\n         });\n \n         let needs_location =\n@@ -1014,14 +1043,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 fn_abi,\n             );\n             let location =\n-                self.get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n+                self.get_caller_location(bx, mir::SourceInfo { span: fn_span, ..source_info });\n             debug!(\n                 \"codegen_call_terminator({:?}): location={:?} (fn_span {:?})\",\n                 terminator, location, fn_span\n             );\n \n             let last_arg = fn_abi.args.last().unwrap();\n-            self.codegen_argument(&mut bx, location, &mut llargs, last_arg);\n+            self.codegen_argument(bx, location, &mut llargs, last_arg);\n         }\n \n         let (is_indirect_call, fn_ptr) = match (llfn, instance) {\n@@ -1046,40 +1075,43 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.cond_br(cond, bb_pass, bb_fail);\n \n             bx.switch_to_block(bb_pass);\n-            helper.do_call(\n+            let merging_succ = helper.do_call(\n                 self,\n-                &mut bx,\n+                bx,\n                 fn_abi,\n                 fn_ptr,\n                 &llargs,\n                 target.as_ref().map(|&target| (ret_dest, target)),\n                 cleanup,\n                 &copied_constant_arguments,\n+                false,\n             );\n+            assert_eq!(merging_succ, MergingSucc::False);\n \n             bx.switch_to_block(bb_fail);\n             bx.abort();\n             bx.unreachable();\n \n-            return;\n+            return MergingSucc::False;\n         }\n \n         helper.do_call(\n             self,\n-            &mut bx,\n+            bx,\n             fn_abi,\n             fn_ptr,\n             &llargs,\n             target.as_ref().map(|&target| (ret_dest, target)),\n             cleanup,\n             &copied_constant_arguments,\n-        );\n+            mergeable_succ,\n+        )\n     }\n \n     fn codegen_asm_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         terminator: &mir::Terminator<'tcx>,\n         template: &[ast::InlineAsmTemplatePiece],\n         operands: &[mir::InlineAsmOperand<'tcx>],\n@@ -1088,24 +1120,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         destination: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         instance: Instance<'_>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let span = terminator.source_info.span;\n \n         let operands: Vec<_> = operands\n             .iter()\n             .map(|op| match *op {\n                 mir::InlineAsmOperand::In { reg, ref value } => {\n-                    let value = self.codegen_operand(&mut bx, value);\n+                    let value = self.codegen_operand(bx, value);\n                     InlineAsmOperandRef::In { reg, value }\n                 }\n                 mir::InlineAsmOperand::Out { reg, late, ref place } => {\n-                    let place = place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n+                    let place = place.map(|place| self.codegen_place(bx, place.as_ref()));\n                     InlineAsmOperandRef::Out { reg, late, place }\n                 }\n                 mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n-                    let in_value = self.codegen_operand(&mut bx, in_value);\n+                    let in_value = self.codegen_operand(bx, in_value);\n                     let out_place =\n-                        out_place.map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n+                        out_place.map(|out_place| self.codegen_place(bx, out_place.as_ref()));\n                     InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n                 }\n                 mir::InlineAsmOperand::Const { ref value } => {\n@@ -1143,79 +1176,136 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         helper.do_inlineasm(\n             self,\n-            &mut bx,\n+            bx,\n             template,\n             &operands,\n             options,\n             line_spans,\n             destination,\n             cleanup,\n             instance,\n-        );\n+            mergeable_succ,\n+        )\n     }\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n-        let llbb = self.llbb(bb);\n-        let mut bx = Bx::build(self.cx, llbb);\n+    pub fn codegen_block(&mut self, mut bb: mir::BasicBlock) {\n+        let llbb = match self.try_llbb(bb) {\n+            Some(llbb) => llbb,\n+            None => return,\n+        };\n+        let bx = &mut Bx::build(self.cx, llbb);\n         let mir = self.mir;\n-        let data = &mir[bb];\n \n-        debug!(\"codegen_block({:?}={:?})\", bb, data);\n+        // MIR basic blocks stop at any function call. This may not be the case\n+        // for the backend's basic blocks, in which case we might be able to\n+        // combine multiple MIR basic blocks into a single backend basic block.\n+        loop {\n+            let data = &mir[bb];\n \n-        for statement in &data.statements {\n-            bx = self.codegen_statement(bx, statement);\n-        }\n+            debug!(\"codegen_block({:?}={:?})\", bb, data);\n+\n+            for statement in &data.statements {\n+                self.codegen_statement(bx, statement);\n+            }\n \n-        self.codegen_terminator(bx, bb, data.terminator());\n+            let merging_succ = self.codegen_terminator(bx, bb, data.terminator());\n+            if let MergingSucc::False = merging_succ {\n+                break;\n+            }\n+\n+            // We are merging the successor into the produced backend basic\n+            // block. Record that the successor should be skipped when it is\n+            // reached.\n+            //\n+            // Note: we must not have already generated code for the successor.\n+            // This is implicitly ensured by the reverse postorder traversal,\n+            // and the assertion explicitly guarantees that.\n+            let mut successors = data.terminator().successors();\n+            let succ = successors.next().unwrap();\n+            assert!(matches!(self.cached_llbbs[succ], CachedLlbb::None));\n+            self.cached_llbbs[succ] = CachedLlbb::Skip;\n+            bb = succ;\n+        }\n     }\n \n     fn codegen_terminator(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         bb: mir::BasicBlock,\n         terminator: &'tcx mir::Terminator<'tcx>,\n-    ) {\n+    ) -> MergingSucc {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n         let helper = TerminatorCodegenHelper { bb, terminator, funclet_bb };\n \n-        self.set_debug_loc(&mut bx, terminator.source_info);\n+        let mergeable_succ = || {\n+            // Note: any call to `switch_to_block` will invalidate a `true` value\n+            // of `mergeable_succ`.\n+            let mut successors = terminator.successors();\n+            if let Some(succ) = successors.next()\n+                && successors.next().is_none()\n+                && let &[succ_pred] = self.mir.basic_blocks.predecessors()[succ].as_slice()\n+            {\n+                // bb has a single successor, and bb is its only predecessor. This\n+                // makes it a candidate for merging.\n+                assert_eq!(succ_pred, bb);\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+\n+        self.set_debug_loc(bx, terminator.source_info);\n         match terminator.kind {\n-            mir::TerminatorKind::Resume => self.codegen_resume_terminator(helper, bx),\n+            mir::TerminatorKind::Resume => {\n+                self.codegen_resume_terminator(helper, bx);\n+                MergingSucc::False\n+            }\n \n             mir::TerminatorKind::Abort => {\n                 self.codegen_abort_terminator(helper, bx, terminator);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.funclet_br(self, &mut bx, target);\n+                helper.funclet_br(self, bx, target, mergeable_succ())\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n                 self.codegen_switchint_terminator(helper, bx, discr, switch_ty, targets);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Return => {\n                 self.codegen_return_terminator(bx);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Unreachable => {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Drop { place, target, unwind } => {\n-                self.codegen_drop_terminator(helper, bx, place, target, unwind);\n+                self.codegen_drop_terminator(helper, bx, place, target, unwind, mergeable_succ())\n             }\n \n-            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                self.codegen_assert_terminator(\n-                    helper, bx, terminator, cond, expected, msg, target, cleanup,\n-                );\n-            }\n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => self\n+                .codegen_assert_terminator(\n+                    helper,\n+                    bx,\n+                    terminator,\n+                    cond,\n+                    expected,\n+                    msg,\n+                    target,\n+                    cleanup,\n+                    mergeable_succ(),\n+                ),\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n                 bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n@@ -1229,19 +1319,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cleanup,\n                 from_hir_call: _,\n                 fn_span,\n-            } => {\n-                self.codegen_call_terminator(\n-                    helper,\n-                    bx,\n-                    terminator,\n-                    func,\n-                    args,\n-                    destination,\n-                    target,\n-                    cleanup,\n-                    fn_span,\n-                );\n-            }\n+            } => self.codegen_call_terminator(\n+                helper,\n+                bx,\n+                terminator,\n+                func,\n+                args,\n+                destination,\n+                target,\n+                cleanup,\n+                fn_span,\n+                mergeable_succ(),\n+            ),\n             mir::TerminatorKind::GeneratorDrop | mir::TerminatorKind::Yield { .. } => {\n                 bug!(\"generator ops in codegen\")\n             }\n@@ -1256,20 +1345,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 line_spans,\n                 destination,\n                 cleanup,\n-            } => {\n-                self.codegen_asm_terminator(\n-                    helper,\n-                    bx,\n-                    terminator,\n-                    template,\n-                    operands,\n-                    options,\n-                    line_spans,\n-                    destination,\n-                    cleanup,\n-                    self.instance,\n-                );\n-            }\n+            } => self.codegen_asm_terminator(\n+                helper,\n+                bx,\n+                terminator,\n+                template,\n+                operands,\n+                options,\n+                line_spans,\n+                destination,\n+                cleanup,\n+                self.instance,\n+                mergeable_succ(),\n+            ),\n         }\n     }\n \n@@ -1587,12 +1675,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a\n     // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbb`).\n     pub fn llbb(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n-        self.cached_llbbs[bb].unwrap_or_else(|| {\n-            // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n-            let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n-            self.cached_llbbs[bb] = Some(llbb);\n-            llbb\n-        })\n+        self.try_llbb(bb).unwrap()\n+    }\n+\n+    /// Like `llbb`, but may fail if the basic block should be skipped.\n+    pub fn try_llbb(&mut self, bb: mir::BasicBlock) -> Option<Bx::BasicBlock> {\n+        match self.cached_llbbs[bb] {\n+            CachedLlbb::None => {\n+                // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n+                let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n+                self.cached_llbbs[bb] = CachedLlbb::Some(llbb);\n+                Some(llbb)\n+            }\n+            CachedLlbb::Some(llbb) => Some(llbb),\n+            CachedLlbb::Skip => None,\n+        }\n     }\n \n     fn make_return_dest("}, {"sha": "79c66a955e76d856cb534aef6a6da2a6ff9cf107", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -16,6 +16,18 @@ use rustc_middle::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n+// Used for tracking the state of generated basic blocks.\n+enum CachedLlbb<T> {\n+    /// Nothing created yet.\n+    None,\n+\n+    /// Has been created.\n+    Some(T),\n+\n+    /// Nothing created yet, and nothing should be.\n+    Skip,\n+}\n+\n /// Master context for codegenning from MIR.\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n@@ -43,7 +55,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// as-needed (e.g. RPO reaching it or another block branching to it).\n     // FIXME(eddyb) rename `llbbs` and other `ll`-prefixed things to use a\n     // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbbs`).\n-    cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n+    cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n@@ -155,11 +167,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n-    let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> = mir\n-        .basic_blocks\n-        .indices()\n-        .map(|bb| if bb == mir::START_BLOCK { Some(start_llbb) } else { None })\n-        .collect();\n+    let cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>> =\n+        mir.basic_blocks\n+            .indices()\n+            .map(|bb| {\n+                if bb == mir::START_BLOCK { CachedLlbb::Some(start_llbb) } else { CachedLlbb::None }\n+            })\n+            .collect();\n \n     let mut fx = FunctionCx {\n         instance,"}, {"sha": "9ad96f7a44742f87d227114f102f388b5c110e01", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 73, "deletions": 100, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -18,17 +18,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n     pub fn codegen_rvalue(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> Bx {\n+    ) {\n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let cg_operand = self.codegen_operand(&mut bx, operand);\n+                let cg_operand = self.codegen_operand(bx, operand);\n                 // FIXME: consider not copying constants through stack. (Fixable by codegen'ing\n                 // constants into `OperandValue::Ref`; why don\u2019t we do that yet if we don\u2019t?)\n-                cg_operand.val.store(&mut bx, dest);\n-                bx\n+                cg_operand.val.store(bx, dest);\n             }\n \n             mir::Rvalue::Cast(mir::CastKind::Pointer(PointerCast::Unsize), ref source, _) => {\n@@ -37,16 +36,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 if bx.cx().is_backend_scalar_pair(dest.layout) {\n                     // Into-coerce of a thin pointer to a fat pointer -- just\n                     // use the operand path.\n-                    let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n-                    temp.val.store(&mut bx, dest);\n-                    return bx;\n+                    let temp = self.codegen_rvalue_operand(bx, rvalue);\n+                    temp.val.store(bx, dest);\n+                    return;\n                 }\n \n                 // Unsize of a nontrivial struct. I would prefer for\n                 // this to be eliminated by MIR building, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.codegen_operand(&mut bx, source);\n+                let operand = self.codegen_operand(bx, source);\n                 match operand.val {\n                     OperandValue::Pair(..) | OperandValue::Immediate(_) => {\n                         // Unsize from an immediate structure. We don't\n@@ -56,111 +55,107 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n-                        scratch.storage_live(&mut bx);\n-                        operand.val.store(&mut bx, scratch);\n-                        base::coerce_unsized_into(&mut bx, scratch, dest);\n-                        scratch.storage_dead(&mut bx);\n+                        let scratch = PlaceRef::alloca(bx, operand.layout);\n+                        scratch.storage_live(bx);\n+                        operand.val.store(bx, scratch);\n+                        base::coerce_unsized_into(bx, scratch, dest);\n+                        scratch.storage_dead(bx);\n                     }\n                     OperandValue::Ref(llref, None, align) => {\n                         let source = PlaceRef::new_sized_aligned(llref, operand.layout, align);\n-                        base::coerce_unsized_into(&mut bx, source, dest);\n+                        base::coerce_unsized_into(bx, source, dest);\n                     }\n                     OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n                 }\n-                bx\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let cg_elem = self.codegen_operand(&mut bx, elem);\n+                let cg_elem = self.codegen_operand(bx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n                 if dest.layout.is_zst() {\n-                    return bx;\n+                    return;\n                 }\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n                     let zero = bx.const_usize(0);\n-                    let start = dest.project_index(&mut bx, zero).llval;\n+                    let start = dest.project_index(bx, zero).llval;\n                     let size = bx.const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if bx.cx().const_to_opt_u128(v, false) == Some(0) {\n                         let fill = bx.cx().const_u8(0);\n                         bx.memset(start, fill, size, dest.align, MemFlags::empty());\n-                        return bx;\n+                        return;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = bx.from_immediate(v);\n                     if bx.cx().val_ty(v) == bx.cx().type_i8() {\n                         bx.memset(start, v, size, dest.align, MemFlags::empty());\n-                        return bx;\n+                        return;\n                     }\n                 }\n \n                 let count =\n                     self.monomorphize(count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n \n-                bx.write_operand_repeatedly(cg_elem, count, dest)\n+                bx.write_operand_repeatedly(cg_elem, count, dest);\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_did, variant_index, _, _, active_field_index) => {\n-                        dest.codegen_set_discr(&mut bx, variant_index);\n+                        dest.codegen_set_discr(bx, variant_index);\n                         if bx.tcx().adt_def(adt_did).is_enum() {\n-                            (dest.project_downcast(&mut bx, variant_index), active_field_index)\n+                            (dest.project_downcast(bx, variant_index), active_field_index)\n                         } else {\n                             (dest, active_field_index)\n                         }\n                     }\n                     _ => (dest, None),\n                 };\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let op = self.codegen_operand(&mut bx, operand);\n+                    let op = self.codegen_operand(bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let field = if let mir::AggregateKind::Array(_) = **kind {\n                             let llindex = bx.cx().const_usize(field_index as u64);\n-                            dest.project_index(&mut bx, llindex)\n+                            dest.project_index(bx, llindex)\n                         } else {\n-                            dest.project_field(&mut bx, field_index)\n+                            dest.project_field(bx, field_index)\n                         };\n-                        op.val.store(&mut bx, field);\n+                        op.val.store(bx, field);\n                     }\n                 }\n-                bx\n             }\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue, DUMMY_SP));\n-                let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n-                temp.val.store(&mut bx, dest);\n-                bx\n+                let temp = self.codegen_rvalue_operand(bx, rvalue);\n+                temp.val.store(bx, dest);\n             }\n         }\n     }\n \n     pub fn codegen_rvalue_unsized(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         indirect_dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> Bx {\n+    ) {\n         debug!(\n             \"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n             indirect_dest.llval, rvalue\n         );\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let cg_operand = self.codegen_operand(&mut bx, operand);\n-                cg_operand.val.store_unsized(&mut bx, indirect_dest);\n-                bx\n+                let cg_operand = self.codegen_operand(bx, operand);\n+                cg_operand.val.store_unsized(bx, indirect_dest);\n             }\n \n             _ => bug!(\"unsized assignment other than `Rvalue::Use`\"),\n@@ -169,9 +164,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn codegen_rvalue_operand(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         rvalue: &mir::Rvalue<'tcx>,\n-    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         assert!(\n             self.rvalue_creates_operand(rvalue, DUMMY_SP),\n             \"cannot codegen {:?} to operand\",\n@@ -180,7 +175,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n-                let operand = self.codegen_operand(&mut bx, source);\n+                let operand = self.codegen_operand(bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n                 let cast = bx.cx().layout_of(self.monomorphize(mir_cast_ty));\n \n@@ -245,7 +240,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             }\n                         };\n                         let (lldata, llextra) =\n-                            base::unsize_ptr(&mut bx, lldata, operand.layout.ty, cast.ty, llextra);\n+                            base::unsize_ptr(bx, lldata, operand.layout.ty, cast.ty, llextra);\n                         OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n@@ -278,7 +273,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Pair(v, l) => (v, Some(l)),\n                         };\n                         let (lldata, llextra) =\n-                            base::cast_to_dyn_star(&mut bx, lldata, operand.layout, cast.ty, llextra);\n+                            base::cast_to_dyn_star(bx, lldata, operand.layout, cast.ty, llextra);\n                         OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(\n@@ -299,7 +294,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {\n                             let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));\n-                            return (bx, OperandRef { val, layout: cast });\n+                            return OperandRef { val, layout: cast };\n                         }\n                         let r_t_in =\n                             CastTy::from_ty(operand.layout.ty).expect(\"bad input type for cast\");\n@@ -348,7 +343,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         OperandValue::Immediate(newval)\n                     }\n                 };\n-                (bx, OperandRef { val, layout: cast })\n+                OperandRef { val, layout: cast }\n             }\n \n             mir::Rvalue::Ref(_, bk, place) => {\n@@ -361,10 +356,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_place_to_pointer(bx, place, mk_ref)\n             }\n \n-            mir::Rvalue::CopyForDeref(place) => {\n-                let operand = self.codegen_operand(&mut bx, &Operand::Copy(place));\n-                (bx, operand)\n-            }\n+            mir::Rvalue::CopyForDeref(place) => self.codegen_operand(bx, &Operand::Copy(place)),\n             mir::Rvalue::AddressOf(mutability, place) => {\n                 let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ptr(ty::TypeAndMut { ty, mutbl: mutability })\n@@ -373,23 +365,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Len(place) => {\n-                let size = self.evaluate_array_len(&mut bx, place);\n-                let operand = OperandRef {\n+                let size = self.evaluate_array_len(bx, place);\n+                OperandRef {\n                     val: OperandValue::Immediate(size),\n                     layout: bx.cx().layout_of(bx.tcx().types.usize),\n-                };\n-                (bx, operand)\n+                }\n             }\n \n             mir::Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) => {\n-                let lhs = self.codegen_operand(&mut bx, lhs);\n-                let rhs = self.codegen_operand(&mut bx, rhs);\n+                let lhs = self.codegen_operand(bx, lhs);\n+                let rhs = self.codegen_operand(bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n                     (\n                         OperandValue::Pair(lhs_addr, lhs_extra),\n                         OperandValue::Pair(rhs_addr, rhs_extra),\n                     ) => self.codegen_fat_ptr_binop(\n-                        &mut bx,\n+                        bx,\n                         op,\n                         lhs_addr,\n                         lhs_extra,\n@@ -399,36 +390,33 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     ),\n \n                     (OperandValue::Immediate(lhs_val), OperandValue::Immediate(rhs_val)) => {\n-                        self.codegen_scalar_binop(&mut bx, op, lhs_val, rhs_val, lhs.layout.ty)\n+                        self.codegen_scalar_binop(bx, op, lhs_val, rhs_val, lhs.layout.ty)\n                     }\n \n                     _ => bug!(),\n                 };\n-                let operand = OperandRef {\n+                OperandRef {\n                     val: OperandValue::Immediate(llresult),\n                     layout: bx.cx().layout_of(op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n-                };\n-                (bx, operand)\n+                }\n             }\n             mir::Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n-                let lhs = self.codegen_operand(&mut bx, lhs);\n-                let rhs = self.codegen_operand(&mut bx, rhs);\n+                let lhs = self.codegen_operand(bx, lhs);\n+                let rhs = self.codegen_operand(bx, rhs);\n                 let result = self.codegen_scalar_checked_binop(\n-                    &mut bx,\n+                    bx,\n                     op,\n                     lhs.immediate(),\n                     rhs.immediate(),\n                     lhs.layout.ty,\n                 );\n                 let val_ty = op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty);\n                 let operand_ty = bx.tcx().intern_tup(&[val_ty, bx.tcx().types.bool]);\n-                let operand = OperandRef { val: result, layout: bx.cx().layout_of(operand_ty) };\n-\n-                (bx, operand)\n+                OperandRef { val: result, layout: bx.cx().layout_of(operand_ty) }\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n+                let operand = self.codegen_operand(bx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.layout.ty.is_floating_point();\n                 let llval = match op {\n@@ -441,22 +429,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                 };\n-                (bx, OperandRef { val: OperandValue::Immediate(llval), layout: operand.layout })\n+                OperandRef { val: OperandValue::Immediate(llval), layout: operand.layout }\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(self.mir, bx.tcx());\n                 let discr_ty = self.monomorphize(discr_ty);\n-                let discr = self\n-                    .codegen_place(&mut bx, place.as_ref())\n-                    .codegen_get_discr(&mut bx, discr_ty);\n-                (\n-                    bx,\n-                    OperandRef {\n-                        val: OperandValue::Immediate(discr),\n-                        layout: self.cx.layout_of(discr_ty),\n-                    },\n-                )\n+                let discr = self.codegen_place(bx, place.as_ref()).codegen_get_discr(bx, discr_ty);\n+                OperandRef {\n+                    val: OperandValue::Immediate(discr),\n+                    layout: self.cx.layout_of(discr_ty),\n+                }\n             }\n \n             mir::Rvalue::NullaryOp(null_op, ty) => {\n@@ -469,45 +452,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let val = bx.cx().const_usize(val);\n                 let tcx = self.cx.tcx();\n-                (\n-                    bx,\n-                    OperandRef {\n-                        val: OperandValue::Immediate(val),\n-                        layout: self.cx.layout_of(tcx.types.usize),\n-                    },\n-                )\n+                OperandRef {\n+                    val: OperandValue::Immediate(val),\n+                    layout: self.cx.layout_of(tcx.types.usize),\n+                }\n             }\n \n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(bx.cx().tcx().is_static(def_id));\n                 let static_ = bx.get_static(def_id);\n                 let layout = bx.layout_of(bx.cx().tcx().static_ptr_ty(def_id));\n-                let operand = OperandRef::from_immediate_or_packed_pair(&mut bx, static_, layout);\n-                (bx, operand)\n-            }\n-            mir::Rvalue::Use(ref operand) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n-                (bx, operand)\n+                OperandRef::from_immediate_or_packed_pair(bx, static_, layout)\n             }\n+            mir::Rvalue::Use(ref operand) => self.codegen_operand(bx, operand),\n             mir::Rvalue::Repeat(..) | mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                let operand =\n-                    OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(ty)));\n-                (bx, operand)\n+                OperandRef::new_zst(bx, self.cx.layout_of(self.monomorphize(ty)))\n             }\n             mir::Rvalue::ShallowInitBox(ref operand, content_ty) => {\n-                let operand = self.codegen_operand(&mut bx, operand);\n+                let operand = self.codegen_operand(bx, operand);\n                 let lloperand = operand.immediate();\n \n                 let content_ty = self.monomorphize(content_ty);\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = bx.cx().backend_type(box_layout);\n \n                 let val = bx.pointercast(lloperand, llty_ptr);\n-                let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };\n-                (bx, operand)\n+                OperandRef { val: OperandValue::Immediate(val), layout: box_layout }\n             }\n         }\n     }\n@@ -531,11 +504,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Codegen an `Rvalue::AddressOf` or `Rvalue::Ref`\n     fn codegen_place_to_pointer(\n         &mut self,\n-        mut bx: Bx,\n+        bx: &mut Bx,\n         place: mir::Place<'tcx>,\n         mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n-    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n-        let cg_place = self.codegen_place(&mut bx, place.as_ref());\n+    ) -> OperandRef<'tcx, Bx::Value> {\n+        let cg_place = self.codegen_place(bx, place.as_ref());\n \n         let ty = cg_place.layout.ty;\n \n@@ -546,7 +519,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n         };\n-        (bx, OperandRef { val, layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)) })\n+        OperandRef { val, layout: self.cx.layout_of(mk_ptr_ty(self.cx.tcx(), ty)) }\n     }\n \n     pub fn codegen_scalar_binop("}, {"sha": "19452c8cdc805da6068a7b37f8a871368961588b", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -8,8 +8,8 @@ use crate::traits::*;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"debug\", skip(self, bx))]\n-    pub fn codegen_statement(&mut self, mut bx: Bx, statement: &mir::Statement<'tcx>) -> Bx {\n-        self.set_debug_loc(&mut bx, statement.source_info);\n+    pub fn codegen_statement(&mut self, bx: &mut Bx, statement: &mir::Statement<'tcx>) {\n+        self.set_debug_loc(bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box (ref place, ref rvalue)) => {\n                 if let Some(index) = place.as_local() {\n@@ -19,10 +19,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n+                            let operand = self.codegen_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n-                            self.debug_introduce_local(&mut bx, index);\n-                            bx\n+                            self.debug_introduce_local(bx, index);\n                         }\n                         LocalRef::Operand(Some(op)) => {\n                             if !op.layout.is_zst() {\n@@ -35,72 +34,64 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                             // If the type is zero-sized, it's already been set here,\n                             // but we still need to make sure we codegen the operand\n-                            self.codegen_rvalue_operand(bx, rvalue).0\n+                            self.codegen_rvalue_operand(bx, rvalue);\n                         }\n                     }\n                 } else {\n-                    let cg_dest = self.codegen_place(&mut bx, place.as_ref());\n-                    self.codegen_rvalue(bx, cg_dest, rvalue)\n+                    let cg_dest = self.codegen_place(bx, place.as_ref());\n+                    self.codegen_rvalue(bx, cg_dest, rvalue);\n                 }\n             }\n             mir::StatementKind::SetDiscriminant { box ref place, variant_index } => {\n-                self.codegen_place(&mut bx, place.as_ref())\n-                    .codegen_set_discr(&mut bx, variant_index);\n-                bx\n+                self.codegen_place(bx, place.as_ref()).codegen_set_discr(bx, variant_index);\n             }\n             mir::StatementKind::Deinit(..) => {\n                 // For now, don't codegen this to anything. In the future it may be worth\n                 // experimenting with what kind of information we can emit to LLVM without hurting\n                 // perf here\n-                bx\n             }\n             mir::StatementKind::StorageLive(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n-                    cg_place.storage_live(&mut bx);\n+                    cg_place.storage_live(bx);\n                 } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n-                    cg_indirect_place.storage_live(&mut bx);\n+                    cg_indirect_place.storage_live(bx);\n                 }\n-                bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n                 if let LocalRef::Place(cg_place) = self.locals[local] {\n-                    cg_place.storage_dead(&mut bx);\n+                    cg_place.storage_dead(bx);\n                 } else if let LocalRef::UnsizedPlace(cg_indirect_place) = self.locals[local] {\n-                    cg_indirect_place.storage_dead(&mut bx);\n+                    cg_indirect_place.storage_dead(bx);\n                 }\n-                bx\n             }\n             mir::StatementKind::Coverage(box ref coverage) => {\n-                self.codegen_coverage(&mut bx, coverage.clone(), statement.source_info.scope);\n-                bx\n+                self.codegen_coverage(bx, coverage.clone(), statement.source_info.scope);\n             }\n             mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(ref op)) => {\n-                let op_val = self.codegen_operand(&mut bx, op);\n+                let op_val = self.codegen_operand(bx, op);\n                 bx.assume(op_val.immediate());\n-                bx\n             }\n             mir::StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n                 mir::CopyNonOverlapping { ref count, ref src, ref dst },\n             )) => {\n-                let dst_val = self.codegen_operand(&mut bx, dst);\n-                let src_val = self.codegen_operand(&mut bx, src);\n-                let count = self.codegen_operand(&mut bx, count).immediate();\n+                let dst_val = self.codegen_operand(bx, dst);\n+                let src_val = self.codegen_operand(bx, src);\n+                let count = self.codegen_operand(bx, count).immediate();\n                 let pointee_layout = dst_val\n                     .layout\n-                    .pointee_info_at(&bx, rustc_target::abi::Size::ZERO)\n+                    .pointee_info_at(bx, rustc_target::abi::Size::ZERO)\n                     .expect(\"Expected pointer\");\n                 let bytes = bx.mul(count, bx.const_usize(pointee_layout.size.bytes()));\n \n                 let align = pointee_layout.align;\n                 let dst = dst_val.immediate();\n                 let src = src_val.immediate();\n                 bx.memcpy(dst, align, src, align, bytes, crate::MemFlags::empty());\n-                bx\n             }\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n-            | mir::StatementKind::Nop => bx,\n+            | mir::StatementKind::Nop => {}\n         }\n     }\n }"}, {"sha": "bc679a5dc87b122a4fcc7ea8111216f8b871b8f3", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -151,11 +151,11 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     /// Called for Rvalue::Repeat when the elem is neither a ZST nor optimizable using memset.\n     fn write_operand_repeatedly(\n-        self,\n+        &mut self,\n         elem: OperandRef<'tcx, Self::Value>,\n         count: u64,\n         dest: PlaceRef<'tcx, Self::Value>,\n-    ) -> Self;\n+    );\n \n     fn range_metadata(&mut self, load: Self::Value, range: WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);"}, {"sha": "8fee459bd7ac778113bdc5b523ccfa2c36cc9767", "filename": "src/test/debuginfo/lexical-scope-in-if-let.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/251831ece9601d64172127b6caae9087358c2386/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251831ece9601d64172127b6caae9087358c2386/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs?ref=251831ece9601d64172127b6caae9087358c2386", "patch": "@@ -58,19 +58,19 @@\n \n // cdb-command: g\n // cdb-command: dv\n-// cdb-check:[...]y = true\n-// cdb-check:[...]b = 0n456\n // cdb-check:[...]a = 0n123\n // cdb-check:[...]x = 0n42\n+// cdb-check:[...]b = 0n456\n+// cdb-check:[...]y = true\n \n // cdb-command: g\n // cdb-command: dv\n // cdb-check:[...]z = 0n10\n // cdb-check:[...]c = 0n789\n-// cdb-check:[...]y = true\n-// cdb-check:[...]b = 0n456\n // cdb-check:[...]a = 0n123\n // cdb-check:[...]x = 0n42\n+// cdb-check:[...]b = 0n456\n+// cdb-check:[...]y = true\n \n fn main() {\n     let a = id(123);"}]}