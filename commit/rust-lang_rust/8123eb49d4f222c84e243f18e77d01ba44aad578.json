{"sha": "8123eb49d4f222c84e243f18e77d01ba44aad578", "node_id": "C_kwDOAAsO6NoAKDgxMjNlYjQ5ZDRmMjIyYzg0ZTI0M2YxOGU3N2QwMWJhNDRhYWQ1Nzg", "commit": {"author": {"name": "Chris Denton", "email": "chris@chrisdenton.dev", "date": "2023-02-20T10:41:26Z"}, "committer": {"name": "Chris Denton", "email": "chris@chrisdenton.dev", "date": "2023-02-20T14:16:43Z"}, "message": "Move `NtWriteFile` miri shim to `foreign_items`", "tree": {"sha": "31a15dcfdfdc3c966f96723cc4104389f32640ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a15dcfdfdc3c966f96723cc4104389f32640ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8123eb49d4f222c84e243f18e77d01ba44aad578", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmPzgMwACgkQcTRy8vRW\nJ94NdBAAhi/zDVJL00MRZ3oGgcTlslpdHdTjRL5NWCh92C0eq8ByMauOa2rFBoRY\nZPgVTpp4c49NVYuwhBT/4tIZNs+uowy5Yu3yqzSg/P2RO9aFI1xoe0TkKQA0AWPk\nYx39vs1eAca8Cdr2R3P7M4cWClM7Bn5oH4oShvpxnFj7eLNCgOqDK5zwFt2XE27K\nm17JeDJoDQ41UC9QXMU0Rpa+24HocPmMAhECBpfCgjmJKPOscSvy1g/9vjbBTJYv\nf0ZXOf3od/DA9nezsmiM0JGEDCTT4MAny0uO5y8mWODKT+9afVQBP4ugbJG6gqgQ\ncdSzXjeVDoYy+VBfL0sl1gW16IIU75DQexfsBdtRMPEaNcQ5j82qOJSeo3A4WW5T\nhgg7T96NANvoq+je7zTDnXYqlLt6U+uUndPtsyYJB16V0WGiO0UpOgqvx2MW6IEj\nwu1GkxkVH7d9YQzmbezhsfv6SdbbIqQSC0rEL55CKxyU652/zrxF4DQneKDbrA5F\nmIhzThX6mbp0+cQjZHmYEjVrxjx7+Ys7D6ATX7sLV1Ol/xTUW2ivSpSBtGgJJEnP\nYHflRlKLgO2WSr7qY7Mk6HakpRAFHuJKd1sy48IyP+URp0A2NQgzTr2n6rza7Nu7\nE+Y8zwyO9L8DOaRzFSx0XhrGjUf/zgox6Q+CkCc8sh0xEoagiVM=\n=3Hx/\n-----END PGP SIGNATURE-----", "payload": "tree 31a15dcfdfdc3c966f96723cc4104389f32640ac\nparent 77de724f92ab111b9cbf48b968552a974168d983\nauthor Chris Denton <chris@chrisdenton.dev> 1676889686 +0000\ncommitter Chris Denton <chris@chrisdenton.dev> 1676902603 +0000\n\nMove `NtWriteFile` miri shim to `foreign_items`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8123eb49d4f222c84e243f18e77d01ba44aad578", "html_url": "https://github.com/rust-lang/rust/commit/8123eb49d4f222c84e243f18e77d01ba44aad578", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8123eb49d4f222c84e243f18e77d01ba44aad578/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77de724f92ab111b9cbf48b968552a974168d983", "url": "https://api.github.com/repos/rust-lang/rust/commits/77de724f92ab111b9cbf48b968552a974168d983", "html_url": "https://github.com/rust-lang/rust/commit/77de724f92ab111b9cbf48b968552a974168d983"}], "stats": {"total": 137, "additions": 68, "deletions": 69}, "files": [{"sha": "7e2051fc98a0ee8ed2f5c65d5874dd4aa88d16aa", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8123eb49d4f222c84e243f18e77d01ba44aad578/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8123eb49d4f222c84e243f18e77d01ba44aad578/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=8123eb49d4f222c84e243f18e77d01ba44aad578", "patch": "@@ -1,5 +1,4 @@\n use rustc_middle::mir;\n-use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use log::trace;\n@@ -11,7 +10,6 @@ use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n-    NtWriteFile,\n     SetThreadDescription,\n     WaitOnAddress,\n     WakeByAddressSingle,\n@@ -23,7 +21,6 @@ impl Dlsym {\n     pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n-            \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n             \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n             \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n@@ -49,72 +46,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.check_abi(abi, Abi::System { unwind: false })?;\n \n         match dlsym {\n-            Dlsym::NtWriteFile => {\n-                if !this.frame_in_std() {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n-                    );\n-                }\n-\n-                let [\n-                    handle,\n-                    _event,\n-                    _apc_routine,\n-                    _apc_context,\n-                    io_status_block,\n-                    buf,\n-                    n,\n-                    byte_offset,\n-                    _key,\n-                ] = check_arg_count(args)?;\n-                let handle = this.read_target_isize(handle)?;\n-                let buf = this.read_pointer(buf)?;\n-                let n = this.read_scalar(n)?.to_u32()?;\n-                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n-                let io_status_block = this.deref_operand(io_status_block)?;\n-\n-                if byte_offset != 0 {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n-                    );\n-                }\n-\n-                let written = if handle == -11 || handle == -12 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont =\n-                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n-                    let res = if this.machine.mute_stdout_stderr {\n-                        Ok(buf_cont.len())\n-                    } else if handle == -11 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n-                    res.ok().map(|n| u32::try_from(n).unwrap())\n-                } else {\n-                    throw_unsup_format!(\n-                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n-                    )\n-                };\n-                // We have to put the result into io_status_block.\n-                if let Some(n) = written {\n-                    let io_status_information =\n-                        this.mplace_field_named(&io_status_block, \"Information\")?;\n-                    this.write_scalar(\n-                        Scalar::from_target_usize(n.into(), this),\n-                        &io_status_information.into(),\n-                    )?;\n-                }\n-                // Return whether this was a success. >= 0 is success.\n-                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n-                this.write_scalar(\n-                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n-                    dest,\n-                )?;\n-            }\n             Dlsym::SetThreadDescription => {\n                 let [handle, name] = check_arg_count(args)?;\n "}, {"sha": "665c7ed438f3d1bf777f250398dfa7971481cff6", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8123eb49d4f222c84e243f18e77d01ba44aad578/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8123eb49d4f222c84e243f18e77d01ba44aad578/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=8123eb49d4f222c84e243f18e77d01ba44aad578", "patch": "@@ -69,6 +69,74 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.write_scalar(result, dest)?;\n             }\n \n+            // File related shims\n+            \"NtWriteFile\" => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n+                    );\n+                }\n+\n+                let [\n+                    handle,\n+                    _event,\n+                    _apc_routine,\n+                    _apc_context,\n+                    io_status_block,\n+                    buf,\n+                    n,\n+                    byte_offset,\n+                    _key,\n+                ] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let handle = this.read_target_isize(handle)?;\n+                let buf = this.read_pointer(buf)?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n+                let io_status_block = this.deref_operand(io_status_block)?;\n+\n+                if byte_offset != 0 {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n+                    );\n+                }\n+\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont =\n+                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if this.machine.mute_stdout_stderr {\n+                        Ok(buf_cont.len())\n+                    } else if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n+                    res.ok().map(|n| u32::try_from(n).unwrap())\n+                } else {\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n+                };\n+                // We have to put the result into io_status_block.\n+                if let Some(n) = written {\n+                    let io_status_information =\n+                        this.mplace_field_named(&io_status_block, \"Information\")?;\n+                    this.write_scalar(\n+                        Scalar::from_target_usize(n.into(), this),\n+                        &io_status_information.into(),\n+                    )?;\n+                }\n+                // Return whether this was a success. >= 0 is success.\n+                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n+                this.write_scalar(\n+                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n+                    dest,\n+                )?;\n+            }\n+\n             // Allocation\n             \"HeapAlloc\" => {\n                 let [handle, flags, size] ="}]}