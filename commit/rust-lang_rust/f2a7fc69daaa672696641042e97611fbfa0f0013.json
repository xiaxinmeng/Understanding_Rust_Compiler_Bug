{"sha": "f2a7fc69daaa672696641042e97611fbfa0f0013", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTdmYzY5ZGFhYTY3MjY5NjY0MTA0MmU5NzYxMWZiZmEwZjAwMTM=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-06-14T05:38:17Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-15T21:20:40Z"}, "message": "Fix Merge Fallout", "tree": {"sha": "22cca87779018f1b67a850a38a5c3586019fdd75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cca87779018f1b67a850a38a5c3586019fdd75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a7fc69daaa672696641042e97611fbfa0f0013", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a7fc69daaa672696641042e97611fbfa0f0013", "html_url": "https://github.com/rust-lang/rust/commit/f2a7fc69daaa672696641042e97611fbfa0f0013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a7fc69daaa672696641042e97611fbfa0f0013/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc908b772cc15a2c03167b33b373a418283c1618", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc908b772cc15a2c03167b33b373a418283c1618", "html_url": "https://github.com/rust-lang/rust/commit/cc908b772cc15a2c03167b33b373a418283c1618"}], "stats": {"total": 238, "additions": 119, "deletions": 119}, "files": [{"sha": "73347f2b91d61ba2cfa0045a71322a4e7cebef62", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -219,109 +219,109 @@ pub fn compile_rest(sess: Session,\n     crate = time(time_passes, ~\"intrinsic injection\", ||\n                  front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n-    crate = time(time_passes, ~\"extra injection\", ||\n-                 front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+        crate = time(time_passes, ~\"extra injection\", ||\n+                     front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    let ast_map = time(time_passes, ~\"ast indexing\", ||\n-                       syntax::ast_map::map_crate(sess.diagnostic(), crate));\n+        let ast_map = time(time_passes, ~\"ast indexing\", ||\n+                           syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-    time(time_passes, ~\"external crate/lib resolution\", ||\n-         creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n-                              sess.filesearch,\n-                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                              sess.opts.is_static,\n-                              token::get_ident_interner()));\n+        time(time_passes, ~\"external crate/lib resolution\", ||\n+             creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n+                                  sess.filesearch,\n+                                  session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                                  sess.opts.is_static,\n+                                  token::get_ident_interner()));\n \n-    let lang_items = time(time_passes, ~\"language item collection\", ||\n-                          middle::lang_items::collect_language_items(crate, sess));\n+        let lang_items = time(time_passes, ~\"language item collection\", ||\n+                              middle::lang_items::collect_language_items(crate, sess));\n \n-    let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map\n-    } =\n-        time(time_passes, ~\"resolution\", ||\n-             middle::resolve::resolve_crate(sess, lang_items, crate));\n+        let middle::resolve::CrateMap {\n+            def_map: def_map,\n+            exp_map2: exp_map2,\n+            trait_map: trait_map\n+        } =\n+            time(time_passes, ~\"resolution\", ||\n+                 middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-    time(time_passes, ~\"looking for entry point\",\n-         || middle::entry::find_entry_point(sess, crate, ast_map));\n+        time(time_passes, ~\"looking for entry point\",\n+             || middle::entry::find_entry_point(sess, crate, ast_map));\n \n-    let freevars = time(time_passes, ~\"freevar finding\", ||\n-                        freevars::annotate_freevars(def_map, crate));\n+        let freevars = time(time_passes, ~\"freevar finding\", ||\n+                            freevars::annotate_freevars(def_map, crate));\n \n-    let region_map = time(time_passes, ~\"region resolution\", ||\n-                          middle::region::resolve_crate(sess, def_map, crate));\n+        let region_map = time(time_passes, ~\"region resolution\", ||\n+                              middle::region::resolve_crate(sess, def_map, crate));\n \n-    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n-                      middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+        let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+                          middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, lang_items);\n+        let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                                region_map, rp_set, lang_items);\n \n-    // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(\n-        ty_cx, trait_map, crate);\n+        // passes are timed inside typeck\n+        let (method_map, vtable_map) = typeck::check_crate(\n+            ty_cx, trait_map, crate);\n \n-    // These next two const passes can probably be merged\n-    time(time_passes, ~\"const marking\", ||\n-         middle::const_eval::process_crate(crate, ty_cx));\n+        // These next two const passes can probably be merged\n+        time(time_passes, ~\"const marking\", ||\n+             middle::const_eval::process_crate(crate, ty_cx));\n \n-    time(time_passes, ~\"const checking\", ||\n-         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                          method_map, ty_cx));\n+        time(time_passes, ~\"const checking\", ||\n+             middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                              method_map, ty_cx));\n \n-    if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n \n-    time(time_passes, ~\"privacy checking\", ||\n-         middle::privacy::check_crate(ty_cx, &method_map, crate));\n+        time(time_passes, ~\"privacy checking\", ||\n+             middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n-    time(time_passes, ~\"effect checking\", ||\n-         middle::effect::check_crate(ty_cx, method_map, crate));\n+        time(time_passes, ~\"effect checking\", ||\n+             middle::effect::check_crate(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"loop checking\", ||\n-         middle::check_loop::check_crate(ty_cx, crate));\n+        time(time_passes, ~\"loop checking\", ||\n+             middle::check_loop::check_crate(ty_cx, crate));\n \n-    let middle::moves::MoveMaps {moves_map, moved_variables_set,\n-                                 capture_map} =\n-        time(time_passes, ~\"compute moves\", ||\n-             middle::moves::compute_moves(ty_cx, method_map, crate));\n+        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                     capture_map} =\n+            time(time_passes, ~\"compute moves\", ||\n+                 middle::moves::compute_moves(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"match checking\", ||\n-         middle::check_match::check_crate(ty_cx, method_map,\n-                                          moves_map, crate));\n+        time(time_passes, ~\"match checking\", ||\n+             middle::check_match::check_crate(ty_cx, method_map,\n+                                              moves_map, crate));\n \n-    time(time_passes, ~\"liveness checking\", ||\n-         middle::liveness::check_crate(ty_cx, method_map,\n-                                       capture_map, crate));\n-\n-    let (root_map, write_guard_map) =\n-        time(time_passes, ~\"borrow checking\", ||\n-             middle::borrowck::check_crate(ty_cx, method_map,\n-                                           moves_map, moved_variables_set,\n+        time(time_passes, ~\"liveness checking\", ||\n+             middle::liveness::check_crate(ty_cx, method_map,\n                                            capture_map, crate));\n \n-    time(time_passes, ~\"kind checking\", ||\n-         kind::check_crate(ty_cx, method_map, crate));\n+        let (root_map, write_guard_map) =\n+            time(time_passes, ~\"borrow checking\", ||\n+                 middle::borrowck::check_crate(ty_cx, method_map,\n+                                               moves_map, moved_variables_set,\n+                                               capture_map, crate));\n \n-    time(time_passes, ~\"lint checking\", ||\n-         lint::check_crate(ty_cx, crate));\n+        time(time_passes, ~\"kind checking\", ||\n+             kind::check_crate(ty_cx, method_map, crate));\n \n-    if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        time(time_passes, ~\"lint checking\", ||\n+             lint::check_crate(ty_cx, crate));\n \n-    let maps = astencode::Maps {\n-        root_map: root_map,\n-        method_map: method_map,\n-        vtable_map: vtable_map,\n-        write_guard_map: write_guard_map,\n-        moves_map: moves_map,\n-        capture_map: capture_map\n-    };\n+        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n \n-    let outputs = outputs.get_ref();\n-    time(time_passes, ~\"translation\", ||\n-         trans::base::trans_crate(sess, crate, ty_cx,\n-                                  &outputs.obj_filename,\n-                                  exp_map2, maps))\n+        let maps = astencode::Maps {\n+            root_map: root_map,\n+            method_map: method_map,\n+            vtable_map: vtable_map,\n+            write_guard_map: write_guard_map,\n+            moves_map: moves_map,\n+            capture_map: capture_map\n+        };\n+\n+        let outputs = outputs.get_ref();\n+        time(time_passes, ~\"translation\", ||\n+             trans::base::trans_crate(sess, crate, ty_cx,\n+                                      &outputs.obj_filename,\n+                                      exp_map2, maps))\n     };\n \n     let outputs = outputs.get_ref();"}, {"sha": "e2073d21fe3969a556d3f1e0acf0afd4d059f2f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -3114,20 +3114,10 @@ pub fn trans_crate(sess: session::Session,\n             io::println(fmt!(\"%-7u %s\", v, k));\n         }\n     }\n-    return (llmod, link_meta);\n-}\n-\n-fn task_local_llcx_key(_v: @ContextRef) {}\n+    let llcx = ccx.llcx;\n+    let link_meta = ccx.link_meta;\n+    let llmod = ccx.llmod;\n \n-pub fn task_llcx() -> ContextRef {\n-    let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n-    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n+    return (llcx, llmod, link_meta);\n }\n \n-unsafe fn set_task_llcx(c: ContextRef) {\n-    local_data::local_data_set(task_local_llcx_key, @c);\n-}\n-\n-unsafe fn unset_task_llcx() {\n-    local_data::local_data_pop(task_local_llcx_key);\n-}"}, {"sha": "0c771d21da5cef64fab00a7fed71d59f89342d1c", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -18,7 +18,7 @@ use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute};\n use lib::llvm::True;\n-use middle::trans::base::task_llcx;\n+use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n "}, {"sha": "75d7aaa88a6d0c81e616cd8e033a2d968b50f387", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -89,6 +89,8 @@ pub struct CrateContext {\n      // Cache of external const values\n      extern_const_values: HashMap<ast::def_id, ValueRef>,\n \n+     impl_method_cache: HashMap<(ast::def_id, ast::ident), ast::def_id>,\n+\n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, TypeRef>,\n      llsizingtypes: HashMap<ty::t, TypeRef>,\n@@ -178,6 +180,7 @@ impl CrateContext {\n                   const_globals: HashMap::new(),\n                   const_values: HashMap::new(),\n                   extern_const_values: HashMap::new(),\n+                  impl_method_cache: HashMap::new(),\n                   module_data: HashMap::new(),\n                   lltypes: HashMap::new(),\n                   llsizingtypes: HashMap::new(),\n@@ -244,4 +247,3 @@ unsafe fn set_task_llcx(c: ContextRef) {\n unsafe fn unset_task_llcx() {\n     local_data::local_data_pop(task_local_llcx_key);\n }\n-"}, {"sha": "7a8ebb4abfddfa03e22845cc3ebab8b63e850766", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n-use middle::trans::base::task_llcx;\n+use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;"}, {"sha": "c59b3f36779b789acaa41dd0233fe39407a569d1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a7fc69daaa672696641042e97611fbfa0f0013/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f2a7fc69daaa672696641042e97611fbfa0f0013", "patch": "@@ -381,36 +381,44 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n pub fn method_with_name_or_default(ccx: @mut CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n-    *do ccx.impl_method_cache.find_or_insert_with((impl_id, name)) |_| {\n-        if impl_id.crate == ast::local_crate {\n-            match ccx.tcx.items.get_copy(&impl_id.node) {\n-                ast_map::node_item(@ast::item {\n-                                   node: ast::item_impl(_, _, _, ref ms), _\n-                                   }, _) => {\n-                    let did = method_from_methods(*ms, name);\n-                    if did.is_some() {\n-                        did.get()\n-                    } else {\n-                        // Look for a default method\n-                        let pmm = ccx.tcx.provided_methods;\n-                        match pmm.find(&impl_id) {\n-                            Some(pmis) => {\n-                                for pmis.each |pmi| {\n-                                    if pmi.method_info.ident == name {\n-                                        debug!(\"pmi.method_info.did = %?\", pmi.method_info.did);\n-                                        return pmi.method_info.did;\n+    let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n+    match imp {\n+        Some(m) => m,\n+        None => {\n+            let imp = if impl_id.crate == ast::local_crate {\n+                match ccx.tcx.items.get_copy(&impl_id.node) {\n+                    ast_map::node_item(@ast::item {\n+                                       node: ast::item_impl(_, _, _, ref ms), _\n+                                       }, _) => {\n+                        let did = method_from_methods(*ms, name);\n+                        if did.is_some() {\n+                            did.get()\n+                        } else {\n+                            // Look for a default method\n+                            let pmm = ccx.tcx.provided_methods;\n+                            match pmm.find(&impl_id) {\n+                                Some(pmis) => {\n+                                    for pmis.each |pmi| {\n+                                        if pmi.method_info.ident == name {\n+                                            debug!(\"pmi.method_info.did = %?\", pmi.method_info.did);\n+                                            return pmi.method_info.did;\n+                                        }\n                                     }\n+                                    fail!()\n                                 }\n-                                fail!()\n+                                None => fail!()\n                             }\n-                            None => fail!()\n                         }\n                     }\n+                    _ => fail!(\"method_with_name\")\n                 }\n-                _ => fail!(\"method_with_name\")\n-            }\n-        } else {\n-            csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n+            } else {\n+                csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n+            };\n+\n+            ccx.impl_method_cache.insert((impl_id, name), imp);\n+\n+            imp\n         }\n     }\n }"}]}