{"sha": "87de9bd1088ec0f1a2e8893a517cde2005a546a0", "node_id": "C_kwDOAAsO6NoAKDg3ZGU5YmQxMDg4ZWMwZjFhMmU4ODkzYTUxN2NkZTIwMDVhNTQ2YTA", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-09-18T17:45:36Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-11-05T22:56:02Z"}, "message": "Prevent auto-application of associated functions with placeholders", "tree": {"sha": "224b1792f604cbaf3973372db498868d6e5bc7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/224b1792f604cbaf3973372db498868d6e5bc7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87de9bd1088ec0f1a2e8893a517cde2005a546a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87de9bd1088ec0f1a2e8893a517cde2005a546a0", "html_url": "https://github.com/rust-lang/rust/commit/87de9bd1088ec0f1a2e8893a517cde2005a546a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87de9bd1088ec0f1a2e8893a517cde2005a546a0/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "371100b1fb811e604f7451eff3b06960587fe1af", "url": "https://api.github.com/repos/rust-lang/rust/commits/371100b1fb811e604f7451eff3b06960587fe1af", "html_url": "https://github.com/rust-lang/rust/commit/371100b1fb811e604f7451eff3b06960587fe1af"}], "stats": {"total": 51, "additions": 34, "deletions": 17}, "files": [{"sha": "613acd3d705c54d6062d7d1d3170aed34d438c95", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/87de9bd1088ec0f1a2e8893a517cde2005a546a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87de9bd1088ec0f1a2e8893a517cde2005a546a0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=87de9bd1088ec0f1a2e8893a517cde2005a546a0", "patch": "@@ -18,7 +18,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, DefIdTree, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -392,28 +392,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n-                            // When the \"method\" is resolved through dereferencing, we really want the\n-                            // original type that has the associated function for accurate suggestions.\n-                            // (#61411)\n-                            let ty = tcx.at(span).type_of(*impl_did);\n-                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                    // Use `actual` as it will have more `substs` filled in.\n-                                    self.ty_to_value_string(actual.peel_refs())\n-                                }\n-                                _ => self.ty_to_value_string(ty.peel_refs()),\n+                    let (ty_str, placeholders) = if let Some(CandidateSource::Impl(impl_did)) =\n+                    static_candidates.get(0)\n+                    {\n+                        // When the \"method\" is resolved through dereferencing, we really want the\n+                        // original type that has the associated function for accurate suggestions.\n+                        // (#61411)\n+                        let ty = tcx.at(span).type_of(*impl_did);\n+                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n+                                // If there are any inferred arguments, (`{integer}`), we shouldn't mark\n+                                // this as machine-applicable.\n+                                let placeholders = substs\n+                                    .iter()\n+                                    .filter_map(|arg| {\n+                                        if let GenericArgKind::Type(ty) = arg.unpack() {\n+                                            Some(ty)\n+                                        } else {\n+                                            None\n+                                        }\n+                                    })\n+                                    .any(|ty| matches!(ty.kind(), ty::Infer(_)));\n+                                // Use `actual` as it will have more `substs` filled in.\n+                                (self.ty_to_value_string(actual.peel_refs()), placeholders)\n                             }\n-                        } else {\n-                            self.ty_to_value_string(actual.peel_refs())\n-                        };\n+                            _ => (self.ty_to_value_string(ty.peel_refs()), true),\n+                        }\n+                    } else {\n+                        (self.ty_to_value_string(actual.peel_refs()), true)\n+                    };\n+                    let applicability = match placeholders {\n+                        true => Applicability::HasPlaceholders,\n+                        false => Applicability::MachineApplicable,\n+                    };\n                     if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n                             expr.span.to(span),\n                             \"use associated function syntax instead\",\n                             format!(\"{}::{}\", ty_str, item_name),\n-                            Applicability::MachineApplicable,\n+                            applicability,\n                         );\n                     } else {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));"}]}