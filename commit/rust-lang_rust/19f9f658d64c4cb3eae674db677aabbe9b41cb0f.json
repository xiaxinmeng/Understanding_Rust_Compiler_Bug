{"sha": "19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "node_id": "C_kwDOAAsO6NoAKDE5ZjlmNjU4ZDY0YzRjYjNlYWU2NzRkYjY3N2FhYmJlOWI0MWNiMGY", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-04T00:12:19Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-04T00:17:39Z"}, "message": "rustdoc: migrate document functions to return a Display", "tree": {"sha": "9e7bd962afa7ed47cf250ac0dd386b0a7afa9d4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e7bd962afa7ed47cf250ac0dd386b0a7afa9d4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "html_url": "https://github.com/rust-lang/rust/commit/19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94faa5c7399202d9b3277e1851f34b3248675ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/94faa5c7399202d9b3277e1851f34b3248675ec8", "html_url": "https://github.com/rust-lang/rust/commit/94faa5c7399202d9b3277e1851f34b3248675ec8"}], "stats": {"total": 319, "additions": 169, "deletions": 150}, "files": [{"sha": "49986433dfbbb27721dca3abf0e82d57f524d73e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 140, "deletions": 124, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "patch": "@@ -70,7 +70,7 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    display_fn, href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n     print_default_space, print_generic_bounds, print_where_clause, visibility_print_with_space,\n     Buffer, Ending, HrefError, PrintWithSpace,\n };\n@@ -409,128 +409,134 @@ fn scrape_examples_help(shared: &SharedContext<'_>) -> String {\n     )\n }\n \n-fn document(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    item: &clean::Item,\n-    parent: Option<&clean::Item>,\n+fn document<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    item: &'a clean::Item,\n+    parent: Option<&'a clean::Item>,\n     heading_offset: HeadingOffset,\n-) {\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n-    document_item_info(cx, item, parent).render_into(w).unwrap();\n-    if parent.is_none() {\n-        document_full_collapsible(w, item, cx, heading_offset);\n-    } else {\n-        document_full(w, item, cx, heading_offset);\n-    }\n+\n+    display_fn(move |f| {\n+        document_item_info(cx, item, parent).render_into(f).unwrap();\n+        if parent.is_none() {\n+            write!(f, \"{}\", document_full_collapsible(item, cx, heading_offset))?;\n+        } else {\n+            write!(f, \"{}\", document_full(item, cx, heading_offset))?;\n+        }\n+        Ok(())\n+    })\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    md_text: &str,\n+fn render_markdown<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    md_text: &'a str,\n     links: Vec<RenderedLink>,\n     heading_offset: HeadingOffset,\n-) {\n-    write!(\n-        w,\n-        \"<div class=\\\"docblock\\\">{}</div>\",\n-        Markdown {\n-            content: md_text,\n-            links: &links,\n-            ids: &mut cx.id_map,\n-            error_codes: cx.shared.codes,\n-            edition: cx.shared.edition(),\n-            playground: &cx.shared.playground,\n-            heading_offset,\n-        }\n-        .into_string()\n-    )\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        write!(\n+            f,\n+            \"<div class=\\\"docblock\\\">{}</div>\",\n+            Markdown {\n+                content: md_text,\n+                links: &links,\n+                ids: &mut cx.id_map,\n+                error_codes: cx.shared.codes,\n+                edition: cx.shared.edition(),\n+                playground: &cx.shared.playground,\n+                heading_offset,\n+            }\n+            .into_string()\n+        )\n+    })\n }\n \n /// Writes a documentation block containing only the first paragraph of the documentation. If the\n /// docs are longer, a \"Read more\" link is appended to the end.\n-fn document_short(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n-    link: AssocItemLink<'_>,\n-    parent: &clean::Item,\n+fn document_short<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n+    link: AssocItemLink<'a>,\n+    parent: &'a clean::Item,\n     show_def_docs: bool,\n-) {\n-    document_item_info(cx, item, Some(parent)).render_into(w).unwrap();\n-    if !show_def_docs {\n-        return;\n-    }\n-    if let Some(s) = item.doc_value() {\n-        let (mut summary_html, has_more_content) =\n-            MarkdownSummaryLine(&s, &item.links(cx)).into_string_with_has_more_content();\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        document_item_info(cx, item, Some(parent)).render_into(f).unwrap();\n+        if !show_def_docs {\n+            return Ok(());\n+        }\n+        if let Some(s) = item.doc_value() {\n+            let (mut summary_html, has_more_content) =\n+                MarkdownSummaryLine(&s, &item.links(cx)).into_string_with_has_more_content();\n \n-        if has_more_content {\n-            let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n+            if has_more_content {\n+                let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n \n-            if let Some(idx) = summary_html.rfind(\"</p>\") {\n-                summary_html.insert_str(idx, &link);\n-            } else {\n-                summary_html.push_str(&link);\n+                if let Some(idx) = summary_html.rfind(\"</p>\") {\n+                    summary_html.insert_str(idx, &link);\n+                } else {\n+                    summary_html.push_str(&link);\n+                }\n             }\n-        }\n \n-        write!(w, \"<div class='docblock'>{}</div>\", summary_html,);\n-    }\n+            write!(f, \"<div class='docblock'>{}</div>\", summary_html)?;\n+        }\n+        Ok(())\n+    })\n }\n \n-fn document_full_collapsible(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full_collapsible<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     heading_offset: HeadingOffset,\n-) {\n-    document_full_inner(w, item, cx, true, heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    document_full_inner(item, cx, true, heading_offset)\n }\n \n-fn document_full(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     heading_offset: HeadingOffset,\n-) {\n-    document_full_inner(w, item, cx, false, heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    document_full_inner(item, cx, false, heading_offset)\n }\n \n-fn document_full_inner(\n-    w: &mut Buffer,\n-    item: &clean::Item,\n-    cx: &mut Context<'_>,\n+fn document_full_inner<'a, 'cx: 'a>(\n+    item: &'a clean::Item,\n+    cx: &'a mut Context<'cx>,\n     is_collapsible: bool,\n     heading_offset: HeadingOffset,\n-) {\n-    if let Some(s) = item.collapsed_doc_value() {\n-        debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        if is_collapsible {\n-            w.write_str(\n-                \"<details class=\\\"toggle top-doc\\\" open>\\\n-                <summary class=\\\"hideme\\\">\\\n-                     <span>Expand description</span>\\\n-                </summary>\",\n-            );\n-            render_markdown(w, cx, &s, item.links(cx), heading_offset);\n-            w.write_str(\"</details>\");\n-        } else {\n-            render_markdown(w, cx, &s, item.links(cx), heading_offset);\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |f| {\n+        if let Some(s) = item.collapsed_doc_value() {\n+            debug!(\"Doc block: =====\\n{}\\n=====\", s);\n+            if is_collapsible {\n+                write!(\n+                    f,\n+                    \"<details class=\\\"toggle top-doc\\\" open>\\\n+                    <summary class=\\\"hideme\\\">\\\n+                        <span>Expand description</span>\\\n+                    </summary>{}</details>\",\n+                    render_markdown(cx, &s, item.links(cx), heading_offset)\n+                )?;\n+            } else {\n+                write!(f, \"{}\", render_markdown(cx, &s, item.links(cx), heading_offset))?;\n+            }\n         }\n-    }\n \n-    let kind = match &*item.kind {\n-        clean::ItemKind::StrippedItem(box kind) | kind => kind,\n-    };\n+        let kind = match &*item.kind {\n+            clean::ItemKind::StrippedItem(box kind) | kind => kind,\n+        };\n \n-    if let clean::ItemKind::FunctionItem(..) | clean::ItemKind::MethodItem(..) = kind {\n-        render_call_locations(w, cx, item);\n-    }\n+        if let clean::ItemKind::FunctionItem(..) | clean::ItemKind::MethodItem(..) = kind {\n+            render_call_locations(f, cx, item);\n+        }\n+        Ok(())\n+    })\n }\n \n #[derive(Template)]\n@@ -1485,18 +1491,25 @@ fn render_impl(\n                             document_item_info(cx, it, Some(parent))\n                                 .render_into(&mut info_buffer)\n                                 .unwrap();\n-                            document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n+                            write!(\n+                                &mut doc_buffer,\n+                                \"{}\",\n+                                document_full(item, cx, HeadingOffset::H5)\n+                            );\n                             short_documented = false;\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(\n+                            write!(\n                                 &mut doc_buffer,\n-                                it,\n-                                cx,\n-                                link,\n-                                parent,\n-                                rendering_params.show_def_docs,\n+                                \"{}\",\n+                                document_short(\n+                                    it,\n+                                    cx,\n+                                    link,\n+                                    parent,\n+                                    rendering_params.show_def_docs,\n+                                )\n                             );\n                         }\n                     }\n@@ -1505,18 +1518,15 @@ fn render_impl(\n                         .render_into(&mut info_buffer)\n                         .unwrap();\n                     if rendering_params.show_def_docs {\n-                        document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n+                        write!(&mut doc_buffer, \"{}\", document_full(item, cx, HeadingOffset::H5));\n                         short_documented = false;\n                     }\n                 }\n             } else {\n-                document_short(\n+                write!(\n                     &mut doc_buffer,\n-                    item,\n-                    cx,\n-                    link,\n-                    parent,\n-                    rendering_params.show_def_docs,\n+                    \"{}\",\n+                    document_short(item, cx, link, parent, rendering_params.show_def_docs,)\n                 );\n             }\n         }\n@@ -2213,7 +2223,7 @@ const MAX_FULL_EXAMPLES: usize = 5;\n const NUM_VISIBLE_LINES: usize = 10;\n \n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n-fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item) {\n+fn render_call_locations<W: fmt::Write>(mut w: W, cx: &mut Context<'_>, item: &clean::Item) {\n     let tcx = cx.tcx();\n     let def_id = item.item_id.expect_def_id();\n     let key = tcx.def_path_hash(def_id);\n@@ -2222,7 +2232,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     // Generate a unique ID so users can link to this section for a given method\n     let id = cx.id_map.derive(\"scraped-examples\");\n     write!(\n-        w,\n+        &mut w,\n         \"<div class=\\\"docblock scraped-example-list\\\">\\\n           <span></span>\\\n           <h5 id=\\\"{id}\\\">\\\n@@ -2231,7 +2241,8 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n           </h5>\",\n         root_path = cx.root_path(),\n         id = id\n-    );\n+    )\n+    .unwrap();\n \n     // Create a URL to a particular location in a reverse-dependency's source file\n     let link_to_loc = |call_data: &CallData, loc: &CallLocation| -> (String, String) {\n@@ -2249,7 +2260,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     };\n \n     // Generate the HTML for a single example, being the title and code block\n-    let write_example = |w: &mut Buffer, (path, call_data): (&PathBuf, &CallData)| -> bool {\n+    let write_example = |mut w: &mut W, (path, call_data): (&PathBuf, &CallData)| -> bool {\n         let contents = match fs::read_to_string(&path) {\n             Ok(contents) => contents,\n             Err(err) => {\n@@ -2297,7 +2308,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n         let locations_encoded = serde_json::to_string(&line_ranges).unwrap();\n \n         write!(\n-            w,\n+            &mut w,\n             \"<div class=\\\"scraped-example {expanded_cls}\\\" data-locs=\\\"{locations}\\\">\\\n                 <div class=\\\"scraped-example-title\\\">\\\n                    {name} (<a href=\\\"{url}\\\">{title}</a>)\\\n@@ -2310,10 +2321,12 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n             // The locations are encoded as a data attribute, so they can be read\n             // later by the JS for interactions.\n             locations = Escape(&locations_encoded)\n-        );\n+        )\n+        .unwrap();\n \n         if line_ranges.len() > 1 {\n-            write!(w, r#\"<button class=\"prev\">&pr;</button> <button class=\"next\">&sc;</button>\"#);\n+            write!(w, r#\"<button class=\"prev\">&pr;</button> <button class=\"next\">&sc;</button>\"#)\n+                .unwrap();\n         }\n \n         // Look for the example file in the source map if it exists, otherwise return a dummy span\n@@ -2340,15 +2353,15 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n         decoration_info.insert(\"highlight\", byte_ranges);\n \n         sources::print_src(\n-            w,\n+            &mut w,\n             contents_subset,\n             file_span,\n             cx,\n             &cx.root_path(),\n             highlight::DecorationInfo(decoration_info),\n             sources::SourceContext::Embedded { offset: line_min, needs_expansion },\n         );\n-        write!(w, \"</div></div>\");\n+        write!(w, \"</div></div>\").unwrap();\n \n         true\n     };\n@@ -2382,7 +2395,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n \n     // An example may fail to write if its source can't be read for some reason, so this method\n     // continues iterating until a write succeeds\n-    let write_and_skip_failure = |w: &mut Buffer, it: &mut Peekable<_>| {\n+    let write_and_skip_failure = |w: &mut W, it: &mut Peekable<_>| {\n         while let Some(example) = it.next() {\n             if write_example(&mut *w, example) {\n                 break;\n@@ -2391,7 +2404,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n     };\n \n     // Write just one example that's visible by default in the method's description.\n-    write_and_skip_failure(w, &mut it);\n+    write_and_skip_failure(&mut w, &mut it);\n \n     // Then add the remaining examples in a hidden section.\n     if it.peek().is_some() {\n@@ -2404,31 +2417,34 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n                   <div class=\\\"hide-more\\\">Hide additional examples</div>\\\n                   <div class=\\\"more-scraped-examples\\\">\\\n                     <div class=\\\"toggle-line\\\"><div class=\\\"toggle-line-inner\\\"></div></div>\"\n-        );\n+        )\n+        .unwrap();\n \n         // Only generate inline code for MAX_FULL_EXAMPLES number of examples. Otherwise we could\n         // make the page arbitrarily huge!\n         for _ in 0..MAX_FULL_EXAMPLES {\n-            write_and_skip_failure(w, &mut it);\n+            write_and_skip_failure(&mut w, &mut it);\n         }\n \n         // For the remaining examples, generate a <ul> containing links to the source files.\n         if it.peek().is_some() {\n-            write!(w, r#\"<div class=\"example-links\">Additional examples can be found in:<br><ul>\"#);\n+            write!(w, r#\"<div class=\"example-links\">Additional examples can be found in:<br><ul>\"#)\n+                .unwrap();\n             it.for_each(|(_, call_data)| {\n                 let (url, _) = link_to_loc(call_data, &call_data.locations[0]);\n                 write!(\n                     w,\n                     r#\"<li><a href=\"{url}\">{name}</a></li>\"#,\n                     url = url,\n                     name = call_data.display_name\n-                );\n+                )\n+                .unwrap();\n             });\n-            write!(w, \"</ul></div>\");\n+            write!(w, \"</ul></div>\").unwrap();\n         }\n \n-        write!(w, \"</div></details>\");\n+        write!(w, \"</div></details>\").unwrap();\n     }\n \n-    write!(w, \"</div>\");\n+    write!(w, \"</div>\").unwrap();\n }"}, {"sha": "ea53f8d107dcd36fcf16ee3a0d3187705974aad1", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "patch": "@@ -218,7 +218,7 @@ fn toggle_close(w: &mut Buffer) {\n }\n \n fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n-    document(w, cx, item, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, item, None, HeadingOffset::H2));\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n \n@@ -562,7 +562,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n             notable_traits = notable_traits.unwrap_or_default(),\n         );\n     });\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n }\n \n fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {\n@@ -717,7 +717,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     });\n \n     // Trait documentation\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     fn write_small_section_header(w: &mut Buffer, id: &str, title: &str, extra_content: &str) {\n         write!(\n@@ -735,7 +735,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         let mut content = Buffer::empty_from(w);\n-        document(&mut content, cx, m, Some(t), HeadingOffset::H5);\n+        write!(&mut content, \"{}\", document(cx, m, Some(t), HeadingOffset::H5));\n         let toggled = !content.is_empty();\n         if toggled {\n             let method_toggle_class = if item_type.is_method() { \" method-toggle\" } else { \"\" };\n@@ -1068,7 +1068,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -1090,7 +1090,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &cl\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -1117,7 +1117,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n \n     write_content(w, cx, it, t);\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n@@ -1134,7 +1134,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n         render_union(w, it, Some(&s.generics), &s.fields, cx);\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let mut fields = s\n         .fields\n@@ -1166,7 +1166,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n                 write!(w, \"<span class=\\\"stab {stability_class}\\\"></span>\");\n             }\n-            document(w, cx, field, Some(it), HeadingOffset::H3);\n+            write!(w, \"{}\", document(cx, field, Some(it), HeadingOffset::H3));\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n@@ -1248,7 +1248,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         }\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     if count_variants != 0 {\n         write!(\n@@ -1324,18 +1324,21 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                      <code>{f}: {t}</code>\\\n                                  </span>\",\n                                 f = field.name.unwrap(),\n-                                t = ty.print(cx)\n+                                t = ty.print(cx),\n+                            );\n+                            write!(\n+                                w,\n+                                \"{}</div>\",\n+                                document(cx, field, Some(variant), HeadingOffset::H5)\n                             );\n-                            document(w, cx, field, Some(variant), HeadingOffset::H5);\n-                            write!(w, \"</div>\");\n                         }\n                         _ => unreachable!(),\n                     }\n                 }\n                 w.write_str(\"</div>\");\n             }\n \n-            document(w, cx, variant, Some(it), HeadingOffset::H4);\n+            write!(w, \"{}\", document(cx, variant, Some(it), HeadingOffset::H4));\n         }\n         write!(w, \"</div>\");\n     }\n@@ -1346,7 +1349,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n \n fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Macro) {\n     highlight::render_item_decl_with_highlighting(&t.source, w);\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n@@ -1372,12 +1375,12 @@ fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &c\n             }\n         }\n     });\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     let def_id = it.item_id.expect_def_id();\n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n         render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     } else {\n@@ -1435,7 +1438,7 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n         }\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Struct) {\n@@ -1444,7 +1447,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         render_struct(w, it, Some(&s.generics), s.ctor_kind, &s.fields, \"\", true, cx);\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let mut fields = s\n         .fields\n@@ -1478,7 +1481,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                     item_type = ItemType::StructField,\n                     ty = ty.print(cx)\n                 );\n-                document(w, cx, field, Some(it), HeadingOffset::H3);\n+                write!(w, \"{}\", document(cx, field, Some(it), HeadingOffset::H3));\n             }\n         }\n     }\n@@ -1499,7 +1502,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             typ = s.type_.print(cx)\n         );\n     });\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n@@ -1514,13 +1517,13 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n         );\n     });\n \n-    document(w, cx, it, None, HeadingOffset::H2);\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n-    document(w, cx, it, None, HeadingOffset::H2)\n+    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order)."}, {"sha": "c8397967c879108bde00a81501140816217bede5", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f9f658d64c4cb3eae674db677aabbe9b41cb0f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "patch": "@@ -2,7 +2,6 @@ use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n use crate::html::format;\n-use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::Context;\n@@ -17,6 +16,7 @@ use rustc_span::source_map::FileName;\n \n use std::cell::RefCell;\n use std::ffi::OsStr;\n+use std::fmt;\n use std::fs;\n use std::ops::RangeInclusive;\n use std::path::{Component, Path, PathBuf};\n@@ -294,7 +294,7 @@ pub(crate) enum SourceContext {\n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n pub(crate) fn print_src(\n-    buf: &mut Buffer,\n+    mut writer: impl fmt::Write,\n     s: &str,\n     file_span: rustc_span::Span,\n     context: &Context<'_>,\n@@ -329,5 +329,5 @@ pub(crate) fn print_src(\n         );\n         Ok(())\n     });\n-    Source { embedded, needs_expansion, lines, code_html: code }.render_into(buf).unwrap();\n+    Source { embedded, needs_expansion, lines, code_html: code }.render_into(&mut writer).unwrap();\n }"}]}