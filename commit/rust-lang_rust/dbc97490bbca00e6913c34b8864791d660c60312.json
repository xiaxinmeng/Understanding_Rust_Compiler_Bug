{"sha": "dbc97490bbca00e6913c34b8864791d660c60312", "node_id": "C_kwDOAAsO6NoAKGRiYzk3NDkwYmJjYTAwZTY5MTNjMzRiODg2NDc5MWQ2NjBjNjAzMTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-20T16:10:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-20T16:10:43Z"}, "message": "Rollup merge of #93112 - pietroalbini:pa-cve-2022-21658-nightly, r=pietroalbini\n\nFix CVE-2022-21658\n\nSee https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html. Patches reviewed by `@m-ou-se.`\n\nr? `@ghost`", "tree": {"sha": "82f458e6da62ec8cd4baa7cf5c1b4c2eed5f3cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82f458e6da62ec8cd4baa7cf5c1b4c2eed5f3cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc97490bbca00e6913c34b8864791d660c60312", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6YmDCRBK7hj4Ov3rIwAA/00IAIoyzDmXfWhD1ihAOz2JiHBp\nFstIJCrcX0eYIB02bBFqC4CurldOpS5/zcKqnBLfYrMZ+pbIfP1C7Xr5h9xBFaXx\nr9S2tp9WiA69safTBSS+JLl+el2AHM3vknnhKCmr6TErGsDXenDIaPg/VNr3SDBP\n6zwlX8vJAhdL7TM0wAo00cn61UztkURVyy1zc+e5qPtSRfQYr0G7KdoUVUs+7wKl\n0UICMm3VnYulLBu1ruuuATCl+shrYQ6yhLpW8p758bqMCtWLZmlSg1rMGoOhQ4Pm\nPO6oQ0hODBbAcZVODA03GHFZjZD6aKkTcFexiHnIOXW2bQSEt/9oYrQ/duIv0hE=\n=OxvQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 82f458e6da62ec8cd4baa7cf5c1b4c2eed5f3cc5\nparent d893b0ab323c6b17b6a00ee713b9ab478cc8a3fd\nparent 0a6c9adc4a09d6c34437a57e83adf78b2ad1e7db\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642695043 +0100\ncommitter GitHub <noreply@github.com> 1642695043 +0100\n\nRollup merge of #93112 - pietroalbini:pa-cve-2022-21658-nightly, r=pietroalbini\n\nFix CVE-2022-21658\n\nSee https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html. Patches reviewed by `@m-ou-se.`\n\nr? `@ghost`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc97490bbca00e6913c34b8864791d660c60312", "html_url": "https://github.com/rust-lang/rust/commit/dbc97490bbca00e6913c34b8864791d660c60312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc97490bbca00e6913c34b8864791d660c60312/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d893b0ab323c6b17b6a00ee713b9ab478cc8a3fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d893b0ab323c6b17b6a00ee713b9ab478cc8a3fd", "html_url": "https://github.com/rust-lang/rust/commit/d893b0ab323c6b17b6a00ee713b9ab478cc8a3fd"}, {"sha": "0a6c9adc4a09d6c34437a57e83adf78b2ad1e7db", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6c9adc4a09d6c34437a57e83adf78b2ad1e7db", "html_url": "https://github.com/rust-lang/rust/commit/0a6c9adc4a09d6c34437a57e83adf78b2ad1e7db"}], "stats": {"total": 890, "additions": 838, "deletions": 52}, "files": [{"sha": "9d6b2fe8c25d845b9811385c57fa3b7f3f79a4a5", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -2042,13 +2042,17 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// # Platform-specific behavior\n ///\n-/// This function currently corresponds to `opendir`, `lstat`, `rm` and `rmdir` functions on Unix\n-/// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n-/// on Windows.\n-/// Note that, this [may change in the future][changes].\n+/// This function currently corresponds to `openat`, `fdopendir`, `unlinkat` and `lstat` functions\n+/// on Unix (except for macOS before version 10.10 and REDOX) and the `CreateFileW`,\n+/// `GetFileInformationByHandleEx`, `SetFileInformationByHandle`, and `NtOpenFile` functions on\n+/// Windows. Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior\n ///\n+/// On macOS before version 10.10 and REDOX this function is not protected against time-of-check to\n+/// time-of-use (TOCTOU) race conditions, and should not be used in security-sensitive code on\n+/// those platforms. All other platforms are protected.\n+///\n /// # Errors\n ///\n /// See [`fs::remove_file`] and [`fs::remove_dir`]."}, {"sha": "a62c01ef29b27d59407dec2c1f6410fa657d17d7", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -4,8 +4,10 @@ use crate::fs::{self, File, OpenOptions};\n use crate::io::{ErrorKind, SeekFrom};\n use crate::path::Path;\n use crate::str;\n+use crate::sync::Arc;\n use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n+use crate::time::{Duration, Instant};\n \n use rand::{rngs::StdRng, RngCore, SeedableRng};\n \n@@ -601,6 +603,21 @@ fn recursive_rmdir_of_symlink() {\n     assert!(canary.exists());\n }\n \n+#[test]\n+fn recursive_rmdir_of_file_fails() {\n+    // test we do not delete a directly specified file.\n+    let tmpdir = tmpdir();\n+    let canary = tmpdir.join(\"do_not_delete\");\n+    check!(check!(File::create(&canary)).write(b\"foo\"));\n+    let result = fs::remove_dir_all(&canary);\n+    #[cfg(unix)]\n+    error!(result, \"Not a directory\");\n+    #[cfg(windows)]\n+    error!(result, 267); // ERROR_DIRECTORY - The directory name is invalid.\n+    assert!(result.is_err());\n+    assert!(canary.exists());\n+}\n+\n #[test]\n // only Windows makes a distinction between file and directory symlinks.\n #[cfg(windows)]\n@@ -620,6 +637,59 @@ fn recursive_rmdir_of_file_symlink() {\n     }\n }\n \n+#[test]\n+#[ignore] // takes too much time\n+fn recursive_rmdir_toctou() {\n+    // Test for time-of-check to time-of-use issues.\n+    //\n+    // Scenario:\n+    // The attacker wants to get directory contents deleted, to which he does not have access.\n+    // He has a way to get a privileged Rust binary call `std::fs::remove_dir_all()` on a\n+    // directory he controls, e.g. in his home directory.\n+    //\n+    // The POC sets up the `attack_dest/attack_file` which the attacker wants to have deleted.\n+    // The attacker repeatedly creates a directory and replaces it with a symlink from\n+    // `victim_del` to `attack_dest` while the victim code calls `std::fs::remove_dir_all()`\n+    // on `victim_del`. After a few seconds the attack has succeeded and\n+    // `attack_dest/attack_file` is deleted.\n+    let tmpdir = tmpdir();\n+    let victim_del_path = tmpdir.join(\"victim_del\");\n+    let victim_del_path_clone = victim_del_path.clone();\n+\n+    // setup dest\n+    let attack_dest_dir = tmpdir.join(\"attack_dest\");\n+    let attack_dest_dir = attack_dest_dir.as_path();\n+    fs::create_dir(attack_dest_dir).unwrap();\n+    let attack_dest_file = tmpdir.join(\"attack_dest/attack_file\");\n+    File::create(&attack_dest_file).unwrap();\n+\n+    let drop_canary_arc = Arc::new(());\n+    let drop_canary_weak = Arc::downgrade(&drop_canary_arc);\n+\n+    eprintln!(\"x: {:?}\", &victim_del_path);\n+\n+    // victim just continuously removes `victim_del`\n+    thread::spawn(move || {\n+        while drop_canary_weak.upgrade().is_some() {\n+            let _ = fs::remove_dir_all(&victim_del_path_clone);\n+        }\n+    });\n+\n+    // attacker (could of course be in a separate process)\n+    let start_time = Instant::now();\n+    while Instant::now().duration_since(start_time) < Duration::from_secs(1000) {\n+        if !attack_dest_file.exists() {\n+            panic!(\n+                \"Victim deleted symlinked file outside of victim_del. Attack succeeded in {:?}.\",\n+                Instant::now().duration_since(start_time)\n+            );\n+        }\n+        let _ = fs::create_dir(&victim_del_path);\n+        let _ = fs::remove_dir(&victim_del_path);\n+        let _ = symlink_dir(attack_dest_dir, &victim_del_path);\n+    }\n+}\n+\n #[test]\n fn unicode_path_is_dir() {\n     assert!(Path::new(\".\").is_dir());"}, {"sha": "f8deda93fe2a7797d91fa53e15472395bdebca02", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 274, "deletions": 11, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -64,7 +64,7 @@ use libc::{\n     dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n };\n \n-pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n+pub use crate::sys_common::fs::try_exists;\n \n pub struct File(FileDesc);\n \n@@ -228,7 +228,7 @@ pub struct DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n-    name: Box<[u8]>,\n+    name: CString,\n }\n \n #[derive(Clone, Debug)]\n@@ -455,8 +455,6 @@ impl Iterator for ReadDir {\n         target_os = \"illumos\"\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        use crate::slice;\n-\n         unsafe {\n             loop {\n                 // Although readdir_r(3) would be a correct function to use here because\n@@ -474,14 +472,10 @@ impl Iterator for ReadDir {\n                     };\n                 }\n \n-                let name = (*entry_ptr).d_name.as_ptr();\n-                let namelen = libc::strlen(name) as usize;\n-\n                 let ret = DirEntry {\n                     entry: *entry_ptr,\n-                    name: slice::from_raw_parts(name as *const u8, namelen as usize)\n-                        .to_owned()\n-                        .into_boxed_slice(),\n+                    // d_name is guaranteed to be null-terminated.\n+                    name: CStr::from_ptr((*entry_ptr).d_name.as_ptr()).to_owned(),\n                     dir: Arc::clone(&self.inner),\n                 };\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n@@ -664,7 +658,21 @@ impl DirEntry {\n         target_os = \"redox\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n-        &*self.name\n+        self.name.as_bytes()\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"fuchsia\",\n+        target_os = \"redox\"\n+    )))]\n+    fn name_cstr(&self) -> &CStr {\n+        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n+    }\n+    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"fuchsia\"))]\n+    fn name_cstr(&self) -> &CStr {\n+        &self.name\n     }\n \n     pub fn file_name_os_str(&self) -> &OsStr {\n@@ -1437,3 +1445,258 @@ pub fn chroot(dir: &Path) -> io::Result<()> {\n     cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n     Ok(())\n }\n+\n+pub use remove_dir_impl::remove_dir_all;\n+\n+// Fallback for REDOX\n+#[cfg(target_os = \"redox\")]\n+mod remove_dir_impl {\n+    pub use crate::sys_common::fs::remove_dir_all;\n+}\n+\n+// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n+#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::weak::weak;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{c_char, c_int, DIR};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        let fd = cvt_r(|| unsafe {\n+            openat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n+        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match child.entry.d_type {\n+                libc::DT_DIR => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                libc::DT_UNKNOWN => {\n+                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n+                    {\n+                        // type unknown - try to unlink\n+                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n+                            // if the file is a directory unlink fails with EPERM\n+                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                        }\n+                        result => {\n+                            result?;\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // not a directory -> unlink\n+                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                pcstr.as_ptr(),\n+                libc::AT_REMOVEDIR,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        if openat.get().is_some() {\n+            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n+            remove_dir_all_modern(p)\n+        } else {\n+            // fall back to classic implementation\n+            crate::sys_common::fs::remove_dir_all(p)\n+        }\n+    }\n+}\n+\n+// Modern implementation using openat(), unlinkat() and fdopendir()\n+#[cfg(not(any(all(target_os = \"macos\", target_arch = \"x86_64\"), target_os = \"redox\")))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{fdopendir, openat, unlinkat};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        let fd = cvt_r(|| unsafe {\n+            openat(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        let ptr = unsafe { fdopendir(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                #[cfg(not(any(\n+                    target_os = \"solaris\",\n+                    target_os = \"illumos\",\n+                    target_os = \"fuchsia\",\n+                    target_os = \"redox\",\n+                )))]\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\",\n+        target_os = \"fuchsia\"\n+    ))]\n+    fn is_dir(_ent: &DirEntry) -> Option<bool> {\n+        None\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\",\n+        target_os = \"fuchsia\"\n+    )))]\n+    fn is_dir(ent: &DirEntry) -> Option<bool> {\n+        match ent.entry.d_type {\n+            libc::DT_UNKNOWN => None,\n+            libc::DT_DIR => Some(true),\n+            _ => Some(false),\n+        }\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match is_dir(&child) {\n+                Some(true) => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                Some(false) => {\n+                    cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+                None => match cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) }) {\n+                    // type unknown - try to unlink\n+                    Err(err)\n+                        if err.raw_os_error() == Some(libc::EISDIR)\n+                            || err.raw_os_error() == Some(libc::EPERM) =>\n+                    {\n+                        // if the file is a directory unlink fails with EISDIR on Linux and EPERM everyhwere else\n+                        remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    }\n+                    result => {\n+                        result?;\n+                    }\n+                },\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), pcstr.as_ptr(), libc::AT_REMOVEDIR)\n+        })?;\n+        Ok(())\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+}"}, {"sha": "da63c068384a2b56a4926360db10c4213646d616", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -73,12 +73,14 @@ impl<F> ExternWeak<F> {\n \n pub(crate) macro dlsym {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+         dlsym!(fn $name($($t),*) -> $ret, stringify!($name));\n+    ),\n+    (fn $name:ident($($t:ty),*) -> $ret:ty, $sym:expr) => (\n         static DLSYM: DlsymWeak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n-            DlsymWeak::new(concat!(stringify!($name), '\\0'));\n+            DlsymWeak::new(concat!($sym, '\\0'));\n         let $name = &DLSYM;\n     )\n }\n-\n pub(crate) struct DlsymWeak<F> {\n     name: &'static str,\n     addr: AtomicUsize,"}, {"sha": "5924789d12ba40bb75ef46e06d0efd187b380712", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -16,7 +16,7 @@ use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n-pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n+pub use crate::sys_common::fs::try_exists;\n \n pub struct File {\n     fd: WasiFd,\n@@ -130,6 +130,18 @@ impl FileType {\n     }\n }\n \n+impl ReadDir {\n+    fn new(dir: File, root: PathBuf) -> ReadDir {\n+        ReadDir {\n+            cookie: Some(0),\n+            buf: vec![0; 128],\n+            offset: 0,\n+            cap: 0,\n+            inner: Arc::new(ReadDirInner { dir, root }),\n+        }\n+    }\n+}\n+\n impl fmt::Debug for ReadDir {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"ReadDir\").finish_non_exhaustive()\n@@ -516,13 +528,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     opts.directory(true);\n     opts.read(true);\n     let dir = File::open(p, &opts)?;\n-    Ok(ReadDir {\n-        cookie: Some(0),\n-        buf: vec![0; 128],\n-        offset: 0,\n-        cap: 0,\n-        inner: Arc::new(ReadDirInner { dir, root: p.to_path_buf() }),\n-    })\n+    Ok(ReadDir::new(dir, p.to_path_buf()))\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n@@ -716,3 +722,52 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n     io::copy(&mut reader, &mut writer)\n }\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let (parent, path) = open_parent(path)?;\n+    remove_dir_all_recursive(&parent, &path)\n+}\n+\n+fn remove_dir_all_recursive(parent: &WasiFd, path: &Path) -> io::Result<()> {\n+    // Open up a file descriptor for the directory itself. Note that we don't\n+    // follow symlinks here and we specifically open directories.\n+    //\n+    // At the root invocation of this function this will correctly handle\n+    // symlinks passed to the top-level `remove_dir_all`. At the recursive\n+    // level this will double-check that after the `readdir` call deduced this\n+    // was a directory it's still a directory by the time we open it up.\n+    //\n+    // If the opened file was actually a symlink then the symlink is deleted,\n+    // not the directory recursively.\n+    let mut opts = OpenOptions::new();\n+    opts.lookup_flags(0);\n+    opts.directory(true);\n+    opts.read(true);\n+    let fd = open_at(parent, path, &opts)?;\n+    if fd.file_attr()?.file_type().is_symlink() {\n+        return parent.unlink_file(osstr2str(path.as_ref())?);\n+    }\n+\n+    // this \"root\" is only used by `DirEntry::path` which we don't use below so\n+    // it's ok for this to be a bogus value\n+    let dummy_root = PathBuf::new();\n+\n+    // Iterate over all the entries in this directory, and travel recursively if\n+    // necessary\n+    for entry in ReadDir::new(fd, dummy_root) {\n+        let entry = entry?;\n+        let path = crate::str::from_utf8(&entry.name).map_err(|_| {\n+            io::Error::new_const(io::ErrorKind::Uncategorized, &\"invalid utf-8 file name found\")\n+        })?;\n+\n+        if entry.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&entry.inner.dir.fd, path.as_ref())?;\n+        } else {\n+            entry.inner.dir.fd.unlink_file(path)?;\n+        }\n+    }\n+\n+    // Once all this directory's contents are deleted it should be safe to\n+    // delete the directory tiself.\n+    parent.remove_directory(osstr2str(path.as_ref())?)\n+}"}, {"sha": "09d3661e4fd52d0b961f5e8fcaf898a3fe21ef71", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n+use crate::mem;\n use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n@@ -36,6 +37,7 @@ pub type USHORT = c_ushort;\n pub type SIZE_T = usize;\n pub type WORD = u16;\n pub type CHAR = c_char;\n+pub type CCHAR = c_char;\n pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n pub type NTSTATUS = LONG;\n@@ -86,16 +88,21 @@ pub const FILE_SHARE_DELETE: DWORD = 0x4;\n pub const FILE_SHARE_READ: DWORD = 0x1;\n pub const FILE_SHARE_WRITE: DWORD = 0x2;\n \n+pub const FILE_OPEN_REPARSE_POINT: ULONG = 0x200000;\n+pub const OBJ_DONT_REPARSE: ULONG = 0x1000;\n+\n pub const CREATE_ALWAYS: DWORD = 2;\n pub const CREATE_NEW: DWORD = 1;\n pub const OPEN_ALWAYS: DWORD = 4;\n pub const OPEN_EXISTING: DWORD = 3;\n pub const TRUNCATE_EXISTING: DWORD = 5;\n \n+pub const FILE_LIST_DIRECTORY: DWORD = 0x1;\n pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n pub const FILE_WRITE_EA: DWORD = 0x00000010;\n pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const DELETE: DWORD = 0x10000;\n pub const READ_CONTROL: DWORD = 0x00020000;\n pub const SYNCHRONIZE: DWORD = 0x00100000;\n pub const GENERIC_READ: DWORD = 0x80000000;\n@@ -261,9 +268,61 @@ pub const FD_SETSIZE: usize = 64;\n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n+pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n+pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n+\n+// Equivalent to the `NT_SUCCESS` C preprocessor macro.\n+// See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n+pub fn nt_success(status: NTSTATUS) -> bool {\n+    status >= 0\n+}\n \n pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n \n+#[repr(C)]\n+pub struct UNICODE_STRING {\n+    pub Length: u16,\n+    pub MaximumLength: u16,\n+    pub Buffer: *mut u16,\n+}\n+impl UNICODE_STRING {\n+    pub fn from_ref(slice: &[u16]) -> Self {\n+        let len = slice.len() * mem::size_of::<u16>();\n+        Self { Length: len as _, MaximumLength: len as _, Buffer: slice.as_ptr() as _ }\n+    }\n+}\n+#[repr(C)]\n+pub struct OBJECT_ATTRIBUTES {\n+    pub Length: ULONG,\n+    pub RootDirectory: HANDLE,\n+    pub ObjectName: *const UNICODE_STRING,\n+    pub Attributes: ULONG,\n+    pub SecurityDescriptor: *mut c_void,\n+    pub SecurityQualityOfService: *mut c_void,\n+}\n+impl Default for OBJECT_ATTRIBUTES {\n+    fn default() -> Self {\n+        Self {\n+            Length: mem::size_of::<Self>() as _,\n+            RootDirectory: ptr::null_mut(),\n+            ObjectName: ptr::null_mut(),\n+            Attributes: 0,\n+            SecurityDescriptor: ptr::null_mut(),\n+            SecurityQualityOfService: ptr::null_mut(),\n+        }\n+    }\n+}\n+#[repr(C)]\n+pub struct IO_STATUS_BLOCK {\n+    pub Pointer: *mut c_void,\n+    pub Information: usize,\n+}\n+impl Default for IO_STATUS_BLOCK {\n+    fn default() -> Self {\n+        Self { Pointer: ptr::null_mut(), Information: 0 }\n+    }\n+}\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -353,9 +412,43 @@ pub enum FILE_INFO_BY_HANDLE_CLASS {\n     FileIdInfo = 18,                     // 0x12\n     FileIdExtdDirectoryInfo = 19,        // 0x13\n     FileIdExtdDirectoryRestartInfo = 20, // 0x14\n+    FileDispositionInfoEx = 21,          // 0x15, Windows 10 version 1607\n     MaximumFileInfoByHandlesClass,\n }\n \n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO {\n+    pub DeleteFile: BOOLEAN,\n+}\n+\n+pub const FILE_DISPOSITION_DELETE: DWORD = 0x1;\n+pub const FILE_DISPOSITION_POSIX_SEMANTICS: DWORD = 0x2;\n+pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: DWORD = 0x10;\n+\n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO_EX {\n+    pub Flags: DWORD,\n+}\n+\n+#[repr(C)]\n+#[derive(Default)]\n+pub struct FILE_ID_BOTH_DIR_INFO {\n+    pub NextEntryOffset: DWORD,\n+    pub FileIndex: DWORD,\n+    pub CreationTime: LARGE_INTEGER,\n+    pub LastAccessTime: LARGE_INTEGER,\n+    pub LastWriteTime: LARGE_INTEGER,\n+    pub ChangeTime: LARGE_INTEGER,\n+    pub EndOfFile: LARGE_INTEGER,\n+    pub AllocationSize: LARGE_INTEGER,\n+    pub FileAttributes: DWORD,\n+    pub FileNameLength: DWORD,\n+    pub EaSize: DWORD,\n+    pub ShortNameLength: CCHAR,\n+    pub ShortName: [WCHAR; 12],\n+    pub FileId: LARGE_INTEGER,\n+    pub FileName: [WCHAR; 1],\n+}\n #[repr(C)]\n pub struct FILE_BASIC_INFO {\n     pub CreationTime: LARGE_INTEGER,\n@@ -750,16 +843,6 @@ if #[cfg(target_vendor = \"uwp\")] {\n         pub DeletePending: BOOLEAN,\n         pub Directory: BOOLEAN,\n     }\n-\n-    #[link(name = \"kernel32\")]\n-    extern \"system\" {\n-        pub fn GetFileInformationByHandleEx(\n-            hFile: HANDLE,\n-            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-            lpFileInformation: LPVOID,\n-            dwBufferSize: DWORD,\n-        ) -> BOOL;\n-    }\n }\n }\n \n@@ -949,6 +1032,12 @@ extern \"system\" {\n         cchFilePath: DWORD,\n         dwFlags: DWORD,\n     ) -> DWORD;\n+    pub fn GetFileInformationByHandleEx(\n+        hFile: HANDLE,\n+        fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+        lpFileInformation: LPVOID,\n+        dwBufferSize: DWORD,\n+    ) -> BOOL;\n     pub fn SetFileInformationByHandle(\n         hFile: HANDLE,\n         FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n@@ -1139,6 +1228,21 @@ compat_fn! {\n \n compat_fn! {\n     \"ntdll\":\n+    pub fn NtOpenFile(\n+        FileHandle: *mut HANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n+        IoStatusBlock: *mut IO_STATUS_BLOCK,\n+        ShareAccess: ULONG,\n+        OpenOptions: ULONG\n+    ) -> NTSTATUS {\n+        panic!(\"`NtOpenFile` not available\");\n+    }\n+    pub fn RtlNtStatusToDosError(\n+        Status: NTSTATUS\n+    ) -> ULONG {\n+        panic!(\"`RtlNtStatusToDosError` not available\");\n+    }\n     pub fn NtCreateKeyedEvent(\n         KeyedEventHandle: LPHANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "dd21c6b43891f137d3b70e3800e9152c4795c394", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 305, "deletions": 17, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc97490bbca00e6913c34b8864791d660c60312/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=dbc97490bbca00e6913c34b8864791d660c60312", "patch": "@@ -547,6 +547,218 @@ impl File {\n         })?;\n         Ok(())\n     }\n+    /// Get only basic file information such as attributes and file times.\n+    fn basic_info(&self) -> io::Result<c::FILE_BASIC_INFO> {\n+        unsafe {\n+            let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n+            let size = mem::size_of_val(&info);\n+            cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                c::FileBasicInfo,\n+                &mut info as *mut _ as *mut libc::c_void,\n+                size as c::DWORD,\n+            ))?;\n+            Ok(info)\n+        }\n+    }\n+    /// Delete using POSIX semantics.\n+    ///\n+    /// Files will be deleted as soon as the handle is closed. This is supported\n+    /// for Windows 10 1607 (aka RS1) and later. However some filesystem\n+    /// drivers will not support it even then, e.g. FAT32.\n+    ///\n+    /// If the operation is not supported for this filesystem or OS version\n+    /// then errors will be `ERROR_NOT_SUPPORTED` or `ERROR_INVALID_PARAMETER`.\n+    fn posix_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO_EX {\n+            Flags: c::FILE_DISPOSITION_DELETE\n+                | c::FILE_DISPOSITION_POSIX_SEMANTICS\n+                | c::FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE,\n+        };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfoEx,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Delete a file using win32 semantics. The file won't actually be deleted\n+    /// until all file handles are closed. However, marking a file for deletion\n+    /// will prevent anyone from opening a new handle to the file.\n+    fn win32_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO { DeleteFile: c::TRUE as _ };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfo,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Fill the given buffer with as many directory entries as will fit.\n+    /// This will remember its position and continue from the last call unless\n+    /// `restart` is set to `true`.\n+    ///\n+    /// The returned bool indicates if there are more entries or not.\n+    /// It is an error if `self` is not a directory.\n+    ///\n+    /// # Symlinks and other reparse points\n+    ///\n+    /// On Windows a file is either a directory or a non-directory.\n+    /// A symlink directory is simply an empty directory with some \"reparse\" metadata attached.\n+    /// So if you open a link (not its target) and iterate the directory,\n+    /// you will always iterate an empty directory regardless of the target.\n+    fn fill_dir_buff(&self, buffer: &mut DirBuff, restart: bool) -> io::Result<bool> {\n+        let class =\n+            if restart { c::FileIdBothDirectoryRestartInfo } else { c::FileIdBothDirectoryInfo };\n+\n+        unsafe {\n+            let result = cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                class,\n+                buffer.as_mut_ptr().cast(),\n+                buffer.capacity() as _,\n+            ));\n+            match result {\n+                Ok(_) => Ok(true),\n+                Err(e) if e.raw_os_error() == Some(c::ERROR_NO_MORE_FILES as _) => Ok(false),\n+                Err(e) => Err(e),\n+            }\n+        }\n+    }\n+}\n+\n+/// A buffer for holding directory entries.\n+struct DirBuff {\n+    buffer: Vec<u8>,\n+}\n+impl DirBuff {\n+    fn new() -> Self {\n+        const BUFFER_SIZE: usize = 1024;\n+        Self { buffer: vec![0_u8; BUFFER_SIZE] }\n+    }\n+    fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+    fn as_mut_ptr(&mut self) -> *mut u8 {\n+        self.buffer.as_mut_ptr().cast()\n+    }\n+    /// Returns a `DirBuffIter`.\n+    fn iter(&self) -> DirBuffIter<'_> {\n+        DirBuffIter::new(self)\n+    }\n+}\n+impl AsRef<[u8]> for DirBuff {\n+    fn as_ref(&self) -> &[u8] {\n+        &self.buffer\n+    }\n+}\n+\n+/// An iterator over entries stored in a `DirBuff`.\n+///\n+/// Currently only returns file names (UTF-16 encoded).\n+struct DirBuffIter<'a> {\n+    buffer: Option<&'a [u8]>,\n+    cursor: usize,\n+}\n+impl<'a> DirBuffIter<'a> {\n+    fn new(buffer: &'a DirBuff) -> Self {\n+        Self { buffer: Some(buffer.as_ref()), cursor: 0 }\n+    }\n+}\n+impl<'a> Iterator for DirBuffIter<'a> {\n+    type Item = &'a [u16];\n+    fn next(&mut self) -> Option<Self::Item> {\n+        use crate::mem::size_of;\n+        let buffer = &self.buffer?[self.cursor..];\n+\n+        // Get the name and next entry from the buffer.\n+        // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n+        // last field (the file name) is unsized. So an offset has to be\n+        // used to get the file name slice.\n+        let (name, next_entry) = unsafe {\n+            let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n+            let next_entry = (*info).NextEntryOffset as usize;\n+            let name = crate::slice::from_raw_parts(\n+                (*info).FileName.as_ptr().cast::<u16>(),\n+                (*info).FileNameLength as usize / size_of::<u16>(),\n+            );\n+            (name, next_entry)\n+        };\n+\n+        if next_entry == 0 {\n+            self.buffer = None\n+        } else {\n+            self.cursor += next_entry\n+        }\n+\n+        // Skip `.` and `..` pseudo entries.\n+        const DOT: u16 = b'.' as u16;\n+        match name {\n+            [DOT] | [DOT, DOT] => self.next(),\n+            _ => Some(name),\n+        }\n+    }\n+}\n+\n+/// Open a link relative to the parent directory, ensure no symlinks are followed.\n+fn open_link_no_reparse(parent: &File, name: &[u16], access: u32) -> io::Result<File> {\n+    // This is implemented using the lower level `NtOpenFile` function as\n+    // unfortunately opening a file relative to a parent is not supported by\n+    // win32 functions. It is however a fundamental feature of the NT kernel.\n+    //\n+    // See https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntopenfile\n+    unsafe {\n+        let mut handle = ptr::null_mut();\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+        let name_str = c::UNICODE_STRING::from_ref(name);\n+        use crate::sync::atomic::{AtomicU32, Ordering};\n+        // The `OBJ_DONT_REPARSE` attribute ensures that we haven't been\n+        // tricked into following a symlink. However, it may not be available in\n+        // earlier versions of Windows.\n+        static ATTRIBUTES: AtomicU32 = AtomicU32::new(c::OBJ_DONT_REPARSE);\n+        let object = c::OBJECT_ATTRIBUTES {\n+            ObjectName: &name_str,\n+            RootDirectory: parent.as_raw_handle(),\n+            Attributes: ATTRIBUTES.load(Ordering::Relaxed),\n+            ..c::OBJECT_ATTRIBUTES::default()\n+        };\n+        let status = c::NtOpenFile(\n+            &mut handle,\n+            access,\n+            &object,\n+            &mut io_status,\n+            c::FILE_SHARE_DELETE | c::FILE_SHARE_READ | c::FILE_SHARE_WRITE,\n+            // If `name` is a symlink then open the link rather than the target.\n+            c::FILE_OPEN_REPARSE_POINT,\n+        );\n+        // Convert an NTSTATUS to the more familiar Win32 error codes (aka \"DosError\")\n+        if c::nt_success(status) {\n+            Ok(File::from_raw_handle(handle))\n+        } else if status == c::STATUS_DELETE_PENDING {\n+            // We make a special exception for `STATUS_DELETE_PENDING` because\n+            // otherwise this will be mapped to `ERROR_ACCESS_DENIED` which is\n+            // very unhelpful.\n+            Err(io::Error::from_raw_os_error(c::ERROR_DELETE_PENDING as _))\n+        } else if status == c::STATUS_INVALID_PARAMETER\n+            && ATTRIBUTES.load(Ordering::Relaxed) == c::OBJ_DONT_REPARSE\n+        {\n+            // Try without `OBJ_DONT_REPARSE`. See above.\n+            ATTRIBUTES.store(0, Ordering::Relaxed);\n+            open_link_no_reparse(parent, name, access)\n+        } else {\n+            Err(io::Error::from_raw_os_error(c::RtlNtStatusToDosError(status) as _))\n+        }\n+    }\n }\n \n impl AsInner<Handle> for File {\n@@ -756,30 +968,106 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+/// Open a file or directory without following symlinks.\n+fn open_link(path: &Path, access_mode: u32) -> io::Result<File> {\n+    let mut opts = OpenOptions::new();\n+    opts.access_mode(access_mode);\n+    // `FILE_FLAG_BACKUP_SEMANTICS` allows opening directories.\n+    // `FILE_FLAG_OPEN_REPARSE_POINT` opens a link instead of its target.\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n+    File::open(path, &opts)\n+}\n+\n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        // On Windows symlinks to files and directories are removed differently.\n-        // rmdir only deletes dir symlinks and junctions, not file symlinks.\n-        rmdir(path)\n+    let file = open_link(path, c::DELETE | c::FILE_LIST_DIRECTORY)?;\n+\n+    // Test if the file is not a directory or a symlink to a directory.\n+    if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0 {\n+        return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _));\n+    }\n+    let mut delete: fn(&File) -> io::Result<()> = File::posix_delete;\n+    let result = match delete(&file) {\n+        Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+            match remove_dir_all_recursive(&file, delete) {\n+                // Return unexpected errors.\n+                Err(e) if e.kind() != io::ErrorKind::DirectoryNotEmpty => return Err(e),\n+                result => result,\n+            }\n+        }\n+        // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n+        Err(e)\n+            if e.raw_os_error() == Some(c::ERROR_NOT_SUPPORTED as i32)\n+                || e.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) =>\n+        {\n+            delete = File::win32_delete;\n+            Err(e)\n+        }\n+        result => result,\n+    };\n+    if result.is_ok() {\n+        Ok(())\n     } else {\n-        remove_dir_all_recursive(path)\n+        // This is a fallback to make sure the directory is actually deleted.\n+        // Otherwise this function is prone to failing with `DirectoryNotEmpty`\n+        // due to possible delays between marking a file for deletion and the\n+        // file actually being deleted from the filesystem.\n+        //\n+        // So we retry a few times before giving up.\n+        for _ in 0..5 {\n+            match remove_dir_all_recursive(&file, delete) {\n+                Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                result => return result,\n+            }\n+        }\n+        // Try one last time.\n+        delete(&file)\n     }\n }\n \n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        let child_type = child.file_type()?;\n-        if child_type.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else if child_type.is_symlink_dir() {\n-            rmdir(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n+fn remove_dir_all_recursive(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+    let mut buffer = DirBuff::new();\n+    let mut restart = true;\n+    // Fill the buffer and iterate the entries.\n+    while f.fill_dir_buff(&mut buffer, restart)? {\n+        for name in buffer.iter() {\n+            // Open the file without following symlinks and try deleting it.\n+            // We try opening will all needed permissions and if that is denied\n+            // fallback to opening without `FILE_LIST_DIRECTORY` permission.\n+            // Note `SYNCHRONIZE` permission is needed for synchronous access.\n+            let mut result =\n+                open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY);\n+            if matches!(&result, Err(e) if e.kind() == io::ErrorKind::PermissionDenied) {\n+                result = open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE);\n+            }\n+            match result {\n+                Ok(file) => match delete(&file) {\n+                    Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+                        // Iterate the directory's files.\n+                        // Ignore `DirectoryNotEmpty` errors here. They will be\n+                        // caught when `remove_dir_all` tries to delete the top\n+                        // level directory. It can then decide if to retry or not.\n+                        match remove_dir_all_recursive(&file, delete) {\n+                            Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                            result => result?,\n+                        }\n+                    }\n+                    result => result?,\n+                },\n+                // Ignore error if a delete is already in progress or the file\n+                // has already been deleted. It also ignores sharing violations\n+                // (where a file is locked by another process) as these are\n+                // usually temporary.\n+                Err(e)\n+                    if e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                        || e.kind() == io::ErrorKind::NotFound\n+                        || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {}\n+                Err(e) => return Err(e),\n+            }\n         }\n+        // Continue reading directory entries without restarting from the beginning,\n+        restart = false;\n     }\n-    rmdir(path)\n+    delete(&f)\n }\n \n pub fn readlink(path: &Path) -> io::Result<PathBuf> {"}]}