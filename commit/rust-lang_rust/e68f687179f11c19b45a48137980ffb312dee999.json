{"sha": "e68f687179f11c19b45a48137980ffb312dee999", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OGY2ODcxNzlmMTFjMTliNDVhNDgxMzc5ODBmZmIzMTJkZWU5OTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-02T22:12:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-02T22:12:27Z"}, "message": "rustc: Root values spilled via do_spill()", "tree": {"sha": "24cb6e7e8d9fc2164ba6f01c13bd0e3b5070f14e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24cb6e7e8d9fc2164ba6f01c13bd0e3b5070f14e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68f687179f11c19b45a48137980ffb312dee999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68f687179f11c19b45a48137980ffb312dee999", "html_url": "https://github.com/rust-lang/rust/commit/e68f687179f11c19b45a48137980ffb312dee999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68f687179f11c19b45a48137980ffb312dee999/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00470fef1297d61e1efbc485d0658e3ecdbaf35e", "url": "https://api.github.com/repos/rust-lang/rust/commits/00470fef1297d61e1efbc485d0658e3ecdbaf35e", "html_url": "https://github.com/rust-lang/rust/commit/00470fef1297d61e1efbc485d0658e3ecdbaf35e"}], "stats": {"total": 118, "additions": 76, "deletions": 42}, "files": [{"sha": "6363d44a30ea4329616fd69e551aaede5af376db", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 62, "deletions": 32, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e68f687179f11c19b45a48137980ffb312dee999", "patch": "@@ -1983,36 +1983,39 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n \n-    let lllhs = spill_if_immediate(cx, lhs, t);\n-    let llrhs = spill_if_immediate(cx, rhs, t);\n-    let llrawlhsptr = BitCast(cx, lllhs, T_ptr(T_i8()));\n-    let llrawrhsptr = BitCast(cx, llrhs, T_ptr(T_i8()));\n+    let bcx = cx;\n+\n+    let r = spill_if_immediate(bcx, lhs, t);\n+    let lllhs = r.val; bcx = r.bcx;\n+    r = spill_if_immediate(bcx, rhs, t);\n+    let llrhs = r.val; bcx = r.bcx;\n+\n+    let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n+    let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n     let ti = none::<@tydesc_info>;\n-    let r = get_tydesc(cx, t, false, tps_normal, ti).result;\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, ti);\n-    let lltydesc = r.val;\n-    let lltydescs =\n-        GEP(r.bcx, lltydesc,\n+    r = get_tydesc(bcx, t, false, tps_normal, ti).result;\n+    let lltydesc = r.val; bcx = r.bcx;\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_cmp_glue, ti);\n+    let lltydescs = GEP(bcx, lltydesc,\n                         [C_int(0), C_int(abi::tydesc_field_first_param)]);\n-    lltydescs = Load(r.bcx, lltydescs);\n+    lltydescs = Load(bcx, lltydescs);\n \n     let llfn;\n     alt ti {\n       none. {\n-        let llfnptr =\n-            GEP(r.bcx, lltydesc,\n-                            [C_int(0), C_int(abi::tydesc_field_cmp_glue)]);\n-        llfn = Load(r.bcx, llfnptr);\n+        let llfnptr = GEP(bcx, lltydesc,\n+                          [C_int(0), C_int(abi::tydesc_field_cmp_glue)]);\n+        llfn = Load(bcx, llfnptr);\n       }\n       some(sti) { llfn = option::get(sti.cmp_glue); }\n     }\n \n-    let llcmpresultptr = alloca(r.bcx, T_i1());\n+    let llcmpresultptr = alloca(bcx, T_i1());\n     let llargs: [ValueRef] =\n-        [llcmpresultptr, r.bcx.fcx.lltaskptr, lltydesc, lltydescs,\n+        [llcmpresultptr, bcx.fcx.lltaskptr, lltydesc, lltydescs,\n          llrawlhsptr, llrawrhsptr, llop];\n-    Call(r.bcx, llfn, llargs);\n-    ret rslt(r.bcx, Load(r.bcx, llcmpresultptr));\n+    Call(bcx, llfn, llargs);\n+    ret rslt(bcx, Load(bcx, llcmpresultptr));\n }\n \n // Compares two values. Performs the simple scalar comparison if the types are\n@@ -3625,7 +3628,10 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n             if ty::type_is_vec(ccx.tcx, e_ty) {\n-                let arg_copy = do_spill(bcx, Load(bcx, val));\n+                let r = do_spill(bcx, Load(bcx, val), e_ty);\n+                bcx = r.bcx;\n+                let arg_copy = r.val;\n+\n                 bcx = take_ty(bcx, arg_copy, e_ty);\n                 val = Load(bcx, arg_copy);\n             } else {\n@@ -3635,7 +3641,8 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             add_clean_temp(bcx, val, e_ty);\n         }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n-        val = do_spill(bcx, val);\n+        let r = do_spill(bcx, val, e_ty);\n+        val = r.val; bcx = r.bcx;\n     }\n \n     if !is_bot && ty::type_contains_params(ccx.tcx, arg.ty) {\n@@ -3812,11 +3819,12 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n     let llretslot = args_res.retslot;\n+\n     /*\n-    log \"calling: \" + val_str(bcx_ccx(cx).tn, faddr);\n+    log_err \"calling: \" + val_str(bcx_ccx(cx).tn, faddr);\n \n     for arg: ValueRef in llargs {\n-        log \"arg: \" + val_str(bcx_ccx(cx).tn, arg);\n+        log_err \"arg: \" + val_str(bcx_ccx(cx).tn, arg);\n     }\n     */\n \n@@ -4172,16 +4180,29 @@ fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n         ty::type_is_native(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t);\n }\n \n-fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    // We have a value but we have to spill it to pass by alias.\n+fn do_spill(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n+    // We have a value but we have to spill it, and root it, to pass by alias.\n+    let bcx = cx;\n+    let r = alloc_ty(bcx, t);\n+    bcx = r.bcx;\n+    let llptr = r.val;\n+\n+    Store(bcx, v, llptr);\n+\n+    ret rslt(bcx, llptr);\n+}\n+\n+// Since this function does *not* root, it is the caller's responsibility to\n+// ensure that the referent is pointed to by a root.\n+fn do_spill_noroot(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     ret llptr;\n }\n \n-fn spill_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n-    if type_is_immediate(bcx_ccx(cx), t) { ret do_spill(cx, v); }\n-    ret v;\n+fn spill_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n+    if type_is_immediate(bcx_ccx(cx), t) { ret do_spill(cx, v, t); }\n+    ret rslt(cx, v);\n }\n \n fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n@@ -4222,13 +4243,17 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let ti = none::<@tydesc_info>;\n     let r = get_tydesc(log_bcx, e_ty, false, tps_normal, ti).result;\n     log_bcx = r.bcx;\n+    let lltydesc = r.val;\n \n     // Call the polymorphic log function.\n-    let llvalptr = spill_if_immediate(log_bcx, sub.val, e_ty);\n+    r = spill_if_immediate(log_bcx, sub.val, e_ty);\n+    log_bcx = r.bcx;\n+    let llvalptr = r.val;\n+\n     let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n \n     Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n-                       [log_bcx.fcx.lltaskptr, r.val, llval_i8, C_int(lvl)]);\n+         [log_bcx.fcx.lltaskptr, lltydesc, llval_i8, C_int(lvl)]);\n \n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     Br(log_bcx, after_cx.llbb);\n@@ -4940,7 +4965,8 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n \n fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n                         args: &[ast::arg], arg_tys: &[ty::arg]) {\n-    let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+    let llcopyargs = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+    let bcx = llcopyargs;\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n         let arg_ty = arg_tys[arg_n].ty;\n@@ -4951,7 +4977,11 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n             if !type_is_structural_or_param(fcx_tcx(fcx), arg_ty) {\n                 // Overwrite the llargs entry for this arg with its alloca.\n                 let aval = bcx.fcx.llargs.get(aarg.id);\n-                let addr = do_spill(bcx, aval);\n+\n+                let r = do_spill(bcx, aval, arg_ty);\n+                bcx = r.bcx;\n+                let addr = r.val;\n+\n                 bcx.fcx.llargs.insert(aarg.id, addr);\n \n                 // Args that are locally assigned to need to do a local\n@@ -4969,7 +4999,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n         }\n         arg_n += 1u;\n     }\n-    fcx.llcopyargs = bcx.llbb;\n+    fcx.llcopyargs = llcopyargs.llbb;\n }\n \n fn is_terminated(cx: &@block_ctxt) -> bool {"}, {"sha": "37327437af02fa75ef763551f569073c5ad41699", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=e68f687179f11c19b45a48137980ffb312dee999", "patch": "@@ -534,9 +534,9 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n     let exit_map = [];\n     let t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n-    let v = trans::spill_if_immediate(er.bcx, er.val, t);\n-    compile_submatch(er.bcx, match, [v], bind mk_fail(cx, expr.span, fail_cx),\n-                     exit_map);\n+    let vr = trans::spill_if_immediate(er.bcx, er.val, t);\n+    compile_submatch(vr.bcx, match, [vr.val],\n+                     bind mk_fail(cx, expr.span, fail_cx), exit_map);\n \n     let i = 0u;\n     let arm_results = [];"}, {"sha": "a86e077028b89687d0024ec87639eb53ace21dcc", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e68f687179f11c19b45a48137980ffb312dee999", "patch": "@@ -302,9 +302,11 @@ fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n     find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, val, ty))];\n }\n fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    fn spill_and_drop(bcx: &@block_ctxt, val: ValueRef, ty: ty::t)\n+    fn spill_and_drop(cx: &@block_ctxt, val: ValueRef, ty: ty::t)\n         -> @block_ctxt {\n-        let spilled = trans::spill_if_immediate(bcx, val, ty);\n+        let bcx = cx;\n+        let r = trans::spill_if_immediate(bcx, val, ty);\n+        let spilled = r.val; bcx = r.bcx;\n         ret drop_ty(bcx, spilled, ty);\n     }\n     find_scope_cx(cx).cleanups +="}, {"sha": "436b6d951aa99c3e952c7504b099b38c57893bef", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68f687179f11c19b45a48137980ffb312dee999/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=e68f687179f11c19b45a48137980ffb312dee999", "patch": "@@ -8,7 +8,7 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of,\n                alloca, size_of, llderivedtydescs_block_ctxt,\n                lazily_emit_tydesc_glue, get_tydesc, load_inbounds,\n                move_val_if_temp, trans_lval, node_id_type,\n-               new_sub_block_ctxt, tps_normal, do_spill};\n+               new_sub_block_ctxt, tps_normal, do_spill_noroot};\n import trans_build::*;\n import trans_common::*;\n \n@@ -159,7 +159,7 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n-    let write_ptr_ptr = do_spill(bcx, write_ptr);\n+    let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n     let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill, { | &bcx, addr, _ty |\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n@@ -186,7 +186,8 @@ fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n         bcx = e_bcx;\n-        let spilled = trans::spill_if_immediate(bcx, elt, elt_ty);\n+        let r = trans::spill_if_immediate(bcx, elt, elt_ty);\n+        let spilled = r.val; bcx = r.bcx;\n         Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n              [bcx.fcx.lltaskptr, opaque_v, td,\n               PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n@@ -212,7 +213,8 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let new_vec = PointerCast(bcx, new_vec, T_ptr(T_vec(llunitty)));\n     add_clean_temp(bcx, new_vec, vec_ty);\n \n-    let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n+    let write_ptr_ptr = do_spill_noroot(bcx,\n+                                        get_dataptr(bcx, new_vec, llunitty));\n     let copy_fn = bind fn(bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n                           write_ptr_ptr: ValueRef, unit_ty: ty::t,\n                           llunitsz: ValueRef) -> @block_ctxt {\n@@ -249,7 +251,7 @@ fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     // TODO: Optimize this when the size of the unit type is statically\n     // known to not use pointer casts, which tend to confuse LLVM.\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n-    let data_ptr_ptr = do_spill(bcx, data_ptr);\n+    let data_ptr_ptr = do_spill_noroot(bcx, data_ptr);\n \n     // Now perform the iteration.\n     let header_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_loop_header\");"}]}