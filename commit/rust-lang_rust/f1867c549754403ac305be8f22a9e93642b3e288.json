{"sha": "f1867c549754403ac305be8f22a9e93642b3e288", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxODY3YzU0OTc1NDQwM2FjMzA1YmU4ZjIyYTllOTM2NDJiM2UyODg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-07T09:18:03Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-07T09:18:03Z"}, "message": "Rename `infer_types` to `infer_args`", "tree": {"sha": "d568bfc143d8d86e836ae1ec7efae57677aab12c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d568bfc143d8d86e836ae1ec7efae57677aab12c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1867c549754403ac305be8f22a9e93642b3e288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1867c549754403ac305be8f22a9e93642b3e288", "html_url": "https://github.com/rust-lang/rust/commit/f1867c549754403ac305be8f22a9e93642b3e288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1867c549754403ac305be8f22a9e93642b3e288/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b36867093fb774bcbd9f787cbc470a5f44c1310", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b36867093fb774bcbd9f787cbc470a5f44c1310", "html_url": "https://github.com/rust-lang/rust/commit/8b36867093fb774bcbd9f787cbc470a5f44c1310"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "1b433c8da60b09b830571e4d215a497c04372689", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f1867c549754403ac305be8f22a9e93642b3e288", "patch": "@@ -2168,7 +2168,7 @@ impl<'a> LoweringContext<'a> {\n         itctx: ImplTraitContext<'_>,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment {\n-        let (mut generic_args, infer_types) = if let Some(ref generic_args) = segment.args {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n@@ -2305,7 +2305,7 @@ impl<'a> LoweringContext<'a> {\n             Some(id),\n             Some(self.lower_res(res)),\n             generic_args,\n-            infer_types,\n+            infer_args,\n         )\n     }\n "}, {"sha": "82b7dfd363f14a3294971d0b31d2374ad19ab306", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f1867c549754403ac305be8f22a9e93642b3e288", "patch": "@@ -348,7 +348,7 @@ pub struct PathSegment {\n     /// This only applies to expression and pattern paths, and\n     /// out of those only the segments with no type parameters\n     /// to begin with, e.g., `Vec::new` is `<Vec<..>>::new::<..>`.\n-    pub infer_types: bool,\n+    pub infer_args: bool,\n }\n \n impl PathSegment {\n@@ -358,7 +358,7 @@ impl PathSegment {\n             ident,\n             hir_id: None,\n             res: None,\n-            infer_types: true,\n+            infer_args: true,\n             args: None,\n         }\n     }\n@@ -368,13 +368,13 @@ impl PathSegment {\n         hir_id: Option<HirId>,\n         res: Option<Res>,\n         args: GenericArgs,\n-        infer_types: bool,\n+        infer_args: bool,\n     ) -> Self {\n         PathSegment {\n             ident,\n             hir_id,\n             res,\n-            infer_types,\n+            infer_args,\n             args: if args.is_empty() {\n                 None\n             } else {"}, {"sha": "7b0a499fa5c663fa43077443a3f08c95aea5e4ce", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f1867c549754403ac305be8f22a9e93642b3e288", "patch": "@@ -1196,7 +1196,7 @@ impl<'a> State<'a> {\n \n         segment.with_generic_args(|generic_args| {\n             if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n-                return self.print_generic_args(&generic_args, segment.infer_types, true);\n+                return self.print_generic_args(&generic_args, segment.infer_args, true);\n             }\n             Ok(())\n         })?;\n@@ -1561,7 +1561,7 @@ impl<'a> State<'a> {\n             if segment.ident.name != kw::PathRoot {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n-                   self.print_generic_args(generic_args, segment.infer_types,\n+                   self.print_generic_args(generic_args, segment.infer_args,\n                                            colons_before_params)\n                })?;\n             }\n@@ -1574,7 +1574,7 @@ impl<'a> State<'a> {\n         if segment.ident.name != kw::PathRoot {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n-               self.print_generic_args(generic_args, segment.infer_types, false)\n+               self.print_generic_args(generic_args, segment.infer_args, false)\n            })?;\n         }\n         Ok(())\n@@ -1602,7 +1602,7 @@ impl<'a> State<'a> {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,\n-                                                    segment.infer_types,\n+                                                    segment.infer_args,\n                                                     colons_before_params)\n                         })?;\n                     }\n@@ -1614,7 +1614,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n-                                            item_segment.infer_types,\n+                                            item_segment.infer_args,\n                                             colons_before_params)\n                 })\n             }\n@@ -1626,7 +1626,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n-                                            item_segment.infer_types,\n+                                            item_segment.infer_args,\n                                             colons_before_params)\n                 })\n             }\n@@ -1635,7 +1635,7 @@ impl<'a> State<'a> {\n \n     fn print_generic_args(&mut self,\n                              generic_args: &hir::GenericArgs,\n-                             infer_types: bool,\n+                             infer_args: bool,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if generic_args.parenthesized {\n@@ -1681,7 +1681,7 @@ impl<'a> State<'a> {\n \n             // FIXME(eddyb): this would leak into error messages (e.g.,\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n-            if infer_types && false {\n+            if infer_args && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;\n             }"}, {"sha": "bac4df927b66a78da9ff2308c5dbccd7d6483b50", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f1867c549754403ac305be8f22a9e93642b3e288", "patch": "@@ -191,7 +191,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 span,\n                 def_id,\n                 generic_args,\n-                item_segment.infer_types,\n+                item_segment.infer_args,\n                 None,\n             )\n         });\n@@ -208,7 +208,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n     ) -> bool {\n-        let explicit = !seg.infer_types;\n+        let explicit = !seg.infer_args;\n         let impl_trait = generics.params.iter().any(|param| match param.kind {\n             ty::GenericParamDefKind::Type {\n                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n@@ -259,7 +259,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 GenericArgPosition::Value\n             },\n             def.parent.is_none() && def.has_self, // `has_self`\n-            seg.infer_types || suppress_mismatch, // `infer_types`\n+            seg.infer_args || suppress_mismatch, // `infer_args`\n         ).0\n     }\n \n@@ -272,7 +272,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         args: &hir::GenericArgs,\n         position: GenericArgPosition,\n         has_self: bool,\n-        infer_types: bool,\n+        infer_args: bool,\n     ) -> (bool, Option<Vec<Span>>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n@@ -414,7 +414,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             );\n         }\n         // Note that type errors are currently be emitted *after* const errors.\n-        if !infer_types\n+        if !infer_args\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n                 \"type\",\n@@ -511,7 +511,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_types) = args_for_def_id(def_id);\n+            let (generic_args, infer_args) = args_for_def_id(def_id);\n \n             let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter())\n                 .peekable();\n@@ -535,7 +535,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                             | (GenericArg::Const(_), GenericParamDefKind::Lifetime) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_types));\n+                                substs.push(inferred_kind(None, param, infer_args));\n                                 params.next();\n                             }\n                             (_, _) => {\n@@ -556,7 +556,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_types));\n+                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n                         args.next();\n                         params.next();\n                     }\n@@ -592,7 +592,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         span: Span,\n         def_id: DefId,\n         generic_args: &'a hir::GenericArgs,\n-        infer_types: bool,\n+        infer_args: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n     {\n@@ -617,7 +617,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             &generic_args,\n             GenericArgPosition::Type,\n             has_self,\n-            infer_types,\n+            infer_args,\n         );\n \n         let is_object = self_ty.map_or(false, |ty| {\n@@ -644,7 +644,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             self_ty.is_some(),\n             self_ty,\n             // Provide the generic args, and whether types should be inferred.\n-            |_| (Some(generic_args), infer_types),\n+            |_| (Some(generic_args), infer_args),\n             // Provide substitutions for parameters for which (valid) arguments have been provided.\n             |param, arg| {\n                 match (&param.kind, arg) {\n@@ -661,11 +661,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n             },\n             // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_types| {\n+            |substs, param, infer_args| {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n-                        if !infer_types && has_default {\n+                        if !infer_args && has_default {\n                             // No type parameter provided, but a default exists.\n \n                             // If we are converting an object type, then the\n@@ -693,7 +693,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                        .subst_spanned(tcx, substs.unwrap(), Some(span))\n                                 ).into()\n                             }\n-                        } else if infer_types {\n+                        } else if infer_args {\n                             // No type parameters were provided, we can infer all.\n                             if !default_needs_object_self(param) {\n                                 self.ty_infer_for_def(param, span).into()\n@@ -880,7 +880,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             self.create_substs_for_ast_path(span,\n                                             trait_def_id,\n                                             generic_args,\n-                                            trait_segment.infer_types,\n+                                            trait_segment.infer_args,\n                                             Some(self_ty))\n         })\n     }"}, {"sha": "c66d5ff08c0b8937a785f5d940ad066fe819c62f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1867c549754403ac305be8f22a9e93642b3e288/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f1867c549754403ac305be8f22a9e93642b3e288", "patch": "@@ -5419,10 +5419,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !infer_args_for_err.contains(&index) {\n                         // Check whether the user has provided generic arguments.\n                         if let Some(ref data) = segments[index].args {\n-                            return (Some(data), segments[index].infer_types);\n+                            return (Some(data), segments[index].infer_args);\n                         }\n                     }\n-                    return (None, segments[index].infer_types);\n+                    return (None, segments[index].infer_args);\n                 }\n \n                 (None, true)\n@@ -5443,13 +5443,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             },\n             // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_types| {\n+            |substs, param, infer_args| {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n                         self.re_infer(span, Some(param)).unwrap().into()\n                     }\n                     GenericParamDefKind::Type { has_default, .. } => {\n-                        if !infer_types && has_default {\n+                        if !infer_args && has_default {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing."}]}