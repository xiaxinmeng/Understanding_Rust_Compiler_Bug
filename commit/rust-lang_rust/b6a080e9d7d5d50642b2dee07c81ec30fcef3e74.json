{"sha": "b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2YTA4MGU5ZDdkNWQ1MDY0MmIyZGVlMDdjODFlYzMwZmNlZjNlNzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-10T19:10:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T20:24:46Z"}, "message": "rework `relate_type_and_user_type` to use type inference variables\n\nWe used to use a kind of \"home-grown\" variant where we tracked the\nvalue of each canonical variable.", "tree": {"sha": "dc5588677f42525f2a8b2e30e07407788b231929", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc5588677f42525f2a8b2e30e07407788b231929"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "html_url": "https://github.com/rust-lang/rust/commit/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3409a1640785c6280693a21ec39603615353d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3409a1640785c6280693a21ec39603615353d28", "html_url": "https://github.com/rust-lang/rust/commit/a3409a1640785c6280693a21ec39603615353d28"}], "stats": {"total": 113, "additions": 39, "deletions": 74}, "files": [{"sha": "26cd939a4da1ea6acb67a1d83dd0a8cdb653e167", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 39, "deletions": 74, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6a080e9d7d5d50642b2dee07c81ec30fcef3e74/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=b6a080e9d7d5d50642b2dee07c81ec30fcef3e74", "patch": "@@ -10,16 +10,15 @@\n \n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use rustc::infer::canonical::{Canonical, CanonicalVarInfos, CanonicalVarValues};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::Kind;\n-use rustc::ty::{self, CanonicalTy, CanonicalVar, Ty, TyCtxt};\n+use rustc::ty::{self, CanonicalTy, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax::source_map::DUMMY_SP;\n \n /// Adds sufficient constraints to ensure that `a <: b`.\n pub(super) fn sub_types<'tcx>(\n@@ -35,7 +34,6 @@ pub(super) fn sub_types<'tcx>(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Covariant,\n-        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -54,7 +52,6 @@ pub(super) fn eq_types<'tcx>(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Invariant,\n-        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -66,19 +63,20 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n     v: ty::Variance,\n-    b: CanonicalTy<'tcx>,\n+    canonical_b: CanonicalTy<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<Ty<'tcx>> {\n     debug!(\n-        \"sub_type_and_user_type(a={:?}, b={:?}, locations={:?})\",\n-        a, b, locations\n+        \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n+        a, v, canonical_b, locations\n+    );\n+\n+    let (b, _values) = infcx.instantiate_canonical_with_fresh_inference_vars(\n+        DUMMY_SP,\n+        &canonical_b,\n     );\n-    let Canonical {\n-        variables: b_variables,\n-        value: b_value,\n-    } = b;\n \n     // The `TypeRelating` code assumes that the \"canonical variables\"\n     // appear in the \"a\" side, so flip `Contravariant` ambient\n@@ -89,20 +87,10 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v1,\n-        b_variables,\n     );\n-    type_relating.relate(&b_value, &a)?;\n-\n-    Ok(b.substitute(\n-        infcx.tcx,\n-        &CanonicalVarValues {\n-            var_values: type_relating\n-                .canonical_var_values\n-                .into_iter()\n-                .map(|x| x.expect(\"unsubstituted canonical variable\"))\n-                .collect(),\n-        },\n-    ))\n+    type_relating.relate(&b, &a)?;\n+\n+    Ok(b)\n }\n \n struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n@@ -136,19 +124,6 @@ where\n \n     /// Same as `a_scopes`, but for the `b` type.\n     b_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// As we execute, the type on the LHS *may* come from a canonical\n-    /// source. In that case, we will sometimes find a constraint like\n-    /// `?0 = B`, where `B` is a type from the RHS. The first time we\n-    /// find that, we simply record `B` (and the list of scopes that\n-    /// tells us how to *interpret* `B`). The next time we encounter\n-    /// `?0`, then, we can read this value out and use it.\n-    ///\n-    /// One problem: these variables may be in some other universe,\n-    /// how can we enforce that? I guess I could add some kind of\n-    /// \"minimum universe constraint\" that we can feed to the NLL checker.\n-    /// --> also, we know this doesn't happen\n-    canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n trait TypeRelatingDelegate<'tcx> {\n@@ -279,14 +254,11 @@ where\n         infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n         delegate: D,\n         ambient_variance: ty::Variance,\n-        canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n-        let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n         Self {\n             infcx,\n             delegate,\n             ambient_variance,\n-            canonical_var_values,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -400,19 +372,13 @@ where\n     /// equated, then equate it again.\n     fn relate_var(\n         &mut self,\n-        var: CanonicalVar,\n-        b_kind: Kind<'tcx>,\n-    ) -> RelateResult<'tcx, Kind<'tcx>> {\n-        debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n-\n-        let generalized_kind = match self.canonical_var_values[var] {\n-            Some(v) => v,\n-            None => {\n-                let generalized_kind = self.generalize_value(b_kind);\n-                self.canonical_var_values[var] = Some(generalized_kind);\n-                generalized_kind\n-            }\n-        };\n+        var_ty: Ty<'tcx>,\n+        value_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+\n+        let generalized_ty = self.generalize_value(value_ty);\n+        self.infcx.force_instantiate_unchecked(var_ty, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -421,16 +387,16 @@ where\n         let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n \n         // Relate the generalized kind to the original one.\n-        let result = self.relate(&generalized_kind, &b_kind);\n+        let result = self.relate(&generalized_ty, &value_ty);\n \n         // Restore the old scopes now.\n         self.a_scopes = old_a_scopes;\n \n         debug!(\"equate_var: complete, result = {:?}\", result);\n-        return result;\n+        result\n     }\n \n-    fn generalize_value(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n         TypeGeneralizer {\n             tcx: self.infcx.tcx,\n             delegate: &mut self.delegate,\n@@ -440,7 +406,7 @@ where\n             // These always correspond to an `_` or `'_` written by\n             // user, and those are always in the root universe.\n             universe: ty::UniverseIndex::ROOT,\n-        }.relate(&kind, &kind)\n+        }.relate(&value, &value)\n             .unwrap()\n     }\n }\n@@ -490,18 +456,22 @@ where\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        // Watch out for the case that we are matching a `?T` against the\n-        // right-hand side.\n-        if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            self.relate_var(var, b.into())?;\n-            Ok(a)\n-        } else {\n-            debug!(\n-                \"tys(a={:?}, b={:?}, variance={:?})\",\n-                a, b, self.ambient_variance\n-            );\n+        let a = self.infcx.shallow_resolve(a);\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) |\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n+                self.relate_var(a.into(), b.into())\n+            }\n+\n+            _ => {\n+                debug!(\n+                    \"tys(a={:?}, b={:?}, variance={:?})\",\n+                    a, b, self.ambient_variance\n+                );\n \n-            relate::super_relate_tys(self, a, b)\n+                relate::super_relate_tys(self, a, b)\n+            }\n         }\n     }\n \n@@ -510,11 +480,6 @@ where\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        if let ty::ReCanonical(var) = a {\n-            self.relate_var(*var, b.into())?;\n-            return Ok(a);\n-        }\n-\n         debug!(\n             \"regions(a={:?}, b={:?}, variance={:?})\",\n             a, b, self.ambient_variance"}]}