{"sha": "6ceb1637b2500f384015578a5a6f556bcc992052", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZWIxNjM3YjI1MDBmMzg0MDE1NTc4YTVhNmY1NTZiY2M5OTIwNTI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-15T17:02:41Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-07T08:47:22Z"}, "message": "Move some functions out of rustc_codegen_llvm and fix metadata_only backend", "tree": {"sha": "f19b7aa29e17b30195a6018ce817456f3d00c925", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f19b7aa29e17b30195a6018ce817456f3d00c925"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ceb1637b2500f384015578a5a6f556bcc992052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ceb1637b2500f384015578a5a6f556bcc992052", "html_url": "https://github.com/rust-lang/rust/commit/6ceb1637b2500f384015578a5a6f556bcc992052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ceb1637b2500f384015578a5a6f556bcc992052/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f0ca9248f93162201ea88a99594deedf0ebd897", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f0ca9248f93162201ea88a99594deedf0ebd897", "html_url": "https://github.com/rust-lang/rust/commit/4f0ca9248f93162201ea88a99594deedf0ebd897"}], "stats": {"total": 404, "additions": 265, "deletions": 139}, "files": [{"sha": "d38ffe431e04e9eb9411205c8dfcc77e76dba350", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -114,6 +114,10 @@ fn main() {\n \n     cmd.env(\"RUSTC_BREAK_ON_ICE\", \"1\");\n \n+    if args.iter().find(|s| **s == OsString::from(\"___\")).is_some() {\n+        cmd.arg(\"-Zcodegen-backend=metadata_only\");\n+    }\n+\n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option."}, {"sha": "e23566d52f0bc59f23239d5fde7d1b532328efad", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -182,11 +182,13 @@ pub fn std_cargo(builder: &Builder,\n             // missing\n             // We also only build the runtimes when --enable-sanitizers (or its\n             // config.toml equivalent) is used\n-            let llvm_config = builder.ensure(native::Llvm {\n-                target: builder.config.build,\n-                emscripten: false,\n-            });\n-            cargo.env(\"LLVM_CONFIG\", llvm_config);\n+            if !builder.config.rust_codegen_backends.is_empty() {\n+                let llvm_config = builder.ensure(native::Llvm {\n+                    target: builder.config.build,\n+                    emscripten: false,\n+                });\n+                cargo.env(\"LLVM_CONFIG\", llvm_config);\n+            }\n         }\n \n         cargo.arg(\"--features\").arg(features)\n@@ -675,7 +677,9 @@ impl Step for CodegenBackend {\n             .arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n-        features += &build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n+        if !backend.is_empty() {\n+            features += &build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n+        }\n \n         let tmp_stamp = builder.cargo_out(compiler, Mode::Codegen, target)\n             .join(\".tmp.stamp\");"}, {"sha": "53c70eb42ce54dd66a1893e342918253494c6035", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -56,6 +56,7 @@ use builder::{Builder, MemFlags};\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n+use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n use context::{self, CodegenCx};\n@@ -67,7 +68,7 @@ use monomorphize::Instance;\n use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use rustc_codegen_utils::symbol_names_test;\n use time_graph;\n-use mono_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n+use mono_item::{MonoItem, BaseMonoItemExt, MonoItemExt};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n@@ -92,8 +93,6 @@ use syntax::ast;\n \n use mir::operand::OperandValue;\n \n-pub use rustc_codegen_utils::check_for_rustc_errors_attr;\n-\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     cx: &'a CodegenCx<'a, 'tcx>,\n     name: Option<String>,\n@@ -715,7 +714,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCodegen {\n \n-    check_for_rustc_errors_attr(tcx);\n+    ::rustc_codegen_utils::check_for_rustc_errors_attr(tcx);\n \n     if let Some(true) = tcx.sess.opts.debugging_opts.thinlto {\n         if unsafe { !llvm::LLVMRustThinLTOAvailable() } {"}, {"sha": "099d717e3c00cc91867e3918a61bad47fdf1fb70", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 101, "deletions": 3, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -12,9 +12,7 @@\n \n //! Code that is useful in various codegen modules.\n \n-use llvm;\n-use llvm::{ValueRef, ContextRef, TypeKind};\n-use llvm::{True, False, Bool, OperandBundleDef};\n+use llvm::{self, ValueRef, ContextRef, TypeKind, True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use abi;\n@@ -29,6 +27,8 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n \n+use meth;\n+\n use libc::{c_uint, c_char};\n use std::iter;\n \n@@ -448,3 +448,101 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }\n }\n+\n+pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+                                       -> (ValueRef, ValueRef) {\n+    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n+           t, Value(info));\n+    if bx.cx.type_is_sized(t) {\n+        let (size, align) = bx.cx.size_and_align_of(t);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n+               t, Value(info), size, align);\n+        let size = C_usize(bx.cx, size.bytes());\n+        let align = C_usize(bx.cx, align.abi());\n+        return (size, align);\n+    }\n+    assert!(!info.is_null());\n+    match t.sty {\n+        ty::TyDynamic(..) => {\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit = t.sequence_element_type(bx.tcx());\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            let (size, align) = bx.cx.size_and_align_of(unit);\n+            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n+             C_usize(bx.cx, align.abi()))\n+        }\n+        _ => {\n+            let cx = bx.cx;\n+            // First get the size of all statically known fields.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n+            assert!(!t.is_simd());\n+            let layout = cx.layout_of(t);\n+            debug!(\"DST {} layout: {:?}\", t, layout);\n+\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align.abi();\n+            debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                   t, sized_size, sized_align);\n+            let sized_size = C_usize(cx, sized_size);\n+            let sized_align = C_usize(cx, sized_align);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let field_ty = layout.field(cx, i).ty;\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bx, field_ty, info);\n+\n+            // FIXME (#26403, #27023): We should be adding padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`. (Note that since #26403\n+            // is unfixed, we do not yet add the necessary padding\n+            // here. But this is where the add would go.)\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = bx.add(sized_size, unsized_size);\n+\n+            // Packed types ignore the alignment of their fields.\n+            if let ty::TyAdt(def, _) = t.sty {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n+            // Choose max of two known alignments (combined value must\n+            // be aligned according to more restrictive of the two).\n+            let align = match (const_to_opt_u128(sized_align, false),\n+                               const_to_opt_u128(unsized_align, false)) {\n+                (Some(sized_align), Some(unsized_align)) => {\n+                    // If both alignments are constant, (the sized_align should always be), then\n+                    // pick the correct alignment statically.\n+                    C_usize(cx, ::std::cmp::max(sized_align, unsized_align) as u64)\n+                }\n+                _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n+                                sized_align,\n+                                unsized_align)\n+            };\n+\n+            // Issue #27023: must add any necessary padding to `size`\n+            // (to make it a multiple of `align`) before returning it.\n+            //\n+            // Namely, the returned size should be, in C notation:\n+            //\n+            //   `size + ((size & (align-1)) ? align : 0)`\n+            //\n+            // emulated via the semi-standard fast bit trick:\n+            //\n+            //   `(size + (align-1)) & -align`\n+\n+            let addend = bx.sub(align, C_usize(bx.cx, 1));\n+            let size = bx.and(bx.add(size, addend), bx.neg(align));\n+\n+            (size, align)\n+        }\n+    }\n+}"}, {"sha": "eee4e5f8f7a099b3392e7e5b813a9e671550a487", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -79,6 +79,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc_mir::monomorphize;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_codegen_utils::time_graph;\n \n mod diagnostics;\n \n@@ -114,7 +115,6 @@ mod llvm_util;\n mod metadata;\n mod meth;\n mod mir;\n-mod time_graph;\n mod mono_item;\n mod type_;\n mod type_of;\n@@ -368,7 +368,7 @@ struct CodegenResults {\n     crate_info: CrateInfo,\n }\n \n-// Misc info we load from metadata to persist beyond the tcx\n+/// Misc info we load from metadata to persist beyond the tcx\n struct CrateInfo {\n     panic_runtime: Option<CrateNum>,\n     compiler_builtins: Option<CrateNum>,"}, {"sha": "b63b43c9c73afedb0215ace81a5d4de74cc4a5e2", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -20,6 +20,8 @@ use syntax::feature_gate::UnstableFeatures;\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Once;\n \n+pub use rustc_codegen_utils::llvm_target_features::*;\n+\n static POISONED: AtomicBool = AtomicBool::new(false);\n static INIT: Once = Once::new();\n \n@@ -79,108 +81,6 @@ unsafe fn configure_llvm(sess: &Session) {\n                                  llvm_args.as_ptr());\n }\n \n-// WARNING: the features after applying `to_llvm_feature` must be known\n-// to LLVM or the feature detection code will walk past the end of the feature\n-// array, leading to crashes.\n-\n-const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"mclass\", Some(\"arm_target_feature\")),\n-    (\"neon\", Some(\"arm_target_feature\")),\n-    (\"v7\", Some(\"arm_target_feature\")),\n-    (\"vfp2\", Some(\"arm_target_feature\")),\n-    (\"vfp3\", Some(\"arm_target_feature\")),\n-    (\"vfp4\", Some(\"arm_target_feature\")),\n-];\n-\n-const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp\", Some(\"aarch64_target_feature\")),\n-    (\"neon\", Some(\"aarch64_target_feature\")),\n-    (\"sve\", Some(\"aarch64_target_feature\")),\n-    (\"crc\", Some(\"aarch64_target_feature\")),\n-    (\"crypto\", Some(\"aarch64_target_feature\")),\n-    (\"ras\", Some(\"aarch64_target_feature\")),\n-    (\"lse\", Some(\"aarch64_target_feature\")),\n-    (\"rdm\", Some(\"aarch64_target_feature\")),\n-    (\"fp16\", Some(\"aarch64_target_feature\")),\n-    (\"rcpc\", Some(\"aarch64_target_feature\")),\n-    (\"dotprod\", Some(\"aarch64_target_feature\")),\n-    (\"v8.1a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.2a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.3a\", Some(\"aarch64_target_feature\")),\n-];\n-\n-const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"aes\", None),\n-    (\"avx\", None),\n-    (\"avx2\", None),\n-    (\"avx512bw\", Some(\"avx512_target_feature\")),\n-    (\"avx512cd\", Some(\"avx512_target_feature\")),\n-    (\"avx512dq\", Some(\"avx512_target_feature\")),\n-    (\"avx512er\", Some(\"avx512_target_feature\")),\n-    (\"avx512f\", Some(\"avx512_target_feature\")),\n-    (\"avx512ifma\", Some(\"avx512_target_feature\")),\n-    (\"avx512pf\", Some(\"avx512_target_feature\")),\n-    (\"avx512vbmi\", Some(\"avx512_target_feature\")),\n-    (\"avx512vl\", Some(\"avx512_target_feature\")),\n-    (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n-    (\"bmi1\", None),\n-    (\"bmi2\", None),\n-    (\"fma\", None),\n-    (\"fxsr\", None),\n-    (\"lzcnt\", None),\n-    (\"mmx\", Some(\"mmx_target_feature\")),\n-    (\"pclmulqdq\", None),\n-    (\"popcnt\", None),\n-    (\"rdrand\", None),\n-    (\"rdseed\", None),\n-    (\"sha\", None),\n-    (\"sse\", None),\n-    (\"sse2\", None),\n-    (\"sse3\", None),\n-    (\"sse4.1\", None),\n-    (\"sse4.2\", None),\n-    (\"sse4a\", Some(\"sse4a_target_feature\")),\n-    (\"ssse3\", None),\n-    (\"tbm\", Some(\"tbm_target_feature\")),\n-    (\"xsave\", None),\n-    (\"xsavec\", None),\n-    (\"xsaveopt\", None),\n-    (\"xsaves\", None),\n-];\n-\n-const HEXAGON_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"hvx\", Some(\"hexagon_target_feature\")),\n-    (\"hvx-double\", Some(\"hexagon_target_feature\")),\n-];\n-\n-const POWERPC_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power9-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-vector\", Some(\"powerpc_target_feature\")),\n-    (\"power9-vector\", Some(\"powerpc_target_feature\")),\n-    (\"vsx\", Some(\"powerpc_target_feature\")),\n-];\n-\n-const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp64\", Some(\"mips_target_feature\")),\n-    (\"msa\", Some(\"mips_target_feature\")),\n-];\n-\n-/// When rustdoc is running, provide a list of all known features so that all their respective\n-/// primtives may be documented.\n-///\n-/// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n-/// iterator!\n-pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static str>)> {\n-    ARM_WHITELIST.iter().cloned()\n-        .chain(AARCH64_WHITELIST.iter().cloned())\n-        .chain(X86_WHITELIST.iter().cloned())\n-        .chain(HEXAGON_WHITELIST.iter().cloned())\n-        .chain(POWERPC_WHITELIST.iter().cloned())\n-        .chain(MIPS_WHITELIST.iter().cloned())\n-}\n-\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.target.arch == \"x86_64\" {\n         \"x86\"\n@@ -216,20 +116,6 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .map(|feature| Symbol::intern(feature)).collect()\n }\n \n-pub fn target_feature_whitelist(sess: &Session)\n-    -> &'static [(&'static str, Option<&'static str>)]\n-{\n-    match &*sess.target.target.arch {\n-        \"arm\" => ARM_WHITELIST,\n-        \"aarch64\" => AARCH64_WHITELIST,\n-        \"x86\" | \"x86_64\" => X86_WHITELIST,\n-        \"hexagon\" => HEXAGON_WHITELIST,\n-        \"mips\" | \"mips64\" => MIPS_WHITELIST,\n-        \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n-        _ => &[],\n-    }\n-}\n-\n pub fn print_version() {\n     // Can be called without initializing LLVM\n     unsafe {"}, {"sha": "61f4bc3e6bc80d57dc7a1fb34fffd00672beb669", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -33,7 +33,7 @@ use std::fmt;\n \n pub use rustc::mir::mono::MonoItem;\n \n-pub use rustc_mir::monomorphize::item::*;\n+use rustc_mir::monomorphize::item::*;\n pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n \n pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {"}, {"sha": "8b52d61fd9e54e69831da872592a18d44ff0d637", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -26,7 +26,7 @@ use std::io::prelude::*;\n use std::io::{self, Cursor};\n use std::fs::File;\n use std::path::Path;\n-use std::sync::mpsc;\n+use std::sync::{mpsc, Arc};\n \n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::sync::Lrc;\n@@ -44,7 +44,6 @@ use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc_target::spec::Target;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n@@ -203,10 +202,17 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n         ::symbol_names::provide(providers);\n \n         providers.target_features_whitelist = |_tcx, _cnum| {\n-            Lrc::new(FxHashMap()) // Just a dummy\n+            Lrc::new(::llvm_target_features::all_known_features()\n+                .map(|(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .collect())\n         };\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n+        providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());\n+        providers.wasm_custom_sections = |_tcx, _crate| Lrc::new(Vec::new());\n+    }\n+    fn provide_extern(&self, providers: &mut Providers) {\n+        providers.is_reachable_non_generic = |_tcx, _defid| true;\n     }\n-    fn provide_extern(&self, _providers: &mut Providers) {}\n \n     fn codegen_crate<'a, 'tcx>(\n         &self,\n@@ -225,7 +231,7 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n                 collector::MonoItemCollectionMode::Eager\n             ).0.iter()\n         );\n-        ::rustc::middle::dependency_format::calculate(tcx);\n+        //::rustc::middle::dependency_format::calculate(tcx);\n         let _ = tcx.link_args(LOCAL_CRATE);\n         let _ = tcx.native_libraries(LOCAL_CRATE);\n         for mono_item in"}, {"sha": "058e4b7841f56bdf6de0e2539978413cc18495f3", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -47,6 +47,8 @@ pub mod link;\n pub mod codegen_backend;\n pub mod symbol_names;\n pub mod symbol_names_test;\n+pub mod time_graph;\n+pub mod llvm_target_features;\n \n /// check for the #[rustc_error] annotation, which forces an\n /// error in codegen. This is used to write compile-fail tests"}, {"sha": "82cd397be232bf6fb19fb4398882f5419d9baba8", "filename": "src/librustc_codegen_utils/llvm_target_features.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Fllvm_target_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Fllvm_target_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fllvm_target_features.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -0,0 +1,117 @@\n+use rustc::session::Session;\n+\n+// WARNING: the features after applying `to_llvm_feature` must be known\n+// to LLVM or the feature detection code will walk past the end of the feature\n+// array, leading to crashes.\n+\n+const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"mclass\", Some(\"arm_target_feature\")),\n+    (\"neon\", Some(\"arm_target_feature\")),\n+    (\"v7\", Some(\"arm_target_feature\")),\n+    (\"vfp2\", Some(\"arm_target_feature\")),\n+    (\"vfp3\", Some(\"arm_target_feature\")),\n+    (\"vfp4\", Some(\"arm_target_feature\")),\n+];\n+\n+const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"fp\", Some(\"aarch64_target_feature\")),\n+    (\"neon\", Some(\"aarch64_target_feature\")),\n+    (\"sve\", Some(\"aarch64_target_feature\")),\n+    (\"crc\", Some(\"aarch64_target_feature\")),\n+    (\"crypto\", Some(\"aarch64_target_feature\")),\n+    (\"ras\", Some(\"aarch64_target_feature\")),\n+    (\"lse\", Some(\"aarch64_target_feature\")),\n+    (\"rdm\", Some(\"aarch64_target_feature\")),\n+    (\"fp16\", Some(\"aarch64_target_feature\")),\n+    (\"rcpc\", Some(\"aarch64_target_feature\")),\n+    (\"dotprod\", Some(\"aarch64_target_feature\")),\n+    (\"v8.1a\", Some(\"aarch64_target_feature\")),\n+    (\"v8.2a\", Some(\"aarch64_target_feature\")),\n+    (\"v8.3a\", Some(\"aarch64_target_feature\")),\n+];\n+\n+const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"aes\", None),\n+    (\"avx\", None),\n+    (\"avx2\", None),\n+    (\"avx512bw\", Some(\"avx512_target_feature\")),\n+    (\"avx512cd\", Some(\"avx512_target_feature\")),\n+    (\"avx512dq\", Some(\"avx512_target_feature\")),\n+    (\"avx512er\", Some(\"avx512_target_feature\")),\n+    (\"avx512f\", Some(\"avx512_target_feature\")),\n+    (\"avx512ifma\", Some(\"avx512_target_feature\")),\n+    (\"avx512pf\", Some(\"avx512_target_feature\")),\n+    (\"avx512vbmi\", Some(\"avx512_target_feature\")),\n+    (\"avx512vl\", Some(\"avx512_target_feature\")),\n+    (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n+    (\"bmi1\", None),\n+    (\"bmi2\", None),\n+    (\"fma\", None),\n+    (\"fxsr\", None),\n+    (\"lzcnt\", None),\n+    (\"mmx\", Some(\"mmx_target_feature\")),\n+    (\"pclmulqdq\", None),\n+    (\"popcnt\", None),\n+    (\"rdrand\", None),\n+    (\"rdseed\", None),\n+    (\"sha\", None),\n+    (\"sse\", None),\n+    (\"sse2\", None),\n+    (\"sse3\", None),\n+    (\"sse4.1\", None),\n+    (\"sse4.2\", None),\n+    (\"sse4a\", Some(\"sse4a_target_feature\")),\n+    (\"ssse3\", None),\n+    (\"tbm\", Some(\"tbm_target_feature\")),\n+    (\"xsave\", None),\n+    (\"xsavec\", None),\n+    (\"xsaveopt\", None),\n+    (\"xsaves\", None),\n+];\n+\n+const HEXAGON_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"hvx\", Some(\"hexagon_target_feature\")),\n+    (\"hvx-double\", Some(\"hexagon_target_feature\")),\n+];\n+\n+const POWERPC_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"altivec\", Some(\"powerpc_target_feature\")),\n+    (\"power8-altivec\", Some(\"powerpc_target_feature\")),\n+    (\"power9-altivec\", Some(\"powerpc_target_feature\")),\n+    (\"power8-vector\", Some(\"powerpc_target_feature\")),\n+    (\"power9-vector\", Some(\"powerpc_target_feature\")),\n+    (\"vsx\", Some(\"powerpc_target_feature\")),\n+];\n+\n+const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"fp64\", Some(\"mips_target_feature\")),\n+    (\"msa\", Some(\"mips_target_feature\")),\n+];\n+\n+/// When rustdoc is running, provide a list of all known features so that all their respective\n+/// primtives may be documented.\n+///\n+/// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n+/// iterator!\n+pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static str>)> {\n+    ARM_WHITELIST.iter().cloned()\n+        .chain(AARCH64_WHITELIST.iter().cloned())\n+        .chain(X86_WHITELIST.iter().cloned())\n+        .chain(HEXAGON_WHITELIST.iter().cloned())\n+        .chain(POWERPC_WHITELIST.iter().cloned())\n+        .chain(MIPS_WHITELIST.iter().cloned())\n+}\n+\n+pub fn target_feature_whitelist(sess: &Session)\n+    -> &'static [(&'static str, Option<&'static str>)]\n+{\n+    match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"aarch64\" => AARCH64_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n+        \"mips\" | \"mips64\" => MIPS_WHITELIST,\n+        \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n+        _ => &[],\n+    }\n+}"}, {"sha": "a8502682a806b718f93c6e5b7c9943d86cba759a", "filename": "src/librustc_codegen_utils/time_graph.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_codegen_utils%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Ftime_graph.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "previous_filename": "src/librustc_codegen_llvm/time_graph.rs"}, {"sha": "321d398b52100d344a8f99a7c8ad761054f5e29e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ceb1637b2500f384015578a5a6f556bcc992052/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6ceb1637b2500f384015578a5a6f556bcc992052", "patch": "@@ -375,10 +375,20 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<CodegenBackend> {\n     match file {\n         Some(ref s) => return load_backend_from_dylib(s),\n         None => {\n-            let err = format!(\"failed to load default codegen backend for `{}`, \\\n+            if !::rustc::session::config::nightly_options::is_nightly_build() {\n+                let err = format!(\"failed to load default codegen backend for `{}`, \\\n                                no appropriate codegen dylib found in `{}`\",\n                                backend_name, sysroot.display());\n-            early_error(ErrorOutputType::default(), &err);\n+                early_error(ErrorOutputType::default(), &err);\n+            } else {\n+                let warn = format!(\"no codegen-backend `{}`, \\\n+                               no appropriate dylib in `{}`. \\\n+                               Falling back to metadata_only codegen backend. \\\n+                               **This is suitable for dev purposes only**\",\n+                               backend_name, sysroot.display());\n+                early_warn(ErrorOutputType::default(), &warn);\n+                return rustc_codegen_utils::codegen_backend::MetadataOnlyCodegenBackend::new;\n+            }\n         }\n     }\n "}]}