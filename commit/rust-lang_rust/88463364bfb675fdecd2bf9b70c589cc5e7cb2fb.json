{"sha": "88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDYzMzY0YmZiNjc1ZmRlY2QyYmY5YjcwYzU4OWNjNWU3Y2IyZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-17T06:47:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-17T06:47:55Z"}, "message": "Auto merge of #30426 - gereeter:btree-rewrite, r=Gankro\n\nDespite being over 700 lines shorter, this implementation should use less memory than the previous one and is faster on at least insertions and iteration, the latter improving approximately 5x.\n\nTechnically a [breaking-change] due to removal of deprecated functions.\n\ncc @apasel422 @Gankro @goyox86\n\nFixes #27865.\n\n<!-- Reviewable:start -->\n[<img src=\"https://reviewable.io/review_button.png\" height=40 alt=\"Review on Reviewable\"/>](https://reviewable.io/reviews/rust-lang/rust/30426)\n<!-- Reviewable:end -->", "tree": {"sha": "46a9a3614144baa8c903ac1660c2ddbc7fd8c847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a9a3614144baa8c903ac1660c2ddbc7fd8c847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "html_url": "https://github.com/rust-lang/rust/commit/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "077f4eeb8485e5a1437f6e27973a907ac772b616", "url": "https://api.github.com/repos/rust-lang/rust/commits/077f4eeb8485e5a1437f6e27973a907ac772b616", "html_url": "https://github.com/rust-lang/rust/commit/077f4eeb8485e5a1437f6e27973a907ac772b616"}, {"sha": "be4128d148ae5b0edf9d547530dc5e149697b693", "url": "https://api.github.com/repos/rust-lang/rust/commits/be4128d148ae5b0edf9d547530dc5e149697b693", "html_url": "https://github.com/rust-lang/rust/commit/be4128d148ae5b0edf9d547530dc5e149697b693"}], "stats": {"total": 4511, "additions": 1916, "deletions": 2595}, "files": [{"sha": "2375a63fbd700e311c6b76bab2478ffd6f6ae8bd", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 940, "deletions": 1216, "changes": 2156, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,32 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This implementation is largely based on the high-level description and analysis of B-Trees\n-// found in *Open Data Structures* (ODS). Although our implementation does not use any of\n-// the source found in ODS, if one wishes to review the high-level design of this structure, it\n-// can be freely downloaded at http://opendatastructures.org/. Its contents are as of this\n-// writing (August 2014) freely licensed under the following Creative Commons Attribution\n-// License: [CC BY 2.5 CA](http://creativecommons.org/licenses/by/2.5/ca/).\n-\n-use self::Entry::*;\n-\n use core::cmp::Ordering;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Map, FromIterator};\n+use core::iter::FromIterator;\n use core::ops::Index;\n-use core::{fmt, mem, usize};\n-use Bound::{self, Included, Excluded, Unbounded};\n+use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use vec_deque::VecDeque;\n+use Bound::{self, Included, Excluded, Unbounded};\n+\n+use super::node::{self, NodeRef, Handle, marker};\n+use super::search;\n \n-use self::Continuation::{Continue, Finished};\n-use self::StackOp::*;\n-use super::node::ForceResult::{Leaf, Internal};\n-use super::node::TraversalItem::{self, Elem, Edge};\n-use super::node::{Traversal, MutTraversal, MoveTraversal};\n-use super::node::{self, Node, Found, GoDown};\n+use super::node::InsertResult::*;\n+use super::node::ForceResult::*;\n+use super::search::SearchResult::*;\n+use self::UnderflowResult::*;\n+use self::Entry::*;\n \n /// A map based on a B-Tree.\n ///\n@@ -65,60 +57,173 @@ use super::node::{self, Node, Found, GoDown};\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n /// any other key, as determined by the `Ord` trait, changes while it is in the map. This is\n /// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: Node<K, V>,\n-    length: usize,\n-    depth: usize,\n-    b: usize,\n+    root: node::Root<K, V>,\n+    length: usize\n+}\n+\n+impl<K, V> Drop for BTreeMap<K, V> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        unsafe {\n+            for _ in ptr::read(self).into_iter() { }\n+        }\n+    }\n+}\n+\n+impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n+    fn clone(&self) -> BTreeMap<K, V> {\n+        fn clone_subtree<K: Clone, V: Clone>(\n+                node: node::NodeRef<marker::Immut, K, V, marker::LeafOrInternal>)\n+                -> BTreeMap<K, V> {\n+\n+            match node.force() {\n+                Leaf(leaf) => {\n+                    let mut out_tree = BTreeMap {\n+                        root: node::Root::new_leaf(),\n+                        length: 0\n+                    };\n+\n+                    {\n+                        let mut out_node = match out_tree.root.as_mut().force() {\n+                            Leaf(leaf) => leaf,\n+                            Internal(_) => unreachable!()\n+                        };\n+\n+                        let mut in_edge = leaf.first_edge();\n+                        while let Ok(kv) = in_edge.right_kv() {\n+                            let (k, v) = kv.into_kv();\n+                            in_edge = kv.right_edge();\n+\n+                            out_node.push(k.clone(), v.clone());\n+                            out_tree.length += 1;\n+                        }\n+                    }\n+\n+                    out_tree\n+                },\n+                Internal(internal) => {\n+                    let mut out_tree = clone_subtree(internal.first_edge().descend());\n+\n+                    {\n+                        let mut out_node = out_tree.root.push_level();\n+                        let mut in_edge = internal.first_edge();\n+                        while let Ok(kv) = in_edge.right_kv() {\n+                            let (k, v) = kv.into_kv();\n+                            in_edge = kv.right_edge();\n+\n+                            let k = (*k).clone();\n+                            let v = (*v).clone();\n+                            let subtree = clone_subtree(in_edge.descend());\n+\n+                            // We can't destructure subtree directly\n+                            // because BTreeMap implements Drop\n+                            let (subroot, sublength) = unsafe {\n+                                let root = ptr::read(&subtree.root);\n+                                let length = subtree.length;\n+                                mem::forget(subtree);\n+                                (root, length)\n+                            };\n+\n+                            out_node.push(k, v, subroot);\n+                            out_tree.length += 1 + sublength;\n+                        }\n+                    }\n+\n+                    out_tree\n+                }\n+            }\n+        }\n+\n+        clone_subtree(self.root.as_ref())\n+    }\n }\n \n-/// An abstract base over-which all other BTree iterators are built.\n-#[derive(Clone)]\n-struct AbsIter<T> {\n-    traversals: VecDeque<T>,\n-    size: usize,\n+impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n+    where K: Borrow<Q> + Ord,\n+          Q: Ord\n+{\n+    type Key = K;\n+\n+    fn get(&self, key: &Q) -> Option<&K> {\n+        match search::search_tree(self.root.as_ref(), key) {\n+            Found(handle) => Some(handle.into_kv().0),\n+            GoDown(_) => None\n+        }\n+    }\n+\n+    fn take(&mut self, key: &Q) -> Option<K> {\n+        match search::search_tree(self.root.as_mut(), key) {\n+            Found(handle) => {\n+                Some(OccupiedEntry {\n+                    handle: handle,\n+                    length: &mut self.length\n+                }.remove_kv().0)\n+            },\n+            GoDown(_) => None\n+        }\n+    }\n+\n+    fn replace(&mut self, key: K) -> Option<K> {\n+        match search::search_tree::<marker::Mut, K, (), K>(self.root.as_mut(), &key) {\n+            Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n+            GoDown(handle) => {\n+                VacantEntry {\n+                    key: key,\n+                    handle: handle,\n+                    length: &mut self.length\n+                }.insert(());\n+                None\n+            }\n+        }\n+    }\n }\n \n /// An iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>,\n+    range: Range<'a, K, V>,\n+    length: usize\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>,\n+    range: RangeMut<'a, K, V>,\n+    length: usize\n }\n \n /// An owning iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: AbsIter<MoveTraversal<K, V>>,\n+    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    length: usize\n }\n \n /// An iterator over a BTreeMap's keys.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>,\n+    inner: Iter<'a, K, V>,\n }\n \n /// An iterator over a BTreeMap's values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>,\n+    inner: Iter<'a, K, V>,\n }\n \n /// An iterator over a sub-range of BTreeMap's entries.\n pub struct Range<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>,\n+    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>\n }\n \n /// A mutable iterator over a sub-range of BTreeMap's entries.\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>,\n+    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n@@ -141,28 +246,30 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n-    stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n+    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    length: &'a mut usize\n }\n \n /// An occupied Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n+    handle: Handle<NodeRef<\n+        marker::Mut<'a>,\n+        K, V,\n+        marker::LeafOrInternal\n+    >, marker::KV>,\n+\n+    length: &'a mut usize\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n     pub fn new() -> BTreeMap<K, V> {\n         BTreeMap {\n-            length: 0,\n-            depth: 1,\n-            root: Node::make_leaf_root(6),\n-            // FIXME(Gankro): Tune this as a function of size_of<K/V>?\n-            b: 6,\n+            root: node::Root::new_leaf(),\n+            length: 0\n         }\n-\n     }\n \n     /// Clears the map, removing all values.\n@@ -179,18 +286,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::new()) {}\n+        // FIXME(gereeter) .clear() allocates\n+        *self = BTreeMap::new();\n     }\n \n-    // Searching in a B-Tree is pretty straightforward.\n-    //\n-    // Start at the root. Try to find the key in the current node. If we find it, return it.\n-    // If it's not in there, follow the edge *before* the smallest key larger than\n-    // the search key. If no such key exists (they're *all* smaller), then just take the last\n-    // edge in the node. If we're in a leaf and we don't find our key, then it's not\n-    // in the tree.\n-\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -207,24 +306,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n-    {\n-        let mut cur_node = &self.root;\n-        loop {\n-            match Node::search(cur_node, key) {\n-                Found(handle) => return Some(handle.into_kv().1),\n-                GoDown(handle) => {\n-                    match handle.force() {\n-                        Leaf(_) => return None,\n-                        Internal(internal_handle) => {\n-                            cur_node = internal_handle.into_edge();\n-                            continue;\n-                        }\n-                    }\n-                }\n-            }\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n+        match search::search_tree(self.root.as_ref(), key) {\n+            Found(handle) => Some(handle.into_kv().1),\n+            GoDown(_) => None\n         }\n     }\n \n@@ -244,10 +329,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n-        where K: Borrow<Q>,\n-              Q: Ord\n-    {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n         self.get(key).is_some()\n     }\n \n@@ -270,55 +352,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n-    {\n-        // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n-        let mut temp_node = &mut self.root;\n-        loop {\n-            let cur_node = temp_node;\n-            match Node::search(cur_node, key) {\n-                Found(handle) => return Some(handle.into_kv_mut().1),\n-                GoDown(handle) => {\n-                    match handle.force() {\n-                        Leaf(_) => return None,\n-                        Internal(internal_handle) => {\n-                            temp_node = internal_handle.into_edge_mut();\n-                            continue;\n-                        }\n-                    }\n-                }\n-            }\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n+        match search::search_tree(self.root.as_mut(), key) {\n+            Found(handle) => Some(handle.into_kv_mut().1),\n+            GoDown(_) => None\n         }\n     }\n \n-    // Insertion in a B-Tree is a bit complicated.\n-    //\n-    // First we do the same kind of search described in `find`. But we need to maintain a stack of\n-    // all the nodes/edges in our search path. If we find a match for the key we're trying to\n-    // insert, just swap the vals and return the old ones. However, when we bottom out in a leaf,\n-    // we attempt to insert our key-value pair at the same location we would want to follow another\n-    // edge.\n-    //\n-    // If the node has room, then this is done in the obvious way by shifting elements. However,\n-    // if the node itself is full, we split node into two, and give its median key-value\n-    // pair to its parent to insert the new node with. Of course, the parent may also be\n-    // full, and insertion can propagate until we reach the root. If we reach the root, and\n-    // it is *also* full, then we split the root and place the two nodes under a newly made root.\n-    //\n-    // Note that we subtly deviate from Open Data Structures in our implementation of split.\n-    // ODS describes inserting into the node *regardless* of its capacity, and then\n-    // splitting *afterwards* if it happens to be overfull. However, this is inefficient.\n-    // Instead, we split beforehand, and then insert the key-value pair into the appropriate\n-    // result node. This has two consequences:\n-    //\n-    // 1) While ODS produces a left node of size B-1, and a right node of size B,\n-    // we may potentially reverse this. However, this shouldn't effect the analysis.\n-    //\n-    // 2) While ODS may potentially return the pair we *just* inserted after\n-    // the split, we will never do this. Again, this shouldn't effect the analysis.\n-\n     /// Inserts a key-value pair into the map.\n     ///\n     /// If the map did not have this key present, `None` is returned.\n@@ -343,98 +383,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n-        // This is a stack of rawptrs to nodes paired with indices, respectively\n-        // representing the nodes and edges of our search path. We have to store rawptrs\n-        // because as far as Rust is concerned, we can mutate aliased data with such a\n-        // stack. It is of course correct, but what it doesn't know is that we will only\n-        // be popping and using these ptrs one at a time in child-to-parent order. The alternative\n-        // to doing this is to take the Nodes from their parents. This actually makes\n-        // borrowck *really* happy and everything is pretty smooth. However, this creates\n-        // *tons* of pointless writes, and requires us to always walk all the way back to\n-        // the root after an insertion, even if we only needed to change a leaf. Therefore,\n-        // we accept this potential unsafety and complexity in the name of performance.\n-        //\n-        // Regardless, the actual dangerous logic is completely abstracted away from BTreeMap\n-        // by the stack module. All it can do is immutably read nodes, and ask the search stack\n-        // to proceed down some edge by index. This makes the search logic we'll be reusing in a\n-        // few different methods much neater, and of course drastically improves safety.\n-        let mut stack = stack::PartialSearchStack::new(self);\n-\n-        loop {\n-            let result = stack.with(move |pusher, node| {\n-                // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n-                // actual nodes for us\n-                match Node::search(node, &key) {\n-                    Found(mut handle) => {\n-                        // Perfect match, swap the values and return the old one\n-                        mem::swap(handle.val_mut(), &mut value);\n-                        Finished(Some(value))\n-                    }\n-                    GoDown(handle) => {\n-                        // We need to keep searching, try to get the search stack\n-                        // to go down further\n-                        match handle.force() {\n-                            Leaf(leaf_handle) => {\n-                                // We've reached a leaf, perform the insertion here\n-                                pusher.seal(leaf_handle).insert(key, value);\n-                                Finished(None)\n-                            }\n-                            Internal(internal_handle) => {\n-                                // We've found the subtree to insert this key/value pair in,\n-                                // keep searching\n-                                Continue((pusher.push(internal_handle), key, value))\n-                            }\n-                        }\n-                    }\n-                }\n-            });\n-            match result {\n-                Finished(ret) => return ret,\n-                Continue((new_stack, renewed_key, renewed_val)) => {\n-                    stack = new_stack;\n-                    key = renewed_key;\n-                    value = renewed_val;\n-                }\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+        match self.entry(key) {\n+            Occupied(mut entry) => Some(entry.insert(value)),\n+            Vacant(entry) => {\n+                entry.insert(value);\n+                None\n             }\n         }\n     }\n \n-    // Deletion is the most complicated operation for a B-Tree.\n-    //\n-    // First we do the same kind of search described in\n-    // `find`. But we need to maintain a stack of all the nodes/edges in our search path.\n-    // If we don't find the key, then we just return `None` and do nothing. If we do find the\n-    // key, we perform two operations: remove the item, and then possibly handle underflow.\n-    //\n-    // # removing the item\n-    //      If the node is a leaf, we just remove the item, and shift\n-    //      any items after it back to fill the hole.\n-    //\n-    //      If the node is an internal node, we *swap* the item with the smallest item in\n-    //      in its right subtree (which must reside in a leaf), and then revert to the leaf\n-    //      case\n-    //\n-    // # handling underflow\n-    //      After removing an item, there may be too few items in the node. We want nodes\n-    //      to be mostly full for efficiency, although we make an exception for the root, which\n-    //      may have as few as one item. If this is the case, we may first try to steal\n-    //      an item from our left or right neighbour.\n-    //\n-    //      To steal from the left (right) neighbour,\n-    //      we take the largest (smallest) item and child from it. We then swap the taken item\n-    //      with the item in their mutual parent that separates them, and then insert the\n-    //      parent's item and the taken child into the first (last) index of the underflowed node.\n-    //\n-    //      However, stealing has the possibility of underflowing our neighbour. If this is the\n-    //      case, we instead *merge* with our neighbour. This of course reduces the number of\n-    //      children in the parent. Therefore, we also steal the item that separates the now\n-    //      merged nodes, and insert it into the merged node.\n-    //\n-    //      Merging may cause the parent to underflow. If this is the case, then we must repeat\n-    //      the underflow handling process on the parent. If merging merges the last two children\n-    //      of the root, then we replace the root with the merged node.\n-\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -452,73 +410,201 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n-        where K: Borrow<Q>,\n-              Q: Ord\n-    {\n-        // See `swap` for a more thorough description of the stuff going on in here\n-        let mut stack = stack::PartialSearchStack::new(self);\n-        loop {\n-            let result = stack.with(move |pusher, node| {\n-                match Node::search(node, key) {\n-                    Found(handle) => {\n-                        // Perfect match. Terminate the stack here, and remove the entry\n-                        Finished(Some(pusher.seal(handle).remove()))\n-                    }\n-                    GoDown(handle) => {\n-                        // We need to keep searching, try to go down the next edge\n-                        match handle.force() {\n-                            // We're at a leaf; the key isn't in here\n-                            Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n-                        }\n-                    }\n-                }\n-            });\n-            match result {\n-                Finished(ret) => return ret.map(|(_, v)| v),\n-                Continue(new_stack) => stack = new_stack,\n-            }\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n+        match search::search_tree(self.root.as_mut(), key) {\n+            Found(handle) => {\n+                Some(OccupiedEntry {\n+                    handle: handle,\n+                    length: &mut self.length\n+                }.remove())\n+            },\n+            GoDown(_) => None\n         }\n     }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> IntoIterator for BTreeMap<K, V> {\n-    type Item = (K, V);\n-    type IntoIter = IntoIter<K, V>;\n \n-    /// Gets an owning iterator over the entries of the map.\n+    /// Constructs a double-ended iterator over a sub-range of elements in the map, starting\n+    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n+    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n+    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(btree_range, collections_bound)]\n+    ///\n     /// use std::collections::BTreeMap;\n+    /// use std::collections::Bound::{Included, Unbounded};\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(2, \"b\");\n-    /// map.insert(3, \"c\");\n-    ///\n-    /// for (key, value) in map.into_iter() {\n+    /// map.insert(3, \"a\");\n+    /// map.insert(5, \"b\");\n+    /// map.insert(8, \"c\");\n+    /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n+    /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    fn into_iter(self) -> IntoIter<K, V> {\n-        let len = self.len();\n-        let mut lca = VecDeque::new();\n-        lca.push_back(Traverse::traverse(self.root));\n-        IntoIter {\n-            inner: AbsIter {\n-                traversals: lca,\n-                size: len,\n+    #[unstable(feature = \"btree_range\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27787\")]\n+    pub fn range<Min: ?Sized + Ord, Max: ?Sized + Ord>(&self,\n+                                                       min: Bound<&Min>,\n+                                                       max: Bound<&Max>)\n+                                                       -> Range<K, V>\n+        where K: Borrow<Min> + Borrow<Max>,\n+    {\n+        let front = match min {\n+            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n+                Found(kv_handle) => match kv_handle.left_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => last_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n+                Found(kv_handle) => match kv_handle.right_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => first_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Unbounded => first_leaf_edge(self.root.as_ref())\n+        };\n+\n+        let back = match max {\n+            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n+                Found(kv_handle) => match kv_handle.right_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => first_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n+                Found(kv_handle) => match kv_handle.left_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => last_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Unbounded => last_leaf_edge(self.root.as_ref())\n+        };\n+\n+        Range {\n+            front: front,\n+            back: back\n+        }\n+    }\n+\n+    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n+    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n+    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n+    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(btree_range, collections_bound)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::Bound::{Included, Excluded};\n+    ///\n+    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"].iter()\n+    ///                                                                       .map(|&s| (s, 0))\n+    ///                                                                       .collect();\n+    /// for (_, balance) in map.range_mut(Included(\"B\"), Excluded(\"Cheryl\")) {\n+    ///     *balance += 100;\n+    /// }\n+    /// for (name, balance) in &map {\n+    ///     println!(\"{} => {}\", name, balance);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"btree_range\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27787\")]\n+    pub fn range_mut<Min: ?Sized + Ord, Max: ?Sized + Ord>(&mut self,\n+                                                           min: Bound<&Min>,\n+                                                           max: Bound<&Max>)\n+                                                           -> RangeMut<K, V>\n+        where K: Borrow<Min> + Borrow<Max>,\n+    {\n+        let root1 = self.root.as_mut();\n+        let root2 = unsafe { ptr::read(&root1) };\n+\n+        let front = match min {\n+            Included(key) => match search::search_tree(root1, key) {\n+                Found(kv_handle) => match kv_handle.left_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => last_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Excluded(key) => match search::search_tree(root1, key) {\n+                Found(kv_handle) => match kv_handle.right_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => first_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Unbounded => first_leaf_edge(root1)\n+        };\n+\n+        let back = match max {\n+            Included(key) => match search::search_tree(root2, key) {\n+                Found(kv_handle) => match kv_handle.right_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => first_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n+            },\n+            Excluded(key) => match search::search_tree(root2, key) {\n+                Found(kv_handle) => match kv_handle.left_edge().force() {\n+                    Leaf(bottom) => bottom,\n+                    Internal(internal) => last_leaf_edge(internal.descend())\n+                },\n+                GoDown(bottom) => bottom\n             },\n+            Unbounded => last_leaf_edge(root2)\n+        };\n+\n+        RangeMut {\n+            front: front,\n+            back: back\n+        }\n+    }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// // count the number of occurrences of letters in the vec\n+    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n+    ///     *count.entry(x).or_insert(0) += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(count[\"a\"], 3);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n+        match search::search_tree(self.root.as_mut(), &key) {\n+            Found(handle) => Occupied(OccupiedEntry {\n+                handle: handle,\n+                length: &mut self.length\n+            }),\n+            GoDown(handle) => Vacant(VacantEntry {\n+                key: key,\n+                handle: handle,\n+                length: &mut self.length\n+            })\n         }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n+impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -527,769 +613,570 @@ impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n-    type Item = (&'a K, &'a mut V);\n-    type IntoIter = IterMut<'a, K, V>;\n+impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n \n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n-        self.iter_mut()\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.length == 0 {\n+            None\n+        } else {\n+            self.length -= 1;\n+            unsafe { Some(self.range.next_unchecked()) }\n+        }\n     }\n-}\n \n-/// A helper enum useful for deciding whether to continue a loop since we can't\n-/// return from a closure\n-enum Continuation<A, B> {\n-    Continue(A),\n-    Finished(B),\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.length, Some(self.length))\n+    }\n }\n \n-/// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n-/// to nodes. By using this module much better safety guarantees can be made, and more search\n-/// boilerplate gets cut out.\n-mod stack {\n-    use core::marker;\n-    use core::mem;\n-    use core::ops::{Deref, DerefMut};\n-    use super::BTreeMap;\n-    use super::super::node::{self, Node, Fit, Split, Internal, Leaf};\n-    use super::super::node::handle;\n-    use vec::Vec;\n-\n-    struct InvariantLifetime<'id>(marker::PhantomData<::core::cell::Cell<&'id ()>>);\n-\n-    impl<'id> InvariantLifetime<'id> {\n-        fn new() -> InvariantLifetime<'id> {\n-            InvariantLifetime(marker::PhantomData)\n+impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.length == 0 {\n+            None\n+        } else {\n+            self.length -= 1;\n+            unsafe { Some(self.range.next_back_unchecked()) }\n         }\n     }\n+}\n \n-    /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n-    /// parameter is invariant. This means that wherever an `IdRef` is expected, only an `IdRef`\n-    /// with the exact requested lifetime can be used. This is in contrast to normal references,\n-    /// where `&'static` can be used in any function expecting any lifetime reference.\n-    pub struct IdRef<'id, T: 'id> {\n-        inner: &'id mut T,\n-        _marker: InvariantLifetime<'id>,\n-    }\n-\n-    impl<'id, T> Deref for IdRef<'id, T> {\n-        type Target = T;\n+impl<'a, K: 'a, V: 'a> ExactSizeIterator for Iter<'a, K, V> {\n+    fn len(&self) -> usize { self.length }\n+}\n \n-        fn deref(&self) -> &T {\n-            &*self.inner\n+impl<'a, K, V> Clone for Iter<'a, K, V> {\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter {\n+            range: self.range.clone(),\n+            length: self.length\n         }\n     }\n+}\n \n-    impl<'id, T> DerefMut for IdRef<'id, T> {\n-        fn deref_mut(&mut self) -> &mut T {\n-            &mut *self.inner\n-        }\n+impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n+    type Item = (&'a K, &'a mut V);\n+    type IntoIter = IterMut<'a, K, V>;\n+\n+    fn into_iter(self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n     }\n+}\n \n-    type StackItem<K, V> = node::Handle<*mut Node<K, V>, handle::Edge, handle::Internal>;\n-    type Stack<K, V> = Vec<StackItem<K, V>>;\n+impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n \n-    /// A `PartialSearchStack` handles the construction of a search stack.\n-    pub struct PartialSearchStack<'a, K: 'a, V: 'a> {\n-        map: &'a mut BTreeMap<K, V>,\n-        stack: Stack<K, V>,\n-        next: *mut Node<K, V>,\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        if self.length == 0 {\n+            None\n+        } else {\n+            self.length -= 1;\n+            unsafe { Some(self.range.next_unchecked()) }\n+        }\n     }\n \n-    /// A `SearchStack` represents a full path to an element or an edge of interest. It provides\n-    /// methods depending on the type of what the path points to for removing an element, inserting\n-    /// a new element, and manipulating to element at the top of the stack.\n-    pub struct SearchStack<'a, K: 'a, V: 'a, Type, NodeType> {\n-        map: &'a mut BTreeMap<K, V>,\n-        stack: Stack<K, V>,\n-        top: node::Handle<*mut Node<K, V>, Type, NodeType>,\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.length, Some(self.length))\n     }\n+}\n \n-    /// A `PartialSearchStack` that doesn't hold a reference to the next node, and is just\n-    /// just waiting for a `Handle` to that next node to be pushed. See `PartialSearchStack::with`\n-    /// for more details.\n-    pub struct Pusher<'id, 'a, K: 'a, V: 'a> {\n-        map: &'a mut BTreeMap<K, V>,\n-        stack: Stack<K, V>,\n-        _marker: InvariantLifetime<'id>,\n+impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        if self.length == 0 {\n+            None\n+        } else {\n+            self.length -= 1;\n+            unsafe { Some(self.range.next_back_unchecked()) }\n+        }\n     }\n+}\n \n-    impl<'a, K, V> PartialSearchStack<'a, K, V> {\n-        /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n-        /// root of the tree.\n-        pub fn new(map: &'a mut BTreeMap<K, V>) -> PartialSearchStack<'a, K, V> {\n-            let depth = map.depth;\n+impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n+    fn len(&self) -> usize { self.length }\n+}\n \n-            PartialSearchStack {\n-                next: &mut map.root as *mut _,\n-                map: map,\n-                stack: Vec::with_capacity(depth),\n-            }\n-        }\n+impl<K, V> IntoIterator for BTreeMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<K, V>;\n \n-        /// Breaks up the stack into a `Pusher` and the next `Node`, allowing the given closure\n-        /// to interact with, search, and finally push the `Node` onto the stack. The passed in\n-        /// closure must be polymorphic on the `'id` lifetime parameter, as this statically\n-        /// ensures that only `Handle`s from the correct `Node` can be pushed.\n-        ///\n-        /// The reason this works is that the `Pusher` has an `'id` parameter, and will only accept\n-        /// handles with the same `'id`. The closure could only get references with that lifetime\n-        /// through its arguments or through some other `IdRef` that it has lying around. However,\n-        /// no other `IdRef` could possibly work - because the `'id` is held in an invariant\n-        /// parameter, it would need to have precisely the correct lifetime, which would mean that\n-        /// at least one of the calls to `with` wouldn't be properly polymorphic, wanting a\n-        /// specific lifetime instead of the one that `with` chooses to give it.\n-        ///\n-        /// See also Haskell's `ST` monad, which uses a similar trick.\n-        pub fn with<T, F: for<'id> FnOnce(Pusher<'id, 'a, K, V>,\n-                                          IdRef<'id, Node<K, V>>) -> T>(self, closure: F) -> T {\n-            let pusher = Pusher {\n-                map: self.map,\n-                stack: self.stack,\n-                _marker: InvariantLifetime::new(),\n-            };\n-            let node = IdRef {\n-                inner: unsafe { &mut *self.next },\n-                _marker: InvariantLifetime::new(),\n-            };\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        let root1 = unsafe { ptr::read(&self.root).into_ref() };\n+        let root2 = unsafe { ptr::read(&self.root).into_ref() };\n+        let len = self.length;\n+        mem::forget(self);\n \n-            closure(pusher, node)\n+        IntoIter {\n+            front: first_leaf_edge(root1),\n+            back: last_leaf_edge(root2),\n+            length: len\n         }\n     }\n+}\n \n-    impl<'id, 'a, K, V> Pusher<'id, 'a, K, V> {\n-        /// Pushes the requested child of the stack's current top on top of the stack. If the child\n-        /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n-        /// yielded.\n-        pub fn push(mut self,\n-                    mut edge: node::Handle<IdRef<'id, Node<K, V>>, handle::Edge, handle::Internal>)\n-                    -> PartialSearchStack<'a, K, V> {\n-            self.stack.push(edge.as_raw());\n-            PartialSearchStack {\n-                map: self.map,\n-                stack: self.stack,\n-                next: edge.edge_mut() as *mut _,\n-            }\n-        }\n-\n-        /// Converts the PartialSearchStack into a SearchStack.\n-        pub fn seal<Type, NodeType>(self,\n-                                    mut handle: node::Handle<IdRef<'id, Node<K, V>>,\n-                                                             Type,\n-                                                             NodeType>)\n-                                    -> SearchStack<'a, K, V, Type, NodeType> {\n-            SearchStack {\n-                map: self.map,\n-                stack: self.stack,\n-                top: handle.as_raw(),\n+impl<K, V> Drop for IntoIter<K, V> {\n+    fn drop(&mut self) {\n+        for _ in &mut *self { }\n+        unsafe {\n+            let leaf_node = ptr::read(&self.front).into_node();\n+            if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n+                let mut cur_node = first_parent.into_node();\n+                while let Some(parent) = cur_node.deallocate_and_ascend() {\n+                    cur_node = parent.into_node()\n+                }\n             }\n         }\n     }\n+}\n \n-    impl<'a, K, V, NodeType> SearchStack<'a, K, V, handle::KV, NodeType> {\n-        /// Gets a reference to the value the stack points to.\n-        pub fn peek(&self) -> &V {\n-            unsafe { self.top.from_raw().into_kv().1 }\n-        }\n-\n-        /// Gets a mutable reference to the value the stack points to.\n-        pub fn peek_mut(&mut self) -> &mut V {\n-            unsafe { self.top.from_raw_mut().into_kv_mut().1 }\n-        }\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (K, V);\n \n-        /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n-        /// tied to the original tree.\n-        pub fn into_top(mut self) -> &'a mut V {\n-            unsafe { &mut *(self.top.from_raw_mut().val_mut() as *mut V) }\n+    fn next(&mut self) -> Option<(K, V)> {\n+        if self.length == 0 {\n+            return None;\n+        } else {\n+            self.length -= 1;\n         }\n-    }\n \n-    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n-        /// Removes the key and value in the top element of the stack, then handles underflows as\n-        /// described in BTree's pop function.\n-        fn remove_leaf(mut self) -> (K, V) {\n-            self.map.length -= 1;\n+        let handle = unsafe { ptr::read(&self.front) };\n \n-            // Remove the key-value pair from the leaf that this search stack points to.\n-            // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n-            // to avoid ownership issues.\n-            let (key_val, mut underflow) = unsafe {\n-                let key_val = self.top.from_raw_mut().remove_as_leaf();\n-                let underflow = self.top.from_raw().node().is_underfull();\n-                (key_val, underflow)\n-            };\n+        let mut cur_handle = match handle.right_kv() {\n+            Ok(kv) => {\n+                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                self.front = kv.right_edge();\n+                return Some((k, v));\n+            },\n+            Err(last_edge) => unsafe {\n+                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+            }\n+        };\n \n-            loop {\n-                match self.stack.pop() {\n-                    None => {\n-                        // We've reached the root, so no matter what, we're done. We manually\n-                        // access the root via the tree itself to avoid creating any dangling\n-                        // pointers.\n-                        if self.map.root.is_empty() && !self.map.root.is_leaf() {\n-                            // We've emptied out the root, so make its only child the new root.\n-                            // If it's a leaf, we just let it become empty.\n-                            self.map.depth -= 1;\n-                            self.map.root.hoist_lone_child();\n-                        }\n-                        return key_val;\n-                    }\n-                    Some(mut handle) => {\n-                        if underflow {\n-                            // Underflow! Handle it!\n-                            unsafe {\n-                                handle.from_raw_mut().handle_underflow();\n-                                underflow = handle.from_raw().node().is_underfull();\n-                            }\n-                        } else {\n-                            // All done!\n-                            return key_val;\n-                        }\n-                    }\n+        loop {\n+            match cur_handle.right_kv() {\n+                Ok(kv) => {\n+                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                    self.front = first_leaf_edge(kv.right_edge().descend());\n+                    return Some((k, v));\n+                },\n+                Err(last_edge) => unsafe {\n+                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n                 }\n             }\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::LeafOrInternal> {\n-        /// Removes the key and value in the top element of the stack, then handles underflows as\n-        /// described in BTree's pop function.\n-        pub fn remove(self) -> (K, V) {\n-            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n-            // in a BTree. Note that this may put the tree in an inconsistent state (further\n-            // described in into_leaf's comments), but this is immediately fixed by the\n-            // removing the value we want to remove\n-            self.into_leaf().remove_leaf()\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.length, Some(self.length))\n+    }\n+}\n+\n+impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n+    fn next_back(&mut self) -> Option<(K, V)> {\n+        if self.length == 0 {\n+            return None;\n+        } else {\n+            self.length -= 1;\n         }\n \n-        /// Subroutine for removal. Takes a search stack for a key that might terminate at an\n-        /// internal node, and mutates the tree and search stack to *make* it a search stack\n-        /// for that same key that *does* terminates at a leaf. If the mutation occurs, then this\n-        /// leaves the tree in an inconsistent state that must be repaired by the caller by\n-        /// removing the entry in question. Specifically the key-value pair and its successor will\n-        /// become swapped.\n-        fn into_leaf(mut self) -> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n-            unsafe {\n-                let mut top_raw = self.top;\n-                let mut top = top_raw.from_raw_mut();\n-\n-                let key_ptr = top.key_mut() as *mut _;\n-                let val_ptr = top.val_mut() as *mut _;\n-\n-                // Try to go into the right subtree of the found key to find its successor\n-                match top.force() {\n-                    Leaf(mut leaf_handle) => {\n-                        // We're a proper leaf stack, nothing to do\n-                        return SearchStack {\n-                            map: self.map,\n-                            stack: self.stack,\n-                            top: leaf_handle.as_raw(),\n-                        };\n-                    }\n-                    Internal(mut internal_handle) => {\n-                        let mut right_handle = internal_handle.right_edge();\n-\n-                        // We're not a proper leaf stack, let's get to work.\n-                        self.stack.push(right_handle.as_raw());\n-\n-                        let mut temp_node = right_handle.edge_mut();\n-                        loop {\n-                            // Walk into the smallest subtree of this node\n-                            let node = temp_node;\n-\n-                            match node.kv_handle(0).force() {\n-                                Leaf(mut handle) => {\n-                                    // This node is a leaf, do the swap and return\n-                                    mem::swap(handle.key_mut(), &mut *key_ptr);\n-                                    mem::swap(handle.val_mut(), &mut *val_ptr);\n-                                    return SearchStack {\n-                                        map: self.map,\n-                                        stack: self.stack,\n-                                        top: handle.as_raw(),\n-                                    };\n-                                }\n-                                Internal(kv_handle) => {\n-                                    // This node is internal, go deeper\n-                                    let mut handle = kv_handle.into_left_edge();\n-                                    self.stack.push(handle.as_raw());\n-                                    temp_node = handle.into_edge_mut();\n-                                }\n-                            }\n-                        }\n-                    }\n+        let handle = unsafe { ptr::read(&self.back) };\n+\n+        let mut cur_handle = match handle.left_kv() {\n+            Ok(kv) => {\n+                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                self.back = kv.left_edge();\n+                return Some((k, v));\n+            },\n+            Err(last_edge) => unsafe {\n+                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+            }\n+        };\n+\n+        loop {\n+            match cur_handle.left_kv() {\n+                Ok(kv) => {\n+                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+                    self.back = last_leaf_edge(kv.left_edge().descend());\n+                    return Some((k, v));\n+                },\n+                Err(last_edge) => unsafe {\n+                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n                 }\n             }\n         }\n     }\n+}\n \n-    impl<'a, K, V> SearchStack<'a, K, V, handle::Edge, handle::Leaf> {\n-        /// Inserts the key and value into the top element in the stack, and if that node has to\n-        /// split recursively inserts the split contents into the next element stack until\n-        /// splits stop.\n-        ///\n-        /// Assumes that the stack represents a search path from the root to a leaf.\n-        ///\n-        /// An &mut V is returned to the inserted value, for callers that want a reference to this.\n-        pub fn insert(mut self, key: K, val: V) -> &'a mut V {\n-            unsafe {\n-                self.map.length += 1;\n-\n-                // Insert the key and value into the leaf at the top of the stack\n-                let (mut insertion, inserted_ptr) = self.top\n-                                                        .from_raw_mut()\n-                                                        .insert_as_leaf(key, val);\n-\n-                loop {\n-                    match insertion {\n-                        Fit => {\n-                            // The last insertion went off without a hitch, no splits! We can stop\n-                            // inserting now.\n-                            return &mut *inserted_ptr;\n-                        }\n-                        Split(key, val, right) => {\n-                            match self.stack.pop() {\n-                                // The last insertion triggered a split, so get the next element on\n-                                // the stack to recursively insert the split node into.\n-                                None => {\n-                                    // The stack was empty; we've split the root, and need to make a\n-                                    // a new one. This is done in-place because we can't move the\n-                                    // root out of a reference to the tree.\n-                                    Node::make_internal_root(&mut self.map.root,\n-                                                             self.map.b,\n-                                                             key,\n-                                                             val,\n-                                                             right);\n-\n-                                    self.map.depth += 1;\n-                                    return &mut *inserted_ptr;\n-                                }\n-                                Some(mut handle) => {\n-                                    // The stack wasn't empty, do the insertion and recurse\n-                                    insertion = handle.from_raw_mut()\n-                                                      .insert_as_internal(key, val, right);\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n+impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n+    fn len(&self) -> usize { self.length }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n-        let mut map = BTreeMap::new();\n-        map.extend(iter);\n-        map\n-    }\n-}\n+impl<'a, K, V> Iterator for Keys<'a, K, V> {\n+    type Item = &'a K;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n-    #[inline]\n-    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n+    fn next(&mut self) -> Option<&'a K> {\n+        self.inner.next().map(|(k, _)| k)\n     }\n-}\n \n-#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n-    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        for elt in self {\n-            elt.hash(state);\n-        }\n+impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n+    fn next_back(&mut self) -> Option<&'a K> {\n+        self.inner.next_back().map(|(k, _)| k)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    fn default() -> BTreeMap<K, V> {\n-        BTreeMap::new()\n+impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n-    fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n-        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n+impl<'a, K, V> Clone for Keys<'a, K, V> {\n+    fn clone(&self) -> Keys<'a, K, V> {\n+        Keys {\n+            inner: self.inner.clone()\n+        }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n-        self.iter().partial_cmp(other.iter())\n+    fn next(&mut self) -> Option<&'a V> {\n+        self.inner.next().map(|(_, v)| v)\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n-    #[inline]\n-    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n-        self.iter().cmp(other.iter())\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_map().entries(self.iter()).finish()\n+impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n+    fn next_back(&mut self) -> Option<&'a V> {\n+        self.inner.next_back().map(|(_, v)| v)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>,\n-          Q: Ord\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index(&self, key: &Q) -> &V {\n-        self.get(key).expect(\"no entry found for key\")\n+impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n     }\n }\n \n-/// Genericizes over how to get the correct type of iterator from the correct type\n-/// of Node ownership.\n-trait Traverse<N> {\n-    fn traverse(node: N) -> Self;\n-}\n-\n-impl<'a, K, V> Traverse<&'a Node<K, V>> for Traversal<'a, K, V> {\n-    fn traverse(node: &'a Node<K, V>) -> Traversal<'a, K, V> {\n-        node.iter()\n+impl<'a, K, V> Clone for Values<'a, K, V> {\n+    fn clone(&self) -> Values<'a, K, V> {\n+        Values {\n+            inner: self.inner.clone()\n+        }\n     }\n }\n \n-impl<'a, K, V> Traverse<&'a mut Node<K, V>> for MutTraversal<'a, K, V> {\n-    fn traverse(node: &'a mut Node<K, V>) -> MutTraversal<'a, K, V> {\n-        node.iter_mut()\n-    }\n-}\n+impl<'a, K, V> Iterator for Range<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n \n-impl<K, V> Traverse<Node<K, V>> for MoveTraversal<K, V> {\n-    fn traverse(node: Node<K, V>) -> MoveTraversal<K, V> {\n-        node.into_iter()\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.front == self.back {\n+            None\n+        } else {\n+            unsafe { Some(self.next_unchecked()) }\n+        }\n     }\n }\n \n-/// Represents an operation to perform inside the following iterator methods.\n-/// This is necessary to use in `next` because we want to modify `self.traversals` inside\n-/// a match that borrows it. Similarly in `next_back`. Instead, we use this enum to note\n-/// what we want to do, and do it after the match.\n-enum StackOp<T> {\n-    Push(T),\n-    Pop,\n-}\n-impl<K, V, E, T> Iterator for AbsIter<T>\n-    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n-{\n-    type Item = (K, V);\n+impl<'a, K, V> Range<'a, K, V> {\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let handle = self.front;\n \n-    // Our iterator represents a queue of all ancestors of elements we have\n-    // yet to yield, from smallest to largest.  Note that the design of these\n-    // iterators permits an *arbitrary* initial pair of min and max, making\n-    // these arbitrary sub-range iterators.\n-    fn next(&mut self) -> Option<(K, V)> {\n-        loop {\n-            // We want the smallest element, so try to get the back of the queue\n-            let op = match self.traversals.back_mut() {\n-                None => return None,\n-                // The queue wasn't empty, so continue along the node in its head\n-                Some(iter) => {\n-                    match iter.next() {\n-                        // The head is empty, so Pop it off and continue the process\n-                        None => Pop,\n-                        // The head yielded an edge, so make that the new head\n-                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                        // The head yielded an entry, so yield that\n-                        Some(Elem(kv)) => {\n-                            self.size -= 1;\n-                            return Some(kv);\n-                        }\n-                    }\n-                }\n-            };\n+        let mut cur_handle = match handle.right_kv() {\n+            Ok(kv) => {\n+                let ret = kv.into_kv();\n+                self.front = kv.right_edge();\n+                return ret;\n+            },\n+            Err(last_edge) => {\n+                let next_level = last_edge.into_node().ascend().ok();\n+                unwrap_unchecked(next_level)\n+            }\n+        };\n \n-            // Handle any operation as necessary, without a conflicting borrow of the queue\n-            match op {\n-                Push(item) => {\n-                    self.traversals.push_back(item);\n-                }\n-                Pop => {\n-                    self.traversals.pop_back();\n+        loop {\n+            match cur_handle.right_kv() {\n+                Ok(kv) => {\n+                    let ret = kv.into_kv();\n+                    self.front = first_leaf_edge(kv.right_edge().descend());\n+                    return ret;\n+                },\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    cur_handle = unwrap_unchecked(next_level);\n                 }\n             }\n         }\n     }\n+}\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.size, Some(self.size))\n+impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        if self.front == self.back {\n+            None\n+        } else {\n+            unsafe { Some(self.next_back_unchecked()) }\n+        }\n     }\n }\n \n-impl<K, V, E, T> DoubleEndedIterator for AbsIter<T>\n-    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n-{\n-    // next_back is totally symmetric to next\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(K, V)> {\n-        loop {\n-            let op = match self.traversals.front_mut() {\n-                None => return None,\n-                Some(iter) => {\n-                    match iter.next_back() {\n-                        None => Pop,\n-                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                        Some(Elem(kv)) => {\n-                            self.size -= 1;\n-                            return Some(kv);\n-                        }\n-                    }\n-                }\n-            };\n+impl<'a, K, V> Range<'a, K, V> {\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let handle = self.back;\n \n-            match op {\n-                Push(item) => {\n-                    self.traversals.push_front(item);\n-                }\n-                Pop => {\n-                    self.traversals.pop_front();\n+        let mut cur_handle = match handle.left_kv() {\n+            Ok(kv) => {\n+                let ret = kv.into_kv();\n+                self.back = kv.left_edge();\n+                return ret;\n+            },\n+            Err(last_edge) => {\n+                let next_level = last_edge.into_node().ascend().ok();\n+                unwrap_unchecked(next_level)\n+            }\n+        };\n+\n+        loop {\n+            match cur_handle.left_kv() {\n+                Ok(kv) => {\n+                    let ret = kv.into_kv();\n+                    self.back = last_leaf_edge(kv.left_edge().descend());\n+                    return ret;\n+                },\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    cur_handle = unwrap_unchecked(next_level);\n                 }\n             }\n         }\n     }\n }\n \n-impl<'a, K, V> Clone for Iter<'a, K, V> {\n-    fn clone(&self) -> Iter<'a, K, V> {\n-        Iter { inner: self.inner.clone() }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Iter<'a, K, V> {\n-    type Item = (&'a K, &'a V);\n-\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next_back()\n+impl<'a, K, V> Clone for Range<'a, K, V> {\n+    fn clone(&self) -> Range<'a, K, V> {\n+        Range {\n+            front: self.front,\n+            back: self.back\n+        }\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n+impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next_back()\n+        if self.front == self.back {\n+            None\n+        } else {\n+            unsafe { Some (self.next_unchecked()) }\n+        }\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> Iterator for IntoIter<K, V> {\n-    type Item = (K, V);\n+impl<'a, K, V> RangeMut<'a, K, V> {\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+        let handle = ptr::read(&self.front);\n \n-    fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n-    fn next_back(&mut self) -> Option<(K, V)> {\n-        self.inner.next_back()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n+        let mut cur_handle = match handle.right_kv() {\n+            Ok(kv) => {\n+                let (k, v) = ptr::read(&kv).into_kv_mut();\n+                self.front = kv.right_edge();\n+                return (k, v);\n+            },\n+            Err(last_edge) => {\n+                let next_level = last_edge.into_node().ascend().ok();\n+                unwrap_unchecked(next_level)\n+            }\n+        };\n \n-impl<'a, K, V> Clone for Keys<'a, K, V> {\n-    fn clone(&self) -> Keys<'a, K, V> {\n-        Keys { inner: self.inner.clone() }\n+        loop {\n+            match cur_handle.right_kv() {\n+                Ok(kv) => {\n+                    let (k, v) = ptr::read(&kv).into_kv_mut();\n+                    self.front = first_leaf_edge(kv.right_edge().descend());\n+                    return (k, v);\n+                },\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    cur_handle = unwrap_unchecked(next_level);\n+                }\n+            }\n+        }\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Keys<'a, K, V> {\n-    type Item = &'a K;\n \n-    fn next(&mut self) -> Option<(&'a K)> {\n-        self.inner.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K)> {\n-        self.inner.next_back()\n+impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        if self.front == self.back {\n+            None\n+        } else {\n+            unsafe { Some(self.next_back_unchecked()) }\n+        }\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n+impl<'a, K, V> RangeMut<'a, K, V> {\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n+        let handle = ptr::read(&self.back);\n \n-impl<'a, K, V> Clone for Values<'a, K, V> {\n-    fn clone(&self) -> Values<'a, K, V> {\n-        Values { inner: self.inner.clone() }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Values<'a, K, V> {\n-    type Item = &'a V;\n+        let mut cur_handle = match handle.left_kv() {\n+            Ok(kv) => {\n+                let (k, v) = ptr::read(&kv).into_kv_mut();\n+                self.back = kv.left_edge();\n+                return (k, v);\n+            },\n+            Err(last_edge) => {\n+                let next_level = last_edge.into_node().ascend().ok();\n+                unwrap_unchecked(next_level)\n+            }\n+        };\n \n-    fn next(&mut self) -> Option<(&'a V)> {\n-        self.inner.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n+        loop {\n+            match cur_handle.left_kv() {\n+                Ok(kv) => {\n+                    let (k, v) = ptr::read(&kv).into_kv_mut();\n+                    self.back = last_leaf_edge(kv.left_edge().descend());\n+                    return (k, v);\n+                },\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    cur_handle = unwrap_unchecked(next_level);\n+                }\n+            }\n+        }\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a V)> {\n-        self.inner.next_back()\n+\n+impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+        let mut map = BTreeMap::new();\n+        map.extend(iter);\n+        map\n     }\n }\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, K, V> Clone for Range<'a, K, V> {\n-    fn clone(&self) -> Range<'a, K, V> {\n-        Range { inner: self.inner.clone() }\n+impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n+    #[inline]\n+    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+        for (k, v) in iter {\n+            self.insert(k, v);\n+        }\n     }\n }\n-impl<'a, K, V> Iterator for Range<'a, K, V> {\n-    type Item = (&'a K, &'a V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next()\n+impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n+    fn extend<I: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: I) {\n+        self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n-impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next_back()\n+\n+impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        for elt in self {\n+            elt.hash(state);\n+        }\n     }\n }\n \n-impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n-    type Item = (&'a K, &'a mut V);\n-\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next()\n+impl<K: Ord, V> Default for BTreeMap<K, V> {\n+    fn default() -> BTreeMap<K, V> {\n+        BTreeMap::new()\n     }\n }\n-impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next_back()\n+\n+impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n+    fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n-impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n-    pub fn or_insert(self, default: V) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default),\n-        }\n-    }\n+impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default()),\n-        }\n+impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n+        self.iter().partial_cmp(other.iter())\n     }\n }\n \n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n-    /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        self.stack.insert(self.key, value)\n+impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n+    #[inline]\n+    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n+        self.iter().cmp(other.iter())\n     }\n }\n \n-impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.stack.peek()\n+impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_map().entries(self.iter()).finish()\n     }\n+}\n \n-    /// Gets a mutable reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.stack.peek_mut()\n-    }\n+impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n+    where K: Borrow<Q>, Q: Ord\n+{\n+    type Output = V;\n \n-    /// Converts the entry into a mutable reference to its value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.stack.into_top()\n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n     }\n+}\n \n-    /// Sets the value of the entry with the OccupiedEntry's key,\n-    /// and returns the entry's old value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut value: V) -> V {\n-        mem::swap(self.stack.peek_mut(), &mut value);\n-        value\n+fn first_leaf_edge<BorrowType, K, V>(\n+        mut node: NodeRef<BorrowType,\n+                          K, V,\n+                          marker::LeafOrInternal>\n+        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    loop {\n+        match node.force() {\n+            Leaf(leaf) => return leaf.first_edge(),\n+            Internal(internal) => {\n+                node = internal.first_edge().descend();\n+            }\n+        }\n     }\n+}\n \n-    /// Takes the value of the entry out of the map, and returns it.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        self.stack.remove().1\n+fn last_leaf_edge<BorrowType, K, V>(\n+        mut node: NodeRef<BorrowType,\n+                          K, V,\n+                          marker::LeafOrInternal>\n+        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    loop {\n+        match node.force() {\n+            Leaf(leaf) => return leaf.last_edge(),\n+            Internal(internal) => {\n+                node = internal.last_edge().descend();\n+            }\n+        }\n     }\n }\n \n+#[inline(always)]\n+unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n+    val.unwrap_or_else(|| {\n+        if cfg!(debug_assertions) {\n+            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n+        } else {\n+            intrinsics::unreachable();\n+        }\n+    })\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map.\n     ///\n@@ -1312,15 +1199,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n-        let len = self.len();\n-        // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n-        let mut lca = VecDeque::new();\n-        lca.push_back(Traverse::traverse(&self.root));\n         Iter {\n-            inner: AbsIter {\n-                traversals: lca,\n-                size: len,\n+            range: Range {\n+                front: first_leaf_edge(self.root.as_ref()),\n+                back: last_leaf_edge(self.root.as_ref())\n             },\n+            length: self.length\n         }\n     }\n \n@@ -1345,14 +1229,14 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n-        let len = self.len();\n-        let mut lca = VecDeque::new();\n-        lca.push_back(Traverse::traverse(&mut self.root));\n+        let root1 = self.root.as_mut();\n+        let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n-            inner: AbsIter {\n-                traversals: lca,\n-                size: len,\n+            range: RangeMut {\n+                front: first_leaf_edge(root1),\n+                back: last_leaf_edge(root2),\n             },\n+            length: self.length\n         }\n     }\n \n@@ -1372,12 +1256,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A {\n-            a\n-        }\n-        let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n-\n-        Keys { inner: self.iter().map(first) }\n+        Keys { inner: self.iter() }\n     }\n \n     /// Gets an iterator over the values of the map.\n@@ -1396,12 +1275,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B {\n-            b\n-        }\n-        let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n-\n-        Values { inner: self.iter().map(second) }\n+        Values { inner: self.iter() }\n     }\n \n     /// Returns the number of elements in the map.\n@@ -1439,357 +1313,207 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-macro_rules! range_impl {\n-    ($root:expr, $min:expr, $max:expr, $as_slices_internal:ident, $iter:ident, $Range:ident,\n-                                       $edges:ident, [$($mutability:ident)*]) => (\n-        {\n-            // A deque that encodes two search paths containing (left-to-right):\n-            // a series of truncated-from-the-left iterators, the LCA's doubly-truncated iterator,\n-            // and a series of truncated-from-the-right iterators.\n-            let mut traversals = VecDeque::new();\n-            let (root, min, max) = ($root, $min, $max);\n-\n-            let mut leftmost = None;\n-            let mut rightmost = None;\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default),\n+        }\n+    }\n \n-            match (&min, &max) {\n-                (&Unbounded, &Unbounded) => {\n-                    traversals.push_back(Traverse::traverse(root))\n-                }\n-                (&Unbounded, &Included(_)) | (&Unbounded, &Excluded(_)) => {\n-                    rightmost = Some(root);\n-                }\n-                (&Included(_), &Unbounded) | (&Excluded(_), &Unbounded) => {\n-                    leftmost = Some(root);\n-                }\n-                  (&Included(min_key), &Included(max_key))\n-                | (&Included(min_key), &Excluded(max_key))\n-                | (&Excluded(min_key), &Included(max_key))\n-                | (&Excluded(min_key), &Excluded(max_key)) => {\n-                    // lca represents the Lowest Common Ancestor, above which we never\n-                    // walk, since everything else is outside the range to iterate.\n-                    //       ___________________\n-                    //      |__0_|_80_|_85_|_90_|  (root)\n-                    //      |    |    |    |    |\n-                    //           |\n-                    //           v\n-                    //  ___________________\n-                    // |__5_|_15_|_30_|_73_|\n-                    // |    |    |    |    |\n-                    //                |\n-                    //                v\n-                    //       ___________________\n-                    //      |_33_|_58_|_63_|_68_|  lca for the range [41, 65]\n-                    //      |    |\\___|___/|    |  iterator at traversals[2]\n-                    //           |         |\n-                    //           |         v\n-                    //           v         rightmost\n-                    //           leftmost\n-                    let mut is_leaf = root.is_leaf();\n-                    let mut lca = root.$as_slices_internal();\n-                    loop {\n-                        let slice = lca.slice_from(min_key).slice_to(max_key);\n-                        if let [ref $($mutability)* edge] = slice.edges {\n-                            // Follow the only edge that leads the node that covers the range.\n-                            is_leaf = edge.is_leaf();\n-                            lca = edge.$as_slices_internal();\n-                        } else {\n-                            let mut iter = slice.$iter();\n-                            if is_leaf {\n-                                leftmost = None;\n-                                rightmost = None;\n-                            } else {\n-                                // Only change the state of nodes with edges.\n-                                leftmost = iter.next_edge_item();\n-                                rightmost = iter.next_edge_item_back();\n-                            }\n-                            traversals.push_back(iter);\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            // Keep narrowing the range by going down.\n-            //               ___________________\n-            //              |_38_|_43_|_48_|_53_|\n-            //              |    |____|____|____/ iterator at traversals[1]\n-            //                   |\n-            //                   v\n-            //  ___________________\n-            // |_39_|_40_|_41_|_42_|  (leaf, the last leftmost)\n-            //           \\_________|  iterator at traversals[0]\n-            match min {\n-                Included(key) | Excluded(key) =>\n-                    while let Some(left) = leftmost {\n-                        let is_leaf = left.is_leaf();\n-                        let mut iter = left.$as_slices_internal().slice_from(key).$iter();\n-                        leftmost = if is_leaf {\n-                            None\n-                        } else {\n-                            // Only change the state of nodes with edges.\n-                            iter.next_edge_item()\n-                        };\n-                        traversals.push_back(iter);\n-                    },\n-                _ => {}\n-            }\n-            // If the leftmost iterator starts with an element, then it was an exact match.\n-            if let (Excluded(_), Some(leftmost_iter)) = (min, traversals.back_mut()) {\n-                // Drop this excluded element. `next_kv_item` has no effect when\n-                // the next item is an edge.\n-                leftmost_iter.next_kv_item();\n-            }\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default()),\n+        }\n+    }\n+}\n \n-            // The code for the right side is similar.\n-            match max {\n-                Included(key) | Excluded(key) =>\n-                    while let Some(right) = rightmost {\n-                        let is_leaf = right.is_leaf();\n-                        let mut iter = right.$as_slices_internal().slice_to(key).$iter();\n-                        rightmost = if is_leaf {\n-                            None\n-                        } else {\n-                            iter.next_edge_item_back()\n-                        };\n-                        traversals.push_front(iter);\n-                    },\n-                _ => {}\n-            }\n-            if let (Excluded(_), Some(rightmost_iter)) = (max, traversals.front_mut()) {\n-                rightmost_iter.next_kv_item_back();\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        *self.length += 1;\n+\n+        let out_ptr;\n+\n+        let mut ins_k;\n+        let mut ins_v;\n+        let mut ins_edge;\n+\n+        let mut cur_parent = match self.handle.insert(self.key, value) {\n+            (Fit(handle), _) => return handle.into_kv_mut().1,\n+            (Split(left, k, v, right), ptr) => {\n+                ins_k = k;\n+                ins_v = v;\n+                ins_edge = right;\n+                out_ptr = ptr;\n+                left.ascend().map_err(|n| n.into_root_mut())\n             }\n+        };\n \n-            $Range {\n-                inner: AbsIter {\n-                    traversals: traversals,\n-                    size: usize::MAX, // unused\n+        loop {\n+            match cur_parent {\n+                Ok(parent) => match parent.insert(ins_k, ins_v, ins_edge) {\n+                    Fit(_) => return unsafe { &mut *out_ptr },\n+                    Split(left, k, v, right) => {\n+                        ins_k = k;\n+                        ins_v = v;\n+                        ins_edge = right;\n+                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n+                    }\n+                },\n+                Err(root) => {\n+                    root.push_level().push(ins_k, ins_v, ins_edge);\n+                    return unsafe { &mut *out_ptr };\n                 }\n             }\n         }\n-    )\n+    }\n }\n \n-impl<K: Ord, V> BTreeMap<K, V> {\n-    /// Constructs a double-ended iterator over a sub-range of elements in the map, starting\n-    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n-    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n-    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(btree_range, collections_bound)]\n-    ///\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::{Included, Unbounded};\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// map.insert(3, \"a\");\n-    /// map.insert(5, \"b\");\n-    /// map.insert(8, \"c\");\n-    /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n-    /// ```\n-    #[unstable(feature = \"btree_range\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\",\n-               issue = \"27787\")]\n-    pub fn range<Min: ?Sized + Ord, Max: ?Sized + Ord>(&self,\n-                                                       min: Bound<&Min>,\n-                                                       max: Bound<&Max>)\n-                                                       -> Range<K, V>\n-        where K: Borrow<Min> + Borrow<Max>\n-    {\n-        range_impl!(&self.root,\n-                    min,\n-                    max,\n-                    as_slices_internal,\n-                    iter,\n-                    Range,\n-                    edges,\n-                    [])\n+impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> &V {\n+        self.handle.reborrow().into_kv().1\n     }\n \n-    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n-    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n-    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n-    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(btree_range, collections_bound)]\n-    ///\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::{Included, Excluded};\n-    ///\n-    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"].iter()\n-    ///                                                                       .map(|&s| (s, 0))\n-    ///                                                                       .collect();\n-    /// for (_, balance) in map.range_mut(Included(\"B\"), Excluded(\"Cheryl\")) {\n-    ///     *balance += 100;\n-    /// }\n-    /// for (name, balance) in &map {\n-    ///     println!(\"{} => {}\", name, balance);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"btree_range\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\",\n-               issue = \"27787\")]\n-    pub fn range_mut<Min: ?Sized + Ord, Max: ?Sized + Ord>(&mut self,\n-                                                           min: Bound<&Min>,\n-                                                           max: Bound<&Max>)\n-                                                           -> RangeMut<K, V>\n-        where K: Borrow<Min> + Borrow<Max>\n-    {\n-        range_impl!(&mut self.root,\n-                    min,\n-                    max,\n-                    as_slices_internal_mut,\n-                    iter_mut,\n-                    RangeMut,\n-                    edges_mut,\n-                    [mut])\n+    /// Gets a mutable reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.handle.kv_mut().1\n     }\n \n-    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// // count the number of occurrences of letters in the vec\n-    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n-    ///     *count.entry(x).or_insert(0) += 1;\n-    /// }\n-    ///\n-    /// assert_eq!(count[\"a\"], 3);\n-    /// ```\n+    /// Converts the entry into a mutable reference to its value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, mut key: K) -> Entry<K, V> {\n-        // same basic logic of `swap` and `pop`, blended together\n-        let mut stack = stack::PartialSearchStack::new(self);\n-        loop {\n-            let result = stack.with(move |pusher, node| {\n-                match Node::search(node, &key) {\n-                    Found(handle) => {\n-                        // Perfect match\n-                        Finished(Occupied(OccupiedEntry { stack: pusher.seal(handle) }))\n-                    }\n-                    GoDown(handle) => {\n-                        match handle.force() {\n-                            Leaf(leaf_handle) => {\n-                                Finished(Vacant(VacantEntry {\n-                                    stack: pusher.seal(leaf_handle),\n-                                    key: key,\n-                                }))\n-                            }\n-                            Internal(internal_handle) => {\n-                                Continue((pusher.push(internal_handle), key))\n-                            }\n-                        }\n-                    }\n-                }\n-            });\n-            match result {\n-                Finished(finished) => return finished,\n-                Continue((new_stack, renewed_key)) => {\n-                    stack = new_stack;\n-                    key = renewed_key;\n-                }\n-            }\n-        }\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.handle.into_kv_mut().1\n     }\n-}\n \n-impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n-    where K: Borrow<Q> + Ord,\n-          Q: Ord\n-{\n-    type Key = K;\n+    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// and returns the entry's old value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n \n-    fn get(&self, key: &Q) -> Option<&K> {\n-        let mut cur_node = &self.root;\n-        loop {\n-            match Node::search(cur_node, key) {\n-                Found(handle) => return Some(handle.into_kv().0),\n-                GoDown(handle) => {\n-                    match handle.force() {\n-                        Leaf(_) => return None,\n-                        Internal(internal_handle) => {\n-                            cur_node = internal_handle.into_edge();\n-                            continue;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    /// Takes the value of the entry out of the map, and returns it.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove(self) -> V {\n+        self.remove_kv().1\n     }\n \n-    fn take(&mut self, key: &Q) -> Option<K> {\n-        // See `remove` for an explanation of this.\n+    fn remove_kv(self) -> (K, V) {\n+        *self.length -= 1;\n \n-        let mut stack = stack::PartialSearchStack::new(self);\n-        loop {\n-            let result = stack.with(move |pusher, node| {\n-                match Node::search(node, key) {\n-                    Found(handle) => {\n-                        // Perfect match. Terminate the stack here, and remove the entry\n-                        Finished(Some(pusher.seal(handle).remove()))\n-                    }\n-                    GoDown(handle) => {\n-                        // We need to keep searching, try to go down the next edge\n-                        match handle.force() {\n-                            // We're at a leaf; the key isn't in here\n-                            Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n-                        }\n-                    }\n-                }\n-            });\n-            match result {\n-                Finished(ret) => return ret.map(|(k, _)| k),\n-                Continue(new_stack) => stack = new_stack,\n+        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+            Leaf(leaf) => {\n+                let (hole, old_key, old_val) = leaf.remove();\n+                (hole.into_node(), old_key, old_val)\n+            },\n+            Internal(mut internal) => {\n+                let key_loc = internal.kv_mut().0 as *mut K;\n+                let val_loc = internal.kv_mut().1 as *mut V;\n+\n+                let to_remove = first_leaf_edge(internal.right_edge().descend()).right_kv().ok();\n+                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n+\n+                let (hole, key, val) = to_remove.remove();\n+\n+                let old_key = unsafe {\n+                    mem::replace(&mut *key_loc, key)\n+                };\n+                let old_val = unsafe {\n+                    mem::replace(&mut *val_loc, val)\n+                };\n+\n+                (hole.into_node(), old_key, old_val)\n+            }\n+        };\n+\n+        // Handle underflow\n+        let mut cur_node = small_leaf.forget_type();\n+        while cur_node.len() < node::CAPACITY / 2 {\n+            match handle_underfull_node(cur_node) {\n+                AtRoot => break,\n+                EmptyParent(_) => unreachable!(),\n+                Merged(parent) => if parent.len() == 0 {\n+                    // We must be at the root\n+                    parent.into_root_mut().pop_level();\n+                    break;\n+                } else {\n+                    cur_node = parent.forget_type();\n+                },\n+                Stole(_) => break\n             }\n         }\n+\n+        (old_key, old_val)\n     }\n+}\n \n-    fn replace(&mut self, mut key: K) -> Option<K> {\n-        // See `insert` for an explanation of this.\n+enum UnderflowResult<'a, K, V> {\n+    AtRoot,\n+    EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>)\n+}\n \n-        let mut stack = stack::PartialSearchStack::new(self);\n+fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n+                                                 K, V,\n+                                                 marker::LeafOrInternal>)\n+                                                 -> UnderflowResult<'a, K, V> {\n+    let parent = if let Ok(parent) = node.ascend() {\n+        parent\n+    } else {\n+        return AtRoot;\n+    };\n+\n+    let (is_left, mut handle) = match parent.left_kv() {\n+        Ok(left) => (true, left),\n+        Err(parent) => match parent.right_kv() {\n+            Ok(right) => (false, right),\n+            Err(parent) => {\n+                return EmptyParent(parent.into_node());\n+            }\n+        }\n+    };\n+\n+    if handle.can_merge() {\n+        return Merged(handle.merge().into_node());\n+    } else {\n+        unsafe {\n+            let (k, v, edge) = if is_left {\n+                handle.reborrow_mut().left_edge().descend().pop()\n+            } else {\n+                handle.reborrow_mut().right_edge().descend().pop_front()\n+            };\n \n-        loop {\n-            let result = stack.with(move |pusher, node| {\n-                match Node::search::<K, _>(node, &key) {\n-                    Found(mut handle) => {\n-                        mem::swap(handle.key_mut(), &mut key);\n-                        Finished(Some(key))\n-                    }\n-                    GoDown(handle) => {\n-                        match handle.force() {\n-                            Leaf(leaf_handle) => {\n-                                pusher.seal(leaf_handle).insert(key, ());\n-                                Finished(None)\n-                            }\n-                            Internal(internal_handle) => {\n-                                Continue((pusher.push(internal_handle), key, ()))\n-                            }\n-                        }\n-                    }\n+            let k = mem::replace(handle.reborrow_mut().into_kv_mut().0, k);\n+            let v = mem::replace(handle.reborrow_mut().into_kv_mut().1, v);\n+\n+            // FIXME: reuse cur_node?\n+            if is_left {\n+                match handle.reborrow_mut().right_edge().descend().force() {\n+                    Leaf(mut leaf) => leaf.push_front(k, v),\n+                    Internal(mut internal) => internal.push_front(k, v, edge.unwrap())\n                 }\n-            });\n-            match result {\n-                Finished(ret) => return ret,\n-                Continue((new_stack, renewed_key, _)) => {\n-                    stack = new_stack;\n-                    key = renewed_key;\n+            } else {\n+                match handle.reborrow_mut().left_edge().descend().force() {\n+                    Leaf(mut leaf) => leaf.push(k, v),\n+                    Internal(mut internal) => internal.push(k, v, edge.unwrap())\n                 }\n             }\n         }\n+\n+        return Stole(handle.into_node());\n     }\n }"}, {"sha": "087c9f228d4448bb6c119675ce28eac9e354a6b4", "filename": "src/libcollections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmod.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n mod node;\n+mod search;\n pub mod map;\n pub mod set;\n "}, {"sha": "2e2a39df3477afb2cf17a36f2ca09ca532f60e7b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 865, "deletions": 1377, "changes": 2242, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -8,1632 +8,1120 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This module represents all the internal representation and logic for a B-Tree's node\n-// with a safe interface, so that BTreeMap itself does not depend on any of these details.\n-\n-pub use self::InsertionResult::*;\n-pub use self::SearchResult::*;\n-pub use self::ForceResult::*;\n-pub use self::TraversalItem::*;\n+// This is an attempt at an implementation following the ideal\n+//\n+// ```\n+// struct BTreeMap<K, V> {\n+//     height: usize,\n+//     root: Option<Box<Node<K, V, height>>>\n+// }\n+//\n+// struct Node<K, V, height: usize> {\n+//     keys: [K; 2 * B - 1],\n+//     vals: [V; 2 * B - 1],\n+//     edges: if height > 0 {\n+//         [Box<Node<K, V, height - 1>>; 2 * B]\n+//     } else { () },\n+//     parent: *const Node<K, V, height + 1>,\n+//     parent_idx: u16,\n+//     len: u16,\n+// }\n+// ```\n+//\n+// Since Rust doesn't acutally have dependent types and polymorphic recursion,\n+// we make do with lots of unsafety.\n \n-use core::cmp::Ordering::{Greater, Less, Equal};\n-use core::intrinsics::arith_offset;\n-use core::iter::Zip;\n-use core::marker::PhantomData;\n-use core::ops::{Deref, DerefMut, Index, IndexMut};\n-use core::ptr::Unique;\n-use core::{slice, mem, ptr, cmp};\n use alloc::heap;\n-\n-use borrow::Borrow;\n-\n-/// Represents the result of an Insertion: either the item fit, or the node had to split\n-pub enum InsertionResult<K, V> {\n-    /// The inserted element fit\n-    Fit,\n-    /// The inserted element did not fit, so the node was split\n-    Split(K, V, Node<K, V>),\n-}\n-\n-/// Represents the result of a search for a key in a single node\n-pub enum SearchResult<NodeRef> {\n-    /// The element was found at the given index\n-    Found(Handle<NodeRef, handle::KV, handle::LeafOrInternal>),\n-    /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n-    GoDown(Handle<NodeRef, handle::Edge, handle::LeafOrInternal>),\n-}\n-\n-/// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n-#[unsafe_no_drop_flag]\n-pub struct Node<K, V> {\n-    // To avoid the need for multiple allocations, we allocate a single buffer with enough space\n-    // for `capacity` keys, `capacity` values, and (in internal nodes) `capacity + 1` edges.\n-    // Despite this, we store three separate pointers to the three \"chunks\" of the buffer because\n-    // the performance drops significantly if the locations of the vals and edges need to be\n-    // recalculated upon access.\n-    //\n-    // These will never be null during normal usage of a `Node`. However, to avoid the need for a\n-    // drop flag, `Node::drop` zeroes `keys`, signaling that the `Node` has already been cleaned\n-    // up.\n-    keys: Unique<K>,\n-    vals: Unique<V>,\n-\n-    // In leaf nodes, this will be None, and no space will be allocated for edges.\n-    edges: Option<Unique<Node<K, V>>>,\n-\n-    // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n-    // `_len + 1` edges. In a leaf node, there will never be any edges.\n-    //\n-    // Note: instead of accessing this field directly, please call the `len()` method, which should\n-    // be more stable in the face of representation changes.\n-    _len: usize,\n-\n-    // FIXME(gereeter) It shouldn't be necessary to store the capacity in every node, as it should\n-    // be constant throughout the tree. Once a solution to this is found, it might be possible to\n-    // also pass down the offsets into the buffer that vals and edges are stored at, removing the\n-    // need for those two pointers.\n-    //\n-    // Note: instead of accessing this field directly, please call the `capacity()` method, which\n-    // should be more stable in the face of representation changes.\n-    _capacity: usize,\n-}\n-\n-pub struct NodeSlice<'a, K: 'a, V: 'a> {\n-    keys: &'a [K],\n-    vals: &'a [V],\n-    pub edges: &'a [Node<K, V>],\n-    head_is_edge: bool,\n-    tail_is_edge: bool,\n-    has_edges: bool,\n-}\n-\n-pub struct MutNodeSlice<'a, K: 'a, V: 'a> {\n-    keys: &'a [K],\n-    vals: &'a mut [V],\n-    pub edges: &'a mut [Node<K, V>],\n-    head_is_edge: bool,\n-    tail_is_edge: bool,\n-    has_edges: bool,\n-}\n-\n-/// Rounds up to a multiple of a power of two. Returns the closest multiple\n-/// of `target_alignment` that is higher or equal to `unrounded`.\n-///\n-/// # Panics\n-///\n-/// Fails if `target_alignment` is not a power of two.\n-#[inline]\n-fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n-    assert!(target_alignment.is_power_of_two());\n-    (unrounded + target_alignment - 1) & !(target_alignment - 1)\n-}\n-\n-#[test]\n-fn test_rounding() {\n-    assert_eq!(round_up_to_next(0, 4), 0);\n-    assert_eq!(round_up_to_next(1, 4), 4);\n-    assert_eq!(round_up_to_next(2, 4), 4);\n-    assert_eq!(round_up_to_next(3, 4), 4);\n-    assert_eq!(round_up_to_next(4, 4), 4);\n-    assert_eq!(round_up_to_next(5, 4), 8);\n-}\n-\n-// Returns a tuple of (val_offset, edge_offset),\n-// from the start of a mallocated array.\n-#[inline]\n-fn calculate_offsets(keys_size: usize,\n-                     vals_size: usize,\n-                     vals_align: usize,\n-                     edges_align: usize)\n-                     -> (usize, usize) {\n-    let vals_offset = round_up_to_next(keys_size, vals_align);\n-    let end_of_vals = vals_offset + vals_size;\n-\n-    let edges_offset = round_up_to_next(end_of_vals, edges_align);\n-\n-    (vals_offset, edges_offset)\n-}\n-\n-// Returns a tuple of (minimum required alignment, array_size),\n-// from the start of a mallocated array.\n-#[inline]\n-fn calculate_allocation(keys_size: usize,\n-                        keys_align: usize,\n-                        vals_size: usize,\n-                        vals_align: usize,\n-                        edges_size: usize,\n-                        edges_align: usize)\n-                        -> (usize, usize) {\n-    let (_, edges_offset) = calculate_offsets(keys_size, vals_size, vals_align, edges_align);\n-    let end_of_edges = edges_offset + edges_size;\n-\n-    let min_align = cmp::max(keys_align, cmp::max(vals_align, edges_align));\n-\n-    (min_align, end_of_edges)\n-}\n-\n-#[test]\n-fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4), (8, 148));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 6));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 48));\n-    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n-    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5));\n-    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24));\n+use core::marker::PhantomData;\n+use core::mem;\n+use core::nonzero::NonZero;\n+use core::ptr::{self, Unique};\n+use core::slice;\n+\n+use boxed::Box;\n+\n+const B: usize = 6;\n+pub const CAPACITY: usize = 2 * B - 1;\n+\n+struct LeafNode<K, V> {\n+    keys: [K; CAPACITY],\n+    vals: [V; CAPACITY],\n+    parent: *const InternalNode<K, V>,\n+    parent_idx: u16,\n+    len: u16,\n }\n \n-fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n-    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::align_of::<K>());\n-    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::align_of::<V>());\n-    let (edges_size, edges_align) = if is_leaf {\n-        // allocate one edge to ensure that we don't pass size 0 to `heap::allocate`\n-        if mem::size_of::<K>() == 0 && mem::size_of::<V>() == 0 {\n-            (1, mem::align_of::<Node<K, V>>())\n-        } else {\n-            (0, 1)\n+impl<K, V> LeafNode<K, V> {\n+    unsafe fn new() -> Self {\n+        LeafNode {\n+            keys: mem::uninitialized(),\n+            vals: mem::uninitialized(),\n+            parent: ptr::null(),\n+            parent_idx: mem::uninitialized(),\n+            len: 0\n         }\n-    } else {\n-        ((capacity + 1) * mem::size_of::<Node<K, V>>(),\n-         mem::align_of::<Node<K, V>>())\n-    };\n-\n-    calculate_allocation(keys_size,\n-                         keys_align,\n-                         vals_size,\n-                         vals_align,\n-                         edges_size,\n-                         edges_align)\n-}\n-\n-fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n-    let keys_size = capacity * mem::size_of::<K>();\n-    let vals_size = capacity * mem::size_of::<V>();\n-    let vals_align = mem::align_of::<V>();\n-    let edges_align = if is_leaf {\n-        1\n-    } else {\n-        mem::align_of::<Node<K, V>>()\n-    };\n-\n-    calculate_offsets(keys_size, vals_size, vals_align, edges_align)\n+    }\n }\n \n-/// An iterator over a slice that owns the elements of the slice but not the allocation.\n-struct RawItems<T> {\n-    head: *const T,\n-    tail: *const T,\n+// We use repr(C) so that a pointer to an internal node can be\n+// directly used as a pointer to a leaf node\n+#[repr(C)]\n+struct InternalNode<K, V> {\n+    data: LeafNode<K, V>,\n+    edges: [BoxedNode<K, V>; 2 * B],\n }\n \n-impl<T> RawItems<T> {\n-    unsafe fn from_slice(slice: &[T]) -> RawItems<T> {\n-        RawItems::from_parts(slice.as_ptr(), slice.len())\n-    }\n-\n-    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n-        if mem::size_of::<T>() == 0 {\n-            RawItems {\n-                head: ptr,\n-                tail: arith_offset(ptr as *const i8, len as isize) as *const T,\n-            }\n-        } else {\n-            RawItems {\n-                head: ptr,\n-                tail: ptr.offset(len as isize),\n-            }\n-        }\n-    }\n-\n-    unsafe fn push(&mut self, val: T) {\n-        ptr::write(self.tail as *mut T, val);\n-\n-        if mem::size_of::<T>() == 0 {\n-            self.tail = arith_offset(self.tail as *const i8, 1) as *const T;\n-        } else {\n-            self.tail = self.tail.offset(1);\n+impl<K, V> InternalNode<K, V> {\n+    unsafe fn new() -> Self {\n+        InternalNode {\n+            data: LeafNode::new(),\n+            edges: mem::uninitialized()\n         }\n     }\n }\n \n-impl<T> Iterator for RawItems<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                let ret = Some(ptr::read(self.head));\n-\n-                if mem::size_of::<T>() == 0 {\n-                    self.head = arith_offset(self.head as *const i8, 1) as *const T;\n-                } else {\n-                    self.head = self.head.offset(1);\n-                }\n+struct BoxedNode<K, V> {\n+    ptr: Unique<LeafNode<K, V>> // we don't know if this points to a leaf node or an internal node\n+}\n \n-                ret\n-            }\n+impl<K, V> BoxedNode<K, V> {\n+    fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n+        unsafe {\n+            BoxedNode { ptr: Unique::new(Box::into_raw(node)) }\n         }\n     }\n-}\n-\n-impl<T> DoubleEndedIterator for RawItems<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                if mem::size_of::<T>() == 0 {\n-                    self.tail = arith_offset(self.tail as *const i8, -1) as *const T;\n-                } else {\n-                    self.tail = self.tail.offset(-1);\n-                }\n \n-                Some(ptr::read(self.tail))\n-            }\n+    fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n+        unsafe {\n+            BoxedNode { ptr: Unique::new(Box::into_raw(node) as *mut LeafNode<K, V>) }\n         }\n     }\n-}\n \n-impl<T> Drop for RawItems<T> {\n-    #[unsafe_destructor_blind_to_params]\n-    fn drop(&mut self) {\n-        for _ in self {}\n+    unsafe fn from_ptr(ptr: NonZero<*mut LeafNode<K, V>>) -> Self {\n+        BoxedNode { ptr: Unique::new(*ptr) }\n     }\n-}\n \n-impl<K, V> Drop for Node<K, V> {\n-    #[unsafe_destructor_blind_to_params]\n-    fn drop(&mut self) {\n-        if self.keys.is_null() ||\n-           (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE }) {\n-            // Since we have #[unsafe_no_drop_flag], we have to watch\n-            // out for the sentinel value being stored in self.keys. (Using\n-            // null is technically a violation of the `Unique`\n-            // requirements, though.)\n-            return;\n-        }\n-\n-        // Do the actual cleanup.\n+    fn as_ptr(&self) -> NonZero<*mut LeafNode<K, V>> {\n         unsafe {\n-            drop(RawItems::from_slice(self.keys()));\n-            drop(RawItems::from_slice(self.vals()));\n-            drop(RawItems::from_slice(self.edges()));\n-\n-            self.destroy();\n+            NonZero::new(*self.ptr)\n         }\n-\n-        self.keys = unsafe { Unique::new(ptr::null_mut()) };\n     }\n }\n \n-impl<K, V> Node<K, V> {\n-    /// Make a new internal node. The caller must initialize the result to fix the invariant that\n-    /// there are `len() + 1` edges.\n-    unsafe fn new_internal(capacity: usize) -> Node<K, V> {\n-        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n-\n-        let buffer = heap::allocate(size, alignment);\n-        if buffer.is_null() {\n-            ::alloc::oom();\n-        }\n+/// An owned tree. Note that despite being owned, this does not have a destructor,\n+/// and must be cleaned up manually.\n+pub struct Root<K, V> {\n+    node: BoxedNode<K, V>,\n+    height: usize\n+}\n \n-        let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n+unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> { }\n+unsafe impl<K: Send, V: Send> Send for Root<K, V> { }\n \n-        Node {\n-            keys: Unique::new(buffer as *mut K),\n-            vals: Unique::new(buffer.offset(vals_offset as isize) as *mut V),\n-            edges: Some(Unique::new(buffer.offset(edges_offset as isize) as *mut Node<K, V>)),\n-            _len: 0,\n-            _capacity: capacity,\n+impl<K, V> Root<K, V> {\n+    pub fn new_leaf() -> Self {\n+        Root {\n+            node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })),\n+            height: 0\n         }\n     }\n \n-    /// Make a new leaf node\n-    fn new_leaf(capacity: usize) -> Node<K, V> {\n-        let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n-\n-        let buffer = unsafe { heap::allocate(size, alignment) };\n-        if buffer.is_null() {\n-            ::alloc::oom();\n-        }\n-\n-        let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n-\n-        Node {\n-            keys: unsafe { Unique::new(buffer as *mut K) },\n-            vals: unsafe { Unique::new(buffer.offset(vals_offset as isize) as *mut V) },\n-            edges: None,\n-            _len: 0,\n-            _capacity: capacity,\n+    pub fn as_ref(&self)\n+            -> NodeRef<marker::Immut, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node.as_ptr(),\n+            root: self as *const _ as *mut _,\n+            _marker: PhantomData,\n         }\n     }\n \n-    unsafe fn destroy(&mut self) {\n-        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity(),\n-                                                                     self.is_leaf());\n-        heap::deallocate(*self.keys as *mut u8, size, alignment);\n-    }\n-\n-    #[inline]\n-    pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n-        unsafe {\n-            (slice::from_raw_parts(*self.keys, self.len()),\n-             slice::from_raw_parts(*self.vals, self.len()))\n+    pub fn as_mut(&mut self)\n+            -> NodeRef<marker::Mut, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node.as_ptr(),\n+            root: self as *mut _,\n+            _marker: PhantomData,\n         }\n     }\n \n-    #[inline]\n-    pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe {\n-            (slice::from_raw_parts_mut(*self.keys, self.len()),\n-             slice::from_raw_parts_mut(*self.vals, self.len()))\n+    pub fn into_ref(self)\n+            -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node.as_ptr(),\n+            root: ptr::null_mut(), // FIXME: Is there anything better to do here?\n+            _marker: PhantomData,\n         }\n     }\n \n-    #[inline]\n-    pub fn as_slices_internal<'b>(&'b self) -> NodeSlice<'b, K, V> {\n-        let is_leaf = self.is_leaf();\n-        let (keys, vals) = self.as_slices();\n-        let edges: &[_] = if self.is_leaf() {\n-            &[]\n-        } else {\n-            unsafe {\n-                let data = match self.edges {\n-                    None => heap::EMPTY as *const Node<K, V>,\n-                    Some(ref p) => **p as *const Node<K, V>,\n-                };\n-                slice::from_raw_parts(data, self.len() + 1)\n-            }\n-        };\n-        NodeSlice {\n-            keys: keys,\n-            vals: vals,\n-            edges: edges,\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n-        }\n-    }\n+    /// Add a new internal node with a single edge, pointing to the previous root, and make that\n+    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n+    pub fn push_level(&mut self)\n+            -> NodeRef<marker::Mut, K, V, marker::Internal> {\n+        let mut new_node = Box::new(unsafe { InternalNode::new() });\n+        new_node.edges[0] = unsafe { BoxedNode::from_ptr(self.node.as_ptr()) };\n \n-    #[inline]\n-    pub fn as_slices_internal_mut<'b>(&'b mut self) -> MutNodeSlice<'b, K, V> {\n-        let len = self.len();\n-        let is_leaf = self.is_leaf();\n-        let keys = unsafe { slice::from_raw_parts_mut(*self.keys, len) };\n-        let vals = unsafe { slice::from_raw_parts_mut(*self.vals, len) };\n-        let edges: &mut [_] = if is_leaf {\n-            &mut []\n-        } else {\n-            unsafe {\n-                let data = match self.edges {\n-                    None => heap::EMPTY as *mut Node<K, V>,\n-                    Some(ref mut p) => **p as *mut Node<K, V>,\n-                };\n-                slice::from_raw_parts_mut(data, len + 1)\n-            }\n-        };\n-        MutNodeSlice {\n-            keys: keys,\n-            vals: vals,\n-            edges: edges,\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n-        }\n-    }\n+        self.node = BoxedNode::from_internal(new_node);\n+        self.height += 1;\n \n-    #[inline]\n-    pub fn keys<'a>(&'a self) -> &'a [K] {\n-        self.as_slices().0\n-    }\n+        let mut ret = NodeRef {\n+            height: self.height,\n+            node: self.node.as_ptr(),\n+            root: self as *mut _,\n+            _marker: PhantomData\n+        };\n \n-    #[inline]\n-    pub fn keys_mut<'a>(&'a mut self) -> &'a mut [K] {\n-        self.as_slices_mut().0\n-    }\n+        unsafe {\n+            ret.reborrow_mut().first_edge().correct_parent_link();\n+        }\n \n-    #[inline]\n-    pub fn vals<'a>(&'a self) -> &'a [V] {\n-        self.as_slices().1\n+        ret\n     }\n \n-    #[inline]\n-    pub fn vals_mut<'a>(&'a mut self) -> &'a mut [V] {\n-        self.as_slices_mut().1\n-    }\n+    ///\u00a0Remove the root node, using its first child as the new root. This cannot be called when\n+    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n+    /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_level`.\n+    pub fn pop_level(&mut self) {\n+        debug_assert!(self.height > 0);\n \n-    #[inline]\n-    pub fn edges<'a>(&'a self) -> &'a [Node<K, V>] {\n-        self.as_slices_internal().edges\n-    }\n+        let top = *self.node.ptr as *mut u8;\n \n-    #[inline]\n-    pub fn edges_mut<'a>(&'a mut self) -> &'a mut [Node<K, V>] {\n-        self.as_slices_internal_mut().edges\n-    }\n-}\n-\n-// FIXME(gereeter) Write an efficient clone_from\n-impl<K: Clone, V: Clone> Clone for Node<K, V> {\n-    fn clone(&self) -> Node<K, V> {\n-        let mut ret = if self.is_leaf() {\n-            Node::new_leaf(self.capacity())\n-        } else {\n-            unsafe { Node::new_internal(self.capacity()) }\n+        self.node = unsafe {\n+            BoxedNode::from_ptr(self.as_mut()\n+                                    .cast_unchecked::<marker::Internal>()\n+                                    .first_edge()\n+                                    .descend()\n+                                    .node)\n         };\n+        self.height -= 1;\n+        self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            // For failure safety\n-            let mut keys = RawItems::from_parts(ret.keys().as_ptr(), 0);\n-            let mut vals = RawItems::from_parts(ret.vals().as_ptr(), 0);\n-            let mut edges = RawItems::from_parts(ret.edges().as_ptr(), 0);\n-\n-            for key in self.keys() {\n-                keys.push(key.clone())\n-            }\n-            for val in self.vals() {\n-                vals.push(val.clone())\n-            }\n-            for edge in self.edges() {\n-                edges.push(edge.clone())\n-            }\n-\n-            mem::forget(keys);\n-            mem::forget(vals);\n-            mem::forget(edges);\n-\n-            ret._len = self.len();\n+            heap::deallocate(\n+                top,\n+                mem::size_of::<InternalNode<K, V>>(),\n+                mem::align_of::<InternalNode<K, V>>()\n+            );\n         }\n-\n-        ret\n     }\n }\n \n-/// A reference to something in the middle of a `Node`. There are two `Type`s of `Handle`s,\n-/// namely `KV` handles, which point to key/value pairs, and `Edge` handles, which point to edges\n-/// before or after key/value pairs. Methods are provided for removing pairs, inserting into edges,\n-/// accessing the stored values, and moving around the `Node`.\n-///\n-/// This handle is generic, and can take any sort of reference to a `Node`. The reason for this is\n-/// two-fold. First of all, it reduces the amount of repetitive code, implementing functions that\n-/// don't need mutability on both mutable and immutable references. Secondly and more importantly,\n-/// this allows users of the `Handle` API to associate metadata with the reference. This is used in\n-/// `BTreeMap` to give `Node`s temporary \"IDs\" that persist to when the `Node` is used in a\n-/// `Handle`.\n+/// A reference to a node.\n ///\n-/// # A note on safety\n-///\n-/// Unfortunately, the extra power afforded by being generic also means that safety can technically\n-/// be broken. For sensible implementations of `Deref` and `DerefMut`, these handles are perfectly\n-/// safe. As long as repeatedly calling `.deref()` results in the same Node being returned each\n-/// time, everything should work fine. However, if the `Deref` implementation swaps in multiple\n-/// different nodes, then the indices that are assumed to be in bounds suddenly stop being so. For\n-/// example:\n-///\n-/// ```rust,ignore\n-/// struct Nasty<'a> {\n-///     first: &'a Node<usize, usize>,\n-///     second: &'a Node<usize, usize>,\n-///     flag: &'a Cell<bool>,\n-/// }\n-///\n-/// impl<'a> Deref for Nasty<'a> {\n-///     type Target = Node<usize, usize>;\n-///\n-///     fn deref(&self) -> &Node<usize, usize> {\n-///         if self.flag.get() {\n-///             &*self.second\n-///         } else {\n-///             &*self.first\n-///         }\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let flag = Cell::new(false);\n-///     let mut small_node = Node::make_leaf_root(3);\n-///     let mut large_node = Node::make_leaf_root(100);\n-///\n-///     for i in 0..100 {\n-///         // Insert to the end\n-///         large_node.edge_handle(i).insert_as_leaf(i, i);\n-///     }\n-///\n-///     let nasty = Nasty {\n-///         first: &large_node,\n-///         second: &small_node,\n-///         flag: &flag\n-///     }\n-///\n-///     // The handle points at index 75.\n-///     let handle = Node::search(nasty, 75);\n-///\n-///     // Now the handle still points at index 75, but on the small node, which has no index 75.\n-///     flag.set(true);\n-///\n-///     println!(\"Uninitialized memory: {:?}\", handle.into_kv());\n-/// }\n-/// ```\n-#[derive(Copy, Clone)]\n-pub struct Handle<NodeRef, Type, NodeType> {\n-    node: NodeRef,\n-    index: usize,\n-    marker: PhantomData<(Type, NodeType)>,\n+/// This type has a number of paramaters that controls how it acts:\n+/// - `BorrowType`: This can be `Immut<'a>` or `Mut<'a>` for some `'a` or `Owned`.\n+///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n+///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n+///    and when this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`.\n+/// - `K` and `V`: These control what types of things are stored in the nodes.\n+/// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n+///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n+///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n+///   `NodeRef` could be pointing to either type of node.\n+pub struct NodeRef<BorrowType, K, V, Type> {\n+    height: usize,\n+    node: NonZero<*mut LeafNode<K, V>>,\n+    root: *mut Root<K, V>,\n+    _marker: PhantomData<(BorrowType, Type)>\n }\n \n-pub mod handle {\n-    // Handle types.\n-    pub enum KV {}\n-    pub enum Edge {}\n-\n-    // Handle node types.\n-    pub enum LeafOrInternal {}\n-    pub enum Leaf {}\n-    pub enum Internal {}\n+impl<'a, K: 'a, V: 'a, Type> Copy for NodeRef<marker::Immut<'a>, K, V, Type> { }\n+impl<'a, K: 'a, V: 'a, Type> Clone for NodeRef<marker::Immut<'a>, K, V, Type> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n-impl<K: Ord, V> Node<K, V> {\n-    /// Searches for the given key in the node. If it finds an exact match,\n-    /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n-    /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Q: ?Sized, NodeRef: Deref<Target = Node<K, V>>>(node: NodeRef,\n-                                                                  key: &Q)\n-                                                                  -> SearchResult<NodeRef>\n-        where K: Borrow<Q>,\n-              Q: Ord\n-    {\n-        // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n-        // For the B configured as of this writing (B = 6), binary search was *significantly*\n-        // worse for usizes.\n-        match node.as_slices_internal().search_linear(key) {\n-            (index, true) => {\n-                Found(Handle {\n-                    node: node,\n-                    index: index,\n-                    marker: PhantomData,\n-                })\n-            }\n-            (index, false) => {\n-                GoDown(Handle {\n-                    node: node,\n-                    index: index,\n-                    marker: PhantomData,\n-                })\n-            }\n+unsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync\n+    for NodeRef<BorrowType, K, V, Type> { }\n+\n+unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send\n+   for NodeRef<marker::Immut<'a>, K, V, Type> { }\n+unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send\n+   for NodeRef<marker::Mut<'a>, K, V, Type> { }\n+unsafe impl<K: Send, V: Send, Type> Send\n+   for NodeRef<marker::Owned, K, V, Type> { }\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    fn as_internal(&self) -> &InternalNode<K, V> {\n+        unsafe {\n+            &*(*self.node as *const InternalNode<K, V>)\n         }\n     }\n }\n \n-// Public interface\n-impl<K, V> Node<K, V> {\n-    /// Make a leaf root from scratch\n-    pub fn make_leaf_root(b: usize) -> Node<K, V> {\n-        Node::new_leaf(capacity_from_b(b))\n-    }\n-\n-    /// Make an internal root and swap it with an old root\n-    pub fn make_internal_root(left_and_out: &mut Node<K, V>,\n-                              b: usize,\n-                              key: K,\n-                              value: V,\n-                              right: Node<K, V>) {\n-        let node = mem::replace(left_and_out,\n-                                unsafe { Node::new_internal(capacity_from_b(b)) });\n-        left_and_out._len = 1;\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n-            ptr::write(left_and_out.vals_mut().get_unchecked_mut(0), value);\n-            ptr::write(left_and_out.edges_mut().get_unchecked_mut(0), node);\n-            ptr::write(left_and_out.edges_mut().get_unchecked_mut(1), right);\n+            &mut *(*self.node as *mut InternalNode<K, V>)\n         }\n     }\n+}\n \n-    /// How many key-value pairs the node contains\n-    pub fn len(&self) -> usize {\n-        self._len\n-    }\n \n-    /// Does the node not contain any key-value pairs\n-    pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    pub fn len(&self) -> usize {\n+        self.as_leaf().len as usize\n     }\n \n-    /// How many key-value pairs the node can fit\n-    pub fn capacity(&self) -> usize {\n-        self._capacity\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node,\n+            root: self.root,\n+            _marker: PhantomData\n+        }\n     }\n \n-    /// If the node has any children\n-    pub fn is_leaf(&self) -> bool {\n-        self.edges.is_none()\n+    fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node,\n+            root: self.root,\n+            _marker: PhantomData\n+        }\n     }\n \n-    /// if the node has too few elements\n-    pub fn is_underfull(&self) -> bool {\n-        self.len() < min_load_from_capacity(self.capacity())\n+    fn as_leaf(&self) -> &LeafNode<K, V> {\n+        unsafe {\n+            &**self.node\n+        }\n     }\n \n-    /// if the node cannot fit any more elements\n-    pub fn is_full(&self) -> bool {\n-        self.len() == self.capacity()\n+    pub fn keys(&self) -> &[K] {\n+        self.reborrow().into_slices().0\n     }\n-}\n \n-impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n-    /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n-    /// is very different from `edge` and `edge_mut` because those return children of the node\n-    /// returned by `node`.\n-    pub fn node(&self) -> &Node<K, V> {\n-        &*self.node\n+    pub fn vals(&self) -> &[V] {\n+        self.reborrow().into_slices().1\n     }\n-}\n \n-impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Converts a handle into one that stores the same information using a raw pointer. This can\n-    /// be useful in conjunction with `from_raw` when the type system is insufficient for\n-    /// determining the lifetimes of the nodes.\n-    pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n-        Handle {\n-            node: &mut *self.node as *mut _,\n-            index: self.index,\n-            marker: PhantomData,\n+    pub fn ascend(self) -> Result<\n+        Handle<\n+            NodeRef<\n+                BorrowType,\n+                K, V,\n+                marker::Internal\n+            >,\n+            marker::Edge\n+        >,\n+        Self\n+    > {\n+        if self.as_leaf().parent.is_null() {\n+            Err(self)\n+        } else {\n+            Ok(Handle {\n+                node: NodeRef {\n+                    height: self.height + 1,\n+                    node: unsafe {\n+                        NonZero::new(self.as_leaf().parent as *mut LeafNode<K, V>)\n+                    },\n+                    root: self.root,\n+                    _marker: PhantomData\n+                },\n+                idx: self.as_leaf().parent_idx as usize,\n+                _marker: PhantomData\n+            })\n         }\n     }\n-}\n \n-impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n-    /// unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n-        Handle {\n-            node: &*self.node,\n-            index: self.index,\n-            marker: PhantomData,\n-        }\n+    pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n+        Handle::new_edge(self, 0)\n     }\n \n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n-    /// allow unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index,\n-            marker: PhantomData,\n-        }\n+    pub fn last_edge(self) -> Handle<Self, marker::Edge> {\n+        let len = self.len();\n+        Handle::new_edge(self, len)\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n-    /// Turns the handle into a reference to the edge it points at. This is necessary because the\n-    /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n-    /// making it more suitable for moving down a chain of nodes.\n-    pub fn into_edge(self) -> &'a Node<K, V> {\n-        unsafe { self.node.edges().get_unchecked(self.index) }\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    pub unsafe fn deallocate_and_ascend(self) -> Option<\n+        Handle<\n+            NodeRef<\n+                marker::Owned,\n+                K, V,\n+                marker::Internal\n+            >,\n+            marker::Edge\n+        >\n+    > {\n+        let ptr = self.as_leaf() as *const LeafNode<K, V> as *const u8 as *mut u8;\n+        let ret = self.ascend().ok();\n+        heap::deallocate(ptr, mem::size_of::<LeafNode<K, V>>(), mem::align_of::<LeafNode<K, V>>());\n+        ret\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal> {\n-    /// Turns the handle into a mutable reference to the edge it points at. This is necessary\n-    /// because the returned pointer has a larger lifetime than what would be returned by\n-    /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n-    pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n-        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    pub unsafe fn deallocate_and_ascend(self) -> Option<\n+        Handle<\n+            NodeRef<\n+                marker::Owned,\n+                K, V,\n+                marker::Internal\n+            >,\n+            marker::Edge\n+        >\n+    > {\n+        let ptr = self.as_internal() as *const InternalNode<K, V> as *const u8 as *mut u8;\n+        let ret = self.ascend().ok();\n+        heap::deallocate(\n+            ptr,\n+            mem::size_of::<InternalNode<K, V>>(),\n+            mem::align_of::<InternalNode<K, V>>()\n+        );\n+        ret\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Target = Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n-    // This doesn't exist because there are no uses for it,\n-    // but is fine to add, analogous to edge_mut.\n-    //\n-    // /// Returns a reference to the edge pointed-to by this handle. This should not be\n-    // /// confused with `node`, which references the parent node of what is returned here.\n-    // pub fn edge(&self) -> &Node<K, V>\n-}\n-\n-pub enum ForceResult<NodeRef, Type> {\n-    Leaf(Handle<NodeRef, Type, handle::Leaf>),\n-    Internal(Handle<NodeRef, Type, handle::Internal>),\n-}\n+impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    unsafe fn cast_unchecked<NewType>(&mut self)\n+            -> NodeRef<marker::Mut, K, V, NewType> {\n \n-impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type>\n-    Handle<NodeRef, Type, handle::LeafOrInternal>\n-{\n-    /// Figure out whether this handle is pointing to something in a leaf node or to something in\n-    /// an internal node, clarifying the type according to the result.\n-    pub fn force(self) -> ForceResult<NodeRef, Type> {\n-        if self.node.is_leaf() {\n-            Leaf(Handle {\n-                node: self.node,\n-                index: self.index,\n-                marker: PhantomData,\n-            })\n-        } else {\n-            Internal(Handle {\n-                node: self.node,\n-                index: self.index,\n-                marker: PhantomData,\n-            })\n+        NodeRef {\n+            height: self.height,\n+            node: self.node,\n+            root: self.root,\n+            _marker: PhantomData\n         }\n     }\n-}\n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Tries to insert this key-value pair at the given index in this leaf node\n-    /// If the node is full, we have to split it.\n-    ///\n-    /// Returns a *mut V to the inserted value, because the caller may want this when\n-    /// they're done mutating the tree, but we don't want to borrow anything for now.\n-    pub fn insert_as_leaf(mut self, key: K, value: V) -> (InsertionResult<K, V>, *mut V) {\n-        if !self.node.is_full() {\n-            // The element can fit, just insert it\n-            (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n-        } else {\n-            // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.node.split();\n-            let left_len = self.node.len();\n-\n-            let ptr = unsafe {\n-                if self.index <= left_len {\n-                    self.node.insert_kv(self.index, key, value)\n-                } else {\n-                    // We need to subtract 1 because in splitting we took out new_key and new_val.\n-                    // Just being in the right node means we are past left_len k/v pairs in the\n-                    // left node and 1 k/v pair in the parent node.\n-                    new_right.insert_kv(self.index - left_len - 1, key, value)\n-                }\n-            } as *mut _;\n-\n-            (Split(new_key, new_val, new_right), ptr)\n-        }\n-    }\n-}\n-\n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n-    /// confused with `node`, which references the parent node of what is returned here.\n-    pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n-        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n-    }\n-\n-    /// Tries to insert this key-value pair at the given index in this internal node\n-    /// If the node is full, we have to split it.\n-    pub fn insert_as_internal(mut self,\n-                              key: K,\n-                              value: V,\n-                              right: Node<K, V>)\n-                              -> InsertionResult<K, V> {\n-        if !self.node.is_full() {\n-            // The element can fit, just insert it\n-            unsafe {\n-                self.node.insert_kv(self.index, key, value);\n-                self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n-            }\n-            Fit\n-        } else {\n-            // The element can't fit, this node is full. Split it into two nodes.\n-            let (new_key, new_val, mut new_right) = self.node.split();\n-            let left_len = self.node.len();\n \n-            if self.index <= left_len {\n-                unsafe {\n-                    self.node.insert_kv(self.index, key, value);\n-                    self.node.insert_edge(self.index + 1, right); // +1 to insert to the right\n-                }\n-            } else {\n-                unsafe {\n-                    // The -1 here is for the same reason as in insert_as_internal - because we\n-                    // split, there are actually left_len + 1 k/v pairs before the right node, with\n-                    // the extra 1 being put in the parent.\n-                    new_right.insert_kv(self.index - left_len - 1, key, value);\n-                    new_right.insert_edge(self.index - left_len, right);\n-                }\n-            }\n-\n-            Split(new_key, new_val, new_right)\n+    unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut, K, V, Type> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node,\n+            root: self.root,\n+            _marker: PhantomData\n         }\n     }\n \n-    /// Handle an underflow in this node's child. We favor handling \"to the left\" because we know\n-    /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n-    /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n-    /// (always slow, but at least faster since we know we're half-empty).\n-    /// Handling \"to the right\" reverses these roles. Of course, we merge whenever possible\n-    /// because we want dense nodes, and merging is about equal work regardless of direction.\n-    pub fn handle_underflow(mut self) {\n+    fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            if self.index > 0 {\n-                self.handle_underflow_to_left();\n-            } else {\n-                self.handle_underflow_to_right();\n-            }\n+            &mut **self.node\n         }\n     }\n \n-    /// Right is underflowed. Tries to steal from left,\n-    /// but merges left and right if left is low too.\n-    unsafe fn handle_underflow_to_left(&mut self) {\n-        let left_len = self.node.edges()[self.index - 1].len();\n-        if left_len > min_load_from_capacity(self.node.capacity()) {\n-            self.left_kv().steal_rightward();\n-        } else {\n-            self.left_kv().merge_children();\n-        }\n+    pub fn keys_mut(&mut self) -> &mut [K] {\n+        unsafe { self.reborrow_mut().into_slices_mut().0 }\n     }\n \n-    /// Left is underflowed. Tries to steal from the right,\n-    /// but merges left and right if right is low too.\n-    unsafe fn handle_underflow_to_right(&mut self) {\n-        let right_len = self.node.edges()[self.index + 1].len();\n-        if right_len > min_load_from_capacity(self.node.capacity()) {\n-            self.right_kv().steal_leftward();\n-        } else {\n-            self.right_kv().merge_children();\n-        }\n+    pub fn vals_mut(&mut self) -> &mut [V] {\n+        unsafe { self.reborrow_mut().into_slices_mut().1 }\n     }\n }\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n-    /// This is unsafe because the handle might point to the first edge in the node, which has no\n-    /// pair to its left.\n-    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index - 1,\n-            marker: PhantomData,\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    pub fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        unsafe {\n+            (\n+                slice::from_raw_parts(\n+                    self.as_leaf().keys.as_ptr(),\n+                    self.len()\n+                ),\n+                slice::from_raw_parts(\n+                    self.as_leaf().vals.as_ptr(),\n+                    self.len()\n+                )\n+            )\n         }\n     }\n+}\n \n-    /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n-    /// This is unsafe because the handle might point to the last edge in the node, which has no\n-    /// pair to its right.\n-    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index,\n-            marker: PhantomData,\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n+        unsafe {\n+            &mut *self.root\n         }\n     }\n-}\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n-    /// Turns the handle into references to the key and value it points at. This is necessary\n-    /// because the returned pointers have larger lifetimes than what would be returned by `key`\n-    /// or `val`.\n-    pub fn into_kv(self) -> (&'a K, &'a V) {\n-        let (keys, vals) = self.node.as_slices();\n+    pub fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         unsafe {\n-            (keys.get_unchecked(self.index),\n-             vals.get_unchecked(self.index))\n+            (\n+                slice::from_raw_parts_mut(\n+                    &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n+                    self.len()\n+                ),\n+                slice::from_raw_parts_mut(\n+                    &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n+                    self.len()\n+                )\n+            )\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n-    /// Turns the handle into mutable references to the key and value it points at. This is\n-    /// necessary because the returned pointers have larger lifetimes than what would be returned\n-    /// by `key_mut` or `val_mut`.\n-    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n-        let (keys, vals) = self.node.as_slices_mut();\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+    pub fn push(&mut self, key: K, val: V) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(self.len() < CAPACITY);\n+\n+        let idx = self.len();\n+\n         unsafe {\n-            (keys.get_unchecked_mut(self.index),\n-             vals.get_unchecked_mut(self.index))\n+            ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n+            ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n         }\n+\n+        self.as_leaf_mut().len += 1;\n     }\n \n-    /// Convert this handle into one pointing at the edge immediately to the left of the key/value\n-    /// pair pointed-to by this handle. This is useful because it returns a reference with larger\n-    /// lifetime than `left_edge`.\n-    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index,\n-            marker: PhantomData,\n+    pub fn push_front(&mut self, key: K, val: V) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(self.len() < CAPACITY);\n+\n+        unsafe {\n+            slice_insert(self.keys_mut(), 0, key);\n+            slice_insert(self.vals_mut(), 0, val);\n         }\n+\n+        self.as_leaf_mut().len += 1;\n     }\n }\n \n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(edge.height == self.height - 1);\n+        debug_assert!(self.len() < CAPACITY);\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target = Node<K, V>> + 'a, NodeType> Handle<NodeRef,\n-                                                                                  handle::KV,\n-                                                                                  NodeType> {\n-    // These are fine to include, but are currently unneeded.\n-    //\n-    // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n-    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n-    // /// handle.\n-    // pub fn key(&'a self) -> &'a K {\n-    //     unsafe { self.node.keys().get_unchecked(self.index) }\n-    // }\n-    //\n-    // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n-    // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n-    // /// handle.\n-    // pub fn val(&'a self) -> &'a V {\n-    //     unsafe { self.node.vals().get_unchecked(self.index) }\n-    // }\n-}\n+        let idx = self.len();\n \n-impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n-    where NodeRef: 'a + Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n-    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n-    /// handle.\n-    pub fn key_mut(&'a mut self) -> &'a mut K {\n-        unsafe { self.node.keys_mut().get_unchecked_mut(self.index) }\n-    }\n+        unsafe {\n+            ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n+            ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n+            ptr::write(self.as_internal_mut().edges.get_unchecked_mut(idx + 1), edge.node);\n \n-    /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n-    /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n-    /// handle.\n-    pub fn val_mut(&'a mut self) -> &'a mut V {\n-        unsafe { self.node.vals_mut().get_unchecked_mut(self.index) }\n-    }\n-}\n+            self.as_leaf_mut().len += 1;\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n-    /// to by this handle.\n-    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index,\n-            marker: PhantomData,\n+            Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n \n-    /// Gets the handle pointing to the edge immediately to the right of the key/value pair pointed\n-    /// to by this handle.\n-    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n-        Handle {\n-            node: &mut *self.node,\n-            index: self.index + 1,\n-            marker: PhantomData,\n+    pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(edge.height == self.height - 1);\n+        debug_assert!(self.len() < CAPACITY);\n+\n+        unsafe {\n+            slice_insert(self.keys_mut(), 0, key);\n+            slice_insert(self.vals_mut(), 0, val);\n+            slice_insert(\n+                slice::from_raw_parts_mut(\n+                    self.as_internal_mut().edges.as_mut_ptr(),\n+                    self.len()+1\n+                ),\n+                0,\n+                edge.node\n+            );\n+\n+            self.as_leaf_mut().len += 1;\n+\n+            for i in 0..self.len()+1 {\n+                Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n+            }\n         }\n-    }\n-}\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Removes the key/value pair at the handle's location.\n-    ///\n-    /// # Panics (in debug build)\n-    ///\n-    /// Panics if the node containing the pair is not a leaf node.\n-    pub fn remove_as_leaf(mut self) -> (K, V) {\n-        unsafe { self.node.remove_kv(self.index) }\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal>\n-    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n-{\n-    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n-    /// In this case, we're \"rotating\" right.\n-    unsafe fn steal_rightward(&mut self) {\n-        // Take the biggest stuff off left\n-        let (mut key, mut val, edge) = {\n-            let mut left_handle = self.left_edge();\n-            let left = left_handle.edge_mut();\n-            let (key, val) = left.pop_kv();\n-            let edge = if left.is_leaf() {\n-                None\n-            } else {\n-                Some(left.pop_edge())\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(self.len() > 0);\n+\n+        let idx = self.len() - 1;\n+\n+        unsafe {\n+            let key = ptr::read(self.keys().get_unchecked(idx));\n+            let val = ptr::read(self.vals().get_unchecked(idx));\n+            let edge = match self.reborrow_mut().force() {\n+                ForceResult::Leaf(_) => None,\n+                ForceResult::Internal(internal) => {\n+                    let edge = ptr::read(internal.as_internal().edges.get_unchecked(idx + 1));\n+                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n+                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    Some(new_root)\n+                }\n             };\n \n+            self.as_leaf_mut().len -= 1;\n             (key, val, edge)\n-        };\n-\n-        // Swap the parent's separating key-value pair with left's\n-        mem::swap(&mut key, self.key_mut());\n-        mem::swap(&mut val, self.val_mut());\n-\n-        // Put them at the start of right\n-        let mut right_handle = self.right_edge();\n-        let right = right_handle.edge_mut();\n-        right.insert_kv(0, key, val);\n-        match edge {\n-            Some(edge) => right.insert_edge(0, edge),\n-            None => {}\n         }\n     }\n \n-    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n-    /// In this case, we're \"rotating\" left.\n-    unsafe fn steal_leftward(&mut self) {\n-        // Take the smallest stuff off right\n-        let (mut key, mut val, edge) = {\n-            let mut right_handle = self.right_edge();\n-            let right = right_handle.edge_mut();\n-            let (key, val) = right.remove_kv(0);\n-            let edge = if right.is_leaf() {\n-                None\n-            } else {\n-                Some(right.remove_edge(0))\n-            };\n+    pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(self.len() > 0);\n \n-            (key, val, edge)\n-        };\n+        let old_len = self.len();\n \n-        // Swap the parent's separating key-value pair with right's\n-        mem::swap(&mut key, self.key_mut());\n-        mem::swap(&mut val, self.val_mut());\n-\n-        // Put them at the end of left\n-        let mut left_handle = self.left_edge();\n-        let left = left_handle.edge_mut();\n-        left.push_kv(key, val);\n-        match edge {\n-            Some(edge) => left.push_edge(edge),\n-            None => {}\n-        }\n-    }\n+        unsafe {\n+            let key = slice_remove(self.keys_mut(), 0);\n+            let val = slice_remove(self.vals_mut(), 0);\n+            let edge = match self.reborrow_mut().force() {\n+                ForceResult::Leaf(_) => None,\n+                ForceResult::Internal(mut internal) => {\n+                    let edge = slice_remove(\n+                        slice::from_raw_parts_mut(\n+                            internal.as_internal_mut().edges.as_mut_ptr(),\n+                            old_len+1\n+                        ),\n+                        0\n+                    );\n+\n+                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n+                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+\n+                    for i in 0..old_len {\n+                        Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n+                    }\n+\n+                    Some(new_root)\n+                }\n+            };\n \n-    /// Merge! Smooshes left and right into one node, along with the key-value\n-    /// pair that separated them in their parent.\n-    unsafe fn merge_children(mut self) {\n-        // Permanently remove right's index, and the key-value pair that separates\n-        // left and right\n-        let (key, val) = self.node.remove_kv(self.index);\n-        let right = self.node.remove_edge(self.index + 1);\n+            self.as_leaf_mut().len -= 1;\n \n-        // Give left right's stuff.\n-        self.left_edge()\n-            .edge_mut()\n-            .absorb(key, val, right);\n+            (key, val, edge)\n+        }\n     }\n }\n \n-impl<K, V> Node<K, V> {\n-    /// Returns the mutable handle pointing to the key/value pair at a given index.\n-    ///\n-    /// # Panics (in debug build)\n-    ///\n-    /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self,\n-                     index: usize)\n-                     -> Handle<&mut Node<K, V>, handle::KV, handle::LeafOrInternal> {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n-        Handle {\n-            node: self,\n-            index: index,\n-            marker: PhantomData,\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    pub fn force(self) -> ForceResult<\n+        NodeRef<BorrowType, K, V, marker::Leaf>,\n+        NodeRef<BorrowType, K, V, marker::Internal>\n+    > {\n+        if self.height == 0 {\n+            ForceResult::Leaf(NodeRef {\n+                height: self.height,\n+                node: self.node,\n+                root: self.root,\n+                _marker: PhantomData\n+            })\n+        } else {\n+            ForceResult::Internal(NodeRef {\n+                height: self.height,\n+                node: self.node,\n+                root: self.root,\n+                _marker: PhantomData\n+            })\n         }\n     }\n+}\n \n-    pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n-        self.as_slices_internal().iter()\n-    }\n+pub struct Handle<Node, Type> {\n+    node: Node,\n+    idx: usize,\n+    _marker: PhantomData<Type>\n+}\n \n-    pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n-        self.as_slices_internal_mut().iter_mut()\n+impl<Node: Copy, Type> Copy for Handle<Node, Type> { }\n+impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n+}\n \n-    pub fn into_iter(self) -> MoveTraversal<K, V> {\n-        unsafe {\n-            let ret = MoveTraversal {\n-                inner: MoveTraversalImpl {\n-                    keys: RawItems::from_slice(self.keys()),\n-                    vals: RawItems::from_slice(self.vals()),\n-                    edges: RawItems::from_slice(self.edges()),\n-\n-                    ptr: Unique::new(*self.keys as *mut u8),\n-                    capacity: self.capacity(),\n-                    is_leaf: self.is_leaf(),\n-                },\n-                head_is_edge: true,\n-                tail_is_edge: true,\n-                has_edges: !self.is_leaf(),\n-            };\n-            mem::forget(self);\n-            ret\n-        }\n+impl<Node, Type> Handle<Node, Type> {\n+    pub fn into_node(self) -> Node {\n+        self.node\n     }\n+}\n \n-    /// When a node has no keys or values and only a single edge, extract that edge.\n-    pub fn hoist_lone_child(&mut self) {\n+impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n+    pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n-        debug_assert!(self.is_empty());\n-        debug_assert!(!self.is_leaf());\n+        debug_assert!(idx < node.len());\n \n-        unsafe {\n-            let ret = ptr::read(self.edges().get_unchecked(0));\n-            self.destroy();\n-            ptr::write(self, ret);\n+        Handle {\n+            node: node,\n+            idx: idx,\n+            _marker: PhantomData\n         }\n     }\n-}\n-\n-// Vector functions (all unchecked)\n-impl<K, V> Node<K, V> {\n-    // This must be followed by push_edge on an internal node.\n-    #[inline]\n-    unsafe fn push_kv(&mut self, key: K, val: V) {\n-        let len = self.len();\n-\n-        ptr::write(self.keys_mut().get_unchecked_mut(len), key);\n-        ptr::write(self.vals_mut().get_unchecked_mut(len), val);\n \n-        self._len += 1;\n+    pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n+        Handle::new_edge(self.node, self.idx)\n     }\n \n-    // This can only be called immediately after a call to push_kv.\n-    #[inline]\n-    unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n-        let len = self.len();\n-\n-        ptr::write(self.edges_mut().get_unchecked_mut(len), edge);\n+    pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n+        Handle::new_edge(self.node, self.idx + 1)\n     }\n+}\n \n-    // This must be followed by insert_edge on an internal node.\n-    #[inline]\n-    unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n-        ptr::copy(self.keys().as_ptr().offset(index as isize),\n-                  self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n-                  self.len() - index);\n-        ptr::copy(self.vals().as_ptr().offset(index as isize),\n-                  self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n-                  self.len() - index);\n+impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n+        for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n-        ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n-        ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n+    fn eq(&self, other: &Self) -> bool {\n+        self.node.node == other.node.node && self.idx == other.idx\n+    }\n+}\n \n-        self._len += 1;\n+impl<BorrowType, K, V, NodeType, HandleType>\n+        Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n-        self.vals_mut().get_unchecked_mut(index)\n-    }\n+    pub fn reborrow(&self)\n+            -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n \n-    // This can only be called immediately after a call to insert_kv.\n-    #[inline]\n-    unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n-        ptr::copy(self.edges().as_ptr().offset(index as isize),\n-                  self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n-                  self.len() - index);\n-        ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n+        // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n+        Handle {\n+            node: self.node.reborrow(),\n+            idx: self.idx,\n+            _marker: PhantomData\n+        }\n     }\n+}\n \n-    // This must be followed by pop_edge on an internal node.\n-    #[inline]\n-    unsafe fn pop_kv(&mut self) -> (K, V) {\n-        let key = ptr::read(self.keys().get_unchecked(self.len() - 1));\n-        let val = ptr::read(self.vals().get_unchecked(self.len() - 1));\n+impl<'a, K, V, NodeType, HandleType>\n+        Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n \n-        self._len -= 1;\n+    pub unsafe fn reborrow_mut(&mut self)\n+            -> Handle<NodeRef<marker::Mut, K, V, NodeType>, HandleType> {\n \n-        (key, val)\n+        // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n+        Handle {\n+            node: self.node.reborrow_mut(),\n+            idx: self.idx,\n+            _marker: PhantomData\n+        }\n     }\n+}\n \n-    // This can only be called immediately after a call to pop_kv.\n-    #[inline]\n-    unsafe fn pop_edge(&mut self) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().get_unchecked(self.len() + 1));\n-\n-        edge\n-    }\n+impl<BorrowType, K, V, NodeType>\n+        Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n \n-    // This must be followed by remove_edge on an internal node.\n-    #[inline]\n-    unsafe fn remove_kv(&mut self, index: usize) -> (K, V) {\n-        let key = ptr::read(self.keys().get_unchecked(index));\n-        let val = ptr::read(self.vals().get_unchecked(index));\n+    pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(idx <= node.len());\n \n-        ptr::copy(self.keys().as_ptr().offset(index as isize + 1),\n-                  self.keys_mut().as_mut_ptr().offset(index as isize),\n-                  self.len() - index - 1);\n-        ptr::copy(self.vals().as_ptr().offset(index as isize + 1),\n-                  self.vals_mut().as_mut_ptr().offset(index as isize),\n-                  self.len() - index - 1);\n+        Handle {\n+            node: node,\n+            idx: idx,\n+            _marker: PhantomData\n+        }\n+    }\n \n-        self._len -= 1;\n+    pub fn left_kv(self)\n+            -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n \n-        (key, val)\n+        if self.idx > 0 {\n+            Ok(Handle::new_kv(self.node, self.idx - 1))\n+        } else {\n+            Err(self)\n+        }\n     }\n \n-    // This can only be called immediately after a call to remove_kv.\n-    #[inline]\n-    unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().get_unchecked(index));\n+    pub fn right_kv(self)\n+            -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n \n-        ptr::copy(self.edges().as_ptr().offset(index as isize + 1),\n-                  self.edges_mut().as_mut_ptr().offset(index as isize),\n-                  // index can be == len+1, so do the +1 first to avoid underflow.\n-                  (self.len() + 1) - index);\n-\n-        edge\n+        if self.idx < self.node.len() {\n+            Ok(Handle::new_kv(self.node, self.idx))\n+        } else {\n+            Err(self)\n+        }\n     }\n }\n \n-// Private implementation details\n-impl<K, V> Node<K, V> {\n-    /// Node is full, so split it into two nodes, and yield the middle-most key-value pair\n-    /// because we have one too many, and our parent now has one too few\n-    fn split(&mut self) -> (K, V, Node<K, V>) {\n-        // Necessary for correctness, but in a private function\n-        debug_assert!(!self.is_empty());\n-\n-        let mut right = if self.is_leaf() {\n-            Node::new_leaf(self.capacity())\n-        } else {\n-            unsafe { Node::new_internal(self.capacity()) }\n-        };\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+        // Necessary for correctness, but in a private module\n+        debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n-            right._len = self.len() / 2;\n-            let right_offset = self.len() - right.len();\n-            ptr::copy_nonoverlapping(self.keys().as_ptr().offset(right_offset as isize),\n-                                     right.keys_mut().as_mut_ptr(),\n-                                     right.len());\n-            ptr::copy_nonoverlapping(self.vals().as_ptr().offset(right_offset as isize),\n-                                     right.vals_mut().as_mut_ptr(),\n-                                     right.len());\n-            if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(self.edges().as_ptr().offset(right_offset as isize),\n-                                         right.edges_mut().as_mut_ptr(),\n-                                         right.len() + 1);\n-            }\n-\n-            let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n-            let val = ptr::read(self.vals().get_unchecked(right_offset - 1));\n+            slice_insert(self.node.keys_mut(), self.idx, key);\n+            slice_insert(self.node.vals_mut(), self.idx, val);\n \n-            self._len = right_offset - 1;\n+            self.node.as_leaf_mut().len += 1;\n \n-            (key, val, right)\n+            self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n     }\n \n-    /// Take all the values from right, separated by the given key and value\n-    fn absorb(&mut self, key: K, val: V, mut right: Node<K, V>) {\n-        // Necessary for correctness, but in a private function\n-        // Just as a sanity check, make sure we can fit this guy in\n-        debug_assert!(self.len() + right.len() <= self.capacity());\n-        debug_assert!(self.is_leaf() == right.is_leaf());\n+    pub fn insert(mut self, key: K, val: V)\n+            -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n \n-        unsafe {\n-            let old_len = self.len();\n-            self._len += right.len() + 1;\n-\n-            ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n-            ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n-\n-            ptr::copy_nonoverlapping(right.keys().as_ptr(),\n-                                     self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                                     right.len());\n-            ptr::copy_nonoverlapping(right.vals().as_ptr(),\n-                                     self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                                     right.len());\n-            if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(right.edges().as_ptr(),\n-                                         self.edges_mut()\n-                                             .as_mut_ptr()\n-                                             .offset(old_len as isize + 1),\n-                                         right.len() + 1);\n-            }\n-\n-            right.destroy();\n-            mem::forget(right);\n+        if self.node.len() < CAPACITY {\n+            let ptr = self.insert_fit(key, val);\n+            (InsertResult::Fit(Handle::new_kv(self.node, self.idx)), ptr)\n+        } else {\n+            let middle = Handle::new_kv(self.node, B);\n+            let (mut left, k, v, mut right) = middle.split();\n+            let ptr = if self.idx <= B {\n+                unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val)\n+                }\n+            } else {\n+                unsafe {\n+                    Handle::new_edge(\n+                        right.as_mut().cast_unchecked::<marker::Leaf>(),\n+                        self.idx - (B + 1)\n+                    ).insert_fit(key, val)\n+                }\n+            };\n+            (InsertResult::Split(left, k, v, right), ptr)\n         }\n     }\n }\n \n-/// Get the capacity of a node from the order of the parent B-Tree\n-fn capacity_from_b(b: usize) -> usize {\n-    2 * b - 1\n-}\n-\n-/// Get the minimum load of a node from its capacity\n-fn min_load_from_capacity(cap: usize) -> usize {\n-    // B - 1\n-    cap / 2\n-}\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+    fn correct_parent_link(mut self) {\n+        let idx = self.idx as u16;\n+        let ptr = self.node.as_internal_mut() as *mut _;\n+        let mut child = self.descend();\n+        child.as_leaf_mut().parent = ptr;\n+        child.as_leaf_mut().parent_idx = idx;\n+    }\n \n-/// A trait for pairs of `Iterator`s, one over edges and the other over key/value pairs. This is\n-/// necessary, as the `MoveTraversalImpl` needs to have a destructor that deallocates the `Node`,\n-/// and a pair of `Iterator`s would require two independent destructors.\n-pub trait TraversalImpl {\n-    type Item;\n-    type Edge;\n+    unsafe fn cast_unchecked<NewType>(&mut self)\n+            -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n \n-    fn next_kv(&mut self) -> Option<Self::Item>;\n-    fn next_kv_back(&mut self) -> Option<Self::Item>;\n+        Handle::new_edge(self.node.cast_unchecked(), self.idx)\n+    }\n \n-    fn next_edge(&mut self) -> Option<Self::Edge>;\n-    fn next_edge_back(&mut self) -> Option<Self::Edge>;\n-}\n+    fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        // Necessary for correctness, but in an internal module\n+        debug_assert!(self.node.len() < CAPACITY);\n+        debug_assert!(edge.height == self.node.height - 1);\n \n-/// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n-/// as no deallocation needs to be done.\n-#[derive(Clone)]\n-pub struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n+        unsafe {\n+            self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n+\n+            slice_insert(\n+                slice::from_raw_parts_mut(\n+                    self.node.as_internal_mut().edges.as_mut_ptr(),\n+                    self.node.len()\n+                ),\n+                self.idx + 1,\n+                edge.node\n+            );\n+\n+            for i in (self.idx+1)..(self.node.len()+1) {\n+                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n+            }\n+        }\n+    }\n \n-impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n-        TraversalImpl for ElemsAndEdges<Elems, Edges>\n-    where Elems : Iterator<Item=(K, V)>, Edges : Iterator<Item=E>\n-{\n-    type Item = (K, V);\n-    type Edge = E;\n+    pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n+            -> InsertResult<'a, K, V, marker::Internal> {\n \n-    fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }\n-    fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }\n+        // Necessary for correctness, but this is an internal module\n+        debug_assert!(edge.height == self.node.height - 1);\n \n-    fn next_edge(&mut self) -> Option<E> { self.1.next() }\n-    fn next_edge_back(&mut self) -> Option<E> { self.1.next_back() }\n+        if self.node.len() < CAPACITY {\n+            self.insert_fit(key, val, edge);\n+            InsertResult::Fit(Handle::new_kv(self.node, self.idx))\n+        } else {\n+            let middle = Handle::new_kv(self.node, B);\n+            let (mut left, k, v, mut right) = middle.split();\n+            if self.idx <= B {\n+                unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val, edge);\n+                }\n+            } else {\n+                unsafe {\n+                    Handle::new_edge(\n+                        right.as_mut().cast_unchecked::<marker::Internal>(),\n+                        self.idx - (B + 1)\n+                    ).insert_fit(key, val, edge);\n+                }\n+            }\n+            InsertResult::Split(left, k, v, right)\n+        }\n+    }\n }\n \n-/// A `TraversalImpl` taking a `Node` by value.\n-pub struct MoveTraversalImpl<K, V> {\n-    keys: RawItems<K>,\n-    vals: RawItems<V>,\n-    edges: RawItems<Node<K, V>>,\n+impl<BorrowType, K, V>\n+        Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n \n-    // For deallocation when we are done iterating.\n-    ptr: Unique<u8>,\n-    capacity: usize,\n-    is_leaf: bool,\n+    pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.node.height - 1,\n+            node: unsafe { self.node.as_internal().edges.get_unchecked(self.idx).as_ptr() },\n+            root: self.node.root,\n+            _marker: PhantomData\n+        }\n+    }\n }\n \n-unsafe impl<K: Sync, V: Sync> Sync for MoveTraversalImpl<K, V> {}\n-unsafe impl<K: Send, V: Send> Send for MoveTraversalImpl<K, V> {}\n-\n-impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n-    type Item = (K, V);\n-    type Edge = Node<K, V>;\n+impl<'a, K: 'a, V: 'a, NodeType>\n+        Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n \n-    fn next_kv(&mut self) -> Option<(K, V)> {\n-        match (self.keys.next(), self.vals.next()) {\n-            (Some(k), Some(v)) => Some((k, v)),\n-            _ => None,\n+    pub fn into_kv(self) -> (&'a K, &'a V) {\n+        let (keys, vals) = self.node.into_slices();\n+        unsafe {\n+            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n         }\n     }\n+}\n \n-    fn next_kv_back(&mut self) -> Option<(K, V)> {\n-        match (self.keys.next_back(), self.vals.next_back()) {\n-            (Some(k), Some(v)) => Some((k, v)),\n-            _ => None,\n-        }\n-    }\n+impl<'a, K: 'a, V: 'a, NodeType>\n+        Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n \n-    fn next_edge(&mut self) -> Option<Node<K, V>> {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(!self.is_leaf);\n-        self.edges.next()\n+    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n+        let (mut keys, mut vals) = self.node.into_slices_mut();\n+        unsafe {\n+            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+        }\n     }\n+}\n \n-    fn next_edge_back(&mut self) -> Option<Node<K, V>> {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(!self.is_leaf);\n-        self.edges.next_back()\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n+        unsafe {\n+            let (mut keys, mut vals) = self.node.reborrow_mut().into_slices_mut();\n+            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+        }\n     }\n }\n \n-impl<K, V> Drop for MoveTraversalImpl<K, V> {\n-    #[unsafe_destructor_blind_to_params]\n-    fn drop(&mut self) {\n-        // We need to cleanup the stored values manually, as the RawItems destructor would run\n-        // after our deallocation.\n-        for _ in self.keys.by_ref() {}\n-        for _ in self.vals.by_ref() {}\n-        for _ in self.edges.by_ref() {}\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    pub fn split(mut self)\n+            -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+        unsafe {\n+            let mut new_node = Box::new(LeafNode::new());\n+\n+            let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n+            let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n+\n+            let new_len = self.node.len() - self.idx - 1;\n+\n+            ptr::copy_nonoverlapping(\n+                self.node.keys().as_ptr().offset(self.idx as isize + 1),\n+                new_node.keys.as_mut_ptr(),\n+                new_len\n+            );\n+            ptr::copy_nonoverlapping(\n+                self.node.vals().as_ptr().offset(self.idx as isize + 1),\n+                new_node.vals.as_mut_ptr(),\n+                new_len\n+            );\n+\n+            self.node.as_leaf_mut().len = self.idx as u16;\n+            new_node.len = new_len as u16;\n+\n+            (\n+                self.node,\n+                k, v,\n+                Root {\n+                    node: BoxedNode::from_leaf(new_node),\n+                    height: 0\n+                }\n+            )\n+        }\n+    }\n \n-        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n-        unsafe { heap::deallocate(*self.ptr, size, alignment) };\n+    pub fn remove(mut self)\n+            -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+        unsafe {\n+            let k = slice_remove(self.node.keys_mut(), self.idx);\n+            let v = slice_remove(self.node.vals_mut(), self.idx);\n+            self.node.as_leaf_mut().len -= 1;\n+            (self.left_edge(), k, v)\n+        }\n     }\n }\n \n-/// An abstraction over all the different kinds of traversals a node supports\n-#[derive(Clone)]\n-pub struct AbsTraversal<Impl> {\n-    inner: Impl,\n-    head_is_edge: bool,\n-    tail_is_edge: bool,\n-    has_edges: bool,\n-}\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    pub fn split(mut self)\n+            -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n+        unsafe {\n+            let mut new_node = Box::new(InternalNode::new());\n+\n+            let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n+            let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n+\n+            let height = self.node.height;\n+            let new_len = self.node.len() - self.idx - 1;\n+\n+            ptr::copy_nonoverlapping(\n+                self.node.keys().as_ptr().offset(self.idx as isize + 1),\n+                new_node.data.keys.as_mut_ptr(),\n+                new_len\n+            );\n+            ptr::copy_nonoverlapping(\n+                self.node.vals().as_ptr().offset(self.idx as isize + 1),\n+                new_node.data.vals.as_mut_ptr(),\n+                new_len\n+            );\n+            ptr::copy_nonoverlapping(\n+                self.node.as_internal().edges.as_ptr().offset(self.idx as isize + 1),\n+                new_node.edges.as_mut_ptr(),\n+                new_len + 1\n+            );\n+\n+            self.node.as_leaf_mut().len = self.idx as u16;\n+            new_node.data.len = new_len as u16;\n+\n+            let mut new_root = Root {\n+                node: BoxedNode::from_internal(new_node),\n+                height: height\n+            };\n \n-/// A single atomic step in a traversal.\n-pub enum TraversalItem<K, V, E> {\n-    /// An element is visited. This isn't written as `Elem(K, V)` just because `opt.map(Elem)`\n-    /// requires the function to take a single argument. (Enum constructors are functions.)\n-    Elem((K, V)),\n-    /// An edge is followed.\n-    Edge(E),\n-}\n+            for i in 0..(new_len+1) {\n+                Handle::new_edge(new_root.as_mut().cast_unchecked(), i).correct_parent_link();\n+            }\n \n-/// A traversal over a node's entries and edges\n-pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n-                                                              slice::Iter<'a, V>>,\n-                                                          slice::Iter<'a, Node<K, V>>>>;\n+            (\n+                self.node,\n+                k, v,\n+                new_root\n+            )\n+        }\n+    }\n \n-/// A mutable traversal over a node's entries and edges\n-pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n-                                                                 slice::IterMut<'a, V>>,\n-                                                             slice::IterMut<'a, Node<K, V>>>>;\n+    pub fn can_merge(&self) -> bool {\n+        (\n+            self.reborrow()\n+                .left_edge()\n+                .descend()\n+                .len()\n+          + self.reborrow()\n+                .right_edge()\n+                .descend()\n+                .len()\n+          + 1\n+        ) <= CAPACITY\n+    }\n+\n+    pub fn merge(mut self)\n+            -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+        let self1 = unsafe { ptr::read(&self) };\n+        let self2 = unsafe { ptr::read(&self) };\n+        let mut left_node = self1.left_edge().descend();\n+        let left_len = left_node.len();\n+        let mut right_node = self2.right_edge().descend();\n+        let right_len = right_node.len();\n+\n+        // necessary for correctness, but in a private module\n+        debug_assert!(left_len + right_len + 1 <= CAPACITY);\n \n-/// An owning traversal over a node's entries and edges\n-pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n+        unsafe {\n+            ptr::write(left_node.keys_mut().get_unchecked_mut(left_len),\n+                       slice_remove(self.node.keys_mut(), self.idx));\n+            ptr::copy_nonoverlapping(\n+                right_node.keys().as_ptr(),\n+                left_node.keys_mut().as_mut_ptr().offset(left_len as isize + 1),\n+                right_len\n+            );\n+            ptr::write(left_node.vals_mut().get_unchecked_mut(left_len),\n+                       slice_remove(self.node.vals_mut(), self.idx));\n+            ptr::copy_nonoverlapping(\n+                right_node.vals().as_ptr(),\n+                left_node.vals_mut().as_mut_ptr().offset(left_len as isize + 1),\n+                right_len\n+            );\n+\n+            slice_remove(&mut self.node.as_internal_mut().edges, self.idx + 1);\n+            for i in self.idx+1..self.node.len() {\n+                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n+            }\n+            self.node.as_leaf_mut().len -= 1;\n+\n+            if self.node.height > 1 {\n+                ptr::copy_nonoverlapping(\n+                    right_node.cast_unchecked().as_internal().edges.as_ptr(),\n+                    left_node.cast_unchecked()\n+                             .as_internal_mut()\n+                             .edges\n+                             .as_mut_ptr()\n+                             .offset(left_len as isize + 1),\n+                    right_len + 1\n+                );\n+\n+                for i in left_len+1..left_len+right_len+2 {\n+                    Handle::new_edge(\n+                        left_node.cast_unchecked().reborrow_mut(),\n+                        i\n+                    ).correct_parent_link();\n+                }\n \n+                heap::deallocate(\n+                    *right_node.node as *mut u8,\n+                    mem::size_of::<InternalNode<K, V>>(),\n+                    mem::align_of::<InternalNode<K, V>>()\n+                );\n+            } else {\n+                heap::deallocate(\n+                    *right_node.node as *mut u8,\n+                    mem::size_of::<LeafNode<K, V>>(),\n+                    mem::align_of::<LeafNode<K, V>>()\n+                );\n+            }\n \n-impl<K, V, E, Impl> Iterator for AbsTraversal<Impl>\n-    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n-{\n-    type Item = TraversalItem<K, V, E>;\n+            left_node.as_leaf_mut().len += right_len as u16 + 1;\n \n-    fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item().map(Edge).or_else(|| self.next_kv_item().map(Elem))\n+            Handle::new_edge(self.node, self.idx)\n+        }\n     }\n }\n \n-impl<K, V, E, Impl> DoubleEndedIterator for AbsTraversal<Impl>\n-    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n-{\n-    fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item_back().map(Edge).or_else(|| self.next_kv_item_back().map(Elem))\n+impl<BorrowType, K, V, HandleType>\n+        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n+\n+    pub fn force(self) -> ForceResult<\n+        Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n+        Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>\n+    > {\n+        match self.node.force() {\n+            ForceResult::Leaf(node) => ForceResult::Leaf(Handle {\n+                node: node,\n+                idx: self.idx,\n+                _marker: PhantomData\n+            }),\n+            ForceResult::Internal(node) => ForceResult::Internal(Handle {\n+                node: node,\n+                idx: self.idx,\n+                _marker: PhantomData\n+            })\n+        }\n     }\n }\n \n-impl<K, V, E, Impl> AbsTraversal<Impl> where Impl: TraversalImpl<Item = (K, V), Edge = E> {\n-    /// Advances the iterator and returns the item if it's an edge. Returns None\n-    /// and does nothing if the first item is not an edge.\n-    pub fn next_edge_item(&mut self) -> Option<E> {\n-        // NB. `&& self.has_edges` might be redundant in this condition.\n-        let edge = if self.head_is_edge && self.has_edges {\n-            self.inner.next_edge()\n-        } else {\n-            None\n-        };\n-        self.head_is_edge = false;\n-        edge\n-    }\n-\n-    /// Advances the iterator and returns the item if it's an edge. Returns None\n-    /// and does nothing if the last item is not an edge.\n-    pub fn next_edge_item_back(&mut self) -> Option<E> {\n-        let edge = if self.tail_is_edge && self.has_edges {\n-            self.inner.next_edge_back()\n-        } else {\n-            None\n-        };\n-        self.tail_is_edge = false;\n-        edge\n-    }\n-\n-    /// Advances the iterator and returns the item if it's a key-value pair. Returns None\n-    /// and does nothing if the first item is not a key-value pair.\n-    pub fn next_kv_item(&mut self) -> Option<(K, V)> {\n-        if !self.head_is_edge {\n-            self.head_is_edge = true;\n-            self.inner.next_kv()\n-        } else {\n-            None\n-        }\n-    }\n+pub enum ForceResult<Leaf, Internal> {\n+    Leaf(Leaf),\n+    Internal(Internal)\n+}\n \n-    /// Advances the iterator and returns the item if it's a key-value pair. Returns None\n-    /// and does nothing if the last item is not a key-value pair.\n-    pub fn next_kv_item_back(&mut self) -> Option<(K, V)> {\n-        if !self.tail_is_edge {\n-            self.tail_is_edge = true;\n-            self.inner.next_kv_back()\n-        } else {\n-            None\n-        }\n-    }\n+pub enum InsertResult<'a, K, V, Type> {\n+    Fit(Handle<NodeRef<marker::Mut<'a>, K, V, Type>, marker::KV>),\n+    Split(NodeRef<marker::Mut<'a>, K, V, Type>, K, V, Root<K, V>)\n }\n \n-macro_rules! node_slice_impl {\n-    ($NodeSlice:ident, $Traversal:ident,\n-     $as_slices_internal:ident, $index:ident, $iter:ident) => {\n-        impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n-            /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n-            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (usize, bool)\n-                    where K: Borrow<Q>, Q: Ord {\n-                for (i, k) in self.keys.iter().enumerate() {\n-                    match key.cmp(k.borrow()) {\n-                        Greater => {},\n-                        Equal => return (i, true),\n-                        Less => return (i, false),\n-                    }\n-                }\n-                (self.keys.len(), false)\n-            }\n+pub mod marker {\n+    use core::marker::PhantomData;\n \n-            /// Returns a sub-slice with elements starting with `min_key`.\n-            pub fn slice_from<Q: ?Sized + Ord>(self, min_key: &Q) -> $NodeSlice<'a, K, V> where\n-                K: Borrow<Q>,\n-            {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                // \\___|___|___|___/  slice_from(&0); pos = 0\n-                //     \\___|___|___/  slice_from(&2); pos = 1\n-                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n-                //         \\___|___/  slice_from(&4); pos = 2\n-                //             \\___/  slice_from(&6); pos = 3\n-                //                \\|/ slice_from(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(min_key);\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(pos ..)\n-                    },\n-                    keys: &self.keys[pos ..],\n-                    vals: self.vals.$index(pos ..),\n-                    head_is_edge: !pos_is_kv,\n-                    tail_is_edge: self.tail_is_edge,\n-                }\n-            }\n+    pub enum Leaf { }\n+    pub enum Internal { }\n+    pub enum LeafOrInternal { }\n \n-            /// Returns a sub-slice with elements up to and including `max_key`.\n-            pub fn slice_to<Q: ?Sized + Ord>(self, max_key: &Q) -> $NodeSlice<'a, K, V> where\n-                K: Borrow<Q>,\n-            {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n-                // \\___/   |   |   |  slice_to(&2); pos = 1\n-                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n-                // \\___|___/   |   |  slice_to(&4); pos = 2\n-                // \\___|___|___/   |  slice_to(&6); pos = 3\n-                // \\___|___|___|___/  slice_to(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(max_key);\n-                let pos = pos + if pos_is_kv { 1 } else { 0 };\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(.. (pos + 1))\n-                    },\n-                    keys: &self.keys[..pos],\n-                    vals: self.vals.$index(.. pos),\n-                    head_is_edge: self.head_is_edge,\n-                    tail_is_edge: !pos_is_kv,\n-                }\n-            }\n-        }\n+    pub enum Owned { }\n+    pub struct Immut<'a>(PhantomData<&'a ()>);\n+    pub struct Mut<'a>(PhantomData<&'a mut ()>);\n \n-        impl<'a, K: 'a, V: 'a> $NodeSlice<'a, K, V> {\n-            /// Returns an iterator over key/value pairs and edges in a slice.\n-            #[inline]\n-            pub fn $iter(self) -> $Traversal<'a, K, V> {\n-                let mut edges = self.edges.$iter();\n-                // Skip edges at both ends, if excluded.\n-                if !self.head_is_edge { edges.next(); }\n-                if !self.tail_is_edge { edges.next_back(); }\n-                // The key iterator is always immutable.\n-                $Traversal {\n-                    inner: ElemsAndEdges(\n-                        self.keys.iter().zip(self.vals.$iter()),\n-                        edges\n-                    ),\n-                    head_is_edge: self.head_is_edge,\n-                    tail_is_edge: self.tail_is_edge,\n-                    has_edges: self.has_edges,\n-                }\n-            }\n-        }\n-    }\n+    pub enum KV { }\n+    pub enum Edge { }\n }\n \n-node_slice_impl!(NodeSlice, Traversal, as_slices_internal, index, iter);\n-node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, index_mut, iter_mut);\n+unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n+    ptr::copy(\n+        slice.as_ptr().offset(idx as isize),\n+        slice.as_mut_ptr().offset(idx as isize + 1),\n+        slice.len() - idx\n+    );\n+    ptr::write(slice.get_unchecked_mut(idx), val);\n+}\n+\n+unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n+    let ret = ptr::read(slice.get_unchecked(idx));\n+    ptr::copy(\n+        slice.as_ptr().offset(idx as isize + 1),\n+        slice.as_mut_ptr().offset(idx as isize),\n+        slice.len() - idx - 1\n+    );\n+    ret\n+}"}, {"sha": "c94b570bfed8b06dbf85e30acd1ff9331f3d3c55", "filename": "src/libcollections/btree/search.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fsearch.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cmp::Ordering;\n+\n+use borrow::Borrow;\n+\n+use super::node::{Handle, NodeRef, marker};\n+\n+use super::node::ForceResult::*;\n+use self::SearchResult::*;\n+\n+pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n+    Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n+    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>)\n+}\n+\n+pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n+    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    key: &Q\n+) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n+        where Q: Ord, K: Borrow<Q> {\n+\n+    loop {\n+        match search_node(node, key) {\n+            Found(handle) => return Found(handle),\n+            GoDown(handle) => match handle.force() {\n+                Leaf(leaf) => return GoDown(leaf),\n+                Internal(internal) => {\n+                    node = internal.descend();\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n+    node: NodeRef<BorrowType, K, V, Type>,\n+    key: &Q\n+) -> SearchResult<BorrowType, K, V, Type, Type>\n+        where Q: Ord, K: Borrow<Q> {\n+\n+    match search_linear(&node, key) {\n+        (idx, true) => Found(\n+            Handle::new_kv(node, idx)\n+        ),\n+        (idx, false) => SearchResult::GoDown(\n+            Handle::new_edge(node, idx)\n+        )\n+    }\n+}\n+\n+fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+    node: &NodeRef<BorrowType, K, V, Type>,\n+    key: &Q\n+) -> (usize, bool)\n+        where Q: Ord, K: Borrow<Q> {\n+\n+    for (i, k) in node.keys().iter().enumerate() {\n+        match key.cmp(k.borrow()) {\n+            Ordering::Greater => {},\n+            Ordering::Equal => return (i, true),\n+            Ordering::Less => return (i, false)\n+        }\n+    }\n+    (node.keys().len(), false)\n+}\n+"}, {"sha": "41f52b670791e5181ad419fc8fafd856d5f1d76d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -43,8 +43,8 @@\n #![feature(iter_arith)]\n #![feature(iter_arith)]\n #![feature(lang_items)]\n+#![feature(nonzero)]\n #![feature(num_bits_bytes)]\n-#![feature(oom)]\n #![feature(pattern)]\n #![feature(shared)]\n #![feature(slice_bytes)]\n@@ -55,7 +55,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(unsafe_no_drop_flag)]\n #![cfg_attr(test, feature(clone_from_slice, rand, test))]\n \n #![no_std]"}, {"sha": "c4473b64066d5f292d54dfffb0fdb63215c4724f", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88463364bfb675fdecd2bf9b70c589cc5e7cb2fb/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=88463364bfb675fdecd2bf9b70c589cc5e7cb2fb", "patch": "@@ -346,6 +346,38 @@ fn test_bad_zst() {\n     }\n }\n \n+#[test]\n+fn test_clone() {\n+    let mut map = BTreeMap::new();\n+    let size = 100;\n+    assert_eq!(map.len(), 0);\n+\n+    for i in 0..size {\n+        assert_eq!(map.insert(i, 10*i), None);\n+        assert_eq!(map.len(), i + 1);\n+        assert_eq!(map, map.clone());\n+    }\n+\n+    for i in 0..size {\n+        assert_eq!(map.insert(i, 100*i), Some(10*i));\n+        assert_eq!(map.len(), size);\n+        assert_eq!(map, map.clone());\n+    }\n+\n+    for i in 0..size/2 {\n+        assert_eq!(map.remove(&(i*2)), Some(i*200));\n+        assert_eq!(map.len(), size - i - 1);\n+        assert_eq!(map, map.clone());\n+    }\n+\n+    for i in 0..size/2 {\n+        assert_eq!(map.remove(&(2*i)), None);\n+        assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n+        assert_eq!(map.len(), size/2 - i - 1);\n+        assert_eq!(map, map.clone());\n+    }\n+}\n+\n mod bench {\n     use std::collections::BTreeMap;\n     use std::__rand::{Rng, thread_rng};"}]}