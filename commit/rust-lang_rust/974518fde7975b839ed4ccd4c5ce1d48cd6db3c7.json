{"sha": "974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDUxOGZkZTc5NzViODM5ZWQ0Y2NkNGM1Y2UxZDQ4Y2Q2ZGIzYzc=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-09-01T08:26:10Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-10-08T02:04:20Z"}, "message": "Code reorganisation and field support", "tree": {"sha": "cf25ef47c5531ca9934842a963afaabe78fc525f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf25ef47c5531ca9934842a963afaabe78fc525f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "html_url": "https://github.com/rust-lang/rust/commit/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14194b428efdb09cc45f9862ec34bef0038cd35", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14194b428efdb09cc45f9862ec34bef0038cd35", "html_url": "https://github.com/rust-lang/rust/commit/a14194b428efdb09cc45f9862ec34bef0038cd35"}], "stats": {"total": 165, "additions": 105, "deletions": 60}, "files": [{"sha": "1dd6d73f380774d598a6397d9a1f13e02c01b9d0", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -35,7 +35,7 @@ use hir_ty::{\n     traits::SolutionVariables,\n     ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n     InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n-    TyDefId, TyKind, TypeCtor,\n+    TyDefId, TyKind, TypeCtor, TyLoweringContext, TypeCtor,\n };\n use rustc_hash::FxHashSet;\n use stdx::impl_from;\n@@ -186,6 +186,25 @@ impl_from!(\n     for ModuleDef\n );\n \n+impl From<MethodOwner> for ModuleDef {\n+    fn from(mowner: MethodOwner) -> Self {\n+        match mowner {\n+            MethodOwner::Trait(t) => t.into(),\n+            MethodOwner::Adt(t) => t.into(),\n+        }\n+    }\n+}\n+\n+impl From<VariantDef> for ModuleDef {\n+    fn from(var: VariantDef) -> Self {\n+        match var {\n+            VariantDef::Struct(t) => Adt::from(t).into(),\n+            VariantDef::Union(t) => Adt::from(t).into(),\n+            VariantDef::EnumVariant(t) => t.into(),\n+        }\n+    }\n+}\n+\n impl ModuleDef {\n     pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n         match self {\n@@ -752,8 +771,35 @@ impl Function {\n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         hir_ty::diagnostics::validate_body(db, self.id.into(), sink)\n     }\n+\n+    pub fn parent_def(self, db: &dyn HirDatabase) -> Option<MethodOwner> {\n+        match self.as_assoc_item(db).map(|assoc| assoc.container(db)) {\n+            Some(AssocItemContainer::Trait(t)) => Some(t.into()),\n+            Some(AssocItemContainer::ImplDef(imp)) => {\n+                let resolver = ModuleId::from(imp.module(db)).resolver(db.upcast());\n+                let ctx = TyLoweringContext::new(db, &resolver);\n+                let adt = Ty::from_hir(\n+                    &ctx,\n+                    &imp.target_trait(db).unwrap_or_else(|| imp.target_type(db)),\n+                )\n+                .as_adt()\n+                .map(|t| t.0)\n+                .unwrap();\n+                Some(Adt::from(adt).into())\n+            }\n+            None => None,\n+        }\n+    }\n }\n \n+#[derive(Debug)]\n+pub enum MethodOwner {\n+    Trait(Trait),\n+    Adt(Adt),\n+}\n+\n+impl_from!(Trait, Adt for MethodOwner);\n+\n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n pub enum Access {\n     Shared,"}, {"sha": "512c42c4d169d8a4a89621565c0bc920c198459e", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -2,20 +2,27 @@\n //!\n //! Most of the implementation can be found in [`hir::doc_links`].\n \n-use hir::{Adt, Crate, HasAttrs, ModuleDef};\n-use ide_db::{defs::Definition, RootDatabase};\n-use pulldown_cmark::{CowStr, Event, LinkType, Options, Parser, Tag};\n+use std::iter::once;\n+\n+use itertools::Itertools;\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n+use pulldown_cmark::{CowStr, Event, LinkType, Options, Parser, Tag};\n use url::Url;\n \n-use crate::{FilePosition, Semantics};\n-use hir::{get_doc_link, resolve_doc_link};\n+use ide_db::{defs::Definition, RootDatabase};\n+\n+use hir::{\n+    db::{DefDatabase, HirDatabase},\n+    Adt, AsName, AssocItem, Crate, Field, HasAttrs, ItemInNs, ModuleDef,\n+};\n use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n+use crate::{FilePosition, Semantics};\n+\n pub type DocumentationLink = String;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n@@ -100,64 +107,58 @@ pub fn get_doc_link<T: Resolvable + Clone>(db: &dyn HirDatabase, definition: &T)\n // BUG: For Option\n // Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some\n // Instead of https://doc.rust-lang.org/nightly/core/option/enum.Option.html\n-fn get_doc_link_impl(db: &dyn HirDatabase, moddef: &ModuleDef) -> Option<String> {\n+// This could be worked around by turning the `EnumVariant` into `Enum` before attempting resolution,\n+// but it's really just working around the problem. Ideally we need to implement a slightly different\n+// version of import map which follows the same process as rustdoc. Otherwise there'll always be some\n+// edge cases where we select the wrong import path.\n+fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n     // Get the outermost definition for the moduledef. This is used to resolve the public path to the type,\n     // then we can join the method, field, etc onto it if required.\n-    let target_def: ModuleDef = match moddef {\n-        ModuleDef::Function(f) => match f.as_assoc_item(db).map(|assoc| assoc.container(db)) {\n-            Some(AssocItemContainer::Trait(t)) => t.into(),\n-            Some(AssocItemContainer::ImplDef(imp)) => {\n-                let resolver = ModuleId::from(imp.module(db)).resolver(db.upcast());\n-                let ctx = TyLoweringContext::new(db, &resolver);\n-                Adt::from(\n-                    Ty::from_hir(\n-                        &ctx,\n-                        &imp.target_trait(db).unwrap_or_else(|| imp.target_type(db)),\n-                    )\n-                    .as_adt()\n-                    .map(|t| t.0)\n-                    .unwrap(),\n-                )\n-                .into()\n+    let target_def: ModuleDef = match definition {\n+        Definition::ModuleDef(moddef) => match moddef {\n+            ModuleDef::Function(f) => {\n+                f.parent_def(db).map(|mowner| mowner.into()).unwrap_or_else(|| f.clone().into())\n             }\n-            None => ModuleDef::Function(*f),\n+            moddef => moddef,\n         },\n-        moddef => *moddef,\n+        Definition::Field(f) => f.parent_def(db).into(),\n+        // FIXME: Handle macros\n+        _ => return None,\n     };\n \n     let ns = ItemInNs::Types(target_def.clone().into());\n \n-    let module = moddef.module(db)?;\n+    let module = definition.module(db)?;\n     let krate = module.krate();\n     let import_map = db.import_map(krate.into());\n     let base = once(krate.display_name(db).unwrap())\n         .chain(import_map.path_of(ns).unwrap().segments.iter().map(|name| format!(\"{}\", name)))\n         .join(\"/\");\n \n-    get_doc_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, &target_def).as_deref().and_then(|f| url.join(f).ok())\n-        })\n-        .and_then(|url| match moddef {\n+    let filename = get_symbol_filename(db, &target_def);\n+    let fragment = match definition {\n+        Definition::ModuleDef(moddef) => match moddef {\n             ModuleDef::Function(f) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Function(*f)))\n-                    .as_deref()\n-                    .and_then(|f| url.join(f).ok())\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Function(f)))\n             }\n             ModuleDef::Const(c) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Const(*c)))\n-                    .as_deref()\n-                    .and_then(|f| url.join(f).ok())\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Const(c)))\n             }\n             ModuleDef::TypeAlias(ty) => {\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::TypeAlias(*ty)))\n-                    .as_deref()\n-                    .and_then(|f| url.join(f).ok())\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::TypeAlias(ty)))\n             }\n-            // TODO:  Field <- this requires passing in a definition or something\n-            _ => Some(url),\n-        })\n+            _ => None,\n+        },\n+        Definition::Field(field) => get_symbol_fragment(db, &FieldOrAssocItem::Field(field)),\n+        _ => None,\n+    };\n+\n+    get_doc_url(db, &krate)\n+        .and_then(|url| url.join(&base).ok())\n+        .and_then(|url| filename.as_deref().and_then(|f| url.join(f).ok()))\n+        .and_then(\n+            |url| if let Some(fragment) = fragment { url.join(&fragment).ok() } else { Some(url) },\n+        )\n         .map(|url| url.into_string())\n }\n \n@@ -219,9 +220,8 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n         .map(|url| url.into_string())\n }\n \n-// FIXME: This should either be moved, or the module should be renamed.\n /// Retrieve a link to documentation for the given symbol.\n-pub fn get_doc_url(db: &RootDatabase, position: &FilePosition) -> Option<DocumentationLink> {\n+pub fn external_docs(db: &RootDatabase, position: &FilePosition) -> Option<DocumentationLink> {\n     let sema = Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let token = pick_best(file.token_at_offset(position.offset))?;\n@@ -236,14 +236,7 @@ pub fn get_doc_url(db: &RootDatabase, position: &FilePosition) -> Option<Documen\n         }\n     };\n \n-    match definition? {\n-        Definition::Macro(t) => get_doc_link(db, &t),\n-        Definition::Field(t) => get_doc_link(db, &t),\n-        Definition::ModuleDef(t) => get_doc_link(db, &t),\n-        Definition::SelfType(t) => get_doc_link(db, &t),\n-        Definition::Local(t) => get_doc_link(db, &t),\n-        Definition::TypeParam(t) => get_doc_link(db, &t),\n-    }\n+    get_doc_link(db, definition?)\n }\n \n /// Rewrites a markdown document, applying 'callback' to each link."}, {"sha": "5db6e1311fd43d20b1fc3cbb5793c6d4a2fd1ab3", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -387,7 +387,7 @@ impl Analysis {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<doc_links::DocumentationLink>> {\n-        self.with_db(|db| doc_links::get_doc_url(db, &position))\n+        self.with_db(|db| doc_links::external_docs(db, &position))\n     }\n \n     /// Computes parameter information for the given call expression."}, {"sha": "f5ee3484b0ce95d9be1bb51c5c57498f82d85313", "filename": "crates/stdx/src/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fstdx%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/crates%2Fstdx%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fmacros.rs?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -18,7 +18,13 @@ macro_rules! format_to {\n     };\n }\n \n-// Generates `From` impls for `Enum E { Foo(Foo), Bar(Bar) }` enums\n+/// Generates `From` impls for `Enum E { Foo(Foo), Bar(Bar) }` enums\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// impl_from!(Struct, Union, Enum for Adt);\n+/// ```\n #[macro_export]\n macro_rules! impl_from {\n     ($($variant:ident $(($($sub_variant:ident),*))?),* for $enum:ident) => {"}, {"sha": "24c2e196dbf2240cc95a7ab3eeaed0dd16740b67", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -421,12 +421,10 @@ export function gotoLocation(ctx: Ctx): Cmd {\n \n export function openDocs(ctx: Ctx): Cmd {\n     return async () => {\n-        console.log(\"running openDocs\");\n \n         const client = ctx.client;\n         const editor = vscode.window.activeTextEditor;\n         if (!editor || !client) {\n-            console.log(\"not yet ready\");\n             return\n         };\n \n@@ -435,7 +433,9 @@ export function openDocs(ctx: Ctx): Cmd {\n \n         const doclink = await client.sendRequest(ra.openDocs, { position, textDocument });\n \n-        vscode.commands.executeCommand(\"vscode.open\", vscode.Uri.parse(doclink.remote));\n+        if (doclink != null) {\n+            vscode.commands.executeCommand(\"vscode.open\", vscode.Uri.parse(doclink));\n+        }\n     };\n \n }"}, {"sha": "fc8e120b3fc6d8854f0e7bd68607e9aae77fe91f", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/974518fde7975b839ed4ccd4c5ce1d48cd6db3c7/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=974518fde7975b839ed4ccd4c5ce1d48cd6db3c7", "patch": "@@ -119,4 +119,4 @@ export interface CommandLinkGroup {\n     commands: CommandLink[];\n }\n \n-export const openDocs = new lc.RequestType<lc.TextDocumentPositionParams, String | void, void>('experimental/externalDocs');\n+export const openDocs = new lc.RequestType<lc.TextDocumentPositionParams, string | void, void>('experimental/externalDocs');"}]}