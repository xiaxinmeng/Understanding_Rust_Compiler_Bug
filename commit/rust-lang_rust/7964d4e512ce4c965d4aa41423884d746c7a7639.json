{"sha": "7964d4e512ce4c965d4aa41423884d746c7a7639", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NjRkNGU1MTJjZTRjOTY1ZDRhYTQxNDIzODg0ZDc0NmM3YTc2Mzk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:52:48Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:52:48Z"}, "message": "Rollup merge of #25321 - steveklabnik:second_tutorial, r=alexcrichton\n\nThis is a little rough, and it needs squashed and section headers, but i'd like to get some eyes on it sooner rather than later.", "tree": {"sha": "992374abb80c66c39a11360dc575914934f89a8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/992374abb80c66c39a11360dc575914934f89a8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7964d4e512ce4c965d4aa41423884d746c7a7639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7964d4e512ce4c965d4aa41423884d746c7a7639", "html_url": "https://github.com/rust-lang/rust/commit/7964d4e512ce4c965d4aa41423884d746c7a7639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7964d4e512ce4c965d4aa41423884d746c7a7639/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe8a4e3dbf71037ab5b8e1edd89b29d423287646", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8a4e3dbf71037ab5b8e1edd89b29d423287646", "html_url": "https://github.com/rust-lang/rust/commit/fe8a4e3dbf71037ab5b8e1edd89b29d423287646"}, {"sha": "2ba61698ccb2c43ad1ea081988ef499735bfa62d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba61698ccb2c43ad1ea081988ef499735bfa62d", "html_url": "https://github.com/rust-lang/rust/commit/2ba61698ccb2c43ad1ea081988ef499735bfa62d"}], "stats": {"total": 691, "additions": 691, "deletions": 0}, "files": [{"sha": "68cca29439848bbba1f7ccb2f5c85ad34b9a8dec", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7964d4e512ce4c965d4aa41423884d746c7a7639/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/7964d4e512ce4c965d4aa41423884d746c7a7639/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=7964d4e512ce4c965d4aa41423884d746c7a7639", "patch": "@@ -6,6 +6,7 @@\n     * [Hello, Cargo!](hello-cargo.md)\n * [Learn Rust](learn-rust.md)\n     * [Guessing Game](guessing-game.md)\n+    * [Dining Philosophers](dining-philosophers.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)"}, {"sha": "b1bea4f819ef4b0120759fbf1bbd716db4efcfcf", "filename": "src/doc/trpl/dining-philosophers.md", "status": "added", "additions": 690, "deletions": 0, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/7964d4e512ce4c965d4aa41423884d746c7a7639/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/7964d4e512ce4c965d4aa41423884d746c7a7639/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=7964d4e512ce4c965d4aa41423884d746c7a7639", "patch": "@@ -0,0 +1,690 @@\n+% Dining Philosophers\n+\n+For our second project, let\u2019s look at a classic concurrency problem. It\u2019s\n+called \u2018the dining philosophers\u2019. It was originally conceived by Dijkstra in\n+1965, but we\u2019ll use the version from [this paper][paper] by Tony Hoare in 1985.\n+\n+[paper]: http://www.usingcsp.com/cspbook.pdf\n+\n+> In ancient times, a wealthy philanthropist endowed a College to accommodate\n+> five eminent philosophers. Each philosopher had a room in which he could\n+> engage in his professional activity of thinking; there was also a common\n+> dining room, furnished with a circular table, surrounded by five chairs, each\n+> labelled by the name of the philosopher who was to sit in it. They sat\n+> anticlockwise around the table. To the left of each philosopher there was\n+> laid a golden fork, and in the centre stood a large bowl of spaghetti, which\n+> was constantly replenished. A philosopher was expected to spend most of his\n+> time thinking; but when he felt hungry, he went to the dining room, sat down\n+> in his own chair, picked up his own fork on his left, and plunged it into the\n+> spaghetti. But such is the tangled nature of spaghetti that a second fork is\n+> required to carry it to the mouth. The philosopher therefore had also to pick\n+> up the fork on his right. When we was finished he would put down both his\n+> forks, get up from his chair, and continue thinking. Of course, a fork can be\n+> used by only one philosopher at a time. If the other philosopher wants it, he\n+> just has to wait until the fork is available again.\n+\n+This classic problem shows off a few different elements of concurrency. The\n+reason is that it's actually slightly tricky to implement: a simple\n+implementation can deadlock. For example, let's consider a simple algorithm\n+that would solve this problem:\n+\n+1. A philosopher picks up the fork on their left.\n+2. They then pick up the fork on their right.\n+3. They eat.\n+4. They return the forks.\n+\n+Now, let\u2019s imagine this sequence of events:\n+\n+1. Philosopher 1 begins the algorithm, picking up the fork on their left.\n+2. Philosopher 2 begins the algorithm, picking up the fork on their left.\n+3. Philosopher 3 begins the algorithm, picking up the fork on their left.\n+4. Philosopher 4 begins the algorithm, picking up the fork on their left.\n+5. Philosopher 5 begins the algorithm, picking up the fork on their left.\n+6. ... ? All the forks are taken, but nobody can eat!\n+\n+There are different ways to solve this problem. We\u2019ll get to our solution in\n+the tutorial itself. For now, let\u2019s get started modelling the problem itself.\n+We\u2019ll start with the philosophers:\n+\n+```rust\n+struct Philosopher {\n+    name: String,\n+}\n+\n+impl Philosopher {\n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p2 = Philosopher::new(\"Gilles Deleuze\");\n+    let p3 = Philosopher::new(\"Karl Marx\");\n+    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p5 = Philosopher::new(\"Michel Foucault\");\n+}\n+```\n+\n+Here, we make a [`struct`][struct] to represent a philosopher. For now,\n+a name is all we need. We choose the [`String`][string] type for the name,\n+rather than `&str`. Generally speaking, working with a type which owns its\n+data is easier than working with one that uses references.\n+\n+Let\u2019s continue:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+impl Philosopher {\n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+}\n+```\n+\n+This `impl` block lets us define things on `Philosopher` structs. In this case,\n+we define an \u2018associated function\u2019 called `new`. The first line looks like this:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# impl Philosopher {\n+fn new(name: &str) -> Philosopher {\n+#         Philosopher {\n+#             name: name.to_string(),\n+#         }\n+#     }\n+# }\n+```\n+\n+We take one argument, a `name`, of type `&str`. This is a reference to another\n+string. It returns an instance of our `Philosopher` struct.\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# impl Philosopher {\n+#    fn new(name: &str) -> Philosopher {\n+Philosopher {\n+    name: name.to_string(),\n+}\n+#     }\n+# }\n+```\n+\n+This creates a new `Philosopher`, and sets its `name` to our `name` argument.\n+Not just the argument itself, though, as we call `.to_string()` on it. This\n+will create a copy of the string that our `&str` points to, and give us a new\n+`String`, which is the type of the `name` field of `Philosopher`.\n+\n+Why not accept a `String` directly? It\u2019s nicer to call. If we took a `String`,\n+but our caller had a `&str`, they\u2019d have to call this method themselves. The\n+downside of this flexibility is that we _always_ make a copy. For this small\n+program, that\u2019s not particularly important, as we know we\u2019ll just be using\n+short strings anyway.\n+\n+One last thing you\u2019ll notice: we just define a `Philosopher`, and seemingly\n+don\u2019t do anything with it. Rust is an \u2018expression based\u2019 language, which means\n+that almost everything in Rust is an expression which returns a value. This is\n+true of functions as well, the last expression is automatically returned. Since\n+we create a new `Philosopher` as the last expression of this function, we end\n+up returning it.\n+\n+This name, `new()`, isn\u2019t anything special to Rust, but it is a convention for\n+functions that create new instances of structs. Before we talk about why, let\u2019s\n+look at `main()` again:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# \n+# impl Philosopher {\n+#     fn new(name: &str) -> Philosopher {\n+#         Philosopher {\n+#             name: name.to_string(),\n+#         }\n+#     }\n+# }\n+# \n+fn main() {\n+    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p2 = Philosopher::new(\"Gilles Deleuze\");\n+    let p3 = Philosopher::new(\"Karl Marx\");\n+    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p5 = Philosopher::new(\"Michel Foucault\");\n+}\n+```\n+\n+Here, we create five variable bindings with five new philosophers. These are my\n+favorite five, but you can substitute anyone you want. If we _didn\u2019t_ define\n+that `new()` function, it would look like this:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+fn main() {\n+    let p1 = Philosopher { name: \"Baruch Spinoza\".to_string() };\n+    let p2 = Philosopher { name: \"Gilles Deleuze\".to_string() };\n+    let p3 = Philosopher { name: \"Karl Marx\".to_string() };\n+    let p4 = Philosopher { name: \"Friedrich Nietzche\".to_string() };\n+    let p5 = Philosopher { name: \"Michel Foucault\".to_string() };\n+}\n+```\n+\n+That\u2019s much noisier. Using `new` has other advantages too, but even in\n+this simple case, it ends up being nicer to use.\n+\n+Now that we\u2019ve got the basics in place, there\u2019s a number of ways that we can\n+tackle the broader problem here. I like to start from the end first: let\u2019s\n+set up a way for each philosopher to finish eating. As a tiny step, let\u2019s make\n+a method, and then loop through all the philosophers, calling it:\n+\n+```rust\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+    \n+    fn eat(&self) {\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    for p in &philosophers {\n+        p.eat();\n+    }\n+}\n+```\n+\n+Let\u2019s look at `main()` first. Rather than have five individual variable\n+bindings for our philosophers, we make a `Vec<T>` of them instead. `Vec<T>` is\n+also called a \u2018vector\u2019, and it\u2019s a growable array type. We then use a\n+[`for`][for] loop to iterate through the vector, getting a reference to each\n+philosopher in turn.\n+\n+[for]: for-loops.html\n+\n+In the body of the loop, we call `p.eat()`, which is defined above:\n+\n+```rust,ignore\n+fn eat(&self) {\n+    println!(\"{} is done eating.\", self.name);\n+}\n+```\n+\n+In Rust, methods take an explicit `self` parameter. That\u2019s why `eat()` is a\n+method, but `new` is an associated function: `new()` has no `self`. For our\n+first version of `eat()`, we just print out the name of the philosopher, and\n+mention they\u2019re done eating. Running this program should give you the following\n+output:\n+\n+```text\n+Baruch Spinoza is done eating.\n+Gilles Deleuze is done eating.\n+Karl Marx is done eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+Easy enough, they\u2019re all done! We haven\u2019t actually implemented the real problem\n+yet, though, so we\u2019re not done yet!\n+\n+Next, we want to make our philosophers not just finish eating, but actually\n+eat. Here\u2019s the next version:\n+\n+```rust\n+use std::thread;\n+\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+    \n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    for p in &philosophers {\n+        p.eat();\n+    }\n+}\n+```\n+\n+Just a few changes. Let\u2019s break it down.\n+\n+```rust,ignore\n+use std::thread;\n+```\n+\n+`use` brings names into scope. We\u2019re going to start using the `thread` module\n+from the standard library, and so we need to `use` it.\n+\n+```rust,ignore\n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+```\n+\n+We now print out two messages, with a `sleep_ms()` in the middle. This will\n+simulate the time it takes a philosopher to eat.\n+\n+If you run this program, You should see each philosopher eat in turn:\n+\n+```text\n+Baruch Spinoza is eating.\n+Baruch Spinoza is done eating.\n+Gilles Deleuze is eating.\n+Gilles Deleuze is done eating.\n+Karl Marx is eating.\n+Karl Marx is done eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is eating.\n+Michel Foucault is done eating.\n+```\n+\n+Excellent! We\u2019re getting there. There\u2019s just one problem: we aren\u2019t actually\n+operating in a concurrent fashion, which is a core part of the problem!\n+\n+To make our philosophers eat concurrently, we need to make a small change.\n+Here\u2019s the next iteration:\n+\n+```rust\n+use std::thread;\n+\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+\n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+        thread::spawn(move || {\n+            p.eat();\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().unwrap();\n+    }\n+}\n+```\n+\n+All we\u2019ve done is change the loop in `main()`, and added a second one! Here\u2019s the\n+first change:\n+\n+```rust,ignore\n+let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+    thread::spawn(move || {\n+        p.eat();\n+    })\n+}).collect();\n+```\n+\n+While this is only five lines, they\u2019re a dense four. Let\u2019s break it down.\n+\n+```rust,ignore\n+let handles: Vec<_> = \n+```\n+\n+We introduce a new binding, called `handles`. We\u2019ve given it this name because\n+we are going to make some new threads, and that will return some handles to those\n+threads that let us control their operation. We need to explicitly annotate\n+the type here, though, due to an issue we\u2019ll talk about later. The `_` is\n+a type placeholder. We\u2019re saying \u201c`handles` is a vector of something, but you\n+can figure out what that something is, Rust.\u201d\n+\n+```rust,ignore\n+philosophers.into_iter().map(|p| {\n+```\n+\n+We take our list of philosophers and call `into_iter()` on it. This creates an\n+iterator that takes ownership of each philosopher. We need to do this to pass\n+them to our threads. We take that iterator and call `map` on it, which takes a\n+closure as an argument and calls that closure on each element in turn.\n+\n+```rust,ignore\n+    thread::spawn(move || {\n+        p.eat();\n+    })\n+```\n+\n+Here\u2019s where the concurrency happens. The `thread::spawn` function takes a closure\n+as an argument and executes that closure in a new thread. This closure needs\n+an extra annotation, `move`, to indicate that the closure is going to take\n+ownership of the values it\u2019s capturing. Primarily, the `p` variable of the\n+`map` function.\n+\n+Inside the thread, all we do is call `eat()` on `p`.\n+\n+```rust,ignore\n+}).collect();\n+```\n+\n+Finally, we take the result of all those `map` calls and collect them up.\n+`collect()` will make them into a collection of some kind, which is why we\n+needed to annotate the return type: we want a `Vec<T>`. The elements are the\n+return values of the `thread::spawn` calls, which are handles to those threads.\n+Whew!\n+\n+```rust,ignore\n+for h in handles {\n+    h.join().unwrap();\n+}\n+```\n+\n+At the end of `main()`, we loop through the handles and call `join()` on them,\n+which blocks execution until the thread has completed execution. This ensures\n+that the threads complete their work before the program exits.\n+\n+If you run this program, you\u2019ll see that the philosophers eat out of order!\n+We have mult-threading!\n+\n+```text\n+Gilles Deleuze is eating.\n+Gilles Deleuze is done eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is eating.\n+Baruch Spinoza is eating.\n+Baruch Spinoza is done eating.\n+Karl Marx is eating.\n+Karl Marx is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+But what about the forks? We haven\u2019t modeled them at all yet.\n+\n+To do that, let\u2019s make a new `struct`:\n+\n+```rust\n+use std::sync::Mutex;\n+\n+struct Table {\n+    forks: Vec<Mutex<()>>,\n+}\n+```\n+\n+This `Table` has an vector of `Mutex`es. A mutex is a way to control\n+concurrency: only one thread can access the contents at once. This is exactly\n+the property we need with our forks. We use an empty tuple, `()`, inside the\n+mutex, since we\u2019re not actually going to use the value, just hold onto it.\n+\n+Let\u2019s modify the program to use the `Table`:\n+\n+```rust\n+use std::thread;\n+use std::sync::{Mutex, Arc};\n+\n+struct Philosopher {\n+    name: String,\n+    left: usize,\n+    right: usize,\n+}\n+\n+impl Philosopher {\n+    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+            left: left,\n+            right: right,\n+        }\n+    }\n+\n+    fn eat(&self, table: &Table) {\n+        let _left = table.forks[self.left].lock().unwrap();\n+        let _right = table.forks[self.right].lock().unwrap();\n+\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+struct Table {\n+    forks: Vec<Mutex<()>>,\n+}\n+\n+fn main() {\n+    let table = Arc::new(Table { forks: vec![\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+    ]});\n+\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n+        Philosopher::new(\"Karl Marx\", 2, 3),\n+        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+        Philosopher::new(\"Michel Foucault\", 0, 4),\n+    ];\n+\n+    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+        let table = table.clone();\n+\n+        thread::spawn(move || {\n+            p.eat(&table);\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().unwrap();\n+    }\n+}\n+```\n+\n+Lots of changes! However, with this iteration, we\u2019ve got a working program.\n+Let\u2019s go over the details:\n+\n+```rust,ignore\n+use std::sync::{Mutex, Arc};\n+```\n+\n+We\u2019re going to use another structure from the `std::sync` package: `Arc<T>`.\n+We\u2019ll talk more about it when we use it.\n+\n+```rust,ignore\n+struct Philosopher {\n+    name: String,\n+    left: usize,\n+    right: usize,\n+}\n+```\n+\n+We need to add two more fields to our `Philosopher`. Each philosopher is going\n+to have two forks: the one on their left, and the one on their right.\n+We\u2019ll use the `usize` type to indicate them, as it\u2019s the type that you index\n+vectors with. These two values will be the indexes into the `forks` our `Table`\n+has.\n+\n+```rust,ignore\n+fn new(name: &str, left: usize, right: usize) -> Philosopher {\n+    Philosopher {\n+        name: name.to_string(),\n+        left: left,\n+        right: right,\n+    }\n+}\n+```\n+\n+We now need to construct those `left` and `right` values, so we add them to\n+`new()`.\n+\n+```rust,ignore\n+fn eat(&self, table: &Table) {\n+    let _left = table.forks[self.left].lock().unwrap();\n+    let _right = table.forks[self.right].lock().unwrap();\n+\n+    println!(\"{} is eating.\", self.name);\n+\n+    thread::sleep_ms(1000);\n+\n+    println!(\"{} is done eating.\", self.name);\n+}\n+```\n+\n+We have two new lines. We\u2019ve also added an argument, `table`. We access the\n+`Table`\u2019s list of forks, and then use `self.left` and `self.right` to access\n+the fork at that particular index. That gives us access to the `Mutex` at that\n+index, and we call `lock()` on it. If the mutex is currently being accessed by\n+someone else, we\u2019ll block until it becomes available.\n+\n+The call to `lock()` might fail, and if it does, we want to crash. In this\n+case, the error that could happen is that the mutex is [\u2018poisoned\u2019][poison],\n+which is what happens when the thread panics while the lock is held. Since this\n+shouldn\u2019t happen, we just use `unwrap()`.\n+\n+[poison]: ../std/sync/struct.Mutex.html#poisoning\n+\n+One other odd thing about these lines: we\u2019ve named the results `_left` and\n+`_right`. What\u2019s up with that underscore? Well, we aren\u2019t planning on\n+_using_ the value inside the lock. We just want to acquire it. As such,\n+Rust will warn us that we never use the value. By using the underscore,\n+we tell Rust that this is what we intended, and it won\u2019t throw a warning.\n+\n+What about releasing the lock? Well, that will happen when `_left` and\n+`_right` go out of scope, automatically.\n+\n+```rust,ignore\n+    let table = Arc::new(Table { forks: vec![\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+    ]});\n+```\n+\n+Next, in `main()`, we make a new `Table` and wrap it in an `Arc<T>`.\n+\u2018arc\u2019 stands for \u2018atomic reference count\u2019, and we need that to share\n+our `Table` across multiple threads. As we share it, the reference\n+count will go up, and when each thread ends, it will go back down.\n+\n+\n+```rust,ignore\n+let philosophers = vec![\n+    Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+    Philosopher::new(\"Gilles Deleuze\", 1, 2),\n+    Philosopher::new(\"Karl Marx\", 2, 3),\n+    Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+    Philosopher::new(\"Michel Foucault\", 0, 4),\n+];\n+```\n+\n+We need to pass in our `left` and `right` values to the constructors for our\n+`Philosopher`s. But there\u2019s one more detail here, and it\u2019s _very_ important. If\n+you look at the pattern, it\u2019s all consistent until the very end. Monsieur\n+Foucault should have `4, 0` as arguments, but instead, has `0, 4`. This is what\n+prevents deadlock, actually: one of our philosophers is left handed! This is\n+one way to solve the problem, and in my opinion, it\u2019s the simplest.\n+\n+```rust,ignore\n+let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+    let table = table.clone();\n+\n+    thread::spawn(move || {\n+        p.eat(&table);\n+    })\n+}).collect();\n+```\n+\n+Finally, inside of our `map()`/`collect()` loop, we call `table.clone()`. The\n+`clone()` method on `Arc<T>` is what bumps up the reference count, and when it\n+goes out of scope, it decrements the count. You\u2019ll notice we can introduce a\n+new binding to `table` here, and it will shadow the old one. This is often used\n+so that you don\u2019t need to come up with two unique names.\n+\n+With this, our program works! Only two philosophers can eat at any one time,\n+and so you\u2019ll get some output like this:\n+\n+```text\n+Gilles Deleuze is eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Gilles Deleuze is done eating.\n+Baruch Spinoza is eating.\n+Karl Marx is eating.\n+Baruch Spinoza is done eating.\n+Michel Foucault is eating.\n+Karl Marx is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+Congrats! You\u2019ve implemented a classic concurrency problem in Rust."}]}