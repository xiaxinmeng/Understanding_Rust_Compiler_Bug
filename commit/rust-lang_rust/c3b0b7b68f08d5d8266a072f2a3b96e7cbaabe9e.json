{"sha": "c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYjBiN2I2OGYwOGQ1ZDgyNjZhMDcyZjJhM2I5NmU3Y2JhYWJlOWU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-08T21:50:39Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-08T21:58:37Z"}, "message": "Revert #71956", "tree": {"sha": "448d7f6d199620086a0ce279b1f2958388304f1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/448d7f6d199620086a0ce279b1f2958388304f1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "html_url": "https://github.com/rust-lang/rust/commit/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "html_url": "https://github.com/rust-lang/rust/commit/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e"}], "stats": {"total": 509, "additions": 372, "deletions": 137}, "files": [{"sha": "1d49a32e19645d61f8a57fa42cc6e813e1f146f4", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -99,9 +99,6 @@ impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n where\n     K: BorrowAnalysisKind<'tcx>,\n {\n-    // The generator transform relies on the fact that this analysis does **not** use \"before\"\n-    // effects.\n-\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "01cb794a2e085d512d868fb9cd4fc4e70fd62b8c", "filename": "src/librustc_mir/dataflow/impls/init_locals.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -33,9 +33,6 @@ impl dataflow::AnalysisDomain<'tcx> for MaybeInitializedLocals {\n }\n \n impl dataflow::GenKillAnalysis<'tcx> for MaybeInitializedLocals {\n-    // The generator transform relies on the fact that this analysis does **not** use \"before\"\n-    // effects.\n-\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "d5def0389126a90068f9f2afe9d48bc1f6e2ea7a", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -30,7 +30,7 @@ pub use self::borrowed_locals::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::borrows::Borrows;\n pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n-pub use self::storage_liveness::MaybeStorageLive;\n+pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n \n /// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow"}, {"sha": "cd04493c092e034e8ee546553c68c3f01f385680", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 233, "deletions": 1, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -1,9 +1,11 @@\n pub use super::*;\n \n use crate::dataflow::BottomValue;\n-use crate::dataflow::{self, GenKill};\n+use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n use crate::util::storage::AlwaysLiveLocals;\n+use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct MaybeStorageLive {\n@@ -76,3 +78,233 @@ impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n+\n+type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n+\n+/// Dataflow analysis that determines whether each local requires storage at a\n+/// given location; i.e. whether its storage can go away without being observed.\n+pub struct MaybeRequiresStorage<'mir, 'tcx> {\n+    body: &'mir Body<'tcx>,\n+    borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n+}\n+\n+impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n+    pub fn new(\n+        body: &'mir Body<'tcx>,\n+        borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n+    ) -> Self {\n+        MaybeRequiresStorage {\n+            body,\n+            borrowed_locals: RefCell::new(ResultsRefCursor::new(&body, borrowed_locals)),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n+    type Idx = Local;\n+\n+    const NAME: &'static str = \"requires_storage\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n+    }\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n+        // The resume argument is live on function entry (we don't care about\n+        // the `self` argument)\n+        for arg in body.args_iter().skip(1) {\n+            on_entry.insert(arg);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n+    fn before_statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        // If a place is borrowed in a statement, it needs storage for that statement.\n+        self.borrowed_locals.borrow().analysis().statement_effect(trans, stmt, loc);\n+\n+        match &stmt.kind {\n+            StatementKind::StorageDead(l) => trans.kill(*l),\n+\n+            // If a place is assigned to in a statement, it needs storage for that statement.\n+            StatementKind::Assign(box (place, _))\n+            | StatementKind::SetDiscriminant { box place, .. } => {\n+                trans.gen(place.local);\n+            }\n+            StatementKind::LlvmInlineAsm(asm) => {\n+                for place in &*asm.outputs {\n+                    trans.gen(place.local);\n+                }\n+            }\n+\n+            // Nothing to do for these. Match exhaustively so this fails to compile when new\n+            // variants are added.\n+            StatementKind::AscribeUserType(..)\n+            | StatementKind::FakeRead(..)\n+            | StatementKind::Nop\n+            | StatementKind::Retag(..)\n+            | StatementKind::StorageLive(..) => {}\n+        }\n+    }\n+\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        // If we move from a place then only stops needing storage *after*\n+        // that statement.\n+        self.check_for_move(trans, loc);\n+    }\n+\n+    fn before_terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        // If a place is borrowed in a terminator, it needs storage for that terminator.\n+        self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n+\n+        match &terminator.kind {\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n+                trans.gen(place.local);\n+            }\n+\n+            // Note that we do *not* gen the `resume_arg` of `Yield` terminators. The reason for\n+            // that is that a `yield` will return from the function, and `resume_arg` is written\n+            // only when the generator is later resumed. Unlike `Call`, this doesn't require the\n+            // place to have storage *before* the yield, only after.\n+            TerminatorKind::Yield { .. } => {}\n+\n+            TerminatorKind::InlineAsm { operands, .. } => {\n+                for op in operands {\n+                    match op {\n+                        InlineAsmOperand::Out { place, .. }\n+                        | InlineAsmOperand::InOut { out_place: place, .. } => {\n+                            if let Some(place) = place {\n+                                trans.gen(place.local);\n+                            }\n+                        }\n+                        InlineAsmOperand::In { .. }\n+                        | InlineAsmOperand::Const { .. }\n+                        | InlineAsmOperand::SymFn { .. }\n+                        | InlineAsmOperand::SymStatic { .. } => {}\n+                    }\n+                }\n+            }\n+\n+            // Nothing to do for these. Match exhaustively so this fails to compile when new\n+            // variants are added.\n+            TerminatorKind::Call { destination: None, .. }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable => {}\n+        }\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        match &terminator.kind {\n+            // For call terminators the destination requires storage for the call\n+            // and after the call returns successfully, but not after a panic.\n+            // Since `propagate_call_unwind` doesn't exist, we have to kill the\n+            // destination here, and then gen it again in `call_return_effect`.\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n+                trans.kill(place.local);\n+            }\n+\n+            // Nothing to do for these. Match exhaustively so this fails to compile when new\n+            // variants are added.\n+            TerminatorKind::Call { destination: None, .. }\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::InlineAsm { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable => {}\n+        }\n+\n+        self.check_for_move(trans, loc);\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        return_place: mir::Place<'tcx>,\n+    ) {\n+        trans.gen(return_place.local);\n+    }\n+\n+    fn yield_resume_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        resume_place: mir::Place<'tcx>,\n+    ) {\n+        trans.gen(resume_place.local);\n+    }\n+}\n+\n+impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n+    /// Kill locals that are fully moved and have not been borrowed.\n+    fn check_for_move(&self, trans: &mut impl GenKill<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor { trans, borrowed_locals: &self.borrowed_locals };\n+        visitor.visit_location(&self.body, loc);\n+    }\n+}\n+\n+impl<'mir, 'tcx> BottomValue for MaybeRequiresStorage<'mir, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+struct MoveVisitor<'a, 'mir, 'tcx, T> {\n+    borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n+    trans: &'a mut T,\n+}\n+\n+impl<'a, 'mir, 'tcx, T> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx, T>\n+where\n+    T: GenKill<Local>,\n+{\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n+        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n+            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+            borrowed_locals.seek_before_primary_effect(loc);\n+            if !borrowed_locals.contains(*local) {\n+                self.trans.kill(*local);\n+            }\n+        }\n+    }\n+}"}, {"sha": "25b6a51d91b97f31eaa38914961b4f7c07fba6f2", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 136, "deletions": 127, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -50,7 +50,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::dataflow::impls::{\n-    MaybeBorrowedLocals, MaybeInitializedLocals, MaybeLiveLocals, MaybeStorageLive,\n+    MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n };\n use crate::dataflow::{self, Analysis};\n use crate::transform::no_landing_pads::no_landing_pads;\n@@ -444,80 +444,86 @@ fn locals_live_across_suspend_points(\n     movable: bool,\n ) -> LivenessInfo {\n     let def_id = source.def_id();\n+    let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n-        .into_engine(tcx, body, def_id)\n+        .into_engine(tcx, body_ref, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body);\n-\n-    let mut init = MaybeInitializedLocals\n-        .into_engine(tcx, body, def_id)\n-        .iterate_to_fixpoint()\n-        .into_results_cursor(body);\n-\n-    let mut live = MaybeLiveLocals\n-        .into_engine(tcx, body, def_id)\n-        .iterate_to_fixpoint()\n-        .into_results_cursor(body);\n-\n-    let mut borrowed = MaybeBorrowedLocals::all_borrows()\n-        .into_engine(tcx, body, def_id)\n+        .into_results_cursor(body_ref);\n+\n+    // Calculate the MIR locals which have been previously\n+    // borrowed (even if they are still active).\n+    let borrowed_locals_results =\n+        MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n+\n+    let mut borrowed_locals_cursor =\n+        dataflow::ResultsCursor::new(body_ref, &borrowed_locals_results);\n+\n+    // Calculate the MIR locals that we actually need to keep storage around\n+    // for.\n+    let requires_storage_results = MaybeRequiresStorage::new(body, &borrowed_locals_results)\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint();\n+    let mut requires_storage_cursor =\n+        dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n+\n+    // Calculate the liveness of MIR locals ignoring borrows.\n+    let mut liveness = MaybeLiveLocals\n+        .into_engine(tcx, body_ref, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body);\n-\n-    // Liveness across yield points is determined by the following boolean equation, where `live`,\n-    // `init` and `borrowed` come from dataflow and `movable` is a property of the generator.\n-    // Movable generators do not allow borrows to live across yield points, so they don't need to\n-    // store a local simply because it is borrowed.\n-    //\n-    //    live_across_yield := (live & init) | (!movable & borrowed)\n-    //\n-    let mut locals_live_across_yield_point = |block| {\n-        live.seek_to_block_end(block);\n-        let mut live_locals = live.get().clone();\n-\n-        init.seek_to_block_end(block);\n-        live_locals.intersect(init.get());\n-\n-        if !movable {\n-            borrowed.seek_to_block_end(block);\n-            live_locals.union(borrowed.get());\n-        }\n-\n-        live_locals\n-    };\n+        .into_results_cursor(body_ref);\n \n     let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n     let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n-        if !matches!(data.terminator().kind, TerminatorKind::Yield { ..  }) {\n-            continue;\n-        }\n+        if let TerminatorKind::Yield { .. } = data.terminator().kind {\n+            let loc = Location { block, statement_index: data.statements.len() };\n+\n+            liveness.seek_to_block_end(block);\n+            let mut live_locals = liveness.get().clone();\n+\n+            if !movable {\n+                // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n+                // This is correct for movable generators since borrows cannot live across\n+                // suspension points. However for immovable generators we need to account for\n+                // borrows, so we conseratively assume that all borrowed locals are live until\n+                // we find a StorageDead statement referencing the locals.\n+                // To do this we just union our `liveness` result with `borrowed_locals`, which\n+                // contains all the locals which has been borrowed before this suspension point.\n+                // If a borrow is converted to a raw reference, we must also assume that it lives\n+                // forever. Note that the final liveness is still bounded by the storage liveness\n+                // of the local, which happens using the `intersect` operation below.\n+                borrowed_locals_cursor.seek_before_primary_effect(loc);\n+                live_locals.union(borrowed_locals_cursor.get());\n+            }\n \n-        // Store the storage liveness for later use so we can restore the state\n-        // after a suspension point\n-        storage_live.seek_to_block_end(block);\n-        storage_liveness_map[block] = Some(storage_live.get().clone());\n+            // Store the storage liveness for later use so we can restore the state\n+            // after a suspension point\n+            storage_live.seek_before_primary_effect(loc);\n+            storage_liveness_map[block] = Some(storage_live.get().clone());\n \n-        let mut live_locals = locals_live_across_yield_point(block);\n+            // Locals live are live at this point only if they are used across\n+            // suspension points (the `liveness` variable)\n+            // and their storage is required (the `storage_required` variable)\n+            requires_storage_cursor.seek_before_primary_effect(loc);\n+            live_locals.intersect(requires_storage_cursor.get());\n \n-        // The combination of `MaybeInitializedLocals` and `MaybeBorrowedLocals` should be strictly\n-        // more precise than `MaybeStorageLive` because they handle `StorageDead` themselves. This\n-        // assumes that the MIR forbids locals from being initialized/borrowed before reaching\n-        // `StorageLive`.\n-        debug_assert!(storage_live.get().superset(&live_locals));\n+            // The generator argument is ignored.\n+            live_locals.remove(SELF_ARG);\n \n-        // Ignore the generator's `self` argument since it is handled seperately.\n-        live_locals.remove(SELF_ARG);\n-        debug!(\"block = {:?}, live_locals = {:?}\", block, live_locals);\n-        live_locals_at_any_suspension_point.union(&live_locals);\n-        live_locals_at_suspension_points.push(live_locals);\n-    }\n+            debug!(\"loc = {:?}, live_locals = {:?}\", loc, live_locals);\n \n+            // Add the locals live at this suspension point to the set of locals which live across\n+            // any suspension points\n+            live_locals_at_any_suspension_point.union(&live_locals);\n+\n+            live_locals_at_suspension_points.push(live_locals);\n+        }\n+    }\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n@@ -528,11 +534,10 @@ fn locals_live_across_suspend_points(\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n-        body,\n+        body_ref,\n         &live_locals_at_any_suspension_point,\n         always_live_locals.clone(),\n-        init,\n-        borrowed,\n+        requires_storage_results,\n     );\n \n     LivenessInfo {\n@@ -564,37 +569,6 @@ fn renumber_bitset(\n     out\n }\n \n-/// Record conflicts between locals at the current dataflow cursor positions.\n-///\n-/// You need to seek the cursors before calling this function.\n-fn record_conflicts_at_curr_loc(\n-    local_conflicts: &mut BitMatrix<Local, Local>,\n-    init: &dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n-    borrowed: &dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n-) {\n-    // A local requires storage if it is initialized or borrowed. For now, a local\n-    // becomes uninitialized if it is moved from, but is still considered \"borrowed\".\n-    //\n-    //     requires_storage := init | borrowed\n-    //\n-    // Just like when determining what locals are live at yield points, there is no need\n-    // to look at storage liveness here, since `init | borrowed` is strictly more precise.\n-    //\n-    // FIXME: This function is called in a loop, so it might be better to pass in a temporary\n-    // bitset rather than cloning here.\n-    let mut requires_storage = init.get().clone();\n-    requires_storage.union(borrowed.get());\n-\n-    for local in requires_storage.iter() {\n-        local_conflicts.union_row_with(&requires_storage, local);\n-    }\n-\n-    // `>1` because the `self` argument always requires storage.\n-    if requires_storage.count() > 1 {\n-        trace!(\"requires_storage={:?}\", requires_storage);\n-    }\n-}\n-\n /// For every saved local, looks for which locals are StorageLive at the same\n /// time. Generates a bitset for every local of all the other locals that may be\n /// StorageLive simultaneously with that local. This is used in the layout\n@@ -603,45 +577,30 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &BitSet<Local>,\n     always_live_locals: storage::AlwaysLiveLocals,\n-    mut init: dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n-    mut borrowed: dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n+    requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    debug!(\"compute_storage_conflicts({:?})\", body.span);\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n \n-    // Locals that are always live conflict with all other locals.\n-    //\n-    // FIXME: Why do we need to handle locals without `Storage{Live,Dead}` specially here?\n-    // Shouldn't it be enough to know whether they are initialized?\n-    let always_live_locals = always_live_locals.into_inner();\n-    let mut local_conflicts = BitMatrix::from_row_n(&always_live_locals, body.local_decls.len());\n-\n-    // Visit every reachable statement and terminator. The exact order does not matter. When two\n-    // locals are live at the same point in time, add an entry in the conflict matrix.\n-    for (block, data) in traversal::preorder(body) {\n-        // Ignore unreachable blocks.\n-        if data.terminator().kind == TerminatorKind::Unreachable {\n-            continue;\n-        }\n+    debug!(\"compute_storage_conflicts({:?})\", body.span);\n+    debug!(\"always_live = {:?}\", always_live_locals);\n \n-        // Observe the dataflow state *before* all possible locations (statement or terminator) in\n-        // each basic block...\n-        for statement_index in 0..=data.statements.len() {\n-            let loc = Location { block, statement_index };\n-            trace!(\"record conflicts at {:?}\", loc);\n-            init.seek_before_primary_effect(loc);\n-            borrowed.seek_before_primary_effect(loc);\n-            record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n-        }\n+    // Locals that are always live or ones that need to be stored across\n+    // suspension points are not eligible for overlap.\n+    let mut ineligible_locals = always_live_locals.into_inner();\n+    ineligible_locals.intersect(stored_locals);\n \n-        // ...and then observe the state *after* the terminator effect is applied. As long as\n-        // neither `init` nor `borrowed` has a \"before\" effect, we will observe all possible\n-        // dataflow states here or in the loop above.\n-        trace!(\"record conflicts at end of {:?}\", block);\n-        init.seek_to_block_end(block);\n-        borrowed.seek_to_block_end(block);\n-        record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n-    }\n+    // Compute the storage conflicts for all eligible locals.\n+    let mut visitor = StorageConflictVisitor {\n+        body,\n+        stored_locals: &stored_locals,\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n+    };\n+\n+    // Visit only reachable basic blocks. The exact order is not important.\n+    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n+    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+\n+    let local_conflicts = visitor.local_conflicts;\n \n     // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n     //\n@@ -653,7 +612,7 @@ fn compute_storage_conflicts(\n     let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n     for (idx_a, local_a) in stored_locals.iter().enumerate() {\n         let saved_local_a = GeneratorSavedLocal::new(idx_a);\n-        if always_live_locals.contains(local_a) {\n+        if ineligible_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n@@ -669,6 +628,56 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n+struct StorageConflictVisitor<'mir, 'tcx, 's> {\n+    body: &'mir Body<'tcx>,\n+    stored_locals: &'s BitSet<Local>,\n+    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n+    // benchmarks for generators.\n+    local_conflicts: BitMatrix<Local, Local>,\n+}\n+\n+impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n+    type FlowState = BitSet<Local>;\n+\n+    fn visit_statement_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.apply_state(state, loc);\n+    }\n+\n+    fn visit_terminator_before_primary_effect(\n+        &mut self,\n+        state: &Self::FlowState,\n+        _terminator: &'mir Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.apply_state(state, loc);\n+    }\n+}\n+\n+impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n+    fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n+        // Ignore unreachable blocks.\n+        if self.body.basic_blocks()[loc.block].terminator().kind == TerminatorKind::Unreachable {\n+            return;\n+        }\n+\n+        let mut eligible_storage_live = flow_state.clone();\n+        eligible_storage_live.intersect(&self.stored_locals);\n+\n+        for local in eligible_storage_live.iter() {\n+            self.local_conflicts.union_row_with(&eligible_storage_live, local);\n+        }\n+\n+        if eligible_storage_live.count() > 1 {\n+            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n+        }\n+    }\n+}\n+\n /// Validates the typeck view of the generator against the actual set of types retained between\n /// yield points.\n fn sanitize_witness<'tcx>("}, {"sha": "636fafc2bc44a248731973987639c545c49daf4f", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -114,5 +114,5 @@ fn main() {\n     assert_eq!(1026, std::mem::size_of_val(&single_with_noop()));\n     assert_eq!(3078, std::mem::size_of_val(&joined()));\n     assert_eq!(3079, std::mem::size_of_val(&joined_with_noop()));\n-    assert_eq!(6157, std::mem::size_of_val(&mixed_sizes()));\n+    assert_eq!(7181, std::mem::size_of_val(&mixed_sizes()));\n }"}, {"sha": "74c60d98154dd3da107bb7672c5d40afa5129c65", "filename": "src/test/ui/generator/size-moved-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs?ref=c3b0b7b68f08d5d8266a072f2a3b96e7cbaabe9e", "patch": "@@ -72,6 +72,6 @@ fn overlap_x_and_y() -> impl Generator<Yield = (), Return = ()> {\n fn main() {\n     assert_eq!(1025, std::mem::size_of_val(&move_before_yield()));\n     assert_eq!(1026, std::mem::size_of_val(&move_before_yield_with_noop()));\n-    assert_eq!(1027, std::mem::size_of_val(&overlap_move_points()));\n+    assert_eq!(2051, std::mem::size_of_val(&overlap_move_points()));\n     assert_eq!(1026, std::mem::size_of_val(&overlap_x_and_y()));\n }"}]}