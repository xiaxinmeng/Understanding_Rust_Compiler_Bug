{"sha": "040ac2a93270b4420c59621521d554a078e2d451", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MGFjMmE5MzI3MGI0NDIwYzU5NjIxNTIxZDU1NGEwNzhlMmQ0NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-30T22:02:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-30T22:02:05Z"}, "message": "auto merge of #7495 : thestinger/rust/exchange, r=cmr\n\nWith these changes, exchange allocator headers are never initialized, read or written to. Removing the header will now just involve updating the code in trans using an offset to only do it if the type contained is managed.\r\n\r\nThe only thing blocking removing the initialization of the last field in the header was ~fn since it uses it to store the dynamic size/types due to captures. I temporarily switched it to a `closure_exchange_alloc` lang item (it uses the same `exchange_free`) and #7496 is filed about removing that.\r\n\r\nSince the `exchange_free` call is now inlined all over the codebase, I don't think we should have an assert for null. It doesn't currently ever happen, but it would be fine if we started generating code that did do it. The `exchange_free` function also had a comment declaring that it must not fail, but a regular assert would cause a failure. I also removed the atomic counter because valgrind can already find these leaks, and we have valgrind bots now.\r\n\r\nNote that exchange free does not currently print an error an out-of-memory when it aborts, because our `io` code may allocate. We could probably get away with a `#[rust_stack]` call to a `stdio` function but it would be better to make a write system call.", "tree": {"sha": "16dc8d87d4352a8e695949c906af4e5e55f2f47d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16dc8d87d4352a8e695949c906af4e5e55f2f47d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040ac2a93270b4420c59621521d554a078e2d451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040ac2a93270b4420c59621521d554a078e2d451", "html_url": "https://github.com/rust-lang/rust/commit/040ac2a93270b4420c59621521d554a078e2d451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040ac2a93270b4420c59621521d554a078e2d451/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca835f482cebcd353db789e45f9cec72db1a24ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca835f482cebcd353db789e45f9cec72db1a24ed", "html_url": "https://github.com/rust-lang/rust/commit/ca835f482cebcd353db789e45f9cec72db1a24ed"}, {"sha": "4a29d6eb3f20c2b7a05bb9c9c2f964da606e39ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a29d6eb3f20c2b7a05bb9c9c2f964da606e39ca", "html_url": "https://github.com/rust-lang/rust/commit/4a29d6eb3f20c2b7a05bb9c9c2f964da606e39ca"}], "stats": {"total": 468, "additions": 207, "deletions": 261}, "files": [{"sha": "0e9361193b0a31a5a9e6640d68089b51c686cb92", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 71, "deletions": 65, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -32,63 +32,64 @@ use syntax::visit::visit_crate;\n use std::hashmap::HashMap;\n \n pub enum LangItem {\n-    FreezeTraitLangItem,        // 0\n-    CopyTraitLangItem,          // 1\n-    SendTraitLangItem,          // 2\n-    SizedTraitLangItem,         // 3\n-\n-    DropTraitLangItem,          // 4\n-\n-    AddTraitLangItem,           // 5\n-    SubTraitLangItem,           // 6\n-    MulTraitLangItem,           // 7\n-    DivTraitLangItem,           // 8\n-    RemTraitLangItem,           // 9\n-    NegTraitLangItem,           // 10\n-    NotTraitLangItem,           // 11\n-    BitXorTraitLangItem,        // 11\n-    BitAndTraitLangItem,        // 13\n-    BitOrTraitLangItem,         // 14\n-    ShlTraitLangItem,           // 15\n-    ShrTraitLangItem,           // 16\n-    IndexTraitLangItem,         // 17\n-\n-    EqTraitLangItem,            // 18\n-    OrdTraitLangItem,           // 19\n-\n-    StrEqFnLangItem,            // 20\n-    UniqStrEqFnLangItem,        // 21\n-    AnnihilateFnLangItem,       // 22\n-    LogTypeFnLangItem,          // 23\n-    FailFnLangItem,             // 24\n-    FailBoundsCheckFnLangItem,  // 25\n-    ExchangeMallocFnLangItem,   // 26\n-    ExchangeFreeFnLangItem,     // 27\n-    MallocFnLangItem,           // 28\n-    FreeFnLangItem,             // 29\n-    BorrowAsImmFnLangItem,      // 30\n-    BorrowAsMutFnLangItem,      // 31\n-    ReturnToMutFnLangItem,      // 32\n-    CheckNotBorrowedFnLangItem, // 33\n-    StrDupUniqFnLangItem,       // 34\n-    RecordBorrowFnLangItem,     // 35\n-    UnrecordBorrowFnLangItem,   // 36\n-\n-    StartFnLangItem,            // 37\n-\n-    TyDescStructLangItem,       // 38\n-    TyVisitorTraitLangItem,     // 39\n-    OpaqueStructLangItem,       // 40\n+    FreezeTraitLangItem,               // 0\n+    CopyTraitLangItem,                 // 1\n+    SendTraitLangItem,                 // 2\n+    SizedTraitLangItem,                // 3\n+\n+    DropTraitLangItem,                 // 4\n+\n+    AddTraitLangItem,                  // 5\n+    SubTraitLangItem,                  // 6\n+    MulTraitLangItem,                  // 7\n+    DivTraitLangItem,                  // 8\n+    RemTraitLangItem,                  // 9\n+    NegTraitLangItem,                  // 10\n+    NotTraitLangItem,                  // 11\n+    BitXorTraitLangItem,               // 11\n+    BitAndTraitLangItem,               // 13\n+    BitOrTraitLangItem,                // 14\n+    ShlTraitLangItem,                  // 15\n+    ShrTraitLangItem,                  // 16\n+    IndexTraitLangItem,                // 17\n+\n+    EqTraitLangItem,                   // 18\n+    OrdTraitLangItem,                  // 19\n+\n+    StrEqFnLangItem,                   // 20\n+    UniqStrEqFnLangItem,               // 21\n+    AnnihilateFnLangItem,              // 22\n+    LogTypeFnLangItem,                 // 23\n+    FailFnLangItem,                    // 24\n+    FailBoundsCheckFnLangItem,         // 25\n+    ExchangeMallocFnLangItem,          // 26\n+    ClosureExchangeMallocFnLangItem,   // 27\n+    ExchangeFreeFnLangItem,            // 28\n+    MallocFnLangItem,                  // 29\n+    FreeFnLangItem,                    // 30\n+    BorrowAsImmFnLangItem,             // 31\n+    BorrowAsMutFnLangItem,             // 32\n+    ReturnToMutFnLangItem,             // 33\n+    CheckNotBorrowedFnLangItem,        // 34\n+    StrDupUniqFnLangItem,              // 35\n+    RecordBorrowFnLangItem,            // 36\n+    UnrecordBorrowFnLangItem,          // 37\n+\n+    StartFnLangItem,                   // 38\n+\n+    TyDescStructLangItem,              // 39\n+    TyVisitorTraitLangItem,            // 40\n+    OpaqueStructLangItem,              // 41\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..41]\n+    items: [Option<def_id>, ..42]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..41 ]\n+            items: [ None, ..42 ]\n         }\n     }\n \n@@ -128,22 +129,23 @@ impl LanguageItems {\n             24 => \"fail_\",\n             25 => \"fail_bounds_check\",\n             26 => \"exchange_malloc\",\n-            27 => \"exchange_free\",\n-            28 => \"malloc\",\n-            29 => \"free\",\n-            30 => \"borrow_as_imm\",\n-            31 => \"borrow_as_mut\",\n-            32 => \"return_to_mut\",\n-            33 => \"check_not_borrowed\",\n-            34 => \"strdup_uniq\",\n-            35 => \"record_borrow\",\n-            36 => \"unrecord_borrow\",\n-\n-            37 => \"start\",\n-\n-            38 => \"ty_desc\",\n-            39 => \"ty_visitor\",\n-            40 => \"opaque\",\n+            27 => \"closure_exchange_malloc\",\n+            28 => \"exchange_free\",\n+            29 => \"malloc\",\n+            30 => \"free\",\n+            31 => \"borrow_as_imm\",\n+            32 => \"borrow_as_mut\",\n+            33 => \"return_to_mut\",\n+            34 => \"check_not_borrowed\",\n+            35 => \"strdup_uniq\",\n+            36 => \"record_borrow\",\n+            37 => \"unrecord_borrow\",\n+\n+            38 => \"start\",\n+\n+            39 => \"ty_desc\",\n+            40 => \"ty_visitor\",\n+            41 => \"opaque\",\n \n             _ => \"???\"\n         }\n@@ -236,6 +238,9 @@ impl LanguageItems {\n     pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n+    pub fn closure_exchange_malloc_fn(&self) -> def_id {\n+        self.items[ClosureExchangeMallocFnLangItem as uint].get()\n+    }\n     pub fn exchange_free_fn(&self) -> def_id {\n         self.items[ExchangeFreeFnLangItem as uint].get()\n     }\n@@ -326,6 +331,7 @@ impl<'self> LanguageItemCollector<'self> {\n         item_refs.insert(@\"fail_bounds_check\",\n                          FailBoundsCheckFnLangItem as uint);\n         item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"closure_exchange_malloc\", ClosureExchangeMallocFnLangItem as uint);\n         item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n         item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n         item_refs.insert(@\"free\", FreeFnLangItem as uint);"}, {"sha": "cf671bdce6776e8ce2bfff0158157ff299c4646c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -253,6 +253,9 @@ pub fn malloc_raw_dyn(bcx: block,\n         heap_exchange => {\n             (ty::mk_imm_uniq, bcx.tcx().lang_items.exchange_malloc_fn())\n         }\n+        heap_exchange_closure => {\n+            (ty::mk_imm_uniq, bcx.tcx().lang_items.closure_exchange_malloc_fn())\n+        }\n     };\n \n     // Grab the TypeRef type of box_ptr_ty."}, {"sha": "3478925753e22bb1db641282f7953818cdd9c749", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -159,6 +159,14 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n+fn heap_for_unique_closure(bcx: block, t: ty::t) -> heap {\n+    if ty::type_contents(bcx.tcx(), t).contains_managed() {\n+        heap_managed_unique\n+    } else {\n+        heap_exchange_closure\n+    }\n+}\n+\n pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n@@ -181,7 +189,7 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n             malloc_raw(bcx, cdata_ty, heap_managed)\n         }\n         ast::OwnedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_for_unique(bcx, cdata_ty))\n+            malloc_raw(bcx, cdata_ty, heap_for_unique_closure(bcx, cdata_ty))\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n@@ -526,7 +534,7 @@ pub fn make_opaque_cbox_take_glue(\n         let rval = alloca(bcx, Type::i8p());\n         let bcx = callee::trans_lang_call(\n             bcx,\n-            bcx.tcx().lang_items.exchange_malloc_fn(),\n+            bcx.tcx().lang_items.closure_exchange_malloc_fn(),\n             [opaque_tydesc, sz],\n             expr::SaveIn(rval));\n         let cbox_out = PointerCast(bcx, Load(bcx, rval), llopaquecboxty);"}, {"sha": "7234285f9e71ca164f28dac403b105e0ea2f9869", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -275,6 +275,7 @@ pub enum heap {\n     heap_managed,\n     heap_managed_unique,\n     heap_exchange,\n+    heap_exchange_closure\n }\n \n #[deriving(Eq)]\n@@ -384,7 +385,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n         f\n       }\n-      heap_exchange => {\n+      heap_exchange | heap_exchange_closure => {\n         let f: @fn(block) -> block = |a| glue::trans_exchange_free(a, ptr);\n         f\n       }"}, {"sha": "c01f01db5fd150a6cda0a98198f6191f7f4cd6c9", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -750,6 +750,12 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                   C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n                   fcx.llretptr.get());\n         }\n+        \"contains_managed\" => {\n+            let tp_ty = substs.tys[0];\n+            Store(bcx,\n+                  C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()),\n+                  fcx.llretptr.get());\n+        }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);"}, {"sha": "233508c5f668bfe5b3b15aa399586b7a51df1dfe", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -321,6 +321,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                 _ => {}\n             }\n         }\n+        heap_exchange_closure => fail!(\"vectors are not allocated with closure_exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n "}, {"sha": "b3848f5e86cb8b42907066f46c6346efb9318066", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -127,7 +127,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n                     \"move_val_init\" => use_repr,\n \n-                    \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n+                    \"get_tydesc\" | \"needs_drop\" | \"contains_managed\" => use_tydesc,\n \n                     \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n                     \"morestack_addr\" => 0,"}, {"sha": "ada85c82b304b6a2b8ba9184b5fe436ec9b553b1", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -52,13 +52,5 @@ pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     } = malloc_unique(bcx, body_datum.ty);\n     body_datum.copy_to(bcx, datum::INIT, dst_body);\n \n-    // Copy the type descriptor\n-    let src_tydesc_ptr = GEPi(bcx, src_box,\n-                              [0u, back::abi::box_field_tydesc]);\n-    let dst_tydesc_ptr = GEPi(bcx, dst_box,\n-                              [0u, back::abi::box_field_tydesc]);\n-    let td = Load(bcx, src_tydesc_ptr);\n-    Store(bcx, td, dst_tydesc_ptr);\n-\n-    return rslt(bcx, dst_box);\n+    rslt(bcx, dst_box)\n }"}, {"sha": "c33b644ee9f371fb4f2a40f1145ea24312085455", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -3539,7 +3539,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                ty::mk_nil())\n             }\n             \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-\n+            \"contains_managed\" => (1u, ~[], ty::mk_bool()),\n             \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n             \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n             \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {"}, {"sha": "2c9fcb2999f06b694b8569ba6610555aa16f4757", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -17,7 +17,6 @@ use ptr::to_unsafe_ptr;\n pub mod raw {\n     use std::unstable::intrinsics::TyDesc;\n \n-    pub static RC_EXCHANGE_UNIQUE : uint = (-1) as uint;\n     pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n     pub static RC_IMMORTAL : uint = 0x77777777;\n "}, {"sha": "9b74754d71107dda00bd4a2c84e16e018836fe14", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -730,7 +730,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n         #[cfg(windows)]\n         unsafe fn get_list(p: &Path) -> ~[~str] {\n             use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::wcslen;\n+            use libc::{wcslen, free};\n             use libc::funcs::extra::kernel32::{\n                 FindFirstFileW,\n                 FindNextFileW,\n@@ -739,7 +739,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             use os::win32::{\n                 as_utf16_p\n             };\n-            use rt::global_heap::{malloc_raw, free_raw};\n+            use rt::global_heap::malloc_raw;\n             #[nolink]\n             extern {\n                 unsafe fn rust_list_dir_wfd_size() -> libc::size_t;\n@@ -772,7 +772,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                             ::cast::transmute(wfd_ptr));\n                     }\n                     FindClose(find_handle);\n-                    free_raw(wfd_ptr);\n+                    free(wfd_ptr)\n                 }\n                 strings\n             }"}, {"sha": "f669dc753d60df76a95ee22761de449b49678b97", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -8,62 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use sys::{size_of};\n-use libc::{c_void, size_t, uintptr_t};\n-use c_malloc = libc::malloc;\n-use c_free = libc::free;\n+use libc::{c_char, c_void, size_t, uintptr_t, free, malloc};\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n-use cast::transmute;\n-use unstable::intrinsics::{atomic_xadd,atomic_xsub,TyDesc};\n-use ptr::null;\n+use unstable::intrinsics::TyDesc;\n+use sys::size_of;\n \n-pub unsafe fn malloc(td: *TyDesc, size: uint) -> *c_void {\n-    assert!(td.is_not_null());\n-\n-    let total_size = get_box_size(size, (*td).align);\n-    let p = c_malloc(total_size as size_t);\n-    assert!(p.is_not_null());\n-\n-    let box: &mut BoxRepr = transmute(p);\n-    box.header.ref_count = -1; // Exchange values not ref counted\n-    box.header.type_desc = td;\n-    box.header.prev = null();\n-    box.header.next = null();\n-\n-    let exchange_count = &mut *exchange_count_ptr();\n-    atomic_xadd(exchange_count, 1);\n-\n-    return transmute(box);\n-}\n-/**\n-Thin wrapper around libc::malloc, none of the box header\n-stuff in exchange_alloc::malloc\n-*/\n-pub unsafe fn malloc_raw(size: uint) -> *c_void {\n-    let p = c_malloc(size as size_t);\n-    if p.is_null() {\n-        fail!(\"Failure in malloc_raw: result ptr is null\");\n-    }\n-    p\n-}\n-\n-pub unsafe fn free(ptr: *c_void) {\n-    let exchange_count = &mut *exchange_count_ptr();\n-    atomic_xsub(exchange_count, 1);\n-\n-    assert!(ptr.is_not_null());\n-    c_free(ptr);\n-}\n-///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n-pub unsafe fn free_raw(ptr: *c_void) {\n-    c_free(ptr);\n+extern {\n+    #[rust_stack]\n+    fn abort();\n }\n \n fn get_box_size(body_size: uint, body_align: uint) -> uint {\n     let header_size = size_of::<BoxHeaderRepr>();\n     // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n     let total_size = align_to(header_size, body_align) + body_size;\n-    return total_size;\n+    total_size\n }\n \n // Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n@@ -73,11 +32,74 @@ fn align_to(size: uint, align: uint) -> uint {\n     (size + align - 1) & !(align - 1)\n }\n \n-fn exchange_count_ptr() -> *mut int {\n-    // XXX: Need mutable globals\n-    unsafe { transmute(&rust_exchange_count) }\n+/// A wrapper around libc::malloc, aborting on out-of-memory\n+pub unsafe fn malloc_raw(size: uint) -> *c_void {\n+    let p = malloc(size as size_t);\n+    if p.is_null() {\n+        // we need a non-allocating way to print an error here\n+        abort();\n+    }\n+    p\n }\n \n-extern {\n-    static rust_exchange_count: uintptr_t;\n+// FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n+#[cfg(stage0, not(test))]\n+#[lang=\"exchange_malloc\"]\n+#[inline]\n+pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+    let td = td as *TyDesc;\n+    let size = size as uint;\n+\n+    assert!(td.is_not_null());\n+\n+    let total_size = get_box_size(size, (*td).align);\n+    let p = malloc_raw(total_size as uint);\n+\n+    let box: *mut BoxRepr = p as *mut BoxRepr;\n+    (*box).header.ref_count = -1;\n+    (*box).header.type_desc = td;\n+\n+    box as *c_char\n+}\n+\n+// FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n+#[cfg(not(stage0), not(test))]\n+#[lang=\"exchange_malloc\"]\n+#[inline]\n+pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+    let td = td as *TyDesc;\n+    let size = size as uint;\n+\n+    assert!(td.is_not_null());\n+\n+    let total_size = get_box_size(size, (*td).align);\n+    malloc_raw(total_size as uint) as *c_char\n+}\n+\n+// FIXME: #7496\n+#[cfg(not(test))]\n+#[lang=\"closure_exchange_malloc\"]\n+#[inline]\n+pub unsafe fn closure_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+    let td = td as *TyDesc;\n+    let size = size as uint;\n+\n+    assert!(td.is_not_null());\n+\n+    let total_size = get_box_size(size, (*td).align);\n+    let p = malloc_raw(total_size as uint);\n+\n+    let box: *mut BoxRepr = p as *mut BoxRepr;\n+    (*box).header.type_desc = td;\n+\n+    box as *c_char\n+}\n+\n+// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n+// inside a landing pad may corrupt the state of the exception handler.\n+#[cfg(not(test))]\n+#[lang=\"exchange_free\"]\n+#[inline]\n+pub unsafe fn exchange_free(ptr: *c_char) {\n+    free(ptr as *c_void);\n }"}, {"sha": "5c47901df480226214d2db95f88ac4ef310c8b64", "filename": "src/libstd/unstable/exchange_alloc.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ca835f482cebcd353db789e45f9cec72db1a24ed/src%2Flibstd%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca835f482cebcd353db789e45f9cec72db1a24ed/src%2Flibstd%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fexchange_alloc.rs?ref=ca835f482cebcd353db789e45f9cec72db1a24ed", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use sys::size_of;\n-use libc::{c_void, size_t};\n-use c_malloc = libc::malloc;\n-use c_free = libc::free;\n-use managed::raw::{BoxHeaderRepr, BoxRepr};\n-use cast::transmute;\n-use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n-use ptr::null;\n-#[cfg(stage0)]\n-use intrinsic::TyDesc;\n-#[cfg(not(stage0))]\n-use unstable::intrinsics::TyDesc;\n-\n-pub unsafe fn malloc(td: *TyDesc, size: uint) -> *c_void {\n-    assert!(td.is_not_null());\n-\n-    let total_size = get_box_size(size, (*td).align);\n-    let p = c_malloc(total_size as size_t);\n-    assert!(p.is_not_null());\n-\n-    let box: &mut BoxRepr = transmute(p);\n-    box.header.ref_count = -1; // Exchange values not ref counted\n-    box.header.type_desc = td;\n-    box.header.prev = null();\n-    box.header.next = null();\n-\n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n-    atomic_xadd(exchange_count, 1);\n-\n-    return transmute(box);\n-}\n-/**\n-Thin wrapper around libc::malloc, none of the box header\n-stuff in exchange_alloc::malloc\n-*/\n-pub unsafe fn malloc_raw(size: uint) -> *c_void {\n-    let p = c_malloc(size as size_t);\n-    if p.is_null() {\n-        fail!(\"Failure in malloc_raw: result ptr is null\");\n-    }\n-    p\n-}\n-\n-pub unsafe fn free(ptr: *c_void) {\n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n-    atomic_xsub(exchange_count, 1);\n-\n-    assert!(ptr.is_not_null());\n-    c_free(ptr);\n-}\n-///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n-pub unsafe fn free_raw(ptr: *c_void) {\n-    c_free(ptr);\n-}\n-\n-fn get_box_size(body_size: uint, body_align: uint) -> uint {\n-    let header_size = size_of::<BoxHeaderRepr>();\n-    // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n-    let total_size = align_to(header_size, body_align) + body_size;\n-    return total_size;\n-}\n-\n-// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n-// of two.\n-fn align_to(size: uint, align: uint) -> uint {\n-    assert!(align != 0);\n-    (size + align - 1) & !(align - 1)\n-}\n-\n-extern {\n-    #[rust_stack]\n-    fn rust_get_exchange_count_ptr() -> *mut int;\n-}"}, {"sha": "500143fb5777341a8957112b5a3c3bea858fd4df", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -308,6 +308,10 @@ pub extern \"rust-intrinsic\" {\n     /// Returns `true` if a type requires drop glue.\n     pub fn needs_drop<T>() -> bool;\n \n+    /// Returns `true` if a type is managed (will be allocated on the local heap)\n+    #[cfg(not(stage0))]\n+    pub fn contains_managed<T>() -> bool;\n+\n     #[cfg(not(stage0))]\n     pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n "}, {"sha": "fddd847af341ca5f5663efe5ee6a612d14e0d44c", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -22,7 +22,6 @@ use rt::task::Task;\n use rt::local::Local;\n use option::{Option, Some, None};\n use io;\n-use rt::global_heap;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -150,13 +149,6 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n     }\n }\n \n-// FIXME #4942: Make these signatures agree with exchange_alloc's signatures\n-#[lang=\"exchange_malloc\"]\n-#[inline]\n-pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    transmute(global_heap::malloc(transmute(td), transmute(size)))\n-}\n-\n /// Because this code is so perf. sensitive, use a static constant so that\n /// debug printouts are compiled out most of the time.\n static ENABLE_DEBUG: bool = false;\n@@ -228,15 +220,6 @@ impl DebugPrints for io::fd_t {\n     }\n }\n \n-// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n-// inside a landing pad may corrupt the state of the exception handler. If a\n-// problem occurs, call exit instead.\n-#[lang=\"exchange_free\"]\n-#[inline]\n-pub unsafe fn exchange_free(ptr: *c_char) {\n-    global_heap::free(transmute(ptr))\n-}\n-\n #[lang=\"malloc\"]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     match context() {"}, {"sha": "272ad0ac705f45848759c07af8ee2449bf9d53fb", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -35,7 +35,7 @@ use unstable::intrinsics;\n #[cfg(stage0)]\n use intrinsic::{get_tydesc};\n #[cfg(not(stage0))]\n-use unstable::intrinsics::{get_tydesc};\n+use unstable::intrinsics::{get_tydesc, contains_managed};\n use vec;\n use util;\n \n@@ -1517,6 +1517,7 @@ impl<T> OwnedVector<T> for ~[T] {\n      * * n - The number of elements to reserve space for\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         use managed;\n@@ -1534,6 +1535,33 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n+    /**\n+     * Reserves capacity for exactly `n` elements in the given vector.\n+     *\n+     * If the capacity for `self` is already equal to or greater than the requested\n+     * capacity, then no action is taken.\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to reserve space for\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn reserve(&mut self, n: uint) {\n+        // Only make the (slow) call into the runtime if we have to\n+        if self.capacity() < n {\n+            unsafe {\n+                let ptr: **raw::VecRepr = cast::transmute(self);\n+                let td = get_tydesc::<T>();\n+                if contains_managed::<T>() {\n+                    rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n+                } else {\n+                    rustrt::vec_reserve_shared(td, ptr, n as libc::size_t);\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Reserves capacity for at least `n` elements in the given vector.\n      *"}, {"sha": "658d97031ce0aa28910706cd62ba6e289df1404a", "filename": "src/rt/rust_exchange_alloc.cpp", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_exchange_alloc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_exchange_alloc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.cpp?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -15,16 +15,10 @@\n #include <string.h>\n #include <stdio.h>\n \n-extern uintptr_t rust_exchange_count;\n-uintptr_t rust_exchange_count = 0;\n-\n void *\n rust_exchange_alloc::malloc(size_t size) {\n   void *value = ::malloc(size);\n   assert(value);\n-\n-  sync::increment(rust_exchange_count);\n-\n   return value;\n }\n \n@@ -37,15 +31,5 @@ rust_exchange_alloc::realloc(void *ptr, size_t size) {\n \n void\n rust_exchange_alloc::free(void *ptr) {\n-  sync::decrement(rust_exchange_count);\n   ::free(ptr);\n }\n-\n-void\n-rust_check_exchange_count_on_exit() {\n-  if (rust_exchange_count != 0) {\n-    printf(\"exchange heap not empty on exit\\n\");\n-    printf(\"%d dangling allocations\\n\", (int)rust_exchange_count);\n-    abort();\n-  }\n-}"}, {"sha": "9699ef6b5e9d9c1f2c4030b7757d598148e42b8e", "filename": "src/rt/rust_exchange_alloc.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_exchange_alloc.h", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_exchange_alloc.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.h?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -21,10 +21,4 @@ class rust_exchange_alloc {\n     void free(void *mem);\n };\n \n-extern \"C\" uintptr_t *\n-rust_get_exchange_count_ptr();\n-\n-void\n-rust_check_exchange_count_on_exit();\n-\n #endif"}, {"sha": "583f836c0d66ced9f0b8a6602911f7e0a2f0489b", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -211,7 +211,6 @@ rust_kernel::run() {\n     assert(osmain_driver != NULL);\n     osmain_driver->start_main_loop();\n     sched_reaper.join();\n-    rust_check_exchange_count_on_exit();\n     return rval;\n }\n "}, {"sha": "b572f1aba6a5321470f17dfdd584490b38fd37a3", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/040ac2a93270b4420c59621521d554a078e2d451/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=040ac2a93270b4420c59621521d554a078e2d451", "patch": "@@ -196,7 +196,6 @@ rust_register_exit_function\n rust_get_global_data_ptr\n rust_inc_kernel_live_count\n rust_dec_kernel_live_count\n-rust_exchange_count\n rust_get_rt_tls_key\n swap_registers\n rust_readdir"}]}