{"sha": "773b73c66c653f66ae056cecf9798de0686ef4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3M2I3M2M2NmM2NTNmNjZhZTA1NmNlY2Y5Nzk4ZGUwNjg2ZWY0YWQ=", "commit": {"author": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-10-07T21:14:11Z"}, "committer": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-11-21T23:39:16Z"}, "message": "Split iterator adaptors into individual modules\n\nThis commit also makes fields of `Take` private. I have no idea why they\nwere `pub(super)` before.", "tree": {"sha": "5d28e004d9bb9742067bc0c8cb72bc4b1bb68e11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d28e004d9bb9742067bc0c8cb72bc4b1bb68e11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/773b73c66c653f66ae056cecf9798de0686ef4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/773b73c66c653f66ae056cecf9798de0686ef4ad", "html_url": "https://github.com/rust-lang/rust/commit/773b73c66c653f66ae056cecf9798de0686ef4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/773b73c66c653f66ae056cecf9798de0686ef4ad/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75", "html_url": "https://github.com/rust-lang/rust/commit/3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75"}], "stats": {"total": 5802, "additions": 2969, "deletions": 2833}, "files": [{"sha": "da523c836561b1b4c49137d628ff9cabe2ce0a8e", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,142 @@\n+use crate::{\n+    iter::{\n+        adapters::zip::try_get_unchecked, adapters::TrustedRandomAccess, FusedIterator, TrustedLen,\n+    },\n+    ops::Try,\n+};\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned`]: Iterator::cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+\n+impl<I> Cloned<I> {\n+    pub(in crate::iter) fn new(it: I) -> Cloned<I> {\n+        Cloned { it }\n+    }\n+}\n+\n+fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, clone_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).fold(init, f)\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, clone_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).rfold(init, f)\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Cloned<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Clone,\n+{\n+}"}, {"sha": "98e231498c9a659743defa38fd71bfc1f1980033", "filename": "library/core/src/iter/adapters/copied.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,158 @@\n+use crate::{\n+    iter::{\n+        adapters::zip::try_get_unchecked, adapters::TrustedRandomAccess, FusedIterator, TrustedLen,\n+    },\n+    ops::Try,\n+};\n+\n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: Iterator::copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+\n+impl<I> Copied<I> {\n+    pub(in crate::iter) fn new(it: I) -> Copied<I> {\n+        Copied { it }\n+    }\n+}\n+\n+fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, copy_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, copy_fold(f))\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<T> {\n+        self.it.nth(n).copied()\n+    }\n+\n+    fn last(self) -> Option<T> {\n+        self.it.last().copied()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.it.count()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        *unsafe { try_get_unchecked(&mut self.it, idx) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, copy_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, copy_fold(f))\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Copied<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Copy,\n+{\n+}"}, {"sha": "6e9a011f819afce629cb5411aa86807aac47460a", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,87 @@\n+use crate::{iter::FusedIterator, ops::Try};\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle`]: Iterator::cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+\n+impl<I: Clone> Cycle<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Cycle<I> {\n+        Cycle { orig: iter.clone(), iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I>\n+where\n+    I: Clone + Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => {\n+                self.iter = self.orig.clone();\n+                self.iter.next()\n+            }\n+            y => y,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // fully iterate the current iterator. this is necessary because\n+        // `self.iter` may be empty even when `self.orig` isn't\n+        acc = self.iter.try_fold(acc, &mut f)?;\n+        self.iter = self.orig.clone();\n+\n+        // complete a full cycle, keeping track of whether the cycled\n+        // iterator is empty or not. we need to return early in case\n+        // of an empty iterator to prevent an infinite loop\n+        let mut is_empty = true;\n+        acc = self.iter.try_fold(acc, |acc, x| {\n+            is_empty = false;\n+            f(acc, x)\n+        })?;\n+\n+        if is_empty {\n+            return try { acc };\n+        }\n+\n+        loop {\n+            self.iter = self.orig.clone();\n+            acc = self.iter.try_fold(acc, &mut f)?;\n+        }\n+    }\n+\n+    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n+    // and we can't do anything better than the default.\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}"}, {"sha": "c42028ddeed69158e8869a3e02c62dc7b9a6c099", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,242 @@\n+use crate::{\n+    iter::{\n+        adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess},\n+        FusedIterator, InPlaceIterable, TrustedLen,\n+    },\n+    ops::{Add, AddAssign, Try},\n+};\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate`]: Iterator::enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+impl<I> Enumerate<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Enumerate<I> {\n+        Enumerate { iter, count: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n+        (Add::add(self.count, idx), value)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}"}, {"sha": "4de520eaca32d2268903deeb93b7a812eff90153", "filename": "library/core/src/iter/adapters/filter.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,154 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::Try,\n+};\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter`]: Iterator::filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+impl<I, P> Filter<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n+        Filter { iter, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        self.iter.find(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(self) -> usize {\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        self.iter.rfind(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}"}, {"sha": "c7c63db3cdc719f0945a3783bac58f5b7889184b", "filename": "library/core/src/iter/adapters/filter_map.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,153 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::ControlFlow,\n+    ops::Try,\n+};\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map`]: Iterator::filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> FilterMap<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FilterMap<I, F> {\n+        FilterMap { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => try { acc },\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.find_map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>,\n+        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::CONTINUE,\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n+    F: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "60e5ea8054e69022b35ef05273c68748156f7214", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -14,8 +14,9 @@ use super::Map;\n pub struct FlatMap<I, U: IntoIterator, F> {\n     inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n+\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n-    pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n         FlatMap { inner: FlattenCompat::new(iter.map(f)) }\n     }\n }"}, {"sha": "c159e67773b07856e8a1b1c930e9964e5ef5559b", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -1,10 +1,11 @@\n-use super::InPlaceIterable;\n-use crate::intrinsics;\n-use crate::iter::adapters::zip::try_get_unchecked;\n-use crate::iter::adapters::SourceIter;\n-use crate::iter::TrustedRandomAccess;\n-use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n-use crate::ops::Try;\n+use crate::{\n+    intrinsics,\n+    iter::{\n+        adapters::{zip::try_get_unchecked, InPlaceIterable, SourceIter},\n+        DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedRandomAccess,\n+    },\n+    ops::Try,\n+};\n \n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once."}, {"sha": "ae2e5eac728612967fd0543c9dab8f2afda22f82", "filename": "library/core/src/iter/adapters/inspect.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,169 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::Try,\n+};\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect`]: Iterator::inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Inspect<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Inspect<I, F> {\n+        Inspect { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}"}, {"sha": "0691f997f7b169626262f9928d372e544a4275df", "filename": "library/core/src/iter/adapters/map.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,217 @@\n+use crate::{\n+    fmt,\n+    iter::{\n+        adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess},\n+        FusedIterator, InPlaceIterable, TrustedLen,\n+    },\n+    ops::Try,\n+};\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map`]: Iterator::map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazily on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Map<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n+        Map { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, map_fold(self.f, g))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, map_fold(self.f, g))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+where\n+    I: TrustedLen,\n+    F: FnMut(I::Item) -> B,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}"}, {"sha": "a3dcbb4d82f7fdf4184f2e21856b418e22e6139e", "filename": "library/core/src/iter/adapters/map_while.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,103 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, InPlaceIterable},\n+    ops::{ControlFlow, Try},\n+};\n+\n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: Iterator::map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let x = self.iter.next()?;\n+        (self.predicate)(x)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let Self { iter, predicate } = self;\n+        iter.try_fold(init, |acc, x| match predicate(x) {\n+            Some(item) => ControlFlow::from_try(fold(acc, item)),\n+            None => ControlFlow::Break(try { acc }),\n+        })\n+        .into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n+    P: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "358049848e94297f984294828c41b2dfed4311ff", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 55, "deletions": 2818, "changes": 2873, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -1,26 +1,67 @@\n-use crate::cmp;\n-use crate::fmt;\n-use crate::intrinsics;\n-use crate::ops::{Add, AddAssign, ControlFlow, Try};\n-\n-use super::from_fn;\n-use super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, TrustedLen,\n+use crate::{\n+    iter::{InPlaceIterable, Iterator},\n+    ops::{ControlFlow, Try},\n };\n \n mod chain;\n+mod cloned;\n+mod copied;\n+mod cycle;\n+mod enumerate;\n+mod filter;\n+mod filter_map;\n mod flatten;\n mod fuse;\n+mod inspect;\n+mod map;\n+mod map_while;\n+mod peekable;\n+mod rev;\n+mod scan;\n+mod skip;\n+mod skip_while;\n+mod step_by;\n+mod take;\n+mod take_while;\n mod zip;\n \n-pub use self::chain::Chain;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::flatten::{FlatMap, Flatten};\n-pub use self::fuse::Fuse;\n-use self::zip::try_get_unchecked;\n+pub use self::{\n+    chain::Chain,\n+    cycle::Cycle,\n+    enumerate::Enumerate,\n+    filter::Filter,\n+    filter_map::FilterMap,\n+    flatten::FlatMap,\n+    fuse::Fuse,\n+    inspect::Inspect,\n+    map::Map,\n+    peekable::Peekable,\n+    rev::Rev,\n+    scan::Scan,\n+    skip::Skip,\n+    skip_while::SkipWhile,\n+    take::Take,\n+    take_while::TakeWhile,\n+    zip::Zip,\n+};\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+pub use self::cloned::Cloned;\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::step_by::StepBy;\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::flatten::Flatten;\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+pub use self::copied::Copied;\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+pub use self::map_while::MapWhile;\n+\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::zip::TrustedRandomAccess;\n-pub use self::zip::Zip;\n \n /// This trait provides transitive access to source-stage in an interator-adapter pipeline\n /// under the conditions that\n@@ -89,2810 +130,6 @@ pub unsafe trait SourceIter {\n     unsafe fn as_inner(&mut self) -> &mut Self::Source;\n }\n \n-/// A double-ended iterator with the direction inverted.\n-///\n-/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`rev`]: Iterator::rev\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rev<T> {\n-    iter: T,\n-}\n-impl<T> Rev<T> {\n-    pub(super) fn new(iter: T) -> Rev<T> {\n-        Rev { iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_back_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_rfold(init, f)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.rfind(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_fold(init, f)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, f)\n-    }\n-\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.find(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}\n-\n-/// An iterator that copies the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`copied`]: Iterator::copied\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Copied<I> {\n-    it: I,\n-}\n-\n-impl<I> Copied<I> {\n-    pub(super) fn new(it: I) -> Copied<I> {\n-        Copied { it }\n-    }\n-}\n-\n-fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> Iterator for Copied<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().copied()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, copy_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, copy_fold(f))\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<T> {\n-        self.it.nth(n).copied()\n-    }\n-\n-    fn last(self) -> Option<T> {\n-        self.it.last().copied()\n-    }\n-\n-    fn count(self) -> usize {\n-        self.it.count()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        *unsafe { try_get_unchecked(&mut self.it, idx) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().copied()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, copy_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, copy_fold(f))\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Copied<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-/// An iterator that clones the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cloned`]: Iterator::cloned\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Cloned<I> {\n-    it: I,\n-}\n-impl<I> Cloned<I> {\n-    pub(super) fn new(it: I) -> Cloned<I> {\n-        Cloned { it }\n-    }\n-}\n-\n-fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, elt| f(acc, elt.clone())\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> Iterator for Cloned<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().cloned()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, clone_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).fold(init, f)\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().cloned()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, clone_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).rfold(init, f)\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Cloned<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-/// An iterator that repeats endlessly.\n-///\n-/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cycle`]: Iterator::cycle\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Cycle<I> {\n-    orig: I,\n-    iter: I,\n-}\n-impl<I: Clone> Cycle<I> {\n-    pub(super) fn new(iter: I) -> Cycle<I> {\n-        Cycle { orig: iter.clone(), iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I>\n-where\n-    I: Clone + Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        match self.iter.next() {\n-            None => {\n-                self.iter = self.orig.clone();\n-                self.iter.next()\n-            }\n-            y => y,\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // the cycle iterator is either empty or infinite\n-        match self.orig.size_hint() {\n-            sz @ (0, Some(0)) => sz,\n-            (0, _) => (0, None),\n-            _ => (usize::MAX, None),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // fully iterate the current iterator. this is necessary because\n-        // `self.iter` may be empty even when `self.orig` isn't\n-        acc = self.iter.try_fold(acc, &mut f)?;\n-        self.iter = self.orig.clone();\n-\n-        // complete a full cycle, keeping track of whether the cycled\n-        // iterator is empty or not. we need to return early in case\n-        // of an empty iterator to prevent an infinite loop\n-        let mut is_empty = true;\n-        acc = self.iter.try_fold(acc, |acc, x| {\n-            is_empty = false;\n-            f(acc, x)\n-        })?;\n-\n-        if is_empty {\n-            return try { acc };\n-        }\n-\n-        loop {\n-            self.iter = self.orig.clone();\n-            acc = self.iter.try_fold(acc, &mut f)?;\n-        }\n-    }\n-\n-    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n-    // and we can't do anything better than the default.\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n-\n-/// An iterator for stepping iterators by a custom amount.\n-///\n-/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n-/// its documentation for more.\n-///\n-/// [`step_by`]: Iterator::step_by\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-#[derive(Clone, Debug)]\n-pub struct StepBy<I> {\n-    iter: I,\n-    step: usize,\n-    first_take: bool,\n-}\n-impl<I> StepBy<I> {\n-    pub(super) fn new(iter: I, step: usize) -> StepBy<I> {\n-        assert!(step != 0);\n-        StepBy { iter, step: step - 1, first_take: true }\n-    }\n-}\n-\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            self.iter.next()\n-        } else {\n-            self.iter.nth(self.step)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        #[inline]\n-        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n-        }\n-\n-        #[inline]\n-        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| n / (step + 1)\n-        }\n-\n-        let (low, high) = self.iter.size_hint();\n-\n-        if self.first_take {\n-            let f = first_size(self.step);\n-            (f(low), high.map(f))\n-        } else {\n-            let f = other_size(self.step);\n-            (f(low), high.map(f))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            let first = self.iter.next();\n-            if n == 0 {\n-                return first;\n-            }\n-            n -= 1;\n-        }\n-        // n and self.step are indices, we need to add 1 to get the amount of elements\n-        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n-        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n-        let mut step = self.step + 1;\n-        // n + 1 could overflow\n-        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n-        if n == usize::MAX {\n-            self.iter.nth(step - 1);\n-        } else {\n-            n += 1;\n-        }\n-\n-        // overflow handling\n-        loop {\n-            let mul = n.checked_mul(step);\n-            {\n-                if intrinsics::likely(mul.is_some()) {\n-                    return self.iter.nth(mul.unwrap() - 1);\n-                }\n-            }\n-            let div_n = usize::MAX / n;\n-            let div_step = usize::MAX / step;\n-            let nth_n = div_n * n;\n-            let nth_step = div_step * step;\n-            let nth = if nth_n > nth_step {\n-                step -= div_n;\n-                nth_n\n-            } else {\n-                n -= div_step;\n-                nth_step\n-            };\n-            self.iter.nth(nth - 1);\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return try { acc },\n-                Some(x) => acc = f(acc, x)?,\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n-    }\n-\n-    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return acc,\n-                Some(x) => acc = f(acc, x),\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n-    }\n-}\n-\n-impl<I> StepBy<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    // The zero-based index starting from the end of the iterator of the\n-    // last element. Used in the `DoubleEndedIterator` implementation.\n-    fn next_back_index(&self) -> usize {\n-        let rem = self.iter.len() % (self.step + 1);\n-        if self.first_take {\n-            if rem == 0 { self.step } else { rem - 1 }\n-        } else {\n-            rem\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for StepBy<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.iter.nth_back(self.next_back_index())\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n-        // is out of bounds because the length of `self.iter` does not exceed\n-        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n-        // zero-indexed\n-        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => try { init },\n-            Some(x) => {\n-                let acc = f(init, x)?;\n-                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n-    where\n-        Self: Sized,\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => init,\n-            Some(x) => {\n-                let acc = f(init, x);\n-                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n-            }\n-        }\n-    }\n-}\n-\n-// StepBy can only make the iterator shorter, so the len will still fit.\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n-\n-/// An iterator that maps the values of `iter` with `f`.\n-///\n-/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map`]: Iterator::map\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Notes about side effects\n-///\n-/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n-/// you can also [`map`] backwards:\n-///\n-/// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n-///\n-/// assert_eq!(v, [4, 3, 2]);\n-/// ```\n-///\n-/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-///\n-/// But if your closure has state, iterating backwards may act in a way you do\n-/// not expect. Let's go through an example. First, in the forward direction:\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) }) {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n-///\n-/// Now consider this twist where we add a call to `rev`. This version will\n-/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n-/// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazily on each item, but we are popping items off the\n-/// back of the vector now, instead of shifting them from the front.\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) })\n-///                                .rev() {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Map<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Map<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Map<I, F> {\n-        Map { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-fn map_try_fold<'a, T, B, Acc, R>(\n-    f: &'a mut impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, map_fold(self.f, g))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(&mut self.f)\n-    }\n-\n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, map_fold(self.f, g))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> B,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-/// An iterator that filters the elements of `iter` with `predicate`.\n-///\n-/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter`]: Iterator::filter\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Filter<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-impl<I, P> Filter<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> Filter<I, P> {\n-        Filter { iter, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_fold<T, Acc>(\n-    mut predicate: impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n-}\n-\n-fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n-    predicate: &'a mut impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        self.iter.find(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    // this special case allows the compiler to make `.filter(_).count()`\n-    // branchless. Barring perfect branch prediction (which is unattainable in\n-    // the general case), this will be much faster in >90% of cases (containing\n-    // virtually all real workloads) and only a tiny bit slower in the rest.\n-    //\n-    // Having this specialization thus allows us to write `.filter(p).count()`\n-    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n-    // less readable and also less backwards-compatible to Rust before 1.10.\n-    //\n-    // Using the branchless version will also simplify the LLVM byte code, thus\n-    // leaving more budget for LLVM optimizations.\n-    #[inline]\n-    fn count(self) -> usize {\n-        #[inline]\n-        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n-            move |x| predicate(&x) as usize\n-        }\n-\n-        self.iter.map(to_usize(self.predicate)).sum()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        self.iter.rfind(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that uses `f` to both filter and map elements from `iter`.\n-///\n-/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter_map`]: Iterator::filter_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct FilterMap<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> FilterMap<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> FilterMap<I, F> {\n-        FilterMap { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => acc,\n-    }\n-}\n-\n-fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n-    f: &'a mut impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => try { acc },\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.find_map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        #[inline]\n-        fn find<T, B>(\n-            f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n-            move |(), x| match f(x) {\n-                Some(x) => ControlFlow::Break(x),\n-                None => ControlFlow::CONTINUE,\n-            }\n-        }\n-\n-        self.iter.try_rfold((), find(&mut self.f)).break_value()\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n-    F: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that yields the current count and the element during iteration.\n-///\n-/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`enumerate`]: Iterator::enumerate\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Enumerate<I> {\n-    iter: I,\n-    count: usize,\n-}\n-impl<I> Enumerate<I> {\n-    pub(super) fn new(iter: I) -> Enumerate<I> {\n-        Enumerate { iter, count: 0 }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = (usize, <I as Iterator>::Item);\n-\n-    /// # Overflow Behavior\n-    ///\n-    /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n-    /// debug assertions are enabled, a panic is guaranteed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Might panic if the index of the element overflows a `usize`.\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next()?;\n-        let i = self.count;\n-        // Possible undefined overflow.\n-        AddAssign::add_assign(&mut self.count, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        let a = self.iter.nth(n)?;\n-        // Possible undefined overflow.\n-        let i = Add::add(self.count, n);\n-        self.count = Add::add(i, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn enumerate<'a, T, Acc, R>(\n-            count: &'a mut usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> R + 'a {\n-            move |acc, item| {\n-                let acc = fold(acc, (*count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                let acc = fold(acc, (count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(&mut count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.fold(init, enumerate(self.count, fold))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n-        (Add::add(self.count, idx), value)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next_back()?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.nth_back(n)?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc, R>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n-        ) -> impl FnMut(Acc, T) -> R {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, enumerate(count, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.rfold(init, enumerate(count, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}\n-\n-/// An iterator with a `peek()` that returns an optional reference to the next\n-/// element.\n-///\n-/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`peekable`]: Iterator::peekable\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<I: Iterator> {\n-    iter: I,\n-    /// Remember a peeked value, even if it was None.\n-    peeked: Option<Option<I::Item>>,\n-}\n-impl<I: Iterator> Peekable<I> {\n-    pub(super) fn new(iter: I) -> Peekable<I> {\n-        Peekable { iter, peeked: None }\n-    }\n-}\n-\n-// Peekable must remember if a None has been seen in the `.peek()` method.\n-// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n-// underlying iterator at most once. This does not by itself make the iterator\n-// fused.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> Iterator for Peekable<I> {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(v) => v,\n-            None => self.iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(mut self) -> usize {\n-        match self.peeked.take() {\n-            Some(None) => 0,\n-            Some(Some(_)) => 1 + self.iter.count(),\n-            None => self.iter.count(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(None) => None,\n-            Some(v @ Some(_)) if n == 0 => v,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        let peek_opt = match self.peeked.take() {\n-            Some(None) => return None,\n-            Some(v) => v,\n-            None => None,\n-        };\n-        self.iter.last().or(peek_opt)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let peek_len = match self.peeked {\n-            Some(None) => return (0, Some(0)),\n-            Some(Some(_)) => 1,\n-            None => 0,\n-        };\n-        let (lo, hi) = self.iter.size_hint();\n-        let lo = lo.saturating_add(peek_len);\n-        let hi = match hi {\n-            Some(x) => x.checked_add(peek_len),\n-            None => None,\n-        };\n-        (lo, hi)\n-    }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let acc = match self.peeked.take() {\n-            Some(None) => return try { init },\n-            Some(Some(v)) => f(init, v)?,\n-            None => init,\n-        };\n-        self.iter.try_fold(acc, f)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let acc = match self.peeked {\n-            Some(None) => return init,\n-            Some(Some(v)) => fold(init, v),\n-            None => init,\n-        };\n-        self.iter.fold(acc, fold)\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Peekable<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        match self.peeked.as_mut() {\n-            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n-            Some(None) => None,\n-            None => self.iter.next_back(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        match self.peeked.take() {\n-            Some(None) => try { init },\n-            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n-                Ok(acc) => f(acc, v),\n-                Err(e) => {\n-                    self.peeked = Some(Some(v));\n-                    Try::from_error(e)\n-                }\n-            },\n-            None => self.iter.try_rfold(init, f),\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        match self.peeked {\n-            Some(None) => init,\n-            Some(Some(v)) => {\n-                let acc = self.iter.rfold(init, &mut fold);\n-                fold(acc, v)\n-            }\n-            None => self.iter.rfold(init, fold),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n-\n-impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next() value without advancing the iterator.\n-    ///\n-    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n-    /// But if the iteration is over, `None` is returned.\n-    ///\n-    /// [`next`]: Iterator::next\n-    ///\n-    /// Because `peek()` returns a reference, and many iterators iterate over\n-    /// references, there can be a possibly confusing situation where the\n-    /// return value is a double reference. You can see this effect in the\n-    /// examples below.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // peek() lets us see into the future\n-    /// assert_eq!(iter.peek(), Some(&&1));\n-    /// assert_eq!(iter.next(), Some(&1));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&2));\n-    ///\n-    /// // The iterator does not advance even if we `peek` multiple times\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&3));\n-    ///\n-    /// // After the iterator is finished, so is `peek()`\n-    /// assert_eq!(iter.peek(), None);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&mut self) -> Option<&I::Item> {\n-        let iter = &mut self.iter;\n-        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n-    }\n-\n-    /// Consume and return the next value of this iterator if a condition is true.\n-    ///\n-    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n-    /// Otherwise, return `None`.\n-    ///\n-    /// # Examples\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n-    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    ///\n-    /// Consume any number less than 10.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (1..20).peekable();\n-    /// // Consume all numbers less than 10\n-    /// while iter.next_if(|&x| x < 10).is_some() {}\n-    /// // The next value returned will be 10\n-    /// assert_eq!(iter.next(), Some(10));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n-        match self.next() {\n-            Some(matched) if func(&matched) => Some(matched),\n-            other => {\n-                // Since we called `self.next()`, we consumed `self.peeked`.\n-                assert!(self.peeked.is_none());\n-                self.peeked = Some(other);\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Consume and return the next item if it is equal to `expected`.\n-    ///\n-    /// # Example\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if_eq(&0), None);\n-    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n-    where\n-        T: ?Sized,\n-        I::Item: PartialEq<T>,\n-    {\n-        self.next_if(|next| next == expected)\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}\n-\n-/// An iterator that rejects elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip_while`]: Iterator::skip_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct SkipWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> SkipWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n-        SkipWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        fn check<'a, T>(\n-            flag: &'a mut bool,\n-            pred: &'a mut impl FnMut(&T) -> bool,\n-        ) -> impl FnMut(&T) -> bool + 'a {\n-            move |x| {\n-                if *flag || !pred(x) {\n-                    *flag = true;\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-\n-        let flag = &mut self.flag;\n-        let pred = &mut self.predicate;\n-        self.iter.find(check(flag, pred))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v)?,\n-                None => return try { init },\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v),\n-                None => return init,\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for SkipWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take_while`]: Iterator::take_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct TakeWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> TakeWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n-        TakeWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.flag {\n-            None\n-        } else {\n-            let x = self.iter.next()?;\n-            if (self.predicate)(&x) {\n-                Some(x)\n-            } else {\n-                self.flag = true;\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.flag {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper) // can't know a lower bound, due to the predicate\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            flag: &'a mut bool,\n-            p: &'a mut impl FnMut(&T) -> bool,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                if p(&x) {\n-                    ControlFlow::from_try(fold(acc, x))\n-                } else {\n-                    *flag = true;\n-                    ControlFlow::Break(try { acc })\n-                }\n-            }\n-        }\n-\n-        if self.flag {\n-            try { init }\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for TakeWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n-///\n-/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map_while`]: Iterator::map_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-#[derive(Clone)]\n-pub struct MapWhile<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-\n-impl<I, P> MapWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n-        MapWhile { iter, predicate }\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let x = self.iter.next()?;\n-        (self.predicate)(x)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let Self { iter, predicate } = self;\n-        iter.try_fold(init, |acc, x| match predicate(x) {\n-            Some(item) => ControlFlow::from_try(fold(acc, item)),\n-            None => ControlFlow::Break(try { acc }),\n-        })\n-        .into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n-    P: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that skips over `n` elements of `iter`.\n-///\n-/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip`]: Iterator::skip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Skip<I> {\n-    iter: I,\n-    n: usize,\n-}\n-impl<I> Skip<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Skip<I> {\n-        Skip { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.next()\n-        } else {\n-            let old_n = self.n;\n-            self.n = 0;\n-            self.iter.nth(old_n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // Can't just add n + self.n due to overflow.\n-        if self.n > 0 {\n-            let to_skip = self.n;\n-            self.n = 0;\n-            // nth(n) skips n+1\n-            self.iter.nth(to_skip - 1)?;\n-        }\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn count(mut self) -> usize {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return 0;\n-            }\n-        }\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            self.iter.nth(self.n - 1)?;\n-        }\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = lower.saturating_sub(self.n);\n-        let upper = match upper {\n-            Some(x) => Some(x.saturating_sub(self.n)),\n-            None => None,\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let n = self.n;\n-        self.n = 0;\n-        if n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(n - 1).is_none() {\n-                return try { init };\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return init;\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 { self.iter.next_back() } else { None }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n-        let len = self.len();\n-        if n < len {\n-            self.iter.nth_back(n)\n-        } else {\n-            if len > 0 {\n-                // consume the original iterator\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<T, Acc, R: Try<Ok = Acc>>(\n-            mut n: usize,\n-            mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n-            move |acc, x| {\n-                n -= 1;\n-                let r = fold(acc, x);\n-                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        let n = self.len();\n-        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n-    }\n-\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_rfold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}\n-\n-/// An iterator that only iterates over the first `n` iterations of `iter`.\n-///\n-/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take`]: Iterator::take\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Take<I> {\n-    pub(super) iter: I,\n-    pub(super) n: usize,\n-}\n-impl<I> Take<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Take<I> {\n-        Take { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.n != 0 {\n-            self.n -= 1;\n-            self.iter.next()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.n > n {\n-            self.n -= n + 1;\n-            self.iter.nth(n)\n-        } else {\n-            if self.n > 0 {\n-                self.iter.nth(self.n - 1);\n-                self.n = 0;\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.n == 0 {\n-            return (0, Some(0));\n-        }\n-\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = cmp::min(lower, self.n);\n-\n-        let upper = match upper {\n-            Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n),\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            n: &'a mut usize,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                *n -= 1;\n-                let r = fold(acc, x);\n-                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, check(n, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n-\n-#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Take<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.n == 0 {\n-            None\n-        } else {\n-            let n = self.n;\n-            self.n -= 1;\n-            self.iter.nth_back(self.iter.len().saturating_sub(n))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        let len = self.iter.len();\n-        if self.n > n {\n-            let m = len.saturating_sub(self.n) + n;\n-            self.n -= n + 1;\n-            self.iter.nth_back(m)\n-        } else {\n-            if len > 0 {\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                try { init }\n-            } else {\n-                self.iter.try_rfold(init, fold)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n == 0 {\n-            init\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                init\n-            } else {\n-                self.iter.rfold(init, fold)\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-/// An iterator to maintain state while iterating another iterator.\n-///\n-/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`scan`]: Iterator::scan\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Scan<I, St, F> {\n-    iter: I,\n-    f: F,\n-    state: St,\n-}\n-impl<I, St, F> Scan<I, St, F> {\n-    pub(super) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n-        Scan { iter, state, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F>\n-where\n-    I: Iterator,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let a = self.iter.next()?;\n-        (self.f)(&mut self.state, a)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the scan function\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n-            state: &'a mut St,\n-            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n-            mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| match f(state, x) {\n-                None => ControlFlow::Break(try { acc }),\n-                Some(x) => ControlFlow::from_try(fold(acc, x)),\n-            }\n-        }\n-\n-        let state = &mut self.state;\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n-where\n-    I: SourceIter<Source = S>,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n-    F: FnMut(&mut St, I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that calls a function with a reference to each element before\n-/// yielding it.\n-///\n-/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`inspect`]: Iterator::inspect\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Inspect<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Inspect<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Inspect<I, F> {\n-        Inspect { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-impl<I: Iterator, F> Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        if let Some(ref a) = elt {\n-            (self.f)(a);\n-        }\n-\n-        elt\n-    }\n-}\n-\n-fn inspect_fold<T, Acc>(\n-    mut f: impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-fn inspect_try_fold<'a, T, Acc, R>(\n-    f: &'a mut impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next_back();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///"}, {"sha": "1822e10bdf67585a7d69e8ed5ffb204a21de8f44", "filename": "library/core/src/iter/adapters/peekable.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,303 @@\n+use crate::{\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen},\n+    ops::Try,\n+};\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable`]: Iterator::peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n+}\n+\n+impl<I: Iterator> Peekable<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Peekable<I> {\n+        Peekable { iter, peeked: None }\n+    }\n+}\n+\n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(v) => v,\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n+        let (lo, hi) = self.iter.size_hint();\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n+        (lo, hi)\n+    }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return try { init },\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        match self.peeked.as_mut() {\n+            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n+            Some(None) => None,\n+            None => self.iter.next_back(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        match self.peeked.take() {\n+            Some(None) => try { init },\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n+    /// But if the iteration is over, `None` is returned.\n+    ///\n+    /// [`next`]: Iterator::next\n+    ///\n+    /// Because `peek()` returns a reference, and many iterators iterate over\n+    /// references, there can be a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // The iterator does not advance even if we `peek` multiple times\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // After the iterator is finished, so is `peek()`\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n+    }\n+\n+    /// Consume and return the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume and return the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n+    where\n+        T: ?Sized,\n+        I::Item: PartialEq<T>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}"}, {"sha": "48ec0a80ad96679c2c2b91ae3427ae78c5618990", "filename": "library/core/src/iter/adapters/rev.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,139 @@\n+use crate::{\n+    iter::{FusedIterator, TrustedLen},\n+    ops::Try,\n+};\n+\n+/// A double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev`]: Iterator::rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T,\n+}\n+\n+impl<T> Rev<T> {\n+    pub(in crate::iter) fn new(iter: T) -> Rev<T> {\n+        Rev { iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_back_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}"}, {"sha": "12c11419c70fd69c7a82d0edc8ade85f65702e22", "filename": "library/core/src/iter/adapters/scan.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,113 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, InPlaceIterable},\n+    ops::{ControlFlow, Try},\n+};\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan`]: Iterator::scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+\n+impl<I, St, F> Scan<I, St, F> {\n+    pub(in crate::iter) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n+        Scan { iter, state, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F>\n+where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| match f(state, x) {\n+                None => ControlFlow::Break(try { acc }),\n+                Some(x) => ControlFlow::from_try(fold(acc, x)),\n+            }\n+        }\n+\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n+where\n+    I: SourceIter<Source = S>,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>\n+{\n+}"}, {"sha": "ff2d07c0c0d5a1d911fa0f5e1f2ce991c669f1fc", "filename": "library/core/src/iter/adapters/skip.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,201 @@\n+use crate::{\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::{ControlFlow, Try},\n+};\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip`]: Iterator::skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Skip<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Skip<I> {\n+        Skip { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n > 0 {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            self.iter.nth(to_skip - 1)?;\n+        }\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return 0;\n+            }\n+        }\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            self.iter.nth(self.n - 1)?;\n+        }\n+        self.iter.last()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return try { init };\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n+impl<I> DoubleEndedIterator for Skip<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 { self.iter.next_back() } else { None }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        let len = self.len();\n+        if n < len {\n+            self.iter.nth_back(n)\n+        } else {\n+            if len > 0 {\n+                // consume the original iterator\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n+            move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n+    }\n+\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}"}, {"sha": "cda8f9188d215c7e90f9cf512eac63edc316b473", "filename": "library/core/src/iter/adapters/skip_while.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,128 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::Try,\n+};\n+\n+/// An iterator that rejects elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while`]: Iterator::skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> SkipWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n+        SkipWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(check(flag, pred))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return try { init },\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for SkipWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "2ba56eeccba1729a23adb0d28a2bce1d43979326", "filename": "library/core/src/iter/adapters/step_by.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,235 @@\n+use crate::{intrinsics, iter::from_fn, ops::Try};\n+\n+/// An iterator for stepping iterators by a custom amount.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: Iterator::step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    iter: I,\n+    step: usize,\n+    first_take: bool,\n+}\n+\n+impl<I> StepBy<I> {\n+    pub(in crate::iter) fn new(iter: I, step: usize) -> StepBy<I> {\n+        assert!(step != 0);\n+        StepBy { iter, step: step - 1, first_take: true }\n+    }\n+}\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> Iterator for StepBy<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n+\n+        if self.first_take {\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n+        } else {\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            let first = self.iter.next();\n+            if n == 0 {\n+                return first;\n+            }\n+            n -= 1;\n+        }\n+        // n and self.step are indices, we need to add 1 to get the amount of elements\n+        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n+        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n+        let mut step = self.step + 1;\n+        // n + 1 could overflow\n+        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n+        if n == usize::MAX {\n+            self.iter.nth(step - 1);\n+        } else {\n+            n += 1;\n+        }\n+\n+        // overflow handling\n+        loop {\n+            let mul = n.checked_mul(step);\n+            {\n+                if intrinsics::likely(mul.is_some()) {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n+            }\n+            let div_n = usize::MAX / n;\n+            let div_step = usize::MAX / step;\n+            let nth_n = div_n * n;\n+            let nth_step = div_step * step;\n+            let nth = if nth_n > nth_step {\n+                step -= div_n;\n+                nth_n\n+            } else {\n+                n -= div_step;\n+                nth_step\n+            };\n+            self.iter.nth(nth - 1);\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return try { acc },\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n+\n+    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return acc,\n+                Some(x) => acc = f(acc, x),\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n+    }\n+}\n+\n+impl<I> StepBy<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => try { init },\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => init,\n+            Some(x) => {\n+                let acc = f(init, x);\n+                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n+            }\n+        }\n+    }\n+}\n+\n+// StepBy can only make the iterator shorter, so the len will still fit.\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}"}, {"sha": "982dbfcba3a43723abe5002dd2edb18e3495ea84", "filename": "library/core/src/iter/adapters/take.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,211 @@\n+use crate::{\n+    cmp, iter::FusedIterator, iter::InPlaceIterable, iter::TrustedLen, ops::ControlFlow, ops::Try,\n+};\n+\n+use super::SourceIter;\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take`]: Iterator::take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Take<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Take<I> {\n+        Take { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n),\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n+\n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                try { init }\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n == 0 {\n+            init\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                init\n+            } else {\n+                self.iter.rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}"}, {"sha": "aae0b20b83c4a2398efbeeead267119a5a9140c0", "filename": "library/core/src/iter/adapters/take_while.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -0,0 +1,141 @@\n+use crate::{\n+    fmt,\n+    iter::{adapters::SourceIter, FusedIterator, InPlaceIterable},\n+    ops::{ControlFlow, Try},\n+};\n+\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while`]: Iterator::take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> TakeWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n+        TakeWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                if p(&x) {\n+                    ControlFlow::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    ControlFlow::Break(try { acc })\n+                }\n+            }\n+        }\n+\n+        if self.flag {\n+            try { init }\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for TakeWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "fdc4035a612f191d751292eb513a17db5d73aea8", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773b73c66c653f66ae056cecf9798de0686ef4ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=773b73c66c653f66ae056cecf9798de0686ef4ad", "patch": "@@ -1,9 +1,10 @@\n-use crate::cmp;\n-use crate::fmt::{self, Debug};\n-\n-use super::super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, SourceIter,\n-    TrustedLen,\n+use crate::{\n+    cmp,\n+    fmt::{self, Debug},\n+    iter::{\n+        DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator,\n+        SourceIter, TrustedLen,\n+    },\n };\n \n /// An iterator that iterates two other iterators simultaneously.\n@@ -21,7 +22,7 @@ pub struct Zip<A, B> {\n     len: usize,\n }\n impl<A: Iterator, B: Iterator> Zip<A, B> {\n-    pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {\n+    pub(in crate::iter) fn new(a: A, b: B) -> Zip<A, B> {\n         ZipImpl::new(a, b)\n     }\n     fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {"}]}