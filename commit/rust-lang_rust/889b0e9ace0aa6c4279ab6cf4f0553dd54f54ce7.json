{"sha": "889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OWIwZTlhY2UwYWE2YzQyNzlhYjZjZjRmMDU1M2RkNTRmNTRjZTc=", "commit": {"author": {"name": "corentih", "email": "corentin.henry@alcatel-lucent.com", "date": "2015-10-26T19:31:11Z"}, "committer": {"name": "corentih", "email": "corentin.henry@alcatel-lucent.com", "date": "2015-11-14T15:21:30Z"}, "message": "rustfmt librustc_resolve", "tree": {"sha": "f769365a8e396acfae27408e9cf3cf792ed1042f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f769365a8e396acfae27408e9cf3cf792ed1042f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "html_url": "https://github.com/rust-lang/rust/commit/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/comments", "author": null, "committer": null, "parents": [{"sha": "4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207", "html_url": "https://github.com/rust-lang/rust/commit/4f5edf9e386f9ee7ed3f34edbaa3b71bd574c207"}], "stats": {"total": 2410, "additions": 1220, "deletions": 1190}, "files": [{"sha": "3481f1bfd5203449d3bd43949fa33ec8ccd56204", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 267, "deletions": 256, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "patch": "@@ -66,27 +66,27 @@ enum DuplicateCheckingMode {\n     ForbidDuplicateTypesAndModules,\n     ForbidDuplicateValues,\n     ForbidDuplicateTypesAndValues,\n-    OverwriteDuplicates\n+    OverwriteDuplicates,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n enum NamespaceError {\n     NoError,\n     ModuleError,\n     TypeError,\n-    ValueError\n+    ValueError,\n }\n \n fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n     match ns {\n-        NoError                 => \"\",\n+        NoError => \"\",\n         ModuleError | TypeError => \"type or module\",\n-        ValueError              => \"value\",\n+        ValueError => \"value\",\n     }\n }\n \n-struct GraphBuilder<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>\n+struct GraphBuilder<'a, 'b: 'a, 'tcx: 'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n }\n \n impl<'a, 'b:'a, 'tcx:'b> Deref for GraphBuilder<'a, 'b, 'tcx> {\n@@ -109,7 +109,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let parent = self.graph_root.get_module();\n         let mut visitor = BuildReducedGraphVisitor {\n             builder: self,\n-            parent: parent\n+            parent: parent,\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -135,9 +135,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n \n-        self.check_for_conflicts_between_external_crates_and_items(&**parent,\n-                                                                   name,\n-                                                                   sp);\n+        self.check_for_conflicts_between_external_crates_and_items(&**parent, name, sp);\n \n         // Add or reuse the child.\n         let child = parent.children.borrow().get(&name).cloned();\n@@ -194,14 +192,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                 n = Some(TypeNS);\n                                 duplicate_type = TypeError;\n                             }\n-                        };\n+                        }\n                         if child.defined_in_namespace(ValueNS) {\n                             duplicate_type = ValueError;\n                             n = Some(ValueNS);\n                         }\n                         n\n                     }\n-                    OverwriteDuplicates => None\n+                    OverwriteDuplicates => None,\n                 };\n                 if duplicate_type != NoError {\n                     // Return an error here by looking up the namespace that\n@@ -218,7 +216,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n                             self.session.span_note(sp,\n-                                 &format!(\"first definition of {} `{}` here\",\n+                                                   &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n                                       name));\n                         }\n@@ -278,15 +276,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module_path = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n-                            .split_last().unwrap().1\n-                            .iter().map(|seg| seg.identifier.name)\n-                            .collect()\n+                                 .split_last()\n+                                 .unwrap()\n+                                 .1\n+                                 .iter()\n+                                 .map(|seg| seg.identifier.name)\n+                                 .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n-                            .iter().map(|seg| seg.identifier.name).collect()\n+                                         .iter()\n+                                         .map(|seg| seg.identifier.name)\n+                                         .collect()\n                     }\n                 };\n \n@@ -302,8 +305,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n+                        let source_name = full_path.segments.last().unwrap().identifier.name;\n                         if source_name.as_str() == \"mod\" || source_name.as_str() == \"self\" {\n                             resolve_error(self,\n                                           view_path.span,\n@@ -321,19 +323,21 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n+                        let mod_spans = source_items.iter()\n+                                                    .filter_map(|item| {\n+                                                        match item.node {\n+                                                            PathListMod { .. } => Some(item.span),\n+                                                            _ => None,\n+                                                        }\n+                                                    })\n+                                                    .collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            resolve_error(\n-                                self,\n-                                mod_spans[0],\n-                                ResolutionError::SelfImportCanOnlyAppearOnceInTheList\n-                            );\n+                            resolve_error(self,\n+                                          mod_spans[0],\n+                                          ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n                             for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `self` import appears here\");\n+                                self.session\n+                                    .span_note(*other_span, \"another `self` import appears here\");\n                             }\n                         }\n \n@@ -359,14 +363,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            self.build_import_directive(\n-                                &**parent,\n-                                module_path,\n-                                SingleImport(rename, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n+                            self.build_import_directive(&**parent,\n+                                                        module_path,\n+                                                        SingleImport(rename, name),\n+                                                        source_item.span,\n+                                                        source_item.node.id(),\n+                                                        is_public,\n+                                                        shadowable);\n                         }\n                     }\n                     ViewPathGlob(_) => {\n@@ -383,9 +386,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n \n             ItemExternCrate(_) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n+                // n.b. we don't need to look at the path option here, because cstore already\n+                // did\n                 if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    let def_id = DefId { krate: crate_id, index: CRATE_DEF_INDEX };\n+                    let def_id = DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,\n@@ -394,9 +401,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                               false,\n                                                               true));\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            module_to_string(&*external_module));\n+                           module_to_string(&*external_module));\n                     self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n-                    parent.external_module_children.borrow_mut()\n+                    parent.external_module_children\n+                          .borrow_mut()\n                           .insert(name, external_module.clone());\n                     self.build_reduced_graph_for_external_crate(&external_module);\n                 }\n@@ -407,20 +415,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let child = parent.children.borrow().get(&name).cloned();\n                 if let Some(child) = child {\n                     // check if there's struct of the same name already defined\n-                    if child.defined_in_namespace(TypeNS)\n-                        && child.get_module_if_available().is_none() {\n-                        self.session.span_warn(sp, &format!(\n-                                                    \"duplicate definition of {} `{}`. \\\n-                                                     Defining a module and a struct with \\\n-                                                     the same name will be disallowed \\\n-                                                     soon.\",\n-                                               namespace_error_to_string(TypeError),\n-                                               name));\n+                    if child.defined_in_namespace(TypeNS) &&\n+                       child.get_module_if_available().is_none() {\n+                        self.session.span_warn(sp,\n+                                               &format!(\"duplicate definition of {} `{}`. \\\n+                                                         Defining a module and a struct with \\\n+                                                         the same name will be disallowed soon.\",\n+                                                        namespace_error_to_string(TypeError),\n+                                                        name));\n                         {\n                             let r = child.span_for_namespace(TypeNS);\n                             if let Some(sp) = r {\n                                 self.session.span_note(sp,\n-                                     &format!(\"first definition of {} `{}` here\",\n+                                                       &format!(\"first definition of {} `{}` here\",\n                                           namespace_error_to_string(TypeError),\n                                           name));\n                             }\n@@ -468,10 +475,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n-                let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+                let name_bindings = self.add_child(name,\n+                                                   parent,\n+                                                   ForbidDuplicateTypesAndModules,\n+                                                   sp);\n \n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false), sp,\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n+                                          sp,\n                                           modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n@@ -485,8 +495,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n-                let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+                let name_bindings = self.add_child(name,\n+                                                   parent,\n+                                                   ForbidDuplicateTypesAndModules,\n+                                                   sp);\n \n                 name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), true),\n                                           sp,\n@@ -504,10 +516,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(\n-                        &**variant,\n-                        item_def_id,\n-                        &module);\n+                    self.build_reduced_graph_for_variant(&**variant, item_def_id, &module);\n                 }\n                 parent.clone()\n             }\n@@ -522,20 +531,21 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     if let Some(child) = child {\n                         // check if theres a DefMod\n                         if let Some(DefMod(_)) = child.def_for_namespace(TypeNS) {\n-                            self.session.span_warn(sp, &format!(\n-                                                        \"duplicate definition of {} `{}`. \\\n-                                                         Defining a module and a struct with \\\n-                                                         the same name will be disallowed \\\n-                                                         soon.\",\n-                                                   namespace_error_to_string(TypeError),\n-                                                   name));\n+                            self.session.span_warn(sp,\n+                                                   &format!(\"duplicate definition of {} `{}`. \\\n+                                                             Defining a module and a struct \\\n+                                                             with the same name will be \\\n+                                                             disallowed soon.\",\n+                                                            namespace_error_to_string(TypeError),\n+                                                            name));\n                             {\n                                 let r = child.span_for_namespace(TypeNS);\n                                 if let Some(sp) = r {\n-                                    self.session.span_note(sp,\n-                                         &format!(\"first definition of {} `{}` here\",\n-                                              namespace_error_to_string(TypeError),\n-                                              name));\n+                                    self.session\n+                                        .span_note(sp,\n+                                                   &format!(\"first definition of {} `{}` here\",\n+                                                            namespace_error_to_string(TypeError),\n+                                                            name));\n                                 }\n                             }\n                         }\n@@ -559,12 +569,15 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let named_fields = struct_def.fields().iter().filter_map(|f| {\n-                    match f.node.kind {\n-                        NamedField(name, _) => Some(name),\n-                        UnnamedField(_) => None\n-                    }\n-                }).collect();\n+                let named_fields = struct_def.fields()\n+                                             .iter()\n+                                             .filter_map(|f| {\n+                                                 match f.node.kind {\n+                                                     NamedField(name, _) => Some(name),\n+                                                     UnnamedField(_) => None,\n+                                                 }\n+                                             })\n+                                             .collect();\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, named_fields);\n \n@@ -575,8 +588,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemImpl(..) => parent.clone(),\n \n             ItemTrait(_, _, _, ref items) => {\n-                let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+                let name_bindings = self.add_child(name,\n+                                                   parent,\n+                                                   ForbidDuplicateTypesAndModules,\n+                                                   sp);\n \n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n@@ -593,9 +608,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n                     let name_bindings = self.add_child(trait_item.name,\n-                                        &module_parent,\n-                                        ForbidDuplicateTypesAndValues,\n-                                        trait_item.span);\n+                                                       &module_parent,\n+                                                       ForbidDuplicateTypesAndValues,\n+                                                       trait_item.span);\n \n                     match trait_item.node {\n                         hir::ConstTraitItem(..) => {\n@@ -642,19 +657,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             false\n         };\n \n-        let child = self.add_child(name, parent,\n-                                   ForbidDuplicateTypesAndValues,\n-                                   variant.span);\n+        let child = self.add_child(name, parent, ForbidDuplicateTypesAndValues, variant.span);\n         // variants are always treated as importable to allow them to be glob\n         // used\n         child.define_value(DefVariant(item_id,\n                                       self.ast_map.local_def_id(variant.node.data.id()),\n                                       is_exported),\n-                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n+                           variant.span,\n+                           DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n                                      self.ast_map.local_def_id(variant.node.data.id()),\n                                      is_exported),\n-                          variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n+                          variant.span,\n+                          DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -668,9 +683,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n-        let name_bindings =\n-            self.add_child(name, parent, ForbidDuplicateValues,\n-                           foreign_item.span);\n+        let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, foreign_item.span);\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -687,16 +700,15 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n-            debug!(\"(building reduced graph for block) creating a new \\\n-                    anonymous module for block {}\",\n+            debug!(\"(building reduced graph for block) creating a new anonymous module for block \\\n+                    {}\",\n                    block_id);\n \n-            let new_module = Rc::new(Module::new(\n-                BlockParentLink(Rc::downgrade(parent), block_id),\n-                None,\n-                AnonymousModuleKind,\n-                false,\n-                false));\n+            let new_module = Rc::new(Module::new(BlockParentLink(Rc::downgrade(parent), block_id),\n+                                                 None,\n+                                                 AnonymousModuleKind,\n+                                                 false,\n+                                                 false));\n             parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n             new_module\n         } else {\n@@ -711,18 +723,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            final_ident: &str,\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n-        debug!(\"(building reduced graph for \\\n-                external crate) building external def {}, priv {:?}\",\n-               final_ident, vis);\n+        debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n+               final_ident,\n+               vis);\n         let is_public = vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n-        let is_exported = is_public && match new_parent.def_id.get() {\n+        let is_exported = is_public &&\n+                          match new_parent.def_id.get() {\n             None => true,\n-            Some(did) => self.external_exports.contains(&did)\n+            Some(did) => self.external_exports.contains(&did),\n         };\n         if is_exported {\n             self.external_exports.insert(def.def_id());\n@@ -731,140 +744,148 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let kind = match def {\n             DefTy(_, true) => EnumModuleKind,\n             DefTy(_, false) | DefStruct(..) => TypeModuleKind,\n-            _ => NormalModuleKind\n+            _ => NormalModuleKind,\n         };\n \n         match def {\n-          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n-          DefTy(def_id, _) => {\n-            let type_def = child_name_bindings.type_def.borrow().clone();\n-            match type_def {\n-              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        already created module\");\n-                module_def.def_id.set(Some(def_id));\n-              }\n-              Some(_) | None => {\n-                debug!(\"(building reduced graph for \\\n-                        external crate) building module \\\n-                        {} {}\", final_ident, is_public);\n-                let parent_link = self.get_parent_link(new_parent, name);\n-\n-                child_name_bindings.define_module(parent_link,\n-                                                  Some(def_id),\n-                                                  kind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP);\n-              }\n+            DefMod(def_id) |\n+            DefForeignMod(def_id) |\n+            DefStruct(def_id) |\n+            DefTy(def_id, _) => {\n+                let type_def = child_name_bindings.type_def.borrow().clone();\n+                match type_def {\n+                    Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n+                        debug!(\"(building reduced graph for external crate) already created \\\n+                                module\");\n+                        module_def.def_id.set(Some(def_id));\n+                    }\n+                    Some(_) | None => {\n+                        debug!(\"(building reduced graph for external crate) building module {} {}\",\n+                               final_ident,\n+                               is_public);\n+                        let parent_link = self.get_parent_link(new_parent, name);\n+\n+                        child_name_bindings.define_module(parent_link,\n+                                                          Some(def_id),\n+                                                          kind,\n+                                                          true,\n+                                                          is_public,\n+                                                          DUMMY_SP);\n+                    }\n+                }\n             }\n-          }\n-          _ => {}\n+            _ => {}\n         }\n \n         match def {\n-          DefMod(_) | DefForeignMod(_) => {}\n-          DefVariant(_, variant_id, is_struct) => {\n-              debug!(\"(building reduced graph for external crate) building \\\n-                      variant {}\",\n-                      final_ident);\n-              // variants are always treated as importable to allow them to be\n-              // glob used\n-              let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-              if is_struct {\n-                  child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                  // Not adding fields for variants as they are not accessed with a self receiver\n-                  self.structs.insert(variant_id, Vec::new());\n-              } else {\n-                  child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-              }\n-          }\n-          DefFn(ctor_id, true) => {\n-            child_name_bindings.define_value(\n+            DefMod(_) | DefForeignMod(_) => {}\n+            DefVariant(_, variant_id, is_struct) => {\n+                debug!(\"(building reduced graph for external crate) building variant {}\",\n+                       final_ident);\n+                // variants are always treated as importable to allow them to be\n+                // glob used\n+                let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n+                if is_struct {\n+                    child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                    // Not adding fields for variants as they are not accessed with a self receiver\n+                    self.structs.insert(variant_id, Vec::new());\n+                } else {\n+                    child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+                }\n+            }\n+            DefFn(ctor_id, true) => {\n+                child_name_bindings.define_value(\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n-          }\n-          DefFn(..) | DefStatic(..) | DefConst(..) | DefAssociatedConst(..) |\n-          DefMethod(..) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building value (fn/static) {}\", final_ident);\n-            // impl methods have already been defined with the correct importability modifier\n-            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n-                             (def.modifiers &  DefModifiers::IMPORTABLE),\n-                None => modifiers\n-            };\n-            if new_parent.kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !DefModifiers::IMPORTABLE;\n             }\n-            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-          }\n-          DefTrait(def_id) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              // If this is a trait, add all the trait item names to the trait\n-              // info.\n-\n-              let trait_item_def_ids =\n-                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def in &trait_item_def_ids {\n-                  let trait_item_name = csearch::get_trait_name(&self.session.cstore,\n-                                                                trait_item_def.def_id());\n-\n-                  debug!(\"(building reduced graph for external crate) ... \\\n-                          adding trait item '{}'\",\n-                         trait_item_name);\n-\n-                  self.trait_item_map.insert((trait_item_name, def_id),\n-                                             trait_item_def.def_id());\n-\n-                  if is_exported {\n-                      self.external_exports.insert(trait_item_def.def_id());\n-                  }\n-              }\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-\n-              // Define a module if necessary.\n-              let parent_link = self.get_parent_link(new_parent, name);\n-              child_name_bindings.set_module_kind(parent_link,\n-                                                  Some(def_id),\n-                                                  TraitModuleKind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP)\n-          }\n-          DefTy(..) | DefAssociatedTy(..) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              let modifiers = match new_parent.kind.get() {\n-                  NormalModuleKind => modifiers,\n-                  _ => modifiers & !DefModifiers::IMPORTABLE\n-              };\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-          }\n-          DefStruct(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type and value for {}\",\n-                   final_ident);\n-            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-            let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n-\n-            if fields.is_empty() {\n+            DefFn(..) |\n+            DefStatic(..) |\n+            DefConst(..) |\n+            DefAssociatedConst(..) |\n+            DefMethod(..) => {\n+                debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n+                       final_ident);\n+                // impl methods have already been defined with the correct importability\n+                // modifier\n+                let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                    Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n+                                     (def.modifiers & DefModifiers::IMPORTABLE),\n+                    None => modifiers,\n+                };\n+                if new_parent.kind.get() != NormalModuleKind {\n+                    modifiers = modifiers & !DefModifiers::IMPORTABLE;\n+                }\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n+            DefTrait(def_id) => {\n+                debug!(\"(building reduced graph for external crate) building type {}\",\n+                       final_ident);\n+\n+                // If this is a trait, add all the trait item names to the trait\n+                // info.\n+\n+                let trait_item_def_ids = csearch::get_trait_item_def_ids(&self.session.cstore,\n+                                                                         def_id);\n+                for trait_item_def in &trait_item_def_ids {\n+                    let trait_item_name = csearch::get_trait_name(&self.session.cstore,\n+                                                                  trait_item_def.def_id());\n+\n+                    debug!(\"(building reduced graph for external crate) ... adding trait item \\\n+                            '{}'\",\n+                           trait_item_name);\n+\n+                    self.trait_item_map.insert((trait_item_name, def_id), trait_item_def.def_id());\n+\n+                    if is_exported {\n+                        self.external_exports.insert(trait_item_def.def_id());\n+                    }\n+                }\n+\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+\n+                // Define a module if necessary.\n+                let parent_link = self.get_parent_link(new_parent, name);\n+                child_name_bindings.set_module_kind(parent_link,\n+                                                    Some(def_id),\n+                                                    TraitModuleKind,\n+                                                    true,\n+                                                    is_public,\n+                                                    DUMMY_SP)\n+            }\n+            DefTy(..) | DefAssociatedTy(..) => {\n+                debug!(\"(building reduced graph for external crate) building type {}\",\n+                       final_ident);\n \n-            // Record the def ID and fields of this struct.\n-            self.structs.insert(def_id, fields);\n-          }\n-          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n-          DefUse(..) | DefUpvar(..) |\n-          DefLabel(..) | DefSelfTy(..) => {\n-            panic!(\"didn't expect `{:?}`\", def);\n-          }\n+                let modifiers = match new_parent.kind.get() {\n+                    NormalModuleKind => modifiers,\n+                    _ => modifiers & !DefModifiers::IMPORTABLE,\n+                };\n+\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+            }\n+            DefStruct(def_id) => {\n+                debug!(\"(building reduced graph for external crate) building type and value for \\\n+                        {}\",\n+                       final_ident);\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n+\n+                if fields.is_empty() {\n+                    child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+                }\n+\n+                // Record the def ID and fields of this struct.\n+                self.structs.insert(def_id, fields);\n+            }\n+            DefLocal(..) |\n+            DefPrimTy(..) |\n+            DefTyParam(..) |\n+            DefUse(..) |\n+            DefUpvar(..) |\n+            DefLabel(..) |\n+            DefSelfTy(..) => {\n+                panic!(\"didn't expect `{:?}`\", def);\n+            }\n         }\n     }\n \n@@ -894,11 +915,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         });\n                     }\n                     _ => {\n-                        let child_name_bindings =\n-                            self.add_child(name,\n-                                           root,\n-                                           OverwriteDuplicates,\n-                                           DUMMY_SP);\n+                        let child_name_bindings = self.add_child(name,\n+                                                                 root,\n+                                                                 OverwriteDuplicates,\n+                                                                 DUMMY_SP);\n \n                         self.handle_external_def(def,\n                                                  def_visibility,\n@@ -910,12 +930,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n             }\n             DlImpl(_) => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        ignoring impl\");\n+                debug!(\"(building reduced graph for external crate) ignoring impl\");\n             }\n             DlField => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        ignoring field\");\n+                debug!(\"(building reduced graph for external crate) ignoring field\");\n             }\n         }\n     }\n@@ -928,21 +946,21 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let def_id = match module.def_id.get() {\n             None => {\n                 debug!(\"(populating external module) ... no def ID!\");\n-                return\n+                return;\n             }\n             Some(def_id) => def_id,\n         };\n \n         csearch::each_child_of_item(&self.session.cstore,\n                                     def_id,\n                                     |def_like, child_name, visibility| {\n-            debug!(\"(populating external module) ... found ident: {}\",\n-                   child_name);\n-            self.build_reduced_graph_for_external_crate_def(module,\n-                                                            def_like,\n-                                                            child_name,\n-                                                            visibility)\n-        });\n+                                        debug!(\"(populating external module) ... found ident: {}\",\n+                                               child_name);\n+                                        self.build_reduced_graph_for_external_crate_def(module,\n+                                                                                        def_like,\n+                                                                                        child_name,\n+                                                                                        visibility)\n+                                    });\n         module.populated.set(true)\n     }\n \n@@ -977,12 +995,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                               id: NodeId,\n                               is_public: bool,\n                               shadowable: Shadowable) {\n-        module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n-                                                               subclass,\n-                                                               span,\n-                                                               id,\n-                                                               is_public,\n-                                                               shadowable));\n+        module_.imports\n+               .borrow_mut()\n+               .push(ImportDirective::new(module_path, subclass, span, id, is_public, shadowable));\n         self.unresolved_imports += 1;\n \n         if is_public {\n@@ -1030,9 +1045,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n+struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     builder: GraphBuilder<'a, 'b, 'tcx>,\n-    parent: Rc<Module>\n+    parent: Rc<Module>,\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n@@ -1056,13 +1071,9 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n }\n \n pub fn build_reduced_graph(resolver: &mut Resolver, krate: &hir::Crate) {\n-    GraphBuilder {\n-        resolver: resolver\n-    }.build_reduced_graph(krate);\n+    GraphBuilder { resolver: resolver }.build_reduced_graph(krate);\n }\n \n pub fn populate_module_if_necessary(resolver: &mut Resolver, module: &Rc<Module>) {\n-    GraphBuilder {\n-        resolver: resolver\n-    }.populate_module_if_necessary(module);\n+    GraphBuilder { resolver: resolver }.populate_module_if_necessary(module);\n }"}, {"sha": "870990f78607c2e305735d7d1420c7c4f4121d0b", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "patch": "@@ -31,8 +31,8 @@ use rustc_front::hir;\n use rustc_front::hir::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use rustc_front::visit::{self, Visitor};\n \n-struct UnusedImportCheckVisitor<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>\n+struct UnusedImportCheckVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n@@ -51,16 +51,16 @@ impl<'a, 'b, 'tcx:'b> DerefMut for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    // We have information about whether `use` (import) directives are actually used now.\n-    // If an import is not used at all, we signal a lint error. If an import is only used\n-    // for a single namespace, we remove the other namespace from the recorded privacy\n-    // information. That means in privacy.rs, we will only check imports and namespaces\n-    // which are used. In particular, this means that if an import could name either a\n-    // public or private item, we will check the correct thing, dependent on how the import\n-    // is used.\n+    // We have information about whether `use` (import) directives are actually\n+    // used now. If an import is not used at all, we signal a lint error. If an\n+    // import is only used for a single namespace, we remove the other namespace\n+    // from the recorded privacy information. That means in privacy.rs, we will\n+    // only check imports and namespaces which are used. In particular, this\n+    // means that if an import could name either a public or private item, we\n+    // will check the correct thing, dependent on how the import is used.\n     fn finalize_import(&mut self, id: ast::NodeId, span: Span) {\n         debug!(\"finalizing import uses for {:?}\",\n-                self.session.codemap().span_to_snippet(span));\n+               self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n@@ -99,14 +99,14 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n             // we might have two LastPrivates pointing at the same thing. There is no point\n             // checking both, so lets not check the value one.\n             (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n-            _ => {},\n+            _ => {}\n         }\n \n         path_res.last_private = LastImport {\n             value_priv: v_priv,\n             value_used: v_used,\n             type_priv: t_priv,\n-            type_used: t_used\n+            type_used: t_used,\n         };\n     }\n }\n@@ -132,7 +132,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                                               \"unused extern crate\".to_string());\n                     }\n                 }\n-            },\n+            }\n             hir::ItemUse(ref p) => {\n                 match p.node {\n                     ViewPathSimple(_, _) => {"}, {"sha": "a6665a137865dd0d6111e4589056572f3dd455a2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "patch": "@@ -10,9 +10,9 @@\n \n #![allow(non_snake_case)]\n \n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+// Error messages for EXXXX errors.  Each message should start and end with a\n+// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n+// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n \n E0154: r##\""}, {"sha": "a402d8310f96a74def4d490b0a872e7445d05d69", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 748, "deletions": 716, "changes": 1464, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7"}, {"sha": "96fad16536cb8ba45afb3c921b7b32654e0db10c", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "patch": "@@ -30,8 +30,8 @@ use syntax::ast;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n \n-struct ExportRecorder<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>\n+struct ExportRecorder<'a, 'b: 'a, 'tcx: 'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n }\n \n // Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n@@ -50,28 +50,26 @@ impl<'a, 'b, 'tcx:'b> DerefMut for ExportRecorder<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n-    fn record_exports_for_module_subtree(&mut self,\n-                                         module_: Rc<Module>) {\n+    fn record_exports_for_module_subtree(&mut self, module_: Rc<Module>) {\n         // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n         match module_.def_id.get() {\n             Some(def_id) if def_id.is_local() => {\n                 // OK. Continue.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module `{}`\",\n+                debug!(\"(recording exports for module subtree) recording exports for local \\\n+                        module `{}`\",\n                        module_to_string(&*module_));\n             }\n             None => {\n                 // Record exports for the root module.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module `{}`\",\n+                debug!(\"(recording exports for module subtree) recording exports for root module \\\n+                        `{}`\",\n                        module_to_string(&*module_));\n             }\n             Some(_) => {\n                 // Bail out.\n-                debug!(\"(recording exports for module subtree) not recording \\\n-                        exports for `{}`\",\n+                debug!(\"(recording exports for module subtree) not recording exports for `{}`\",\n                        module_to_string(&*module_));\n                 return;\n             }\n@@ -118,10 +116,11 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       name, d.def_id());\n+                       name,\n+                       d.def_id());\n                 exports.push(Export {\n                     name: name,\n-                    def_id: d.def_id()\n+                    def_id: d.def_id(),\n                 });\n             }\n             d_opt => {\n@@ -130,25 +129,19 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn add_exports_for_module(&mut self,\n-                              exports: &mut Vec<Export>,\n-                              module_: &Module) {\n+    fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: &Module) {\n         for (name, import_resolution) in module_.import_resolutions.borrow().iter() {\n             if !import_resolution.is_public {\n-                continue\n+                continue;\n             }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n                 match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n-                        debug!(\"(computing exports) maybe export '{}'\",\n-                               name);\n-                        self.add_exports_of_namebindings(exports,\n-                                                         *name,\n-                                                         &*target.bindings,\n-                                                         ns)\n+                        debug!(\"(computing exports) maybe export '{}'\", name);\n+                        self.add_exports_of_namebindings(exports, *name, &*target.bindings, ns)\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "9a21ec86685c169dc1cec8e0a0050e272b5b8624", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 173, "deletions": 179, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=889b0e9ace0aa6c4279ab6cf4f0553dd54f54ce7", "patch": "@@ -42,14 +42,14 @@ use std::rc::Rc;\n #[derive(Copy, Clone,Debug)]\n pub enum ImportDirectiveSubclass {\n     SingleImport(Name /* target */, Name /* source */),\n-    GlobImport\n+    GlobImport,\n }\n \n /// Whether an import can be shadowed by another import.\n #[derive(Debug,PartialEq,Clone,Copy)]\n pub enum Shadowable {\n     Always,\n-    Never\n+    Never,\n }\n \n /// One import directive.\n@@ -64,13 +64,13 @@ pub struct ImportDirective {\n }\n \n impl ImportDirective {\n-    pub fn new(module_path: Vec<Name> ,\n-           subclass: ImportDirectiveSubclass,\n-           span: Span,\n-           id: NodeId,\n-           is_public: bool,\n-           shadowable: Shadowable)\n-           -> ImportDirective {\n+    pub fn new(module_path: Vec<Name>,\n+               subclass: ImportDirectiveSubclass,\n+               span: Span,\n+               id: NodeId,\n+               is_public: bool,\n+               shadowable: Shadowable)\n+               -> ImportDirective {\n         ImportDirective {\n             module_path: module_path,\n             subclass: subclass,\n@@ -92,9 +92,9 @@ pub struct Target {\n \n impl Target {\n     pub fn new(target_module: Rc<Module>,\n-           bindings: Rc<NameBindings>,\n-           shadowable: Shadowable)\n-           -> Target {\n+               bindings: Rc<NameBindings>,\n+               shadowable: Shadowable)\n+               -> Target {\n         Target {\n             target_module: target_module,\n             bindings: bindings,\n@@ -144,17 +144,16 @@ impl ImportResolution {\n         }\n     }\n \n-    pub fn target_for_namespace(&self, namespace: Namespace)\n-                                -> Option<Target> {\n+    pub fn target_for_namespace(&self, namespace: Namespace) -> Option<Target> {\n         match namespace {\n-            TypeNS  => self.type_target.clone(),\n+            TypeNS => self.type_target.clone(),\n             ValueNS => self.value_target.clone(),\n         }\n     }\n \n     pub fn id(&self, namespace: Namespace) -> NodeId {\n         match namespace {\n-            TypeNS  => self.type_id,\n+            TypeNS => self.type_id,\n             ValueNS => self.value_id,\n         }\n     }\n@@ -168,12 +167,9 @@ impl ImportResolution {\n         target.unwrap().shadowable\n     }\n \n-    pub fn set_target_and_id(&mut self,\n-                         namespace: Namespace,\n-                         target: Option<Target>,\n-                         id: NodeId) {\n+    pub fn set_target_and_id(&mut self, namespace: Namespace, target: Option<Target>, id: NodeId) {\n         match namespace {\n-            TypeNS  => {\n+            TypeNS => {\n                 self.type_target = target;\n                 self.type_id = id;\n             }\n@@ -191,8 +187,8 @@ struct ImportResolvingError {\n     help: String,\n }\n \n-struct ImportResolver<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>\n+struct ImportResolver<'a, 'b: 'a, 'tcx: 'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n }\n \n impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n@@ -211,7 +207,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut prev_unresolved_imports = 0;\n         loop {\n             debug!(\"(resolving imports) iteration {}, {} imports left\",\n-                   i, self.resolver.unresolved_imports);\n+                   i,\n+                   self.resolver.unresolved_imports);\n \n             let module_root = self.resolver.graph_root.get_module();\n             let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n@@ -246,7 +243,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>)\n+    fn resolve_imports_for_module_subtree(&mut self,\n+                                          module_: Rc<Module>)\n                                           -> Vec<ImportResolvingError> {\n         let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n@@ -279,8 +277,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut errors = Vec::new();\n \n         if module.all_imports_resolved() {\n-            debug!(\"(resolving imports for module) all imports resolved for \\\n-                   {}\",\n+            debug!(\"(resolving imports for module) all imports resolved for {}\",\n                    module_to_string(&*module));\n             return errors;\n         }\n@@ -290,22 +287,19 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut indeterminate_imports = Vec::new();\n         while module.resolved_import_count.get() + indeterminate_imports.len() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            match self.resolve_import_for_module(module.clone(),\n-                                                 &imports[import_index]) {\n+            match self.resolve_import_for_module(module.clone(), &imports[import_index]) {\n                 ResolveResult::Failed(err) => {\n                     let import_directive = &imports[import_index];\n                     let (span, help) = match err {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                        None => (import_directive.span, String::new())\n+                        None => (import_directive.span, String::new()),\n                     };\n                     errors.push(ImportResolvingError {\n-                                    span: span,\n-                                    path: import_path_to_string(\n-                                            &import_directive.module_path,\n-                                            import_directive.subclass\n-                                         ),\n-                                    help: help\n-                                });\n+                        span: span,\n+                        path: import_path_to_string(&import_directive.module_path,\n+                                                    import_directive.subclass),\n+                        help: help,\n+                    });\n                 }\n                 ResolveResult::Indeterminate => {}\n                 ResolveResult::Success(()) => {\n@@ -354,7 +348,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 ResolveResult::Failed(err) => {\n                     resolution_result = ResolveResult::Failed(err);\n                     None\n-                },\n+                }\n                 ResolveResult::Indeterminate => {\n                     resolution_result = ResolveResult::Indeterminate;\n                     None\n@@ -371,20 +365,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n                 match import_directive.subclass {\n                     SingleImport(target, source) => {\n-                        resolution_result =\n-                            self.resolve_single_import(&module_,\n-                                                       containing_module,\n-                                                       target,\n-                                                       source,\n-                                                       import_directive,\n-                                                       lp);\n+                        resolution_result = self.resolve_single_import(&module_,\n+                                                                       containing_module,\n+                                                                       target,\n+                                                                       source,\n+                                                                       import_directive,\n+                                                                       lp);\n                     }\n                     GlobImport => {\n-                        resolution_result =\n-                            self.resolve_glob_import(&module_,\n-                                                     containing_module,\n-                                                     import_directive,\n-                                                     lp);\n+                        resolution_result = self.resolve_glob_import(&module_,\n+                                                                     containing_module,\n+                                                                     import_directive,\n+                                                                     lp);\n                     }\n                 }\n             }\n@@ -433,8 +425,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              directive: &ImportDirective,\n                              lp: LastPrivate)\n                              -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {:?}\",\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}, last \\\n+                private {:?}\",\n                target,\n                module_to_string(&*target_module),\n                source,\n@@ -445,9 +437,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let lp = match lp {\n             LastMod(lp) => lp,\n             LastImport {..} => {\n-                self.resolver.session\n-                    .span_bug(directive.span,\n-                              \"not expecting Import here, must be LastMod\")\n+                self.resolver\n+                    .session\n+                    .span_bug(directive.span, \"not expecting Import here, must be LastMod\")\n             }\n         };\n \n@@ -472,11 +464,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     value_result = BoundResult(target_module.clone(),\n                                                (*child_name_bindings).clone());\n                     if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\",\n-                                          source);\n-                        let note_msg =\n-                            format!(\"Consider marking `{}` as `pub` in the imported module\",\n-                                    source);\n+                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                        let note_msg = format!(\"Consider marking `{}` as `pub` in the imported \\\n+                                                module\",\n+                                               source);\n                         span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n                         self.resolver.session.span_note(directive.span, &note_msg);\n                         pub_err = true;\n@@ -487,8 +478,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     type_result = BoundResult(target_module.clone(),\n                                               (*child_name_bindings).clone());\n                     if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\",\n-                                          source);\n+                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n                                                source);\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n@@ -510,8 +500,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 // able to resolve this import.\n \n                 if target_module.pub_glob_count.get() > 0 {\n-                    debug!(\"(resolving single import) unresolved pub glob; \\\n-                            bailing out\");\n+                    debug!(\"(resolving single import) unresolved pub glob; bailing out\");\n                     return ResolveResult::Indeterminate;\n                 }\n \n@@ -531,14 +520,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             type_result = UnboundResult;\n                         }\n                     }\n-                    Some(import_resolution)\n-                            if import_resolution.outstanding_references == 0 => {\n+                    Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n \n                         fn get_binding(this: &mut Resolver,\n                                        import_resolution: &ImportResolution,\n                                        namespace: Namespace,\n                                        source: Name)\n-                                    -> NamespaceResult {\n+                                       -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n@@ -555,16 +543,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     bindings,\n                                     shadowable: _\n                                 }) => {\n-                                    debug!(\"(resolving single import) found \\\n-                                            import in ns {:?}\", namespace);\n+                                    debug!(\"(resolving single import) found import in ns {:?}\",\n+                                           namespace);\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n                                     this.record_import_use(id, source);\n                                     match target_module.def_id.get() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n-                                        },\n+                                        }\n                                         _ => {}\n                                     }\n                                     return BoundResult(target_module, bindings);\n@@ -603,19 +591,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         // In this case we continue as if we resolved the import and let the\n                         // check_for_conflicts_between_imports_and_items call below handle\n                         // the conflict\n-                        match (module_.def_id.get(),  target_module.def_id.get()) {\n-                            (Some(id1), Some(id2)) if id1 == id2  => {\n+                        match (module_.def_id.get(), target_module.def_id.get()) {\n+                            (Some(id1), Some(id2)) if id1 == id2 => {\n                                 if value_result.is_unknown() {\n                                     value_result = UnboundResult;\n                                 }\n                                 if type_result.is_unknown() {\n                                     type_result = UnboundResult;\n                                 }\n                             }\n-                            _ =>  {\n+                            _ => {\n                                 // The import is unresolved. Bail out.\n-                                debug!(\"(resolving single import) unresolved import; \\\n-                                        bailing out\");\n+                                debug!(\"(resolving single import) unresolved import; bailing out\");\n                                 return ResolveResult::Indeterminate;\n                             }\n                         }\n@@ -668,17 +655,15 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_bindings.def_for_namespace(namespace));\n-                        self.check_for_conflicting_import(\n-                            &import_resolution,\n-                            directive.span,\n-                            target,\n-                            namespace);\n-\n-                        self.check_that_import_is_importable(\n-                            &**name_bindings,\n-                            directive.span,\n-                            target,\n-                            namespace);\n+                        self.check_for_conflicting_import(&import_resolution,\n+                                                          directive.span,\n+                                                          target,\n+                                                          namespace);\n+\n+                        self.check_that_import_is_importable(&**name_bindings,\n+                                                             directive.span,\n+                                                             target,\n+                                                             namespace);\n \n                         let target = Some(Target::new(target_module.clone(),\n                                                       name_bindings.clone(),\n@@ -687,7 +672,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         import_resolution.is_public = directive.is_public;\n                         *used_public = name_bindings.defined_in_public_namespace(namespace);\n                     }\n-                    UnboundResult => { /* Continue. */ }\n+                    UnboundResult => {\n+                        // Continue.\n+                    }\n                     UnknownResult => {\n                         panic!(\"{:?} result should be known at this point\", namespace_name);\n                     }\n@@ -697,11 +684,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n         }\n \n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            import_resolution,\n-            directive.span,\n-            target);\n+        self.check_for_conflicts_between_imports_and_items(module_,\n+                                                           import_resolution,\n+                                                           directive.span,\n+                                                           target);\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n@@ -720,33 +706,45 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // purposes it's good enough to just favor one over the other.\n         let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n             let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n-            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n+            (def,\n+             if value_used_public {\n+                lp\n+            } else {\n+                DependsOn(def.def_id())\n+            })\n         });\n         let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n             let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n-            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n+            (def,\n+             if type_used_public {\n+                lp\n+            } else {\n+                DependsOn(def.def_id())\n+            })\n         });\n \n         let import_lp = LastImport {\n             value_priv: value_def_and_priv.map(|(_, p)| p),\n             value_used: Used,\n             type_priv: type_def_and_priv.map(|(_, p)| p),\n-            type_used: Used\n+            type_used: Used,\n         };\n \n         if let Some((def, _)) = value_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n+            self.resolver.def_map.borrow_mut().insert(directive.id,\n+                                                      PathResolution {\n+                                                          base_def: def,\n+                                                          last_private: import_lp,\n+                                                          depth: 0,\n+                                                      });\n         }\n         if let Some((def, _)) = type_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n+            self.resolver.def_map.borrow_mut().insert(directive.id,\n+                                                      PathResolution {\n+                                                          base_def: def,\n+                                                          last_private: import_lp,\n+                                                          depth: 0,\n+                                                      });\n         }\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -774,8 +772,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n         if (*target_module).pub_count.get() > 0 {\n-            debug!(\"(resolving glob import) target module has unresolved \\\n-                    pub imports; bailing out\");\n+            debug!(\"(resolving glob import) target module has unresolved pub imports; bailing out\");\n             return ResolveResult::Indeterminate;\n         }\n \n@@ -787,21 +784,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // This means we are trying to glob import a module into itself,\n             // and it is a no-go\n             debug!(\"(resolving glob imports) target module is current module; giving up\");\n-            return ResolveResult::Failed(Some((\n-                        import_directive.span,\n-                        \"Cannot glob-import a module into itself.\".into()\n-                    )));\n+            return ResolveResult::Failed(Some((import_directive.span,\n+                                               \"Cannot glob-import a module into itself.\".into())));\n         }\n \n         for (name, target_import_resolution) in import_resolutions.iter() {\n-            debug!(\"(resolving glob import) writing module resolution \\\n-                    {} into `{}`\",\n+            debug!(\"(resolving glob import) writing module resolution {} into `{}`\",\n                    *name,\n                    module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n                 debug!(\"(resolving glob import) nevermind, just kidding\");\n-                continue\n+                continue;\n             }\n \n             // Here we merge two import resolutions.\n@@ -843,10 +837,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             // Simple: just copy the old import resolution.\n             let mut new_import_resolution = ImportResolution::new(id, is_public);\n-            new_import_resolution.value_target =\n-                target_import_resolution.value_target.clone();\n-            new_import_resolution.type_target =\n-                target_import_resolution.type_target.clone();\n+            new_import_resolution.value_target = target_import_resolution.value_target.clone();\n+            new_import_resolution.type_target = target_import_resolution.type_target.clone();\n \n             import_resolutions.insert(*name, new_import_resolution);\n         }\n@@ -865,8 +857,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // Add external module children from the containing module.\n         for (&name, module) in target_module.external_module_children.borrow().iter() {\n-            let name_bindings =\n-                Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n+            let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n                                          target_module.clone(),\n                                          import_directive,\n@@ -876,11 +867,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id.get() {\n-            self.resolver.def_map.borrow_mut().insert(id, PathResolution {\n-                base_def: DefMod(did),\n-                last_private: lp,\n-                depth: 0\n-            });\n+            self.resolver.def_map.borrow_mut().insert(id,\n+                                                      PathResolution {\n+                                                          base_def: DefMod(did),\n+                                                          last_private: lp,\n+                                                          depth: 0,\n+                                                      });\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -898,10 +890,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let dest_import_resolution = import_resolutions.entry(name)\n-            .or_insert_with(|| ImportResolution::new(id, is_public));\n+                                                       .or_insert_with(|| {\n+                                                           ImportResolution::new(id, is_public)\n+                                                       });\n \n-        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n-               to `{}`\",\n+        debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n                name,\n                module_to_string(&*containing_module),\n                module_to_string(module_));\n@@ -918,18 +911,20 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     };\n                     debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n                     if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n-                        let msg = format!(\"a {} named `{}` has already been imported \\\n-                                           in this module\",\n+                        let msg = format!(\"a {} named `{}` has already been imported in this \\\n+                                           module\",\n                                           namespace_name,\n                                           name);\n-                        span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n+                        span_err!(self.resolver.session,\n+                                  import_directive.span,\n+                                  E0251,\n+                                  \"{}\",\n+                                  msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n                                                  name_bindings.clone(),\n                                                  import_directive.shadowable);\n-                        dest_import_resolution.set_target_and_id(namespace,\n-                                                                 Some(target),\n-                                                                 id);\n+                        dest_import_resolution.set_target_and_id(namespace, Some(target), id);\n                     }\n                 }\n             };\n@@ -939,11 +934,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         dest_import_resolution.is_public = is_public;\n \n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            dest_import_resolution,\n-            import_directive.span,\n-            name);\n+        self.check_for_conflicts_between_imports_and_items(module_,\n+                                                           dest_import_resolution,\n+                                                           import_directive.span,\n+                                                           name);\n     }\n \n     /// Checks that imported names and items don't have the same name.\n@@ -963,28 +957,31 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     TypeNS => {\n                         if let Some(ref ty_def) = *target.bindings.type_def.borrow() {\n                             match ty_def.module_def {\n-                                Some(ref module)\n-                                    if module.kind.get() == ModuleKind::NormalModuleKind =>\n-                                        \"module\",\n-                                Some(ref module)\n-                                    if module.kind.get() == ModuleKind::TraitModuleKind =>\n-                                        \"trait\",\n+                                Some(ref module) if module.kind.get() ==\n+                                                    ModuleKind::NormalModuleKind => \"module\",\n+                                Some(ref module) if module.kind.get() ==\n+                                                    ModuleKind::TraitModuleKind => \"trait\",\n                                 _ => \"type\",\n                             }\n-                        } else { \"type\" }\n-                    },\n+                        } else {\n+                            \"type\"\n+                        }\n+                    }\n                     ValueNS => \"value\",\n                 };\n-                span_err!(self.resolver.session, import_span, E0252,\n-                          \"a {} named `{}` has already been imported \\\n-                           in this module\", ns_word,\n-                                  name);\n+                span_err!(self.resolver.session,\n+                          import_span,\n+                          E0252,\n+                          \"a {} named `{}` has already been imported in this module\",\n+                          ns_word,\n+                          name);\n                 let use_id = import_resolution.id(namespace);\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n-                span_note!(self.resolver.session, item.span,\n-                            \"previous import of `{}` here\",\n-                            name);\n+                span_note!(self.resolver.session,\n+                           item.span,\n+                           \"previous import of `{}` here\",\n+                           name);\n             }\n             Some(_) | None => {}\n         }\n@@ -997,17 +994,15 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        name: Name,\n                                        namespace: Namespace) {\n         if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n-            let msg = format!(\"`{}` is not directly importable\",\n-                              name);\n+            let msg = format!(\"`{}` is not directly importable\", name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: &Module,\n-                                                     import_resolution:\n-                                                     &ImportResolution,\n+                                                     import_resolution: &ImportResolution,\n                                                      import_span: Span,\n                                                      name: Name) {\n         // First, check for conflicts between imports and `extern crate`s.\n@@ -1016,8 +1011,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                  .contains_key(&name) {\n             match import_resolution.type_target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    let msg = format!(\"import `{0}` conflicts with imported \\\n-                                       crate in this module \\\n+                    let msg = format!(\"import `{0}` conflicts with imported crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       name);\n                     span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n@@ -1031,15 +1025,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let name_bindings = match children.get(&name) {\n             None => {\n                 // There can't be any conflicts.\n-                return\n+                return;\n             }\n             Some(ref name_bindings) => (*name_bindings).clone(),\n         };\n \n         match import_resolution.value_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n-                    span_err!(self.resolver.session, import_span, E0255,\n+                    span_err!(self.resolver.session,\n+                              import_span,\n+                              E0255,\n                               \"import `{}` conflicts with value in this module\",\n                               name);\n                     if let Some(span) = value.value_span {\n@@ -1054,17 +1050,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_def.borrow() {\n                     let (what, note) = match ty.module_def {\n-                        Some(ref module)\n-                            if module.kind.get() == ModuleKind::NormalModuleKind =>\n-                                (\"existing submodule\", \"note conflicting module here\"),\n-                        Some(ref module)\n-                            if module.kind.get() == ModuleKind::TraitModuleKind =>\n-                                (\"trait in this module\", \"note conflicting trait here\"),\n-                        _    => (\"type in this module\", \"note conflicting type here\"),\n+                        Some(ref module) if module.kind.get() == ModuleKind::NormalModuleKind =>\n+                            (\"existing submodule\", \"note conflicting module here\"),\n+                        Some(ref module) if module.kind.get() == ModuleKind::TraitModuleKind =>\n+                            (\"trait in this module\", \"note conflicting trait here\"),\n+                        _ => (\"type in this module\", \"note conflicting type here\"),\n                     };\n-                    span_err!(self.resolver.session, import_span, E0256,\n+                    span_err!(self.resolver.session,\n+                              import_span,\n+                              E0256,\n                               \"import `{}` conflicts with {}\",\n-                              name, what);\n+                              name,\n+                              what);\n                     if let Some(span) = ty.type_span {\n                         self.resolver.session.span_note(span, note);\n                     }\n@@ -1075,28 +1072,25 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n }\n \n-fn import_path_to_string(names: &[Name],\n-                         subclass: ImportDirectiveSubclass)\n-                         -> String {\n+fn import_path_to_string(names: &[Name], subclass: ImportDirectiveSubclass) -> String {\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {\n         (format!(\"{}::{}\",\n                  names_to_string(names),\n-                 import_directive_subclass_to_string(subclass))).to_string()\n+                 import_directive_subclass_to_string(subclass)))\n+            .to_string()\n     }\n }\n \n fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n     match subclass {\n         SingleImport(_, source) => source.to_string(),\n-        GlobImport => \"*\".to_string()\n+        GlobImport => \"*\".to_string(),\n     }\n }\n \n pub fn resolve_imports(resolver: &mut Resolver) {\n-    let mut import_resolver = ImportResolver {\n-        resolver: resolver,\n-    };\n+    let mut import_resolver = ImportResolver { resolver: resolver };\n     import_resolver.resolve_imports();\n }"}]}