{"sha": "f2f5452089a6cf8eb611badf20118960030f6585", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZjU0NTIwODlhNmNmOGViNjExYmFkZjIwMTE4OTYwMDMwZjY1ODU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-09T13:36:25Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-18T17:14:21Z"}, "message": "Use real atomic instructions instead of a global lock", "tree": {"sha": "7657c36db95950734ffbeb113afc3fa14408d31d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7657c36db95950734ffbeb113afc3fa14408d31d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f5452089a6cf8eb611badf20118960030f6585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f5452089a6cf8eb611badf20118960030f6585", "html_url": "https://github.com/rust-lang/rust/commit/f2f5452089a6cf8eb611badf20118960030f6585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f5452089a6cf8eb611badf20118960030f6585/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92f765fce96b6344ccfe9b288bbd8b652f5ad0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f765fce96b6344ccfe9b288bbd8b652f5ad0ef", "html_url": "https://github.com/rust-lang/rust/commit/92f765fce96b6344ccfe9b288bbd8b652f5ad0ef"}], "stats": {"total": 540, "additions": 129, "deletions": 411}, "files": [{"sha": "c2ed2bf256d5980a188421ba69b229777e2c8d16", "filename": "scripts/config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/scripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/scripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fconfig.sh?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -26,7 +26,7 @@ export RUSTC=$dir\"/bin/cg_clif\"\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n-# FIXME remove once the atomic shim is gone\n+# FIXME fix `#[linkage = \"extern_weak\"]` without this\n if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi"}, {"sha": "674e6d907510a8510607cea2c747a66d17238c74", "filename": "src/atomic_shim.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/92f765fce96b6344ccfe9b288bbd8b652f5ad0ef/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f765fce96b6344ccfe9b288bbd8b652f5ad0ef/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=92f765fce96b6344ccfe9b288bbd8b652f5ad0ef", "patch": "@@ -1,185 +0,0 @@\n-//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n-//! atomic operations yet.\n-\n-// FIXME implement atomic instructions in Cranelift.\n-\n-use crate::prelude::*;\n-\n-#[cfg(all(feature = \"jit\", unix))]\n-#[no_mangle]\n-static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n-\n-pub(crate) fn init_global_lock(\n-    module: &mut impl Module,\n-    bcx: &mut FunctionBuilder<'_>,\n-    use_jit: bool,\n-) {\n-    if use_jit {\n-        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n-        // so instead we define it in the cg_clif dylib.\n-\n-        return;\n-    }\n-\n-    let mut data_ctx = DataContext::new();\n-    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    data_ctx.set_align(16);\n-    let atomic_mutex = module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Export,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-    module.define_data(atomic_mutex, &data_ctx).unwrap();\n-\n-    let pthread_mutex_init = module\n-        .declare_function(\n-            \"pthread_mutex_init\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: module.target_config().default_call_conv,\n-                params: vec![\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                    ),\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n-                    ),\n-                ],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n-\n-    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx\n-        .ins()\n-        .global_value(module.target_config().pointer_type(), atomic_mutex);\n-\n-    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n-\n-    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n-}\n-\n-pub(crate) fn init_global_lock_constructor(\n-    module: &mut impl Module,\n-    constructor_name: &str,\n-) -> FuncId {\n-    let sig = Signature::new(CallConv::SystemV);\n-    let init_func_id = module\n-        .declare_function(constructor_name, Linkage::Export, &sig)\n-        .unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-\n-        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n-\n-        bcx.ins().return_(&[]);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module\n-        .define_function(\n-            init_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n-\n-    init_func_id\n-}\n-\n-pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_lock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n-}\n-\n-pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_unlock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n-}"}, {"sha": "a5718244816d229f2d3dc6bddeba7ceb78c2bc31", "filename": "src/backend.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbackend.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -8,7 +8,7 @@ use rustc_session::Session;\n use cranelift_module::FuncId;\n \n use object::write::*;\n-use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n@@ -118,49 +118,6 @@ impl WriteDebugInfo for ObjectProduct {\n     }\n }\n \n-// FIXME remove once atomic instructions are implemented in Cranelift.\n-pub(crate) trait AddConstructor {\n-    fn add_constructor(&mut self, func_id: FuncId);\n-}\n-\n-impl AddConstructor for ObjectProduct {\n-    fn add_constructor(&mut self, func_id: FuncId) {\n-        let symbol = self.function_symbol(func_id);\n-        let segment = self\n-            .object\n-            .segment_name(object::write::StandardSegment::Data);\n-        let init_array_section =\n-            self.object\n-                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n-        let address_size = self\n-            .object\n-            .architecture()\n-            .address_size()\n-            .expect(\"address_size must be known\")\n-            .bytes();\n-        self.object.append_section_data(\n-            init_array_section,\n-            &std::iter::repeat(0)\n-                .take(address_size.into())\n-                .collect::<Vec<u8>>(),\n-            8,\n-        );\n-        self.object\n-            .add_relocation(\n-                init_array_section,\n-                object::write::Relocation {\n-                    offset: 0,\n-                    size: address_size * 8,\n-                    kind: RelocationKind::Absolute,\n-                    encoding: RelocationEncoding::Generic,\n-                    symbol,\n-                    addend: 0,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n     let triple = crate::build_isa(sess).triple().clone();\n "}, {"sha": "8085a04184b2bc6217ef61904efbd90979047cd0", "filename": "src/driver/aot.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -12,12 +12,10 @@ use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n-use cranelift_object::{ObjectModule, ObjectProduct};\n+use cranelift_object::ObjectModule;\n \n use crate::{prelude::*, BackendConfig};\n \n-use crate::backend::AddConstructor;\n-\n fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n     let module = crate::backend::make_module(tcx.sess, name);\n     assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n@@ -39,7 +37,6 @@ fn emit_module(\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext<'_>,\n-    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -49,8 +46,6 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let product = map_product(product);\n-\n     let tmp_file = tcx\n         .output_filenames(LOCAL_CRATE)\n         .temp_path(OutputType::Object, Some(&name));\n@@ -124,30 +119,7 @@ fn module_codegen(\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n-\n-    // Initialize the global atomic mutex using a constructor for proc-macros.\n-    // FIXME implement atomic instructions in Cranelift.\n-    let mut init_atomics_mutex_from_constructor = None;\n-    if tcx\n-        .sess\n-        .crate_types()\n-        .contains(&rustc_session::config::CrateType::ProcMacro)\n-    {\n-        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n-            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n-                .symbol_name(Instance::mono(tcx, *def_id))\n-                .name\n-                .contains(\"__rustc_proc_macro_decls_\"),\n-            _ => false,\n-        }) {\n-            init_atomics_mutex_from_constructor =\n-                Some(crate::atomic_shim::init_global_lock_constructor(\n-                    &mut module,\n-                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n-                ));\n-        }\n-    }\n+    let module = new_module(tcx, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n@@ -180,7 +152,7 @@ fn module_codegen(\n     }\n     let (mut module, global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n@@ -189,13 +161,6 @@ fn module_codegen(\n         module,\n         debug,\n         unwind_context,\n-        |mut product| {\n-            if let Some(func_id) = init_atomics_mutex_from_constructor {\n-                product.add_constructor(func_id);\n-            }\n-\n-            product\n-        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -275,7 +240,6 @@ pub(super) fn run_aot(\n             allocator_module,\n             None,\n             allocator_unwind_context,\n-            |product| product,\n         );\n         if let Some((id, product)) = work_product {\n             work_products.insert(id, product);"}, {"sha": "4abfcfcd7b19e9ddd75094856fb5bd35eb00ea0a", "filename": "src/driver/jit.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -23,24 +23,6 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n \n-    #[cfg(unix)]\n-    unsafe {\n-        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n-        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n-        // as global.\n-        // FIXME remove once atomic_shim is gone\n-\n-        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n-        assert_ne!(\n-            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n-            0\n-        );\n-        assert_ne!(\n-            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n-            std::ptr::null_mut(),\n-        );\n-    }\n-\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n     let mut jit_builder = JITBuilder::with_isa(\n@@ -111,7 +93,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();"}, {"sha": "4aed09d2b143b865e54860f302c3f70ed8b42615", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 123, "deletions": 115, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -9,6 +9,7 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;\n+use cranelift_codegen::ir::AtomicRmwOp;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n@@ -112,38 +113,6 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-    let new = $fx.bcx.ins().$op(old, $src);\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n-macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    // Read old\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-\n-    // Compare\n-    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-    let new = $fx.bcx.ins().select(is_eq, old, $src);\n-\n-    // Write new\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-\n-    let ret_val = CValue::by_val(old, $ret.layout());\n-    $ret.write_cvalue($fx, ret_val);\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n@@ -912,136 +881,175 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         _ if intrinsic.starts_with(\"atomic_fence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().fence();\n         };\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            // FIXME use a compiler fence once Cranelift supports it\n+            fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+            let ty = fx.clif_type(T).unwrap();\n \n-            let inner_layout =\n-                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n-            ret.write_cvalue(fx, val);\n+            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let val = CValue::by_val(val, fx.layout_of(T));\n+            ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n-            dest.write_cvalue(fx, val);\n+            let val = val.load_scalar(fx);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let new = new.load_scalar(fx);\n \n-            // Write new\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n-            dest.write_cvalue(fx, src);\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xchg, ptr, new);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-\n-            // Compare\n+            let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n-            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n-\n-            // Write new\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n-            ret.write_cvalue(fx, ret_val);\n-\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Add, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Sub, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::And, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let and = fx.bcx.ins().band(old, src);\n-            let new = fx.bcx.ins().bnot(and);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Or, ptr, src);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xor, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+\n+        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n+        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Nand, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n+        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n \n         minnumf32, (v a, v b) {"}, {"sha": "417934f760326c646469cc459ade6ab362f85880", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -12,8 +12,6 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-#[cfg(feature = \"jit\")]\n-extern crate libc;\n extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n@@ -54,7 +52,6 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod atomic_shim;\n mod backend;\n mod base;\n mod cast;"}, {"sha": "4ea9b9f99530387dc788ef9210f116d3d415d116", "filename": "src/main_shim.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f5452089a6cf8eb611badf20118960030f6585/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=f2f5452089a6cf8eb611badf20118960030f6585", "patch": "@@ -9,7 +9,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext<'_>,\n-    use_jit: bool,\n ) {\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n@@ -33,7 +32,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n         unwind_context,\n         main_def_id,\n         use_start_lang_item,\n-        use_jit,\n     );\n \n     fn create_entry_fn(\n@@ -42,7 +40,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n         unwind_context: &mut UnwindContext<'_>,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-        use_jit: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -86,8 +83,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n \n-            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n-\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {"}]}