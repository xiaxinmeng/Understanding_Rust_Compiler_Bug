{"sha": "fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYWRiYTU3ODY1NWVkMzVmOTkzOTViNjZjZDM2ZDhmNmQ2ZmRhZjM=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-14T10:11:40Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-14T10:11:40Z"}, "message": "Store TokenTree in MacroRulesMacroExpander", "tree": {"sha": "9ba88eb62d1df2e67c3e588f3bb29ad38136fa97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ba88eb62d1df2e67c3e588f3bb29ad38136fa97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "html_url": "https://github.com/rust-lang/rust/commit/fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdadba578655ed35f99395b66cd36d8f6d6fdaf3/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82251354ff30e9a6f9f98d8dbef9fe54df400285", "url": "https://api.github.com/repos/rust-lang/rust/commits/82251354ff30e9a6f9f98d8dbef9fe54df400285", "html_url": "https://github.com/rust-lang/rust/commit/82251354ff30e9a6f9f98d8dbef9fe54df400285"}], "stats": {"total": 51, "additions": 23, "deletions": 28}, "files": [{"sha": "898d4d80b997a937cd31b4d62c7b060f5d471560", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fdadba578655ed35f99395b66cd36d8f6d6fdaf3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdadba578655ed35f99395b66cd36d8f6d6fdaf3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=fdadba578655ed35f99395b66cd36d8f6d6fdaf3", "patch": "@@ -13,7 +13,7 @@ use codemap::{Span, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n-use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::parse;\n use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n@@ -129,15 +129,15 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     imported_from: Option<ast::Ident>,\n-    lhses: Vec<Rc<NamedMatch>>,\n-    rhses: Vec<Rc<NamedMatch>>,\n+    lhses: Vec<TokenTree>,\n+    rhses: Vec<TokenTree>,\n }\n \n impl TTMacroExpander for MacroRulesMacroExpander {\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n-                   arg: &[ast::TokenTree])\n+                   arg: &[TokenTree])\n                    -> Box<MacResult+'cx> {\n         generic_extension(cx,\n                           sp,\n@@ -154,9 +154,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: ast::Ident,\n                           imported_from: Option<ast::Ident>,\n-                          arg: &[ast::TokenTree],\n-                          lhses: &[Rc<NamedMatch>],\n-                          rhses: &[Rc<NamedMatch>])\n+                          arg: &[TokenTree],\n+                          lhses: &[TokenTree],\n+                          rhses: &[TokenTree])\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n         println!(\"{}! {{ {} }}\",\n@@ -169,25 +169,17 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     let mut best_fail_msg = \"internal error: ran no matchers\".to_string();\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-        match **lhs {\n-          MatchedNonterminal(NtTT(ref lhs_tt)) => {\n-            let lhs_tt = match **lhs_tt {\n+            let lhs_tt = match *lhs {\n                 TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => panic!(cx.span_fatal(sp, \"malformed macro lhs\"))\n             };\n \n             match TokenTree::parse(cx, lhs_tt, arg) {\n               Success(named_matches) => {\n-                let rhs = match *rhses[i] {\n-                    // okay, what's your transcriber?\n-                    MatchedNonterminal(NtTT(ref tt)) => {\n-                        match **tt {\n+                let rhs = match rhses[i] {\n                             // ignore delimiters\n                             TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n                             _ => panic!(cx.span_fatal(sp, \"macro rhs must be delimited\")),\n-                        }\n-                    },\n-                    _ => cx.span_bug(sp, \"bad thing in rhs\")\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n@@ -216,9 +208,6 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 panic!(cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]))\n               }\n             }\n-          }\n-          _ => cx.bug(\"non-matcher found in parsed lhses\")\n-        }\n     }\n \n     panic!(cx.span_fatal(best_fail_spot.substitute_dummy(sp), &best_fail_msg[..]));\n@@ -284,7 +273,12 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n \n     // Extract the arguments:\n     let lhses = match **argument_map.get(&lhs_nm.name).unwrap() {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n+        MatchedSeq(ref s, _) => {\n+            s.iter().map(|m| match **m {\n+                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n+                _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n+            }).collect()\n+        }\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n@@ -293,7 +287,12 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     }\n \n     let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {\n-        MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n+        MatchedSeq(ref s, _) => {\n+            s.iter().map(|m| match **m {\n+                MatchedNonterminal(NtTT(ref tt)) => (**tt).clone(),\n+                _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n+            }).collect()\n+        }\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n@@ -307,11 +306,10 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }\n \n-fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &NamedMatch, sp: Span) {\n-    // lhs is going to be like MatchedNonterminal(NtTT(TokenTree::Delimited(...))), where the\n+fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree, sp: Span) {\n+    // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n-        &MatchedNonterminal(NtTT(ref inner)) => match &**inner {\n             &TokenTree::Delimited(_, ref tts) => {\n                 check_matcher(cx, tts.tts.iter(), &Eof);\n             },\n@@ -320,9 +318,6 @@ fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &NamedMatch, sp: Span) {\n             },\n             _ => cx.span_err(sp, \"Invalid macro matcher; matchers must be contained \\\n                in balanced delimiters or a repetition indicator\")\n-        },\n-        _ => cx.span_bug(sp, \"wrong-structured lhs for follow check (didn't find a \\\n-           MatchedNonterminal)\")\n     };\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way."}]}