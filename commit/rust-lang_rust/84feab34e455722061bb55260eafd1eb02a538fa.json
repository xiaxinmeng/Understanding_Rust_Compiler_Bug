{"sha": "84feab34e455722061bb55260eafd1eb02a538fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZmVhYjM0ZTQ1NTcyMjA2MWJiNTUyNjBlYWZkMWViMDJhNTM4ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-15T05:40:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-15T05:40:12Z"}, "message": "Auto merge of #46537 - pnkfelix:two-phase-borrows, r=arielb1\n\n[MIR-borrowck] Two phase borrows\n\nThis adds limited support for two-phase borrows as described in\n  http://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n\nThe support is off by default; you opt into it via the flag `-Z two-phase-borrows`\n\nI have written \"*limited* support\" above because there are simple variants of the simple `v.push(v.len())` example that one would think should work but currently do not, such as the one documented in the test compile-fail/borrowck/two-phase-reservation-sharing-interference-2.rs\n\n(To be clear, that test is not describing something that is unsound. It is just providing an explicit example of a limitation in the implementation given in this PR. I have ideas on how to fix, but I want to land the work that is in this PR first, so that I can stop repeatedly rebasing this branch.)", "tree": {"sha": "0a791087fcd4e939afeef853e32693170bf3e0e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a791087fcd4e939afeef853e32693170bf3e0e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84feab34e455722061bb55260eafd1eb02a538fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84feab34e455722061bb55260eafd1eb02a538fa", "html_url": "https://github.com/rust-lang/rust/commit/84feab34e455722061bb55260eafd1eb02a538fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84feab34e455722061bb55260eafd1eb02a538fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "933103190950c97b966e789e9206bff2f7bd6118", "url": "https://api.github.com/repos/rust-lang/rust/commits/933103190950c97b966e789e9206bff2f7bd6118", "html_url": "https://github.com/rust-lang/rust/commit/933103190950c97b966e789e9206bff2f7bd6118"}, {"sha": "159037e05383f2349a709aa1c1681f11f89c552a", "url": "https://api.github.com/repos/rust-lang/rust/commits/159037e05383f2349a709aa1c1681f11f89c552a", "html_url": "https://github.com/rust-lang/rust/commit/159037e05383f2349a709aa1c1681f11f89c552a"}], "stats": {"total": 1437, "additions": 1182, "deletions": 255}, "files": [{"sha": "a83c3f29d25bc3a28452d0e083f4d9761fedf4ea", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -1137,7 +1137,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Place<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1151,7 +1151,7 @@ pub enum Place<'tcx> {\n \n /// The def-id of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,"}, {"sha": "009fb61984638fa139752381b5d2959006337348", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -1028,6 +1028,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"emit EndRegion as part of MIR; enable transforms that solely process EndRegion\"),\n     borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"select which borrowck is used (`ast`, `mir`, or `compare`)\"),\n+    two_phase_borrows: bool = (false, parse_bool, [UNTRACKED],\n+        \"use two-phase reserved/active distinction for `&mut` borrows in MIR borrowck\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,"}, {"sha": "223e08de826cea7dfdcb7ec9ef54237f4dbb274d", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::borrow::{Borrow, BorrowMut, ToOwned};\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n@@ -73,6 +74,25 @@ pub struct IdxSet<T: Idx> {\n     bits: [Word],\n }\n \n+impl<T: Idx> Borrow<IdxSet<T>> for IdxSetBuf<T> {\n+    fn borrow(&self) -> &IdxSet<T> {\n+        &*self\n+    }\n+}\n+\n+impl<T: Idx> BorrowMut<IdxSet<T>> for IdxSetBuf<T> {\n+    fn borrow_mut(&mut self) -> &mut IdxSet<T> {\n+        &mut *self\n+    }\n+}\n+\n+impl<T: Idx> ToOwned for IdxSet<T> {\n+    type Owned = IdxSetBuf<T>;\n+    fn to_owned(&self) -> Self::Owned {\n+        IdxSet::to_owned(self)\n+    }\n+}\n+\n impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()"}, {"sha": "769ade5dbcc54f08f76c56d94c1a98f04e248910", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -423,24 +423,28 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n                 s.s.space()?;\n-                s.synth_comment(item.id.to_string())\n+                s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n+                                        item.id, item.hir_id.local_id.0))\n             }\n             pprust_hir::NodeSubItem(id) => {\n                 s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::NodeBlock(blk) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"block {}\", blk.id))\n+                s.synth_comment(format!(\"block node_id: {} hir local_id: {}\",\n+                                        blk.id, blk.hir_id.local_id.0))\n             }\n             pprust_hir::NodeExpr(expr) => {\n                 s.s.space()?;\n-                s.synth_comment(expr.id.to_string())?;\n+                s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n+                                        expr.id, expr.hir_id.local_id.0))?;\n                 s.pclose()\n             }\n             pprust_hir::NodePat(pat) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"pat {}\", pat.id))\n+                s.synth_comment(format!(\"pat node_id: {} hir local_id: {}\",\n+                                        pat.id, pat.hir_id.local_id.0))\n             }\n         }\n     }"}, {"sha": "31a94499fd0cc369e7d6dddd9c3973bcd7098916", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -11,15 +11,15 @@\n use syntax_pos::Span;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{BorrowKind, Field, Local, Location, Operand};\n-use rustc::mir::{Place, ProjectionElem, Rvalue, StatementKind};\n+use rustc::mir::{Place, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty::{self, RegionKind};\n use rustc_data_structures::indexed_vec::Idx;\n \n use std::rc::Rc;\n \n use super::{MirBorrowckCtxt, Context};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{BorrowData, Borrows, FlowAtLocation, MovingOutStatements};\n+use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -96,7 +96,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        let borrow_msg = match self.describe_place(&borrow.place) {\n+        let borrow_msg = match self.describe_place(&borrow.borrowed_place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n@@ -124,7 +124,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(&borrow.borrowed_place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n@@ -143,12 +143,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         use rustc::hir::ExprClosure;\n         use rustc::mir::AggregateKind;\n \n-        let local = if let StatementKind::Assign(Place::Local(local), _) =\n-            self.mir[location.block].statements[location.statement_index].kind\n-        {\n-            local\n-        } else {\n-            return None;\n+        let local = match self.mir[location.block].statements.get(location.statement_index) {\n+            Some(&Statement { kind: StatementKind::Assign(Place::Local(local), _), .. }) => local,\n+            _ => return None,\n         };\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n@@ -324,11 +321,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &Borrows<'cx, 'gcx, 'tcx>\n+        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.scope_tree();\n-        let root_place = self.prefixes(&borrow.place, PrefixSet::All).last().unwrap();\n+        let scope_tree = borrows.0.scope_tree();\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All).last().unwrap();\n \n         match root_place {\n             &Place::Local(local) => {\n@@ -357,7 +354,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => drop_span,\n         };\n \n-        match (borrow.region, &self.describe_place(&borrow.place)) {\n+        match (borrow.region, &self.describe_place(&borrow.borrowed_place)) {\n             (RegionKind::ReScope(_), Some(name)) => {\n                 self.report_scoped_local_value_does_not_live_long_enough(\n                     name, &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);"}, {"sha": "69a08c7a30df3daf838d87bf1bb4c41f0b3655aa", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -17,13 +17,13 @@ use rustc::mir::{BasicBlock, Location};\n \n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{Borrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n-pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n     pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -32,7 +32,7 @@ pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n-        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n         inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -87,7 +87,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");\n@@ -99,7 +99,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");"}, {"sha": "39bcd2b6ae06382e738be72c314573fef832c326", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 207, "deletions": 37, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -28,13 +28,15 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use dataflow::do_dataflow;\n+use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::MoveDataParamEnv;\n-use dataflow::DataflowResultsConsumer;\n+use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{BorrowData, BorrowIndex, Borrows};\n+use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n+use dataflow::{ActiveBorrows, Reservations};\n+use dataflow::indexes::{BorrowIndex};\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -48,6 +50,9 @@ use self::MutateMode::{JustWrite, WriteAndRead};\n mod error_reporting;\n mod flows;\n mod prefixes;\n+\n+use std::borrow::Cow;\n+\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -157,7 +162,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &attributes,\n         &dead_unwinds,\n         MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-        |bd, i| &bd.move_data().move_paths[i],\n+        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n@@ -166,7 +171,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &attributes,\n         &dead_unwinds,\n         MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-        |bd, i| &bd.move_data().move_paths[i],\n+        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_move_outs = FlowAtLocation::new(do_dataflow(\n         tcx,\n@@ -175,7 +180,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &attributes,\n         &dead_unwinds,\n         MovingOutStatements::new(tcx, mir, &mdpe),\n-        |bd, i| &bd.move_data().moves[i],\n+        |bd, i| DebugFormatted::new(&bd.move_data().moves[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n@@ -184,7 +189,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &attributes,\n         &dead_unwinds,\n         EverInitializedLvals::new(tcx, mir, &mdpe),\n-        |bd, i| &bd.move_data().inits[i],\n+        |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n@@ -205,23 +210,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n-    let flow_borrows = FlowAtLocation::new(do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx, def_id, body_id),\n-        |bd, i| bd.location(i),\n-    ));\n-\n-    let mut state = Flows::new(\n-        flow_borrows,\n-        flow_inits,\n-        flow_uninits,\n-        flow_move_outs,\n-        flow_ever_inits,\n-    );\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n@@ -235,8 +223,47 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         },\n         storage_dead_or_drop_error_reported_l: FxHashSet(),\n         storage_dead_or_drop_error_reported_s: FxHashSet(),\n+        reservation_error_reported: FxHashSet(),\n+    };\n+\n+    let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n+    let flow_reservations = do_dataflow(\n+        tcx,\n+        mir,\n+        id,\n+        &attributes,\n+        &dead_unwinds,\n+        Reservations::new(borrows),\n+        |rs, i| {\n+            // In principle we could make the dataflow ensure that\n+            // only reservation bits show up, and assert so here.\n+            //\n+            // In practice it is easier to be looser; in particular,\n+            // it is okay for the kill-sets to hold activation bits.\n+            DebugFormatted::new(&(i.kind(), rs.location(i)))\n+        });\n+    let flow_active_borrows = {\n+        let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n+        let reservations = flow_reservations.0.operator;\n+        let a = DataflowAnalysis::new_with_entry_sets(mir,\n+                                                      &dead_unwinds,\n+                                                      Cow::Borrowed(reservations_on_entry),\n+                                                      ActiveBorrows::new(reservations));\n+        let results = a.run(tcx,\n+                            id,\n+                            &attributes,\n+                            |ab, i| DebugFormatted::new(&(i.kind(), ab.location(i))));\n+        FlowAtLocation::new(results)\n     };\n \n+    let mut state = Flows::new(\n+        flow_active_borrows,\n+        flow_inits,\n+        flow_uninits,\n+        flow_move_outs,\n+        flow_ever_inits,\n+    );\n+\n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n     opt_closure_req\n@@ -262,6 +289,14 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     storage_dead_or_drop_error_reported_l: FxHashSet<Local>,\n     /// Same as the above, but for statics (thread-locals)\n     storage_dead_or_drop_error_reported_s: FxHashSet<DefId>,\n+    /// This field keeps track of when borrow conflict errors are reported\n+    /// for reservations, so that we don't report seemingly duplicate\n+    /// errors for corresponding activations\n+    ///\n+    /// FIXME: Ideally this would be a set of BorrowIndex, not Places,\n+    /// but it is currently inconvenient to track down the BorrowIndex\n+    /// at the time we detect and report a reservation error.\n+    reservation_error_reported: FxHashSet<Place<'tcx>>,\n }\n \n // Check that:\n@@ -293,6 +328,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             flow_state\n         );\n         let span = stmt.source_info.span;\n+\n+        self.check_activations(location, span, flow_state);\n+\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 // NOTE: NLL RFC calls for *shallow* write; using Deep\n@@ -399,6 +437,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             flow_state\n         );\n         let span = term.source_info.span;\n+\n+        self.check_activations(location, span, flow_state);\n+\n         match term.kind {\n             TerminatorKind::SwitchInt {\n                 ref discr,\n@@ -504,9 +545,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let data = domain.borrows();\n                 flow_state.borrows.with_elems_outgoing(|borrows| {\n                     for i in borrows {\n-                        let borrow = &data[i];\n+                        let borrow = &data[i.borrow_index()];\n                         let context = ContextKind::StorageDead.new(loc);\n-\n                         self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n                     }\n                 });\n@@ -533,7 +573,7 @@ enum Control {\n }\n \n use self::ShallowOrDeep::{Deep, Shallow};\n-use self::ReadOrWrite::{Read, Write};\n+use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n@@ -568,6 +608,12 @@ enum ReadOrWrite {\n     /// new values or otherwise invalidated (for example, it could be\n     /// de-initialized, as in a move operation).\n     Write(WriteKind),\n+\n+    /// For two-phase borrows, we distinguish a reservation (which is treated\n+    /// like a Read) from an activation (which is treated like a write), and\n+    /// each of those is furthermore distinguished from Reads/Writes above.\n+    Reservation(WriteKind),\n+    Activation(WriteKind, BorrowIndex),\n }\n \n /// Kind of read access to a value\n@@ -656,6 +702,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> AccessErrorsReported {\n         let (sd, rw) = kind;\n \n+        if let Activation(_, borrow_index) = rw {\n+            if self.reservation_error_reported.contains(&place_span.0) {\n+                debug!(\"skipping access_place for activation of invalid reservation \\\n+                        place: {:?} borrow_index: {:?}\", place_span.0, borrow_index);\n+                return AccessErrorsReported { mutability_error: false, conflict_error: true };\n+            }\n+        }\n+\n         let mutability_error =\n             self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n         let conflict_error =\n@@ -677,9 +731,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, _index, borrow| match (rw, borrow.kind) {\n-                (Read(_), BorrowKind::Shared) => Control::Continue,\n-                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n+            |this, index, borrow| match (rw, borrow.kind) {\n+                // Obviously an activation is compatible with its own\n+                // reservation (or even prior activating uses of same\n+                // borrow); so don't check if they interfere.\n+                //\n+                // NOTE: *reservations* do conflict with themselves;\n+                // thus aren't injecting unsoundenss w/ this check.)\n+                (Activation(_, activating), _) if activating == index.borrow_index() =>\n+                {\n+                    debug!(\"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n+                            skipping {:?} b/c activation of same borrow_index: {:?}\",\n+                           place_span, sd, rw, (index, borrow), index.borrow_index());\n+                    Control::Continue\n+                }\n+\n+                (Read(_), BorrowKind::Shared) |\n+                (Reservation(..), BorrowKind::Shared) => Control::Continue,\n+\n+                (Read(kind), BorrowKind::Unique) |\n+                (Read(kind), BorrowKind::Mut) => {\n+                    // Reading from mere reservations of mutable-borrows is OK.\n+                    if this.tcx.sess.opts.debugging_opts.two_phase_borrows &&\n+                        index.is_reservation()\n+                    {\n+                        return Control::Continue;\n+                    }\n+\n                     match kind {\n                         ReadKind::Copy => {\n                             error_reported = true;\n@@ -702,13 +780,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                     Control::Break\n                 }\n+\n+                (Reservation(kind), BorrowKind::Unique) |\n+                (Reservation(kind), BorrowKind::Mut) |\n+                (Activation(kind, _), _) |\n                 (Write(kind), _) => {\n+\n+                    match rw {\n+                        Reservation(_) => {\n+                            debug!(\"recording invalid reservation of \\\n+                                    place: {:?}\", place_span.0);\n+                            this.reservation_error_reported.insert(place_span.0.clone());\n+                        }\n+                        Activation(_, activating) => {\n+                            debug!(\"observing check_place for activation of \\\n+                                    borrow_index: {:?}\", activating);\n+                        }\n+                        Read(..) | Write(..) => {}\n+                    }\n+\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n+\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n@@ -721,7 +818,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context, borrow, place_span.1, flow_state.borrows.operator());\n+                                context, borrow, place_span.1,\n+                                flow_state.borrows.operator());\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -794,16 +892,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let access_kind = match bk {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut => {\n-                        (Deep, Write(WriteKind::MutableBorrow(bk)))\n+                        let wk = WriteKind::MutableBorrow(bk);\n+                        if self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+                            (Deep, Reservation(wk))\n+                        } else {\n+                            (Deep, Write(wk))\n+                        }\n                     }\n                 };\n+\n                 self.access_place(\n                     context,\n                     (place, span),\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n+\n                 self.check_if_path_is_moved(\n                     context,\n                     InitializationRequiringAction::Borrow,\n@@ -917,7 +1022,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                       flow_state: &Flows<'cx, 'gcx, 'tcx>)\n     {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n-        let place = &borrow.place;\n+        let place = &borrow.borrowed_place;\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n@@ -974,6 +1079,48 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             )\n         }\n     }\n+\n+    fn check_activations(&mut self,\n+                         location: Location,\n+                         span: Span,\n+                         flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+    {\n+        if !self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+            return;\n+        }\n+\n+        // Two-phase borrow support: For each activation that is newly\n+        // generated at this statement, check if it interferes with\n+        // another borrow.\n+        let domain = flow_state.borrows.operator();\n+        let data = domain.borrows();\n+        flow_state.borrows.each_gen_bit(|gen| {\n+            if gen.is_activation()\n+            {\n+                let borrow_index = gen.borrow_index();\n+                let borrow = &data[borrow_index];\n+                // currently the flow analysis registers\n+                // activations for both mutable and immutable\n+                // borrows. So make sure we are talking about a\n+                // mutable borrow before we check it.\n+                match borrow.kind {\n+                    BorrowKind::Shared => return,\n+                    BorrowKind::Unique |\n+                    BorrowKind::Mut => {}\n+                }\n+\n+                self.access_place(ContextKind::Activation.new(location),\n+                                  (&borrow.borrowed_place, span),\n+                                  (Deep, Activation(WriteKind::MutableBorrow(borrow.kind),\n+                                                    borrow_index)),\n+                                  LocalMutationIsAllowed::No,\n+                                  flow_state);\n+                // We do not need to call `check_if_path_is_moved`\n+                // again, as we already called it when we made the\n+                // initial reservation.\n+            }\n+        });\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -1217,11 +1364,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         let mut error_reported = false;\n         match kind {\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique)) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n                 if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut)) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n                 self.is_mutable(place, is_local_mutation_allowed)\n             {\n@@ -1244,6 +1393,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 err.emit();\n             },\n+            Reservation(WriteKind::Mutate) |\n             Write(WriteKind::Mutate) => {\n                 if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n@@ -1265,6 +1415,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n+            Reservation(WriteKind::Move) |\n+            Reservation(WriteKind::StorageDeadOrDrop) |\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Shared)) |\n             Write(WriteKind::Move) |\n             Write(WriteKind::StorageDeadOrDrop) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n@@ -1279,6 +1432,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                 }\n             }\n+\n+            Activation(..) => {} // permission checks are done at Reservation point.\n+\n             Read(ReadKind::Borrow(BorrowKind::Unique)) |\n             Read(ReadKind::Borrow(BorrowKind::Mut)) |\n             Read(ReadKind::Borrow(BorrowKind::Shared)) |\n@@ -1771,14 +1927,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         unreachable!(\"iter::repeat returned None\")\n     }\n \n+    /// This function iterates over all of the current borrows\n+    /// (represented by 1-bits in `flow_state.borrows`) that conflict\n+    /// with an access to a place, invoking the `op` callback for each\n+    /// one.\n+    ///\n+    /// \"Current borrow\" here means a borrow that reaches the point in\n+    /// the control-flow where the access occurs.\n+    ///\n+    /// The borrow's phase is represented by the ReserveOrActivateIndex\n+    /// passed to the callback: one can call `is_reservation()` and\n+    /// `is_activation()` to determine what phase the borrow is\n+    /// currently in, when such distinction matters.\n     fn each_borrow_involving_path<F>(\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n+        F: FnMut(&mut Self, ReserveOrActivateIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -1789,10 +1957,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        for i in flow_state.borrows.elems_incoming() {\n-            let borrowed = &data[i];\n+        let mut elems_incoming = flow_state.borrows.elems_incoming();\n+        while let Some(i) = elems_incoming.next() {\n+            let borrowed = &data[i.borrow_index()];\n \n-            if self.places_conflict(&borrowed.place, place, access) {\n+            if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break { return; }\n             }\n@@ -1836,6 +2005,7 @@ struct Context {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ContextKind {\n+    Activation,\n     AssignLhs,\n     AssignRhs,\n     SetDiscrim,"}, {"sha": "a6c3398489ad7dc166d76c8e4dc70e93bec9d447", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -18,6 +18,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n use dataflow::move_paths::{HasMoveData, MovePathIndex};\n \n+use std::iter;\n+\n /// A trait for \"cartesian products\" of multiple FlowAtLocation.\n ///\n /// There's probably a way to auto-impl this, but I think\n@@ -94,9 +96,9 @@ where\n         self.curr_state.contains(x)\n     }\n \n-    pub fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+    pub fn elems_incoming(&self) -> iter::Peekable<indexed_set::Elems<BD::Idx>> {\n         let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ)\n+        self.curr_state.elems(univ).peekable()\n     }\n \n     pub fn with_elems_outgoing<F>(&self, f: F)\n@@ -121,9 +123,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n         let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n+            on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,\n             kill_set: &mut self.stmt_kill,\n         };\n@@ -135,9 +136,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n         let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n+            on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,\n             kill_set: &mut self.stmt_kill,\n         };"}, {"sha": "b79e044b24f202db76cda68c2aa8658a29bad866", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::indexed_vec::Idx;\n use dot;\n use dot::IntoCow;\n \n-use std::fmt::Debug;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n@@ -29,6 +28,7 @@ use util;\n \n use super::{BitDenotation, DataflowState};\n use super::DataflowBuilder;\n+use super::DebugFormatted;\n \n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation;\n@@ -60,9 +60,9 @@ pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n     render_idx: P)\n     -> io::Result<()>\n     where BD: BitDenotation,\n-          P: Fn(&BD, BD::Idx) -> &Debug\n+          P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n-    let g = Graph { mbcx: mbcx, phantom: PhantomData, render_idx: render_idx };\n+    let g = Graph { mbcx, phantom: PhantomData, render_idx };\n     let mut v = Vec::new();\n     dot::render(&g, &mut v)?;\n     debug!(\"print_borrowck_graph_to path: {} node_id: {}\",\n@@ -82,7 +82,7 @@ fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n \n impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     where MWF: MirWithFlowState<'tcx>,\n-          P: for <'b> Fn(&'b MWF::BD, <MWF::BD as BitDenotation>::Idx) -> &'b Debug,\n+          P: Fn(&MWF::BD, <MWF::BD as BitDenotation>::Idx) -> DebugFormatted,\n {\n     type Node = Node;\n     type Edge = Edge;\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n         const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n         const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n         fn chunked_present_left<W:io::Write>(w: &mut W,\n-                                             interpreted: &[&Debug],\n+                                             interpreted: &[DebugFormatted],\n                                              chunk_size: usize)\n                                              -> io::Result<()>\n         {"}, {"sha": "c61a57cdda0e91bfbb9964dff95eb38ae25ed8c7", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 432, "deletions": 83, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -11,53 +11,109 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n-use rustc::mir::{self, Location, Mir};\n-use rustc::mir::visit::Visitor;\n+use rustc::mir::{self, Location, Place, Mir};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::ty::{self, Region, TyCtxt};\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::{IndexVec};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n-use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n-pub use dataflow::indexes::BorrowIndex;\n+use dataflow::{BitDenotation, BlockSets, InitialFlow};\n+pub use dataflow::indexes::{BorrowIndex, ReserveOrActivateIndex};\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n use std::fmt;\n+use std::hash::Hash;\n use std::rc::Rc;\n \n-// `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n-// uniquely identified in the MIR by the `Location` of the assigment\n-// statement in which it appears on the right hand side.\n+/// `Borrows` stores the data used in the analyses that track the flow\n+/// of borrows.\n+///\n+/// It uniquely identifies every borrow (`Rvalue::Ref`) by a\n+/// `BorrowIndex`, and maps each such index to a `BorrowData`\n+/// describing the borrow. These indexes are used for representing the\n+/// borrows in compact bitvectors.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     scope_tree: Rc<region::ScopeTree>,\n     root_scope: Option<region::Scope>,\n+\n+    /// The fundamental map relating bitvector indexes to the borrows\n+    /// in the MIR.\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+\n+    /// Each borrow is also uniquely identified in the MIR by the\n+    /// `Location` of the assignment statement in which it appears on\n+    /// the right hand side; we map each such location to the\n+    /// corresponding `BorrowIndex`.\n     location_map: FxHashMap<Location, BorrowIndex>,\n+\n+    /// Every borrow in MIR is immediately stored into a place via an\n+    /// assignment statement. This maps each such assigned place back\n+    /// to its borrow-indexes.\n+    assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n+\n+    /// Every borrow has a region; this maps each such regions back to\n+    /// its borrow-indexes.\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n     nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n \n+// Two-phase borrows actually requires two flow analyses; they need\n+// to be separate because the final results of the first are used to\n+// construct the gen+kill sets for the second. (The dataflow system\n+// is not designed to allow the gen/kill sets to change during the\n+// fixed-point iteration.)\n+\n+/// The `Reservations` analysis is the first of the two flow analyses\n+/// tracking (phased) borrows. It computes where a borrow is reserved;\n+/// i.e. where it can reach in the control flow starting from its\n+/// initial `assigned = &'rgn borrowed` statement, and ending\n+/// whereever `'rgn` itself ends.\n+pub(crate) struct Reservations<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n+\n+/// The `ActiveBorrows` analysis is the second of the two flow\n+/// analyses tracking (phased) borrows. It computes where any given\n+/// borrow `&assigned = &'rgn borrowed` is *active*, which starts at\n+/// the first use of `assigned` after the reservation has started, and\n+/// ends whereever `'rgn` itself ends.\n+pub(crate) struct ActiveBorrows<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n+\n+impl<'a, 'gcx, 'tcx> Reservations<'a, 'gcx, 'tcx> {\n+    pub(crate) fn new(b: Borrows<'a, 'gcx, 'tcx>) -> Self { Reservations(b) }\n+    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n+        self.0.location(idx.borrow_index())\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n+    pub(crate) fn new(r: Reservations<'a, 'gcx, 'tcx>) -> Self { ActiveBorrows(r.0) }\n+    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n+        self.0.location(idx.borrow_index())\n+    }\n+}\n+\n // temporarily allow some dead fields: `kind` and `region` will be\n-// needed by borrowck; `place` will probably be a MovePathIndex when\n+// needed by borrowck; `borrowed_place` will probably be a MovePathIndex when\n // that is extended to include borrowed data paths.\n #[allow(dead_code)]\n #[derive(Debug)]\n pub struct BorrowData<'tcx> {\n     pub(crate) location: Location,\n     pub(crate) kind: mir::BorrowKind,\n     pub(crate) region: Region<'tcx>,\n-    pub(crate) place: mir::Place<'tcx>,\n+    pub(crate) borrowed_place: mir::Place<'tcx>,\n+    pub(crate) assigned_place: mir::Place<'tcx>,\n }\n \n impl<'tcx> fmt::Display for BorrowData<'tcx> {\n@@ -69,7 +125,22 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n         };\n         let region = format!(\"{}\", self.region);\n         let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.place)\n+        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n+    }\n+}\n+\n+impl ReserveOrActivateIndex {\n+    fn reserved(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2)) }\n+    fn active(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2) + 1) }\n+\n+    pub(crate) fn is_reservation(self) -> bool { self.index() % 2 == 0 }\n+    pub(crate) fn is_activation(self) -> bool { self.index() % 2 == 1}\n+\n+    pub(crate) fn kind(self) -> &'static str {\n+        if self.is_reservation() { \"reserved\" } else { \"active\" }\n+    }\n+    pub(crate) fn borrow_index(self) -> BorrowIndex {\n+        BorrowIndex::new(self.index() / 2)\n     }\n }\n \n@@ -89,6 +160,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir,\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n+            assigned_map: FxHashMap(),\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n             region_span_map: FxHashMap()\n@@ -100,6 +172,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                          scope_tree,\n                          root_scope,\n                          location_map: visitor.location_map,\n+                         assigned_map: visitor.assigned_map,\n                          region_map: visitor.region_map,\n                          local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n@@ -110,13 +183,16 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir: &'a Mir<'tcx>,\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n+            assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n             local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n-            fn visit_rvalue(&mut self,\n+            fn visit_assign(&mut self,\n+                            block: mir::BasicBlock,\n+                            assigned_place: &mir::Place<'tcx>,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n                 fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n@@ -127,23 +203,59 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     }}\n                 }\n \n-                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n-                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n+                if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+                    if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n \n                     let borrow = BorrowData {\n-                        location: location, kind: kind, region: region, place: place.clone(),\n+                        location, kind, region,\n+                        borrowed_place: borrowed_place.clone(),\n+                        assigned_place: assigned_place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n \n-                    let borrows = self.region_map.entry(region).or_insert(FxHashSet());\n-                    borrows.insert(idx);\n+                    insert(&mut self.assigned_map, assigned_place, idx);\n+                    insert(&mut self.region_map, &region, idx);\n+                    if let Some(local) = root_local(borrowed_place) {\n+                        insert(&mut self.local_map, &local, idx);\n+                    }\n+                }\n \n-                    if let Some(local) = root_local(place) {\n-                        let borrows = self.local_map.entry(local).or_insert(FxHashSet());\n-                        borrows.insert(idx);\n+                return self.super_assign(block, assigned_place, rvalue, location);\n+\n+                fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>,\n+                                    k: &K,\n+                                    v: V)\n+                    where K: Clone+Eq+Hash, V: Eq+Hash\n+                {\n+                    map.entry(k.clone())\n+                        .or_insert(FxHashSet())\n+                        .insert(v);\n+                }\n+            }\n+\n+            fn visit_rvalue(&mut self,\n+                            rvalue: &mir::Rvalue<'tcx>,\n+                            location: mir::Location) {\n+                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+                    // double-check that we already registered a BorrowData for this\n+\n+                    let mut found_it = false;\n+                    for idx in &self.region_map[region] {\n+                        let bd = &self.idx_vec[*idx];\n+                        if bd.location == location &&\n+                            bd.kind == kind &&\n+                            bd.region == region &&\n+                            bd.borrowed_place == *place\n+                        {\n+                            found_it = true;\n+                            break;\n+                        }\n                     }\n+                    assert!(found_it, \"Ref {:?} at {:?} missing BorrowData\", rvalue, location);\n                 }\n+\n+                return self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_statement(&mut self,\n@@ -153,7 +265,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n                     self.region_span_map.insert(ReScope(region_scope), statement.source_info.span);\n                 }\n-                self.super_statement(block, statement, location);\n+                return self.super_statement(block, statement, location);\n             }\n         }\n     }\n@@ -166,80 +278,95 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.region_span_map.get(region) {\n-                    Some(span) => Some(span.end_point()),\n-                    None => Some(self.mir.span.end_point())\n-                }\n-            }\n-        }\n-    }\n-\n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n+    ///\n+    /// `is_activations` tracks whether we are in the Reservations or\n+    /// the ActiveBorrows flow analysis, and does not set the\n+    /// activation kill bits in the former case. (Technically, we\n+    /// could set those kill bits without such a guard, since they are\n+    /// never gen'ed by Reservations in the first place.  But it makes\n+    /// the instrumentation and graph renderings nicer to leave\n+    /// activations out when of the Reservations kill sets.)\n     fn kill_loans_out_of_scope_at_location(&self,\n-                                           sets: &mut BlockSets<BorrowIndex>,\n-                                           location: Location) {\n+                                           sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                           location: Location,\n+                                           is_activations: bool) {\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n+            // NOTE: The state associated with a given `location`\n+            // reflects the dataflow on entry to the statement. If it\n+            // does not contain `borrow_region`, then then that means\n+            // that the statement at `location` kills the borrow.\n+            //\n+            // We are careful always to call this function *before* we\n+            // set up the gen-bits for the statement or\n+            // termanator. That way, if the effect of the statement or\n+            // terminator *does* introduce a new loan of the same\n+            // region, then setting that gen-bit will override any\n+            // potential kill introduced here.\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n-                    // The region checker really considers the borrow\n-                    // to start at the point **after** the location of\n-                    // the borrow, but the borrow checker puts the gen\n-                    // directly **on** the location of the\n-                    // borrow. This results in a gen/kill both being\n-                    // generated for same point if we are not\n-                    // careful. Probably we should change the point of\n-                    // the gen, but for now we hackily account for the\n-                    // mismatch here by not generating a kill for the\n-                    // location on the borrow itself.\n-                    if location != borrow_data.location {\n-                        sets.kill(&borrow_index);\n+                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n+                    if is_activations {\n+                        sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                     }\n                 }\n             }\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n-    type Idx = BorrowIndex;\n-    fn name() -> &'static str { \"borrows\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.borrows.len()\n-    }\n-    fn start_block_effect(&self, _sets: &mut IdxSet<BorrowIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<BorrowIndex>,\n-                        location: Location) {\n+    /// Models statement effect in Reservations and ActiveBorrows flow\n+    /// analyses; `is activations` tells us if we are in the latter\n+    /// case.\n+    fn statement_effect_on_borrows(&self,\n+                                   sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                   location: Location,\n+                                   is_activations: bool) {\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n         let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n             panic!(\"could not find statement at location {:?}\");\n         });\n+\n+        // Do kills introduced by NLL before setting up any potential\n+        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n+\n+        if is_activations {\n+            // INVARIANT: `sets.on_entry` accurately captures\n+            // reservations on entry to statement (b/c\n+            // accumulates_intrablock_state is overridden for\n+            // ActiveBorrows).\n+            //\n+            // Now compute the activations generated by uses within\n+            // the statement based on that reservation state.\n+            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n+            find.visit_statement(location.block, stmt, location);\n+        }\n+\n         match stmt.kind {\n+            // EndRegion kills any borrows (reservations and active borrows both)\n             mir::StatementKind::EndRegion(region_scope) => {\n                 if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n                     assert!(self.nonlexical_regioncx.is_none());\n-                    sets.kill_all(borrow_indexes);\n+                    for idx in borrow_indexes {\n+                        sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n+                        if is_activations {\n+                            sets.kill(&ReserveOrActivateIndex::active(*idx));\n+                        }\n+                    }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n                 }\n             }\n \n             mir::StatementKind::Assign(_, ref rhs) => {\n+                // NOTE: if/when the Assign case is revised to inspect\n+                // the assigned_place here, make sure to also\n+                // re-consider the current implementations of the\n+                // propagate_call_return method.\n+\n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n                     if let RegionKind::ReEmpty = region {\n@@ -254,7 +381,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     assert!(self.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n-                    sets.gen(&index);\n+                    sets.gen(&ReserveOrActivateIndex::reserved(*index));\n                 }\n             }\n \n@@ -264,7 +391,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME: expand this to variables that are assigned over.\n                 if let Some(borrow_indexes) = self.local_map.get(&local) {\n-                    sets.kill_all(borrow_indexes);\n+                    sets.kill_all(borrow_indexes.iter()\n+                                  .map(|b| ReserveOrActivateIndex::reserved(*b)));\n+                    if is_activations {\n+                        sets.kill_all(borrow_indexes.iter()\n+                                      .map(|b| ReserveOrActivateIndex::active(*b)));\n+                    }\n                 }\n             }\n \n@@ -275,17 +407,37 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::Nop => {}\n \n         }\n-\n-        self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<BorrowIndex>,\n-                         location: Location) {\n+    /// Models terminator effect in Reservations and ActiveBorrows\n+    /// flow analyses; `is activations` tells us if we are in the\n+    /// latter case.\n+    fn terminator_effect_on_borrows(&self,\n+                                    sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                    location: Location,\n+                                    is_activations: bool) {\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n-        match block.terminator().kind {\n+\n+        // Do kills introduced by NLL before setting up any potential\n+        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n+\n+        let term = block.terminator();\n+        if is_activations {\n+            // INVARIANT: `sets.on_entry` accurately captures\n+            // reservations on entry to terminator (b/c\n+            // accumulates_intrablock_state is overridden for\n+            // ActiveBorrows).\n+            //\n+            // Now compute effect of the terminator on the activations\n+            // themselves in the ActiveBorrows state.\n+            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n+            find.visit_terminator(location.block, term, location);\n+        }\n+\n+        match term.kind {\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::GeneratorDrop => {\n@@ -304,7 +456,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             if *scope != root_scope &&\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n-                                sets.kill(&borrow_index);\n+                                sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n+                                if is_activations {\n+                                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                                }\n                             }\n                         }\n                     }\n@@ -320,29 +475,223 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::TerminatorKind::FalseEdges {..} |\n             mir::TerminatorKind::Unreachable => {}\n         }\n-        self.kill_loans_out_of_scope_at_location(sets, location);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n+    pub(crate) fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n+        self.0.borrows()\n+    }\n+\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, return region span if it exists and\n+    /// span for end of the function if it doesn't exist.\n+    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n+        match self.0.nonlexical_regioncx {\n+            Some(_) => None,\n+            None => {\n+                match self.0.region_span_map.get(region) {\n+                    Some(span) => Some(span.end_point()),\n+                    None => Some(self.0.mir.span.end_point())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// `FindPlaceUses` is a MIR visitor that updates `self.sets` for all\n+/// of the borrows activated by a given statement or terminator.\n+///\n+/// ----\n+///\n+/// The `ActiveBorrows` flow analysis, when inspecting any given\n+/// statement or terminator, needs to \"generate\" (i.e. set to 1) all\n+/// of the bits for the borrows that are activated by that\n+/// statement/terminator.\n+///\n+/// This struct will seek out all places that are assignment-targets\n+/// for borrows (gathered in `self.assigned_map`; see also the\n+/// `assigned_map` in `struct Borrows`), and set the corresponding\n+/// gen-bits for activations of those borrows in `self.sets`\n+struct FindPlaceUses<'a, 'b: 'a, 'tcx: 'a> {\n+    assigned_map: &'a FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n+    sets: &'a mut BlockSets<'b, ReserveOrActivateIndex>,\n+}\n+\n+impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n+    fn has_been_reserved(&self, b: &BorrowIndex) -> bool {\n+        self.sets.on_entry.contains(&ReserveOrActivateIndex::reserved(*b))\n+    }\n+\n+    /// return whether `context` should be considered a \"use\" of a\n+    /// place found in that context. \"Uses\" activate associated\n+    /// borrows (at least when such uses occur while the borrow also\n+    /// has a reservation at the time).\n+    fn is_potential_use(context: PlaceContext) -> bool {\n+        match context {\n+            // storage effects on an place do not activate it\n+            PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n+\n+            // validation effects do not activate an place\n+            //\n+            // FIXME: Should they? Is it just another read? Or can we\n+            // guarantee it won't dereference the stored address? How\n+            // \"deep\" does validation go?\n+            PlaceContext::Validate => false,\n+\n+            // pure overwrites of an place do not activate it. (note\n+            // PlaceContext::Call is solely about dest place)\n+            PlaceContext::Store | PlaceContext::Call => false,\n+\n+            // reads of an place *do* activate it\n+            PlaceContext::Move |\n+            PlaceContext::Copy |\n+            PlaceContext::Drop |\n+            PlaceContext::Inspect |\n+            PlaceContext::Borrow { .. } |\n+            PlaceContext::Projection(..) => true,\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindPlaceUses<'a, 'b, 'tcx> {\n+    fn visit_place(&mut self,\n+                    place: &mir::Place<'tcx>,\n+                    context: PlaceContext<'tcx>,\n+                    location: Location) {\n+        debug!(\"FindPlaceUses place: {:?} assigned from borrows: {:?} \\\n+                used in context: {:?} at location: {:?}\",\n+               place, self.assigned_map.get(place), context, location);\n+        if Self::is_potential_use(context) {\n+            if let Some(borrows) = self.assigned_map.get(place) {\n+                for borrow_idx in borrows {\n+                    debug!(\"checking if index {:?} for {:?} is reserved ({}) \\\n+                            and thus needs active gen-bit set in sets {:?}\",\n+                           borrow_idx, place, self.has_been_reserved(&borrow_idx), self.sets);\n+                    if self.has_been_reserved(&borrow_idx) {\n+                        self.sets.gen(&ReserveOrActivateIndex::active(*borrow_idx));\n+                    } else {\n+                        // (This can certainly happen in valid code. I\n+                        // just want to know about it in the short\n+                        // term.)\n+                        debug!(\"encountered use of Place {:?} of borrow_idx {:?} \\\n+                                at location {:?} outside of reservation\",\n+                               place, borrow_idx, location);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_place(place, context, location);\n+    }\n+}\n+\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"reservations\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.0.borrows.len() * 2\n+    }\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>)  {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                        location: Location) {\n+        debug!(\"Reservations::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.statement_effect_on_borrows(sets, location, false);\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                         location: Location) {\n+        debug!(\"Reservations::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.terminator_effect_on_borrows(sets, location, false);\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<BorrowIndex>,\n+                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n-        // there are no effects on the region scopes from method calls.\n+        // there are no effects on borrows from method call return...\n+        //\n+        // ... but if overwriting a place can affect flow state, then\n+        // latter is not true; see NOTE on Assign case in\n+        // statement_effect_on_borrows.\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for ActiveBorrows<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"active_borrows\" }\n+\n+    /// Overriding this method; `ActiveBorrows` uses the intrablock\n+    /// state in `on_entry` to track the current reservations (which\n+    /// then affect the construction of the gen/kill sets for\n+    /// activations).\n+    fn accumulates_intrablock_state() -> bool { true }\n+\n+    fn bits_per_block(&self) -> usize {\n+        self.0.borrows.len() * 2\n+    }\n+\n+    fn start_block_effect(&self, _entry_sets: &mut IdxSet<ReserveOrActivateIndex>)  {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                        location: Location) {\n+        debug!(\"ActiveBorrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.statement_effect_on_borrows(sets, location, true);\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                         location: Location) {\n+        debug!(\"ActiveBorrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.terminator_effect_on_borrows(sets, location, true);\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             _dest_place: &mir::Place) {\n+        // there are no effects on borrows from method call return...\n+        //\n+        // ... but If overwriting a place can affect flow state, then\n+        // latter is not true; see NOTE on Assign case in\n+        // statement_effect_on_borrows.\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Reservations<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // union effects of preds when computing reservations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for ActiveBorrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // union effects of preds when computing borrows\n+        pred1 | pred2 // union effects of preds when computing activations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for Reservations<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n-        false // bottom = no Rvalue::Refs are active by default\n+        false // bottom = no Rvalue::Refs are reserved by default\n     }\n }\n "}, {"sha": "106a88e703c798179453703b9f9fe65050723076", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -23,7 +23,7 @@ use util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};\n use super::move_paths::{LookupResult, InitKind};\n-use super::{BitDenotation, BlockSets, DataflowOperator};\n+use super::{BitDenotation, BlockSets, InitialFlow};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -702,35 +702,35 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MovingOutStatements<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no loans in scope by default\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DataflowOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no initialized variables by default"}, {"sha": "dea61542ac4e2e7616deddfc2313bb1e0c0ca748", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> BitwiseOperator for MaybeStorageLive<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for MaybeStorageLive<'a, 'tcx> {\n+impl<'a, 'tcx> InitialFlow for MaybeStorageLive<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = dead"}, {"sha": "83c46e0199eebd290a121b672ca75cd6cb693862", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 162, "deletions": 74, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -18,8 +18,8 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n-use std::borrow::Borrow;\n-use std::fmt::{self, Debug};\n+use std::borrow::{Borrow, Cow};\n+use std::fmt;\n use std::io;\n use std::mem;\n use std::path::PathBuf;\n@@ -29,7 +29,8 @@ pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::EverInitializedLvals;\n-pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n+pub use self::impls::borrows::{Borrows, BorrowData};\n+pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -51,10 +52,29 @@ pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n     print_postflow_to: Option<String>,\n }\n \n-pub trait Dataflow<BD: BitDenotation> {\n+/// `DebugFormatted` encapsulates the \"{:?}\" rendering of some\n+/// arbitrary value. This way: you pay cost of allocating an extra\n+/// string (as well as that of rendering up-front); in exchange, you\n+/// don't have to hand over ownership of your value or deal with\n+/// borrowing it.\n+pub(crate) struct DebugFormatted(String);\n+\n+impl DebugFormatted {\n+    pub fn new(input: &fmt::Debug) -> DebugFormatted {\n+        DebugFormatted(format!(\"{:?}\", input))\n+    }\n+}\n+\n+impl fmt::Debug for DebugFormatted {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        write!(w, \"{}\", self.0)\n+    }\n+}\n+\n+pub(crate) trait Dataflow<BD: BitDenotation> {\n     /// Sets up and runs the dataflow problem, using `p` to render results if\n     /// implementation so chooses.\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n         let _ = p; // default implementation does not instrument process.\n         self.build_sets();\n         self.propagate();\n@@ -69,7 +89,7 @@ pub trait Dataflow<BD: BitDenotation> {\n \n impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n {\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n         self.flow_state.build_sets();\n         self.pre_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n         self.flow_state.propagate();\n@@ -101,44 +121,56 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n }\n \n pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 mir: &Mir<'tcx>,\n+                                                 mir: &'a Mir<'tcx>,\n                                                  node_id: ast::NodeId,\n                                                  attributes: &[ast::Attribute],\n                                                  dead_unwinds: &IdxSet<BasicBlock>,\n                                                  bd: BD,\n                                                  p: P)\n                                                  -> DataflowResults<BD>\n-    where BD: BitDenotation,\n-          P: Fn(&BD, BD::Idx) -> &fmt::Debug\n+    where BD: BitDenotation + InitialFlow,\n+          P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n-    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-        if let Some(item) = has_rustc_mir_with(attrs, name) {\n-            if let Some(s) = item.value_str() {\n-                return Some(s.to_string())\n-            } else {\n-                sess.span_err(\n-                    item.span,\n-                    &format!(\"{} attribute requires a path\", item.name()));\n-                return None;\n+    let flow_state = DataflowAnalysis::new(mir, dead_unwinds, bd);\n+    flow_state.run(tcx, node_id, attributes, p)\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n+{\n+    pub(crate) fn run<P>(self,\n+                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         node_id: ast::NodeId,\n+                         attributes: &[ast::Attribute],\n+                         p: P) -> DataflowResults<BD>\n+        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n+    {\n+        let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n+            if let Some(item) = has_rustc_mir_with(attrs, name) {\n+                if let Some(s) = item.value_str() {\n+                    return Some(s.to_string())\n+                } else {\n+                    sess.span_err(\n+                        item.span,\n+                        &format!(\"{} attribute requires a path\", item.name()));\n+                    return None;\n+                }\n             }\n-        }\n-        return None;\n-    };\n+            return None;\n+        };\n \n-    let print_preflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-    let print_postflow_to =\n-        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+        let print_preflow_to =\n+            name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n+        let print_postflow_to =\n+            name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n \n-    let mut mbcx = DataflowBuilder {\n-        node_id,\n-        print_preflow_to,\n-        print_postflow_to,\n-        flow_state: DataflowAnalysis::new(tcx, mir, dead_unwinds, bd),\n-    };\n+        let mut mbcx = DataflowBuilder {\n+            node_id,\n+            print_preflow_to, print_postflow_to, flow_state: self,\n+        };\n \n-    mbcx.dataflow(p);\n-    mbcx.flow_state.results()\n+        mbcx.dataflow(p);\n+        mbcx.flow_state.results()\n+    }\n }\n \n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n@@ -157,17 +189,12 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n         };\n         while propcx.changed {\n             propcx.changed = false;\n-            propcx.reset(&mut temp);\n             propcx.walk_cfg(&mut temp);\n         }\n     }\n \n     fn build_sets(&mut self) {\n-        // First we need to build the entry-, gen- and kill-sets. The\n-        // gather_moves information provides a high-level mapping from\n-        // mir-locations to the MoveOuts (and those correspond\n-        // directly to gen-sets here). But we still need to figure out\n-        // the kill-sets.\n+        // First we need to build the entry-, gen- and kill-sets.\n \n         {\n             let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n@@ -177,29 +204,35 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n \n+            let mut interim_state;\n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n+            let track_intrablock = BD::accumulates_intrablock_state();\n+            if track_intrablock {\n+                debug!(\"swapping in mutable on_entry, initially {:?}\", sets.on_entry);\n+                interim_state = sets.on_entry.to_owned();\n+                sets.on_entry = &mut interim_state;\n+            }\n             for j_stmt in 0..statements.len() {\n                 let location = Location { block: bb, statement_index: j_stmt };\n                 self.flow_state.operator.statement_effect(sets, location);\n+                if track_intrablock {\n+                    sets.apply_local_effect();\n+                }\n             }\n \n             if terminator.is_some() {\n                 let location = Location { block: bb, statement_index: statements.len() };\n                 self.flow_state.operator.terminator_effect(sets, location);\n+                if track_intrablock {\n+                    sets.apply_local_effect();\n+                }\n             }\n         }\n     }\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation\n {\n-    fn reset(&mut self, bits: &mut IdxSet<BD::Idx>) {\n-        let e = if BD::bottom_value() {!0} else {0};\n-        for b in bits.words_mut() {\n-            *b = e;\n-        }\n-    }\n-\n     fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n         let mir = self.builder.mir;\n         for (bb_idx, bb_data) in mir.basic_blocks().iter().enumerate() {\n@@ -231,7 +264,7 @@ fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-        where P: Fn(&BD, BD::Idx) -> &Debug\n+        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n     {\n         if let Some(ref path_str) = self.print_preflow_to {\n             let path = dataflow_path(BD::name(), \"preflow\", path_str);\n@@ -242,7 +275,7 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n     }\n \n     fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-        where P: Fn(&BD, BD::Idx) -> &Debug\n+        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n     {\n         if let Some(ref path_str) = self.print_postflow_to {\n             let path = dataflow_path(BD::name(), \"postflow\", path_str);\n@@ -255,7 +288,7 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n \n /// Maps each block to a set of bits\n #[derive(Debug)]\n-struct Bits<E:Idx> {\n+pub(crate) struct Bits<E:Idx> {\n     bits: IdxSetBuf<E>,\n }\n \n@@ -276,7 +309,7 @@ impl<E:Idx> Bits<E> {\n /// underlying flow analysis results, because it needs to handle cases\n /// where we are combining the results of *multiple* flow analyses\n /// (e.g. borrows + inits + uninits).\n-pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n+pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     type FlowState: FlowsAtLocation;\n \n     // Observation Hooks: override (at least one of) these to get analysis feedback.\n@@ -403,12 +436,12 @@ impl<O: BitDenotation> DataflowState<O> {\n         words.each_bit(bits_per_block, f)\n     }\n \n-    pub fn interpret_set<'c, P>(&self,\n-                                o: &'c O,\n-                                words: &IdxSet<O::Idx>,\n-                                render_idx: &P)\n-                                -> Vec<&'c Debug>\n-        where P: Fn(&O, O::Idx) -> &Debug\n+    pub(crate) fn interpret_set<'c, P>(&self,\n+                                       o: &'c O,\n+                                       words: &IdxSet<O::Idx>,\n+                                       render_idx: &P)\n+                                       -> Vec<DebugFormatted>\n+        where P: Fn(&O, O::Idx) -> DebugFormatted\n     {\n         let mut v = Vec::new();\n         self.each_bit(words, |i| {\n@@ -455,6 +488,7 @@ pub struct AllSets<E: Idx> {\n /// killed during the iteration. (This is such a good idea that the\n /// `fn gen` and `fn kill` methods that set their state enforce this\n /// for you.)\n+#[derive(Debug)]\n pub struct BlockSets<'a, E: Idx> {\n     /// Dataflow state immediately before control flow enters the given block.\n     pub(crate) on_entry: &'a mut IdxSet<E>,\n@@ -496,6 +530,7 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);\n     }\n+\n     fn kill_all<I>(&mut self, i: I)\n         where I: IntoIterator,\n               I::Item: Borrow<E>\n@@ -504,6 +539,11 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n             self.kill(j.borrow());\n         }\n     }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.on_entry.union(&self.gen_set);\n+        self.on_entry.subtract(&self.kill_set);\n+    }\n }\n \n impl<E:Idx> AllSets<E> {\n@@ -532,18 +572,51 @@ impl<E:Idx> AllSets<E> {\n     pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.on_entry_sets, block_idx)\n     }\n+    pub(crate) fn entry_set_state(&self) -> &Bits<E> {\n+        &self.on_entry_sets\n+    }\n }\n \n /// Parameterization for the precise form of data flow that is used.\n-pub trait DataflowOperator: BitwiseOperator {\n+/// `InitialFlow` handles initializing the bitvectors before any\n+/// code is inspected by the analysis. Analyses that need more nuanced\n+/// initialization (e.g. they need to consult the results of some other\n+/// dataflow analysis to set up the initial bitvectors) should not\n+/// implement this.\n+pub trait InitialFlow {\n     /// Specifies the initial value for each bit in the `on_entry` set\n     fn bottom_value() -> bool;\n }\n \n-pub trait BitDenotation: DataflowOperator {\n+pub trait BitDenotation: BitwiseOperator {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n+    /// Some analyses want to accumulate knowledge within a block when\n+    /// analyzing its statements for building the gen/kill sets. Override\n+    /// this method to return true in such cases.\n+    ///\n+    /// When this returns true, the statement-effect (re)construction\n+    /// will clone the `on_entry` state and pass along a reference via\n+    /// `sets.on_entry` to that local clone into `statement_effect` and\n+    /// `terminator_effect`).\n+    ///\n+    /// When its false, no local clone is constucted; instead a\n+    /// reference directly into `on_entry` is passed along via\n+    /// `sets.on_entry` instead, which represents the flow state at\n+    /// the block's start, not necessarily the state immediately prior\n+    /// to the statement/terminator under analysis.\n+    ///\n+    /// In either case, the passed reference is mutable; but this is a\n+    /// wart from using the `BlockSets` type in the API; the intention\n+    /// is that the `statement_effect` and `terminator_effect` methods\n+    /// mutate only the gen/kill sets.\n+    ///\n+    /// FIXME: We should consider enforcing the intention described in\n+    /// the previous paragraph by passing the three sets in separate\n+    /// parameters to encode their distinct mutabilities.\n+    fn accumulates_intrablock_state() -> bool { false }\n+\n     /// A name describing the dataflow analysis that this\n     /// BitDenotation is supporting.  The name should be something\n     /// suitable for plugging in as part of a filename e.g. avoid\n@@ -618,29 +691,33 @@ pub trait BitDenotation: DataflowOperator {\n                              dest_place: &mir::Place);\n }\n \n-impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n+impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n-    pub fn new(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+    pub fn new(mir: &'a Mir<'tcx>,\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n-               denotation: D) -> Self {\n+               denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-\n-        // (now rounded up to multiple of word size)\n-        let bits_per_block = words_per_block * usize_bits;\n-\n-        let num_blocks = mir.basic_blocks().len();\n-        let num_overall = num_blocks * bits_per_block;\n-\n-        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n+        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n         let on_entry = Bits::new(if D::bottom_value() {\n             IdxSetBuf::new_filled(num_overall)\n         } else {\n             IdxSetBuf::new_empty(num_overall)\n         });\n \n+        Self::new_with_entry_sets(mir, dead_unwinds, Cow::Owned(on_entry), denotation)\n+    }\n+\n+    pub(crate) fn new_with_entry_sets(mir: &'a Mir<'tcx>,\n+                                      dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+                                      on_entry: Cow<Bits<D::Idx>>,\n+                                      denotation: D)\n+                                      -> Self {\n+        let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n+        assert_eq!(num_overall, on_entry.bits.words().len() * usize_bits);\n+        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n@@ -650,12 +727,23 @@ impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                     words_per_block,\n                     gen_sets: zeroes.clone(),\n                     kill_sets: zeroes,\n-                    on_entry_sets: on_entry,\n+                    on_entry_sets: on_entry.into_owned(),\n                 },\n                 operator: denotation,\n-            },\n+            }\n         }\n+    }\n \n+    fn num_bits_overall(mir: &Mir, bits_per_block: usize) -> usize {\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+\n+        // (now rounded up to multiple of word size)\n+        let bits_per_block = words_per_block * usize_bits;\n+\n+        let num_blocks = mir.basic_blocks().len();\n+        let num_overall = num_blocks * bits_per_block;\n+        num_overall\n     }\n }\n "}, {"sha": "bcf4662211e8b3f38a15440b959a3c0c7595face", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -65,6 +65,9 @@ pub(crate) mod indexes {\n \n     /// Index into Borrows.locations\n     new_index!(BorrowIndex, \"bw\");\n+\n+    /// Index into Reservations/Activations bitvector\n+    new_index!(ReserveOrActivateIndex, \"ra\");\n }\n \n pub use self::indexes::MovePathIndex;"}, {"sha": "106bc39d0fc5be64ad2072675674340dac064793", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -14,7 +14,7 @@ use dataflow::{DataflowResults};\n use dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n use dataflow::MoveDataParamEnv;\n-use dataflow;\n+use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n@@ -59,13 +59,13 @@ impl MirPass for ElaborateDrops {\n             };\n             let dead_unwinds = find_dead_unwinds(tcx, mir, id, &env);\n             let flow_inits =\n-                dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                                      MaybeInitializedLvals::new(tcx, mir, &env),\n-                                      |bd, p| &bd.move_data().move_paths[p]);\n+                do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+                            MaybeInitializedLvals::new(tcx, mir, &env),\n+                            |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n             let flow_uninits =\n-                dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                                      MaybeUninitializedLvals::new(tcx, mir, &env),\n-                                      |bd, p| &bd.move_data().move_paths[p]);\n+                do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+                            MaybeUninitializedLvals::new(tcx, mir, &env),\n+                            |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n \n             ElaborateDropsCtxt {\n                 tcx,\n@@ -96,9 +96,9 @@ fn find_dead_unwinds<'a, 'tcx>(\n     // reach cleanup blocks, which can't have unwind edges themselves.\n     let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n-        dataflow::do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                           MaybeInitializedLvals::new(tcx, mir, &env),\n-                           |bd, p| &bd.move_data().move_paths[p]);\n+        do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n+                    MaybeInitializedLvals::new(tcx, mir, &env),\n+                    |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. } |"}, {"sha": "455a07c04cfc0056f97657d5fc84b1bd8594fe9c", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -78,7 +78,7 @@ use std::mem;\n use transform::{MirPass, MirSource};\n use transform::simplify;\n use transform::no_landing_pads::no_landing_pads;\n-use dataflow::{self, MaybeStorageLive, state_for_location};\n+use dataflow::{do_dataflow, DebugFormatted, MaybeStorageLive, state_for_location};\n \n pub struct StateTransform;\n \n@@ -341,8 +341,8 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n     let analysis = MaybeStorageLive::new(mir);\n     let storage_live =\n-        dataflow::do_dataflow(tcx, mir, node_id, &[], &dead_unwinds, analysis,\n-                              |bd, p| &bd.mir().local_decls[p]);\n+        do_dataflow(tcx, mir, node_id, &[], &dead_unwinds, analysis,\n+                    |bd, p| DebugFormatted::new(&bd.mir().local_decls[p]));\n \n     let mut ignored = StorageIgnored(IdxSetBuf::new_filled(mir.local_decls.len()));\n     ignored.visit_mir(mir);"}, {"sha": "6b8e2b073ccd345e67f06f21f5759ade3e1ae1fb", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n \n-use dataflow::do_dataflow;\n+use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::MoveDataParamEnv;\n use dataflow::BitDenotation;\n use dataflow::DataflowResults;\n@@ -51,15 +51,15 @@ impl MirPass for SanityCheck {\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-                        |bd, i| &bd.move_data().move_paths[i]);\n+                        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-                        |bd, i| &bd.move_data().move_paths[i]);\n+                        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n-                        |bd, i| &bd.move_data().move_paths[i]);\n+                        |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n         if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, id, &attributes, &flow_inits);"}, {"sha": "b6f5e17f1f609f2e62cf7055cae5630c03f0f268", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is an important corner case pointed out by Niko: one is\n+// allowed to initiate a shared borrow during a reservation, but it\n+// *must end* before the activation occurs.\n+//\n+// FIXME: for clarity, diagnostics for these cases might be better off\n+// if they specifically said \"cannot activate mutable borrow of `x`\"\n+\n+#![allow(dead_code)]\n+\n+fn read(_: &i32) { }\n+\n+fn ok() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    { let z = &x; read(z); }\n+    *y += 1;\n+}\n+\n+fn not_ok() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let z = &x;\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    read(z);\n+}\n+\n+fn should_be_ok_with_nll() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let z = &x;\n+    read(z);\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with nll today)\n+}\n+\n+fn should_also_eventually_be_ok_with_nll() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let _z = &x;\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+}\n+\n+fn main() { }"}, {"sha": "7695bd3e4652c0e7c6884dc2aee6cd2bf432e3d3", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is the second counter-example from Niko's blog post\n+// smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n+//\n+// It is \"artificial\". It is meant to illustrate directly that we\n+// should allow an aliasing access during reservation, but *not* while\n+// the mutable borrow is active.\n+\n+fn main() {\n+    /*0*/ let mut i = 0;\n+\n+    /*1*/ let p = &mut i; // (reservation of `i` starts here)\n+\n+    /*2*/ let j = i;      // OK: `i` is only reserved here\n+\n+    /*3*/ *p += 1;        // (mutable borrow of `i` starts here, since `p` is used)\n+\n+    /*4*/ let k = i;      //[lxl]~  ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll]~^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n+\n+    /*5*/ *p += 1;\n+\n+    let _ = (j, k, p);\n+}"}, {"sha": "01b04708599c03a489cdfaa2ea65deb1660acd88", "filename": "src/test/compile-fail/borrowck/two-phase-cannot-nest-mut-self-calls.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is the third counter-example from Niko's blog post\n+// smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n+//\n+// It shows that not all nested method calls on `self` are magically\n+// allowed by this change. In particular, a nested `&mut` borrow is\n+// still disallowed.\n+\n+fn main() {\n+\n+\n+    let mut vec = vec![0, 1];\n+    vec.get({\n+\n+        vec.push(2);\n+        //[lxl]~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll]~^^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+\n+        0\n+    });\n+}"}, {"sha": "fc9100c8a9a865f493319b2bd9444b82222e844f", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference-2.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is similar to two-phase-reservation-sharing-interference.rs\n+// in that it shows a reservation that overlaps with a shared borrow.\n+//\n+// Currently, this test fails with lexical lifetimes, but succeeds\n+// with non-lexical lifetimes. (The reason is because the activation\n+// of the mutable borrow ends up overlapping with a lexically-scoped\n+// shared borrow; but a non-lexical shared borrow can end before the\n+// activation occurs.)\n+//\n+// So this test is just making a note of the current behavior.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() { //[nll]~ ERROR compilation successful\n+    let mut v = vec![0, 1, 2];\n+    let shared = &v;\n+\n+    v.push(shared.len());\n+    //[lxl]~^  ERROR cannot borrow `v` as mutable because it is also borrowed as immutable [E0502]\n+\n+    assert_eq!(v, [0, 1, 2, 3]);\n+}"}, {"sha": "cc85315263a4fbb11871f617727e1da19e44a772", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is a corner case that the current implementation is (probably)\n+// treating more conservatively than is necessary. But it also does\n+// not seem like a terribly important use case to cover.\n+//\n+// So this test is just making a note of the current behavior, with\n+// the caveat that in the future, the rules may be loosened, at which\n+// point this test might be thrown out.\n+\n+fn main() {\n+    let mut vec = vec![0, 1];\n+    let delay: &mut Vec<_>;\n+    {\n+        let shared = &vec;\n+\n+        // we reserve here, which could (on its own) be compatible\n+        // with the shared borrow. But in the current implementation,\n+        // its an error.\n+        delay = &mut vec;\n+        //[lxl]~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll]~^^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+\n+        shared[0];\n+    }\n+\n+    // the &mut-borrow only becomes active way down here.\n+    //\n+    // (At least in theory; part of the reason this test fails is that\n+    // the constructed MIR throws in extra &mut reborrows which\n+    // flummoxes our attmpt to delay the activation point here.)\n+    delay.push(2);\n+}\n+"}, {"sha": "32747407c67f0195ee6516fca8a318a4c9de89df", "filename": "src/test/compile-fail/borrowck/two-phase-sneaky.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is the first counter-example from Niko's blog post\n+// smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n+// of a danger for code to crash if we just turned off the check for whether\n+// a mutable-borrow aliases another borrow.\n+\n+fn main() {\n+    let mut v: Vec<String> = vec![format!(\"Hello, \")];\n+    v[0].push_str({\n+\n+        v.push(format!(\"foo\"));\n+        //[lxl]~^ ERROR cannot borrow `v` as mutable more than once at a time [E0499]\n+        //[nll]~^^   ERROR cannot borrow `v` as mutable more than once at a time [E0499]\n+\n+        \"World!\"\n+    });\n+}"}, {"sha": "66234449263982ad635838fecdbb1da69df100e8", "filename": "src/test/run-pass/borrowck/two-phase-baseline.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is the \"goto example\" for why we want two phase borrows.\n+\n+fn main() {\n+    let mut v = vec![0, 1, 2];\n+    v.push(v.len());\n+    assert_eq!(v, [0, 1, 2, 3]);\n+}"}, {"sha": "a891e6072a7a64192ecac4b4a845fb2b8feb90e3", "filename": "src/test/run-pass/borrowck/two-phase-control-flow-split-before-activation.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84feab34e455722061bb55260eafd1eb02a538fa/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs?ref=84feab34e455722061bb55260eafd1eb02a538fa", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+fn main() {\n+    let mut a = 0;\n+    let mut b = 0;\n+    let p = if maybe() {\n+        &mut a\n+    } else {\n+        &mut b\n+    };\n+    use_(p);\n+}\n+\n+fn maybe() -> bool { false }\n+fn use_<T>(_: T) { }"}]}