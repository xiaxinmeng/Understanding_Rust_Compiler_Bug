{"sha": "8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNzFkYWQyYzk0ZDJlNGMzZjYzYzg1Y2VmNWVhZjQyY2YzMWQ3NGY=", "commit": {"author": {"name": "Dave Herman", "email": "dherman@mozilla.com", "date": "2010-10-21T00:04:15Z"}, "committer": {"name": "Dave Herman", "email": "dherman@mozilla.com", "date": "2010-10-21T00:04:15Z"}, "message": "created a first draft of the bit-set library needed for typestate", "tree": {"sha": "46a34006169d5c0a092bf1f5e248633dac2233a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a34006169d5c0a092bf1f5e248633dac2233a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "html_url": "https://github.com/rust-lang/rust/commit/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f/comments", "author": null, "committer": null, "parents": [{"sha": "11deb2f5f1ef731a48e8637a140203a40f9ad303", "url": "https://api.github.com/repos/rust-lang/rust/commits/11deb2f5f1ef731a48e8637a140203a40f9ad303", "html_url": "https://github.com/rust-lang/rust/commit/11deb2f5f1ef731a48e8637a140203a40f9ad303"}], "stats": {"total": 186, "additions": 186, "deletions": 0}, "files": [{"sha": "aeb8fdd1790ca6aa93e2815c47a54549711bfc6c", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "patch": "@@ -28,6 +28,7 @@ mod driver {\n \n mod util {\n     mod common;\n+    mod bits;\n }\n \n auth driver.rustc.main = state;"}, {"sha": "fd45601739d7bbc3c8a79dbedfb78e554fd1f97f", "filename": "src/comp/util/bits.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f/src%2Fcomp%2Futil%2Fbits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f/src%2Fcomp%2Futil%2Fbits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fbits.rs?ref=8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "patch": "@@ -0,0 +1,185 @@\n+import std._uint;\n+import std._int;\n+import std._vec;\n+\n+// FIXME: With recursive object types, we could implement binary methods like\n+//        union, intersection, and difference. At that point, we could write\n+//        an optimizing version of this module that produces a different obj\n+//        for the case where nbits < 32.\n+\n+state type t = rec(vec[mutable uint] storage, uint nbits);\n+\n+// FIXME: we should bind std.max_int\n+fn is32bit() -> bool {\n+    let uint n = 0xffffffffu;\n+    ret (n + 1u) == 0u;\n+}\n+\n+fn uint_bits() -> uint {\n+    if (is32bit()) {\n+        ret 31u;\n+    } else {\n+        ret 63u;\n+    }\n+}\n+\n+// FIXME: this should be state\n+fn create(uint nbits, bool init) -> t {\n+    auto elt;\n+    if (init) {\n+        elt = 1u;\n+    } else {\n+        elt = 0u;\n+    }\n+\n+    ret rec(storage = _vec.init_elt[mutable uint](nbits / uint_bits() + 1u, elt),\n+            nbits = nbits);\n+}\n+\n+\n+\n+// FIXME: this should be state\n+fn process(fn(uint, uint) -> uint op, t v0, t v1) -> bool {\n+    auto len = _vec.len[mutable uint](v1.storage);\n+\n+    check (_vec.len[mutable uint](v0.storage) == len);\n+    check (v0.nbits == v1.nbits);\n+\n+    auto changed = false;\n+\n+    for each (uint i in _uint.range(0u, len)) {\n+        auto w0 = v0.storage.(i);\n+        auto w1 = v1.storage.(i);\n+\n+        auto w = op(w0, w1);\n+        if (w0 != w) {\n+            changed = true;\n+            v0.storage.(i) = w;\n+        }\n+    }\n+\n+    ret changed;\n+}\n+\n+fn lor(uint w0, uint w1) -> uint {\n+    ret w0 | w1;\n+}\n+\n+// FIXME: this should be state\n+fn union(t v0, t v1) -> bool {\n+    auto sub = lor;\n+    ret process(sub, v0, v1);\n+}\n+\n+fn land(uint w0, uint w1) -> uint {\n+    ret w0 & w1;\n+}\n+\n+// FIXME: this should be state\n+fn intersect(t v0, t v1) -> bool {\n+    auto sub = land;\n+    ret process(sub, v0, v1);\n+}\n+\n+fn right(uint w0, uint w1) -> uint {\n+    ret w1;\n+}\n+\n+// FIXME: this should be state\n+fn copy(t v0, t v1) -> bool {\n+    auto sub = right;\n+    ret process(sub, v0, v1);\n+}\n+\n+// FIXME: this should be state\n+fn get(t v, uint i) -> bool {\n+    check (i < v.nbits);\n+\n+    auto bits = uint_bits();\n+\n+    auto w = i / bits;\n+    auto b = i % bits;\n+    auto x = 1u & (v.storage.(w) >> b);\n+    ret x == 1u;\n+}\n+\n+// FIXME: this should be state\n+fn equal(t v0, t v1) -> bool {\n+    // FIXME: when we can break or return from inside an iterator loop,\n+    //        we can eliminate this painful while-loop\n+    auto len = _vec.len[mutable uint](v1.storage);\n+    auto i = 0u;\n+    while (i < len) {\n+        if (v0.storage.(i) != v1.storage.(i)) {\n+            ret false;\n+        }\n+        i = i + 1u;\n+    }\n+    ret true;\n+}\n+\n+// FIXME: this should be state\n+fn clear(t v) {\n+    for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n+        v.storage.(i) = 0u;\n+    }\n+}\n+\n+// FIXME: this should be state\n+fn invert(t v) {\n+    for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n+        v.storage.(i) = ~v.storage.(i);\n+    }\n+}\n+\n+// FIXME: this should be state\n+/* v0 = v0 - v1 */\n+fn difference(t v0, t v1) -> bool {\n+    invert(v1);\n+    auto b = intersect(v0, v1);\n+    invert(v1);\n+    ret b;\n+}\n+\n+// FIXME: this should be state\n+fn set(t v, uint i, bool x) {\n+    check (i < v.nbits);\n+\n+    auto bits = uint_bits();\n+\n+    auto w = i / bits;\n+    auto b = i % bits;\n+    auto w0 = v.storage.(w);\n+    auto flag = 1u << b;\n+    if (x) {\n+        v.storage.(w) = v.storage.(w) | flag;\n+    } else {\n+        v.storage.(w) = v.storage.(w) & ~flag;\n+    }\n+}\n+\n+// FIXME: this should be state\n+fn init_to_vec(t v, uint i) -> uint {\n+    if (get(v, i)) {\n+        ret 1u;\n+    } else {\n+        ret 0u;\n+    }\n+}\n+\n+// FIXME: this should be state\n+fn to_vec(t v) -> vec[uint] {\n+    auto sub = bind init_to_vec(v, _);\n+    ret _vec.init_fn[uint](sub, v.nbits);\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}]}