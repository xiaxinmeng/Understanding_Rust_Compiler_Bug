{"sha": "98c0570a284c477285e59bb1928b582e7089a597", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YzA1NzBhMjg0YzQ3NzI4NWU1OWJiMTkyOGI1ODJlNzA4OWE1OTc=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2016-05-29T15:58:38Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2016-05-29T15:58:38Z"}, "message": "Format non-statement if-else expressions on a single line", "tree": {"sha": "868c74d99b21ee3390934c97c2a2d4aa0f350662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/868c74d99b21ee3390934c97c2a2d4aa0f350662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c0570a284c477285e59bb1928b582e7089a597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c0570a284c477285e59bb1928b582e7089a597", "html_url": "https://github.com/rust-lang/rust/commit/98c0570a284c477285e59bb1928b582e7089a597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c0570a284c477285e59bb1928b582e7089a597/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66cac1f3e9c26a6ef85a0ebe6b2249631976b42b", "url": "https://api.github.com/repos/rust-lang/rust/commits/66cac1f3e9c26a6ef85a0ebe6b2249631976b42b", "html_url": "https://github.com/rust-lang/rust/commit/66cac1f3e9c26a6ef85a0ebe6b2249631976b42b"}], "stats": {"total": 571, "additions": 274, "deletions": 297}, "files": [{"sha": "6b8c4e50246f6217fb52e47c592bff2ea509183d", "filename": "src/chains.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -354,27 +354,13 @@ fn rewrite_chain_subexpr(expr: &ast::Expr,\n         }\n         ast::ExprKind::Field(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n-            if s.len() <= width {\n-                Some(s)\n-            } else {\n-                None\n-            }\n+            if s.len() <= width { Some(s) } else { None }\n         }\n         ast::ExprKind::TupField(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n-            if s.len() <= width {\n-                Some(s)\n-            } else {\n-                None\n-            }\n-        }\n-        ast::ExprKind::Try(_) => {\n-            if width >= 1 {\n-                Some(\"?\".into())\n-            } else {\n-                None\n-            }\n+            if s.len() <= width { Some(s) } else { None }\n         }\n+        ast::ExprKind::Try(_) => if width >= 1 { Some(\"?\".into()) } else { None },\n         _ => unreachable!(),\n     }\n }"}, {"sha": "8a51b3ecefae6abb707cd6a428a2b15b7f392fe7", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -381,7 +381,9 @@ create_config! {\n     chain_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indentation of chain\";\n     chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n-    single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n+    single_line_if_else_max_width: usize, 50, \"Maximum line length for single line if-else \\\n+                                                expressions. A value of zero means always break \\\n+                                                if-else expressions.\";\n     format_strings: bool, true, \"Format string literals where necessary\";\n     force_format_strings: bool, false, \"Always format string literals\";\n     take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";"}, {"sha": "d57c8d294e1571296b65158d86283b013455c45e", "filename": "src/expr.rs", "status": "modified", "additions": 209, "deletions": 197, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -36,193 +36,210 @@ use syntax::parse::classify;\n \n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        let result = match self.node {\n-            ast::ExprKind::Vec(ref expr_vec) => {\n-                rewrite_array(expr_vec.iter().map(|e| &**e),\n-                              mk_sp(context.codemap.span_after(self.span, \"[\"), self.span.hi),\n-                              context,\n-                              width,\n-                              offset)\n-            }\n-            ast::ExprKind::Lit(ref l) => {\n-                match l.node {\n-                    ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n-                        rewrite_string_lit(context, l.span, width, offset)\n-                    }\n-                    _ => {\n-                        wrap_str(context.snippet(self.span),\n-                                 context.config.max_width,\n-                                 width,\n-                                 offset)\n-                    }\n+        format_expr(self, ExprType::SubExpression, context, width, offset)\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+enum ExprType {\n+    Statement,\n+    SubExpression,\n+}\n+\n+fn format_expr(expr: &ast::Expr,\n+               expr_type: ExprType,\n+               context: &RewriteContext,\n+               width: usize,\n+               offset: Indent)\n+               -> Option<String> {\n+    let result = match expr.node {\n+        ast::ExprKind::Vec(ref expr_vec) => {\n+            rewrite_array(expr_vec.iter().map(|e| &**e),\n+                          mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n+                          context,\n+                          width,\n+                          offset)\n+        }\n+        ast::ExprKind::Lit(ref l) => {\n+            match l.node {\n+                ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n+                    rewrite_string_lit(context, l.span, width, offset)\n                 }\n-            }\n-            ast::ExprKind::Call(ref callee, ref args) => {\n-                let inner_span = mk_sp(callee.span.hi, self.span.hi);\n-                rewrite_call(context, &**callee, args, inner_span, width, offset)\n-            }\n-            ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n-            ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n-                rewrite_binary_op(context, op, lhs, rhs, width, offset)\n-            }\n-            ast::ExprKind::Unary(ref op, ref subexpr) => {\n-                rewrite_unary_op(context, op, subexpr, width, offset)\n-            }\n-            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                rewrite_struct_lit(context,\n-                                   path,\n-                                   fields,\n-                                   base.as_ref().map(|e| &**e),\n-                                   self.span,\n-                                   width,\n-                                   offset)\n-            }\n-            ast::ExprKind::Tup(ref items) => {\n-                rewrite_tuple(context,\n-                              items.iter().map(|x| &**x),\n-                              self.span,\n-                              width,\n-                              offset)\n-            }\n-            ast::ExprKind::While(ref cond, ref block, label) => {\n-                Loop::new_while(None, cond, block, label).rewrite(context, width, offset)\n-            }\n-            ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-                Loop::new_while(Some(pat), cond, block, label).rewrite(context, width, offset)\n-            }\n-            ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n-                Loop::new_for(pat, cond, block, label).rewrite(context, width, offset)\n-            }\n-            ast::ExprKind::Loop(ref block, label) => {\n-                Loop::new_loop(block, label).rewrite(context, width, offset)\n-            }\n-            ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n-            ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-                rewrite_if_else(context,\n-                                cond,\n-                                if_block,\n-                                else_block.as_ref().map(|e| &**e),\n-                                self.span,\n-                                None,\n-                                width,\n-                                offset,\n-                                true)\n-            }\n-            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n-                rewrite_if_else(context,\n-                                cond,\n-                                if_block,\n-                                else_block.as_ref().map(|e| &**e),\n-                                self.span,\n-                                Some(pat),\n-                                width,\n-                                offset,\n-                                true)\n-            }\n-            ast::ExprKind::Match(ref cond, ref arms) => {\n-                rewrite_match(context, cond, arms, width, offset, self.span)\n-            }\n-            ast::ExprKind::Path(ref qself, ref path) => {\n-                rewrite_path(context, true, qself.as_ref(), path, width, offset)\n-            }\n-            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                rewrite_assignment(context, lhs, rhs, None, width, offset)\n-            }\n-            ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n-                rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n-            }\n-            ast::ExprKind::Again(ref opt_ident) => {\n-                let id_str = match *opt_ident {\n-                    Some(ident) => format!(\" {}\", ident.node),\n-                    None => String::new(),\n-                };\n-                wrap_str(format!(\"continue{}\", id_str),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            }\n-            ast::ExprKind::Break(ref opt_ident) => {\n-                let id_str = match *opt_ident {\n-                    Some(ident) => format!(\" {}\", ident.node),\n-                    None => String::new(),\n-                };\n-                wrap_str(format!(\"break{}\", id_str),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            }\n-            ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n-                rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n-            }\n-            ast::ExprKind::Try(..) |\n-            ast::ExprKind::Field(..) |\n-            ast::ExprKind::TupField(..) |\n-            ast::ExprKind::MethodCall(..) => rewrite_chain(self, context, width, offset),\n-            ast::ExprKind::Mac(ref mac) => {\n-                // Failure to rewrite a marco should not imply failure to\n-                // rewrite the expression.\n-                rewrite_macro(mac, None, context, width, offset).or_else(|| {\n-                    wrap_str(context.snippet(self.span),\n+                _ => {\n+                    wrap_str(context.snippet(expr.span),\n                              context.config.max_width,\n                              width,\n                              offset)\n-                })\n-            }\n-            ast::ExprKind::Ret(None) => {\n-                wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n-            }\n-            ast::ExprKind::Ret(Some(ref expr)) => {\n-                rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n-            }\n-            ast::ExprKind::Box(ref expr) => {\n-                rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n-            }\n-            ast::ExprKind::AddrOf(mutability, ref expr) => {\n-                rewrite_expr_addrof(context, mutability, expr, width, offset)\n-            }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n-                rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, width, offset)\n-            }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n-                rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, width, offset)\n-            }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n-                rewrite_pair(&**expr, &**index, \"\", \"[\", \"]\", context, width, offset)\n-            }\n-            ast::ExprKind::Repeat(ref expr, ref repeats) => {\n-                rewrite_pair(&**expr, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n-            }\n-            ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n-                let delim = match limits {\n-                    ast::RangeLimits::HalfOpen => \"..\",\n-                    ast::RangeLimits::Closed => \"...\",\n-                };\n-\n-                match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n-                    (Some(ref lhs), Some(ref rhs)) => {\n-                        rewrite_pair(&**lhs, &**rhs, \"\", delim, \"\", context, width, offset)\n-                    }\n-                    (None, Some(ref rhs)) => {\n-                        rewrite_unary_prefix(context, delim, &**rhs, width, offset)\n-                    }\n-                    (Some(ref lhs), None) => {\n-                        rewrite_unary_suffix(context, delim, &**lhs, width, offset)\n-                    }\n-                    (None, None) => wrap_str(delim.into(), context.config.max_width, width, offset),\n                 }\n             }\n-            // We do not format these expressions yet, but they should still\n-            // satisfy our width restrictions.\n-            ast::ExprKind::InPlace(..) |\n-            ast::ExprKind::InlineAsm(..) => {\n-                wrap_str(context.snippet(self.span),\n+        }\n+        ast::ExprKind::Call(ref callee, ref args) => {\n+            let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n+            rewrite_call(context, &**callee, args, inner_span, width, offset)\n+        }\n+        ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n+        ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n+            rewrite_binary_op(context, op, lhs, rhs, width, offset)\n+        }\n+        ast::ExprKind::Unary(ref op, ref subexpr) => {\n+            rewrite_unary_op(context, op, subexpr, width, offset)\n+        }\n+        ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n+            rewrite_struct_lit(context,\n+                               path,\n+                               fields,\n+                               base.as_ref().map(|e| &**e),\n+                               expr.span,\n+                               width,\n+                               offset)\n+        }\n+        ast::ExprKind::Tup(ref items) => {\n+            rewrite_tuple(context,\n+                          items.iter().map(|x| &**x),\n+                          expr.span,\n+                          width,\n+                          offset)\n+        }\n+        ast::ExprKind::While(ref cond, ref block, label) => {\n+            Loop::new_while(None, cond, block, label).rewrite(context, width, offset)\n+        }\n+        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n+            Loop::new_while(Some(pat), cond, block, label).rewrite(context, width, offset)\n+        }\n+        ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n+            Loop::new_for(pat, cond, block, label).rewrite(context, width, offset)\n+        }\n+        ast::ExprKind::Loop(ref block, label) => {\n+            Loop::new_loop(block, label).rewrite(context, width, offset)\n+        }\n+        ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n+        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n+            rewrite_if_else(context,\n+                            cond,\n+                            expr_type,\n+                            if_block,\n+                            else_block.as_ref().map(|e| &**e),\n+                            expr.span,\n+                            None,\n+                            width,\n+                            offset,\n+                            true)\n+        }\n+        ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n+            rewrite_if_else(context,\n+                            cond,\n+                            expr_type,\n+                            if_block,\n+                            else_block.as_ref().map(|e| &**e),\n+                            expr.span,\n+                            Some(pat),\n+                            width,\n+                            offset,\n+                            true)\n+        }\n+        ast::ExprKind::Match(ref cond, ref arms) => {\n+            rewrite_match(context, cond, arms, width, offset, expr.span)\n+        }\n+        ast::ExprKind::Path(ref qself, ref path) => {\n+            rewrite_path(context, true, qself.as_ref(), path, width, offset)\n+        }\n+        ast::ExprKind::Assign(ref lhs, ref rhs) => {\n+            rewrite_assignment(context, lhs, rhs, None, width, offset)\n+        }\n+        ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n+            rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n+        }\n+        ast::ExprKind::Again(ref opt_ident) => {\n+            let id_str = match *opt_ident {\n+                Some(ident) => format!(\" {}\", ident.node),\n+                None => String::new(),\n+            };\n+            wrap_str(format!(\"continue{}\", id_str),\n+                     context.config.max_width,\n+                     width,\n+                     offset)\n+        }\n+        ast::ExprKind::Break(ref opt_ident) => {\n+            let id_str = match *opt_ident {\n+                Some(ident) => format!(\" {}\", ident.node),\n+                None => String::new(),\n+            };\n+            wrap_str(format!(\"break{}\", id_str),\n+                     context.config.max_width,\n+                     width,\n+                     offset)\n+        }\n+        ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n+            rewrite_closure(capture, fn_decl, body, expr.span, context, width, offset)\n+        }\n+        ast::ExprKind::Try(..) |\n+        ast::ExprKind::Field(..) |\n+        ast::ExprKind::TupField(..) |\n+        ast::ExprKind::MethodCall(..) => rewrite_chain(expr, context, width, offset),\n+        ast::ExprKind::Mac(ref mac) => {\n+            // Failure to rewrite a marco should not imply failure to\n+            // rewrite the expression.\n+            rewrite_macro(mac, None, context, width, offset).or_else(|| {\n+                wrap_str(context.snippet(expr.span),\n                          context.config.max_width,\n                          width,\n                          offset)\n+            })\n+        }\n+        ast::ExprKind::Ret(None) => {\n+            wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n+        }\n+        ast::ExprKind::Ret(Some(ref expr)) => {\n+            rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n+        }\n+        ast::ExprKind::Box(ref expr) => {\n+            rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n+        }\n+        ast::ExprKind::AddrOf(mutability, ref expr) => {\n+            rewrite_expr_addrof(context, mutability, expr, width, offset)\n+        }\n+        ast::ExprKind::Cast(ref expr, ref ty) => {\n+            rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, width, offset)\n+        }\n+        ast::ExprKind::Type(ref expr, ref ty) => {\n+            rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, width, offset)\n+        }\n+        ast::ExprKind::Index(ref expr, ref index) => {\n+            rewrite_pair(&**expr, &**index, \"\", \"[\", \"]\", context, width, offset)\n+        }\n+        ast::ExprKind::Repeat(ref expr, ref repeats) => {\n+            rewrite_pair(&**expr, &**repeats, \"[\", \"; \", \"]\", context, width, offset)\n+        }\n+        ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n+            let delim = match limits {\n+                ast::RangeLimits::HalfOpen => \"..\",\n+                ast::RangeLimits::Closed => \"...\",\n+            };\n+\n+            match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n+                (Some(ref lhs), Some(ref rhs)) => {\n+                    rewrite_pair(&**lhs, &**rhs, \"\", delim, \"\", context, width, offset)\n+                }\n+                (None, Some(ref rhs)) => {\n+                    rewrite_unary_prefix(context, delim, &**rhs, width, offset)\n+                }\n+                (Some(ref lhs), None) => {\n+                    rewrite_unary_suffix(context, delim, &**lhs, width, offset)\n+                }\n+                (None, None) => wrap_str(delim.into(), context.config.max_width, width, offset),\n             }\n-        };\n-        result.and_then(|res| recover_comment_removed(res, self.span, context, width, offset))\n-    }\n+        }\n+        // We do not format these expressions yet, but they should still\n+        // satisfy our width restrictions.\n+        ast::ExprKind::InPlace(..) |\n+        ast::ExprKind::InlineAsm(..) => {\n+            wrap_str(context.snippet(expr.span),\n+                     context.config.max_width,\n+                     width,\n+                     offset)\n+        }\n+    };\n+    result.and_then(|res| recover_comment_removed(res, expr.span, context, width, offset))\n }\n \n pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n@@ -470,11 +487,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n }\n \n fn and_one_line(x: Option<String>) -> Option<String> {\n-    x.and_then(|x| if x.contains('\\n') {\n-        None\n-    } else {\n-        Some(x)\n-    })\n+    x.and_then(|x| if x.contains('\\n') { None } else { Some(x) })\n }\n \n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n@@ -560,15 +573,13 @@ impl Rewrite for ast::Stmt {\n             }\n             ast::StmtKind::Expr(ref ex, _) |\n             ast::StmtKind::Semi(ref ex, _) => {\n-                let suffix = if semicolon_for_stmt(self) {\n-                    \";\"\n-                } else {\n-                    \"\"\n-                };\n+                let suffix = if semicolon_for_stmt(self) { \";\" } else { \"\" };\n \n-                ex.rewrite(context,\n-                             context.config.max_width - offset.width() - suffix.len(),\n-                             offset)\n+                format_expr(ex,\n+                            ExprType::Statement,\n+                            context,\n+                            context.config.max_width - offset.width() - suffix.len(),\n+                            offset)\n                     .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) => None,\n@@ -704,6 +715,7 @@ fn extract_comment(span: Span,\n // treated as an if-let-else expression.\n fn rewrite_if_else(context: &RewriteContext,\n                    cond: &ast::Expr,\n+                   expr_type: ExprType,\n                    if_block: &ast::Block,\n                    else_block_opt: Option<&ast::Expr>,\n                    span: Span,\n@@ -726,10 +738,12 @@ fn rewrite_if_else(context: &RewriteContext,\n                                                     offset + 3));\n \n     // Try to format if-else on single line.\n-    if allow_single_line && context.config.single_line_if_else {\n+    if expr_type == ExprType::SubExpression && allow_single_line &&\n+       context.config.single_line_if_else_max_width > 0 {\n         let trial = single_line_if_else(context, &pat_expr_string, if_block, else_block_opt, width);\n \n-        if trial.is_some() {\n+        if trial.is_some() &&\n+           trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n             return trial;\n         }\n     }\n@@ -766,6 +780,7 @@ fn rewrite_if_else(context: &RewriteContext,\n             ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n+                                expr_type,\n                                 if_block,\n                                 next_else_block.as_ref().map(|e| &**e),\n                                 mk_sp(else_block.span.lo, span.hi),\n@@ -777,6 +792,7 @@ fn rewrite_if_else(context: &RewriteContext,\n             ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n+                                expr_type,\n                                 if_block,\n                                 next_else_block.as_ref().map(|e| &**e),\n                                 mk_sp(else_block.span.lo, span.hi),\n@@ -1248,11 +1264,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n \n     // The expression may (partionally) fit on the current line.\n     if width > extra_offset + 1 {\n-        let spacer = if pat.is_some() {\n-            \" \"\n-        } else {\n-            \"\"\n-        };\n+        let spacer = if pat.is_some() { \" \" } else { \"\" };\n \n         let expr_rewrite = expr.rewrite(context,\n                                         width - extra_offset - spacer.len(),"}, {"sha": "cb64448519937fd4d51402e2bf8f5bdeecb04a9e", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -111,11 +111,7 @@ pub fn rewrite_use_list(width: usize,\n     }\n \n     // 2 = ::\n-    let path_separation_w = if !path_str.is_empty() {\n-        2\n-    } else {\n-        0\n-    };\n+    let path_separation_w = if !path_str.is_empty() { 2 } else { 0 };\n     // 1 = {\n     let supp_indent = path_str.len() + path_separation_w + 1;\n     // 1 = }\n@@ -140,11 +136,7 @@ pub fn rewrite_use_list(width: usize,\n     // potentially move \"self\" to the front of the vector without touching\n     // the rest of the items.\n     let has_self = move_self_to_front(&mut items);\n-    let first_index = if has_self {\n-        0\n-    } else {\n-        1\n-    };\n+    let first_index = if has_self { 0 } else { 1 };\n \n     if context.config.reorder_imports {\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));"}, {"sha": "6cafe34a82426510a67dc295aaee30ccb1906d95", "filename": "src/items.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -140,11 +140,7 @@ impl<'a> FmtVisitor<'a> {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function keywords here.\n                 let vis = format_visibility(&item.vis);\n-                let mut_str = if is_mutable {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n+                let mut_str = if is_mutable { \"mut \" } else { \"\" };\n                 let prefix = format!(\"{}static {}{}: \", vis, mut_str, item.ident);\n                 let offset = self.block_indent + prefix.len();\n                 // 1 = ;\n@@ -265,11 +261,7 @@ impl<'a> FmtVisitor<'a> {\n         if self.config.fn_single_line && is_simple_block_stmt(block, codemap) {\n             let rewrite = {\n                 if let Some(ref e) = block.expr {\n-                    let suffix = if semicolon_for_expr(e) {\n-                        \";\"\n-                    } else {\n-                        \"\"\n-                    };\n+                    let suffix = if semicolon_for_expr(e) { \";\" } else { \"\" };\n \n                     e.rewrite(&self.get_context(),\n                                  self.config.max_width - self.block_indent.width(),\n@@ -1280,11 +1272,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         .rewrite(&context, context.config.max_width - indent.width(), indent));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n-    let ret_str_len = if multi_line_ret_str {\n-        0\n-    } else {\n-        ret_str.len()\n-    };\n+    let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n     // Args.\n     let (mut one_line_budget, mut multi_line_budget, mut arg_indent) ="}, {"sha": "2bd4becc57f076452aef8ee959a83dd4ec631af3", "filename": "src/lists.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -208,11 +208,7 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n         let first = i == 0;\n         let last = iter.peek().is_none();\n         let separate = !last || trailing_separator;\n-        let item_sep_len = if separate {\n-            sep_len\n-        } else {\n-            0\n-        };\n+        let item_sep_len = if separate { sep_len } else { 0 };\n \n         // Item string may be multi-line. Its length (used for block comment alignment)\n         // Should be only the length of the last line."}, {"sha": "7e6d15166369ea88b0017c034add3c217824b353", "filename": "src/missed_spans.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -93,13 +93,7 @@ impl<'a> FmtVisitor<'a> {\n \n         fn replace_chars(string: &str) -> String {\n             string.chars()\n-                .map(|ch| {\n-                    if ch.is_whitespace() {\n-                        ch\n-                    } else {\n-                        'X'\n-                    }\n-                })\n+                .map(|ch| { if ch.is_whitespace() { ch } else { 'X' } })\n                 .collect()\n         }\n "}, {"sha": "2fe16495b9974fdd364ccbb02a3493650935a1df", "filename": "src/patterns.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -121,11 +121,7 @@ impl Rewrite for Pat {\n             PatKind::Struct(ref path, ref fields, elipses) => {\n                 let path = try_opt!(rewrite_path(context, true, None, path, width, offset));\n \n-                let (elipses_str, terminator) = if elipses {\n-                    (\", ..\", \"..\")\n-                } else {\n-                    (\"\", \"}\")\n-                };\n+                let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n \n                 // 5 = `{` plus space before and after plus `}` plus space before.\n                 let budget = try_opt!(width.checked_sub(path.len() + 5 + elipses_str.len()));"}, {"sha": "f44a10a4a375356ef6380663bff2391206f9bc08", "filename": "src/types.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -187,11 +187,7 @@ fn rewrite_segment(expr_context: bool,\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = context.codemap.span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n-            let separator = if expr_context {\n-                \"::\"\n-            } else {\n-                \"\"\n-            };\n+            let separator = if expr_context { \"::\" } else { \"\" };\n \n             // 1 for <\n             let extra_offset = 1 + separator.len();"}, {"sha": "188174e602117592adc3ecfff52afba2a9ab850c", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -77,11 +77,7 @@ pub fn format_visibility(vis: &Visibility) -> Cow<'static, str> {\n         Visibility::Crate(_) => Cow::from(\"pub(crate) \"),\n         Visibility::Restricted { ref path, .. } => {\n             let Path { global, ref segments, .. } = **path;\n-            let prefix = if global {\n-                \"::\"\n-            } else {\n-                \"\"\n-            };\n+            let prefix = if global { \"::\" } else { \"\" };\n             let mut segments_iter = segments.iter().map(|seg| seg.identifier.name.as_str());\n \n             Cow::from(format!(\"pub({}{}) \", prefix, segments_iter.join(\"::\")))"}, {"sha": "94ae85b4ecb944b9938cd8cbf8185e5001161f48", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -77,11 +77,7 @@ impl<'a> FmtVisitor<'a> {\n         // Check if this block has braces.\n         let snippet = self.snippet(b.span);\n         let has_braces = snippet.starts_with(\"{\") || snippet.starts_with(\"unsafe\");\n-        let brace_compensation = if has_braces {\n-            BytePos(1)\n-        } else {\n-            BytePos(0)\n-        };\n+        let brace_compensation = if has_braces { BytePos(1) } else { BytePos(0) };\n \n         self.last_pos = self.last_pos + brace_compensation;\n         self.block_indent = self.block_indent.block_indent(self.config);"}, {"sha": "2a0af63eea558cc95910957317a22438cb92245e", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -21,7 +21,7 @@ enum_trailing_comma = true\n report_todo = \"Always\"\n report_fixme = \"Never\"\n reorder_imports = false\n-single_line_if_else = false\n+single_line_if_else_max_width = 0\n format_strings = true\n chains_overflow_last = true\n take_source_hints = true"}, {"sha": "6646056690d1285d905d5a4c10541569a7076262", "filename": "tests/source/chains-block-indented-base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-block-indented-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-block-indented-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-block-indented-base.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chain_base_indent: Inherit\n // Test chain formatting with block indented base\n "}, {"sha": "29c092d9f1adef361717c2a4174cc035b806dcdd", "filename": "tests/source/chains-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-no-overflow.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chains_overflow_last: false\n // Test chain formatting without overflowing the last item.\n "}, {"sha": "bd365ce9a4c9c3ad647b689d7d9259d58750d75e", "filename": "tests/source/chains-visual.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-visual.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chain_indent: Visual\n // rustfmt-chain_base_indent: Visual\n // Test chain formatting."}, {"sha": "d2df8c48da6798d255c4c9201dc09175b22c4064", "filename": "tests/source/chains.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // Test chain formatting.\n \n fn main() {"}, {"sha": "0a0dd7175864e047726f49711fd0734ba2839a27", "filename": "tests/source/closure.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -11,21 +11,19 @@ fn main() {\n         };\n \n     let loooooooooooooong_name = |field| {\n-             // TODO(#27): format comments.\n+             // format comments.\n              if field.node.attrs.len() > 0 { field.node.attrs[0].span.lo\n              } else {\n                  field.span.lo\n              }};\n \n-    let block_me = |field| if true_story() { 1 } else { 2 };\n-\n     let unblock_me = |trivial| {\n                          closure()\n                      };\n \n     let empty = |arg|    {};\n \n-    let simple = |arg| { /* TODO(#27): comment formatting */ foo(arg) };\n+    let simple = |arg| { /*  comment formatting */ foo(arg) };\n \n     let test = |  | { do_something(); do_something_else(); };\n "}, {"sha": "768aa1fe3c04c8ed7b69d86e5eec0849738833b0", "filename": "tests/source/else-if-brace-style-always-next-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: AlwaysNextLine\n \n fn main() {"}, {"sha": "7f8a3f1a3c4725645e0ef9a5e062053ead292845", "filename": "tests/source/else-if-brace-style-always-same-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: AlwaysSameLine\n \n fn main() {"}, {"sha": "8784d7c08d7113a29b890a5919aba81bec944209", "filename": "tests/source/else-if-brace-style-closing-next-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: ClosingNextLine\n \n fn main() {"}, {"sha": "ee24e7426415e1e592a873b6a84fe49f3da42444", "filename": "tests/source/expr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -255,3 +255,20 @@ fn ranges() {\n     // the expr below won't compile for some reason...\n     // let a = 0 ... ;\n }\n+\n+fn if_else() {\n+  let exact = diff /\n+            (if size == 0 {\n+    1\n+} else {\n+    size\n+});\n+\n+            let cx = tp1.x +\n+                 any * radius *\n+                 if anticlockwise {\n+            1.0\n+      } else {\n+           -1.0\n+       };\n+}"}, {"sha": "c19d5d4c01f6082296d78f14f1d4bcc1e605ab26", "filename": "tests/source/hard-tabs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fhard-tabs.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-wrap_comments: true\n // rustfmt-hard_tabs: true\n "}, {"sha": "3780ef7659f4e137bb02b02b21b1a34f5e74b31a", "filename": "tests/source/single-line-if-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fsingle-line-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Fsource%2Fsingle-line-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fsingle-line-if-else.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,4 +1,4 @@\n-// rustfmt-single_line_if_else: true\n+// rustfmt-single_line_if_else_max_width: 100\n \n // Format if-else expressions on a single line, when possible.\n "}, {"sha": "f737745b366770834bddef099febfcd03d1353ab", "filename": "tests/target/chains-block-indented-base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-block-indented-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-block-indented-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-block-indented-base.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chain_base_indent: Inherit\n // Test chain formatting with block indented base\n "}, {"sha": "a6fd0f92a8da2612f62efd2432313631e9f5f6c0", "filename": "tests/target/chains-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chains_overflow_last: false\n // Test chain formatting without overflowing the last item.\n "}, {"sha": "9a13d03d5a29cce94da26c729a5ee86bd4aeed98", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-chain_indent: Visual\n // rustfmt-chain_base_indent: Visual\n // Test chain formatting."}, {"sha": "46bf4eaf354ba7130151d9bd8908a4a98a5841eb", "filename": "tests/target/chains.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // Test chain formatting.\n \n fn main() {"}, {"sha": "ed8a66e2d16ee5c6478f6cee770c04c5342bf054", "filename": "tests/target/closure.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -18,26 +18,20 @@ fn main() {\n     };\n \n     let loooooooooooooong_name = |field| {\n-        // TODO(#27): format comments.\n+        // format comments.\n         if field.node.attrs.len() > 0 {\n             field.node.attrs[0].span.lo\n         } else {\n             field.span.lo\n         }\n     };\n \n-    let block_me = |field| if true_story() {\n-        1\n-    } else {\n-        2\n-    };\n-\n     let unblock_me = |trivial| closure();\n \n     let empty = |arg| {};\n \n     let simple = |arg| {\n-        // TODO(#27): comment formatting\n+        // comment formatting\n         foo(arg)\n     };\n "}, {"sha": "e14bf7d018230ceae378b76a9c355443574b07d3", "filename": "tests/target/else-if-brace-style-always-next-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: AlwaysNextLine\n \n fn main() {"}, {"sha": "e98d9bfc81171de6f5a24651dfd3f2cb536a3904", "filename": "tests/target/else-if-brace-style-always-same-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: AlwaysSameLine\n \n fn main() {"}, {"sha": "7978e3724491d77d573ea2b9a4cc36535f21ca23", "filename": "tests/target/else-if-brace-style-closing-next-line.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-else_if_brace_style: ClosingNextLine\n \n fn main() {"}, {"sha": "87a45a98d494e775829ef228dc165c6bcd75872c", "filename": "tests/target/expr.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -62,11 +62,7 @@ fn foo() -> bool {\n             tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1 + 2 + 3 {\n     }\n \n-    let test = if true {\n-        5\n-    } else {\n-        3\n-    };\n+    let test = if true { 5 } else { 3 };\n \n     if cond() {\n         something();\n@@ -92,11 +88,7 @@ fn bar() {\n     syntactically_correct(loop {\n                               sup('?');\n                           },\n-                          if cond {\n-                              0\n-                          } else {\n-                              1\n-                          });\n+                          if cond { 0 } else { 1 });\n \n     let third = ..10;\n     let infi_range = ..;\n@@ -277,3 +269,9 @@ fn ranges() {\n     // the expr below won't compile for some reason...\n     // let a = 0 ... ;\n }\n+\n+fn if_else() {\n+    let exact = diff / (if size == 0 { 1 } else { size });\n+\n+    let cx = tp1.x + any * radius * if anticlockwise { 1.0 } else { -1.0 };\n+}"}, {"sha": "7fa076b888fa3a3c66fa5c3d37d7629098b74862", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-single_line_if_else_max_width: 0\n // rustfmt-wrap_comments: true\n // rustfmt-hard_tabs: true\n "}, {"sha": "ac55d0621343a300af9a19fed497fb2ba57fc25c", "filename": "tests/target/single-line-if-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fsingle-line-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0570a284c477285e59bb1928b582e7089a597/tests%2Ftarget%2Fsingle-line-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fsingle-line-if-else.rs?ref=98c0570a284c477285e59bb1928b582e7089a597", "patch": "@@ -1,4 +1,4 @@\n-// rustfmt-single_line_if_else: true\n+// rustfmt-single_line_if_else_max_width: 100\n \n // Format if-else expressions on a single line, when possible.\n "}]}