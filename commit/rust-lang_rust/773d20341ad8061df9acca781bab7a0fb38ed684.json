{"sha": "773d20341ad8061df9acca781bab7a0fb38ed684", "node_id": "C_kwDOAAsO6NoAKDc3M2QyMDM0MWFkODA2MWRmOWFjY2E3ODFiYWI3YTBmYjM4ZWQ2ODQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-17T03:55:38Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-17T05:09:25Z"}, "message": "Fix mixed enum variant kinds + code cleanup", "tree": {"sha": "ee3f657dfe10814514c3ef41250b5575fad18694", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee3f657dfe10814514c3ef41250b5575fad18694"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/773d20341ad8061df9acca781bab7a0fb38ed684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/773d20341ad8061df9acca781bab7a0fb38ed684", "html_url": "https://github.com/rust-lang/rust/commit/773d20341ad8061df9acca781bab7a0fb38ed684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/773d20341ad8061df9acca781bab7a0fb38ed684/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08a7157a379ee7f794db386497f5cf1a4ee69fcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/08a7157a379ee7f794db386497f5cf1a4ee69fcc", "html_url": "https://github.com/rust-lang/rust/commit/08a7157a379ee7f794db386497f5cf1a4ee69fcc"}], "stats": {"total": 186, "additions": 123, "deletions": 63}, "files": [{"sha": "b8591fe0db0ad31a3e94fc030f69310a3f137f7f", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/773d20341ad8061df9acca781bab7a0fb38ed684/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773d20341ad8061df9acca781bab7a0fb38ed684/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=773d20341ad8061df9acca781bab7a0fb38ed684", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use core::cmp::Ordering;\n use core::iter;\n+use core::slice;\n use rustc_arena::DroplessArena;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -36,7 +38,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n             normalized_pats[i + 1..]\n                 .iter()\n                 .enumerate()\n-                .find_map(|(j, other)| pat.can_also_match(other).then(|| i + 1 + j))\n+                .find_map(|(j, other)| pat.has_overlapping_values(other).then(|| i + 1 + j))\n                 .unwrap_or(normalized_pats.len())\n         })\n         .collect();\n@@ -52,7 +54,9 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n                 .rev()\n                 .zip(forwards_blocking_idxs[..i].iter().copied().rev())\n                 .skip_while(|&(_, forward_block)| forward_block > i)\n-                .find_map(|((j, other), forward_block)| (forward_block == i || pat.can_also_match(other)).then(|| j))\n+                .find_map(|((j, other), forward_block)| {\n+                    (forward_block == i || pat.has_overlapping_values(other)).then(|| j)\n+                })\n                 .unwrap_or(0)\n         })\n         .collect();\n@@ -159,6 +163,10 @@ enum NormalizedPat<'a> {\n     LitInt(u128),\n     LitBool(bool),\n     Range(PatRange),\n+    /// A slice pattern. If the second value is `None`, then this matches an exact size. Otherwise\n+    /// the first value contains everything before the `..` wildcard pattern, and the second value\n+    /// contains everything afterwards. Note that either side, or both sides, may contain zero\n+    /// patterns.\n     Slice(&'a [Self], Option<&'a [Self]>),\n }\n \n@@ -178,23 +186,43 @@ impl PatRange {\n     }\n \n     fn overlaps(&self, other: &Self) -> bool {\n-        !(self.is_empty() || other.is_empty())\n-            && match self.bounds {\n-                RangeEnd::Included => self.end >= other.start,\n-                RangeEnd::Excluded => self.end > other.start,\n-            }\n-            && match other.bounds {\n-                RangeEnd::Included => self.start <= other.end,\n-                RangeEnd::Excluded => self.start < other.end,\n-            }\n+        // Note: Empty ranges are impossible, so this is correct even though it would return true if an\n+        // empty exclusive range were to reside within an inclusive range.\n+        (match self.bounds {\n+            RangeEnd::Included => self.end >= other.start,\n+            RangeEnd::Excluded => self.end > other.start,\n+        } && match other.bounds {\n+            RangeEnd::Included => self.start <= other.end,\n+            RangeEnd::Excluded => self.start < other.end,\n+        })\n     }\n+}\n \n-    fn is_empty(&self) -> bool {\n-        match self.bounds {\n-            RangeEnd::Included => false,\n-            RangeEnd::Excluded => self.start == self.end,\n+/// Iterates over the pairs of fields with matching names.\n+fn iter_matching_struct_fields<'a>(\n+    left: &'a [(Symbol, NormalizedPat<'a>)],\n+    right: &'a [(Symbol, NormalizedPat<'a>)],\n+) -> impl Iterator<Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>)> + 'a {\n+    struct Iter<'a>(\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+    );\n+    impl<'a> Iterator for Iter<'a> {\n+        type Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>);\n+        fn next(&mut self) -> Option<Self::Item> {\n+            // Note: all the fields in each slice are sorted by symbol value.\n+            let mut left = self.0.next()?;\n+            let mut right = self.1.next()?;\n+            loop {\n+                match left.0.cmp(&right.0) {\n+                    Ordering::Equal => return Some((&left.1, &right.1)),\n+                    Ordering::Less => left = self.0.next()?,\n+                    Ordering::Greater => right = self.1.next()?,\n+                }\n+            }\n         }\n     }\n+    Iter(left.iter(), right.iter())\n }\n \n #[allow(clippy::similar_names)]\n@@ -259,6 +287,7 @@ impl<'a> NormalizedPat<'a> {\n                 Self::Tuple(None, pats)\n             },\n             PatKind::Lit(e) => match &e.kind {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n                 ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n                     LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n@@ -271,6 +300,7 @@ impl<'a> NormalizedPat<'a> {\n                 _ => Self::Wild,\n             },\n             PatKind::Range(start, end, bounds) => {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n                 let start = match start {\n                     None => 0,\n                     Some(e) => match &e.kind {\n@@ -306,42 +336,17 @@ impl<'a> NormalizedPat<'a> {\n \n     /// Checks if two patterns overlap in the values they can match assuming they are for the same\n     /// type.\n-    fn can_also_match(&self, other: &Self) -> bool {\n+    fn has_overlapping_values(&self, other: &Self) -> bool {\n         match (*self, *other) {\n             (Self::Wild, _) | (_, Self::Wild) => true,\n             (Self::Or(pats), ref other) | (ref other, Self::Or(pats)) => {\n-                pats.iter().any(|pat| pat.can_also_match(other))\n+                pats.iter().any(|pat| pat.has_overlapping_values(other))\n             },\n             (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n                 if lpath != rpath {\n                     return false;\n                 }\n-                let mut rfields = rfields.iter();\n-                let mut rfield = match rfields.next() {\n-                    Some(x) => x,\n-                    None => return true,\n-                };\n-                'outer: for lfield in lfields {\n-                    loop {\n-                        if lfield.0 < rfield.0 {\n-                            continue 'outer;\n-                        } else if lfield.0 > rfield.0 {\n-                            rfield = match rfields.next() {\n-                                Some(x) => x,\n-                                None => return true,\n-                            };\n-                        } else if !lfield.1.can_also_match(&rfield.1) {\n-                            return false;\n-                        } else {\n-                            rfield = match rfields.next() {\n-                                Some(x) => x,\n-                                None => return true,\n-                            };\n-                            continue 'outer;\n-                        }\n-                    }\n-                }\n-                true\n+                iter_matching_struct_fields(lfields, rfields).all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n             },\n             (Self::Tuple(lpath, lpats), Self::Tuple(rpath, rpats)) => {\n                 if lpath != rpath {\n@@ -350,7 +355,7 @@ impl<'a> NormalizedPat<'a> {\n                 lpats\n                     .iter()\n                     .zip(rpats.iter())\n-                    .all(|(lpat, rpat)| lpat.can_also_match(rpat))\n+                    .all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n             },\n             (Self::Path(x), Self::Path(y)) => x == y,\n             (Self::LitStr(x), Self::LitStr(y)) => x == y,\n@@ -360,26 +365,38 @@ impl<'a> NormalizedPat<'a> {\n             (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n             (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n             (Self::Slice(lpats, None), Self::Slice(rpats, None)) => {\n-                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.can_also_match(y))\n+                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.has_overlapping_values(y))\n             },\n             (Self::Slice(pats, None), Self::Slice(front, Some(back)))\n             | (Self::Slice(front, Some(back)), Self::Slice(pats, None)) => {\n+                // Here `pats` is an exact size match. If the combined lengths of `front` and `back` are greater\n+                // then the minium length required will be greater than the length of `pats`.\n                 if pats.len() < front.len() + back.len() {\n                     return false;\n                 }\n                 pats[..front.len()]\n                     .iter()\n                     .zip(front.iter())\n                     .chain(pats[pats.len() - back.len()..].iter().zip(back.iter()))\n-                    .all(|(x, y)| x.can_also_match(y))\n+                    .all(|(x, y)| x.has_overlapping_values(y))\n             },\n             (Self::Slice(lfront, Some(lback)), Self::Slice(rfront, Some(rback))) => lfront\n                 .iter()\n                 .zip(rfront.iter())\n                 .chain(lback.iter().rev().zip(rback.iter().rev()))\n-                .all(|(x, y)| x.can_also_match(y)),\n+                .all(|(x, y)| x.has_overlapping_values(y)),\n+\n+            // Enums can mix unit variants with tuple/struct variants. These can never overlap.\n+            (Self::Path(_), Self::Tuple(..) | Self::Struct(..))\n+            | (Self::Tuple(..) | Self::Struct(..), Self::Path(_)) => false,\n+\n+            // Tuples can be matched like a struct.\n+            (Self::Tuple(x, _), Self::Struct(y, _)) | (Self::Struct(x, _), Self::Tuple(y, _)) => {\n+                // TODO: check fields here.\n+                x == y\n+            },\n \n-            // Todo: Lit* with Path, Range with Path, LitBytes with Slice, Slice with Slice\n+            // TODO: Lit* with Path, Range with Path, LitBytes with Slice\n             _ => true,\n         }\n     }"}, {"sha": "f3d818cc3485dd0c617da2a3591418a2b39b032a", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/773d20341ad8061df9acca781bab7a0fb38ed684/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773d20341ad8061df9acca781bab7a0fb38ed684/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=773d20341ad8061df9acca781bab7a0fb38ed684", "patch": "@@ -581,14 +581,19 @@ impl Write {\n             };\n \n             let replacement: String = match lit.token.kind {\n-                LitKind::Integer | LitKind::Float | LitKind::Err => continue,\n                 LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n                 LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n-                LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n+                LitKind::StrRaw(_)\n+                | LitKind::Str\n+                | LitKind::ByteStrRaw(_)\n+                | LitKind::ByteStr\n+                | LitKind::Integer\n+                | LitKind::Float\n+                | LitKind::Err => continue,\n                 LitKind::Byte | LitKind::Char => match lit.token.symbol.as_str() {\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,"}, {"sha": "dbfeb4379d513f7d910ef64346eadf197571ad11", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/773d20341ad8061df9acca781bab7a0fb38ed684/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773d20341ad8061df9acca781bab7a0fb38ed684/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=773d20341ad8061df9acca781bab7a0fb38ed684", "patch": "@@ -204,4 +204,27 @@ fn main() {\n         Foo::Z(_) => 1,\n         _ => 0,\n     };\n+\n+    // Don't lint.\n+    let _ = match 0 {\n+        -2 => 1,\n+        -5..=50 => 2,\n+        -150..=88 => 1,\n+        _ => 3,\n+    };\n+\n+    struct Bar {\n+        x: u32,\n+        y: u32,\n+        z: u32,\n+    }\n+\n+    // Lint.\n+    let _ = match None {\n+        Some(Bar { x: 0, y: 5, .. }) => 1,\n+        Some(Bar { y: 10, z: 0, .. }) => 2,\n+        None => 50,\n+        Some(Bar { y: 0, x: 5, .. }) => 1,\n+        _ => 200,\n+    };\n }"}, {"sha": "14a672ba2fec1d0a5098cb1720566f8639632b1b", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/773d20341ad8061df9acca781bab7a0fb38ed684/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/773d20341ad8061df9acca781bab7a0fb38ed684/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=773d20341ad8061df9acca781bab7a0fb38ed684", "patch": "@@ -40,33 +40,33 @@ LL |         42 => foo(),\n    |         ^^^^^^^^^^^\n \n error: this match arm has an identical body to another arm\n-  --> $DIR/match_same_arms2.rs:39:9\n+  --> $DIR/match_same_arms2.rs:40:9\n    |\n-LL |         Some(_) => 24,\n-   |         -------^^^^^^\n+LL |         None => 24, //~ ERROR match arms have same body\n+   |         ----^^^^^^\n    |         |\n-   |         help: try merging the arm patterns: `Some(_) | None`\n+   |         help: try merging the arm patterns: `None | Some(_)`\n    |\n    = help: or try changing either arm body\n note: other arm here\n-  --> $DIR/match_same_arms2.rs:40:9\n+  --> $DIR/match_same_arms2.rs:39:9\n    |\n-LL |         None => 24, //~ ERROR match arms have same body\n-   |         ^^^^^^^^^^\n+LL |         Some(_) => 24,\n+   |         ^^^^^^^^^^^^^\n \n error: this match arm has an identical body to another arm\n-  --> $DIR/match_same_arms2.rs:61:9\n+  --> $DIR/match_same_arms2.rs:62:9\n    |\n-LL |         (Some(a), None) => bar(a),\n+LL |         (None, Some(a)) => bar(a), //~ ERROR match arms have same body\n    |         ---------------^^^^^^^^^^\n    |         |\n-   |         help: try merging the arm patterns: `(Some(a), None) | (None, Some(a))`\n+   |         help: try merging the arm patterns: `(None, Some(a)) | (Some(a), None)`\n    |\n    = help: or try changing either arm body\n note: other arm here\n-  --> $DIR/match_same_arms2.rs:62:9\n+  --> $DIR/match_same_arms2.rs:61:9\n    |\n-LL |         (None, Some(a)) => bar(a), //~ ERROR match arms have same body\n+LL |         (Some(a), None) => bar(a),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this match arm has an identical body to another arm\n@@ -177,5 +177,20 @@ note: other arm here\n LL |         Foo::X(0) => 1,\n    |         ^^^^^^^^^^^^^^\n \n-error: aborting due to 11 previous errors\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:227:9\n+   |\n+LL |         Some(Bar { y: 0, x: 5, .. }) => 1,\n+   |         ----------------------------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Some(Bar { y: 0, x: 5, .. }) | Some(Bar { x: 0, y: 5, .. })`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:224:9\n+   |\n+LL |         Some(Bar { x: 0, y: 5, .. }) => 1,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n "}]}