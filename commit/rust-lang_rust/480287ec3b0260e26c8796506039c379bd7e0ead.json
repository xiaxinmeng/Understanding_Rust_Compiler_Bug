{"sha": "480287ec3b0260e26c8796506039c379bd7e0ead", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MDI4N2VjM2IwMjYwZTI2Yzg3OTY1MDYwMzljMzc5YmQ3ZTBlYWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2016-09-16T01:18:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2016-09-20T02:18:38Z"}, "message": "librustc: Implement def-use chains and trivial copy propagation on MIR.\n\nThis only supports trivial cases in which there is exactly one def and\none use.", "tree": {"sha": "a31d9ae4975552192e6e3845775bc037a5361db3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a31d9ae4975552192e6e3845775bc037a5361db3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/480287ec3b0260e26c8796506039c379bd7e0ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/480287ec3b0260e26c8796506039c379bd7e0ead", "html_url": "https://github.com/rust-lang/rust/commit/480287ec3b0260e26c8796506039c379bd7e0ead", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/480287ec3b0260e26c8796506039c379bd7e0ead/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6a91812c64a507e3d2ab727824ff9cda8449fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6a91812c64a507e3d2ab727824ff9cda8449fc", "html_url": "https://github.com/rust-lang/rust/commit/2e6a91812c64a507e3d2ab727824ff9cda8449fc"}], "stats": {"total": 592, "additions": 560, "deletions": 32}, "files": [{"sha": "be761c95b6119a40054396a5170b2957308e9669", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -188,6 +188,24 @@ impl<'tcx> Mir<'tcx> {\n         self.temp_decls.len() + 1\n     }\n \n+    pub fn format_local(&self, local: Local) -> String {\n+        let mut index = local.index();\n+        index = match index.checked_sub(self.arg_decls.len()) {\n+            None => return format!(\"{:?}\", Arg::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.var_decls.len()) {\n+            None => return format!(\"{:?}\", Var::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.temp_decls.len()) {\n+            None => return format!(\"{:?}\", Temp::new(index)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        return \"ReturnPointer\".to_string()\n+    }\n+\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_statement_nop(&mut self, location: Location) {\n@@ -844,6 +862,24 @@ impl<'tcx> Lvalue<'tcx> {\n             elem: elem,\n         }))\n     }\n+\n+    pub fn from_local(mir: &Mir<'tcx>, local: Local) -> Lvalue<'tcx> {\n+        let mut index = local.index();\n+        index = match index.checked_sub(mir.arg_decls.len()) {\n+            None => return Lvalue::Arg(Arg(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.var_decls.len()) {\n+            None => return Lvalue::Var(Var(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.temp_decls.len()) {\n+            None => return Lvalue::Temp(Temp(index as u32)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        Lvalue::ReturnPointer\n+    }\n }\n \n impl<'tcx> Debug for Lvalue<'tcx> {\n@@ -1278,3 +1314,13 @@ impl fmt::Debug for Location {\n         write!(fmt, \"{:?}[{}]\", self.block, self.statement_index)\n     }\n }\n+\n+impl Location {\n+    pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n+        if self.block == other.block {\n+            self.statement_index <= other.statement_index\n+        } else {\n+            dominators.is_dominated_by(other.block, self.block)\n+        }\n+    }\n+}"}, {"sha": "2c58d35973e73a2c6b7880875cf0824e10016ff4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 103, "deletions": 5, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -150,7 +150,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 self.super_lvalue(lvalue, context, location);\n             }\n@@ -581,7 +581,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n@@ -606,7 +606,12 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* base,\n                     ref $($mutability)* elem,\n                 } = *proj;\n-                self.visit_lvalue(base, LvalueContext::Projection, location);\n+                let context = if context.is_mutating_use() {\n+                    LvalueContext::Projection(Mutability::Mut)\n+                } else {\n+                    LvalueContext::Projection(Mutability::Not)\n+                };\n+                self.visit_lvalue(base, context, location);\n                 self.visit_projection_elem(elem, context, location);\n             }\n \n@@ -751,6 +756,21 @@ macro_rules! make_mir_visitor {\n \n             fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n             }\n+\n+            // Convenience methods\n+\n+            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)* mir[location.block];\n+                if basic_block.statements.len() == location.statement_index {\n+                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                        self.visit_terminator(location.block, terminator, location)\n+                    }\n+                } else {\n+                    let statement = & $($mutability)*\n+                        basic_block.statements[location.statement_index];\n+                    self.visit_statement(location.block, statement, location)\n+                }\n+            }\n         }\n     }\n }\n@@ -775,8 +795,20 @@ pub enum LvalueContext<'tcx> {\n     // Being borrowed\n     Borrow { region: &'tcx Region, kind: BorrowKind },\n \n-    // Used as base for another lvalue, e.g. `x` in `x.y`\n-    Projection,\n+    // Used as base for another lvalue, e.g. `x` in `x.y`.\n+    //\n+    // The `Mutability` argument specifies whether the projection is being performed in order to\n+    // (potentially) mutate the lvalue. For example, the projection `x.y` is marked as a mutation\n+    // in these cases:\n+    //\n+    //     x.y = ...;\n+    //     f(&mut x.y);\n+    //\n+    // But not in these cases:\n+    //\n+    //     z = x.y;\n+    //     f(&x.y);\n+    Projection(Mutability),\n \n     // Consumed as part of an operand\n     Consume,\n@@ -785,3 +817,69 @@ pub enum LvalueContext<'tcx> {\n     StorageLive,\n     StorageDead,\n }\n+\n+impl<'tcx> LvalueContext<'tcx> {\n+    /// Returns true if this lvalue context represents a drop.\n+    pub fn is_drop(&self) -> bool {\n+        match *self {\n+            LvalueContext::Drop => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live or storage dead marker.\n+    pub fn is_storage_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live marker.\n+    pub fn is_storage_live_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage dead marker.\n+    pub fn is_storage_dead_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that potentially changes the value.\n+    pub fn is_mutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Store | LvalueContext::Call |\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } |\n+            LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop => true,\n+            LvalueContext::Inspect |\n+            LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that does not change the value.\n+    pub fn is_nonmutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Inspect | LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n+            LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    pub fn is_use(&self) -> bool {\n+        self.is_mutating_use() || self.is_nonmutating_use()\n+    }\n+}\n+"}, {"sha": "6346c1e58897e12e62d32e05abc82e3c38c80fc3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -438,6 +438,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n+            StatementKind::Nop => {}\n         }\n     }\n "}, {"sha": "55892801247b5459a5420c43fadd2155c7b4510b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -1028,6 +1028,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // No lifetime analysis based on borrowing can be done from here on out.\n         passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n         passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n+        passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n \n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));"}, {"sha": "7329a20c497082d431b688aa306f0b3ec50c685f", "filename": "src/librustc_mir/def_use.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Def-use analysis.\n+\n+use rustc::mir::repr::{Local, Location, Lvalue, Mir};\n+use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::marker::PhantomData;\n+use std::mem;\n+\n+pub struct DefUseAnalysis<'tcx> {\n+    info: IndexVec<Local, Info<'tcx>>,\n+    mir_summary: MirSummary,\n+}\n+\n+#[derive(Clone)]\n+pub struct Info<'tcx> {\n+    pub defs_and_uses: Vec<Use<'tcx>>,\n+}\n+\n+#[derive(Clone)]\n+pub struct Use<'tcx> {\n+    pub context: LvalueContext<'tcx>,\n+    pub location: Location,\n+}\n+\n+impl<'tcx> DefUseAnalysis<'tcx> {\n+    pub fn new(mir: &Mir<'tcx>) -> DefUseAnalysis<'tcx> {\n+        DefUseAnalysis {\n+            info: IndexVec::from_elem_n(Info::new(), mir.count_locals()),\n+            mir_summary: MirSummary::new(mir),\n+        }\n+    }\n+\n+    pub fn analyze(&mut self, mir: &Mir<'tcx>) {\n+        let mut finder = DefUseFinder {\n+            info: mem::replace(&mut self.info, IndexVec::new()),\n+            mir_summary: self.mir_summary,\n+        };\n+        finder.visit_mir(mir);\n+        self.info = finder.info\n+    }\n+\n+    pub fn local_info(&self, local: Local) -> &Info<'tcx> {\n+        &self.info[local]\n+    }\n+\n+    pub fn local_info_mut(&mut self, local: Local) -> &mut Info<'tcx> {\n+        &mut self.info[local]\n+    }\n+\n+    fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n+                               where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n+                                                      LvalueContext<'tcx>,\n+                                                      Location) {\n+        for lvalue_use in &self.info[local].defs_and_uses {\n+            MutateUseVisitor::new(local,\n+                                  &mut callback,\n+                                  self.mir_summary,\n+                                  mir).visit_location(mir, lvalue_use.location)\n+        }\n+    }\n+\n+    /// FIXME(pcwalton): This should update the def-use chains.\n+    pub fn replace_all_defs_and_uses_with(&self,\n+                                          local: Local,\n+                                          mir: &mut Mir<'tcx>,\n+                                          new_lvalue: Lvalue<'tcx>) {\n+        self.mutate_defs_and_uses(local, mir, |lvalue, _, _| *lvalue = new_lvalue.clone())\n+    }\n+}\n+\n+struct DefUseFinder<'tcx> {\n+    info: IndexVec<Local, Info<'tcx>>,\n+    mir_summary: MirSummary,\n+}\n+\n+impl<'tcx> DefUseFinder<'tcx> {\n+    fn lvalue_mut_info(&mut self, lvalue: &Lvalue<'tcx>) -> Option<&mut Info<'tcx>> {\n+        let info = &mut self.info;\n+        self.mir_summary.local_index(lvalue).map(move |local| &mut info[local])\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DefUseFinder<'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Some(ref mut info) = self.lvalue_mut_info(lvalue) {\n+            info.defs_and_uses.push(Use {\n+                context: context,\n+                location: location,\n+            })\n+        }\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+impl<'tcx> Info<'tcx> {\n+    fn new() -> Info<'tcx> {\n+        Info {\n+            defs_and_uses: vec![],\n+        }\n+    }\n+\n+    pub fn def_count(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| lvalue_use.context.is_mutating_use()).count()\n+    }\n+\n+    pub fn def_count_not_including_drop(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| {\n+            lvalue_use.context.is_mutating_use() && !lvalue_use.context.is_drop()\n+        }).count()\n+    }\n+\n+    pub fn use_count(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| {\n+            lvalue_use.context.is_nonmutating_use()\n+        }).count()\n+    }\n+}\n+\n+struct MutateUseVisitor<'tcx, F> {\n+    query: Local,\n+    callback: F,\n+    mir_summary: MirSummary,\n+    phantom: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n+    fn new(query: Local, callback: F, mir_summary: MirSummary, _: &Mir<'tcx>)\n+           -> MutateUseVisitor<'tcx, F>\n+           where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+        MutateUseVisitor {\n+            query: query,\n+            callback: callback,\n+            mir_summary: mir_summary,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n+              where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if self.mir_summary.local_index(lvalue) == Some(self.query) {\n+            (self.callback)(lvalue, context, location)\n+        }\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+/// A small structure that enables various metadata of the MIR to be queried\n+/// without a reference to the MIR itself.\n+#[derive(Clone, Copy)]\n+struct MirSummary {\n+    arg_count: usize,\n+    var_count: usize,\n+    temp_count: usize,\n+}\n+\n+impl MirSummary {\n+    fn new(mir: &Mir) -> MirSummary {\n+        MirSummary {\n+            arg_count: mir.arg_decls.len(),\n+            var_count: mir.var_decls.len(),\n+            temp_count: mir.temp_decls.len(),\n+        }\n+    }\n+\n+    fn local_index<'tcx>(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n+        match *lvalue {\n+            Lvalue::Arg(arg) => Some(Local::new(arg.index())),\n+            Lvalue::Var(var) => Some(Local::new(var.index() + self.arg_count)),\n+            Lvalue::Temp(temp) => {\n+                Some(Local::new(temp.index() + self.arg_count + self.var_count))\n+            }\n+            Lvalue::ReturnPointer => {\n+                Some(Local::new(self.arg_count + self.var_count + self.temp_count))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+"}, {"sha": "12f1eb8535a3eb7bd27a48a060988b326d3ed06d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -46,8 +46,10 @@ extern crate rustc_const_eval;\n pub mod diagnostics;\n \n pub mod build;\n+pub mod def_use;\n pub mod graphviz;\n mod hair;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n+"}, {"sha": "33f3d6d8842eae5ccb623f5699a5c063857ea323", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Trivial copy propagation pass.\n+//!\n+//! This uses def-use analysis to remove values that have exactly one def and one use, which must\n+//! be an assignment.\n+//!\n+//! To give an example, we look for patterns that look like:\n+//!\n+//!     DEST = SRC\n+//!     ...\n+//!     USE(DEST)\n+//!\n+//! where `DEST` and `SRC` are both locals of some form. We replace that with:\n+//!\n+//!     NOP\n+//!     ...\n+//!     USE(SRC)\n+//!\n+//! The assignment `DEST = SRC` must be (a) the only mutation of `DEST` and (b) the only\n+//! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n+//! future.\n+\n+use def_use::DefUseAnalysis;\n+use rustc::mir::repr::{Local, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+pub struct CopyPropagation;\n+\n+impl Pass for CopyPropagation {}\n+\n+impl<'tcx> MirPass<'tcx> for CopyPropagation {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+        loop {\n+            let mut def_use_analysis = DefUseAnalysis::new(mir);\n+            def_use_analysis.analyze(mir);\n+\n+            let mut changed = false;\n+            for dest_local_index in 0..mir.count_locals() {\n+                let dest_local = Local::new(dest_local_index);\n+                debug!(\"Considering destination local: {}\", mir.format_local(dest_local));\n+\n+                let src_local;\n+                let location;\n+                {\n+                    // The destination must have exactly one def.\n+                    let dest_use_info = def_use_analysis.local_info(dest_local);\n+                    let dest_def_count = dest_use_info.def_count_not_including_drop();\n+                    if dest_def_count == 0 {\n+                        debug!(\"  Can't copy-propagate local: dest {} undefined\",\n+                               mir.format_local(dest_local));\n+                        continue\n+                    }\n+                    if dest_def_count > 1 {\n+                        debug!(\"  Can't copy-propagate local: dest {} defined {} times\",\n+                               mir.format_local(dest_local),\n+                               dest_use_info.def_count());\n+                        continue\n+                    }\n+                    if dest_use_info.use_count() == 0 {\n+                        debug!(\"  Can't copy-propagate local: dest {} unused\",\n+                               mir.format_local(dest_local));\n+                        continue\n+                    }\n+                    let dest_lvalue_def = dest_use_info.defs_and_uses.iter().filter(|lvalue_def| {\n+                        lvalue_def.context.is_mutating_use() && !lvalue_def.context.is_drop()\n+                    }).next().unwrap();\n+                    location = dest_lvalue_def.location;\n+\n+                    let basic_block = &mir[location.block];\n+                    let statement_index = location.statement_index;\n+                    let statement = match basic_block.statements.get(statement_index) {\n+                        Some(statement) => statement,\n+                        None => {\n+                            debug!(\"  Can't copy-propagate local: used in terminator\");\n+                            continue\n+                        }\n+                    };\n+\n+                    // That use of the source must be an assignment.\n+                    let src_lvalue = match statement.kind {\n+                        StatementKind::Assign(\n+                                ref dest_lvalue,\n+                                Rvalue::Use(Operand::Consume(ref src_lvalue)))\n+                                if Some(dest_local) == mir.local_index(dest_lvalue) => {\n+                            src_lvalue\n+                        }\n+                        _ => {\n+                            debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                            continue\n+                        }\n+                    };\n+                    src_local = match mir.local_index(src_lvalue) {\n+                        Some(src_local) => src_local,\n+                        None => {\n+                            debug!(\"  Can't copy-propagate local: source is not a local\");\n+                            continue\n+                        }\n+                    };\n+\n+                    // There must be exactly one use of the source used in a statement (not in a\n+                    // terminator).\n+                    let src_use_info = def_use_analysis.local_info(src_local);\n+                    let src_use_count = src_use_info.use_count();\n+                    if src_use_count == 0 {\n+                        debug!(\"  Can't copy-propagate local: no uses\");\n+                        continue\n+                    }\n+                    if src_use_count != 1 {\n+                        debug!(\"  Can't copy-propagate local: {} uses\", src_use_info.use_count());\n+                        continue\n+                    }\n+\n+                    // Verify that the source doesn't change in between. This is done\n+                    // conservatively for now, by ensuring that the source has exactly one\n+                    // mutation. The goal is to prevent things like:\n+                    //\n+                    //     DEST = SRC;\n+                    //     SRC = X;\n+                    //     USE(DEST);\n+                    //\n+                    // From being misoptimized into:\n+                    //\n+                    //     SRC = X;\n+                    //     USE(SRC);\n+                    let src_def_count = src_use_info.def_count_not_including_drop();\n+                    if src_def_count != 1 {\n+                        debug!(\"  Can't copy-propagate local: {} defs of src\",\n+                               src_use_info.def_count_not_including_drop());\n+                        continue\n+                    }\n+                }\n+\n+                // If all checks passed, then we can eliminate the destination and the assignment.\n+                //\n+                // First, remove all markers.\n+                //\n+                // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n+                debug!(\"  Replacing all uses of {}\", mir.format_local(dest_local));\n+                for lvalue_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n+                    if lvalue_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(lvalue_use.location)\n+                    }\n+                }\n+                for lvalue_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n+                    if lvalue_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(lvalue_use.location)\n+                    }\n+                }\n+\n+                // Now replace all uses of the destination local with the source local.\n+                let src_lvalue = Lvalue::from_local(mir, src_local);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n+\n+                // Finally, zap the now-useless assignment instruction.\n+                mir.make_statement_nop(location);\n+\n+                changed = true;\n+                // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n+                // regenerating the chains.\n+                break\n+            }\n+            if !changed {\n+                break\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "7bcb89b5895e78698dc13eac93643c74ce64fc1b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -19,4 +19,4 @@ pub mod qualify_consts;\n pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n-\n+pub mod copy_prop;"}, {"sha": "57de68fce1d1a4543e435b08bf4cc0b847fa00ba", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -328,7 +328,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext,\n+                    context: LvalueContext<'tcx>,\n                     location: Location) {\n         if let Lvalue::Temp(ref mut temp) = *lvalue {\n             *temp = self.promote_temp(*temp);"}, {"sha": "c3a22853f84373b7aa484b86a465201ce4159b38", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -475,7 +475,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext, location: Location) {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n         match *lvalue {\n             Lvalue::Arg(_) => {\n                 self.add(Qualif::FN_ARGUMENT);"}, {"sha": "6648944540e3b3e855038868cddad4cb6500a25e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext,\n+                    context: mir_visit::LvalueContext<'tcx>,\n                     location: Location) {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n "}, {"sha": "5de59b9f6bded47cb54591fbbfb25195b4a5b1a5", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -147,7 +147,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: LvalueContext,\n+                    context: LvalueContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n@@ -180,7 +180,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 LvalueContext::Store |\n                 LvalueContext::Inspect |\n                 LvalueContext::Borrow { .. } |\n-                LvalueContext::Projection => {\n+                LvalueContext::Projection(..) => {\n                     self.mark_as_lvalue(index);\n                 }\n "}, {"sha": "891ca03cc4dd52f4696a2e52660453e71137e1db", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -23,9 +23,9 @@ fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 0\n // CHECK: store i8* %0, i8** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 1\n // CHECK: store [[USIZE]] %1, [[USIZE]]* [[X1]]\n \n     let x = &*s;"}, {"sha": "8782dcf8898b7405fd5cb2b7a799ffad4a7e4efb", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480287ec3b0260e26c8796506039c379bd7e0ead/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=480287ec3b0260e26c8796506039c379bd7e0ead", "patch": "@@ -21,27 +21,27 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.PreTrans.after.mir\n //     bb0: {\n-//         StorageLive(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n-//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:12:13: 12:14\n-//         StorageLive(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n-//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp2 = var0;                     // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:14:17: 14:25\n-//         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp0 = ();                       // scope 2 at storage_ranges.rs:13:5: 15:6\n-//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         StorageDead(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n-//         StorageLive(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n-//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:16:13: 16:14\n-//         return = ();                     // scope 3 at storage_ranges.rs:11:11: 17:2\n-//         StorageDead(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n-//         StorageDead(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n-//         goto -> bb1;                     // scope 0 at storage_ranges.rs:11:1: 17:2\n+//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:14:13: 14:14\n+//         StorageLive(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n+//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp1 = std::option::Option<i32>::Some(var0,); // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:16:17: 16:25\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp0 = ();                       // scope 2 at storage_ranges.rs:15:5: 17:6\n+//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         StorageDead(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n+//         StorageLive(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n+//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:18:13: 18:14\n+//         return = ();                     // scope 3 at storage_ranges.rs:13:11: 19:2\n+//         StorageDead(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n+//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         goto -> bb1;                     // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n //\n //     bb1: {\n-//         return;                          // scope 0 at storage_ranges.rs:11:1: 17:2\n+//         return;                          // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n // END rustc.node4.PreTrans.after.mir"}]}