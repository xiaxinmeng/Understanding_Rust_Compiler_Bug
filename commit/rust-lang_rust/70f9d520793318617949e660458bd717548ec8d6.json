{"sha": "70f9d520793318617949e660458bd717548ec8d6", "node_id": "C_kwDOAAsO6NoAKDcwZjlkNTIwNzkzMzE4NjE3OTQ5ZTY2MDQ1OGJkNzE3NTQ4ZWM4ZDY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-20T15:59:56Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-20T17:40:50Z"}, "message": "Add and use expect methods to hir.", "tree": {"sha": "48b7ad8e2b2cd1601c496733c2b44d063af8fd76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b7ad8e2b2cd1601c496733c2b44d063af8fd76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70f9d520793318617949e660458bd717548ec8d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70f9d520793318617949e660458bd717548ec8d6", "html_url": "https://github.com/rust-lang/rust/commit/70f9d520793318617949e660458bd717548ec8d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70f9d520793318617949e660458bd717548ec8d6/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "url": "https://api.github.com/repos/rust-lang/rust/commits/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15", "html_url": "https://github.com/rust-lang/rust/commit/56ee85274e5a3a4dda92f3bf73d1664c74ff9c15"}], "stats": {"total": 379, "additions": 356, "deletions": 23}, "files": [{"sha": "4640317ac7328a2b49538480d78a69fdc019962c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 340, "deletions": 3, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -2263,7 +2263,7 @@ pub struct TraitItem<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-impl TraitItem<'_> {\n+impl<'hir> TraitItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2273,6 +2273,27 @@ impl TraitItem<'_> {\n     pub fn trait_item_id(&self) -> TraitItemId {\n         TraitItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`TraitItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, Option<BodyId>) {\n+        let TraitItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &TraitFn<'hir>) {\n+        let TraitItemKind::Fn(ty, trfn) = &self.kind else { unreachable!() };\n+        (ty, trfn)\n+    }\n+\n+    /// Expect an [`TraitItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> (GenericBounds<'hir>, Option<&'hir Ty<'hir>>) {\n+        let TraitItemKind::Type(bounds, ty) = self.kind else { unreachable!() };\n+        (bounds, ty)\n+    }\n }\n \n /// Represents a trait method's body (or just argument names).\n@@ -2325,7 +2346,7 @@ pub struct ImplItem<'hir> {\n     pub vis_span: Span,\n }\n \n-impl ImplItem<'_> {\n+impl<'hir> ImplItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2335,6 +2356,27 @@ impl ImplItem<'_> {\n     pub fn impl_item_id(&self) -> ImplItemId {\n         ImplItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ImplItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ImplItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, BodyId) {\n+        let ImplItemKind::Fn(ty, body) = &self.kind else { unreachable!() };\n+        (ty, *body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> &'hir Ty<'hir> {\n+        let ImplItemKind::Type(ty) = self.kind else { unreachable!() };\n+        ty\n+    }\n }\n \n /// Represents various kinds of content within an `impl`.\n@@ -2995,7 +3037,7 @@ pub struct Item<'hir> {\n     pub vis_span: Span,\n }\n \n-impl Item<'_> {\n+impl<'hir> Item<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -3005,6 +3047,127 @@ impl Item<'_> {\n     pub fn item_id(&self) -> ItemId {\n         ItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_extern_crate(&self) -> Option<Symbol> {\n+        let ItemKind::ExternCrate(s) = self.kind else { unreachable!() };\n+        s\n+    }\n+\n+    /// Expect an [`ItemKind::Use`] or panic.\n+    #[track_caller]\n+    pub fn expect_use(&self) -> (&'hir UsePath<'hir>, UseKind) {\n+        let ItemKind::Use(p, uk) = self.kind else { unreachable!() };\n+        (p, uk)\n+    }\n+\n+    /// Expect an [`ItemKind::Static`] or panic.\n+    #[track_caller]\n+    pub fn expect_static(&self) -> (&'hir Ty<'hir>, Mutability, BodyId) {\n+        let ItemKind::Static(ty, mutbl, body) = self.kind else { unreachable!() };\n+        (ty, mutbl, body)\n+    }\n+    /// Expect an [`ItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        (ty, body)\n+    }\n+    /// Expect an [`ItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &'hir Generics<'hir>, BodyId) {\n+        let ItemKind::Fn(sig, gen, body) = &self.kind else { unreachable!() };\n+        (sig, gen, *body)\n+    }\n+\n+    /// Expect an [`ItemKind::Macro`] or panic.\n+    #[track_caller]\n+    pub fn expect_macro(&self) -> (&ast::MacroDef, MacroKind) {\n+        let ItemKind::Macro(def, mk) = &self.kind else { unreachable!() };\n+        (def, *mk)\n+    }\n+\n+    /// Expect an [`ItemKind::Mod`] or panic.\n+    #[track_caller]\n+    pub fn expect_mod(&self) -> &'hir Mod<'hir> {\n+        let ItemKind::Mod(m) = self.kind else { unreachable!() };\n+        m\n+    }\n+\n+    /// Expect an [`ItemKind::ForeignMod`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_mod(&self) -> (Abi, &'hir [ForeignItemRef]) {\n+        let ItemKind::ForeignMod { abi, items } = self.kind else { unreachable!() };\n+        (abi, items)\n+    }\n+\n+    /// Expect an [`ItemKind::GlobalAsm`] or panic.\n+    #[track_caller]\n+    pub fn expect_global_asm(&self) -> &'hir InlineAsm<'hir> {\n+        let ItemKind::GlobalAsm(asm) = self.kind else { unreachable!() };\n+        asm\n+    }\n+\n+    /// Expect an [`ItemKind::TyAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty_alias(&self) -> (&'hir Ty<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::TyAlias(ty, gen) = self.kind else { unreachable!() };\n+        (ty, gen)\n+    }\n+\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n+    /// Expect an [`ItemKind::OpaqueTy`] or panic.\n+    #[track_caller]\n+    pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n+        let ItemKind::OpaqueTy(ty) = &self.kind else { unreachable!() };\n+        ty\n+    }\n+\n+    /// Expect an [`ItemKind::Enum`] or panic.\n+    #[track_caller]\n+    pub fn expect_enum(&self) -> (&EnumDef<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Enum(def, gen) = &self.kind else { unreachable!() };\n+        (def, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Struct`] or panic.\n+    #[track_caller]\n+    pub fn expect_struct(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Struct(data, gen) = &self.kind else { unreachable!() };\n+        (data, gen)\n+    }\n+\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n+    /// Expect an [`ItemKind::Union`] or panic.\n+    #[track_caller]\n+    pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Union(data, gen) = &self.kind else { unreachable!() };\n+        (data, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Trait`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait(\n+        self,\n+    ) -> (IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]) {\n+        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { unreachable!() };\n+        (is_auto, unsafety, gen, bounds, items)\n+    }\n+\n+    /// Expect an [`ItemKind::TraitAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_alias(&self) -> (&'hir Generics<'hir>, GenericBounds<'hir>) {\n+        let ItemKind::TraitAlias(gen, bounds) = self.kind else { unreachable!() };\n+        (gen, bounds)\n+    }\n+\n+    /// Expect an [`ItemKind::Impl`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl(&self) -> &'hir Impl<'hir> {\n+        let ItemKind::Impl(imp) = self.kind else { unreachable!() };\n+        imp\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -3590,6 +3753,180 @@ impl<'hir> Node<'hir> {\n     pub fn tuple_fields(&self) -> Option<&'hir [FieldDef<'hir>]> {\n         if let Node::Ctor(&VariantData::Tuple(fields, _, _)) = self { Some(fields) } else { None }\n     }\n+\n+    /// Expect a [`Node::Param`] or panic.\n+    #[track_caller]\n+    pub fn expect_param(self) -> &'hir Param<'hir> {\n+        let Node::Param(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Item`] or panic.\n+    #[track_caller]\n+    pub fn expect_item(self) -> &'hir Item<'hir> {\n+        let Node::Item(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ForeignItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n+        let Node::ForeignItem(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n+        let Node::TraitItem(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ImplItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n+        let Node::ImplItem(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Variant`] or panic.\n+    #[track_caller]\n+    pub fn expect_variant(self) -> &'hir Variant<'hir> {\n+        let Node::Variant(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Field`] or panic.\n+    #[track_caller]\n+    pub fn expect_field(self) -> &'hir FieldDef<'hir> {\n+        let Node::Field(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::AnonConst`] or panic.\n+    #[track_caller]\n+    pub fn expect_anon_const(self) -> &'hir AnonConst {\n+        let Node::AnonConst(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Expr`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr(self) -> &'hir Expr<'hir> {\n+        let Node::Expr(this) = self else { unreachable!() };\n+        this\n+    }\n+    /// Expect a [`Node::ExprField`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr_field(self) -> &'hir ExprField<'hir> {\n+        let Node::ExprField(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Stmt`] or panic.\n+    #[track_caller]\n+    pub fn expect_stmt(self) -> &'hir Stmt<'hir> {\n+        let Node::Stmt(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PathSegment`] or panic.\n+    #[track_caller]\n+    pub fn expect_path_segment(self) -> &'hir PathSegment<'hir> {\n+        let Node::PathSegment(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ty`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty(self) -> &'hir Ty<'hir> {\n+        let Node::Ty(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TypeBinding`] or panic.\n+    #[track_caller]\n+    pub fn expect_type_binding(self) -> &'hir TypeBinding<'hir> {\n+        let Node::TypeBinding(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitRef`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_ref(self) -> &'hir TraitRef<'hir> {\n+        let Node::TraitRef(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Pat`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat(self) -> &'hir Pat<'hir> {\n+        let Node::Pat(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PatField`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat_field(self) -> &'hir PatField<'hir> {\n+        let Node::PatField(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Arm`] or panic.\n+    #[track_caller]\n+    pub fn expect_arm(self) -> &'hir Arm<'hir> {\n+        let Node::Arm(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Block`] or panic.\n+    #[track_caller]\n+    pub fn expect_block(self) -> &'hir Block<'hir> {\n+        let Node::Block(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Local`] or panic.\n+    #[track_caller]\n+    pub fn expect_local(self) -> &'hir Local<'hir> {\n+        let Node::Local(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ctor`] or panic.\n+    #[track_caller]\n+    pub fn expect_ctor(self) -> &'hir VariantData<'hir> {\n+        let Node::Ctor(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Lifetime`] or panic.\n+    #[track_caller]\n+    pub fn expect_lifetime(self) -> &'hir Lifetime {\n+        let Node::Lifetime(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::GenericParam`] or panic.\n+    #[track_caller]\n+    pub fn expect_generic_param(self) -> &'hir GenericParam<'hir> {\n+        let Node::GenericParam(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Crate`] or panic.\n+    #[track_caller]\n+    pub fn expect_crate(self) -> &'hir Mod<'hir> {\n+        let Node::Crate(this) = self else { unreachable!() };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Infer`] or panic.\n+    #[track_caller]\n+    pub fn expect_infer(self) -> &'hir InferArg {\n+        let Node::Infer(this) = self else { unreachable!() };\n+        this\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "1b7509d6d421d8fe7781fde00d355bbc00d22dbd", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -3124,8 +3124,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n             hir.get(fn_hir_id) else { return None };\n-        let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n-                hir.get_parent(fn_hir_id) else { bug!(\"ImplItem should have Impl parent\") };\n+        let i = hir.get_parent(fn_hir_id).expect_item().expect_impl();\n \n         let trait_ref = self.instantiate_mono_trait_ref(\n             i.of_trait.as_ref()?,"}, {"sha": "53f5cb2cc9a7cb97880e7252dbe7829ce51f2abf", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n-use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_hir::{GenericParamKind, ImplItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n@@ -916,7 +916,7 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let (sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n             let span = tcx\n                 .hir()\n                 .body_param_names(body)\n@@ -1078,12 +1078,12 @@ fn extract_spans_for_error_reporting<'tcx>(\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n-        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (sig, _) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n \n     let trait_args = trait_m.def_id.as_local().map(|def_id| {\n-        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        let (sig, _) = tcx.hir().expect_trait_item(def_id).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     });\n \n@@ -1356,7 +1356,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             .def_id\n             .as_local()\n             .and_then(|def_id| {\n-                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let (trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).expect_fn();\n                 let pos = trait_number_args.saturating_sub(1);\n                 trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n@@ -1368,7 +1368,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             })\n             .or(trait_item_span);\n \n-        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n         let impl_span = impl_m_sig\n             .decl\n@@ -1704,7 +1704,7 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        let (ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).expect_const();\n         cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n@@ -1717,7 +1717,7 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            let (ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).expect_const();\n             ty.span\n         });\n "}, {"sha": "dd8ecd670cb0f949e8d563e0c43ed212e45c4e6c", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -1053,8 +1053,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n                     hir_ty.span,\n@@ -1087,8 +1087,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             {\n                 let last = idx == variant.fields.len() - 1;\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new("}, {"sha": "cd63235857b229f5b1dafaa44044319e90a40e8b", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -54,7 +54,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n+    let impl_ = tcx.hir().expect_item(impl_did).expect_impl();\n \n     tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }"}, {"sha": "c6b16171311fb0de221c0bbcb9c2c667a7aba35d", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -3,15 +3,13 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::Unsafety;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::LocalDefId;\n \n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = item.expect_impl();\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "1cbface07429a6dc0ff43d4fbc8f561840754a04", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f9d520793318617949e660458bd717548ec8d6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=70f9d520793318617949e660458bd717548ec8d6", "patch": "@@ -1342,8 +1342,7 @@ fn suggest_impl_trait<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = tcx.hir().expect_item(def_id.expect_local()).expect_impl();\n     impl_\n         .of_trait\n         .as_ref()"}]}