{"sha": "727c7c74994cf54baecab8ab6b03c50ace44d634", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyN2M3Yzc0OTk0Y2Y1NGJhZWNhYjhhYjZiMDNjNTBhY2U0NGQ2MzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T21:24:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T21:25:53Z"}, "message": "rustc: Add stub support for struct variants to the AST", "tree": {"sha": "7a3d1ae73f49614ed0163ba20a03f23451d69f00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a3d1ae73f49614ed0163ba20a03f23451d69f00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/727c7c74994cf54baecab8ab6b03c50ace44d634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/727c7c74994cf54baecab8ab6b03c50ace44d634", "html_url": "https://github.com/rust-lang/rust/commit/727c7c74994cf54baecab8ab6b03c50ace44d634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/727c7c74994cf54baecab8ab6b03c50ace44d634/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc267c696c015525ea303e03d448d1507b6afeb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc267c696c015525ea303e03d448d1507b6afeb6", "html_url": "https://github.com/rust-lang/rust/commit/bc267c696c015525ea303e03d448d1507b6afeb6"}], "stats": {"total": 381, "additions": 237, "deletions": 144}, "files": [{"sha": "87fe7fe67a97159b658e9a18416816d205a84ee8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -632,7 +632,13 @@ type foreign_mod =\n type variant_arg = {ty: @ty, id: node_id};\n \n #[auto_serialize]\n-type variant_ = {name: ident, attrs: ~[attribute], args: ~[variant_arg],\n+enum variant_kind {\n+    tuple_variant_kind(~[variant_arg]),\n+    struct_variant_kind\n+}\n+\n+#[auto_serialize]\n+type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: option<@expr>, vis: visibility};\n \n #[auto_serialize]"}, {"sha": "7d7867d05160eb6e04390a5bf6c9bf19b73891d4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -187,12 +187,13 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for m.items.each |it| {\n         if it.ident == i { local = true; }\n         match it.node {\n-          item_enum(variants, _) => for variants.each |v| {\n-            if v.node.name == i {\n-                local = true;\n-                parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n+          item_enum(variants, _) =>\n+            for variants.each |v| {\n+                if v.node.name == i {\n+                    local = true;\n+                    parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n+                }\n             }\n-          },\n           _ => ()\n         }\n         if local { break; }"}, {"sha": "4ce017eeae9acea1c6072be82418fee7ec1ec097", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -830,43 +830,51 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let variant_tys = vec::map(variant.node.args, |a| a.ty);\n-\n-        ser_variant(\n-            cx, tps, variant_tys, v_span, cx.clone(s),\n-\n-            // Generate pattern var(v1, v2, v3)\n-            |pats| {\n-                if vec::is_empty(pats) {\n-                    ast::pat_ident(ast::bind_by_implicit_ref,\n-                                   cx.path(v_span, ~[v_name]),\n-                                   none)\n-                } else {\n-                    ast::pat_enum(cx.path(v_span, ~[v_name]), some(pats))\n-                }\n-            },\n-\n-            // Generate body s.emit_enum_variant(\"foo\", 0u,\n-            //                                   3u, {|| blk })\n-            |-s, blk| {\n-                let v_name = cx.lit_str(v_span, v_name);\n-                let v_id = cx.lit_uint(v_span, vidx);\n-                let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n-                let body = cx.lambda(blk);\n-                #ast[expr]{\n-                    $(s).emit_enum_variant($(v_name), $(v_id),\n-                                           $(sz), $(body))\n-                }\n-            },\n-\n-            // Generate s.emit_enum_variant_arg(i, {|| blk })\n-            |-s, i, blk| {\n-                let idx = cx.lit_uint(v_span, i);\n-                let body = cx.lambda(blk);\n-                #ast[expr]{\n-                    $(s).emit_enum_variant_arg($(idx), $(body))\n-                }\n-            })\n+\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                let variant_tys = vec::map(args, |a| a.ty);\n+\n+                ser_variant(\n+                    cx, tps, variant_tys, v_span, cx.clone(s),\n+\n+                    // Generate pattern var(v1, v2, v3)\n+                    |pats| {\n+                        if vec::is_empty(pats) {\n+                            ast::pat_ident(ast::bind_by_implicit_ref,\n+                                           cx.path(v_span, ~[v_name]),\n+                                           none)\n+                        } else {\n+                            ast::pat_enum(cx.path(v_span, ~[v_name]),\n+                                                  some(pats))\n+                        }\n+                    },\n+\n+                    // Generate body s.emit_enum_variant(\"foo\", 0u,\n+                    //                                   3u, {|| blk })\n+                    |-s, blk| {\n+                        let v_name = cx.lit_str(v_span, v_name);\n+                        let v_id = cx.lit_uint(v_span, vidx);\n+                        let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n+                        let body = cx.lambda(blk);\n+                        #ast[expr]{\n+                            $(s).emit_enum_variant($(v_name), $(v_id),\n+                                                   $(sz), $(body))\n+                        }\n+                    },\n+\n+                    // Generate s.emit_enum_variant_arg(i, {|| blk })\n+                    |-s, i, blk| {\n+                        let idx = cx.lit_uint(v_span, i);\n+                        let body = cx.lambda(blk);\n+                        #ast[expr]{\n+                            $(s).emit_enum_variant_arg($(idx), $(body))\n+                        }\n+                    })\n+            }\n+            _ =>\n+                fail ~\"struct variants unimplemented for auto serialize\"\n+        }\n     };\n     let lam = cx.lambda(cx.blk(e_span, ~[cx.alt_stmt(arms, e_span, v)]));\n     let e_name = cx.lit_str(e_span, e_name);\n@@ -881,24 +889,32 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n         let variant = variants[vidx];\n         let v_span = variant.span;\n         let v_name = variant.node.name;\n-        let tys = vec::map(variant.node.args, |a| a.ty);\n-\n-        let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n-            let idx = cx.lit_uint(v_span, i);\n-            let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n-            #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n-        };\n \n-        let body = {\n-            if vec::is_empty(tys) {\n-                // for a nullary variant v, do \"v\"\n-                cx.var_ref(v_span, v_name)\n-            } else {\n-                // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                cx.expr(v_span, ast::expr_call(\n-                    cx.var_ref(v_span, v_name), arg_exprs, false))\n+        let body;\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                let tys = vec::map(args, |a| a.ty);\n+\n+                let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n+                    let idx = cx.lit_uint(v_span, i);\n+                    let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n+                    #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n+                };\n+\n+                body = {\n+                    if vec::is_empty(tys) {\n+                        // for a nullary variant v, do \"v\"\n+                        cx.var_ref(v_span, v_name)\n+                    } else {\n+                        // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n+                        cx.expr(v_span, ast::expr_call(\n+                            cx.var_ref(v_span, v_name), arg_exprs, false))\n+                    }\n+                };\n             }\n-        };\n+            ast::struct_variant_kind =>\n+                fail ~\"struct variants unimplemented\"\n+        }\n \n         {pats: ~[@{id: cx.next_id(),\n                   node: ast::pat_lit(cx.lit_uint(v_span, vidx)),"}, {"sha": "06a22b63fe0bfc2d6cefaa460366528fdd52b769", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -254,7 +254,7 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n \n         {node: {name: name,\n                 attrs: ~[],\n-                args: args,\n+                kind: ast::tuple_variant_kind(args),\n                 id: self.next_id(),\n                 disr_expr: none,\n                 vis: ast::public},"}, {"sha": "0ceee7f7d97a6f3ef58cd9dada7908c72c368781", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -541,7 +541,15 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n         return {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n-    let args = vec::map(v.args, fold_variant_arg);\n+\n+    let kind;\n+    match v.kind {\n+        tuple_variant_kind(variant_args) =>\n+            kind = tuple_variant_kind(vec::map(variant_args,\n+                                               fold_variant_arg)),\n+        struct_variant_kind =>\n+            kind = struct_variant_kind\n+    }\n \n     let fold_attribute = |x| fold_attribute_(x, fld);\n     let attrs = vec::map(v.attrs, fold_attribute);\n@@ -552,7 +560,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     };\n     return {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n-         args: args, id: fld.new_id(v.id),\n+         kind: kind,\n+         id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }"}, {"sha": "5feb753657de9fbb5f8bacfe52babcc6586dac21", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -49,14 +49,14 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n              stmt_semi, subtract, sty_box, sty_by_ref, sty_region, sty_uniq,\n              sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n-             tt_tok, tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n-             ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_param_bound,\n-             ty_path, ty_ptr, ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq,\n-             ty_vec, ty_fixed_length, unchecked_blk, uniq, unsafe_blk,\n-             unsafe_fn, variant, view_item, view_item_, view_item_export,\n-             view_item_import, view_item_use, view_path, view_path_glob,\n-             view_path_list, view_path_simple, visibility, vstore, vstore_box,\n-             vstore_fixed, vstore_slice, vstore_uniq};\n+             tt_tok, tt_nonterminal, tuple_variant_kind, ty, ty_, ty_bot,\n+             ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n+             ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr,\n+             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, unchecked_blk,\n+             uniq, unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n+             view_item_export, view_item_import, view_item_use, view_path,\n+             view_path_glob, view_path_list, view_path_simple, visibility,\n+             vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n \n export file_type;\n export parser;\n@@ -2830,7 +2830,8 @@ class parser {\n                 spanned(ty.span.lo, ty.span.hi,\n                         {name: id,\n                          attrs: ~[],\n-                         args: ~[{ty: ty, id: self.get_id()}],\n+                         kind: tuple_variant_kind\n+                            (~[{ty: ty, id: self.get_id()}]),\n                          id: self.get_id(),\n                          disr_expr: none,\n                          vis: public});\n@@ -2861,7 +2862,7 @@ class parser {\n             }\n \n             let vr = {name: ident, attrs: variant_attrs,\n-                      args: args, id: self.get_id(),\n+                      kind: tuple_variant_kind(args), id: self.get_id(),\n                       disr_expr: disr_expr, vis: vis};\n             vec::push(variants, spanned(vlo, self.last_span.hi, vr));\n "}, {"sha": "d3eef85f062538f1ba77d74b65fe2fb3efc61cfa", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -488,21 +488,31 @@ fn print_item(s: ps, &&item: @ast::item) {\n         end(s); // end the outer ibox\n       }\n       ast::item_enum(variants, params) => {\n-        let newtype =\n+        let mut newtype =\n             vec::len(variants) == 1u &&\n-                str::eq(item.ident, variants[0].node.name) &&\n-                vec::len(variants[0].node.args) == 1u;\n+                str::eq(item.ident, variants[0].node.name);\n+        if newtype {\n+            match variants[0].node.kind {\n+                ast::tuple_variant_kind(args) if args.len() == 1 => {}\n+                _ => newtype = false\n+            }\n+        }\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, ~\"enum\");\n-        } else { head(s, ~\"enum\"); }\n+        } else {\n+            head(s, ~\"enum\");\n+        }\n \n         word(s.s, *item.ident);\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n             word_space(s, ~\"=\");\n-            print_type(s, variants[0].node.args[0].ty);\n+            match variants[0].node.kind {\n+                ast::tuple_variant_kind(args) => print_type(s, args[0].ty),\n+                _ => fail ~\"newtype syntax with struct?\"\n+            }\n             word(s.s, ~\";\");\n             end(s);\n         } else {\n@@ -680,13 +690,18 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n \n fn print_variant(s: ps, v: ast::variant) {\n     word(s.s, *v.node.name);\n-    if vec::len(v.node.args) > 0u {\n-        popen(s);\n-        fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n-            print_type(s, arg.ty);\n+    match v.node.kind {\n+        ast::tuple_variant_kind(args) => {\n+            if vec::len(args) > 0u {\n+                popen(s);\n+                fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n+                    print_type(s, arg.ty);\n+                }\n+                commasep(s, consistent, args, print_variant_arg);\n+                pclose(s);\n+            }\n         }\n-        commasep(s, consistent, v.node.args, print_variant_arg);\n-        pclose(s);\n+        ast::struct_variant_kind => {}\n     }\n     match v.node.disr_expr {\n       some(d) => {"}, {"sha": "3bf820dd5cf6348e9b15ec6e628ccaad812996e0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -135,7 +135,11 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_enum(variants, tps) => {\n         v.visit_ty_params(tps, e, v);\n         for variants.each |vr| {\n-            for vr.node.args.each |va| { v.visit_ty(va.ty, e, v); }\n+            match vr.node.kind {\n+                tuple_variant_kind(variant_args) =>\n+                    for variant_args.each |va| { v.visit_ty(va.ty, e, v); },\n+                struct_variant_kind => {}\n+            }\n         }\n       }\n       item_impl(tps, traits, ty, methods) => {"}, {"sha": "267bb55e09eb7fdf569b5f362378461d3e3e63c0", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -362,8 +362,12 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_parent_item(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_type(ecx.tcx, variant.node.id));\n-        if vec::len(variant.node.args) > 0u && ty_params.len() == 0u {\n-            encode_symbol(ecx, ebml_w, variant.node.id);\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args)\n+                    if args.len() > 0 && ty_params.len() == 0 => {\n+                encode_symbol(ecx, ebml_w, variant.node.id);\n+            }\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind => {}\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n         if vi[i].disr_val != disr_val {"}, {"sha": "eb23008f18568bf171cf4a6ba02e01833cdb6a48", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -2173,8 +2173,14 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n             tv.id.node == fn_id.node}));\n         let d = mk_lldecl();\n         set_inline_hint(d);\n-        trans_enum_variant(ccx, enum_item.id, v, this_tv.disr_val,\n-                           (*tvs).len() == 1u, psubsts, d);\n+        match v.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                trans_enum_variant(ccx, enum_item.id, v, args,\n+                                   this_tv.disr_val, (*tvs).len() == 1u,\n+                                   psubsts, d);\n+            }\n+            ast::struct_variant_kind => {}\n+        }\n         d\n       }\n       ast_map::node_method(mth, impl_def_id, _) => {\n@@ -4671,13 +4677,16 @@ fn trans_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n-                      variant: ast::variant, disr: int, is_degen: bool,\n+fn trans_enum_variant(ccx: @crate_ctxt,\n+                      enum_id: ast::node_id,\n+                      variant: ast::variant,\n+                      args: ~[ast::variant_arg],\n+                      disr: int, is_degen: bool,\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(~\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n-    let fn_args = vec::map(variant.node.args, |varg|\n+    let fn_args = vec::map(args, |varg|\n         {mode: ast::expl(ast::by_copy),\n          ty: varg.ty,\n          ident: @~\"arg\",\n@@ -4705,7 +4714,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     };\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n-    for vec::eachi(variant.node.args) |i, va| {\n+    for vec::eachi(args) |i, va| {\n         let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n                                  ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n@@ -4867,11 +4876,16 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n             for vec::each(variants) |variant| {\n-                if variant.node.args.len() > 0u {\n-                    let llfn = get_item_val(ccx, variant.node.id);\n-                    trans_enum_variant(ccx, item.id, variant,\n-                                       vi[i].disr_val, degen,\n-                                       none, llfn);\n+                match variant.node.kind {\n+                    ast::tuple_variant_kind(args) if args.len() > 0 => {\n+                        let llfn = get_item_val(ccx, variant.node.id);\n+                        trans_enum_variant(ccx, item.id, variant, args,\n+                                           vi[i].disr_val, degen,\n+                                           none, llfn);\n+                    }\n+                    ast::tuple_variant_kind(_) | ast::struct_variant_kind => {\n+                        // Nothing to do.\n+                    }\n                 }\n                 i += 1;\n             }\n@@ -5166,15 +5180,23 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n           }\n \n           ast_map::node_variant(v, enm, pth) => {\n-            assert v.node.args.len() != 0u;\n-            let pth = vec::append(*pth,\n-                                  ~[path_name(enm.ident),\n-                                   path_name(v.node.name)]);\n-            let llfn = match check enm.node {\n-              ast::item_enum(_, _) => {\n-                register_fn(ccx, v.span, pth, id)\n-              }\n-            };\n+            let llfn;\n+            match v.node.kind {\n+                ast::tuple_variant_kind(args) => {\n+                    assert args.len() != 0u;\n+                    let pth = vec::append(*pth,\n+                                          ~[path_name(enm.ident),\n+                                           path_name(v.node.name)]);\n+                    llfn = match check enm.node {\n+                      ast::item_enum(_, _) => {\n+                        register_fn(ccx, v.span, pth, id)\n+                      }\n+                    };\n+                }\n+                ast::struct_variant_kind => {\n+                    fail ~\"struct unexpected in get_item_val\"\n+                }\n+            }\n             set_inline_hint(llfn);\n             llfn\n           }"}, {"sha": "db8d2b3ae3e6f72f0f21481a887f4e17170ba2f6", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -2837,28 +2837,37 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n           ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) => {\n             let mut disr_val = -1;\n             @vec::map(variants, |variant| {\n-                let ctor_ty = node_id_to_type(cx, variant.node.id);\n-                let arg_tys = {\n-                    if vec::len(variant.node.args) > 0u {\n-                        ty_fn_args(ctor_ty).map(|a| a.ty)\n-                    } else { ~[] }\n-                };\n-                match variant.node.disr_expr {\n-                  some (ex) => {\n-                    // FIXME: issue #1417\n-                    disr_val = match const_eval::eval_const_expr(cx, ex) {\n-                      const_eval::const_int(val) =>val as int,\n-                      _ => cx.sess.bug(~\"tag_variants: bad disr expr\")\n+                match variant.node.kind {\n+                    ast::tuple_variant_kind(args) => {\n+                        let ctor_ty = node_id_to_type(cx, variant.node.id);\n+                        let arg_tys = {\n+                            if vec::len(args) > 0u {\n+                                ty_fn_args(ctor_ty).map(|a| a.ty)\n+                            } else {\n+                                ~[]\n+                            }\n+                        };\n+                        match variant.node.disr_expr {\n+                          some (ex) => {\n+                            // FIXME: issue #1417\n+                            disr_val = match const_eval::eval_const_expr(cx,\n+                                                                         ex) {\n+                              const_eval::const_int(val) => val as int,\n+                              _ => cx.sess.bug(~\"tag_variants: bad disr expr\")\n+                            }\n+                          }\n+                          _ => disr_val += 1\n+                        }\n+                        @{args: arg_tys,\n+                          ctor_ty: ctor_ty,\n+                          name: variant.node.name,\n+                          id: ast_util::local_def(variant.node.id),\n+                          disr_val: disr_val\n+                         }\n                     }\n-                  }\n-                  _ => disr_val += 1\n+                    ast::struct_variant_kind =>\n+                        fail ~\"struct variant kinds unimpl in enum_variants\"\n                 }\n-                @{args: arg_tys,\n-                  ctor_ty: ctor_ty,\n-                  name: variant.node.name,\n-                  id: ast_util::local_def(variant.node.id),\n-                  disr_val: disr_val\n-                 }\n             })\n           }\n           _ => cx.sess.bug(~\"tag_variants: id not bound to an enum\")"}, {"sha": "c62861e211df2e203a428fcfa0aefc1ec7c9b24f", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -2073,9 +2073,13 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         }\n         vec::push(disr_vals, disr_val);\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n-        let arg_tys = if v.node.args.len() > 0u {\n-            ty::ty_fn_args(ctor_ty).map(|a| a.ty)\n-          } else { ~[] };\n+        let arg_tys;\n+        match v.node.kind {\n+            ast::tuple_variant_kind(args) if args.len() > 0u =>\n+                arg_tys = ty::ty_fn_args(ctor_ty).map(|a| a.ty),\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind =>\n+                arg_tys = ~[]\n+        };\n         vec::push(variants, @{args: arg_tys, ctor_ty: ctor_ty,\n               name: v.node.name, id: local_def(v.node.id),\n               disr_val: disr_val});"}, {"sha": "037a93fdf3d48df9940007ef2c92de16039a43e3", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -111,7 +111,6 @@ fn get_base_type_def_id(inference_context: infer_ctxt,\n class CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-\n     let inherent_methods: hashmap<def_id,@dvec<@Impl>>;\n \n     // Contains implementations of methods associated with a trait. For these,"}, {"sha": "3f68cc40f1da33423d9f43781ef1ad556df93127", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727c7c74994cf54baecab8ab6b03c50ace44d634/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=727c7c74994cf54baecab8ab6b03c50ace44d634", "patch": "@@ -115,20 +115,23 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n     for variants.each |variant| {\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n-        let result_ty = if vec::len(variant.node.args) == 0u {\n-            enum_ty\n-        } else {\n-            let rs = type_rscope(rp);\n-            let args = variant.node.args.map(|va| {\n-                let arg_ty = ccx.to_ty(rs, va.ty);\n-                {mode: ast::expl(ast::by_copy), ty: arg_ty}\n-            });\n-            ty::mk_fn(tcx, {purity: ast::pure_fn,\n-                            proto: ast::proto_box,\n-                            bounds: @~[],\n-                            inputs: args,\n-                            output: enum_ty,\n-                            ret_style: ast::return_val})\n+        let result_ty;\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) if args.len() > 0 => {\n+                let rs = type_rscope(rp);\n+                let args = args.map(|va| {\n+                    let arg_ty = ccx.to_ty(rs, va.ty);\n+                    {mode: ast::expl(ast::by_copy), ty: arg_ty}\n+                });\n+                result_ty = ty::mk_fn(tcx, {purity: ast::pure_fn,\n+                                            proto: ast::proto_box,\n+                                            bounds: @~[],\n+                                            inputs: args,\n+                                            output: enum_ty,\n+                                            ret_style: ast::return_val});\n+            }\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind =>\n+                result_ty = enum_ty\n         };\n         let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n                    rp: rp,"}]}