{"sha": "f79a22c3d5a6ab20e896df6a0473755db37b96f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OWEyMmMzZDVhNmFiMjBlODk2ZGY2YTA0NzM3NTVkYjM3Yjk2ZjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T19:05:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-13T07:09:02Z"}, "message": "validate return value on stack pop", "tree": {"sha": "748c94904072b28f567e9a0140285ae8eea700d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748c94904072b28f567e9a0140285ae8eea700d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f79a22c3d5a6ab20e896df6a0473755db37b96f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f79a22c3d5a6ab20e896df6a0473755db37b96f1", "html_url": "https://github.com/rust-lang/rust/commit/f79a22c3d5a6ab20e896df6a0473755db37b96f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f79a22c3d5a6ab20e896df6a0473755db37b96f1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a05914e2dcf196c226a9a93c6609e57970be7e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/a05914e2dcf196c226a9a93c6609e57970be7e23", "html_url": "https://github.com/rust-lang/rust/commit/a05914e2dcf196c226a9a93c6609e57970be7e23"}], "stats": {"total": 94, "additions": 59, "deletions": 35}, "files": [{"sha": "1ce32f8c0a858f501b95596b1b702dfe23ff0a3b", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f79a22c3d5a6ab20e896df6a0473755db37b96f1", "patch": "@@ -33,7 +33,7 @@ use rustc::mir::interpret::{\n     Scalar, Allocation, AllocId, ConstValue,\n };\n use interpret::{self,\n-    Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    PlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind,\n     snapshot,\n };\n@@ -55,13 +55,14 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     let param_env = tcx.param_env(instance.def_id());\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n     // insert a stack frame so any queries have the correct substs\n+    // cannot use `push_stack_frame`; if we do `const_prop` explodes\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n         instance,\n         span,\n         mir,\n-        return_place: Place::null(tcx),\n+        return_place: None,\n         return_to_block: StackPopCleanup::Goto(None), // never pop\n         stmt: 0,\n     });\n@@ -82,7 +83,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         instance,\n         mir.span,\n         mir,\n-        Place::null(tcx),\n+        None,\n         StackPopCleanup::Goto(None), // never pop\n     )?;\n     Ok(ecx)\n@@ -187,7 +188,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         cid.instance,\n         mir.span,\n         mir,\n-        Place::Ptr(*ret),\n+        Some(ret.into()),\n         StackPopCleanup::None { cleanup: false },\n     )?;\n "}, {"sha": "b0b8962b76ab129e482a803d6ae62b57337744f4", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f79a22c3d5a6ab20e896df6a0473755db37b96f1", "patch": "@@ -31,7 +31,7 @@ use rustc::mir::interpret::{\n use syntax::source_map::{self, Span};\n \n use super::{\n-    Value, Operand, MemPlace, MPlaceTy, Place, ScalarMaybeUndef,\n+    Value, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n     Memory, Machine\n };\n \n@@ -73,8 +73,9 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n     /// Work to perform when returning from this function\n     pub return_to_block: StackPopCleanup,\n \n-    /// The location where the result of the current stack frame should be written to.\n-    pub return_place: Place<Tag>,\n+    /// The location where the result of the current stack frame should be written to,\n+    /// and its layout in the caller.\n+    pub return_place: Option<PlaceTy<'tcx, Tag>>,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`.\n@@ -97,7 +98,8 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n-    /// that may never return).\n+    /// that may never return). Also store layout of return place so\n+    /// we can validate it at that layout.\n     Goto(Option<mir::BasicBlock>),\n     /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n     /// `cleanup` says whether locals are deallocated.  Static computation\n@@ -424,7 +426,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         instance: ty::Instance<'tcx>,\n         span: source_map::Span,\n         mir: &'mir mir::Mir<'tcx>,\n-        return_place: Place<M::PointerTag>,\n+        return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n@@ -509,15 +511,38 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             }\n             StackPopCleanup::None { cleanup } => {\n                 if !cleanup {\n-                    // Leak the locals\n+                    // Leak the locals. Also skip validation, this is only used by\n+                    // static/const computation which does its own (stronger) final\n+                    // validation.\n                     return Ok(());\n                 }\n             }\n         }\n-        // deallocate all locals that are backed by an allocation\n+        // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n             self.deallocate_local(local)?;\n         }\n+        // Validate the return value.\n+        if let Some(return_place) = frame.return_place {\n+            if M::ENFORCE_VALIDITY {\n+                // Data got changed, better make sure it matches the type!\n+                // It is still possible that the return place held invalid data while\n+                // the function is running, but that's okay because nobody could have\n+                // accessed that same data from the \"outside\" to observe any broken\n+                // invariant -- that is, unless a function somehow has a ptr to\n+                // its return place... but the way MIR is currently generated, the\n+                // return place is always a local and then this cannot happen.\n+                self.validate_operand(\n+                    self.place_to_op(return_place)?,\n+                    &mut vec![],\n+                    None,\n+                    /*const_mode*/false,\n+                )?;\n+            }\n+        } else {\n+            // Uh, that shouln't happen... the function did not intend to return\n+            return err!(Unreachable);\n+        }\n \n         Ok(())\n     }"}, {"sha": "55077c8b6f9dd89e0f5b9278ef1bafcaea6298f9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f79a22c3d5a6ab20e896df6a0473755db37b96f1", "patch": "@@ -256,12 +256,6 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n }\n \n impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n-    /// Produces a Place that will error if attempted to be read from or written to\n-    #[inline]\n-    pub fn null(cx: impl HasDataLayout, layout: TyLayout<'tcx>) -> Self {\n-        PlaceTy { place: Place::from_scalar_ptr(Scalar::ptr_null(cx), layout.align), layout }\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n@@ -565,9 +559,15 @@ where\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => PlaceTy {\n-                place: self.frame().return_place,\n-                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+                Some(return_place) =>\n+                    // We use our layout to verify our assumption; caller will validate\n+                    // their layout on return.\n+                    PlaceTy {\n+                        place: *return_place,\n+                        layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+                    },\n+                None => return err!(InvalidNullPointerUsage),\n             },\n             Local(local) => PlaceTy {\n                 place: Place::Local {"}, {"sha": "11d5785bc565dbd502a54eb7711c0b96fca8ca94", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=f79a22c3d5a6ab20e896df6a0473755db37b96f1", "patch": "@@ -337,7 +337,7 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n-    return_place: Place<(), AllocIdSnapshot<'a>>,\n+    return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n     locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n@@ -362,7 +362,7 @@ impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir,\n         } = self;\n \n         (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n+        (return_place.as_ref().map(|r| &**r), locals, block, stmt).hash_stable(hcx, hasher);\n     }\n }\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n@@ -388,7 +388,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             block,\n             stmt: *stmt,\n-            return_place: return_place.snapshot(ctx),\n+            return_place: return_place.map(|r| r.snapshot(ctx)),\n             locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n         }\n     }"}, {"sha": "a339fa34ae1f64cc6fd45cc176c788f5cd8dad4f", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79a22c3d5a6ab20e896df6a0473755db37b96f1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f79a22c3d5a6ab20e896df6a0473755db37b96f1", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Value, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -39,7 +39,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.dump_place(self.frame().return_place);\n+                self.frame().return_place.map(|r| self.dump_place(*r));\n                 self.pop_stack_frame()?\n             }\n \n@@ -286,15 +286,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     None => return Ok(()),\n                 };\n \n-                let return_place = match dest {\n-                    Some(place) => *place,\n-                    None => Place::null(&self), // any access will error. good!\n-                };\n                 self.push_stack_frame(\n                     instance,\n                     span,\n                     mir,\n-                    return_place,\n+                    dest,\n                     StackPopCleanup::Goto(ret),\n                 )?;\n \n@@ -375,17 +371,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         return err!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!\n-                    let callee_ret = self.eval_place(&mir::Place::Local(mir::RETURN_PLACE))?;\n                     if let Some(caller_ret) = dest {\n+                        let callee_ret = self.eval_place(&mir::Place::Local(mir::RETURN_PLACE))?;\n                         if !Self::check_argument_compat(caller_ret.layout, callee_ret.layout) {\n                             return err!(FunctionRetMismatch(\n                                 caller_ret.layout.ty, callee_ret.layout.ty\n                             ));\n                         }\n                     } else {\n-                        if !callee_ret.layout.abi.is_uninhabited() {\n+                        let callee_layout =\n+                            self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?;\n+                        if !callee_layout.abi.is_uninhabited() {\n                             return err!(FunctionRetMismatch(\n-                                self.tcx.types.never, callee_ret.layout.ty\n+                                self.tcx.types.never, callee_layout.ty\n                             ));\n                         }\n                     }\n@@ -453,14 +451,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n-        let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n+        let dest = MPlaceTy::dangling(self.layout_of(ty)?, &self);\n \n         self.eval_fn_call(\n             instance,\n             span,\n             Abi::Rust,\n             &[arg],\n-            Some(dest),\n+            Some(dest.into()),\n             Some(target),\n         )\n     }"}]}