{"sha": "f6e5570460b2bb925021dc667ead2a9834ea88cb", "node_id": "C_kwDOAAsO6NoAKGY2ZTU1NzA0NjBiMmJiOTI1MDIxZGM2NjdlYWQyYTk4MzRlYTg4Y2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T01:59:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-07T01:59:11Z"}, "message": "Auto merge of #96531 - kckeiks:remove-item-like-visitor-from-rustc-typeck, r=cjgillot\n\nRemove ItemLikeVisitor impls from rustc_typeck\n\nIssue #95004\ncc `@cjgillot`", "tree": {"sha": "9e301c7ec30b1d6e89432b3228bb5b303cdc03a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e301c7ec30b1d6e89432b3228bb5b303cdc03a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e5570460b2bb925021dc667ead2a9834ea88cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e5570460b2bb925021dc667ead2a9834ea88cb", "html_url": "https://github.com/rust-lang/rust/commit/f6e5570460b2bb925021dc667ead2a9834ea88cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e5570460b2bb925021dc667ead2a9834ea88cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4799baa70d0ff1780ee6dffb743d62c79235ace9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4799baa70d0ff1780ee6dffb743d62c79235ace9", "html_url": "https://github.com/rust-lang/rust/commit/4799baa70d0ff1780ee6dffb743d62c79235ace9"}, {"sha": "91ef3ba71d36c17eafd8d582d348d96b8148fbd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ef3ba71d36c17eafd8d582d348d96b8148fbd9", "html_url": "https://github.com/rust-lang/rust/commit/91ef3ba71d36c17eafd8d582d348d96b8148fbd9"}], "stats": {"total": 1049, "additions": 504, "deletions": 545}, "files": [{"sha": "70da96154b01335bd72863698224febd14514665", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -6,7 +6,7 @@ use rustc_session::cstore::ForeignModule;\n crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut modules = Vec::new();\n     for id in tcx.hir().items() {\n-        if !matches!(tcx.hir().def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n             continue;\n         }\n         let item = tcx.hir().item(id);"}, {"sha": "f468399930d3a3b533754253f2389cbdfe52ac79", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -36,7 +36,7 @@ struct Collector<'tcx> {\n \n impl<'tcx> Collector<'tcx> {\n     fn process_item(&mut self, id: rustc_hir::ItemId) {\n-        if !matches!(self.tcx.hir().def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(self.tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n             return;\n         }\n "}, {"sha": "77d6ce1e766ebb9bb4ff9a93fc0bbbbfdd9376a9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1813,7 +1813,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             FxHashMap::default();\n \n         for id in tcx.hir().items() {\n-            if matches!(tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n+            if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n                 if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id.to_def_id()) {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,"}, {"sha": "895cd4f0eac6e367ad86dc0eece6efbbc73c4dfc", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -308,11 +308,6 @@ impl<'hir> Map<'hir> {\n         Some(def_kind)\n     }\n \n-    pub fn def_kind(self, local_def_id: LocalDefId) -> DefKind {\n-        self.opt_def_kind(local_def_id)\n-            .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n-    }\n-\n     pub fn find_parent_node(self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))"}, {"sha": "eed90337c0a5057aac25794491bc6ebbc54fe594", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -2676,7 +2676,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n     for id in hir.items() {\n-        if matches!(hir.def_kind(id.def_id), DefKind::Use) {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::Use) {\n             continue;\n         }\n "}, {"sha": "f03d3943f9baced2b568d3178702c1a99a2c0f8b", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1164,7 +1164,7 @@ struct RootCollector<'a, 'tcx> {\n \n impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n-        match self.tcx.hir().def_kind(id.def_id) {\n+        match self.tcx.def_kind(id.def_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n                 let item = self.tcx.hir().item(id);\n                 match item.kind {\n@@ -1225,7 +1225,7 @@ impl<'v> RootCollector<'_, 'v> {\n     }\n \n     fn process_impl_item(&mut self, id: hir::ImplItemId) {\n-        if matches!(self.tcx.hir().def_kind(id.def_id), DefKind::AssocFn) {\n+        if matches!(self.tcx.def_kind(id.def_id), DefKind::AssocFn) {\n             self.push_if_root(id.def_id);\n         }\n     }"}, {"sha": "79900a90aed63bfcb9b224d21026bd2160314d6a", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -240,9 +240,9 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        collector.check_for_lang(Target::from_def_kind(tcx.hir().def_kind(id.def_id)), id.hir_id());\n+        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.def_id)), id.hir_id());\n \n-        if matches!(tcx.hir().def_kind(id.def_id), DefKind::Enum) {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::Enum) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(def, ..) = &item.kind {\n                 for variant in def.variants {"}, {"sha": "4627b58c9bcd3854c40799be62d62b33c90fb2c9", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -27,6 +27,7 @@ use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};\n \n+use rustc_hir::def::DefKind;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -711,28 +712,35 @@ fn check_opaque_meets_bounds<'tcx>(\n     });\n }\n \n-pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n+pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n-        it.def_id,\n-        tcx.def_path_str(it.def_id.to_def_id())\n+        id.def_id,\n+        tcx.def_path_str(id.def_id.to_def_id())\n     );\n     let _indenter = indenter();\n-    match it.kind {\n-        // Consts can play a role in type-checking, so they are included here.\n-        hir::ItemKind::Static(..) => {\n-            tcx.ensure().typeck(it.def_id);\n-            maybe_check_static_with_link_section(tcx, it.def_id, it.span);\n-            check_static_inhabited(tcx, it.def_id, it.span);\n+    match tcx.def_kind(id.def_id) {\n+        DefKind::Static(..) => {\n+            tcx.ensure().typeck(id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.def_id, tcx.def_span(id.def_id));\n+            check_static_inhabited(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck(it.def_id);\n+        DefKind::Const => {\n+            tcx.ensure().typeck(id.def_id);\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.def_id);\n+        DefKind::Enum => {\n+            let item = tcx.hir().item(id);\n+            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n+                return;\n+            };\n+            check_enum(tcx, item.span, &enum_definition.variants, item.def_id);\n         }\n-        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-        hir::ItemKind::Impl(ref impl_) => {\n+        DefKind::Fn => {} // entirely within check_item_body\n+        DefKind::Impl => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::Impl(ref impl_) = it.kind else {\n+                return;\n+            };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n                 check_impl_items_against_trait(\n@@ -745,7 +753,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 check_on_unimplemented(tcx, it);\n             }\n         }\n-        hir::ItemKind::Trait(_, _, _, _, ref items) => {\n+        DefKind::Trait => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::Trait(_, _, _, _, ref items) = it.kind else {\n+                return;\n+            };\n             check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n@@ -771,28 +783,36 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             }\n         }\n-        hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.def_id, it.span);\n+        DefKind::Struct => {\n+            check_struct(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.def_id, it.span);\n+        DefKind::Union => {\n+            check_union(tcx, id.def_id, tcx.def_span(id.def_id));\n         }\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n+        DefKind::OpaqueTy => {\n+            let item = tcx.hir().item(id);\n+            let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n+                return;\n+            };\n             // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n             // `async-std` (and `pub async fn` in general).\n             // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n             // See https://github.com/rust-lang/rust/issues/75100\n             if !tcx.sess.opts.actually_rustdoc {\n-                let substs = InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n-                check_opaque(tcx, it.def_id, substs, it.span, &origin);\n+                let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n+                check_opaque(tcx, item.def_id, substs, item.span, &origin);\n             }\n         }\n-        hir::ItemKind::TyAlias(..) => {\n-            let pty_ty = tcx.type_of(it.def_id);\n-            let generics = tcx.generics_of(it.def_id);\n+        DefKind::TyAlias => {\n+            let pty_ty = tcx.type_of(id.def_id);\n+            let generics = tcx.generics_of(id.def_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n-        hir::ItemKind::ForeignMod { abi, items } => {\n+        DefKind::ForeignMod => {\n+            let it = tcx.hir().item(id);\n+            let hir::ItemKind::ForeignMod { abi, items } = it.kind else {\n+                return;\n+            };\n             check_abi(tcx, it.hir_id(), it.span, abi);\n \n             if abi == Abi::RustIntrinsic {\n@@ -851,7 +871,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             }\n         }\n-        _ => { /* nothing to do */ }\n+        _ => {}\n     }\n }\n \n@@ -1451,7 +1471,10 @@ pub(super) fn check_type_params_are_used<'tcx>(\n }\n \n pub(super) fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n+    let module = tcx.hir_module_items(module_def_id);\n+    for id in module.items() {\n+        check_item_type(tcx, id);\n+    }\n }\n \n pub(super) use wfcheck::check_item_well_formed;"}, {"sha": "ceb862b474a5a6ee63b7062484ade1ae194cc303", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n                     sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match def_id.as_local().map(|def_id| hir.def_kind(def_id)) {\n+                    match def_id.as_local().map(|def_id| self.tcx.def_kind(def_id)) {\n                         Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n                             msg = \"instantiate this tuple variant\";\n                         }"}, {"sha": "f88083003a28c0946c2faeb25662be56b93b3781", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -111,7 +111,6 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n@@ -933,19 +932,6 @@ impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n     }\n }\n \n-struct CheckItemTypesVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n-    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n-        check_item_type(self.tcx, i);\n-    }\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _: &'tcx hir::ForeignItem<'tcx>) {}\n-}\n-\n fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n     tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n }"}, {"sha": "1310467aeb9683196021fccf5f44671fe3460c7b", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     }\n \n     for id in tcx.hir().items() {\n-        if matches!(tcx.hir().def_kind(id.def_id), DefKind::Use) {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::Use) {\n             if tcx.visibility(id.def_id).is_public() {\n                 continue;\n             }\n@@ -101,7 +101,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let mut crates_to_lint = vec![];\n \n     for id in tcx.hir().items() {\n-        if matches!(tcx.hir().def_kind(id.def_id), DefKind::ExternCrate) {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::ExternCrate) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n                 crates_to_lint.push(ExternCrateToLint {"}, {"sha": "b9d4167dbff096e0d91a87533a3cf57b3753ab23", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -9,8 +9,8 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -19,7 +19,9 @@ use rustc_span::Span;\n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n     let mut collect = InherentCollect { tcx, impls_map: Default::default() };\n-    tcx.hir().visit_all_item_likes(&mut collect);\n+    for id in tcx.hir().items() {\n+        collect.check_item(id);\n+    }\n     collect.impls_map\n }\n \n@@ -46,79 +48,6 @@ struct InherentCollect<'tcx> {\n     impls_map: CrateInherentImpls,\n }\n \n-impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n-            return;\n-        };\n-\n-        let self_ty = self.tcx.type_of(item.def_id);\n-        match *self_ty.kind() {\n-            ty::Adt(def, _) => {\n-                self.check_def_id(item, self_ty, def.did());\n-            }\n-            ty::Foreign(did) => {\n-                self.check_def_id(item, self_ty, did);\n-            }\n-            ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n-                self.check_def_id(item, self_ty, data.principal_def_id().unwrap());\n-            }\n-            ty::Dynamic(..) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    ty.span,\n-                    E0785,\n-                    \"cannot define inherent `impl` for a dyn auto trait\"\n-                )\n-                .span_label(ty.span, \"impl requires at least one non-auto trait\")\n-                .note(\"define and implement a new trait or type instead\")\n-                .emit();\n-            }\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(_)\n-            | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::Str\n-            | ty::Array(..)\n-            | ty::Slice(_)\n-            | ty::RawPtr(_)\n-            | ty::Ref(..)\n-            | ty::Never\n-            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n-            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    ty.span,\n-                    E0118,\n-                    \"no nominal type found for inherent implementation\"\n-                );\n-\n-                err.span_label(ty.span, \"impl requires a nominal type\")\n-                    .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n-\n-                err.emit();\n-            }\n-            ty::FnDef(..)\n-            | ty::Closure(..)\n-            | ty::Generator(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Bound(..)\n-            | ty::Placeholder(_)\n-            | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n-            }\n-            ty::Error(_) => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n-}\n-\n const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n const INTO_DEFINING_CRATE: &str =\n     \"consider moving this inherent impl into the crate defining the type if possible\";\n@@ -246,4 +175,74 @@ impl<'tcx> InherentCollect<'tcx> {\n             bug!(\"unexpected primitive type: {:?}\", ty);\n         }\n     }\n+\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        if !matches!(self.tcx.def_kind(id.def_id), DefKind::Impl) {\n+            return;\n+        }\n+\n+        let item = self.tcx.hir().item(id);\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n+            return;\n+        };\n+\n+        let self_ty = self.tcx.type_of(item.def_id);\n+        match *self_ty.kind() {\n+            ty::Adt(def, _) => {\n+                self.check_def_id(item, self_ty, def.did());\n+            }\n+            ty::Foreign(did) => {\n+                self.check_def_id(item, self_ty, did);\n+            }\n+            ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n+                self.check_def_id(item, self_ty, data.principal_def_id().unwrap());\n+            }\n+            ty::Dynamic(..) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    ty.span,\n+                    E0785,\n+                    \"cannot define inherent `impl` for a dyn auto trait\"\n+                )\n+                .span_label(ty.span, \"impl requires at least one non-auto trait\")\n+                .note(\"define and implement a new trait or type instead\")\n+                .emit();\n+            }\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n+            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    ty.span,\n+                    E0118,\n+                    \"no nominal type found for inherent implementation\"\n+                );\n+\n+                err.span_label(ty.span, \"impl requires a nominal type\")\n+                    .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n+\n+                err.emit();\n+            }\n+            ty::FnDef(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => {\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+            }\n+            ty::Error(_) => {}\n+        }\n+    }\n }"}, {"sha": "db67c1f7c9ed372de481a16ccc1062041e95c665", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 163, "deletions": 176, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_index::vec::IndexVec;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -12,7 +12,10 @@ use smallvec::SmallVec;\n use std::collections::hash_map::Entry;\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, (): ()) {\n-    tcx.hir().visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n+    let mut inherent_overlap_checker = InherentOverlapChecker { tcx };\n+    for id in tcx.hir().items() {\n+        inherent_overlap_checker.check_item(id);\n+    }\n }\n \n struct InherentOverlapChecker<'tcx> {\n@@ -121,200 +124,184 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             || true,\n         );\n     }\n-}\n \n-impl<'tcx> ItemLikeVisitor<'_> for InherentOverlapChecker<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::Union(..) => {\n-                let impls = self.tcx.inherent_impls(item.def_id);\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        let def_kind = self.tcx.def_kind(id.def_id);\n+        if !matches!(def_kind, DefKind::Enum | DefKind::Struct | DefKind::Trait | DefKind::Union) {\n+            return;\n+        }\n \n-                // If there is only one inherent impl block,\n-                // there is nothing to overlap check it with\n-                if impls.len() <= 1 {\n-                    return;\n-                }\n+        let impls = self.tcx.inherent_impls(id.def_id);\n \n-                let overlap_mode = OverlapMode::get(self.tcx, item.def_id.to_def_id());\n+        // If there is only one inherent impl block,\n+        // there is nothing to overlap check it with\n+        if impls.len() <= 1 {\n+            return;\n+        }\n \n-                let impls_items = impls\n-                    .iter()\n-                    .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n-                    .collect::<SmallVec<[_; 8]>>();\n+        let overlap_mode = OverlapMode::get(self.tcx, id.def_id.to_def_id());\n \n-                // Perform a O(n^2) algorithm for small n,\n-                // otherwise switch to an allocating algorithm with\n-                // faster asymptotic runtime.\n-                const ALLOCATING_ALGO_THRESHOLD: usize = 500;\n-                if impls.len() < ALLOCATING_ALGO_THRESHOLD {\n-                    for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n-                        for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n-                            if self.impls_have_common_items(impl_items1, impl_items2) {\n-                                self.check_for_overlapping_inherent_impls(\n-                                    overlap_mode,\n-                                    impl1_def_id,\n-                                    impl2_def_id,\n-                                );\n-                            }\n-                        }\n+        let impls_items = impls\n+            .iter()\n+            .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n+            .collect::<SmallVec<[_; 8]>>();\n+\n+        // Perform a O(n^2) algorithm for small n,\n+        // otherwise switch to an allocating algorithm with\n+        // faster asymptotic runtime.\n+        const ALLOCATING_ALGO_THRESHOLD: usize = 500;\n+        if impls.len() < ALLOCATING_ALGO_THRESHOLD {\n+            for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n+                for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n+                    if self.impls_have_common_items(impl_items1, impl_items2) {\n+                        self.check_for_overlapping_inherent_impls(\n+                            overlap_mode,\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                        );\n                     }\n-                } else {\n-                    // Build a set of connected regions of impl blocks.\n-                    // Two impl blocks are regarded as connected if they share\n-                    // an item with the same unhygienic identifier.\n-                    // After we have assembled the connected regions,\n-                    // run the O(n^2) algorithm on each connected region.\n-                    // This is advantageous to running the algorithm over the\n-                    // entire graph when there are many connected regions.\n+                }\n+            }\n+        } else {\n+            // Build a set of connected regions of impl blocks.\n+            // Two impl blocks are regarded as connected if they share\n+            // an item with the same unhygienic identifier.\n+            // After we have assembled the connected regions,\n+            // run the O(n^2) algorithm on each connected region.\n+            // This is advantageous to running the algorithm over the\n+            // entire graph when there are many connected regions.\n \n-                    rustc_index::newtype_index! {\n-                        pub struct RegionId {\n-                            ENCODABLE = custom\n+            rustc_index::newtype_index! {\n+                pub struct RegionId {\n+                    ENCODABLE = custom\n+                }\n+            }\n+            struct ConnectedRegion {\n+                idents: SmallVec<[Symbol; 8]>,\n+                impl_blocks: FxHashSet<usize>,\n+            }\n+            let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n+            // Reverse map from the Symbol to the connected region id.\n+            let mut connected_region_ids = FxHashMap::default();\n+\n+            for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n+                if impl_items.len() == 0 {\n+                    continue;\n+                }\n+                // First obtain a list of existing connected region ids\n+                let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n+                let mut ids = impl_items\n+                    .in_definition_order()\n+                    .filter_map(|item| {\n+                        let entry = connected_region_ids.entry(item.name);\n+                        if let Entry::Occupied(e) = &entry {\n+                            Some(*e.get())\n+                        } else {\n+                            idents_to_add.push(item.name);\n+                            None\n                         }\n+                    })\n+                    .collect::<SmallVec<[RegionId; 8]>>();\n+                // Sort the id list so that the algorithm is deterministic\n+                ids.sort_unstable();\n+                ids.dedup();\n+                let ids = ids;\n+                match &ids[..] {\n+                    // Create a new connected region\n+                    [] => {\n+                        let id_to_set = connected_regions.next_index();\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n+                        }\n+                        connected_regions.insert(\n+                            id_to_set,\n+                            ConnectedRegion {\n+                                idents: idents_to_add,\n+                                impl_blocks: std::iter::once(i).collect(),\n+                            },\n+                        );\n                     }\n-                    struct ConnectedRegion {\n-                        idents: SmallVec<[Symbol; 8]>,\n-                        impl_blocks: FxHashSet<usize>,\n+                    // Take the only id inside the list\n+                    &[id_to_set] => {\n+                        let region = connected_regions[id_to_set].as_mut().unwrap();\n+                        region.impl_blocks.insert(i);\n+                        region.idents.extend_from_slice(&idents_to_add);\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n+                        }\n                     }\n-                    let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n-                    // Reverse map from the Symbol to the connected region id.\n-                    let mut connected_region_ids = FxHashMap::default();\n-\n-                    for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n-                        if impl_items.len() == 0 {\n-                            continue;\n+                    // We have multiple connected regions to merge.\n+                    // In the worst case this might add impl blocks\n+                    // one by one and can thus be O(n^2) in the size\n+                    // of the resulting final connected region, but\n+                    // this is no issue as the final step to check\n+                    // for overlaps runs in O(n^2) as well.\n+                    &[id_to_set, ..] => {\n+                        let mut region = connected_regions.remove(id_to_set).unwrap();\n+                        region.impl_blocks.insert(i);\n+                        region.idents.extend_from_slice(&idents_to_add);\n+                        // Update the connected region ids\n+                        for ident in &idents_to_add {\n+                            connected_region_ids.insert(*ident, id_to_set);\n                         }\n-                        // First obtain a list of existing connected region ids\n-                        let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n-                        let mut ids = impl_items\n-                            .in_definition_order()\n-                            .filter_map(|item| {\n-                                let entry = connected_region_ids.entry(item.name);\n-                                if let Entry::Occupied(e) = &entry {\n-                                    Some(*e.get())\n-                                } else {\n-                                    idents_to_add.push(item.name);\n-                                    None\n-                                }\n-                            })\n-                            .collect::<SmallVec<[RegionId; 8]>>();\n-                        // Sort the id list so that the algorithm is deterministic\n-                        ids.sort_unstable();\n-                        ids.dedup();\n-                        let ids = ids;\n-                        match &ids[..] {\n-                            // Create a new connected region\n-                            [] => {\n-                                let id_to_set = connected_regions.next_index();\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-                                connected_regions.insert(\n-                                    id_to_set,\n-                                    ConnectedRegion {\n-                                        idents: idents_to_add,\n-                                        impl_blocks: std::iter::once(i).collect(),\n-                                    },\n-                                );\n-                            }\n-                            // Take the only id inside the list\n-                            &[id_to_set] => {\n-                                let region = connected_regions[id_to_set].as_mut().unwrap();\n-                                region.impl_blocks.insert(i);\n-                                region.idents.extend_from_slice(&idents_to_add);\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-                            }\n-                            // We have multiple connected regions to merge.\n-                            // In the worst case this might add impl blocks\n-                            // one by one and can thus be O(n^2) in the size\n-                            // of the resulting final connected region, but\n-                            // this is no issue as the final step to check\n-                            // for overlaps runs in O(n^2) as well.\n-                            &[id_to_set, ..] => {\n-                                let mut region = connected_regions.remove(id_to_set).unwrap();\n-                                region.impl_blocks.insert(i);\n-                                region.idents.extend_from_slice(&idents_to_add);\n-                                // Update the connected region ids\n-                                for ident in &idents_to_add {\n-                                    connected_region_ids.insert(*ident, id_to_set);\n-                                }\n-\n-                                // Remove other regions from ids.\n-                                for &id in ids.iter() {\n-                                    if id == id_to_set {\n-                                        continue;\n-                                    }\n-                                    let r = connected_regions.remove(id).unwrap();\n-                                    for ident in r.idents.iter() {\n-                                        connected_region_ids.insert(*ident, id_to_set);\n-                                    }\n-                                    region.idents.extend_from_slice(&r.idents);\n-                                    region.impl_blocks.extend(r.impl_blocks);\n-                                }\n \n-                                connected_regions.insert(id_to_set, region);\n+                        // Remove other regions from ids.\n+                        for &id in ids.iter() {\n+                            if id == id_to_set {\n+                                continue;\n+                            }\n+                            let r = connected_regions.remove(id).unwrap();\n+                            for ident in r.idents.iter() {\n+                                connected_region_ids.insert(*ident, id_to_set);\n                             }\n+                            region.idents.extend_from_slice(&r.idents);\n+                            region.impl_blocks.extend(r.impl_blocks);\n                         }\n+\n+                        connected_regions.insert(id_to_set, region);\n                     }\n+                }\n+            }\n \n-                    debug!(\n-                        \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n-                        connected_regions.len(),\n-                        impls.len(),\n-                        impls.len() / connected_regions.len(),\n-                        {\n-                            let avg = impls.len() / connected_regions.len();\n-                            let s = connected_regions\n-                                .iter()\n-                                .flatten()\n-                                .map(|r| r.impl_blocks.len() as isize - avg as isize)\n-                                .map(|v| v.abs() as usize)\n-                                .sum::<usize>();\n-                            s / connected_regions.len()\n-                        },\n-                        connected_regions\n-                            .iter()\n-                            .flatten()\n-                            .map(|r| r.impl_blocks.len())\n-                            .max()\n-                            .unwrap()\n-                    );\n-                    // List of connected regions is built. Now, run the overlap check\n-                    // for each pair of impl blocks in the same connected region.\n-                    for region in connected_regions.into_iter().flatten() {\n-                        let mut impl_blocks =\n-                            region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n-                        impl_blocks.sort_unstable();\n-                        for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n-                            let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n-                            for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n-                                let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n-                                if self.impls_have_common_items(impl_items1, impl_items2) {\n-                                    self.check_for_overlapping_inherent_impls(\n-                                        overlap_mode,\n-                                        impl1_def_id,\n-                                        impl2_def_id,\n-                                    );\n-                                }\n-                            }\n+            debug!(\n+                \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n+                connected_regions.len(),\n+                impls.len(),\n+                impls.len() / connected_regions.len(),\n+                {\n+                    let avg = impls.len() / connected_regions.len();\n+                    let s = connected_regions\n+                        .iter()\n+                        .flatten()\n+                        .map(|r| r.impl_blocks.len() as isize - avg as isize)\n+                        .map(|v| v.abs() as usize)\n+                        .sum::<usize>();\n+                    s / connected_regions.len()\n+                },\n+                connected_regions.iter().flatten().map(|r| r.impl_blocks.len()).max().unwrap()\n+            );\n+            // List of connected regions is built. Now, run the overlap check\n+            // for each pair of impl blocks in the same connected region.\n+            for region in connected_regions.into_iter().flatten() {\n+                let mut impl_blocks =\n+                    region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n+                impl_blocks.sort_unstable();\n+                for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n+                    let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n+                    for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n+                        let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n+                        if self.impls_have_common_items(impl_items1, impl_items2) {\n+                            self.check_for_overlapping_inherent_impls(\n+                                overlap_mode,\n+                                impl1_def_id,\n+                                impl2_def_id,\n+                            );\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n }"}, {"sha": "3cfc96ccbfd28a26deb4ee540836e78bb14f4db2", "filename": "compiler/rustc_typeck/src/coherence/unsafety.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -3,101 +3,83 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_hir::Unsafety;\n use rustc_middle::ty::TyCtxt;\n \n pub fn check(tcx: TyCtxt<'_>) {\n-    let mut unsafety = UnsafetyChecker { tcx };\n-    tcx.hir().visit_all_item_likes(&mut unsafety);\n+    for id in tcx.hir().items() {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::Impl(ref impl_) = item.kind {\n+                check_unsafety_coherence(\n+                    tcx,\n+                    item,\n+                    Some(&impl_.generics),\n+                    impl_.unsafety,\n+                    impl_.polarity,\n+                );\n+            }\n+        }\n+    }\n }\n \n-struct UnsafetyChecker<'tcx> {\n+fn check_unsafety_coherence<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> UnsafetyChecker<'tcx> {\n-    fn check_unsafety_coherence(\n-        &mut self,\n-        item: &hir::Item<'_>,\n-        impl_generics: Option<&hir::Generics<'_>>,\n-        unsafety: hir::Unsafety,\n-        polarity: hir::ImplPolarity,\n-    ) {\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id) {\n-            let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-            let unsafe_attr = impl_generics.and_then(|generics| {\n-                generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")\n-            });\n-            match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n-                (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        item.span,\n-                        E0199,\n-                        \"implementing the trait `{}` is not unsafe\",\n-                        trait_ref.print_only_trait_path()\n-                    )\n-                    .emit();\n-                }\n-\n-                (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        item.span,\n-                        E0200,\n-                        \"the trait `{}` requires an `unsafe impl` declaration\",\n-                        trait_ref.print_only_trait_path()\n-                    )\n-                    .emit();\n-                }\n+    item: &hir::Item<'_>,\n+    impl_generics: Option<&hir::Generics<'_>>,\n+    unsafety: hir::Unsafety,\n+    polarity: hir::ImplPolarity,\n+) {\n+    if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+        let trait_def = tcx.trait_def(trait_ref.def_id);\n+        let unsafe_attr = impl_generics.and_then(|generics| {\n+            generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")\n+        });\n+        match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n+            (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    item.span,\n+                    E0199,\n+                    \"implementing the trait `{}` is not unsafe\",\n+                    trait_ref.print_only_trait_path()\n+                )\n+                .emit();\n+            }\n \n-                (\n-                    Unsafety::Normal,\n-                    Some(attr_name),\n-                    Unsafety::Normal,\n-                    hir::ImplPolarity::Positive,\n-                ) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        item.span,\n-                        E0569,\n-                        \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n-                        attr_name\n-                    )\n-                    .emit();\n-                }\n+            (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    item.span,\n+                    E0200,\n+                    \"the trait `{}` requires an `unsafe impl` declaration\",\n+                    trait_ref.print_only_trait_path()\n+                )\n+                .emit();\n+            }\n \n-                (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative(_)) => {\n-                    // Reported in AST validation\n-                    self.tcx.sess.delay_span_bug(item.span, \"unsafe negative impl\");\n-                }\n-                (_, _, Unsafety::Normal, hir::ImplPolarity::Negative(_))\n-                | (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive)\n-                | (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive)\n-                | (Unsafety::Normal, None, Unsafety::Normal, _) => {\n-                    // OK\n-                }\n+            (Unsafety::Normal, Some(attr_name), Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    item.span,\n+                    E0569,\n+                    \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n+                    attr_name\n+                )\n+                .emit();\n             }\n-        }\n-    }\n-}\n \n-impl<'tcx> ItemLikeVisitor<'_> for UnsafetyChecker<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            self.check_unsafety_coherence(\n-                item,\n-                Some(&impl_.generics),\n-                impl_.unsafety,\n-                impl_.polarity,\n-            );\n+            (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative(_)) => {\n+                // Reported in AST validation\n+                tcx.sess.delay_span_bug(item.span, \"unsafe negative impl\");\n+            }\n+            (_, _, Unsafety::Normal, hir::ImplPolarity::Negative(_))\n+            | (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive)\n+            | (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive)\n+            | (Unsafety::Normal, None, Unsafety::Normal, _) => {\n+                // OK\n+            }\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n }"}, {"sha": "c089d25d222164226f5e71de489fc485c9ad2735", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -14,8 +14,8 @@ use min_specialization::check_min_specialization;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -63,35 +63,23 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n \n fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n-    tcx.hir()\n-        .visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx, min_specialization });\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { check_mod_impl_wf, ..*providers };\n-}\n-\n-struct ImplWfCheck<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    min_specialization: bool,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            enforce_impl_params_are_constrained(self.tcx, item.def_id, impl_.items);\n-            enforce_impl_items_are_distinct(self.tcx, impl_.items);\n-            if self.min_specialization {\n-                check_min_specialization(self.tcx, item.def_id.to_def_id(), item.span);\n+    let module = tcx.hir_module_items(module_def_id);\n+    for id in module.items() {\n+        if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::Impl(ref impl_) = item.kind {\n+                enforce_impl_params_are_constrained(tcx, item.def_id, impl_.items);\n+                enforce_impl_items_are_distinct(tcx, impl_.items);\n+                if min_specialization {\n+                    check_min_specialization(tcx, item.def_id.to_def_id(), item.span);\n+                }\n             }\n         }\n     }\n+}\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem<'tcx>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem<'tcx>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &'tcx hir::ForeignItem<'tcx>) {}\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers { check_mod_impl_wf, ..*providers };\n }\n \n fn enforce_impl_params_are_constrained("}, {"sha": "96dc83b259f55e7468991cccacfc01197eaae81e", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -35,7 +35,7 @@ pub fn infer_predicates<'tcx>(\n             debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n             let mut item_required_predicates = RequiredPredicates::default();\n-            match tcx.hir().def_kind(item_did) {\n+            match tcx.def_kind(item_did) {\n                 DefKind::Union | DefKind::Enum | DefKind::Struct => {\n                     let adt_def = tcx.adt_def(item_did.to_def_id());\n "}, {"sha": "eb0e1203405cb509681d591115f2a42a9116bebb", "filename": "compiler/rustc_typeck/src/outlives/test.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1,28 +1,21 @@\n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n-    tcx.hir().visit_all_item_likes(&mut OutlivesTest { tcx });\n-}\n-\n-struct OutlivesTest<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+    for id in tcx.hir().items() {\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = self.tcx.inferred_outlives_of(item.def_id);\n-            struct_span_err!(self.tcx.sess, item.span, E0640, \"{:?}\", inferred_outlives_of).emit();\n+        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = tcx.inferred_outlives_of(id.def_id);\n+            struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(id.def_id),\n+                E0640,\n+                \"{:?}\",\n+                inferred_outlives_of\n+            )\n+            .emit();\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _: &'tcx hir::ForeignItem<'tcx>) {}\n }"}, {"sha": "be8e825d990f75d8324c2b29259a3f916e50c6d0", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -5,7 +5,7 @@\n \n use hir::def_id::{DefId, LocalDefId};\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -62,61 +62,71 @@ pub fn add_constraints_from_crate<'a, 'tcx>(\n         constraints: Vec::new(),\n     };\n \n-    tcx.hir().visit_all_item_likes(&mut constraint_cx);\n+    let crate_items = tcx.hir_crate_items(());\n+\n+    for id in crate_items.items() {\n+        constraint_cx.check_item(id);\n+    }\n+\n+    for id in crate_items.trait_items() {\n+        if let DefKind::AssocFn = tcx.def_kind(id.def_id) {\n+            constraint_cx.check_node_helper(id.hir_id());\n+        }\n+    }\n+\n+    for id in crate_items.impl_items() {\n+        if let DefKind::AssocFn = tcx.def_kind(id.def_id) {\n+            constraint_cx.check_node_helper(id.hir_id());\n+        }\n+    }\n+\n+    for id in crate_items.foreign_items() {\n+        if let DefKind::Fn = tcx.def_kind(id.def_id) {\n+            constraint_cx.check_node_helper(id.hir_id());\n+        }\n+    }\n \n     constraint_cx\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.visit_node_helper(item.hir_id());\n-\n-                if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.visit_node_helper(struct_def.ctor_hir_id().unwrap());\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        let def_kind = self.tcx().def_kind(id.def_id);\n+        match def_kind {\n+            DefKind::Struct | DefKind::Union => {\n+                let item = self.tcx().hir().item(id);\n+\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    self.check_node_helper(item.hir_id());\n+\n+                    if let hir::VariantData::Tuple(..) = *struct_def {\n+                        self.check_node_helper(struct_def.ctor_hir_id().unwrap());\n+                    }\n                 }\n             }\n+            DefKind::Enum => {\n+                let item = self.tcx().hir().item(id);\n \n-            hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.visit_node_helper(item.hir_id());\n+                if let hir::ItemKind::Enum(ref enum_def, _) = item.kind {\n+                    self.check_node_helper(item.hir_id());\n \n-                for variant in enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.data {\n-                        self.visit_node_helper(variant.data.ctor_hir_id().unwrap());\n+                    for variant in enum_def.variants {\n+                        if let hir::VariantData::Tuple(..) = variant.data {\n+                            self.check_node_helper(variant.data.ctor_hir_id().unwrap());\n+                        }\n                     }\n                 }\n             }\n-\n-            hir::ItemKind::Fn(..) => {\n-                self.visit_node_helper(item.hir_id());\n+            DefKind::Fn => {\n+                self.check_node_helper(id.hir_id());\n             }\n-\n             _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Fn(..) = trait_item.kind {\n-            self.visit_node_helper(trait_item.hir_id());\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n-            self.visit_node_helper(impl_item.hir_id());\n-        }\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n-            self.visit_node_helper(foreign_item.hir_id());\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn visit_node_helper(&mut self, id: hir::HirId) {\n+    fn check_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n         self.build_constraints_for_item(def_id);"}, {"sha": "ab64befe5dc16849ee84c8036f4598e2e404a058", "filename": "compiler/rustc_typeck/src/variance/terms.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -11,7 +11,7 @@\n \n use rustc_arena::DroplessArena;\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_hir::HirIdMap;\n use rustc_middle::ty::{self, TyCtxt};\n use std::fmt;\n@@ -79,7 +79,29 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n     //\n     // - https://rustc-dev-guide.rust-lang.org/query.html\n     // - https://rustc-dev-guide.rust-lang.org/variance.html\n-    tcx.hir().visit_all_item_likes(&mut terms_cx);\n+    let crate_items = tcx.hir_crate_items(());\n+\n+    for id in crate_items.items() {\n+        terms_cx.check_item(id);\n+    }\n+\n+    for id in crate_items.trait_items() {\n+        if let DefKind::AssocFn = tcx.def_kind(id.def_id) {\n+            terms_cx.add_inferreds_for_item(id.hir_id());\n+        }\n+    }\n+\n+    for id in crate_items.impl_items() {\n+        if let DefKind::AssocFn = tcx.def_kind(id.def_id) {\n+            terms_cx.add_inferreds_for_item(id.hir_id());\n+        }\n+    }\n+\n+    for id in crate_items.foreign_items() {\n+        if let DefKind::Fn = tcx.def_kind(id.def_id) {\n+            terms_cx.add_inferreds_for_item(id.hir_id());\n+        }\n+    }\n \n     terms_cx\n }\n@@ -124,54 +146,42 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n             (start..(start + count)).map(|i| &*arena.alloc(InferredTerm(InferredIndex(i)))),\n         );\n     }\n-}\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(item.hir_id()));\n+    fn check_item(&mut self, id: hir::ItemId) {\n+        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(id.hir_id()));\n+\n+        let def_kind = self.tcx.def_kind(id.def_id);\n+        match def_kind {\n+            DefKind::Struct | DefKind::Union => {\n+                let item = self.tcx.hir().item(id);\n \n-        match item.kind {\n-            hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id());\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    self.add_inferreds_for_item(item.hir_id());\n \n-                if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = *struct_def {\n+                        self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n+                    }\n                 }\n             }\n+            DefKind::Enum => {\n+                let item = self.tcx.hir().item(id);\n \n-            hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id());\n+                if let hir::ItemKind::Enum(ref enum_def, _) = item.kind {\n+                    self.add_inferreds_for_item(item.hir_id());\n \n-                for variant in enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.data {\n-                        self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n+                    for variant in enum_def.variants {\n+                        if let hir::VariantData::Tuple(..) = variant.data {\n+                            self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n+                        }\n                     }\n                 }\n             }\n-\n-            hir::ItemKind::Fn(..) => {\n-                self.add_inferreds_for_item(item.hir_id());\n+            DefKind::Fn => {\n+                self.add_inferreds_for_item(id.hir_id());\n             }\n-\n             _ => {}\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Fn(..) = trait_item.kind {\n-            self.add_inferreds_for_item(trait_item.hir_id());\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n-            self.add_inferreds_for_item(impl_item.hir_id());\n-        }\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n-            self.add_inferreds_for_item(foreign_item.hir_id());\n-        }\n-    }\n }"}, {"sha": "2ba87db880b4671440cc85f394d86209d6858258", "filename": "compiler/rustc_typeck/src/variance/test.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1,28 +1,14 @@\n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n pub fn test_variance(tcx: TyCtxt<'_>) {\n-    tcx.hir().visit_all_item_likes(&mut VarianceTest { tcx });\n-}\n-\n-struct VarianceTest<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        // For unit testing: check for a special \"rustc_variance\"\n-        // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = self.tcx.variances_of(item.def_id);\n-            struct_span_err!(self.tcx.sess, item.span, E0208, \"{:?}\", variances_of).emit();\n+    // For unit testing: check for a special \"rustc_variance\"\n+    // attribute and report an error with various results if found.\n+    for id in tcx.hir().items() {\n+        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = tcx.variances_of(id.def_id);\n+            struct_span_err!(tcx.sess, tcx.def_span(id.def_id), E0208, \"{:?}\", variances_of).emit();\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _: &'tcx hir::ForeignItem<'tcx>) {}\n }"}, {"sha": "590475fa03a3ea9947525e40cce3e2748a43fb81", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -29,7 +29,7 @@ mod x {\n mod y {\n     use {Foo, Bar};\n \n-    #[rustc_then_this_would_need(typeck)] //~ ERROR no path\n+    #[rustc_then_this_would_need(typeck)] //~ ERROR OK\n     pub fn call_bar() {\n         char::bar('a');\n     }"}, {"sha": "4e10437362c6ba0af51171037bd3c20f8419e289", "filename": "src/test/ui/dep-graph/dep-graph-trait-impl-two-traits.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-trait-impl-two-traits.stderr?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -1,4 +1,4 @@\n-error: no path from `x::<impl Foo for char>` to `typeck`\n+error: OK\n   --> $DIR/dep-graph-trait-impl-two-traits.rs:32:5\n    |\n LL |     #[rustc_then_this_would_need(typeck)]"}, {"sha": "c5c174cc8f614b735759ff7b4d7213f16292d978", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e5570460b2bb925021dc667ead2a9834ea88cb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=f6e5570460b2bb925021dc667ead2a9834ea88cb", "patch": "@@ -51,14 +51,14 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.def_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n-                    items,\n-                    of_trait,\n-                    self_ty,\n-                    ..\n-                }) = &item.kind\n+                  items,\n+                  of_trait,\n+                  self_ty,\n+                  ..\n+                                      }) = &item.kind\n                 && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n                 if !map.contains_key(res) {"}]}