{"sha": "af3d75ad2e760dc885f54e6179543718ef8f141f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmM2Q3NWFkMmU3NjBkYzg4NWY1NGU2MTc5NTQzNzE4ZWY4ZjE0MWY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-04T16:22:42Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-04T18:00:46Z"}, "message": "Refactor TokenBuffer for reduc cloning", "tree": {"sha": "821093073f61fbfb2d3d31304dfe0eacbef0bcf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/821093073f61fbfb2d3d31304dfe0eacbef0bcf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3d75ad2e760dc885f54e6179543718ef8f141f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3d75ad2e760dc885f54e6179543718ef8f141f", "html_url": "https://github.com/rust-lang/rust/commit/af3d75ad2e760dc885f54e6179543718ef8f141f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3d75ad2e760dc885f54e6179543718ef8f141f/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ffd14922d2dc885ba6441ca8380f7d4cb75269", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ffd14922d2dc885ba6441ca8380f7d4cb75269", "html_url": "https://github.com/rust-lang/rust/commit/f1ffd14922d2dc885ba6441ca8380f7d4cb75269"}], "stats": {"total": 152, "additions": 99, "deletions": 53}, "files": [{"sha": "1923daca55766ba00ce6fe8fb9b1505c4fe68df6", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=af3d75ad2e760dc885f54e6179543718ef8f141f", "patch": "@@ -58,7 +58,7 @@ impl ProcMacroExpander {\n }\n \n fn eat_punct(cursor: &mut Cursor, c: char) -> bool {\n-    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = cursor.token_tree() {\n+    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = cursor.token_tree() {\n         if punct.char == c {\n             *cursor = cursor.bump();\n             return true;\n@@ -68,7 +68,7 @@ fn eat_punct(cursor: &mut Cursor, c: char) -> bool {\n }\n \n fn eat_subtree(cursor: &mut Cursor, kind: tt::DelimiterKind) -> bool {\n-    if let Some(tt::TokenTree::Subtree(subtree)) = cursor.token_tree() {\n+    if let Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) = cursor.token_tree() {\n         if Some(kind) == subtree.delimiter_kind() {\n             *cursor = cursor.bump_subtree();\n             return true;\n@@ -78,7 +78,7 @@ fn eat_subtree(cursor: &mut Cursor, kind: tt::DelimiterKind) -> bool {\n }\n \n fn eat_ident(cursor: &mut Cursor, t: &str) -> bool {\n-    if let Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) = cursor.token_tree() {\n+    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) = cursor.token_tree() {\n         if t == ident.text.as_str() {\n             *cursor = cursor.bump();\n             return true;\n@@ -88,7 +88,7 @@ fn eat_ident(cursor: &mut Cursor, t: &str) -> bool {\n }\n \n fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n-    let buffer = TokenBuffer::new(&tt.token_trees);\n+    let buffer = TokenBuffer::from_tokens(&tt.token_trees);\n     let mut p = buffer.begin();\n     let mut result = tt::Subtree::default();\n \n@@ -106,7 +106,7 @@ fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n             }\n         }\n \n-        result.token_trees.push(curr.token_tree()?.clone());\n+        result.token_trees.push(curr.token_tree()?.cloned());\n         p = curr.bump();\n     }\n "}, {"sha": "fdc8844cef0cdd1af52f672f61e714bf98a46dce", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=af3d75ad2e760dc885f54e6179543718ef8f141f", "patch": "@@ -309,7 +309,7 @@ impl<'a> TtIter<'a> {\n             }\n         }\n \n-        let buffer = TokenBuffer::new(&self.inner.as_slice());\n+        let buffer = TokenBuffer::from_tokens(&self.inner.as_slice());\n         let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n@@ -336,11 +336,11 @@ impl<'a> TtIter<'a> {\n             err = Some(err!(\"no tokens consumed\"));\n         }\n         let res = match res.len() {\n-            1 => Some(res[0].clone()),\n+            1 => Some(res[0].cloned()),\n             0 => None,\n             _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n                 delimiter: None,\n-                token_trees: res.into_iter().cloned().collect(),\n+                token_trees: res.into_iter().map(|it| it.cloned()).collect(),\n             })),\n         };\n         ExpandResult { value: res, err }"}, {"sha": "36d6f1038c96a793c6d7382035ecd5694198104f", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=af3d75ad2e760dc885f54e6179543718ef8f141f", "patch": "@@ -53,10 +53,12 @@ impl<'a> SubtreeTokenSource<'a> {\n         fn is_lifetime(c: Cursor) -> Option<(Cursor, SmolStr)> {\n             let tkn = c.token_tree();\n \n-            if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = tkn {\n+            if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = tkn {\n                 if punct.char == '\\'' {\n                     let next = c.bump();\n-                    if let Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) = next.token_tree() {\n+                    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) =\n+                        next.token_tree()\n+                    {\n                         let res_cursor = next.bump();\n                         let text = SmolStr::new(\"'\".to_string() + &ident.to_string());\n \n@@ -94,11 +96,11 @@ impl<'a> SubtreeTokenSource<'a> {\n                 }\n \n                 match cursor.token_tree() {\n-                    Some(tt::TokenTree::Leaf(leaf)) => {\n+                    Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n                         cached.push(Some(convert_leaf(&leaf)));\n                         self.cached_cursor.set(cursor.bump());\n                     }\n-                    Some(tt::TokenTree::Subtree(subtree)) => {\n+                    Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n                         self.cached_cursor.set(cursor.subtree().unwrap());\n                         cached.push(Some(convert_delim(subtree.delimiter_kind(), false)));\n                     }"}, {"sha": "671036e1ca60263cad25940622908cff8dd4704c", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=af3d75ad2e760dc885f54e6179543718ef8f141f", "patch": "@@ -70,15 +70,12 @@ pub fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n     fragment_kind: FragmentKind,\n ) -> Result<(Parse<SyntaxNode>, TokenMap), ExpandError> {\n-    let tmp;\n-    let tokens = match tt {\n-        tt::Subtree { delimiter: None, token_trees } => token_trees.as_slice(),\n-        _ => {\n-            tmp = [tt.clone().into()];\n-            &tmp[..]\n+    let buffer = match tt {\n+        tt::Subtree { delimiter: None, token_trees } => {\n+            TokenBuffer::from_tokens(token_trees.as_slice())\n         }\n+        _ => TokenBuffer::from_subtree(tt),\n     };\n-    let buffer = TokenBuffer::new(&tokens);\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n     parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n@@ -631,7 +628,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n             }\n             last = self.cursor;\n             let text: &str = match self.cursor.token_tree() {\n-                Some(tt::TokenTree::Leaf(leaf)) => {\n+                Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n                     // Mark the range if needed\n                     let (text, id) = match leaf {\n                         tt::Leaf::Ident(ident) => (&ident.text, ident.id),\n@@ -650,7 +647,7 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n                     self.cursor = self.cursor.bump();\n                     text\n                 }\n-                Some(tt::TokenTree::Subtree(subtree)) => {\n+                Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n                     self.cursor = self.cursor.subtree().unwrap();\n                     if let Some(id) = subtree.delimiter.map(|it| it.id) {\n                         self.open_delims.insert(id, self.text_pos);\n@@ -684,8 +681,8 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         // Add whitespace between adjoint puncts\n         let next = last.bump();\n         if let (\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(curr))),\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(_))),\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(curr), _)),\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(_), _)),\n         ) = (last.token_tree(), next.token_tree())\n         {\n             // Note: We always assume the semi-colon would be the last token in\n@@ -744,7 +741,7 @@ mod tests {\n         )\n         .expand_tt(\"literals!(foo);\");\n         let tts = &[expansion.into()];\n-        let buffer = tt::buffer::TokenBuffer::new(tts);\n+        let buffer = tt::buffer::TokenBuffer::from_tokens(tts);\n         let mut tt_src = SubtreeTokenSource::new(&buffer);\n         let mut tokens = vec![];\n         while tt_src.current().kind != EOF {"}, {"sha": "3606c887dc1b5735f6e4bbe5fc1a9d70c055c1e3", "filename": "crates/tt/src/buffer.rs", "status": "modified", "additions": 76, "deletions": 29, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Ftt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d75ad2e760dc885f54e6179543718ef8f141f/crates%2Ftt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Fbuffer.rs?ref=af3d75ad2e760dc885f54e6179543718ef8f141f", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use crate::{Subtree, TokenTree};\n+use crate::{Leaf, Subtree, TokenTree};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n struct EntryId(usize);\n@@ -13,7 +13,7 @@ struct EntryPtr(EntryId, usize);\n #[derive(Debug)]\n enum Entry<'t> {\n     // Mimicking types from proc-macro.\n-    Subtree(&'t TokenTree, EntryId),\n+    Subtree(Option<&'t TokenTree>, &'t Subtree, EntryId),\n     Leaf(&'t TokenTree),\n     // End entries contain a pointer to the entry from the containing\n     // token tree, or None if this is the outermost level.\n@@ -27,49 +27,76 @@ pub struct TokenBuffer<'t> {\n     buffers: Vec<Box<[Entry<'t>]>>,\n }\n \n-impl<'t> TokenBuffer<'t> {\n-    pub fn new(tokens: &'t [TokenTree]) -> TokenBuffer<'t> {\n-        let mut buffers = vec![];\n-\n-        let idx = TokenBuffer::new_inner(tokens, &mut buffers, None);\n-        assert_eq!(idx, 0);\n-\n-        TokenBuffer { buffers }\n-    }\n+trait TokenList<'a> {\n+    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>);\n+}\n \n-    fn new_inner(\n-        tokens: &'t [TokenTree],\n-        buffers: &mut Vec<Box<[Entry<'t>]>>,\n-        next: Option<EntryPtr>,\n-    ) -> usize {\n+impl<'a> TokenList<'a> for &'a [TokenTree] {\n+    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>) {\n         // Must contain everything in tokens and then the Entry::End\n-        let start_capacity = tokens.len() + 1;\n+        let start_capacity = self.len() + 1;\n         let mut entries = Vec::with_capacity(start_capacity);\n         let mut children = vec![];\n-\n-        for (idx, tt) in tokens.iter().enumerate() {\n+        for (idx, tt) in self.iter().enumerate() {\n             match tt {\n                 TokenTree::Leaf(_) => {\n                     entries.push(Entry::Leaf(tt));\n                 }\n                 TokenTree::Subtree(subtree) => {\n                     entries.push(Entry::End(None));\n-                    children.push((idx, (subtree, tt)));\n+                    children.push((idx, (subtree, Some(tt))));\n                 }\n             }\n         }\n+        (children, entries)\n+    }\n+}\n+\n+impl<'a> TokenList<'a> for &'a Subtree {\n+    fn entries(&self) -> (Vec<(usize, (&'a Subtree, Option<&'a TokenTree>))>, Vec<Entry<'a>>) {\n+        // Must contain everything in tokens and then the Entry::End\n+        let mut entries = vec![];\n+        let mut children = vec![];\n+        entries.push(Entry::End(None));\n+        children.push((0usize, (*self, None)));\n+        (children, entries)\n+    }\n+}\n+\n+impl<'t> TokenBuffer<'t> {\n+    pub fn from_tokens(tokens: &'t [TokenTree]) -> TokenBuffer<'t> {\n+        Self::new(tokens)\n+    }\n+\n+    pub fn from_subtree(subtree: &'t Subtree) -> TokenBuffer<'t> {\n+        Self::new(subtree)\n+    }\n+\n+    fn new<T: TokenList<'t>>(tokens: T) -> TokenBuffer<'t> {\n+        let mut buffers = vec![];\n+        let idx = TokenBuffer::new_inner(tokens, &mut buffers, None);\n+        assert_eq!(idx, 0);\n+        TokenBuffer { buffers }\n+    }\n+\n+    fn new_inner<T: TokenList<'t>>(\n+        tokens: T,\n+        buffers: &mut Vec<Box<[Entry<'t>]>>,\n+        next: Option<EntryPtr>,\n+    ) -> usize {\n+        let (children, mut entries) = tokens.entries();\n \n         entries.push(Entry::End(next));\n         let res = buffers.len();\n         buffers.push(entries.into_boxed_slice());\n \n         for (child_idx, (subtree, tt)) in children {\n             let idx = TokenBuffer::new_inner(\n-                &subtree.token_trees,\n+                subtree.token_trees.as_slice(),\n                 buffers,\n                 Some(EntryPtr(EntryId(res), child_idx + 1)),\n             );\n-            buffers[res].as_mut()[child_idx] = Entry::Subtree(tt, EntryId(idx));\n+            buffers[res].as_mut()[child_idx] = Entry::Subtree(tt, subtree, EntryId(idx));\n         }\n \n         res\n@@ -87,6 +114,24 @@ impl<'t> TokenBuffer<'t> {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum TokenTreeRef<'a> {\n+    Subtree(&'a Subtree, Option<&'a TokenTree>),\n+    Leaf(&'a Leaf, &'a TokenTree),\n+}\n+\n+impl<'a> TokenTreeRef<'a> {\n+    pub fn cloned(&self) -> TokenTree {\n+        match &self {\n+            TokenTreeRef::Subtree(subtree, tt) => match tt {\n+                Some(it) => (*it).clone(),\n+                None => (*subtree).clone().into(),\n+            },\n+            TokenTreeRef::Leaf(_, tt) => (*tt).clone(),\n+        }\n+    }\n+}\n+\n /// A safe version of `Cursor` from `syn` crate https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L125\n #[derive(Copy, Clone, Debug)]\n pub struct Cursor<'a> {\n@@ -114,12 +159,11 @@ impl<'a> Cursor<'a> {\n         match self.entry() {\n             Some(Entry::End(Some(ptr))) => {\n                 let idx = ptr.1;\n-                if let Some(Entry::Subtree(TokenTree::Subtree(subtree), _)) =\n+                if let Some(Entry::Subtree(_, subtree, _)) =\n                     self.buffer.entry(&EntryPtr(ptr.0, idx - 1))\n                 {\n                     return Some(subtree);\n                 }\n-\n                 None\n             }\n             _ => None,\n@@ -134,18 +178,21 @@ impl<'a> Cursor<'a> {\n     /// a cursor into that subtree\n     pub fn subtree(self) -> Option<Cursor<'a>> {\n         match self.entry() {\n-            Some(Entry::Subtree(_, entry_id)) => {\n+            Some(Entry::Subtree(_, _, entry_id)) => {\n                 Some(Cursor::create(self.buffer, EntryPtr(*entry_id, 0)))\n             }\n             _ => None,\n         }\n     }\n \n     /// If the cursor is pointing at a `TokenTree`, returns it\n-    pub fn token_tree(self) -> Option<&'a TokenTree> {\n+    pub fn token_tree(self) -> Option<TokenTreeRef<'a>> {\n         match self.entry() {\n-            Some(Entry::Leaf(tt)) => Some(tt),\n-            Some(Entry::Subtree(tt, _)) => Some(tt),\n+            Some(Entry::Leaf(tt)) => match tt {\n+                TokenTree::Leaf(leaf) => Some(TokenTreeRef::Leaf(leaf, *tt)),\n+                TokenTree::Subtree(subtree) => Some(TokenTreeRef::Subtree(subtree, Some(tt))),\n+            },\n+            Some(Entry::Subtree(tt, subtree, _)) => Some(TokenTreeRef::Subtree(subtree, *tt)),\n             Some(Entry::End(_)) => None,\n             None => None,\n         }\n@@ -172,7 +219,7 @@ impl<'a> Cursor<'a> {\n     /// a cursor into that subtree\n     pub fn bump_subtree(self) -> Cursor<'a> {\n         match self.entry() {\n-            Some(Entry::Subtree(_, _)) => self.subtree().unwrap(),\n+            Some(Entry::Subtree(_, _, _)) => self.subtree().unwrap(),\n             _ => self.bump(),\n         }\n     }"}]}