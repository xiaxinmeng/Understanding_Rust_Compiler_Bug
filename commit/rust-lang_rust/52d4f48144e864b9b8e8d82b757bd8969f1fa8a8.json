{"sha": "52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZDRmNDgxNDRlODY0YjliOGU4ZDgyYjc1N2JkODk2OWYxZmE4YTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T21:38:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T21:43:00Z"}, "message": "rustc: Move ivec stuff to an ivec module in trans", "tree": {"sha": "76cdffbf854832862b3829899aae4e6a854acc97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76cdffbf854832862b3829899aae4e6a854acc97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "html_url": "https://github.com/rust-lang/rust/commit/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c8e94f3975e57c63142558b9a5b23a865f902f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8e94f3975e57c63142558b9a5b23a865f902f8", "html_url": "https://github.com/rust-lang/rust/commit/6c8e94f3975e57c63142558b9a5b23a865f902f8"}], "stats": {"total": 483, "additions": 284, "deletions": 199}, "files": [{"sha": "e378a4d7b09e9c00ebd2def9bd8bab24cc13b361", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 284, "deletions": 199, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "patch": "@@ -2374,7 +2374,7 @@ fn make_numerical_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n \n // Returns the length of an interior vector and a pointer to its first\n // element, in that order.\n-fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n+fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n    tup(ValueRef, ValueRef, @block_ctxt) {\n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n     auto stack_len =\n@@ -2486,11 +2486,13 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         auto rslt = size_of(bcx, unit_ty);\n         auto unit_sz = rslt.val;\n         bcx = rslt.bcx;\n-        auto a_len_and_data = get_ivec_len_and_data(bcx, av, unit_ty);\n+\n+        auto a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n         auto a_len = a_len_and_data._0;\n         auto a_elem = a_len_and_data._1;\n         bcx = a_len_and_data._2;\n-        auto b_len_and_data = get_ivec_len_and_data(bcx, bv, unit_ty);\n+\n+        auto b_len_and_data = ivec::get_len_and_data(bcx, bv, unit_ty);\n         auto b_len = b_len_and_data._0;\n         auto b_elem = b_len_and_data._1;\n         bcx = b_len_and_data._2;\n@@ -3214,209 +3216,292 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n }\n \n \n-// Returns a tuple consisting of a pointer to the newly-reserved space and a\n-// block context. Updates the length appropriately.\n-fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n-                      ValueRef len_needed) -> result {\n-    auto stack_len_ptr =\n-        cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    auto stack_len = cx.build.Load(stack_len_ptr);\n-    auto alen =\n-        cx.build.Load(cx.build.InBoundsGEP(v,\n-                                           [C_int(0),\n-                                            C_uint(abi::ivec_elt_alen)]));\n-    // There are four cases we have to consider:\n-    // (1) On heap, no resize necessary.\n-    // (2) On heap, need to resize.\n-    // (3) On stack, no resize necessary.\n-    // (4) On stack, need to spill to heap.\n-\n-    auto maybe_on_heap =\n-        cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    auto maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n-    auto on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n-    cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb, on_stack_cx.llbb);\n-    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    // We're possibly on the heap, unless the vector is zero-length.\n+mod ivec {\n+    // Returns the length of an interior vector and a pointer to its first\n+    // element, in that order.\n+    fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n+            tup(ValueRef, ValueRef, @block_ctxt) {\n+        auto llunitty = type_of_or_i8(bcx, unit_ty);\n+        auto stack_len =\n+            bcx.build.Load(bcx.build.InBoundsGEP(v,\n+                [C_int(0), C_uint(abi::ivec_elt_len)]));\n+        auto stack_elem =\n+            bcx.build.InBoundsGEP(v,\n+                [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n+        auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len,\n+                                      C_int(0));\n+        auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n+        auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n+        auto heap_stub =\n+            on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr = {\n+            auto v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+            on_heap_cx.build.Load(on_heap_cx.build.InBoundsGEP(heap_stub, v))\n+        };\n \n-    auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+        // Check whether the heap pointer is null. If it is, the vector length\n+        // is truly zero.\n \n-    auto stub_ptr =\n-        maybe_on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    auto heap_ptr =\n-        {\n-            auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n-            maybe_on_heap_cx.build.Load(m)\n+        auto llstubty = T_ivec_heap(llunitty);\n+        auto llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n+        auto heap_ptr_is_null =\n+            on_heap_cx.build.ICmp(lib::llvm::LLVMIntEQ, heap_ptr,\n+                                  C_null(T_ptr(llheapptrty)));\n+        auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n+        auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+        on_heap_cx.build.CondBr(heap_ptr_is_null, zero_len_cx.llbb,\n+                                nonzero_len_cx.llbb);\n+        // Technically this context is unnecessary, but it makes this function\n+        // clearer.\n+\n+        auto zero_len = C_int(0);\n+        auto zero_elem = C_null(T_ptr(llunitty));\n+        zero_len_cx.build.Br(next_cx.llbb);\n+        // If we're here, then we actually have a heapified vector.\n+\n+        auto heap_len = {\n+            auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+            auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n+            nonzero_len_cx.build.Load(m)\n         };\n-    auto on_heap =\n-        maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n-                                    C_null(val_ty(heap_ptr)));\n-    auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n-    maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb, on_stack_cx.llbb);\n-    // We're definitely on the heap. Check whether we need to resize.\n-\n-    auto heap_len_ptr =\n-        on_heap_cx.build.InBoundsGEP(heap_ptr,\n-                                     [C_int(0),\n-                                      C_uint(abi::ivec_heap_elt_len)]);\n-    auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n-    auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n-    auto heap_len_unscaled =\n-        on_heap_cx.build.UDiv(heap_len, llsize_of(llunitty));\n-    auto heap_no_resize_needed =\n-        on_heap_cx.build.ICmp(lib::llvm::LLVMIntULE, new_heap_len, alen);\n-    auto heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n-    auto heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n-    on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n-                            heap_resize_cx.llbb);\n-    // Case (1): We're on the heap and don't need to resize.\n-\n-    auto heap_data_no_resize =\n-        heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n-                                            [C_int(0),\n-                                             C_uint(abi::ivec_heap_elt_elems),\n-                                             heap_len_unscaled]);\n-    heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n-    heap_no_resize_cx.build.Br(next_cx.llbb);\n-    // Case (2): We're on the heap and need to resize. This path is rare, so\n-    // we delegate to cold glue.\n-\n-    {\n-        auto p = heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-        heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n-                                  [cx.fcx.lltaskptr, p, new_heap_len]);\n-    }\n-\n-    auto heap_ptr_resize =\n+        auto heap_elem =\n+            nonzero_len_cx.build.InBoundsGEP(heap_ptr,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+        nonzero_len_cx.build.Br(next_cx.llbb);\n+\n+        // Now we can figure out the length of `v` and get a pointer to its\n+        // first element.\n+\n+        auto len =\n+            next_cx.build.Phi(T_int(),\n+                [stack_len, zero_len, heap_len],\n+                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+        auto elem =\n+            next_cx.build.Phi(T_ptr(llunitty),\n+                [stack_elem, zero_elem, heap_elem],\n+                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+        ret tup(len, elem, next_cx);\n+    }\n+\n+    // Returns a tuple consisting of a pointer to the newly-reserved space and\n+    // a block context. Updates the length appropriately.\n+    fn reserve_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n+                     ValueRef len_needed) -> result {\n+        auto stack_len_ptr =\n+            cx.build.InBoundsGEP(v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n+        auto stack_len = cx.build.Load(stack_len_ptr);\n+        auto alen =\n+            cx.build.Load(cx.build.InBoundsGEP(v,\n+                                               [C_int(0),\n+                                                C_uint(abi::ivec_elt_alen)]));\n+        // There are four cases we have to consider:\n+        // (1) On heap, no resize necessary.\n+        // (2) On heap, need to resize.\n+        // (3) On stack, no resize necessary.\n+        // (4) On stack, need to spill to heap.\n+\n+        auto maybe_on_heap =\n+            cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n+        auto maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n+        auto on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n+        cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb,\n+                        on_stack_cx.llbb);\n+        auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+        // We're possibly on the heap, unless the vector is zero-length.\n+\n+        auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+\n+        auto stub_ptr = maybe_on_heap_cx.build.PointerCast(v,\n+            T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr =\n+            {\n+                auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n+                maybe_on_heap_cx.build.Load(m)\n+            };\n+        auto on_heap =\n+            maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n+                                        C_null(val_ty(heap_ptr)));\n+        auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n+        maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb,\n+                                      on_stack_cx.llbb);\n+\n+        // We're definitely on the heap. Check whether we need to resize.\n+        auto heap_len_ptr =\n+            on_heap_cx.build.InBoundsGEP(heap_ptr,\n+                                         [C_int(0),\n+                                          C_uint(abi::ivec_heap_elt_len)]);\n+        auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n+        auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n+        auto heap_len_unscaled =\n+            on_heap_cx.build.UDiv(heap_len, llsize_of(llunitty));\n+        auto heap_no_resize_needed =\n+            on_heap_cx.build.ICmp(lib::llvm::LLVMIntULE, new_heap_len, alen);\n+        auto heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n+        auto heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n+        on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n+                                heap_resize_cx.llbb);\n+        // Case (1): We're on the heap and don't need to resize.\n+\n+        auto heap_data_no_resize =\n+            heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 heap_len_unscaled]);\n+        heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n+        heap_no_resize_cx.build.Br(next_cx.llbb);\n+\n+        // Case (2): We're on the heap and need to resize. This path is rare,\n+        // so we delegate to cold glue.\n+\n         {\n+            auto p = heap_resize_cx.build.PointerCast(v,\n+                                                      T_ptr(T_opaque_ivec()));\n+            heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n+                                      [cx.fcx.lltaskptr, p, new_heap_len]);\n+        }\n+\n+        auto heap_ptr_resize = {\n             auto m = heap_resize_cx.build.InBoundsGEP(stub_ptr, stub_p);\n             heap_resize_cx.build.Load(m)\n         };\n-    auto heap_data_resize =\n-        heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_elems),\n-                                          heap_len_unscaled]);\n-    heap_resize_cx.build.Br(next_cx.llbb);\n-    // We're on the stack. Check whether we need to spill to the heap.\n-\n-    auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n-    auto stack_no_spill_needed =\n-        on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len, alen);\n-    auto stack_len_unscaled =\n-        on_stack_cx.build.UDiv(stack_len, llsize_of(llunitty));\n-    auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n-    auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n-    on_stack_cx.build.CondBr(stack_no_spill_needed, stack_no_spill_cx.llbb,\n-                             stack_spill_cx.llbb);\n-    // Case (3): We're on the stack and don't need to spill.\n-\n-    auto stack_data_no_spill =\n-        stack_no_spill_cx.build.InBoundsGEP(v,\n-                                            [C_int(0),\n-                                             C_uint(abi::ivec_elt_elems),\n-                                             stack_len_unscaled]);\n-    stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n-    stack_no_spill_cx.build.Br(next_cx.llbb);\n-    // Case (4): We're on the stack and need to spill. Like case (2), this\n-    // path is rare, so we delegate to cold glue.\n-\n-    {\n-        auto p = stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n-        stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n-                                  [cx.fcx.lltaskptr, p, new_stack_len]);\n-    }\n-    auto spill_stub =\n-        stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-    auto heap_ptr_spill =\n-        stack_spill_cx.build.Load(stack_spill_cx.build.InBoundsGEP(spill_stub,\n-                                                                   stub_p));\n-    auto heap_len_ptr_spill =\n-        stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_len)]);\n-    auto heap_data_spill =\n-        stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                                         [C_int(0),\n-                                          C_uint(abi::ivec_heap_elt_elems),\n-                                          stack_len_unscaled]);\n-    stack_spill_cx.build.Br(next_cx.llbb);\n-    // Phi together the different data pointers to get the result.\n+        auto heap_data_resize =\n+            heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 heap_len_unscaled]);\n+        heap_resize_cx.build.Br(next_cx.llbb);\n+\n+        // We're on the stack. Check whether we need to spill to the heap.\n+        auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n+        auto stack_no_spill_needed =\n+            on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len,\n+                                   alen);\n+        auto stack_len_unscaled =\n+            on_stack_cx.build.UDiv(stack_len, llsize_of(llunitty));\n+        auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n+        auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n+        on_stack_cx.build.CondBr(stack_no_spill_needed,\n+                                 stack_no_spill_cx.llbb,\n+                                 stack_spill_cx.llbb);\n+\n+        // Case (3): We're on the stack and don't need to spill.\n+        auto stack_data_no_spill =\n+            stack_no_spill_cx.build.InBoundsGEP(v,\n+                                                [C_int(0),\n+                                                 C_uint(abi::ivec_elt_elems),\n+                                                 stack_len_unscaled]);\n+        stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n+        stack_no_spill_cx.build.Br(next_cx.llbb);\n+\n+        // Case (4): We're on the stack and need to spill. Like case (2), this\n+        // path is rare, so we delegate to cold glue.\n+        {\n+            auto p = stack_spill_cx.build.PointerCast(v,\n+                T_ptr(T_opaque_ivec()));\n+            stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n+                                      [cx.fcx.lltaskptr, p, new_stack_len]);\n+        }\n+\n+        auto spill_stub =\n+            stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n+        auto heap_ptr_spill =\n+            stack_spill_cx.build.Load(\n+                stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p));\n+        auto heap_len_ptr_spill =\n+            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+                [C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+        auto heap_data_spill =\n+            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+                [C_int(0),\n+                 C_uint(abi::ivec_heap_elt_elems),\n+                 stack_len_unscaled]);\n+        stack_spill_cx.build.Br(next_cx.llbb);\n+\n+        // Phi together the different data pointers to get the result.\n+        auto data_ptr =\n+            next_cx.build.Phi(T_ptr(llunitty),\n+                              [heap_data_no_resize, heap_data_resize,\n+                               stack_data_no_spill, heap_data_spill],\n+                              [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n+                               stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n+        ret res(next_cx, data_ptr);\n+    }\n+\n+    fn trans_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n+       result {\n+        auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n+        auto llunitty = type_of_or_i8(cx, unit_ty);\n+        auto skip_null;\n+        alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+            case (ty::ty_istr) { skip_null = true; }\n+            case (ty::ty_ivec(_)) { skip_null = false; }\n+            case (_) {\n+                cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_append\");\n+            }\n+        }\n+        // Gather the various type descriptors we'll need.\n \n-    auto data_ptr =\n-        next_cx.build.Phi(T_ptr(llunitty),\n-                          [heap_data_no_resize, heap_data_resize,\n-                           stack_data_no_spill, heap_data_spill],\n-                          [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n-                           stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n-    ret res(next_cx, data_ptr);\n-}\n+        auto rslt = get_tydesc(cx, t, false, none);\n+        auto vec_tydesc = rslt.val;\n+        auto bcx = rslt.bcx;\n+        rslt = get_tydesc(bcx, unit_ty, false, none);\n+        auto unit_tydesc = rslt.val;\n+        bcx = rslt.bcx;\n \n-fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n-   result {\n-    auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n-    auto llunitty = type_of_or_i8(cx, unit_ty);\n-    auto skip_null;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_istr) { skip_null = true; }\n-        case (ty::ty_ivec(_)) { skip_null = false; }\n-        case (_) {\n-            cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_ivec_append\");\n-        }\n-    }\n-    // Gather the various type descriptors we'll need.\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n \n-    auto rslt = get_tydesc(cx, t, false, none);\n-    auto vec_tydesc = rslt.val;\n-    auto bcx = rslt.bcx;\n-    rslt = get_tydesc(bcx, unit_ty, false, none);\n-    auto unit_tydesc = rslt.val;\n-    bcx = rslt.bcx;\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n-    auto rhs_len_and_data = get_ivec_len_and_data(bcx, rhs, unit_ty);\n-    auto rhs_len = rhs_len_and_data._0;\n-    auto rhs_data = rhs_len_and_data._1;\n-    bcx = rhs_len_and_data._2;\n-    rslt = reserve_ivec_space(bcx, llunitty, lhs, rhs_len);\n-    auto lhs_data = rslt.val;\n-    bcx = rslt.bcx;\n-    // Work out the end pointer.\n-\n-    auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n-    auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n-    // Now emit the copy loop.\n-\n-    auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(lhs_data, dest_ptr);\n-    auto src_ptr = alloca(bcx, T_ptr(llunitty));\n-    bcx.build.Store(rhs_data, src_ptr);\n-    auto copy_loop_header_cx = new_sub_block_ctxt(bcx, \"copy_loop_header\");\n-    bcx.build.Br(copy_loop_header_cx.llbb);\n-    auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n-    auto not_yet_at_end =\n-        copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE, copy_dest_ptr,\n-                                       lhs_end);\n-    auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n-    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    copy_loop_header_cx.build.CondBr(not_yet_at_end, copy_loop_body_cx.llbb,\n-                                     next_cx.llbb);\n-    auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n-    rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr, t);\n-    auto post_copy_cx = rslt.bcx;\n-    // Increment both pointers.\n-\n-    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_dest_ptr,\n-                                                            [C_int(1)]),\n-                             dest_ptr);\n-    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_src_ptr,\n-                                                            [C_int(1)]),\n-                             src_ptr);\n-    post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n-    ret res(next_cx, C_nil());\n+        auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n+        auto rhs_len = rhs_len_and_data._0;\n+        auto rhs_data = rhs_len_and_data._1;\n+\n+        bcx = rhs_len_and_data._2;\n+        rslt = reserve_space(bcx, llunitty, lhs, rhs_len);\n+        auto lhs_data = rslt.val;\n+        bcx = rslt.bcx;\n+\n+        // Work out the end pointer.\n+        auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n+        auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n+\n+        // Now emit the copy loop.\n+        auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n+        bcx.build.Store(lhs_data, dest_ptr);\n+        auto src_ptr = alloca(bcx, T_ptr(llunitty));\n+        bcx.build.Store(rhs_data, src_ptr);\n+        auto copy_loop_header_cx = new_sub_block_ctxt(bcx,\n+                                                      \"copy_loop_header\");\n+        bcx.build.Br(copy_loop_header_cx.llbb);\n+        auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n+        auto not_yet_at_end =\n+            copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+                                           copy_dest_ptr,\n+                                           lhs_end);\n+        auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n+        auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        copy_loop_header_cx.build.CondBr(not_yet_at_end,\n+                                         copy_loop_body_cx.llbb,\n+                                         next_cx.llbb);\n+        auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n+        rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr,\n+                        t);\n+        auto post_copy_cx = rslt.bcx;\n+        // Increment both pointers.\n+\n+        post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_dest_ptr,\n+                                                                [C_int(1)]),\n+                                 dest_ptr);\n+        post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_src_ptr,\n+                                                                [C_int(1)]),\n+                                 src_ptr);\n+        post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n+        ret res(next_cx, C_nil());\n+    }\n }\n \n+\n fn trans_vec_add(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n    result {\n     auto r = alloc_ty(cx, t);\n@@ -4364,7 +4449,7 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     maybe_name_value(cx.fcx.lcx.ccx, scaled_ix, \"scaled_ix\");\n     auto interior_len_and_data;\n     if (is_interior) {\n-        auto rslt = get_ivec_len_and_data(bcx, v, unit_ty);\n+        auto rslt = get_len_and_data(bcx, v, unit_ty);\n         interior_len_and_data = some(tup(rslt._0, rslt._1));\n         bcx = rslt._2;\n     } else { interior_len_and_data = none; }\n@@ -5086,7 +5171,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n }\n \n fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n-   result {\n+        result {\n     auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, typ)) {\n@@ -5330,9 +5415,9 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                 alt (op) {\n                     case (ast::add) {\n                         if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, t)) {\n-                            ret trans_ivec_append(rhs_res.bcx, t,\n-                                                  lhs_res.res.val,\n-                                                  rhs_res.val);\n+                            ret ivec::trans_append(rhs_res.bcx, t,\n+                                                   lhs_res.res.val,\n+                                                   rhs_res.val);\n                         }\n                         ret trans_vec_append(rhs_res.bcx, t, lhs_res.res.val,\n                                              rhs_res.val);"}]}