{"sha": "0b0eb8ead6604df3dc43529ffab4880c1d35fc2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMGViOGVhZDY2MDRkZjNkYzQzNTI5ZmZhYjQ4ODBjMWQzNWZjMmQ=", "commit": {"author": {"name": "cgm616", "email": "cgm616@me.com", "date": "2017-10-22T13:59:19Z"}, "committer": {"name": "cgm616", "email": "cgm616@me.com", "date": "2017-10-22T13:59:19Z"}, "message": "Undo rustfmt changes unrelated to issue", "tree": {"sha": "7d86b044a3efe1b8950410a6ba51088d24c779cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d86b044a3efe1b8950410a6ba51088d24c779cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d", "html_url": "https://github.com/rust-lang/rust/commit/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d/comments", "author": {"login": "cgm616", "id": 2502394, "node_id": "MDQ6VXNlcjI1MDIzOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2502394?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgm616", "html_url": "https://github.com/cgm616", "followers_url": "https://api.github.com/users/cgm616/followers", "following_url": "https://api.github.com/users/cgm616/following{/other_user}", "gists_url": "https://api.github.com/users/cgm616/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgm616/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgm616/subscriptions", "organizations_url": "https://api.github.com/users/cgm616/orgs", "repos_url": "https://api.github.com/users/cgm616/repos", "events_url": "https://api.github.com/users/cgm616/events{/privacy}", "received_events_url": "https://api.github.com/users/cgm616/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cgm616", "id": 2502394, "node_id": "MDQ6VXNlcjI1MDIzOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2502394?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgm616", "html_url": "https://github.com/cgm616", "followers_url": "https://api.github.com/users/cgm616/followers", "following_url": "https://api.github.com/users/cgm616/following{/other_user}", "gists_url": "https://api.github.com/users/cgm616/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgm616/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgm616/subscriptions", "organizations_url": "https://api.github.com/users/cgm616/orgs", "repos_url": "https://api.github.com/users/cgm616/repos", "events_url": "https://api.github.com/users/cgm616/events{/privacy}", "received_events_url": "https://api.github.com/users/cgm616/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "url": "https://api.github.com/repos/rust-lang/rust/commits/60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "html_url": "https://github.com/rust-lang/rust/commit/60c7bd47a56f72938bdd8a7dce328f414e1bc78f"}], "stats": {"total": 122, "additions": 41, "deletions": 81}, "files": [{"sha": "6a68ee961f071ead87784edcdab0a2435b075348", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 41, "deletions": 81, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0eb8ead6604df3dc43529ffab4880c1d35fc2d/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=0b0eb8ead6604df3dc43529ffab4880c1d35fc2d", "patch": "@@ -335,8 +335,7 @@ declare_lint! {\n /// the corresponding trait instead.\n ///\n /// **Why is this bad?**: Calling '.clone()' on an Rc, Arc, or Weak\n-/// can obscure the fact that only the pointer is being cloned, not the\n-/// underlying\n+/// can obscure the fact that only the pointer is being cloned, not the underlying\n /// data.\n ///\n /// **Example:**\n@@ -945,8 +944,12 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n         expr.span,\n         \"using '.clone()' on a ref-counted pointer\",\n         \"try this\",\n-        format!(\"{}::clone(&{})\", caller_type, snippet(cx, arg.span, \"_\")),\n+        format!(\"{}::clone(&{})\",\n+            caller_type,\n+            snippet(cx, arg.span, \"_\")\n+        )\n     );\n+\n }\n \n \n@@ -1004,8 +1007,8 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n }\n \n fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n-        && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) &&\n+        derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n         span_lint(\n             cx,\n@@ -1180,16 +1183,8 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" {\n-            \"None\"\n-        } else {\n-            \"a\"\n-        };\n-        let suggest = if unwrap_snippet == \"None\" {\n-            \"and_then(f)\"\n-        } else {\n-            \"map_or(a, f)\"\n-        };\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let suggest = if unwrap_snippet == \"None\" { \"and_then(f)\" } else { \"map_or(a, f)\" };\n         let msg = &format!(\n             \"called `map(f).unwrap_or({})` on an Option value. \\\n              This can be done more directly by calling `{}` instead\",\n@@ -1220,12 +1215,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    map_args: &'tcx [hir::Expr],\n-    unwrap_args: &'tcx [hir::Expr],\n-) {\n+fn lint_map_unwrap_or_else<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr], unwrap_args: &'tcx [hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -1259,6 +1249,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n+\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n         let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n@@ -1274,9 +1265,13 @@ fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n             let map_or_self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let map_or_func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n             let hint = format!(\"{0}.and_then({1})\", map_or_self_snippet, map_or_func_snippet);\n-            span_lint_and_then(cx, OPTION_MAP_OR_NONE, expr.span, msg, |db| {\n-                db.span_suggestion(expr.span, \"try using and_then instead\", hint);\n-            });\n+            span_lint_and_then(\n+                cx,\n+                OPTION_MAP_OR_NONE,\n+                expr.span,\n+                msg,\n+                |db| { db.span_suggestion(expr.span, \"try using and_then instead\", hint); },\n+            );\n         }\n     }\n }\n@@ -1305,12 +1300,7 @@ fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n-) {\n+fn lint_filter_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n@@ -1320,12 +1310,7 @@ fn lint_filter_map<'a, 'tcx>(\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n-) {\n+fn lint_filter_map_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n@@ -1335,12 +1320,7 @@ fn lint_filter_map_map<'a, 'tcx>(\n }\n \n /// lint use of `filter().flat_map()` for `Iterators`\n-fn lint_filter_flat_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n-) {\n+fn lint_filter_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n@@ -1351,12 +1331,7 @@ fn lint_filter_flat_map<'a, 'tcx>(\n }\n \n /// lint use of `filter_map().flat_map()` for `Iterators`\n-fn lint_filter_map_flat_map<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n-) {\n+fn lint_filter_map_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n@@ -1427,13 +1402,7 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n-    chain_methods: &[&str],\n-    lint: &'static Lint,\n-    suggest: &str,\n-) -> bool {\n+fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n     if_let_chain! {[\n         let Some(args) = method_chain_args(info.chain, chain_methods),\n         let hir::ExprCall(ref fun, ref arg_char) = info.other.node,\n@@ -1480,13 +1449,7 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n-    chain_methods: &[&str],\n-    lint: &'static Lint,\n-    suggest: &str,\n-) -> bool {\n+fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n     if_let_chain! {[\n         let Some(args) = method_chain_args(info.chain, chain_methods),\n         let hir::ExprLit(ref lit) = info.other.node,\n@@ -1530,21 +1493,15 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n     let parent_item = cx.tcx.hir.get_parent(arg.id);\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    if let Ok(&ty::Const {\n-        val: ConstVal::Str(r),\n-        ..\n-    }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg)\n-    {\n+    if let Ok(&ty::Const { val: ConstVal::Str(r), .. }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(\n                 cx,\n                 SINGLE_CHAR_PATTERN,\n                 arg.span,\n                 \"single-character string constant used as pattern\",\n-                |db| {\n-                    db.span_suggestion(expr.span, \"try using a char instead\", hint);\n-                },\n+                |db| { db.span_suggestion(expr.span, \"try using a char instead\", hint); },\n             );\n         }\n     }\n@@ -1715,24 +1672,27 @@ impl SelfKind {\n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n-            param.name == seg.name\n-                && param\n+            param.name == seg.name &&\n+                param\n                     .bounds\n                     .iter()\n                     .any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n                         let path = &ptr.trait_ref.path;\n-                        match_path(path, name)\n-                            && path.segments\n+                        match_path(path, name) &&\n+                            path.segments\n                                 .last()\n-                                .map_or(false, |s| if let Some(ref params) = s.parameters {\n-                                    if params.parenthesized {\n-                                        false\n+                                .map_or(false, |s| {\n+                                    if let Some(ref params) = s.parameters {\n+                                        if params.parenthesized {\n+                                            false\n+                                        } else {\n+                                            params.types.len() == 1 &&\n+                                                (is_self_ty(&params.types[0])\n+                                                  || is_ty(&*params.types[0], self_ty))\n+                                        }\n                                     } else {\n-                                        params.types.len() == 1\n-                                            && (is_self_ty(&params.types[0]) || is_ty(&*params.types[0], self_ty))\n+                                        false\n                                     }\n-                                } else {\n-                                    false\n                                 })\n                     } else {\n                         false"}]}