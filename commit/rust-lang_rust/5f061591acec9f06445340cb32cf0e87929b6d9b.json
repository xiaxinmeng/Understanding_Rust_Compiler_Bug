{"sha": "5f061591acec9f06445340cb32cf0e87929b6d9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMDYxNTkxYWNlYzlmMDY0NDUzNDBjYjMyY2YwZTg3OTI5YjZkOWI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-06T19:19:51Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-06T19:19:51Z"}, "message": "Merge remote-tracking branch 'graydon/master'", "tree": {"sha": "21192e19dafd57b0049c2bbbf3c672ebf0220d14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21192e19dafd57b0049c2bbbf3c672ebf0220d14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f061591acec9f06445340cb32cf0e87929b6d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f061591acec9f06445340cb32cf0e87929b6d9b", "html_url": "https://github.com/rust-lang/rust/commit/5f061591acec9f06445340cb32cf0e87929b6d9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f061591acec9f06445340cb32cf0e87929b6d9b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7bd3f695b62a49d73b2f322681d0b1550e8a055", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bd3f695b62a49d73b2f322681d0b1550e8a055", "html_url": "https://github.com/rust-lang/rust/commit/c7bd3f695b62a49d73b2f322681d0b1550e8a055"}, {"sha": "23210a3293d34822579d8a58b043694286595daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/23210a3293d34822579d8a58b043694286595daf", "html_url": "https://github.com/rust-lang/rust/commit/23210a3293d34822579d8a58b043694286595daf"}], "stats": {"total": 11057, "additions": 5170, "deletions": 5887}, "files": [{"sha": "3d0a1ba8c0968ca8c91fbc368e570ae6e707fb21", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -88,13 +88,13 @@ const worst_case_glue_call_args: int = 7;\n \n const abi_version: uint = 1u;\n \n-fn memcpy_glue_name() -> istr { ret ~\"rust_memcpy_glue\"; }\n+fn memcpy_glue_name() -> str { ret \"rust_memcpy_glue\"; }\n \n-fn bzero_glue_name() -> istr { ret ~\"rust_bzero_glue\"; }\n+fn bzero_glue_name() -> str { ret \"rust_bzero_glue\"; }\n \n-fn yield_glue_name() -> istr { ret ~\"rust_yield_glue\"; }\n+fn yield_glue_name() -> str { ret \"rust_yield_glue\"; }\n \n-fn no_op_type_glue_name() -> istr { ret ~\"rust_no_op_type_glue\"; }\n+fn no_op_type_glue_name() -> str { ret \"rust_no_op_type_glue\"; }\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0bbdafd1e6bf2d876043a815f167c1e47ff3e81a", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 99, "deletions": 100, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -31,37 +31,35 @@ tag output_type {\n     output_type_exe;\n }\n \n-fn llvm_err(sess: session::session, msg: &istr) {\n+fn llvm_err(sess: session::session, msg: &str) {\n     let buf = llvm::LLVMRustGetLastError();\n     if buf == std::ptr::null() {\n         sess.fatal(msg);\n-    } else {\n-        sess.fatal(\n-            msg + ~\": \" + str::str_from_cstr(buf));\n-    }\n+    } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n }\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n-    let path =\n-        fs::connect(sess.get_opts().sysroot,\n-                    ~\"lib/intrinsics.bc\");\n-    let membuf = str::as_buf(path, { |buf|\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-    });\n+    let path = fs::connect(sess.get_opts().sysroot, \"lib/intrinsics.bc\");\n+    let membuf =\n+        str::as_buf(\n+            path,\n+            {|buf|\n+                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+            });\n     if membuf as uint == 0u {\n-        llvm_err(sess, ~\"installation problem: couldn't open \" + path);\n+        llvm_err(sess, \"installation problem: couldn't open \" + path);\n         fail;\n     }\n     let llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n     llvm::LLVMDisposeMemoryBuffer(membuf);\n     if llintrinsicsmod as uint == 0u {\n-        llvm_err(sess, ~\"installation problem: couldn't parse intrinsics.bc\");\n+        llvm_err(sess, \"installation problem: couldn't parse intrinsics.bc\");\n         fail;\n     }\n     let linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n     if linkres == False {\n-        llvm_err(sess, ~\"couldn't link the module with the intrinsics\");\n+        llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n     }\n }\n@@ -77,15 +75,15 @@ mod write {\n \n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n-    fn mk_intermediate_name(output_path: &istr, extension: &istr) -> istr {\n+    fn mk_intermediate_name(output_path: &str, extension: &str) -> str {\n         let dot_pos = str::index(output_path, '.' as u8);\n         let stem;\n         if dot_pos < 0 {\n             stem = output_path;\n         } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n-        ret stem + ~\".\" + extension;\n+        ret stem + \".\" + extension;\n     }\n-    fn run_passes(sess: session::session, llmod: ModuleRef, output: &istr) {\n+    fn run_passes(sess: session::session, llmod: ModuleRef, output: &str) {\n         let opts = sess.get_opts();\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n@@ -102,17 +100,19 @@ mod write {\n             alt opts.output_type {\n               output_type_bitcode. {\n                 if opts.optimize != 0u {\n-                    let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n-                    str::as_buf(filename, { |buf|\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                    });\n+                    let filename = mk_intermediate_name(output, \"no-opt.bc\");\n+                    str::as_buf(filename,\n+                                {|buf|\n+                                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                                });\n                 }\n               }\n               _ {\n-                let filename = mk_intermediate_name(output, ~\"bc\");\n-                str::as_buf(filename, { |buf|\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                });\n+                let filename = mk_intermediate_name(output, \"bc\");\n+                str::as_buf(filename,\n+                            {|buf|\n+                                llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                            });\n               }\n             }\n         }\n@@ -183,25 +183,28 @@ mod write {\n             if opts.save_temps {\n                 // Always output the bitcode file with --save-temps\n \n-                let filename = mk_intermediate_name(output, ~\"opt.bc\");\n+                let filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                str::as_buf(filename, { |buf|\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                });\n+                str::as_buf(filename,\n+                            {|buf|\n+                                llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                            });\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n                     let _: () =\n-                        str::as_buf(x86::get_target_triple(), { |buf_t|\n-                            str::as_buf(output, { |buf_o|\n+                        str::as_buf(x86::get_target_triple(), {|buf_t|\n+                            str::as_buf(output, {|buf_o|\n                                 llvm::LLVMRustWriteOutputFile(\n-                                    pm.llpm, llmod,\n+                                    pm.llpm,\n+                                    llmod,\n                                     buf_t,\n                                     buf_o,\n                                     LLVMAssemblyFile,\n                                     CodeGenOptLevel)\n-                                                 })});\n+                            })\n+                        });\n                 }\n \n \n@@ -210,28 +213,32 @@ mod write {\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n                     let _: () =\n-                        str::as_buf(x86::get_target_triple(), { |buf_t|\n-                            str::as_buf(output, { |buf_o|\n-                                llvm::LLVMRustWriteOutputFile(\n-                                    pm.llpm, llmod,\n-                                    buf_t,\n-                                    buf_o,\n-                                    LLVMObjectFile,\n-                                    CodeGenOptLevel)\n-                                                 })});\n+                        str::as_buf(x86::get_target_triple(), {|buf_t|\n+                            str::as_buf(output, {|buf_o|\n+                                llvm::LLVMRustWriteOutputFile(pm.llpm,\n+                                                              llmod,\n+                                                              buf_t,\n+                                                              buf_o,\n+                                                              LLVMObjectFile,\n+                                                              CodeGenOptLevel)\n+                            })\n+                    });\n                 }\n             } else {\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n \n-                let _: () = str::as_buf(x86::get_target_triple(), { |buf_t|\n-                    str::as_buf(output, { |buf_o|\n-                        llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                                      buf_t,\n-                                                      buf_o,\n-                                                      FileType,\n-                                                      CodeGenOptLevel)\n-                                         })});\n+                let _: () =\n+                    str::as_buf(x86::get_target_triple(), {|buf_t|\n+                        str::as_buf(output, {|buf_o|\n+                            llvm::LLVMRustWriteOutputFile(pm.llpm,\n+                                                          llmod,\n+                                                          buf_t,\n+                                                          buf_o,\n+                                                          FileType,\n+                                                          CodeGenOptLevel)\n+                            })\n+                    });\n             }\n             // Clean up and return\n \n@@ -243,9 +250,8 @@ mod write {\n         // flag, then output it here\n \n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n-        str::as_buf(output, { |buf|\n-            llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-        });\n+        str::as_buf(output,\n+                    {|buf| llvm::LLVMWriteBitcodeToFile(llmod, buf) });\n         llvm::LLVMDisposeModule(llmod);\n         if opts.time_llvm_passes { llvm::LLVMRustPrintPassTimings(); }\n     }\n@@ -303,30 +309,30 @@ mod write {\n  *\n  */\n \n-type link_meta = {name: istr, vers: istr, extras_hash: istr};\n+type link_meta = {name: str, vers: str, extras_hash: str};\n \n-fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n+fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option::t<istr>,\n-         vers: option::t<istr>,\n+        {name: option::t<str>,\n+         vers: option::t<str>,\n          cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n        provided_metas {\n-        let name: option::t<istr> = none;\n-        let vers: option::t<istr> = none;\n+        let name: option::t<str> = none;\n+        let vers: option::t<str> = none;\n         let cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item in linkage_metas {\n-            if attr::get_meta_item_name(meta) == ~\"name\" {\n+            if attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n                   none. { cmh_items += [meta]; }\n                 }\n-            } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n+            } else if attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n                   none. { cmh_items += [meta]; }\n@@ -338,12 +344,12 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n-                              metas: &provided_metas) -> istr {\n-        fn len_and_str(s: &istr) -> istr {\n+                              metas: &provided_metas) -> str {\n+        fn len_and_str(s: &str) -> str {\n             ret #fmt[\"%u_%s\", str::byte_len(s), s];\n         }\n \n-        fn len_and_str_lit(l: &ast::lit) -> istr {\n+        fn len_and_str_lit(l: &ast::lit) -> str {\n             ret len_and_str(pprust::lit_to_str(@l));\n         }\n \n@@ -357,9 +363,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n                 sha.input_str(len_and_str(key));\n                 sha.input_str(len_and_str_lit(value));\n               }\n-              ast::meta_word(name) {\n-                sha.input_str(len_and_str(name));\n-              }\n+              ast::meta_word(name) { sha.input_str(len_and_str(name)); }\n               ast::meta_list(_, _) {\n                 // FIXME (#607): Implement this\n                 fail \"unimplemented meta_item variant\";\n@@ -369,40 +373,37 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n         ret truncated_sha1_result(sha);\n     }\n \n-    fn warn_missing(sess: &session::session, name: &istr, default: &istr) {\n+    fn warn_missing(sess: &session::session, name: &str, default: &str) {\n         if !sess.get_opts().library { ret; }\n-        sess.warn(\n-            #fmt[\"missing crate link meta '%s', using '%s' as default\",\n+        sess.warn(#fmt[\"missing crate link meta '%s', using '%s' as default\",\n                        name, default]);\n     }\n \n     fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n-                       output: &istr, metas: &provided_metas) -> istr {\n+                       output: &str, metas: &provided_metas) -> str {\n         ret alt metas.name {\n               some(v) { v }\n               none. {\n                 let name =\n                     {\n-                        let os = str::split(\n-                            fs::basename(output),\n-                            '.' as u8);\n+                        let os = str::split(fs::basename(output), '.' as u8);\n                         assert (vec::len(os) >= 2u);\n                         vec::pop(os);\n-                        str::connect(os, ~\".\")\n+                        str::connect(os, \".\")\n                     };\n-                warn_missing(sess, ~\"name\", name);\n+                warn_missing(sess, \"name\", name);\n                 name\n               }\n             };\n     }\n \n     fn crate_meta_vers(sess: &session::session, _crate: &ast::crate,\n-                       metas: &provided_metas) -> istr {\n+                       metas: &provided_metas) -> str {\n         ret alt metas.vers {\n               some(v) { v }\n               none. {\n-                let vers = ~\"0.0\";\n-                warn_missing(sess, ~\"vers\", vers);\n+                let vers = \"0.0\";\n+                warn_missing(sess, \"vers\", vers);\n                 vers\n               }\n             };\n@@ -416,32 +417,32 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n     ret {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_sha1_result(sha: sha1) -> istr {\n+fn truncated_sha1_result(sha: sha1) -> str {\n     ret str::substr(sha.result_str(), 0u, 16u);\n }\n \n \n // This calculates STH for a symbol, as defined above\n fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n-   istr {\n+   str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     sha.reset();\n     sha.input_str(link_meta.name);\n-    sha.input_str(~\"-\");\n+    sha.input_str(\"-\");\n     // FIXME: This wants to be link_meta.meta_hash\n     sha.input_str(link_meta.name);\n-    sha.input_str(~\"-\");\n+    sha.input_str(\"-\");\n     sha.input_str(encoder::encoded_ty(tcx, t));\n     let hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n \n-    ret ~\"_\" + hash;\n+    ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> istr {\n-    let hash = ~\"\";\n+fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n+    let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n       none. {\n@@ -452,48 +453,46 @@ fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> istr {\n     ret hash;\n }\n \n-fn mangle(ss: &[istr]) -> istr {\n+fn mangle(ss: &[str]) -> str {\n     // Follow C++ namespace-mangling style\n \n-    let n = ~\"_ZN\"; // Begin name-sequence.\n+    let n = \"_ZN\"; // Begin name-sequence.\n \n-    for s: istr in ss {\n-        n += #fmt[\"%u%s\", str::byte_len(s), s];\n-    }\n-    n += ~\"E\"; // End name-sequence.\n+    for s: str in ss { n += #fmt[\"%u%s\", str::byte_len(s), s]; }\n+    n += \"E\"; // End name-sequence.\n \n     ret n;\n }\n \n-fn exported_name(path: &[istr], hash: &istr, _vers: &istr) -> istr {\n+fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + [hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(ccx: &@crate_ctxt, path: &[istr], t: ty::t) -> istr {\n+fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &istr)\n-   -> istr {\n+fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &str)\n+   -> str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[istr],\n-                                        flav: &istr) -> istr {\n+fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n+                                        flav: &str) -> str {\n     ret mangle(path + [ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[istr]) -> istr {\n+fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[str]) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &istr) -> istr {\n+fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &str) -> str {\n     ret ccx.names.next(flav);\n }\n //"}, {"sha": "c3ae653316b2266569c792f4295fc150934646f6", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -46,16 +46,14 @@ type upcalls =\n \n fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n-    fn decl(llmod: ModuleRef, name: &istr, tys: [TypeRef], rv: TypeRef) ->\n+    fn decl(llmod: ModuleRef, name: &str, tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let arg_tys: [TypeRef] = [];\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n-        ret trans::decl_cdecl_fn(llmod,\n-                                 ~\"upcall_\" + name, fn_ty);\n+        ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef,\n-                         name: &istr,\n+    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef, name: &str,\n                          tys: [TypeRef], rv: TypeRef) -> ValueRef {\n         ret decl(llmod, name, [taskptr_type] + tys, rv);\n     }\n@@ -64,44 +62,45 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n     let dr = bind decl(llmod, _, _, _);\n \n     let empty_vec: [TypeRef] = [];\n-    ret @{grow_task: dv(~\"grow_task\", [T_size_t()]),\n-          _yield: dv(~\"yield\", empty_vec),\n-          sleep: dv(~\"sleep\", [T_size_t()]),\n-          _fail: dv(~\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-          kill: dv(~\"kill\", [taskptr_type]),\n-          exit: dv(~\"exit\", empty_vec),\n+    ret @{grow_task: dv(\"grow_task\", [T_size_t()]),\n+          _yield: dv(\"yield\", empty_vec),\n+          sleep: dv(\"sleep\", [T_size_t()]),\n+          _fail: dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+          kill: dv(\"kill\", [taskptr_type]),\n+          exit: dv(\"exit\", empty_vec),\n           malloc:\n-              d(~\"malloc\", [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-          free: dv(~\"free\", [T_ptr(T_i8()), T_int()]),\n+              d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n+          free: dv(\"free\", [T_ptr(T_i8()), T_int()]),\n           shared_malloc:\n-              d(~\"shared_malloc\", [T_size_t(), T_ptr(tydesc_type)],\n+              d(\"shared_malloc\", [T_size_t(), T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n-          shared_free: dv(~\"shared_free\", [T_ptr(T_i8())]),\n-          mark: d(~\"mark\", [T_ptr(T_i8())], T_int()),\n+          shared_free: dv(\"shared_free\", [T_ptr(T_i8())]),\n+          mark: d(\"mark\", [T_ptr(T_i8())], T_int()),\n           get_type_desc:\n-              d(~\"get_type_desc\",\n+              d(\"get_type_desc\",\n                 [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n                  T_ptr(T_ptr(tydesc_type)), T_int()], T_ptr(tydesc_type)),\n           vec_grow:\n-              d(~\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()],\n+              d(\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()],\n                 T_void()),\n           vec_push:\n-              d(~\"vec_push\",\n+              d(\"vec_push\",\n                 [T_ptr(T_ptr(T_opaque_vec())), T_ptr(tydesc_type),\n                  T_ptr(T_i8())], T_void()),\n           cmp_type:\n-              dr(~\"cmp_type\",\n+              dr(\"cmp_type\",\n                  [T_ptr(T_i1()), taskptr_type, T_ptr(tydesc_type),\n                   T_ptr(T_ptr(tydesc_type)), T_ptr(T_i8()), T_ptr(T_i8()),\n                   T_i8()], T_void()),\n           log_type:\n-              dr(~\"log_type\",\n+              dr(\"log_type\",\n                  [taskptr_type, T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()],\n                  T_void()),\n-          dynastack_mark: d(~\"dynastack_mark\", [], T_ptr(T_i8())),\n-          dynastack_alloc: d(~\"dynastack_alloc_2\",\n-                             [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-          dynastack_free: d(~\"dynastack_free\", [T_ptr(T_i8())], T_void())};\n+          dynastack_mark: d(\"dynastack_mark\", [], T_ptr(T_i8())),\n+          dynastack_alloc:\n+              d(\"dynastack_alloc_2\", [T_size_t(), T_ptr(tydesc_type)],\n+                T_ptr(T_i8())),\n+          dynastack_free: d(\"dynastack_free\", [T_ptr(T_i8())], T_void())};\n }\n //\n // Local Variables:"}, {"sha": "80f0245a3cdda0d3e9e6e04ddf50ee11c1dec9ed", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,32 +4,30 @@ import lib::llvm::llvm::ModuleRef;\n import std::str;\n import std::os::target_os;\n \n-fn get_module_asm() -> istr { ret ~\"\"; }\n+fn get_module_asm() -> str { ret \"\"; }\n \n-fn get_meta_sect_name() -> istr {\n-    if str::eq(target_os(), ~\"macos\") { ret ~\"__DATA,__note.rustc\"; }\n-    if str::eq(target_os(), ~\"win32\") { ret ~\".note.rustc\"; }\n-    ret ~\".note.rustc\";\n+fn get_meta_sect_name() -> str {\n+    if str::eq(target_os(), \"macos\") { ret \"__DATA,__note.rustc\"; }\n+    if str::eq(target_os(), \"win32\") { ret \".note.rustc\"; }\n+    ret \".note.rustc\";\n }\n \n-fn get_data_layout() -> istr {\n-    if str::eq(target_os(), ~\"macos\") {\n-        ret ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n-            ~\"-i32:32:32-i64:32:64\" +\n-            ~\"-f32:32:32-f64:32:64-v64:64:64\" +\n-            ~\"-v128:128:128-a0:0:64-f80:128:128\" +\n-            ~\"-n8:16:32\";\n+fn get_data_layout() -> str {\n+    if str::eq(target_os(), \"macos\") {\n+        ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" + \"-i32:32:32-i64:32:64\" +\n+                \"-f32:32:32-f64:32:64-v64:64:64\" +\n+                \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\";\n     }\n-    if str::eq(target_os(), ~\"win32\") {\n-        ret ~\"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n+    if str::eq(target_os(), \"win32\") {\n+        ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n-    ret ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n+    ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n-fn get_target_triple() -> istr {\n-    if str::eq(target_os(), ~\"macos\") { ret ~\"i686-apple-darwin\"; }\n-    if str::eq(target_os(), ~\"win32\") { ret ~\"i686-pc-mingw32\"; }\n-    ret ~\"i686-unknown-linux-gnu\";\n+fn get_target_triple() -> str {\n+    if str::eq(target_os(), \"macos\") { ret \"i686-apple-darwin\"; }\n+    if str::eq(target_os(), \"win32\") { ret \"i686-pc-mingw32\"; }\n+    ret \"i686-unknown-linux-gnu\";\n }\n //\n // Local Variables:"}, {"sha": "9f8249215e8941295f3ad6b7038ec58de7274a61", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 191, "deletions": 226, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -41,29 +41,26 @@ import back::link::output_type;\n \n tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n \n-fn default_configuration(sess: session::session,\n-                         argv0: &istr, input: &istr) ->\n+fn default_configuration(sess: session::session, argv0: &str, input: &str) ->\n    ast::crate_cfg {\n     let libc =\n         alt sess.get_targ_cfg().os {\n-          session::os_win32. { ~\"msvcrt.dll\" }\n-          session::os_macos. { ~\"libc.dylib\" }\n-          session::os_linux. { ~\"libc.so.6\" }\n-          _ { ~\"libc.so\" }\n+          session::os_win32. { \"msvcrt.dll\" }\n+          session::os_macos. { \"libc.dylib\" }\n+          session::os_linux. { \"libc.so.6\" }\n+          _ { \"libc.so\" }\n         };\n \n     let mk = attr::mk_name_value_item_str;\n \n     ret [ // Target bindings.\n-         mk(~\"target_os\", std::os::target_os()),\n-        mk(~\"target_arch\", ~\"x86\"),\n-         mk(~\"target_libc\", libc),\n+         mk(\"target_os\", std::os::target_os()), mk(\"target_arch\", \"x86\"),\n+         mk(\"target_libc\", libc),\n          // Build bindings.\n-         mk(~\"build_compiler\", argv0),\n-        mk(~\"build_input\", input)];\n+         mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n }\n \n-fn build_configuration(sess: session::session, argv0: &istr, input: &istr) ->\n+fn build_configuration(sess: session::session, argv0: &str, input: &str) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -72,51 +69,46 @@ fn build_configuration(sess: session::session, argv0: &istr, input: &istr) ->\n     // If the user wants a test runner, then add the test cfg\n     let gen_cfg =\n         {\n-            if sess.get_opts().test\n-                && !attr::contains_name(user_cfg, ~\"test\") {\n-                [attr::mk_word_item(~\"test\")]\n+            if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n+               {\n+                [attr::mk_word_item(\"test\")]\n             } else { [] }\n         };\n     ret user_cfg + gen_cfg + default_cfg;\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: &[istr]) -> ast::crate_cfg {\n+fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let words = [];\n-    for s: istr in cfgspecs {\n-        words += [attr::mk_word_item(s)];\n-    }\n+    for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n     ret words;\n }\n \n-fn input_is_stdin(filename: &istr) -> bool { filename == ~\"-\" }\n+fn input_is_stdin(filename: &str) -> bool { filename == \"-\" }\n \n-fn parse_input(sess: session::session, cfg: &ast::crate_cfg,\n-               input: &istr) -> @ast::crate {\n+fn parse_input(sess: session::session, cfg: &ast::crate_cfg, input: &str) ->\n+   @ast::crate {\n     if !input_is_stdin(input) {\n-        parser::parse_crate_from_file(\n-            input, cfg, sess.get_parse_sess())\n+        parser::parse_crate_from_file(input, cfg, sess.get_parse_sess())\n     } else { parse_input_src(sess, cfg, input).crate }\n }\n \n-fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg,\n-                   infile: &istr) -> {crate: @ast::crate, src: istr} {\n+fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: &str)\n+   -> {crate: @ast::crate, src: str} {\n     let srcbytes =\n-        if infile != ~\"-\" {\n+        if infile != \"-\" {\n             io::file_reader(infile)\n         } else { io::stdin() }.read_whole_stream();\n     let src = str::unsafe_from_bytes(srcbytes);\n     let crate =\n-        parser::parse_crate_from_source_str(\n-            infile,\n-            src, cfg,\n-            sess.get_parse_sess());\n+        parser::parse_crate_from_source_str(infile, src, cfg,\n+                                            sess.get_parse_sess());\n     ret {crate: crate, src: src};\n }\n \n-fn time<@T>(do_it: bool, what: &istr, thunk: fn() -> T) -> T {\n+fn time<@T>(do_it: bool, what: &str, thunk: fn() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n@@ -126,73 +118,70 @@ fn time<@T>(do_it: bool, what: &istr, thunk: fn() -> T) -> T {\n     ret rv;\n }\n \n-fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &istr,\n-                 output: &istr) {\n+fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &str,\n+                 output: &str) {\n     let time_passes = sess.get_opts().time_passes;\n     let crate =\n-        time(time_passes, ~\"parsing\", bind parse_input(sess, cfg, input));\n+        time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n     if sess.get_opts().parse_only { ret; }\n     crate =\n-        time(time_passes, ~\"configuration\",\n+        time(time_passes, \"configuration\",\n              bind front::config::strip_unconfigured_items(crate));\n     if sess.get_opts().test {\n         crate =\n-            time(time_passes, ~\"building test harness\",\n+            time(time_passes, \"building test harness\",\n                  bind front::test::modify_for_testing(crate));\n     }\n     crate =\n-        time(time_passes, ~\"expansion\",\n+        time(time_passes, \"expansion\",\n              bind syntax::ext::expand::expand_crate(sess, crate));\n \n     let ast_map =\n-        time(time_passes, ~\"ast indexing\",\n+        time(time_passes, \"ast indexing\",\n              bind middle::ast_map::map_crate(*crate));\n-    time(time_passes, ~\"external crate/lib resolution\",\n+    time(time_passes, \"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n     let {def_map: def_map, ext_map: ext_map} =\n-        time(time_passes, ~\"resolution\",\n+        time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     let freevars =\n-        time(time_passes, ~\"freevar finding\",\n+        time(time_passes, \"freevar finding\",\n              bind freevars::annotate_freevars(def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n-    time(time_passes, ~\"typechecking\",\n-         bind typeck::check_crate(ty_cx, crate));\n-    time(time_passes, ~\"alt checking\",\n+    time(time_passes, \"typechecking\", bind typeck::check_crate(ty_cx, crate));\n+    time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n     if sess.get_opts().run_typestate {\n-        time(time_passes, ~\"typestate checking\",\n+        time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n-    let mut_map = time(time_passes, ~\"mutability checking\",\n-                       bind middle::mut::check_crate(ty_cx, crate));\n-    time(time_passes, ~\"alias checking\",\n+    let mut_map =\n+        time(time_passes, \"mutability checking\",\n+             bind middle::mut::check_crate(ty_cx, crate));\n+    time(time_passes, \"alias checking\",\n          bind middle::alias::check_crate(ty_cx, crate));\n-    time(time_passes, ~\"kind checking\",\n-         bind kind::check_crate(ty_cx, crate));\n+    time(time_passes, \"kind checking\", bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n-    let llmod = time(time_passes, ~\"translation\",\n-                     bind trans::trans_crate(sess, crate, ty_cx,\n-                                             output,\n-                                             ast_map, mut_map));\n-    time(time_passes, ~\"LLVM passes\",\n+    let llmod =\n+        time(time_passes, \"translation\",\n+             bind trans::trans_crate(sess, crate, ty_cx, output, ast_map,\n+                                     mut_map));\n+    time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, output));\n }\n \n fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n-                      input: &istr, ppm: pp_mode) {\n+                      input: &str, ppm: pp_mode) {\n     fn ann_paren_for_expr(node: &pprust::ann_node) {\n         alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n     }\n     fn ann_typed_post(tcx: &ty::ctxt, node: &pprust::ann_node) {\n         alt node {\n           pprust::node_expr(s, expr) {\n             pp::space(s.s);\n-            pp::word(s.s, ~\"as\");\n+            pp::word(s.s, \"as\");\n             pp::space(s.s);\n-            pp::word(\n-                s.s,\n-                ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pprust::pclose(s);\n           }\n           _ { }\n@@ -202,18 +191,16 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n         alt node {\n           pprust::node_item(s, item) {\n             pp::space(s.s);\n-            pprust::synth_comment(\n-                s, int::to_str(item.id, 10u));\n+            pprust::synth_comment(s, int::to_str(item.id, 10u));\n           }\n           pprust::node_block(s, blk) {\n             pp::space(s.s);\n-            pprust::synth_comment(\n-                s, ~\"block \" + int::to_str(blk.node.id, 10u));\n+            pprust::synth_comment(s,\n+                                  \"block \" + int::to_str(blk.node.id, 10u));\n           }\n           pprust::node_expr(s, expr) {\n             pp::space(s.s);\n-            pprust::synth_comment(\n-                s, int::to_str(expr.id, 10u));\n+            pprust::synth_comment(s, int::to_str(expr.id, 10u));\n             pprust::pclose(s);\n           }\n           _ { }\n@@ -249,26 +236,20 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n       }\n       ppm_normal. { ann = pprust::no_ann(); }\n     }\n-    pprust::print_crate(sess.get_codemap(), crate,\n-                        input,\n-                        io::string_reader(src),\n-                        io::stdout(), ann);\n+    pprust::print_crate(sess.get_codemap(), crate, input,\n+                        io::string_reader(src), io::stdout(), ann);\n }\n \n-fn version(argv0: &istr) {\n-    let vers = ~\"unknown version\";\n+fn version(argv0: &str) {\n+    let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n-    io::stdout().write_str(\n-        #fmt[\"%s %s\\n\",\n-                             argv0,\n-                             vers]);\n+    io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n }\n \n-fn usage(argv0: &istr) {\n-    io::stdout().write_str(\n-        #fmt[\"usage: %s [options] <input>\\n\", argv0] +\n-                               ~\"\n+fn usage(argv0: &str) {\n+    io::stdout().write_str(#fmt[\"usage: %s [options] <input>\\n\", argv0] +\n+                               \"\n options:\n \n     -h --help          display this message\n@@ -304,41 +285,39 @@ options:\n \");\n }\n \n-fn get_os(triple: &istr) -> session::os {\n-    ret if str::find(triple, ~\"win32\") >= 0 ||\n-               str::find(triple, ~\"mingw32\") >= 0 {\n+fn get_os(triple: &str) -> session::os {\n+    ret if str::find(triple, \"win32\") >= 0 ||\n+               str::find(triple, \"mingw32\") >= 0 {\n             session::os_win32\n-        } else if str::find(triple, ~\"darwin\") >= 0 {\n+        } else if str::find(triple, \"darwin\") >= 0 {\n             session::os_macos\n-        } else if str::find(triple, ~\"linux\") >= 0 {\n+        } else if str::find(triple, \"linux\") >= 0 {\n             session::os_linux\n-        } else { log_err ~\"Unknown operating system!\"; fail };\n+        } else { log_err \"Unknown operating system!\"; fail };\n }\n \n-fn get_arch(triple: &istr) -> session::arch {\n-    ret if str::find(triple, ~\"i386\") >= 0 ||\n-        str::find(triple, ~\"i486\") >= 0 ||\n-               str::find(triple, ~\"i586\") >= 0 ||\n-               str::find(triple, ~\"i686\") >= 0 ||\n-               str::find(triple, ~\"i786\") >= 0 {\n+fn get_arch(triple: &str) -> session::arch {\n+    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n+               str::find(triple, \"i586\") >= 0 ||\n+               str::find(triple, \"i686\") >= 0 ||\n+               str::find(triple, \"i786\") >= 0 {\n             session::arch_x86\n-        } else if str::find(triple, ~\"x86_64\") >= 0 {\n+        } else if str::find(triple, \"x86_64\") >= 0 {\n             session::arch_x64\n-        } else if str::find(triple, ~\"arm\") >= 0 ||\n-                      str::find(triple, ~\"xscale\") >= 0 {\n+        } else if str::find(triple, \"arm\") >= 0 ||\n+                      str::find(triple, \"xscale\") >= 0 {\n             session::arch_arm\n-        } else { log_err ~\"Unknown architecture! \" + triple; fail };\n+        } else { log_err \"Unknown architecture! \" + triple; fail };\n }\n \n-fn get_default_sysroot(binary: &istr) -> istr {\n+fn get_default_sysroot(binary: &str) -> str {\n     let dirname = fs::dirname(binary);\n-    if str::eq(dirname, binary) { ret ~\".\"; }\n+    if str::eq(dirname, binary) { ret \".\"; }\n     ret dirname;\n }\n \n fn build_target_config() -> @session::config {\n-    let triple: istr =\n-        str::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n+    let triple: str = str::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n     let target_cfg: @session::config =\n         @{os: get_os(triple),\n           arch: get_arch(triple),\n@@ -348,51 +327,49 @@ fn build_target_config() -> @session::config {\n     ret target_cfg;\n }\n \n-fn build_session_options(binary: &istr, match: &getopts::match,\n-                         binary_dir: &istr) -> @session::options {\n-    let library = opt_present(match, ~\"lib\");\n-    let static = opt_present(match, ~\"static\");\n+fn build_session_options(binary: &str, match: &getopts::match,\n+                         binary_dir: &str) -> @session::options {\n+    let library = opt_present(match, \"lib\");\n+    let static = opt_present(match, \"static\");\n \n-    let library_search_paths = [binary_dir + ~\"/lib\"];\n-    let lsp_vec = getopts::opt_strs(match, ~\"L\");\n-    for lsp: istr in lsp_vec {\n-        library_search_paths += [lsp];\n-    }\n+    let library_search_paths = [binary_dir + \"/lib\"];\n+    let lsp_vec = getopts::opt_strs(match, \"L\");\n+    for lsp: str in lsp_vec { library_search_paths += [lsp]; }\n \n-    let parse_only = opt_present(match, ~\"parse-only\");\n-    let no_trans = opt_present(match, ~\"no-trans\");\n+    let parse_only = opt_present(match, \"parse-only\");\n+    let no_trans = opt_present(match, \"no-trans\");\n \n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if opt_present(match, ~\"S\") {\n+        } else if opt_present(match, \"S\") {\n             link::output_type_assembly\n-        } else if opt_present(match, ~\"c\") {\n+        } else if opt_present(match, \"c\") {\n             link::output_type_object\n-        } else if opt_present(match, ~\"emit-llvm\") {\n+        } else if opt_present(match, \"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let verify = !opt_present(match, ~\"noverify\");\n-    let save_temps = opt_present(match, ~\"save-temps\");\n-    let debuginfo = opt_present(match, ~\"g\");\n-    let stats = opt_present(match, ~\"stats\");\n-    let time_passes = opt_present(match, ~\"time-passes\");\n-    let time_llvm_passes = opt_present(match, ~\"time-llvm-passes\");\n-    let run_typestate = !opt_present(match, ~\"no-typestate\");\n-    let sysroot_opt = getopts::opt_maybe_str(match, ~\"sysroot\");\n+    let verify = !opt_present(match, \"noverify\");\n+    let save_temps = opt_present(match, \"save-temps\");\n+    let debuginfo = opt_present(match, \"g\");\n+    let stats = opt_present(match, \"stats\");\n+    let time_passes = opt_present(match, \"time-passes\");\n+    let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n+    let run_typestate = !opt_present(match, \"no-typestate\");\n+    let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n     let opt_level: uint =\n-        if opt_present(match, ~\"O\") {\n-            if opt_present(match, ~\"OptLevel\") {\n+        if opt_present(match, \"O\") {\n+            if opt_present(match, \"OptLevel\") {\n                 log_err \"error: -O and --OptLevel both provided\";\n                 fail;\n             }\n             2u\n-        } else if opt_present(match, ~\"OptLevel\") {\n-            alt getopts::opt_str(match, ~\"OptLevel\") {\n-              ~\"0\" { 0u }\n-              ~\"1\" { 1u }\n-              ~\"2\" { 2u }\n-              ~\"3\" { 3u }\n+        } else if opt_present(match, \"OptLevel\") {\n+            alt getopts::opt_str(match, \"OptLevel\") {\n+              \"0\" { 0u }\n+              \"1\" { 1u }\n+              \"2\" { 2u }\n+              \"3\" { 3u }\n               _ {\n                 log_err \"error: optimization level needs \" +\n                             \"to be between 0-3\";\n@@ -405,10 +382,9 @@ fn build_session_options(binary: &istr, match: &getopts::match,\n           none. { get_default_sysroot(binary) }\n           some(s) { s }\n         };\n-    let cfg = parse_cfgspecs(\n-        getopts::opt_strs(match, ~\"cfg\"));\n-    let test = opt_present(match, ~\"test\");\n-    let do_gc = opt_present(match, ~\"gc\");\n+    let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n+    let test = opt_present(match, \"test\");\n+    let do_gc = opt_present(match, \"gc\");\n     let sopts: @session::options =\n         @{library: library,\n           static: static,\n@@ -439,32 +415,31 @@ fn build_session(sopts: @session::options) -> session::session {\n                          none, 0u);\n }\n \n-fn parse_pretty(sess: session::session, name: &istr) -> pp_mode {\n-    if str::eq(name, ~\"normal\") {\n+fn parse_pretty(sess: session::session, name: &str) -> pp_mode {\n+    if str::eq(name, \"normal\") {\n         ret ppm_normal;\n-    } else if str::eq(name, ~\"expanded\") {\n+    } else if str::eq(name, \"expanded\") {\n         ret ppm_expanded;\n-    } else if str::eq(name, ~\"typed\") {\n+    } else if str::eq(name, \"typed\") {\n         ret ppm_typed;\n-    } else if str::eq(name, ~\"identified\") { ret ppm_identified; }\n-    sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, or \"\n-               + ~\"`identified`\");\n+    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n+    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n+                   \"`identified`\");\n }\n \n fn opts() -> [getopts::opt] {\n-    ret [optflag(~\"h\"), optflag(~\"help\"), optflag(~\"v\"), optflag(~\"version\"),\n-         optflag(~\"glue\"), optflag(~\"emit-llvm\"), optflagopt(~\"pretty\"),\n-         optflag(~\"ls\"), optflag(~\"parse-only\"), optflag(~\"no-trans\"),\n-         optflag(~\"O\"), optopt(~\"OptLevel\"), optmulti(~\"L\"),\n-         optflag(~\"S\"), optflag(~\"c\"), optopt(~\"o\"), optflag(~\"g\"),\n-         optflag(~\"save-temps\"), optopt(~\"sysroot\"), optflag(~\"stats\"),\n-         optflag(~\"time-passes\"), optflag(~\"time-llvm-passes\"),\n-         optflag(~\"no-typestate\"), optflag(~\"noverify\"), optmulti(~\"cfg\"),\n-         optflag(~\"test\"), optflag(~\"lib\"), optflag(~\"static\"),\n-         optflag(~\"gc\")];\n+    ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n+         optflag(\"glue\"), optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n+         optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"no-trans\"),\n+         optflag(\"O\"), optopt(\"OptLevel\"), optmulti(\"L\"), optflag(\"S\"),\n+         optflag(\"c\"), optopt(\"o\"), optflag(\"g\"), optflag(\"save-temps\"),\n+         optopt(\"sysroot\"), optflag(\"stats\"), optflag(\"time-passes\"),\n+         optflag(\"time-llvm-passes\"), optflag(\"no-typestate\"),\n+         optflag(\"noverify\"), optmulti(\"cfg\"), optflag(\"test\"),\n+         optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n }\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     let binary = vec::shift(args);\n     let binary_dir = fs::dirname(binary);\n     let match =\n@@ -475,49 +450,45 @@ fn main(args: [istr]) {\n             fail\n           }\n         };\n-    if opt_present(match, ~\"h\") || opt_present(match, ~\"help\") {\n+    if opt_present(match, \"h\") || opt_present(match, \"help\") {\n         usage(binary);\n         ret;\n     }\n-    if opt_present(match, ~\"v\") || opt_present(match, ~\"version\") {\n+    if opt_present(match, \"v\") || opt_present(match, \"version\") {\n         version(binary);\n         ret;\n     }\n     let sopts = build_session_options(binary, match, binary_dir);\n     let sess = build_session(sopts);\n-    let n_inputs = vec::len::<istr>(match.free);\n-    let output_file = getopts::opt_maybe_str(match, ~\"o\");\n-    let glue = opt_present(match, ~\"glue\");\n+    let n_inputs = vec::len::<str>(match.free);\n+    let output_file = getopts::opt_maybe_str(match, \"o\");\n+    let glue = opt_present(match, \"glue\");\n     if glue {\n         if n_inputs > 0u {\n-            sess.fatal(~\"No input files allowed with --glue.\");\n+            sess.fatal(\"No input files allowed with --glue.\");\n         }\n-        let out = option::from_maybe::<istr>(~\"glue.bc\", output_file);\n+        let out = option::from_maybe::<str>(\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n     if n_inputs == 0u {\n-        sess.fatal(~\"No input filename given.\");\n+        sess.fatal(\"No input filename given.\");\n     } else if n_inputs > 1u {\n-        sess.fatal(~\"Multiple input filenames provided.\");\n+        sess.fatal(\"Multiple input filenames provided.\");\n     }\n     let ifile = match.free[0];\n-    let saved_out_filename: istr = ~\"\";\n-    let cfg = build_configuration(sess, binary,\n-                                  ifile);\n+    let saved_out_filename: str = \"\";\n+    let cfg = build_configuration(sess, binary, ifile);\n     let pretty =\n-        option::map::<istr,\n+        option::map::<str,\n                       pp_mode>(bind parse_pretty(sess, _),\n-                               getopts::opt_default(match, ~\"pretty\",\n-                                                    ~\"normal\"));\n+                               getopts::opt_default(match, \"pretty\",\n+                                                    \"normal\"));\n     alt pretty {\n-      some::<pp_mode>(ppm) {\n-        pretty_print_input(sess, cfg, ifile, ppm);\n-        ret;\n-      }\n+      some::<pp_mode>(ppm) { pretty_print_input(sess, cfg, ifile, ppm); ret; }\n       none::<pp_mode>. {/* continue */ }\n     }\n-    let ls = opt_present(match, ~\"ls\");\n+    let ls = opt_present(match, \"ls\");\n     if ls { metadata::creader::list_file_metadata(ifile, io::stdout()); ret; }\n \n     let stop_after_codegen =\n@@ -532,29 +503,30 @@ fn main(args: [istr]) {\n         let parts =\n             if !input_is_stdin(ifile) {\n                 str::split(ifile, '.' as u8)\n-            } else { [~\"default\", ~\"rs\"] };\n+            } else { [\"default\", \"rs\"] };\n         vec::pop(parts);\n-        saved_out_filename = str::connect(parts, ~\".\");\n+        saved_out_filename = str::connect(parts, \".\");\n         let suffix =\n             alt sopts.output_type {\n-              link::output_type_none. { ~\"none\" }\n-              link::output_type_bitcode. { ~\"bc\" }\n-              link::output_type_assembly. { ~\"s\" }\n+              link::output_type_none. { \"none\" }\n+              link::output_type_bitcode. { \"bc\" }\n+              link::output_type_assembly. { \"s\" }\n+\n \n               // Object and exe output both use the '.o' extension here\n               link::output_type_object. | link::output_type_exe. {\n-                ~\"o\"\n+                \"o\"\n               }\n             };\n-        let ofile = saved_out_filename + ~\".\" + suffix;\n+        let ofile = saved_out_filename + \".\" + suffix;\n         compile_input(sess, cfg, ifile, ofile);\n       }\n       some(ofile) {\n         let ofile = ofile;\n         // FIXME: what about windows? This will create a foo.exe.o.\n         saved_out_filename = ofile;\n         let temp_filename =\n-            if !stop_after_codegen { ofile + ~\".o\" } else { ofile };\n+            if !stop_after_codegen { ofile + \".o\" } else { ofile };\n         compile_input(sess, cfg, ifile, temp_filename);\n       }\n     }\n@@ -565,39 +537,37 @@ fn main(args: [istr]) {\n     // TODO: Factor this out of main.\n     if stop_after_codegen { ret; }\n \n-    let glu: istr = binary_dir + ~\"/lib/glue.o\";\n-    let main: istr = binary_dir + ~\"/lib/main.o\";\n-    let stage: istr = ~\"-L\" + binary_dir + ~\"/lib\";\n-    let prog: istr = ~\"gcc\";\n+    let glu: str = binary_dir + \"/lib/glue.o\";\n+    let main: str = binary_dir + \"/lib/main.o\";\n+    let stage: str = \"-L\" + binary_dir + \"/lib\";\n+    let prog: str = \"gcc\";\n     // The invocations of gcc share some flags across platforms\n \n     let gcc_args =\n-        [stage,\n-         ~\"-Lrt\", ~\"-lrustrt\", glu,\n-         ~\"-m32\", ~\"-o\", saved_out_filename,\n-         saved_out_filename + ~\".o\"];\n+        [stage, \"-Lrt\", \"-lrustrt\", glu, \"-m32\", \"-o\", saved_out_filename,\n+         saved_out_filename + \".o\"];\n     let lib_cmd;\n \n     let os = sess.get_targ_cfg().os;\n     if os == session::os_macos {\n-        lib_cmd = ~\"-dynamiclib\";\n-    } else { lib_cmd = ~\"-shared\"; }\n+        lib_cmd = \"-dynamiclib\";\n+    } else { lib_cmd = \"-shared\"; }\n \n     // Converts a library file name into a gcc -l argument\n-    fn unlib(config: @session::config, filename: &istr) -> istr {\n+    fn unlib(config: @session::config, filename: &str) -> str {\n         let rmlib =\n-            bind fn (config: @session::config, filename: &istr) -> istr {\n-            if config.os == session::os_macos ||\n-                config.os == session::os_linux &&\n-                str::find(filename, ~\"lib\") == 0 {\n-                ret str::slice(filename, 3u,\n-                                str::byte_len(filename));\n-            } else { ret filename; }\n-        }(config, _);\n-        fn rmext(filename: &istr) -> istr {\n+            bind fn (config: @session::config, filename: &str) -> str {\n+                     if config.os == session::os_macos ||\n+                            config.os == session::os_linux &&\n+                                str::find(filename, \"lib\") == 0 {\n+                         ret str::slice(filename, 3u,\n+                                        str::byte_len(filename));\n+                     } else { ret filename; }\n+                 }(config, _);\n+        fn rmext(filename: &str) -> str {\n             let parts = str::split(filename, '.' as u8);\n             vec::pop(parts);\n-            ret str::connect(parts, ~\".\");\n+            ret str::connect(parts, \".\");\n         }\n         ret alt config.os {\n               session::os_macos. { rmext(rmlib(filename)) }\n@@ -607,53 +577,48 @@ fn main(args: [istr]) {\n     }\n \n     let cstore = sess.get_cstore();\n-    for cratepath: istr in cstore::get_used_crate_files(cstore) {\n-        if str::ends_with(cratepath, ~\".rlib\") {\n+    for cratepath: str in cstore::get_used_crate_files(cstore) {\n+        if str::ends_with(cratepath, \".rlib\") {\n             gcc_args += [cratepath];\n             cont;\n         }\n         let cratepath = cratepath;\n         let dir = fs::dirname(cratepath);\n-        if dir != ~\"\" { gcc_args += [~\"-L\" + dir]; }\n+        if dir != \"\" { gcc_args += [\"-L\" + dir]; }\n         let libarg = unlib(sess.get_targ_cfg(), fs::basename(cratepath));\n-        gcc_args += [~\"-l\" + libarg];\n+        gcc_args += [\"-l\" + libarg];\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for arg: istr in ula { gcc_args += [arg]; }\n+    for arg: str in ula { gcc_args += [arg]; }\n \n     let used_libs = cstore::get_used_libraries(cstore);\n-    for l: istr in used_libs { gcc_args += [~\"-l\" + l]; }\n+    for l: str in used_libs { gcc_args += [\"-l\" + l]; }\n \n     if sopts.library {\n         gcc_args += [lib_cmd];\n     } else {\n         // FIXME: why do we hardcode -lm?\n-        gcc_args += [~\"-lm\", main];\n+        gcc_args += [\"-lm\", main];\n     }\n     // We run 'gcc' here\n \n     let err_code = run::run_program(prog, gcc_args);\n     if 0 != err_code {\n-        sess.err(\n-            #fmt[\"linking with gcc failed with code %d\", err_code]);\n-        sess.note(\n-            #fmt[\"gcc arguments: %s\",\n-                       str::connect(gcc_args, ~\" \")]);\n+        sess.err(#fmt[\"linking with gcc failed with code %d\", err_code]);\n+        sess.note(#fmt[\"gcc arguments: %s\", str::connect(gcc_args, \" \")]);\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin\n \n     if sess.get_targ_cfg().os == session::os_macos {\n-        run::run_program(~\"dsymutil\",\n-                         [saved_out_filename]);\n+        run::run_program(\"dsymutil\", [saved_out_filename]);\n     }\n \n \n     // Remove the temporary object file if we aren't saving temps\n     if !sopts.save_temps {\n-        run::run_program(~\"rm\",\n-                         [saved_out_filename + ~\".o\"]);\n+        run::run_program(\"rm\", [saved_out_filename + \".o\"]);\n     }\n }\n \n@@ -664,27 +629,27 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let match =\n-            alt getopts::getopts([~\"--test\"], opts()) {\n+            alt getopts::getopts([\"--test\"], opts()) {\n               getopts::success(m) { m }\n             };\n-        let sessopts = build_session_options(~\"whatever\", match, ~\"whatever\");\n+        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n         let sess = build_session(sessopts);\n-        let cfg = build_configuration(sess, ~\"whatever\", ~\"whatever\");\n-        assert (attr::contains_name(cfg, ~\"test\"));\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        assert (attr::contains_name(cfg, \"test\"));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let match =\n-            alt getopts::getopts([~\"--test\", ~\"--cfg=test\"], opts()) {\n+            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n               getopts::success(m) { m }\n             };\n-        let sessopts = build_session_options(~\"whatever\", match, ~\"whatever\");\n+        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n         let sess = build_session(sessopts);\n-        let cfg = build_configuration(sess, ~\"whatever\", ~\"whatever\");\n-        let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n+        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n         assert (vec::len(test_items) == 1u);\n     }\n }"}, {"sha": "13d17ef6303ead1ece7d8ba67b30c5f197ee35b4", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -37,15 +37,15 @@ type options =\n      time_passes: bool,\n      time_llvm_passes: bool,\n      output_type: back::link::output_type,\n-     library_search_paths: [istr],\n-     sysroot: istr,\n+     library_search_paths: [str],\n+     sysroot: str,\n      cfg: ast::crate_cfg,\n      test: bool,\n      parse_only: bool,\n      no_trans: bool,\n      do_gc: bool};\n \n-type crate_metadata = {name: istr, data: [u8]};\n+type crate_metadata = {name: str, data: [u8]};\n \n obj session(targ_cfg: @config,\n             opts: @options,\n@@ -58,54 +58,46 @@ obj session(targ_cfg: @config,\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n-    fn span_fatal(sp: span, msg: &istr) -> ! {\n+    fn span_fatal(sp: span, msg: &str) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         fail;\n     }\n-    fn fatal(msg: &istr) -> ! {\n+    fn fatal(msg: &str) -> ! {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         fail;\n     }\n-    fn span_err(sp: span, msg: &istr) {\n+    fn span_err(sp: span, msg: &str) {\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         err_count += 1u;\n     }\n-    fn err(msg: &istr) {\n+    fn err(msg: &str) {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n-        if err_count > 0u { self.fatal(~\"aborting due to previous errors\"); }\n+        if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n     }\n-    fn span_warn(sp: span, msg: &istr) {\n+    fn span_warn(sp: span, msg: &str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_warning(some(sp), msg, parse_sess.cm);\n     }\n-    fn warn(msg: &istr) {\n-        codemap::emit_warning(none, msg, parse_sess.cm);\n-    }\n-    fn span_note(sp: span, msg: &istr) {\n+    fn warn(msg: &str) { codemap::emit_warning(none, msg, parse_sess.cm); }\n+    fn span_note(sp: span, msg: &str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_note(some(sp), msg, parse_sess.cm);\n     }\n-    fn note(msg: &istr) {\n-        codemap::emit_note(none, msg, parse_sess.cm);\n-    }\n-    fn span_bug(sp: span, msg: &istr) -> ! {\n-        self.span_fatal(sp,\n-                        #fmt[\"internal compiler error %s\",\n-                                             msg]);\n+    fn note(msg: &str) { codemap::emit_note(none, msg, parse_sess.cm); }\n+    fn span_bug(sp: span, msg: &str) -> ! {\n+        self.span_fatal(sp, #fmt[\"internal compiler error %s\", msg]);\n     }\n-    fn bug(msg: &istr) -> ! {\n-        self.fatal(\n-            #fmt[\"internal compiler error %s\",\n-                 msg]);\n+    fn bug(msg: &str) -> ! {\n+        self.fatal(#fmt[\"internal compiler error %s\", msg]);\n     }\n-    fn span_unimpl(sp: span, msg: &istr) -> ! {\n-        self.span_bug(sp, ~\"unimplemented \" + msg);\n+    fn span_unimpl(sp: span, msg: &str) -> ! {\n+        self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-    fn unimpl(msg: &istr) -> ! { self.bug(~\"unimplemented \" + msg); }\n+    fn unimpl(msg: &str) -> ! { self.bug(\"unimplemented \" + msg); }\n     fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n     fn lookup_pos(pos: uint) -> codemap::loc {\n         ret codemap::lookup_char_pos(parse_sess.cm, pos);\n@@ -114,7 +106,7 @@ obj session(targ_cfg: @config,\n     fn next_node_id() -> ast::node_id {\n         ret syntax::parse::parser::next_node_id(parse_sess);\n     }\n-    fn span_str(sp: span) -> istr {\n+    fn span_str(sp: span) -> str {\n         ret codemap::span_to_str(sp, self.get_codemap());\n     }\n     fn set_main_id(d: node_id) { main_fn = some(d); }"}, {"sha": "edb6da5b257238d3f25086dc1247e38078e3d8e9", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -32,7 +32,7 @@ export mk_attr;\n // linkage\n fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n     let metas: [@ast::meta_item] = [];\n-    for attr: ast::attribute in find_attrs_by_name(attrs, ~\"link\") {\n+    for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n           _ { log \"ignoring link attribute that has incorrect type\"; }\n@@ -80,13 +80,10 @@ fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n \n // Gets the string value if the meta_item is a meta_name_value variant\n // containing a string, otherwise none\n-fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t<istr> {\n+fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n-        alt v.node {\n-          ast::lit_str(s) { option::some(s) }\n-          _ { option::none }\n-        }\n+        alt v.node { ast::lit_str(s) { option::some(s) } _ { option::none } }\n       }\n       _ { option::none }\n     }\n@@ -124,10 +121,10 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n \n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     log #fmt[\"looking for %s\",\n-                 syntax::print::pprust::meta_item_to_str(*needle)];\n+             syntax::print::pprust::meta_item_to_str(*needle)];\n     for item: @ast::meta_item in haystack {\n         log #fmt[\"looking in %s\",\n-                     syntax::print::pprust::meta_item_to_str(*item)];\n+                 syntax::print::pprust::meta_item_to_str(*item)];\n         if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n     log \"found it not :(\";\n@@ -163,11 +160,11 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(items: &[@ast::meta_item], name: &istr) ->\n+fn remove_meta_items_by_name(items: &[@ast::meta_item], name: &str) ->\n    [@ast::meta_item] {\n \n     let filter =\n-        bind fn (item: &@ast::meta_item, name: &istr) ->\n+        bind fn (item: &@ast::meta_item, name: &str) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(item) != name {\n                      option::some(item)\n@@ -183,8 +180,7 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             sess.span_fatal(meta.span,\n-                            #fmt[\"duplicate meta item `%s`\",\n-                                 name]);\n+                            #fmt[\"duplicate meta item `%s`\", name]);\n         }\n         map.insert(name, ());\n     }\n@@ -194,8 +190,7 @@ fn span<@T>(item: &T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }\n \n-fn mk_name_value_item_str(name: ast::ident,\n-                          value: &istr) -> @ast::meta_item {\n+fn mk_name_value_item_str(name: ast::ident, value: &str) -> @ast::meta_item {\n     let value_lit = span(ast::lit_str(value));\n     ret mk_name_value_item(name, value_lit);\n }"}, {"sha": "0d391f63c345321fd5bf9d700d41b275e244b7da", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -77,7 +77,8 @@ fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n     ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n-         id: b.id, rules: b.rules};\n+         id: b.id,\n+         rules: b.rules};\n }\n \n fn item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::item) -> bool {\n@@ -94,7 +95,7 @@ fn native_item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n \n     // The \"cfg\" attributes on the item\n-    let item_cfg_attrs = attr::find_attrs_by_name(attrs, ~\"cfg\");\n+    let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n     let item_has_cfg_attrs = vec::len(item_cfg_attrs) > 0u;\n     if !item_has_cfg_attrs { ret true; }\n \n@@ -108,7 +109,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n                [@ast::meta_item] {\n                 alt cfg_item.node {\n                   ast::meta_list(name, items) {\n-                    assert (name == ~\"cfg\");\n+                    assert (name == \"cfg\");\n                     inner_items + items\n                   }\n                   _ { inner_items }"}, {"sha": "680b422f402a7d8c56d40b77def5bd06c7e7d36d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -65,7 +65,7 @@ fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) ->\n     fn nomain(item: &@ast::item) -> option::t<@ast::item> {\n         alt item.node {\n           ast::item_fn(f, _) {\n-            if item.ident == ~\"main\" {\n+            if item.ident == \"main\" {\n                 option::none\n             } else { option::some(item) }\n           }\n@@ -92,8 +92,7 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];\n-    log #fmt[\"current path: %s\",\n-             ast_util::path_name_i(cx.path)];\n+    log #fmt[\"current path: %s\", ast_util::path_name_i(cx.path)];\n \n     if is_test_fn(i) {\n         log \"this is a test function\";\n@@ -109,7 +108,7 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n \n fn is_test_fn(i: &@ast::item) -> bool {\n     let has_test_attr =\n-        vec::len(attr::find_attrs_by_name(i.attrs, ~\"test\")) > 0u;\n+        vec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n \n     fn has_test_signature(i: &@ast::item) -> bool {\n         alt i.node {\n@@ -127,7 +126,7 @@ fn is_test_fn(i: &@ast::item) -> bool {\n }\n \n fn is_ignored(i: &@ast::item) -> bool {\n-    attr::contains_name(attr::attr_metas(i.attrs), ~\"ignore\")\n+    attr::contains_name(attr::attr_metas(i.attrs), \"ignore\")\n }\n \n fn add_test_module(cx: &test_ctxt, m: &ast::_mod) -> ast::_mod {\n@@ -162,21 +161,18 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     let testmod: ast::_mod = {view_items: [], items: [mainfn, testsfn]};\n     let item_ = ast::item_mod(testmod);\n     let item: ast::item =\n-        {ident: ~\"__test\",\n+        {ident: \"__test\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n          span: dummy_sp()};\n \n-    log #fmt[\"Synthetic test module:\\n%s\\n\",\n-             pprust::item_to_str(@item)];\n+    log #fmt[\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)];\n \n     ret @item;\n }\n \n-fn nospan<@T>(t: &T) -> ast::spanned<T> {\n-    ret {node: t, span: dummy_sp()};\n-}\n+fn nospan<@T>(t: &T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n \n fn mk_tests(cx: &test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n@@ -193,15 +189,15 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n \n-    let body_: ast::blk_ = checked_blk([], option::some(test_descs),\n-                                       cx.next_node_id());\n+    let body_: ast::blk_ =\n+        checked_blk([], option::some(test_descs), cx.next_node_id());\n     let body = nospan(body_);\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n     let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n-        {ident: ~\"tests\",\n+        {ident: \"tests\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n@@ -222,7 +218,7 @@ fn empty_fn_ty() -> ast::ty {\n fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n     let test_desc_ty_path: ast::path =\n         nospan({global: false,\n-                idents: [~\"std\", ~\"test\", ~\"test_desc\"],\n+                idents: [\"std\", \"test\", \"test_desc\"],\n                 types: []});\n \n     let test_desc_ty: ast::ty =\n@@ -249,8 +245,7 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n-    log #fmt[\"encoding %s\",\n-             ast_util::path_name_i(path)];\n+    log #fmt[\"encoding %s\", ast_util::path_name_i(path)];\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path)));\n@@ -260,7 +255,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let name_field: ast::field =\n-        nospan({mut: ast::imm, ident: ~\"name\", expr: @name_expr});\n+        nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n \n     let fn_path: ast::path = nospan({global: false, idents: path, types: []});\n \n@@ -270,7 +265,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let fn_field: ast::field =\n-        nospan({mut: ast::imm, ident: ~\"fn\", expr: @fn_expr});\n+        nospan({mut: ast::imm, ident: \"fn\", expr: @fn_expr});\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -280,7 +275,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n          span: dummy_sp()};\n \n     let ignore_field: ast::field =\n-        nospan({mut: ast::imm, ident: ~\"ignore\", expr: @ignore_expr});\n+        nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec([name_field, fn_field, ignore_field], option::none);\n@@ -291,11 +286,11 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n \n fn mk_main(cx: &test_ctxt) -> @ast::item {\n \n-    let args_mt: ast::mt = {ty: @nospan(ast::ty_istr), mut: ast::imm};\n+    let args_mt: ast::mt = {ty: @nospan(ast::ty_str), mut: ast::imm};\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::val, ty: @args_ty, ident: ~\"args\", id: cx.next_node_id()};\n+        {mode: ast::val, ty: @args_ty, ident: \"args\", id: cx.next_node_id()};\n \n     let ret_ty = nospan(ast::ty_nil);\n \n@@ -310,15 +305,15 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n \n     let test_main_call_expr = mk_test_main_call(cx);\n \n-    let body_: ast::blk_ = checked_blk([], option::some(test_main_call_expr),\n-                                       cx.next_node_id());\n+    let body_: ast::blk_ =\n+        checked_blk([], option::some(test_main_call_expr), cx.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n     let item_ = ast::item_fn(fn_, []);\n     let item: ast::item =\n-        {ident: ~\"main\",\n+        {ident: \"main\",\n          attrs: [],\n          id: cx.next_node_id(),\n          node: item_,\n@@ -330,7 +325,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n     let args_path: ast::path =\n-        nospan({global: false, idents: [~\"args\"], types: []});\n+        nospan({global: false, idents: [\"args\"], types: []});\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n@@ -339,7 +334,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n \n     // Call __test::test to generate the vector of test_descs\n     let test_path: ast::path =\n-        nospan({global: false, idents: [~\"tests\"], types: []});\n+        nospan({global: false, idents: [\"tests\"], types: []});\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n@@ -354,24 +349,20 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     // Call std::test::test_main\n     let test_main_path: ast::path =\n         nospan({global: false,\n-                idents: [~\"std\", ~\"test\", ~\"test_main\"],\n+                idents: [\"std\", \"test\", \"test_main\"],\n                 types: []});\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n \n     let test_main_path_expr: ast::expr =\n-        {id: cx.next_node_id(),\n-         node: test_main_path_expr_,\n-         span: dummy_sp()};\n+        {id: cx.next_node_id(), node: test_main_path_expr_, span: dummy_sp()};\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n                        [@args_path_expr, @test_call_expr]);\n \n     let test_main_call_expr: ast::expr =\n-        {id: cx.next_node_id(),\n-         node: test_main_call_expr_,\n-         span: dummy_sp()};\n+        {id: cx.next_node_id(), node: test_main_call_expr_, span: dummy_sp()};\n \n     ret @test_main_call_expr;\n }"}, {"sha": "431893b0201b79886865775e37faca23d8f0230a", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -810,18 +810,14 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n     fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef,\n                                                    Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-        PMB: PassManagerBuilderRef,\n-        Value: Bool);\n+        PMB: PassManagerBuilderRef, Value: Bool);\n     fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: PassManagerBuilderRef,\n-        threshold: uint);\n+        PMB: PassManagerBuilderRef, threshold: uint);\n     fn LLVMPassManagerBuilderPopulateModulePassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n+        PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n     fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: PassManagerBuilderRef,\n-        PM: PassManagerRef);\n+        PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n     fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -899,10 +895,10 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n \n /* Memory-managed object interface to type handles. */\n \n-obj type_names(type_names: std::map::hashmap<TypeRef, istr>,\n-               named_types: std::map::hashmap<istr, TypeRef>) {\n+obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n+               named_types: std::map::hashmap<str, TypeRef>) {\n \n-    fn associate(s: &istr, t: TypeRef) {\n+    fn associate(s: &str, t: TypeRef) {\n         assert (!named_types.contains_key(s));\n         assert (!type_names.contains_key(t));\n         type_names.insert(t, s);\n@@ -911,15 +907,11 @@ obj type_names(type_names: std::map::hashmap<TypeRef, istr>,\n \n     fn type_has_name(t: TypeRef) -> bool { ret type_names.contains_key(t); }\n \n-    fn get_name(t: TypeRef) -> istr { ret type_names.get(t); }\n+    fn get_name(t: TypeRef) -> str { ret type_names.get(t); }\n \n-    fn name_has_type(s: &istr) -> bool {\n-        ret named_types.contains_key(s);\n-    }\n+    fn name_has_type(s: &str) -> bool { ret named_types.contains_key(s); }\n \n-    fn get_type(s: &istr) -> TypeRef {\n-        ret named_types.get(s);\n-    }\n+    fn get_type(s: &str) -> TypeRef { ret named_types.get(s); }\n }\n \n fn mk_type_names() -> type_names {\n@@ -931,30 +923,29 @@ fn mk_type_names() -> type_names {\n \n     let hasher: std::map::hashfn<TypeRef> = hash;\n     let eqer: std::map::eqfn<TypeRef> = eq;\n-    let tn = std::map::mk_hashmap::<TypeRef, istr>(hasher, eqer);\n+    let tn = std::map::mk_hashmap::<TypeRef, str>(hasher, eqer);\n \n     ret type_names(tn, nt);\n }\n \n-fn type_to_str(names: type_names, ty: TypeRef) -> istr {\n+fn type_to_str(names: type_names, ty: TypeRef) -> str {\n     ret type_to_str_inner(names, [], ty);\n }\n \n fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n-   istr {\n+   str {\n \n     if names.type_has_name(ty) { ret names.get_name(ty); }\n \n     let outer = outer0 + [ty];\n \n     let kind: int = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: &[TypeRef],\n-               tys: &[TypeRef]) -> istr {\n-        let s: istr = ~\"\";\n+    fn tys_str(names: type_names, outer: &[TypeRef], tys: &[TypeRef]) -> str {\n+        let s: str = \"\";\n         let first: bool = true;\n         for t: TypeRef in tys {\n-            if first { first = false; } else { s += ~\", \"; }\n+            if first { first = false; } else { s += \", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n         ret s;\n@@ -965,81 +956,87 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       // FIXME: more enum-as-int constants determined from Core::h;\n       // horrible, horrible. Complete as needed.\n \n       0 {\n-        ret ~\"Void\";\n+        ret \"Void\";\n       }\n-      1 { ret ~\"Float\"; }\n-      2 { ret ~\"Double\"; }\n-      3 { ret ~\"X86_FP80\"; }\n-      4 { ret ~\"FP128\"; }\n-      5 { ret ~\"PPC_FP128\"; }\n-      6 { ret ~\"Label\"; }\n+      1 { ret \"Float\"; }\n+      2 { ret \"Double\"; }\n+      3 { ret \"X86_FP80\"; }\n+      4 { ret \"FP128\"; }\n+      5 { ret \"PPC_FP128\"; }\n+      6 { ret \"Label\"; }\n+\n \n \n \n       7 {\n-        ret ~\"i\" + std::int::str(\n-            llvm::LLVMGetIntTypeWidth(ty) as int);\n+        ret \"i\" + std::int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n \n \n \n+\n       8 {\n-        let s = ~\"fn(\";\n+        let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args: uint = llvm::LLVMCountParamTypes(ty);\n         let args: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_args);\n         llvm::LLVMGetParamTypes(ty, vec::to_ptr(args));\n         s += tys_str(names, outer, args);\n-        s += ~\") -> \";\n+        s += \") -> \";\n         s += type_to_str_inner(names, outer, out_ty);\n         ret s;\n       }\n \n \n \n+\n       9 {\n-        let s: istr = ~\"{\";\n+        let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n         let elts: [TypeRef] = vec::init_elt::<TypeRef>(0 as TypeRef, n_elts);\n         llvm::LLVMGetStructElementTypes(ty, vec::to_ptr(elts));\n         s += tys_str(names, outer, elts);\n-        s += ~\"}\";\n+        s += \"}\";\n         ret s;\n       }\n \n \n \n+\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n-        ret ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\"]\";\n+        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n       }\n \n \n \n+\n       11 {\n         let i: uint = 0u;\n         for tout: TypeRef in outer0 {\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                ret ~\"*\\\\\" + std::int::str(n as int);\n+                ret \"*\\\\\" + std::int::str(n as int);\n             }\n         }\n-        ret ~\"*\" +\n+        ret \"*\" +\n                 type_to_str_inner(names, outer, llvm::LLVMGetElementType(ty));\n       }\n \n \n \n+\n       12 {\n-        ret ~\"Opaque\";\n+        ret \"Opaque\";\n       }\n-      13 { ret ~\"Vector\"; }\n-      14 { ret ~\"Metadata\"; }\n+      13 { ret \"Vector\"; }\n+      14 { ret \"Metadata\"; }\n       _ { log_err #fmt[\"unknown TypeKind %d\", kind as int]; fail; }\n     }\n }\n@@ -1069,10 +1066,9 @@ resource target_data_res(TD: TargetDataRef) {\n \n type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n-fn mk_target_data(string_rep: &istr) -> target_data {\n-    let lltd = str::as_buf(string_rep, { |buf|\n-        llvm::LLVMCreateTargetData(buf)\n-    });\n+fn mk_target_data(string_rep: &str) -> target_data {\n+    let lltd =\n+        str::as_buf(string_rep, {|buf| llvm::LLVMCreateTargetData(buf) });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n "}, {"sha": "9d6a2c745f8e71ef6e4e4aeda942c0128e8edde6", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -67,7 +67,7 @@ const tag_items_data_item_inlineness: uint = 0x27u;\n // djb's cdb hashes.\n fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n \n-fn hash_path(s: &istr) -> uint {\n+fn hash_path(s: &str) -> uint {\n     let h = 5381u;\n     for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;"}, {"sha": "2c74f03612e1c3f3c53304383d7057bdf7d2cda0", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -34,8 +34,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n     let e =\n         @{sess: sess,\n           crate_cache: @std::map::new_str_hash::<int>(),\n-          library_search_paths:\n-          sess.get_opts().library_search_paths,\n+          library_search_paths: sess.get_opts().library_search_paths,\n           mutable next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n@@ -47,8 +46,8 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n \n type env =\n     @{sess: session::session,\n-      crate_cache: @hashmap<istr, int>,\n-      library_search_paths: [istr],\n+      crate_cache: @hashmap<str, int>,\n+      library_search_paths: [str],\n       mutable next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: &@ast::view_item) {\n@@ -68,14 +67,11 @@ fn visit_item(e: env, i: &@ast::item) {\n             ret;\n         }\n         let cstore = e.sess.get_cstore();\n-        if !cstore::add_used_library(cstore,\n-                                     m.native_name) { ret; }\n+        if !cstore::add_used_library(cstore, m.native_name) { ret; }\n         for a: ast::attribute in\n-            attr::find_attrs_by_name(i.attrs, ~\"link_args\") {\n+            attr::find_attrs_by_name(i.attrs, \"link_args\") {\n             alt attr::get_meta_item_value_str(attr::attr_meta(a)) {\n-              some(linkarg) {\n-                cstore::add_used_link_args(cstore, linkarg);\n-              }\n+              some(linkarg) { cstore::add_used_link_args(cstore, linkarg); }\n               none. {/* fallthrough */ }\n             }\n         }\n@@ -85,12 +81,11 @@ fn visit_item(e: env, i: &@ast::item) {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(path: &istr, out: io::writer) {\n+fn list_file_metadata(path: &str, out: io::writer) {\n     alt get_metadata_section(path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n       option::none. {\n-        out.write_str(\n-            ~\"Could not find metadata in \" + path + ~\".\\n\");\n+        out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n       }\n     }\n }\n@@ -104,36 +99,34 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n-            log #fmt[\"missing %s\",\n-                     pprust::meta_item_to_str(*needed)];\n+            log #fmt[\"missing %s\", pprust::meta_item_to_str(*needed)];\n             ret false;\n         }\n     }\n     ret true;\n }\n \n fn default_native_lib_naming(sess: session::session, static: bool) ->\n-   {prefix: istr, suffix: istr} {\n-    if static { ret {prefix: ~\"lib\", suffix: ~\".rlib\"}; }\n+   {prefix: str, suffix: str} {\n+    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n     alt sess.get_targ_cfg().os {\n-      session::os_win32. { ret {prefix: ~\"\", suffix: ~\".dll\"}; }\n-      session::os_macos. { ret {prefix: ~\"lib\", suffix: ~\".dylib\"}; }\n-      session::os_linux. { ret {prefix: ~\"lib\", suffix: ~\".so\"}; }\n+      session::os_win32. { ret {prefix: \"\", suffix: \".dll\"}; }\n+      session::os_macos. { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n+      session::os_linux. { ret {prefix: \"lib\", suffix: \".so\"}; }\n     }\n }\n \n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &[@ast::meta_item],\n-                      library_search_paths: &[istr])\n-   -> option::t<{ident: istr, data: @[u8]}> {\n+                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+   -> option::t<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n \n     // FIXME: Probably want a warning here since the user\n     // is using the wrong type of meta item\n     let crate_name =\n         {\n-            let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n+            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n             alt vec::last(name_items) {\n               some(i) {\n                 alt attr::get_meta_item_value_str(i) {\n@@ -147,49 +140,41 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n \n     let nn = default_native_lib_naming(sess, sess.get_opts().static);\n     let x =\n-        find_library_crate_aux(nn, crate_name,\n-                               metas, library_search_paths);\n+        find_library_crate_aux(nn, crate_name, metas, library_search_paths);\n     if x != none || sess.get_opts().static { ret x; }\n     let nn2 = default_native_lib_naming(sess, true);\n-    ret find_library_crate_aux(nn2, crate_name,\n-                               metas, library_search_paths);\n+    ret find_library_crate_aux(nn2, crate_name, metas, library_search_paths);\n }\n \n-fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n-                          crate_name: &istr,\n+fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: &str,\n                           metas: &[@ast::meta_item],\n-                          library_search_paths: &[istr]) ->\n-   option::t<{ident: istr, data: @[u8]}> {\n-    let prefix: istr = nn.prefix + crate_name;\n-    let suffix: istr = nn.suffix;\n+                          library_search_paths: &[str]) ->\n+   option::t<{ident: str, data: @[u8]}> {\n+    let prefix: str = nn.prefix + crate_name;\n+    let suffix: str = nn.suffix;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n     // tricks. Currently the glob(3) interface is a bit more than we can\n     // stomach from here, and writing a C++ wrapper is more work than just\n     // manually filtering fs::list_dir here.\n \n-    for library_search_path: istr in library_search_paths {\n+    for library_search_path: str in library_search_paths {\n         log #fmt[\"searching %s\", library_search_path];\n-        for path: istr in fs::list_dir(library_search_path) {\n+        for path: str in fs::list_dir(library_search_path) {\n             log #fmt[\"searching %s\", path];\n-            let f: istr = fs::basename(path);\n-            if !(str::starts_with(f, prefix) && str::ends_with(f, suffix))\n-               {\n-                log #fmt[\"skipping %s, doesn't look like %s*%s\",\n-                         path,\n-                         prefix,\n+            let f: str = fs::basename(path);\n+            if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n+                log #fmt[\"skipping %s, doesn't look like %s*%s\", path, prefix,\n                          suffix];\n                 cont;\n             }\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n-                    log #fmt[\"skipping %s, metadata doesn't match\",\n-                             path];\n+                    log #fmt[\"skipping %s, metadata doesn't match\", path];\n                     cont;\n                 }\n-                log #fmt[\"found %s with matching metadata\",\n-                         path];\n+                log #fmt[\"found %s with matching metadata\", path];\n                 ret some({ident: path, data: cvec});\n               }\n               _ { }\n@@ -199,10 +184,11 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n     ret none;\n }\n \n-fn get_metadata_section(filename: &istr) -> option::t<@[u8]> {\n-    let mb = str::as_buf(filename, { |buf|\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-    });\n+fn get_metadata_section(filename: &str) -> option::t<@[u8]> {\n+    let mb =\n+        str::as_buf(filename, {|buf|\n+            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+        });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n@@ -221,17 +207,14 @@ fn get_metadata_section(filename: &istr) -> option::t<@[u8]> {\n }\n \n fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n-                      metas: &[@ast::meta_item],\n-                      library_search_paths: &[istr])\n-   -> {ident: istr, data: @[u8]} {\n+                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+   -> {ident: str, data: @[u8]} {\n \n \n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n       some(t) { ret t; }\n       none. {\n-        sess.span_fatal(span,\n-                        #fmt[\"can't find crate for '%s'\",\n-                                   ident]);\n+        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n       }\n     }\n }\n@@ -254,13 +237,11 @@ fn resolve_crate(e: env, ident: &ast::ident, metas: [@ast::meta_item],\n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n-        let cmeta = {name: ident,\n-                     data: cdata, cnum_map: cnum_map};\n+        let cmeta = {name: ident, data: cdata, cnum_map: cnum_map};\n \n         let cstore = e.sess.get_cstore();\n         cstore::set_crate_data(cstore, cnum, cmeta);\n-        cstore::add_used_crate_file(cstore,\n-                                    cfilename);\n+        cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;\n     } else { ret e.crate_cache.get(ident); }\n }\n@@ -285,9 +266,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n             let fake_span = ast_util::dummy_sp();\n-            let local_cnum = resolve_crate(e,\n-                                           cname,\n-                                           [], fake_span);\n+            let local_cnum = resolve_crate(e, cname, [], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }\n     }"}, {"sha": "d526ee05247b2f8a9a4f0254279b7c0d49047c25", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -11,7 +11,7 @@ export lookup_defs;\n export get_tag_variants;\n export get_type;\n \n-fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> istr {\n+fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_symbol(cdata, def.node);\n }\n@@ -63,7 +63,7 @@ fn translate_def_id(sess: &session::session, searched_crate: ast::crate_num,\n     let local_cnum =\n         alt cmeta.cnum_map.find(ext_cnum) {\n           option::some(n) { n }\n-          option::none. { sess.bug(~\"didn't find a crate in the cnum_map\") }\n+          option::none. { sess.bug(\"didn't find a crate in the cnum_map\") }\n         };\n \n     ret {crate: local_cnum, node: node_id};"}, {"sha": "ed737e046ec567aec443e714e3fb2abef6af0635", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,7 +29,7 @@ export get_use_stmt_cnum;\n // own crate numbers.\n type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n \n-type crate_metadata = {name: istr, data: @[u8], cnum_map: cnum_map};\n+type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for\n@@ -41,9 +41,9 @@ tag cstore { private(cstore_private); }\n type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n-      mutable used_crate_files: [istr],\n-      mutable used_libraries: [istr],\n-      mutable used_link_args: [istr]};\n+      mutable used_crate_files: [str],\n+      mutable used_libraries: [str],\n+      mutable used_link_args: [str]};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n@@ -82,34 +82,34 @@ iter iter_crate_data(cstore: &cstore) ->\n     }\n }\n \n-fn add_used_crate_file(cstore: &cstore, lib: &istr) {\n+fn add_used_crate_file(cstore: &cstore, lib: &str) {\n     if !vec::member(lib, p(cstore).used_crate_files) {\n         p(cstore).used_crate_files += [lib];\n     }\n }\n \n-fn get_used_crate_files(cstore: &cstore) -> [istr] {\n+fn get_used_crate_files(cstore: &cstore) -> [str] {\n     ret p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: &cstore, lib: &istr) -> bool {\n-    if lib == ~\"\" { ret false; }\n+fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n+    if lib == \"\" { ret false; }\n \n     if vec::member(lib, p(cstore).used_libraries) { ret false; }\n \n     p(cstore).used_libraries += [lib];\n     ret true;\n }\n \n-fn get_used_libraries(cstore: &cstore) -> [istr] {\n+fn get_used_libraries(cstore: &cstore) -> [str] {\n     ret p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(cstore: &cstore, args: &istr) {\n+fn add_used_link_args(cstore: &cstore, args: &str) {\n     p(cstore).used_link_args += str::split(args, ' ' as u8);\n }\n \n-fn get_used_link_args(cstore: &cstore) -> [istr] {\n+fn get_used_link_args(cstore: &cstore) -> [str] {\n     ret p(cstore).used_link_args;\n }\n "}, {"sha": "7803e6922a115dfa90127fdad059d93bb73a9da2", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -83,7 +83,7 @@ fn item_family(item: &ebml::doc) -> u8 {\n     ret ebml::doc_as_uint(fam) as u8;\n }\n \n-fn item_symbol(item: &ebml::doc) -> istr {\n+fn item_symbol(item: &ebml::doc) -> str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n     ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n@@ -96,7 +96,7 @@ fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: &external_resolver) -> ty::t {\n     fn parse_external_def_id(this_cnum: ast::crate_num,\n-                             extres: &external_resolver, s: &istr) ->\n+                             extres: &external_resolver, s: &str) ->\n        ast::def_id {\n         let buf = str::bytes(s);\n         let external_def_id = parse_def_id(buf);\n@@ -149,16 +149,15 @@ fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n-    fn eq_item(data: &[u8], s: &istr) -> bool {\n+    fn eq_item(data: &[u8], s: &str) -> bool {\n         ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n-    let s = str::connect(path, ~\"::\");\n+    let s = str::connect(path, \"::\");\n     let md = ebml::new_doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = [];\n-    for doc: ebml::doc in lookup_hash(paths, eqer,\n-                                      hash_path(s)) {\n+    for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += [parse_def_id(ebml::doc_data(did_doc))];\n     }\n@@ -222,7 +221,7 @@ fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n     ret item_ty_param_kinds(lookup_item(id, data));\n }\n \n-fn get_symbol(data: @[u8], id: ast::node_id) -> istr {\n+fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n@@ -268,31 +267,31 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n         };\n }\n \n-fn read_path(d: &ebml::doc) -> {path: istr, pos: uint} {\n+fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n-fn describe_def(items: &ebml::doc, id: ast::def_id) -> istr {\n-    if id.crate != ast::local_crate { ret ~\"external\"; }\n+fn describe_def(items: &ebml::doc, id: ast::def_id) -> str {\n+    if id.crate != ast::local_crate { ret \"external\"; }\n     ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n \n-fn item_family_to_str(fam: u8) -> istr {\n+fn item_family_to_str(fam: u8) -> str {\n     alt fam as char {\n-      'c' { ret ~\"const\"; }\n-      'f' { ret ~\"fn\"; }\n-      'p' { ret ~\"pure fn\"; }\n-      'F' { ret ~\"native fn\"; }\n-      'y' { ret ~\"type\"; }\n-      'T' { ret ~\"native type\"; }\n-      't' { ret ~\"type\"; }\n-      'm' { ret ~\"mod\"; }\n-      'n' { ret ~\"native mod\"; }\n-      'v' { ret ~\"tag\"; }\n+      'c' { ret \"const\"; }\n+      'f' { ret \"fn\"; }\n+      'p' { ret \"pure fn\"; }\n+      'F' { ret \"native fn\"; }\n+      'y' { ret \"type\"; }\n+      'T' { ret \"native type\"; }\n+      't' { ret \"type\"; }\n+      'm' { ret \"mod\"; }\n+      'n' { ret \"native mod\"; }\n+      'v' { ret \"tag\"; }\n     }\n }\n \n@@ -347,29 +346,25 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n \n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n-        out.write_str(\n-                #fmt[\"%s\\n\",\n-                     pprust::meta_item_to_str(*mi)]);\n+        out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n-    out.write_str(~\"=Crate Attributes=\\n\");\n+    out.write_str(\"=Crate Attributes=\\n\");\n \n     for attr: ast::attribute in get_attributes(md) {\n-        out.write_str(\n-                #fmt[\"%s\\n\",\n-                     pprust::attribute_to_str(attr)]);\n+        out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n     }\n \n-    out.write_str(~\"\\n\\n\");\n+    out.write_str(\"\\n\\n\");\n }\n \n fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n     ret get_attributes(ebml::new_doc(data));\n }\n \n-type crate_dep = {cnum: ast::crate_num, ident: istr};\n+type crate_dep = {cnum: ast::crate_num, ident: str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let deps: [crate_dep] = [];\n@@ -385,19 +380,17 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n }\n \n fn list_crate_deps(data: @[u8], out: io::writer) {\n-    out.write_str(~\"=External Dependencies=\\n\");\n+    out.write_str(\"=External Dependencies=\\n\");\n \n     for dep: crate_dep in get_crate_deps(data) {\n-        out.write_str(\n-            #fmt[\"%d %s\\n\", dep.cnum,\n-                                 dep.ident]);\n+        out.write_str(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]);\n     }\n \n-    out.write_str(~\"\\n\");\n+    out.write_str(\"\\n\");\n }\n \n fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n-    out.write_str(~\"=Items=\\n\");\n+    out.write_str(\"=Items=\\n\");\n     let paths = ebml::get_doc(md, tag_paths);\n     let items = ebml::get_doc(md, tag_items);\n     let index = ebml::get_doc(paths, tag_index);\n@@ -410,13 +403,11 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n             let def = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n-            out.write_str(\n-                    #fmt[\"%s (%s)\\n\",\n-                         data.path,\n-                         describe_def(items, did)]);\n+            out.write_str(#fmt[\"%s (%s)\\n\", data.path,\n+                               describe_def(items, did)]);\n         }\n     }\n-    out.write_str(~\"\\n\");\n+    out.write_str(\"\\n\");\n }\n \n fn list_crate_metadata(bytes: &@[u8], out: io::writer) {"}, {"sha": "342ddcc887d65d4fd8a616d40340b71dde215fa7", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -26,7 +26,7 @@ type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n-fn encode_name(ebml_w: &ebml::writer, name: &istr) {\n+fn encode_name(ebml_w: &ebml::writer, name: &str) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(str::bytes(name));\n     ebml::end_tag(ebml_w);\n@@ -41,7 +41,7 @@ fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n type entry<T> = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n-                            path: &[istr], index: &mutable [entry<istr>]) {\n+                            path: &[str], index: &mutable [entry<str>]) {\n     for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -51,16 +51,16 @@ fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n     }\n }\n \n-fn add_to_index(ebml_w: &ebml::writer, path: &[istr],\n-                index: &mutable [entry<istr>], name: &istr) {\n+fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n+                index: &mutable [entry<str>], name: &str) {\n     let full_path = path + [name];\n     index +=\n-        [{val: str::connect(full_path, ~\"::\"), pos: ebml_w.writer.tell()}];\n+        [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n-                                   path: &[istr],\n-                                   index: &mutable [entry<istr>]) {\n+                                   path: &[str],\n+                                   index: &mutable [entry<str>]) {\n     for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -71,7 +71,7 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n }\n \n fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n-                            path: &[istr], index: &mutable [entry<istr>]) {\n+                            path: &[str], index: &mutable [entry<str>]) {\n     for it: @item in module.items {\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -94,20 +94,16 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_module_item_paths(ebml_w, _mod,\n-                                     path + [it.ident],\n-                                     index);\n+            encode_module_item_paths(ebml_w, _mod, path + [it.ident], index);\n             ebml::end_tag(ebml_w);\n           }\n           item_native_mod(nmod) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_mod);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n-            encode_native_module_item_paths(\n-                ebml_w, nmod,\n-                path + [it.ident],\n-                index);\n+            encode_native_module_item_paths(ebml_w, nmod, path + [it.ident],\n+                                            index);\n             ebml::end_tag(ebml_w);\n           }\n           item_ty(_, tps) {\n@@ -153,9 +149,9 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n     }\n }\n \n-fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<istr>] {\n-    let index: [entry<istr>] = [];\n-    let path: [istr] = [];\n+fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<str>] {\n+    let index: [entry<str>] = [];\n+    let path: [str] = [];\n     ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebml::end_tag(ebml_w);\n@@ -176,9 +172,7 @@ fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(did: &def_id) -> istr {\n-    ret #fmt[\"%d:%d\", did.crate, did.node];\n-}\n+fn def_to_str(did: &def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n@@ -441,9 +435,7 @@ fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n     ebml::end_tag(ebml_w);\n }\n \n-fn write_str(writer: &io::writer, s: &istr) {\n-    writer.write_str(s);\n-}\n+fn write_str(writer: &io::writer, s: &str) { writer.write_str(s); }\n \n fn write_int(writer: &io::writer, n: &int) {\n     writer.write_be_uint(n as uint, 4u);\n@@ -505,24 +497,22 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     fn synthesize_link_attr(ecx: &@encode_ctxt, items: &[@meta_item]) ->\n        attribute {\n \n-        assert (ecx.ccx.link_meta.name != ~\"\");\n-        assert (ecx.ccx.link_meta.vers != ~\"\");\n+        assert (ecx.ccx.link_meta.name != \"\");\n+        assert (ecx.ccx.link_meta.vers != \"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(\n-                ~\"name\", ecx.ccx.link_meta.name);\n+            attr::mk_name_value_item_str(\"name\", ecx.ccx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(\n-                ~\"vers\", ecx.ccx.link_meta.vers);\n+            attr::mk_name_value_item_str(\"vers\", ecx.ccx.link_meta.vers);\n \n         let other_items =\n             {\n-                let tmp = attr::remove_meta_items_by_name(items, ~\"name\");\n-                attr::remove_meta_items_by_name(tmp, ~\"vers\")\n+                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n+                attr::remove_meta_items_by_name(tmp, \"vers\")\n             };\n \n         let meta_items = [name_item, vers_item] + other_items;\n-        let link_item = attr::mk_list_item(~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n     }\n@@ -531,7 +521,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     let found_link_attr = false;\n     for attr: attribute in crate.node.attrs {\n         attrs +=\n-            if attr::get_attr_name(attr) != ~\"link\" {\n+            if attr::get_attr_name(attr) != \"link\" {\n                 [attr]\n             } else {\n                 alt attr.node.value.node {\n@@ -551,9 +541,9 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n \n fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n-    fn get_ordered_names(cstore: &cstore::cstore) -> [istr] {\n+    fn get_ordered_names(cstore: &cstore::cstore) -> [str] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n-        type numname = {crate: crate_num, ident: istr};\n+        type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n         let pairs: [mutable numname] = [mutable];\n@@ -575,7 +565,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n         }\n \n         // Return just the names\n-        fn name(kv: &numname) -> istr { kv.ident }\n+        fn name(kv: &numname) -> str { kv.ident }\n         // mutable -> immutable hack for vec::map\n         let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n         ret vec::map(name, immpairs);\n@@ -586,15 +576,15 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml::start_tag(ebml_w, tag_crate_deps);\n-    for cname: istr in get_ordered_names(cstore) {\n+    for cname: str in get_ordered_names(cstore) {\n         ebml::start_tag(ebml_w, tag_crate_dep);\n         ebml_w.writer.write(str::bytes(cname));\n         ebml::end_tag(ebml_w);\n     }\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> istr {\n+fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n \n     let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n@@ -630,7 +620,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> istr {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> istr {\n+fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n     let sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);"}, {"sha": "742e82c5341b9407e9bad5492ed194447dba5032", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -20,7 +20,7 @@ export parse_ty_data;\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn(&istr) -> ast::def_id;\n+type str_def = fn(&str) -> ast::def_id;\n \n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n@@ -42,7 +42,7 @@ fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n \n fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool) ->\n    ast::ident {\n-    let rslt = ~\"\";\n+    let rslt = \"\";\n     while !is_last(peek(st) as char) {\n         rslt += str::unsafe_from_byte(next(st));\n     }\n@@ -193,7 +193,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         }\n       }\n       'c' { ret ty::mk_char(st.tcx); }\n-      'S' { ret ty::mk_istr(st.tcx); }\n+      'S' { ret ty::mk_str(st.tcx); }\n       't' {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, sd);\n@@ -224,7 +224,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         assert (next(st) as char == '[');\n         let fields: [ty::field] = [];\n         while peek(st) as char != ']' {\n-            let name = ~\"\";\n+            let name = \"\";\n             while peek(st) as char != '=' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n@@ -277,7 +277,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n               'W' { proto = ast::proto_iter; }\n               'F' { proto = ast::proto_fn; }\n             }\n-            let name = ~\"\";\n+            let name = \"\";\n             while peek(st) as char != '[' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n@@ -342,10 +342,8 @@ fn parse_mt(st: @pstate, sd: str_def) -> ty::mt {\n }\n \n fn parse_def(st: @pstate, sd: str_def) -> ast::def_id {\n-    let def = ~\"\";\n-    while peek(st) as char != '|' {\n-        def += str::unsafe_from_byte(next(st));\n-    }\n+    let def = \"\";\n+    while peek(st) as char != '|' { def += str::unsafe_from_byte(next(st)); }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n }"}, {"sha": "d44e60c194bbe7d172933b1bf061429daa202cee", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -19,14 +19,14 @@ export ac_use_abbrevs;\n export enc_ty;\n \n type ctxt =\n-     // Def -> str Callback:\n-     // The type context.\n-     {ds: fn(&def_id) -> istr, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n+    // Def -> str Callback:\n+    // The type context.\n+    {ds: fn(&def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = {pos: uint, len: uint, s: @istr};\n+type ty_abbrev = {pos: uint, len: uint, s: @str};\n \n tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n@@ -40,7 +40,7 @@ fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n     alt cx.abbrevs {\n       ac_no_abbrevs. {\n-        let result_str: @istr;\n+        let result_str: @str;\n         alt cx.tcx.short_names_cache.find(t) {\n           some(s) { result_str = s; }\n           none. {\n@@ -71,8 +71,8 @@ fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n                 // I.e. it's actually an abbreviation.\n \n                 let s =\n-                    ~\"#\" + uint::to_str(pos, 16u) + ~\":\" +\n-                    uint::to_str(len, 16u) + ~\"#\";\n+                    \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                        uint::to_str(len, 16u) + \"#\";\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n@@ -100,29 +100,29 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_float. { w.write_char('l'); }\n       ty::ty_machine(mach) {\n         alt mach {\n-          ty_u8. { w.write_str(~\"Mb\"); }\n-          ty_u16. { w.write_str(~\"Mw\"); }\n-          ty_u32. { w.write_str(~\"Ml\"); }\n-          ty_u64. { w.write_str(~\"Md\"); }\n-          ty_i8. { w.write_str(~\"MB\"); }\n-          ty_i16. { w.write_str(~\"MW\"); }\n-          ty_i32. { w.write_str(~\"ML\"); }\n-          ty_i64. { w.write_str(~\"MD\"); }\n-          ty_f32. { w.write_str(~\"Mf\"); }\n-          ty_f64. { w.write_str(~\"MF\"); }\n+          ty_u8. { w.write_str(\"Mb\"); }\n+          ty_u16. { w.write_str(\"Mw\"); }\n+          ty_u32. { w.write_str(\"Ml\"); }\n+          ty_u64. { w.write_str(\"Md\"); }\n+          ty_i8. { w.write_str(\"MB\"); }\n+          ty_i16. { w.write_str(\"MW\"); }\n+          ty_i32. { w.write_str(\"ML\"); }\n+          ty_i64. { w.write_str(\"MD\"); }\n+          ty_f32. { w.write_str(\"Mf\"); }\n+          ty_f64. { w.write_str(\"MF\"); }\n         }\n       }\n       ty::ty_char. { w.write_char('c'); }\n-      ty::ty_istr. { w.write_char('S'); }\n+      ty::ty_str. { w.write_char('S'); }\n       ty::ty_tag(def, tys) {\n-        w.write_str(~\"t[\");\n+        w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n-        w.write_str(~\"T[\");\n+        w.write_str(\"T[\");\n         for t in ts { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n@@ -131,7 +131,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n-        w.write_str(~\"R[\");\n+        w.write_str(\"R[\");\n         for field: ty::field in fields {\n             w.write_str(field.ident);\n             w.write_char('=');\n@@ -155,7 +155,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         enc_ty_fn(w, cx, args, out, return, []);\n       }\n       ty::ty_obj(methods) {\n-        w.write_str(~\"O[\");\n+        w.write_str(\"O[\");\n         for m: ty::method in methods {\n             enc_proto(w, m.proto);\n             w.write_str(m.ident);\n@@ -164,33 +164,30 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_char(']');\n       }\n       ty::ty_res(def, ty, tps) {\n-        w.write_str(~\"r[\");\n+        w.write_str(\"r[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n         for t: ty::t in tps { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n-      ty::ty_var(id) {\n-        w.write_char('X');\n-        w.write_str(int::str(id));\n-      }\n+      ty::ty_var(id) { w.write_char('X'); w.write_str(int::str(id)); }\n       ty::ty_native(def) {\n         w.write_char('E');\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n       ty::ty_param(id, k) {\n         alt k {\n-          kind_unique. { w.write_str(~\"pu\"); }\n-          kind_shared. { w.write_str(~\"ps\"); }\n-          kind_pinned. { w.write_str(~\"pp\"); }\n+          kind_unique. { w.write_str(\"pu\"); }\n+          kind_shared. { w.write_str(\"ps\"); }\n+          kind_pinned. { w.write_str(\"pp\"); }\n         }\n         w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n       ty::ty_constr(ty, cs) {\n-        w.write_str(~\"A[\");\n+        w.write_str(\"A[\");\n         enc_ty(w, cx, ty);\n         for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n@@ -244,9 +241,7 @@ fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n           carg_ident(i) { w.write_uint(i); }\n-          carg_lit(l) {\n-            w.write_str(lit_to_str(l));\n-          }\n+          carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n     }\n     w.write_char(')');\n@@ -262,10 +257,8 @@ fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n-          carg_ident(p) {\n-            w.write_str(path_to_str(p)); }\n-          carg_lit(l) {\n-            w.write_str(lit_to_str(l)); }\n+          carg_ident(p) { w.write_str(path_to_str(p)); }\n+          carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n     }\n     w.write_char(')');"}, {"sha": "a808528031d36e6ac53b11815dedc79a1088b611", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 92, "deletions": 80, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -32,37 +32,45 @@ type restrict =\n \n type scope = @[restrict];\n \n-tag local_info {\n-    local(uint);\n-}\n+tag local_info { local(uint); }\n \n-type ctx = {tcx: ty::ctxt,\n-            local_map: std::map::hashmap<node_id, local_info>,\n-            mutable next_local: uint};\n+type ctx =\n+    {tcx: ty::ctxt,\n+     local_map: std::map::hashmap<node_id, local_info>,\n+     mutable next_local: uint};\n \n fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n-    let cx = @{tcx: tcx,\n-               local_map: std::map::new_int_hash(),\n-               mutable next_local: 0u};\n-    let v = @{visit_fn: visit_fn,\n-              visit_expr: bind visit_expr(cx, _, _, _),\n-              visit_decl: bind visit_decl(cx, _, _, _)\n-              with *visit::default_visitor::<scope>()};\n+    let cx =\n+        @{tcx: tcx,\n+          local_map: std::map::new_int_hash(),\n+          mutable next_local: 0u};\n+    let v =\n+        @{visit_fn: visit_fn,\n+          visit_expr: bind visit_expr(cx, _, _, _),\n+          visit_decl: bind visit_decl(cx, _, _, _)\n+             with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n-            _name: &fn_ident, _id: ast::node_id, sc: &scope, v: &vt<scope>) {\n+fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span, _name: &fn_ident,\n+            _id: ast::node_id, sc: &scope, v: &vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    let scope = alt f.proto {\n-      // Blocks need to obey any restrictions from the enclosing scope.\n-      ast::proto_block. | ast::proto_closure. { sc }\n-      // Non capturing functions start out fresh.\n-      _ { @[] }\n-    };\n+    let scope =\n+        alt f.proto {\n+\n+          // Blocks need to obey any restrictions from the enclosing scope.\n+          ast::proto_block. | ast::proto_closure. {\n+            sc\n+          }\n+\n+          // Non capturing functions start out fresh.\n+          _ {\n+            @[]\n+          }\n+        };\n     v.visit_block(f.body, scope, v);\n }\n \n@@ -80,8 +88,8 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n             let root = expr_root(cx.tcx, ex, false);\n             if mut_field(root.ds) {\n                 cx.tcx.sess.span_err(ex.span,\n-                                     ~\"result of put must be\" +\n-                                         ~\" immutably rooted\");\n+                                     \"result of put must be\" +\n+                                         \" immutably rooted\");\n             }\n             visit_expr(cx, ex, sc, v);\n           }\n@@ -140,8 +148,8 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     }\n }\n \n-fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n-    -> [restrict] {\n+fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n+   [restrict] {\n     let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n@@ -157,65 +165,67 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n                     let dnum = ast_util::def_id_of_def(def).node;\n                     mut_roots += [{arg: i, node: dnum}];\n                   }\n-                  _ {}\n+                  _ { }\n                 }\n             }\n             let root_var = path_def_id(cx, root.ex);\n-            let unsafe_t = alt inner_mut(root.ds) {\n-              some(t) { some(t) }\n-              _ { none }\n-            };\n-            restricts += [@{root_var: root_var,\n-                            local_id: cx.next_local,\n-                            bindings: [arg.id],\n-                            unsafe_ty: unsafe_t,\n-                            depends_on: deps(sc, root_var),\n-                            mutable ok: valid}];\n+            let unsafe_t =\n+                alt inner_mut(root.ds) { some(t) { some(t) } _ { none } };\n+            restricts +=\n+                [@{root_var: root_var,\n+                   local_id: cx.next_local,\n+                   bindings: [arg.id],\n+                   unsafe_ty: unsafe_t,\n+                   depends_on: deps(sc, root_var),\n+                   mutable ok: valid}];\n         }\n         i += 1u;\n     }\n-    let f_may_close = alt f.node {\n-      ast::expr_path(_) { def_is_local(cx.tcx.def_map.get(f.id), true) }\n-      _ { true }\n-    };\n+    let f_may_close =\n+        alt f.node {\n+          ast::expr_path(_) { def_is_local(cx.tcx.def_map.get(f.id), true) }\n+          _ { true }\n+        };\n     if f_may_close {\n         let i = 0u;\n         for r in restricts {\n             if !option::is_none(r.unsafe_ty) {\n                 cx.tcx.sess.span_err(f.span,\n                                      #fmt[\"function may alias with argument \\\n                                            %u, which is not immutably rooted\",\n-                                           i]);\n+                                          i]);\n             }\n             i += 1u;\n         }\n     }\n     let j = 0u;\n-    for @{unsafe_ty, _} in restricts {\n+    for @{unsafe_ty: unsafe_ty, _} in restricts {\n         alt unsafe_ty {\n           some(ty) {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ty::mo_alias(true);\n                 if i != j &&\n-                   ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) {\n-                    cx.tcx.sess.span_err(args[i].span,\n+                       ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) {\n+                    cx.tcx.sess.span_err(\n+                        args[i].span,\n                         #fmt[\"argument %u may alias with argument %u, \\\n-                               which is not immutably rooted\", i, j]);\n+                               which is not immutably rooted\",\n+                                              i, j]);\n                 }\n                 i += 1u;\n             }\n           }\n-          _ {}\n+          _ { }\n         }\n         j += 1u;\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for {node, arg} in mut_roots {\n+    for {node: node, arg: arg} in mut_roots {\n         let mut_alias_to_root = false;\n         let mut_alias_to_root_count = 0u;\n-        for @{root_var, _} in restricts {\n+        for @{root_var: root_var, _} in restricts {\n             alt root_var {\n               some(root) {\n                 if node == root {\n@@ -226,13 +236,13 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n                     }\n                 }\n               }\n-              none. {}\n+              none. { }\n             }\n         }\n \n         if mut_alias_to_root {\n             cx.tcx.sess.span_err(args[arg].span,\n-                                 ~\"passing a mutable alias to a variable \\\n+                                 \"passing a mutable alias to a variable \\\n                                    that roots another alias\");\n         }\n     }\n@@ -248,12 +258,14 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n         let new_sc = sc;\n         if vec::len(dnums) > 0u {\n             let root_var = path_def_id(cx, root.ex);\n-            new_sc = @(*sc + [@{root_var: root_var,\n-                                local_id: cx.next_local,\n-                                bindings: dnums,\n-                                unsafe_ty: inner_mut(root.ds),\n-                                depends_on: deps(sc, root_var),\n-                                mutable ok: valid}]);\n+            new_sc =\n+                @(*sc +\n+                      [@{root_var: root_var,\n+                         local_id: cx.next_local,\n+                         bindings: dnums,\n+                         unsafe_ty: inner_mut(root.ds),\n+                         depends_on: deps(sc, root_var),\n+                         mutable ok: valid}]);\n         }\n         register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, new_sc, v);\n@@ -282,10 +294,11 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     alt ty::struct(cx.tcx, seq_t) {\n       ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = some(seq_t); } }\n-      ty::ty_istr. {/* no-op */ }\n+      ty::ty_str. {/* no-op */ }\n       _ {\n-        cx.tcx.sess.span_unimpl(seq.span, ~\"unknown seq type \" +\n-                                util::ppaux::ty_to_str(cx.tcx, seq_t));\n+        cx.tcx.sess.span_unimpl(seq.span,\n+                                \"unknown seq type \" +\n+                                    util::ppaux::ty_to_str(cx.tcx, seq_t));\n       }\n     }\n     let root_var = path_def_id(cx, root.ex);\n@@ -305,12 +318,11 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     let def = cx.tcx.def_map.get(id);\n     if !def_is_local(def, true) { ret; }\n     let my_defnum = ast_util::def_id_of_def(def).node;\n-    let my_local_id = alt cx.local_map.find(my_defnum) {\n-      some(local(id)) { id }\n-      _ { 0u }\n-    };\n+    let my_local_id =\n+        alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n+\n         // excludes variables introduced since the alias was made\n         if my_local_id < r.local_id {\n             alt r.unsafe_ty {\n@@ -319,7 +331,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n                     r.ok = val_taken(ex.span, p);\n                 }\n               }\n-              _ {}\n+              _ { }\n             }\n         } else if vec::member(my_defnum, r.bindings) {\n             test_scope(cx, sc, r, p);\n@@ -333,9 +345,7 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n         let def = cx.tcx.def_map.get(dest.id);\n         let dnum = ast_util::def_id_of_def(def).node;\n         for r: restrict in *sc {\n-            if r.root_var == some(dnum) {\n-                r.ok = overwritten(dest.span, p);\n-            }\n+            if r.root_var == some(dnum) { r.ok = overwritten(dest.span, p); }\n         }\n       }\n       _ { visit_expr(cx, dest, sc, v); }\n@@ -358,19 +368,17 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n         let msg =\n             alt prob {\n               overwritten(sp, wpt) {\n-                {span: sp, msg: ~\"overwriting \" +\n-                    ast_util::path_name(wpt)}\n+                {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n               }\n               val_taken(sp, vpt) {\n                 {span: sp,\n-                 msg: ~\"taking the value of \" +\n-                     ast_util::path_name(vpt)}\n+                 msg: \"taking the value of \" + ast_util::path_name(vpt)}\n               }\n             };\n         cx.tcx.sess.span_err(msg.span,\n-                             msg.msg + ~\" will invalidate alias \" +\n-                             ast_util::path_name(p) +\n-                             ~\", which is still used\");\n+                             msg.msg + \" will invalidate alias \" +\n+                                 ast_util::path_name(p) +\n+                                 \", which is still used\");\n     }\n }\n \n@@ -384,7 +392,7 @@ fn deps(sc: &scope, root: &option::t<node_id>) -> [uint] {\n             i += 1u;\n         }\n       }\n-      _ {}\n+      _ { }\n     }\n     ret result;\n }\n@@ -438,13 +446,15 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n           }\n \n \n+\n           // These may contain anything.\n           ty::ty_fn(_, _, _, _, _) {\n             ret true;\n           }\n           ty::ty_obj(_) { ret true; }\n \n \n+\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n@@ -460,11 +470,13 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n \n fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n     ret alt d {\n-      ast::def_local(_) | ast::def_arg(_, _) | ast::def_binding(_) |\n-      ast::def_upvar(_, _, _) { true }\n-      ast::def_obj_field(_, _) { objfields_count }\n-      _ { false }\n-    };\n+          ast::def_local(_) | ast::def_arg(_, _) | ast::def_binding(_) |\n+          ast::def_upvar(_, _, _) {\n+            true\n+          }\n+          ast::def_obj_field(_, _) { objfields_count }\n+          _ { false }\n+        };\n }\n \n // Local Variables:"}, {"sha": "356d2b46b8cfe03bf5b709670dfd00156e3d842a", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -131,7 +131,7 @@ mod test {\n     fn test_node_span_item() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_item(@{ident: ~\"test\",\n+            node_item(@{ident: \"test\",\n                         attrs: [],\n                         id: 0,\n                         node: item_mod({view_items: [], items: []}),\n@@ -143,7 +143,7 @@ mod test {\n     fn test_node_span_obj_ctor() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_obj_ctor(@{ident: ~\"test\",\n+            node_obj_ctor(@{ident: \"test\",\n                             attrs: [],\n                             id: 0,\n                             node: item_mod({view_items: [], items: []}),\n@@ -155,7 +155,7 @@ mod test {\n     fn test_node_span_native_item() {\n         let expected: codemap::span = ast_util::mk_sp(20u, 30u);\n         let node =\n-            node_native_item(@{ident: ~\"test\",\n+            node_native_item(@{ident: \"test\",\n                                attrs: [],\n                                node: native_item_ty,\n                                id: 0,"}, {"sha": "ce5e937cf69abc5decf56ea892db5add5cdd23c8", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -34,7 +34,7 @@ fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n                 j += 1;\n             }\n             if !reachable {\n-                tcx.sess.span_err(arm_pat.span, ~\"unreachable pattern\");\n+                tcx.sess.span_err(arm_pat.span, \"unreachable pattern\");\n             }\n         }\n         i += 1;\n@@ -106,7 +106,7 @@ fn check_local(tcx: &ty::ctxt, loc: &@local, s: &(), v: &visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {\n         tcx.sess.span_err(loc.node.pat.span,\n-                          ~\"refutable pattern in local binding\");\n+                          \"refutable pattern in local binding\");\n     }\n }\n "}, {"sha": "50d4d1c062bc14c3393e3502590ec7cf6d376eed", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,53 +29,50 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: &resolve::def_map,\n-                    walker: &fn(&visit::vt<int>)) -> freevar_info {\n+fn collect_freevars(def_map: &resolve::def_map, walker: &fn(&visit::vt<int>))\n+   -> freevar_info {\n     let seen = new_int_hash();\n     let refs = @mutable [];\n \n-    fn ignore_item(_i: &@ast::item, _depth: &int, _v: &visit::vt<int>) {}\n+    fn ignore_item(_i: &@ast::item, _depth: &int, _v: &visit::vt<int>) { }\n \n-    let walk_expr = lambda(expr: &@ast::expr, depth: &int,\n-                           v: &visit::vt<int>) {\n-        alt expr.node {\n-          ast::expr_fn(f) {\n-            if f.proto == ast::proto_block ||\n-               f.proto == ast::proto_closure {\n-                visit::visit_expr(expr, depth + 1, v);\n-            }\n-          }\n-          ast::expr_for_each(dcl, x, b) {\n-            v.visit_local(dcl, depth, v);\n-            v.visit_expr(x, depth, v);\n-            v.visit_block(b, depth + 1, v);\n-          }\n-          ast::expr_path(path) {\n-            let def = def_map.get(expr.id), i = 0;\n-            while i < depth {\n-                alt {def} {\n-                  ast::def_upvar(_, inner, _) {\n-                    def = *inner;\n-                  }\n-                  _ { break; }\n+    let walk_expr =\n+        lambda (expr: &@ast::expr, depth: &int, v: &visit::vt<int>) {\n+            alt expr.node {\n+              ast::expr_fn(f) {\n+                if f.proto == ast::proto_block ||\n+                       f.proto == ast::proto_closure {\n+                    visit::visit_expr(expr, depth + 1, v);\n                 }\n-                i += 1;\n-            }\n-            if i == depth { // Made it to end of loop\n-                let dnum = ast_util::def_id_of_def(def).node;\n-                if !seen.contains_key(dnum) {\n-                    *refs += [def];\n-                    seen.insert(dnum, ());\n+              }\n+              ast::expr_for_each(dcl, x, b) {\n+                v.visit_local(dcl, depth, v);\n+                v.visit_expr(x, depth, v);\n+                v.visit_block(b, depth + 1, v);\n+              }\n+              ast::expr_path(path) {\n+                let def = def_map.get(expr.id), i = 0;\n+                while i < depth {\n+                    alt { def } {\n+                      ast::def_upvar(_, inner, _) { def = *inner; }\n+                      _ { break; }\n+                    }\n+                    i += 1;\n                 }\n+                if i == depth { // Made it to end of loop\n+                    let dnum = ast_util::def_id_of_def(def).node;\n+                    if !seen.contains_key(dnum) {\n+                        *refs += [def];\n+                        seen.insert(dnum, ());\n+                    }\n+                }\n+              }\n+              _ { visit::visit_expr(expr, depth, v); }\n             }\n-          }\n-          _ { visit::visit_expr(expr, depth, v); }\n-        }\n-    };\n+        };\n \n-    walker(visit::mk_vt(@{visit_item: ignore_item,\n-                          visit_expr: walk_expr\n-                          with *visit::default_visitor()}));\n+    walker(visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr\n+                             with *visit::default_visitor()}));\n     ret @*refs;\n }\n \n@@ -84,30 +81,34 @@ fn collect_freevars(def_map: &resolve::def_map,\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-fn annotate_freevars(def_map: &resolve::def_map,\n-                     crate: &@ast::crate) -> freevar_map {\n+fn annotate_freevars(def_map: &resolve::def_map, crate: &@ast::crate) ->\n+   freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn = lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n-                          i: &ast::fn_ident, nid: ast::node_id) {\n-        let start_walk = lambda (v: &visit::vt<int>) {\n-            v.visit_fn(f, tps, sp, i, nid, 1, v);\n-        };\n-        let vars = collect_freevars(def_map, start_walk);\n-        freevars.insert(nid, vars);\n-    };\n-    let walk_expr = lambda (expr: &@ast::expr) {\n-        alt expr.node {\n-          ast::expr_for_each(local, _, body) {\n-            let start_walk = lambda (v: &visit::vt<int>) {\n-                v.visit_block(body, 1, v);\n-            };\n+    let walk_fn =\n+        lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n+                i: &ast::fn_ident, nid: ast::node_id) {\n+            let start_walk =\n+                lambda (v: &visit::vt<int>) {\n+                    v.visit_fn(f, tps, sp, i, nid, 1, v);\n+                };\n             let vars = collect_freevars(def_map, start_walk);\n-            freevars.insert(body.node.id, vars);\n-          }\n-          _ { }\n-        }\n-    };\n+            freevars.insert(nid, vars);\n+        };\n+    let walk_expr =\n+        lambda (expr: &@ast::expr) {\n+            alt expr.node {\n+              ast::expr_for_each(local, _, body) {\n+                let start_walk =\n+                    lambda (v: &visit::vt<int>) {\n+                        v.visit_block(body, 1, v);\n+                    };\n+                let vars = collect_freevars(def_map, start_walk);\n+                freevars.insert(body.node.id, vars);\n+              }\n+              _ { }\n+            }\n+        };\n \n     let visitor =\n         visit::mk_simple_visitor(@{visit_fn: walk_fn, visit_expr: walk_expr\n@@ -119,10 +120,7 @@ fn annotate_freevars(def_map: &resolve::def_map,\n \n fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n     alt tcx.freevars.find(fid) {\n-      none. {\n-        fail ~\"get_freevars: \" + int::str(fid)\n-            + ~\" has no freevars\";\n-      }\n+      none. { fail \"get_freevars: \" + int::str(fid) + \" has no freevars\"; }\n       some(d) { ret d; }\n     }\n }"}, {"sha": "4ce93f7737a0b2abe9a5afd2cfed055cc58c4b37", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,7 +4,7 @@ import lib::llvm::False;\n import lib::llvm::True;\n import lib::llvm::llvm::ValueRef;\n import middle::trans;\n-import middle::trans::{ get_tydesc, tps_normal };\n+import middle::trans::{get_tydesc, tps_normal};\n import middle::trans_common::*;\n import middle::ty;\n import std::option::none;\n@@ -21,10 +21,12 @@ type ctxt = @{mutable next_tydesc_num: uint};\n \n fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n-fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &istr) -> ValueRef {\n-    let llglobal = str::as_buf(name, { |buf|\n-        lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n-    });\n+fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &str) -> ValueRef {\n+    let llglobal =\n+        str::as_buf(name,\n+                    {|buf|\n+                        lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+                    });\n     lll::LLVMSetInitializer(llglobal, llval);\n     lll::LLVMSetGlobalConstant(llglobal, True);\n     ret llglobal;\n@@ -48,7 +50,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     bcx = td_r.result.bcx;\n     let lltydesc = td_r.result.val;\n \n-    let gcroot = bcx_ccx(bcx).intrinsics.get(~\"llvm.gcroot\");\n+    let gcroot = bcx_ccx(bcx).intrinsics.get(\"llvm.gcroot\");\n     let llvalptr = bld::PointerCast(bcx, llval, T_ptr(T_ptr(T_i8())));\n \n     alt td_r.kind {\n@@ -65,30 +67,31 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n         let lldestindex =\n             add_global(bcx_ccx(bcx), C_struct([C_int(0), C_uint(number)]),\n-                       ~\"rust_gc_tydesc_dest_index\");\n+                       \"rust_gc_tydesc_dest_index\");\n         let llsrcindex =\n             add_global(bcx_ccx(bcx), C_struct([C_int(1), C_uint(number)]),\n-                       ~\"rust_gc_tydesc_src_index\");\n+                       \"rust_gc_tydesc_src_index\");\n \n         lldestindex = lll::LLVMConstPointerCast(lldestindex, T_ptr(T_i8()));\n         llsrcindex = lll::LLVMConstPointerCast(llsrcindex, T_ptr(T_i8()));\n \n-        lltydescptr = bld::PointerCast(llderivedtydescs, lltydescptr,\n-                                       T_ptr(T_ptr(T_i8())));\n+        lltydescptr =\n+            bld::PointerCast(llderivedtydescs, lltydescptr,\n+                             T_ptr(T_ptr(T_i8())));\n \n         bld::Call(llderivedtydescs, gcroot, [lltydescptr, lldestindex]);\n         bld::Call(bcx, gcroot, [llvalptr, llsrcindex]);\n       }\n       tk_param. {\n-        bcx_tcx(cx).sess.bug(~\"we should never be trying to root values \" +\n-                                 ~\"of a type parameter\");\n+        bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n+                                 \"of a type parameter\");\n       }\n       tk_static. {\n         // Static type descriptor.\n \n         let llstaticgcmeta =\n             add_global(bcx_ccx(bcx), C_struct([C_int(2), lltydesc]),\n-                       ~\"rust_gc_tydesc_static_gc_meta\");\n+                       \"rust_gc_tydesc_static_gc_meta\");\n         let llstaticgcmetaptr =\n             lll::LLVMConstPointerCast(llstaticgcmeta, T_ptr(T_i8()));\n \n@@ -102,13 +105,14 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n       ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. | ty::ty_float. |\n-      ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_istr. |\n+      ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_str. |\n       ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) | ty::ty_type. |\n       ty::ty_native(_) {\n         ret false;\n       }\n \n \n+\n       ty::ty_rec(fields) {\n         for f in fields { if type_is_gc_relevant(cx, f.mt.ty) { ret true; } }\n         ret false;\n@@ -119,6 +123,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n       }\n \n \n+\n       ty::ty_tag(did, tps) {\n         let variants = ty::tag_variants(cx, did);\n         for variant in variants {\n@@ -131,19 +136,22 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n       }\n \n \n+\n       ty::ty_vec(tm) {\n         ret type_is_gc_relevant(cx, tm.ty);\n       }\n       ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n \n \n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _)\n-      | ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n+\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _) |\n+      ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n       ty::ty_res(_, _, _) {\n         ret true;\n       }\n \n \n+\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";\n       }"}, {"sha": "052eccb304db656d4d1e9e0c5b790fd1fe3a91ff", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -96,11 +96,11 @@ fn lower_kind(a: kind, b: kind) -> kind {\n     if kind_lteq(a, b) { a } else { b }\n }\n \n-fn kind_to_str(k: kind) -> istr {\n+fn kind_to_str(k: kind) -> str {\n     alt k {\n-      ast::kind_pinned. { ~\"pinned\" }\n-      ast::kind_unique. { ~\"unique\" }\n-      ast::kind_shared. { ~\"shared\" }\n+      ast::kind_pinned. { \"pinned\" }\n+      ast::kind_unique. { \"unique\" }\n+      ast::kind_shared. { \"shared\" }\n     }\n }\n \n@@ -112,7 +112,7 @@ fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n }\n \n fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n-                  descr: &istr) {\n+                  descr: &str) {\n     let tk = type_and_kind(tcx, e);\n     log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n              kind_to_str(k_need), kind_to_str(tk.kind),\n@@ -121,36 +121,35 @@ fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n     if !kind_lteq(k_need, tk.kind) {\n         let s =\n             #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n-                 descr, kind_to_str(k_need),\n-                 kind_to_str(tk.kind),\n+                 descr, kind_to_str(k_need), kind_to_str(tk.kind),\n                  util::ppaux::ty_to_str(tcx, tk.ty)];\n         tcx.sess.span_err(e.span, s);\n     }\n }\n \n fn need_shared_lhs_rhs(tcx: &ty::ctxt, a: &@ast::expr, b: &@ast::expr,\n-                       op: &istr) {\n-    need_expr_kind(tcx, a, ast::kind_shared, op + ~\" lhs\");\n-    need_expr_kind(tcx, b, ast::kind_shared, op + ~\" rhs\");\n+                       op: &str) {\n+    need_expr_kind(tcx, a, ast::kind_shared, op + \" lhs\");\n+    need_expr_kind(tcx, b, ast::kind_shared, op + \" rhs\");\n }\n \n fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n     alt e.node {\n-      ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"<-\"); }\n-      ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"=\"); }\n-      ast::expr_assign_op(_, a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"op=\"); }\n-      ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"<->\"); }\n+      ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n+      ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, \"=\"); }\n+      ast::expr_assign_op(_, a, b) { need_shared_lhs_rhs(tcx, a, b, \"op=\"); }\n+      ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n       ast::expr_copy(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, ~\"'copy' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, \"'copy' operand\");\n       }\n       ast::expr_ret(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, ~\"'ret' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, \"'ret' operand\");\n       }\n       ast::expr_be(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, ~\"'be' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, \"'be' operand\");\n       }\n       ast::expr_fail(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, ~\"'fail' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, \"'fail' operand\");\n       }\n       ast::expr_call(callee, _) {\n         let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n@@ -159,8 +158,8 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n         // that all the types we're supplying as typarams conform to the\n         // typaram kind constraints on that item.\n         if vec::len(tpt.params) != 0u {\n-            let callee_def = ast_util::def_id_of_def(\n-                tcx.def_map.get(callee.id));\n+            let callee_def =\n+                ast_util::def_id_of_def(tcx.def_map.get(callee.id));\n             let item_tk = ty::lookup_item_type(tcx, callee_def);\n             let i = 0;\n             assert (vec::len(item_tk.kinds) == vec::len(tpt.params));"}, {"sha": "1721a6e130fac36652ccc3d6853a5352d394e10f", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,8 +12,8 @@ type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar[1] becomes rec(ex=foo,\n // ds=[index,field])\n-fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool)\n-    -> {ex: @expr, ds: @[deref]} {\n+fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool) ->\n+   {ex: @expr, ds: @[deref]} {\n     fn maybe_auto_unbox(tcx: &ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let ds = [];\n         while true {\n@@ -32,13 +32,11 @@ fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool)\n               ty::ty_tag(did, tps) {\n                 let variants = ty::tag_variants(tcx, did);\n                 if vec::len(variants) != 1u ||\n-                   vec::len(variants[0].args) != 1u {\n+                       vec::len(variants[0].args) != 1u {\n                     break;\n                 }\n                 ds += [@{mut: false, kind: unbox, outer_t: t}];\n-                t =\n-                    ty::substitute_type_params(tcx, tps,\n-                                               variants[0].args[0]);\n+                t = ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n               }\n               _ { break; }\n             }\n@@ -121,21 +119,25 @@ type ctx = {tcx: ty::ctxt, mut_map: mut_map};\n \n fn check_crate(tcx: ty::ctxt, crate: &@crate) -> mut_map {\n     let cx = @{tcx: tcx, mut_map: std::map::new_int_hash()};\n-    let v = @{visit_expr: bind visit_expr(cx, _, _, _),\n-              visit_decl: bind visit_decl(cx, _, _, _)\n-              with *visit::default_visitor::<()>()};\n+    let v =\n+        @{visit_expr: bind visit_expr(cx, _, _, _),\n+          visit_decl: bind visit_decl(cx, _, _, _)\n+             with *visit::default_visitor::<()>()};\n     visit::visit_crate(*crate, (), visit::mk_vt(v));\n     ret cx.mut_map;\n }\n \n tag msg { msg_assign; msg_move_out; msg_mut_alias; }\n \n-fn mk_err(cx: &@ctx, span: &syntax::codemap::span, msg: msg, name: &istr) {\n-    cx.tcx.sess.span_err(span, alt msg {\n-      msg_assign. { ~\"assigning to \" + name }\n-      msg_move_out. { ~\"moving out of \" + name }\n-      msg_mut_alias. { ~\"passing \" + name + ~\" by mutable alias\" }\n-    });\n+fn mk_err(cx: &@ctx, span: &syntax::codemap::span, msg: msg, name: &str) {\n+    cx.tcx.sess.span_err(span,\n+                         alt msg {\n+                           msg_assign. { \"assigning to \" + name }\n+                           msg_move_out. { \"moving out of \" + name }\n+                           msg_mut_alias. {\n+                             \"passing \" + name + \" by mutable alias\"\n+                           }\n+                         });\n }\n \n fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n@@ -145,9 +147,7 @@ fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n         for loc: @local in locs {\n             alt loc.node.init {\n               some(init) {\n-                if init.op == init_move {\n-                    check_move_rhs(cx, init.expr);\n-                }\n+                if init.op == init_move { check_move_rhs(cx, init.expr); }\n               }\n               none. { }\n             }\n@@ -159,9 +159,7 @@ fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n \n fn visit_expr(cx: &@ctx, ex: &@expr, e: &(), v: &visit::vt<()>) {\n     alt ex.node {\n-      expr_call(f, args) {\n-        check_call(cx, f, args);\n-      }\n+      expr_call(f, args) { check_call(cx, f, args); }\n       expr_swap(lhs, rhs) {\n         check_lval(cx, lhs, msg_assign);\n         check_lval(cx, rhs, msg_assign);\n@@ -173,7 +171,7 @@ fn visit_expr(cx: &@ctx, ex: &@expr, e: &(), v: &visit::vt<()>) {\n       expr_assign(dest, src) | expr_assign_op(_, dest, src) {\n         check_lval(cx, dest, msg_assign);\n       }\n-      _ {}\n+      _ { }\n     }\n     visit::visit_expr(ex, e, v);\n }\n@@ -184,20 +182,21 @@ fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n         let def = cx.tcx.def_map.get(dest.id);\n         alt is_immutable_def(def) {\n           some(name) { mk_err(cx, dest.span, msg, name); }\n-          _ {}\n+          _ { }\n         }\n         cx.mut_map.insert(ast_util::def_id_of_def(def).node, ());\n       }\n       _ {\n         let root = expr_root(cx.tcx, dest, false);\n         if vec::len(*root.ds) == 0u {\n-            mk_err(cx, dest.span, msg, ~\"non-lvalue\");\n+            mk_err(cx, dest.span, msg, \"non-lvalue\");\n         } else if !root.ds[0].mut {\n-            let name = alt root.ds[0].kind {\n-              mut::unbox. { ~\"immutable box\" }\n-              mut::field. { ~\"immutable field\" }\n-              mut::index. { ~\"immutable vec content\" }\n-            };\n+            let name =\n+                alt root.ds[0].kind {\n+                  mut::unbox. { \"immutable box\" }\n+                  mut::field. { \"immutable field\" }\n+                  mut::index. { \"immutable vec content\" }\n+                };\n             mk_err(cx, dest.span, msg, name);\n         }\n       }\n@@ -209,25 +208,27 @@ fn check_move_rhs(cx: &@ctx, src: &@expr) {\n       expr_path(p) {\n         alt cx.tcx.def_map.get(src.id) {\n           def_obj_field(_, _) {\n-            mk_err(cx, src.span, msg_move_out, ~\"object field\");\n+            mk_err(cx, src.span, msg_move_out, \"object field\");\n           }\n           _ { }\n         }\n         check_lval(cx, src, msg_move_out);\n       }\n       _ {\n         let root = expr_root(cx.tcx, src, false);\n+\n         // Not a path and no-derefs means this is a temporary.\n         if vec::len(*root.ds) != 0u {\n-            cx.tcx.sess.span_err(src.span, ~\"moving out of a data structure\");\n+            cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n         }\n       }\n     }\n }\n \n fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n-    let arg_ts = ty::ty_fn_args(cx.tcx, ty::type_autoderef\n-                                (cx.tcx, ty::expr_ty(cx.tcx, f)));\n+    let arg_ts =\n+        ty::ty_fn_args(cx.tcx,\n+                       ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f)));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         if arg_t.mode == ty::mo_alias(true) {\n@@ -237,17 +238,18 @@ fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n     }\n }\n \n-fn is_immutable_def(def: &def) -> option::t<istr> {\n+fn is_immutable_def(def: &def) -> option::t<str> {\n     alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n-      def_use(_) { some(~\"static item\") }\n-      def_obj_field(_, imm.) { some(~\"immutable object field\") }\n-      def_arg(_, alias(false)) { some(~\"immutable alias\") }\n+      def_use(_) {\n+        some(\"static item\")\n+      }\n+      def_obj_field(_, imm.) { some(\"immutable object field\") }\n+      def_arg(_, alias(false)) { some(\"immutable alias\") }\n       def_upvar(_, inner, mut) {\n-        if !mut { some(~\"upvar\") }\n-        else { is_immutable_def(*inner) }\n+        if !mut { some(\"upvar\") } else { is_immutable_def(*inner) }\n       }\n-      def_binding(_) { some(~\"binding\") }\n+      def_binding(_) { some(\"binding\") }\n       _ { none }\n     }\n }"}, {"sha": "a08458f910d8d6a200ab0f969058fa6052f28fc2", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 99, "deletions": 110, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -74,10 +74,10 @@ tag import_state {\n              option::t<def>); /* module */\n }\n \n-type ext_hash = hashmap<{did: def_id, ident: istr, ns: namespace}, def>;\n+type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n-    type key = {did: def_id, ident: istr, ns: namespace};\n+    type key = {did: def_id, ident: str, ns: namespace};\n     fn hash(v: &key) -> uint {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n@@ -110,7 +110,7 @@ type indexed_mod =\n     {m: option::t<ast::_mod>,\n      index: mod_index,\n      mutable glob_imports: [glob_imp_def],\n-     glob_imported_names: hashmap<istr, import_state>};\n+     glob_imported_names: hashmap<str, import_state>};\n \n \n /* native modules can't contain tags, and we don't store their ASTs because we\n@@ -127,7 +127,7 @@ type env =\n      mod_map: hashmap<ast::node_id, @indexed_mod>,\n      ext_map: hashmap<def_id, [ident]>,\n      ext_cache: ext_hash,\n-     mutable reported: [{ident: istr, sc: scope}],\n+     mutable reported: [{ident: str, sc: scope}],\n      sess: session};\n \n \n@@ -242,6 +242,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n         alt vi.node {\n \n \n+\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n@@ -323,8 +324,8 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n               }\n               _ {\n                 e.sess.span_err(p.span,\n-                                ~\"not a tag variant: \" +\n-                                ast_util::path_name(p));\n+                                \"not a tag variant: \" +\n+                                    ast_util::path_name(p));\n               }\n             }\n           }\n@@ -430,8 +431,8 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n           ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n           _ {\n             e.sess.span_err(sp,\n-                            str::connect(path, ~\"::\") +\n-                                ~\" does not name a module.\");\n+                            str::connect(path, \"::\") +\n+                                \" does not name a module.\");\n             ret none;\n           }\n         }\n@@ -448,8 +449,8 @@ fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n           }\n           _ {\n             e.sess.span_err(c.span,\n-                            ~\"Non-predicate in constraint: \" +\n-                            path_to_str(c.node.path));\n+                            \"Non-predicate in constraint: \" +\n+                                path_to_str(c.node.path));\n           }\n         }\n     }\n@@ -475,8 +476,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n             alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n               some(dcur) { dcur }\n               none. {\n-                unresolved_err(e, sc, sp, ids[0],\n-                               ns_name(ns_module));\n+                unresolved_err(e, sc, sp, ids[0], ns_name(ns_module));\n                 remove_if_unresolved(e.imports, defid.node);\n                 ret ()\n               }\n@@ -498,8 +498,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                         {\n                       some(dcur) { dcur }\n                       none. {\n-                        unresolved_err(e, sc, sp, ids[i],\n-                                       ns_name(ns_module));\n+                        unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n                         remove_if_unresolved(e.imports, defid.node);\n                         ret () // FIXME (issue #521)\n                       }\n@@ -512,7 +511,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                 val: &option::t<def>, typ: &option::t<def>,\n                 md: &option::t<def>) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n-            unresolved_err(e, sc, sp, name, ~\"import\");\n+            unresolved_err(e, sc, sp, name, \"import\");\n         } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n     }\n     fn remove_if_unresolved(imports: hashmap<ast::node_id, import_state>,\n@@ -532,16 +531,15 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n \n \n // Utilities\n-fn ns_name(ns: namespace) -> istr {\n+fn ns_name(ns: namespace) -> str {\n     alt ns {\n-      ns_type. { ret ~\"typename\"; }\n-      ns_value. { ret ~\"name\"; }\n-      ns_module. { ret ~\"modulename\"; }\n+      ns_type. { ret \"typename\"; }\n+      ns_value. { ret \"name\"; }\n+      ns_module. { ret \"modulename\"; }\n     }\n }\n \n-fn unresolved_err(e: &env, sc: &scopes, sp: &span,\n-                  name: &ident, kind: &istr) {\n+fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> scope {\n         while true {\n             alt sc {\n@@ -559,19 +557,18 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span,\n         fail;\n     }\n     let err_scope = find_fn_or_mod_scope(sc);\n-    for rs: {ident: istr, sc: scope} in e.reported {\n-        if str::eq(rs.ident, name)\n-            && err_scope == rs.sc { ret; }\n+    for rs: {ident: str, sc: scope} in e.reported {\n+        if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n     }\n     e.reported += [{ident: name, sc: err_scope}];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n-fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &istr) -> ! {\n+fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n     e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n }\n \n-fn mk_unresolved_msg(id: &ident, kind: &istr) -> istr {\n+fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n     ret #fmt[\"unresolved %s: %s\", kind, id];\n }\n \n@@ -603,8 +600,7 @@ fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n fn lookup_in_scope_strict(e: &env, sc: scopes, sp: &span, name: &ident,\n                           ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n-      none. { unresolved_err(e, sc, sp, name,\n-                             ns_name(ns)); ret none; }\n+      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n@@ -629,10 +625,12 @@ fn scope_closes(sc: &scope) -> option::t<bool> {\n \n fn def_is_local(d: &def) -> bool {\n     ret alt d {\n-      ast::def_arg(_, _) | ast::def_local(_) | ast::def_binding(_) |\n-      ast::def_upvar(_, _, _) { true }\n-      _ { false }\n-    };\n+          ast::def_arg(_, _) | ast::def_local(_) | ast::def_binding(_) |\n+          ast::def_upvar(_, _, _) {\n+            true\n+          }\n+          _ { false }\n+        };\n }\n \n fn def_is_obj_field(d: &def) -> bool {\n@@ -715,24 +713,23 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n             if !is_none(fnd) {\n                 let df = option::get(fnd);\n                 let local = def_is_local(df);\n-                if left_fn && local ||\n-                       left_fn_level2 && def_is_obj_field(df) ||\n-                       scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n-                    let msg = alt ns {\n-                      ns_type. {\n-                        ~\"Attempt to use a type argument out of scope\"\n-                      }\n-                      _ {\n-                        ~\"attempted dynamic environment-capture\"\n-                      }\n-                    };\n+                if left_fn && local || left_fn_level2 && def_is_obj_field(df)\n+                       || scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n+                    let msg =\n+                        alt ns {\n+                          ns_type. {\n+                            \"Attempt to use a type argument out of scope\"\n+                          }\n+                          _ { \"attempted dynamic environment-capture\" }\n+                        };\n                     e.sess.span_fatal(sp, msg);\n                 } else if local {\n                     let i = vec::len(closing);\n                     while i > 0u {\n                         i -= 1u;\n-                        df = ast::def_upvar(ast_util::def_id_of_def(df),\n-                                            @df, closing[i]);\n+                        df =\n+                            ast::def_upvar(ast_util::def_id_of_def(df), @df,\n+                                           closing[i]);\n                         fnd = some(df);\n                     }\n                 }\n@@ -742,16 +739,13 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n                 left_fn_level2 = true;\n             } else if ns == ns_value || ns == ns_type {\n                 left_fn = scope_is_fn(hd);\n-                alt scope_closes(hd) {\n-                  some(mut) { closing += [mut]; }\n-                  _ {}\n-                }\n+                alt scope_closes(hd) { some(mut) { closing += [mut]; } _ { } }\n             }\n             sc = *tl;\n           }\n         }\n     }\n-    e.sess.bug(~\"reached unreachable code in lookup_in_scope\"); // sigh\n+    e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n \n }\n \n@@ -912,8 +906,7 @@ fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n                         ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n-      none. { unresolved_err(e, sc, sp, name,\n-                             ns_name(ns)); ret none; }\n+      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n@@ -924,15 +917,13 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n     if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n \n-        let cached = e.ext_cache.find({did: defid,\n-                                       ident: name, ns: ns});\n+        let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n         if !is_none(cached) { ret cached; }\n         let path = [name];\n         if defid.node != -1 { path = e.ext_map.get(defid) + path; }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n-            e.ext_cache.insert({did: defid,\n-                                ident: name, ns: ns},\n+            e.ext_cache.insert({did: defid, ident: name, ns: ns},\n                                option::get(fnd));\n         }\n         ret fnd;\n@@ -962,7 +953,7 @@ fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n         resolve_import(e, local_def(node_id), name, path, span, scopes);\n         ret lookup_import(e, defid, ns);\n       }\n-      resolving(sp) { e.sess.span_err(sp, ~\"cyclic import\"); ret none; }\n+      resolving(sp) { e.sess.span_err(sp, \"cyclic import\"); ret none; }\n       resolved(val, typ, md) {\n         ret alt ns { ns_value. { val } ns_type. { typ } ns_module. { md } };\n       }\n@@ -1026,13 +1017,11 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         } else {\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n-                e.sess.span_note(\n-                    sp, #fmt[\"'%s' is imported here\", id]);\n+                e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n             }\n             e.sess.span_fatal(sp,\n-                              ~\"'\" + id\n-                              + ~\"' is glob-imported from\" +\n-                                  ~\" multiple different modules.\");\n+                              \"'\" + id + \"' is glob-imported from\" +\n+                                  \" multiple different modules.\");\n         }\n     }\n     // since we don't know what names we have in advance,\n@@ -1043,11 +1032,10 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         let val = per_ns(e, info, sp, id, ns_value, dr);\n         let typ = per_ns(e, info, sp, id, ns_type, dr);\n         let md = per_ns(e, info, sp, id, ns_module, dr);\n-        info.glob_imported_names.insert(id,\n-                                        resolved(val, typ, md));\n+        info.glob_imported_names.insert(id, resolved(val, typ, md));\n     }\n     alt info.glob_imported_names.get(id) {\n-      todo(_, _, _, _, _) { e.sess.bug(~\"Shouldn't've put a todo in.\"); }\n+      todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n       resolving(sp) {\n         ret none::<def>; //circularity is okay in import globs\n \n@@ -1101,11 +1089,10 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n \n \n // Module indexing\n-fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>,\n-                id: &ident, ent: &mod_index_entry) {\n+fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>, id: &ident,\n+                ent: &mod_index_entry) {\n     alt index.find(id) {\n-      none. { index.insert(id,\n-                           cons(ent, @nil::<mod_index_entry>)); }\n+      none. { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n       some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n@@ -1119,11 +1106,13 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n           }\n \n \n+\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n           }\n \n \n+\n           ast::view_item_import_from(_, idents, _) {\n             for ident in idents {\n                 add_to_index(index, ident.node.name,\n@@ -1132,6 +1121,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n           }\n \n \n+\n           //globbed imports have to be resolved lazily.\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {\n           }\n@@ -1238,26 +1228,25 @@ fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     let saw_mod = false;\n     let saw_type = false;\n     let saw_value = false;\n-    fn dup(e: &env, sp: &span, word: &istr, name: &ident) {\n-        e.sess.span_fatal(sp, ~\"duplicate definition of \" +\n-                          word + name);\n+    fn dup(e: &env, sp: &span, word: &str, name: &ident) {\n+        e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n     while true {\n         alt entries {\n           cons(entry, rest) {\n             if !is_none(lookup_in_mie(e, entry, ns_value)) {\n                 if saw_value {\n-                    dup(e, mie_span(entry), ~\"\", name);\n+                    dup(e, mie_span(entry), \"\", name);\n                 } else { saw_value = true; }\n             }\n             if !is_none(lookup_in_mie(e, entry, ns_type)) {\n                 if saw_type {\n-                    dup(e, mie_span(entry), ~\"type \", name);\n+                    dup(e, mie_span(entry), \"type \", name);\n                 } else { saw_type = true; }\n             }\n             if !is_none(lookup_in_mie(e, entry, ns_module)) {\n                 if saw_mod {\n-                    dup(e, mie_span(entry), ~\"module \", name);\n+                    dup(e, mie_span(entry), \"module \", name);\n                 } else { saw_mod = true; }\n             }\n             entries = *rest;\n@@ -1288,20 +1277,20 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n       ast::item_fn(f, ty_params) {\n         check_fn(*e, i.span, f);\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      ~\"type parameter\");\n+                      \"type parameter\");\n       }\n       ast::item_obj(ob, ty_params, _) {\n         fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n-        ensure_unique(*e, i.span, ob.fields, field_name, ~\"object field\");\n+        ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n         for m: @ast::method in ob.methods {\n             check_fn(*e, m.span, m.node.meth);\n         }\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      ~\"type parameter\");\n+                      \"type parameter\");\n       }\n       ast::item_tag(_, ty_params) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      ~\"type parameter\");\n+                      \"type parameter\");\n       }\n       _ { }\n     }\n@@ -1316,28 +1305,28 @@ fn check_pat(ch: checker, p: &@ast::pat) {\n \n fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n     visit::visit_arm(a, x, v);\n-    let ch0 = checker(*e, ~\"binding\");\n+    let ch0 = checker(*e, \"binding\");\n     check_pat(ch0, a.pats[0]);\n     let seen0 = ch0.seen;\n     let i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n-        let ch = checker(*e, ~\"binding\");\n+        let ch = checker(*e, \"binding\");\n         check_pat(ch, a.pats[i]);\n \n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n         if vec::len(ch.seen) != vec::len(seen0) {\n             e.sess.span_err(a.pats[i].span,\n-                            ~\"inconsistent number of bindings\");\n+                            \"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n                 if is_none(vec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n-                                    ~\"binding \" + name_ +\n-                                        ~\" does not occur in first pattern\");\n+                                    \"binding \" + name_ +\n+                                        \" does not occur in first pattern\");\n                 }\n             }\n         }\n@@ -1346,15 +1335,15 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n \n fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n     visit::visit_block(b, x, v);\n-    let values = checker(*e, ~\"value\");\n-    let types = checker(*e, ~\"type\");\n-    let mods = checker(*e, ~\"module\");\n+    let values = checker(*e, \"value\");\n+    let types = checker(*e, \"type\");\n+    let mods = checker(*e, \"module\");\n     for st: @ast::stmt in b.node.stmts {\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n-                let local_values = checker(*e, ~\"value\");\n+                let local_values = checker(*e, \"value\");\n                 for loc in locs {\n                     for each p in ast_util::pat_bindings(loc.node.pat) {\n                         let ident = alt p.node { pat_bind(n) { n } };\n@@ -1394,14 +1383,14 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n \n fn check_fn(e: &env, sp: &span, f: &ast::_fn) {\n     fn arg_name(a: &ast::arg) -> ident { ret a.ident; }\n-    ensure_unique(e, sp, f.decl.inputs, arg_name, ~\"argument\");\n+    ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt<()>) {\n     alt ex.node {\n       ast::expr_rec(fields, _) {\n         fn field_name(f: &ast::field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ex.span, fields, field_name, ~\"field\");\n+        ensure_unique(*e, ex.span, fields, field_name, \"field\");\n       }\n       _ { }\n     }\n@@ -1412,25 +1401,24 @@ fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n     alt ty.node {\n       ast::ty_rec(fields) {\n         fn field_name(f: &ast::ty_field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ty.span, fields, field_name, ~\"field\");\n+        ensure_unique(*e, ty.span, fields, field_name, \"field\");\n       }\n       _ { }\n     }\n     visit::visit_ty(ty, x, v);\n }\n \n-type checker = @{mutable seen: [ident], kind: istr, sess: session};\n+type checker = @{mutable seen: [ident], kind: str, sess: session};\n \n-fn checker(e: &env, kind: &istr) -> checker {\n+fn checker(e: &env, kind: &str) -> checker {\n     let seen: [ident] = [];\n     ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n fn check_name(ch: &checker, sp: &span, name: &ident) {\n     for s: ident in ch.seen {\n         if str::eq(s, name) {\n-            ch.sess.span_fatal(sp, ~\"duplicate \" + ch.kind\n-                               + ~\" name: \" + name);\n+            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n     }\n }\n@@ -1442,41 +1430,42 @@ fn add_name(ch: &checker, sp: &span, name: &ident) {\n fn ident_id(i: &ident) -> ident { ret i; }\n \n fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident,\n-                    kind: &istr) {\n+                    kind: &str) {\n     let ch = checker(e, kind);\n     for elt: T in elts { add_name(ch, sp, id(elt)); }\n }\n \n fn check_bad_exports(e: &@env) {\n-    fn lookup_glob_any(e: &env, info: &@indexed_mod, sp: &span,\n-                       ident: &ident) -> bool {\n-        ret !option::is_none(lookup_glob_in_mod(e, info, sp, ident,\n-                                                ns_module, inside)) ||\n-            !option::is_none(lookup_glob_in_mod(e, info, sp, ident,\n-                                                ns_value, inside)) ||\n-            !option::is_none(lookup_glob_in_mod(e, info, sp, ident,\n-                                                ns_type, inside));\n+    fn lookup_glob_any(e: &env, info: &@indexed_mod, sp: &span, ident: &ident)\n+       -> bool {\n+        ret !option::is_none(lookup_glob_in_mod(e, info, sp, ident, ns_module,\n+                                                inside)) ||\n+                !option::is_none(lookup_glob_in_mod(e, info, sp, ident,\n+                                                    ns_value, inside)) ||\n+                !option::is_none(lookup_glob_in_mod(e, info, sp, ident,\n+                                                    ns_type, inside));\n     }\n \n-    for each @{val, _} in e.mod_map.items() {\n+    for each @{val: val, _} in e.mod_map.items() {\n         alt val.m {\n           some(m) {\n             for vi in m.view_items {\n                 alt vi.node {\n                   ast::view_item_export(idents, _) {\n                     for ident in idents {\n                         if !val.index.contains_key(ident) &&\n-                           !lookup_glob_any(*e, val, vi.span, ident) {\n-                            e.sess.span_warn(vi.span, ~\"exported item \" +\n-                                             ident + ~\" is not defined\");\n+                               !lookup_glob_any(*e, val, vi.span, ident) {\n+                            e.sess.span_warn(vi.span,\n+                                             \"exported item \" + ident +\n+                                                 \" is not defined\");\n                         }\n                     }\n                   }\n-                  _ {}\n+                  _ { }\n                 }\n             }\n           }\n-          none. {}\n+          none. { }\n         }\n     }\n }"}, {"sha": "080018df961b655989a646341e07fa9e8f37332f", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -84,15 +84,18 @@ fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx: &@crate_ctxt, name: &istr, llval: ValueRef,\n-             internal: bool) -> ValueRef {\n-    let llglobal = str::as_buf(name, { |buf|\n-        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n-    });\n+fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef, internal: bool)\n+   -> ValueRef {\n+    let llglobal =\n+        str::as_buf(name,\n+                    {|buf|\n+                        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod,\n+                                                       val_ty(llval), buf)\n+                    });\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n     lib::llvm::llvm::LLVMSetGlobalConstant(llglobal, True);\n \n-    if (internal) {\n+    if internal {\n         lib::llvm::llvm::LLVMSetLinkage(llglobal,\n                                         lib::llvm::LLVMInternalLinkage as\n                                             lib::llvm::llvm::Linkage);\n@@ -256,10 +259,13 @@ fn s_float(_tcx: &ty_ctxt) -> u8 {\n }\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n-    let llshapetablesty = trans_common::T_named_struct(~\"shapes\");\n-    let llshapetables = str::as_buf(~\"shapes\", { |buf|\n-        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n-    });\n+    let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n+    let llshapetables =\n+        str::as_buf(\"shapes\",\n+                    {|buf|\n+                        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty,\n+                                                       buf)\n+                    });\n \n     ret {mutable next_tag_id: 0u16,\n          pad: 0u16,\n@@ -292,17 +298,20 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       }\n \n \n+\n       ty::ty_int. {\n         s += [s_int(ccx.tcx)];\n       }\n       ty::ty_float. { s += [s_float(ccx.tcx)]; }\n \n \n+\n       ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n         s += [s_uint(ccx.tcx)];\n       }\n \n \n+\n       ty::ty_machine(ast::ty_i8.) {\n         s += [shape_i8];\n       }\n@@ -314,13 +323,15 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       ty::ty_machine(ast::ty_i64.) { s += [shape_i64]; }\n \n \n-      ty::ty_istr. {\n+\n+      ty::ty_str. {\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n       }\n \n+\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n           tk_unit. {\n@@ -358,6 +369,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       }\n \n \n+\n       ty::ty_box(mt) {\n         s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n@@ -387,13 +399,15 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       }\n \n \n+\n       ty::ty_fn(_, _, _, _, _) {\n         s += [shape_fn];\n       }\n       ty::ty_native_fn(_, _, _) { s += [shape_u32]; }\n       ty::ty_obj(_) { s += [shape_obj]; }\n \n \n+\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, t: subt};\n@@ -409,39 +423,37 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n       }\n \n+\n       ty::ty_var(n) {\n         fail \"shape_of ty_var\";\n       }\n \n+\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n         let found = false;\n         let i = 0u;\n-        while (i < vec::len(ty_param_map)) {\n+        while i < vec::len(ty_param_map) {\n             if n == ty_param_map[i] {\n                 s += [shape_var, i as u8];\n                 found = true;\n                 break;\n             }\n             i += 1u;\n         }\n-        assert found;\n+        assert (found);\n       }\n     }\n \n     ret s;\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx: &@crate_ctxt,\n-                    v: &ty::variant_info,\n+fn shape_of_variant(ccx: &@crate_ctxt, v: &ty::variant_info,\n                     ty_param_count: uint) -> [u8] {\n     let ty_param_map = [];\n     let i = 0u;\n-    while (i < ty_param_count) {\n-        ty_param_map += [i];\n-        i += 1u;\n-    }\n+    while i < ty_param_count { ty_param_map += [i]; i += 1u; }\n \n     let s = [];\n     for t: ty::t in v.args { s += shape_of(ccx, t, ty_param_map); }\n@@ -540,7 +552,7 @@ fn gen_tag_shapes(ccx: &@crate_ctxt) -> ValueRef {\n     header += data;\n     header += lv_table;\n \n-    ret mk_global(ccx, ~\"tag_shapes\", C_bytes(header), true);\n+    ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n }\n \n fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n@@ -553,7 +565,7 @@ fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n         i += 1u;\n     }\n \n-    ret mk_global(ccx, ~\"resource_shapes\", C_struct(dtors), true);\n+    ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n \n fn gen_shape_tables(ccx: &@crate_ctxt) {"}, {"sha": "a81f910a9469f710e182bd00e62886196beeee21", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 601, "deletions": 666, "changes": 1267, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "5bb5afacb29f517f397844b848252558f98115ef", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -57,7 +57,7 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n-fn assoc(key: &istr, list: &bind_map) -> option::t<ValueRef> {\n+fn assoc(key: &str, list: &bind_map) -> option::t<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n         if str::eq(elt.ident, key) { ret some(elt.val); }\n     }\n@@ -67,9 +67,10 @@ fn assoc(key: &istr, list: &bind_map) -> option::t<ValueRef> {\n type match_branch =\n     @{pats: [@ast::pat],\n       bound: bind_map,\n-      data: @{body: BasicBlockRef,\n-              guard: option::t<@ast::expr>,\n-              id_map: ast_util::pat_id_map}};\n+      data:\n+          @{body: BasicBlockRef,\n+            guard: option::t<@ast::expr>,\n+            id_map: ast_util::pat_id_map}};\n type match = [match_branch];\n \n fn matches_always(p: &@ast::pat) -> bool {\n@@ -89,16 +90,18 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n     for br: match_branch in m {\n         alt e(br.pats[col]) {\n           some(sub) {\n-            let pats = vec::slice(br.pats, 0u, col) + sub +\n+            let pats =\n+                vec::slice(br.pats, 0u, col) + sub +\n                     vec::slice(br.pats, col + 1u, vec::len(br.pats));\n-            let new_br = @{pats: pats,\n-                           bound: alt br.pats[col].node {\n-                             ast::pat_bind(name) {\n-                               br.bound + [{ident: name, val: val}]\n-                             }\n-                             _ { br.bound }\n-                           }\n-                           with *br};\n+            let new_br =\n+                @{pats: pats,\n+                  bound:\n+                      alt br.pats[col].node {\n+                        ast::pat_bind(name) {\n+                          br.bound + [{ident: name, val: val}]\n+                        }\n+                        _ { br.bound }\n+                      } with *br};\n             result += [new_br];\n           }\n           none. { }\n@@ -211,15 +214,14 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n-            PointerCast(bcx, val,\n-                                  trans_common::T_opaque_tag_ptr(ccx.tn));\n+            PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx.tn));\n         blobptr = GEP(bcx, tagptr, [C_int(0), C_int(1)]);\n     }\n     let i = 0u;\n     let vdefs_tg = vdefs.tg;\n     let vdefs_var = vdefs.var;\n     while i < size {\n-        check valid_variant_index(i, bcx, vdefs_tg, vdefs_var);\n+        check (valid_variant_index(i, bcx, vdefs_tg, vdefs_var));\n         let r =\n             trans::GEP_tag(bcx, blobptr, vdefs_tg, vdefs_var, ty_param_substs,\n                            i);\n@@ -298,26 +300,25 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n-            let guard_cx = new_scope_block_ctxt(bcx, ~\"submatch_guard\");\n-            let next_cx = new_sub_block_ctxt(bcx, ~\"submatch_next\");\n-            let else_cx = new_sub_block_ctxt(bcx, ~\"submatch_else\");\n+            let guard_cx = new_scope_block_ctxt(bcx, \"submatch_guard\");\n+            let next_cx = new_sub_block_ctxt(bcx, \"submatch_next\");\n+            let else_cx = new_sub_block_ctxt(bcx, \"submatch_else\");\n             Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n-            for each @{key, val} in data.id_map.items() {\n-                bcx.fcx.lllocals.insert\n-                    (val, option::get(assoc(key,\n-                                            m[0].bound)));\n+            for each @{key: key, val: val} in data.id_map.items() {\n+                bcx.fcx.lllocals.insert(val,\n+                                        option::get(assoc(key, m[0].bound)));\n             }\n             let {bcx: guard_bcx, val: guard_val} =\n                 trans::trans_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n             CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n-            compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)),\n-                             vals, f, exits);\n+            compile_submatch(else_cx, vec::slice(m, 1u, vec::len(m)), vals, f,\n+                             exits);\n             bcx = next_cx;\n           }\n-          _ {}\n+          _ { }\n         }\n         exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n         Br(bcx, data.body);\n@@ -380,8 +381,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let box = Load(bcx, val);\n         let unboxed =\n             InBoundsGEP(bcx, box,\n-                                  [C_int(0),\n-                                   C_int(back::abi::box_rc_field_body)]);\n+                        [C_int(0), C_int(back::abi::box_rc_field_body)]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n                          f, exits);\n         ret;\n@@ -400,7 +400,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             } else {\n                 let tagptr =\n                     PointerCast(bcx, val,\n-                        trans_common::T_opaque_tag_ptr(ccx.tn));\n+                                trans_common::T_opaque_tag_ptr(ccx.tn));\n                 let discrimptr = GEP(bcx, tagptr, [C_int(0), C_int(0)]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n@@ -415,7 +415,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     let else_cx =\n         alt kind {\n           no_branch. | single. { bcx }\n-          _ { new_sub_block_ctxt(bcx, ~\"match_else\") }\n+          _ { new_sub_block_ctxt(bcx, \"match_else\") }\n         };\n     let sw =\n         if kind == switch {\n@@ -424,7 +424,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n-        let opt_cx = new_sub_block_ctxt(bcx, ~\"match_case\");\n+        let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n         alt kind {\n           single. { Br(bcx, opt_cx.llbb); }\n           switch. {\n@@ -433,7 +433,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n           }\n           compare. {\n-            let compare_cx = new_scope_block_ctxt(bcx, ~\"compare_scope\");\n+            let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n             Br(bcx, compare_cx.llbb);\n             bcx = compare_cx;\n             let r = trans_opt(bcx, opt);\n@@ -442,7 +442,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let eq =\n                 trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n             let cleanup_cx = trans::trans_block_cleanups(bcx, compare_cx);\n-            bcx = new_sub_block_ctxt(bcx, ~\"compare_next\");\n+            bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n             CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n@@ -509,15 +509,14 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     }\n \n     for a: ast::arm in arms {\n-        let body = new_scope_block_ctxt(cx, ~\"case_body\");\n+        let body = new_scope_block_ctxt(cx, \"case_body\");\n         let id_map = ast_util::pat_id_map(a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {\n-            match += [@{pats: [p],\n-                        bound: [],\n-                        data: @{body: body.llbb,\n-                                guard: a.guard,\n-                                id_map: id_map}}];\n+            match +=\n+                [@{pats: [p],\n+                   bound: [],\n+                   data: @{body: body.llbb, guard: a.guard, id_map: id_map}}];\n         }\n     }\n \n@@ -526,8 +525,8 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     fn mk_fail(cx: &@block_ctxt, sp: &span,\n                done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n-        let fail_cx = new_sub_block_ctxt(cx, ~\"case_fallthrough\");\n-        trans::trans_fail(fail_cx, some(sp), ~\"non-exhaustive match failure\");\n+        let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n+        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }\n@@ -568,8 +567,9 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n             check type_has_static_size(ccx, ty);\n             let llty = trans::type_of(ccx, pat.span, ty);\n             let alloc = trans::alloca(bcx, llty);\n-            bcx = trans::copy_val(bcx, trans::INIT, alloc,\n-                                  trans::load_if_immediate(bcx, val, ty), ty);\n+            bcx =\n+                trans::copy_val(bcx, trans::INIT, alloc,\n+                                trans::load_if_immediate(bcx, val, ty), ty);\n             table.insert(pat.id, alloc);\n             trans_common::add_clean(bcx, alloc, ty);\n         } else { table.insert(pat.id, val); }\n@@ -606,9 +606,9 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n       }\n       ast::pat_box(inner) {\n         let box = Load(bcx, val);\n-        let unboxed = InBoundsGEP(bcx, box,\n-                                  [C_int(0),\n-                                   C_int(back::abi::box_rc_field_body)]);\n+        let unboxed =\n+            InBoundsGEP(bcx, box,\n+                        [C_int(0), C_int(back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, table, true);\n       }\n       ast::pat_wild. | ast::pat_lit(_) { }"}, {"sha": "52b976e284455b46729d732b813ffcb84349e40a", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 226, "deletions": 291, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,8 +1,8 @@\n import std::{vec, str};\n import std::str::sbuf;\n import lib::llvm::llvm;\n-import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n-              Opcode, ModuleRef};\n+import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n+              ModuleRef};\n import trans_common::block_ctxt;\n \n fn B(cx: &@block_ctxt) -> BuilderRef {\n@@ -12,472 +12,398 @@ fn B(cx: &@block_ctxt) -> BuilderRef {\n }\n \n fn RetVoid(cx: &@block_ctxt) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildRet(B(cx), V);\n }\n \n fn AggregateRet(cx: &@block_ctxt, RetVals: &[ValueRef]) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n                                     vec::len(RetVals));\n }\n \n fn Br(cx: &@block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n fn CondBr(cx: &@block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n-fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef,\n-          NumCases: uint) -> ValueRef {\n-    assert (!cx.terminated);;\n+fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+   -> ValueRef {\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n }\n \n-fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef,\n-              NumDests: uint) -> ValueRef {\n-    assert (!cx.terminated);;\n+fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef, NumDests: uint) -> ValueRef {\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                                              vec::len(Args), Then, Catch,\n+                                              buf)\n+                    });\n }\n \n fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n-    assert (!cx.terminated);;\n+    assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildUnreachable(B(cx));\n }\n \n /* Arithmetic */\n fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf) });\n }\n \n fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSub(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSub(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf) });\n }\n \n fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf) });\n }\n \n fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildMul(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMul(B(cx), LHS, RHS, buf) });\n }\n \n fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf) });\n }\n \n fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf) });\n }\n \n fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf) });\n }\n \n fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf) });\n }\n \n fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildURem(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildURem(B(cx), LHS, RHS, buf) });\n }\n \n fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf) });\n }\n \n fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf) });\n }\n \n fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildShl(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildShl(B(cx), LHS, RHS, buf) });\n }\n \n fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf) });\n }\n \n fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf) });\n }\n \n fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf) });\n }\n \n fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildOr(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildOr(B(cx), LHS, RHS, buf) });\n }\n \n fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildXor(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildXor(B(cx), LHS, RHS, buf) });\n }\n \n-fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n-         RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf)\n-    });\n+fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf) });\n }\n \n fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNeg(B(cx), V, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNeg(B(cx), V, buf) });\n }\n \n fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWNeg(B(cx), V, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWNeg(B(cx), V, buf) });\n }\n \n fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWNeg(B(cx), V, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWNeg(B(cx), V, buf) });\n }\n fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFNeg(B(cx), V, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFNeg(B(cx), V, buf) });\n }\n \n fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNot(B(cx), V, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNot(B(cx), V, buf) });\n }\n \n /* Memory */\n fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildMalloc(B(cx), Ty, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMalloc(B(cx), Ty, buf) });\n }\n \n fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf) });\n }\n \n fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAlloca(B(cx), Ty, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAlloca(B(cx), Ty, buf) });\n }\n \n fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf) });\n }\n \n fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildLoad(B(cx), PointerVal, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLoad(B(cx), PointerVal, buf) });\n }\n \n fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n-fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n-       Indices: &[ValueRef]) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                           vec::len(Indices), buf)\n-    });\n+fn GEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildGEP(B(cx), Pointer,\n+                                           vec::to_ptr(Indices),\n+                                           vec::len(Indices), buf)\n+                    });\n }\n \n-fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n-               Indices: &[ValueRef]) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                                   vec::len(Indices), buf)\n-    });\n+fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+                                                   vec::to_ptr(Indices),\n+                                                   vec::len(Indices), buf)\n+                    });\n }\n \n fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n+                    });\n }\n \n fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGlobalString(B(cx), _Str, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildGlobalString(B(cx), _Str, buf) });\n }\n \n fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n+                    });\n }\n \n /* Casts */\n fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf) });\n }\n \n fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf) });\n }\n \n fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf) });\n }\n \n fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf) });\n }\n \n fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf) });\n }\n \n fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf) });\n }\n \n fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf) });\n }\n \n fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf) });\n }\n \n fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf) });\n }\n \n-fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n-            DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n-    });\n+fn PtrToInt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n-fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n-            DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n-    });\n+fn IntToPtr(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf) });\n }\n \n-fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n-                 DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n-    });\n+fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n-fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n-                 DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n-    });\n+fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n-fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n-                  DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n-    });\n+fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n-fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n-        DestTy: TypeRef, _Name: sbuf) ->\n-    ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n-    });\n+fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n+        _Name: sbuf) -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n+                    });\n }\n \n fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n+                    });\n }\n \n fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf) });\n }\n \n fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf) });\n }\n \n \n /* Comparisons */\n-fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n-        RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf)\n-    });\n+fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf) });\n }\n \n-fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n-        RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf)\n-    });\n+fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf) });\n }\n \n \n /* Miscellaneous instructions */\n fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n        bbs: &[BasicBlockRef]) -> ValueRef {\n-    let phi = str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPhi(B(cx), Ty, buf)\n-    });\n+    let phi = str::as_buf(\"\", {|buf| llvm::LLVMBuildPhi(B(cx), Ty, buf) });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n@@ -491,108 +417,117 @@ fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n }\n \n fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                            vec::len(Args), buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                            vec::len(Args), buf)\n+                    });\n }\n \n fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    let v = str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n-    });\n+    let v =\n+        str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                            vec::len(Args), buf)\n+                    });\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n     ret v;\n }\n \n-fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n-                Conv: uint) -> ValueRef {\n-    let v = str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n-    });\n+fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef], Conv: uint)\n+   -> ValueRef {\n+    let v =\n+        str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                            vec::len(Args), buf)\n+                    });\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n     ret v;\n }\n \n-fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n-          Else: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n-    });\n+fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n+                    });\n }\n \n fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildVAArg(B(cx), list, Ty, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildVAArg(B(cx), list, Ty, buf) });\n }\n \n-fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n-                  Index: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, buf)\n-    });\n+fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n+   ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildExtractElement(B(cx), VecVal, Index,\n+                                                      buf)\n+                    });\n }\n \n fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n-                 Index: ValueRef) ->\n-    ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, buf)\n-    });\n+                 Index: ValueRef) -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal,\n+                                                     Index, buf)\n+                    });\n }\n \n-fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n-                 Mask: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n-    });\n+fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef, Mask: ValueRef)\n+   -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n+                    });\n }\n \n fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n+                    });\n }\n \n-fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n-               EltVal: ValueRef, Index: uint) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, buf)\n-    });\n+fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n+               Index: uint) -> ValueRef {\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal,\n+                                                   Index, buf)\n+                    });\n }\n \n fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIsNull(B(cx), Val, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNull(B(cx), Val, buf) });\n }\n \n fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIsNotNull(B(cx), Val, buf)\n-    });\n+    ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNotNull(B(cx), Val, buf) });\n }\n \n fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf| llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf) });\n }\n \n fn Trap(cx: &@block_ctxt) -> ValueRef {\n     let b = B(cx);\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef = str::as_buf(~\"llvm.trap\", { |buf|\n-        llvm::LLVMGetNamedFunction(M, buf)\n-    });\n+    let T: ValueRef =\n+        str::as_buf(\"llvm.trap\", {|buf| llvm::LLVMGetNamedFunction(M, buf) });\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    ret str::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), buf)\n-    });\n+    ret str::as_buf(\"\",\n+                    {|buf|\n+                        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n+                                            vec::len(Args), buf)\n+                    });\n }\n \n //"}, {"sha": "2943edd43338d12e3d42dd9fac064e64f375982f", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 85, "deletions": 96, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -62,9 +62,7 @@ import trans::type_of_fn_full;\n import trans::drop_ty;\n \n obj namegen(mutable i: int) {\n-    fn next(prefix: &istr) -> istr {\n-        i += 1; ret prefix + int::str(i);\n-    }\n+    fn next(prefix: &str) -> str { i += 1; ret prefix + int::str(i); }\n }\n \n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n@@ -109,11 +107,9 @@ type stats =\n      mutable n_glues_created: uint,\n      mutable n_null_glues: uint,\n      mutable n_real_glues: uint,\n-     fn_times: @mutable [{ident: istr, time: int}]};\n+     fn_times: @mutable [{ident: str, time: int}]};\n \n-resource BuilderRef_res(B: llvm::BuilderRef) {\n-    llvm::LLVMDisposeBuilder(B);\n-}\n+resource BuilderRef_res(B: llvm::BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n@@ -125,27 +121,27 @@ type crate_ctxt =\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n-     externs: hashmap<istr, ValueRef>,\n-     intrinsics: hashmap<istr, ValueRef>,\n+     externs: hashmap<str, ValueRef>,\n+     intrinsics: hashmap<str, ValueRef>,\n      item_ids: hashmap<ast::node_id, ValueRef>,\n      ast_map: ast_map::map,\n-     item_symbols: hashmap<ast::node_id, istr>,\n+     item_symbols: hashmap<ast::node_id, str>,\n      mutable main_fn: option::t<ValueRef>,\n      link_meta: link::link_meta,\n      tag_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::node_id, ValueRef>,\n-     discrim_symbols: hashmap<ast::node_id, istr>,\n+     discrim_symbols: hashmap<ast::node_id, str>,\n      fn_pairs: hashmap<ast::node_id, ValueRef>,\n      consts: hashmap<ast::node_id, ValueRef>,\n      obj_methods: hashmap<ast::node_id, ()>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n-     module_data: hashmap<istr, ValueRef>,\n+     module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      glues: @glue_fns,\n      names: namegen,\n      sha: std::sha1::sha1,\n-     type_sha1s: hashmap<ty::t, istr>,\n-     type_short_names: hashmap<ty::t, istr>,\n+     type_sha1s: hashmap<ty::t, str>,\n+     type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n      mut_map: mut::mut_map,\n      stats: stats,\n@@ -158,8 +154,8 @@ type crate_ctxt =\n      gc_cx: gc::ctxt};\n \n type local_ctxt =\n-    {path: [istr],\n-     module_path: [istr],\n+    {path: [str],\n+     module_path: [str],\n      obj_typarams: [ast::ty_param],\n      obj_fields: [ast::obj_field],\n      ccx: @crate_ctxt};\n@@ -302,11 +298,12 @@ fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n     find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, val, ty))];\n }\n fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    fn spill_and_drop(cx: &@block_ctxt, val: ValueRef, ty: ty::t)\n-        -> @block_ctxt {\n+    fn spill_and_drop(cx: &@block_ctxt, val: ValueRef, ty: ty::t) ->\n+       @block_ctxt {\n         let bcx = cx;\n         let r = trans::spill_if_immediate(bcx, val, ty);\n-        let spilled = r.val; bcx = r.bcx;\n+        let spilled = r.val;\n+        bcx = r.bcx;\n         ret drop_ty(bcx, spilled, ty);\n     }\n     find_scope_cx(cx).cleanups +=\n@@ -345,7 +342,7 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n     if did.crate == ast::local_crate {\n         alt ccx.fn_pairs.find(did.node) {\n           some(x) { ret x; }\n-          _ { ccx.tcx.sess.bug(~\"get_res_dtor: can't find resource dtor!\"); }\n+          _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n         }\n     }\n \n@@ -355,9 +352,8 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n                           [{mode: ty::mo_alias(false), ty: inner_t}],\n                           ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n-                                csearch::get_symbol(\n-                                    ccx.sess.get_cstore(),\n-                                    did),\n+                                csearch::get_symbol(ccx.sess.get_cstore(),\n+                                                    did),\n                                 T_fn_pair(*ccx, f_t));\n }\n \n@@ -396,26 +392,24 @@ type block_ctxt =\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n+    // The block pointing to this one in the function's digraph.\n+    // The 'kind' of basic block this is.\n+    // A list of functions that run at the end of translating this\n+    // block, cleaning up any variables that were introduced in the\n+    // block and need to go out of scope at the end of it.\n+    // The source span where this block comes from, for error\n+    // reporting. FIXME this is not currently reliable\n+    // The function context for the function to which this block is\n+    // attached.\n     {llbb: BasicBlockRef,\n      mutable terminated: bool,\n-     // The block pointing to this one in the function's digraph.\n      parent: block_parent,\n-     // The 'kind' of basic block this is.\n      kind: block_kind,\n-     // A list of functions that run at the end of translating this\n-     // block, cleaning up any variables that were introduced in the\n-     // block and need to go out of scope at the end of it.\n      mutable cleanups: [cleanup],\n-     // The source span where this block comes from, for error\n-     // reporting. FIXME this is not currently reliable\n      sp: span,\n-     // The function context for the function to which this block is\n-     // attached.\n      fcx: @fn_ctxt};\n \n-fn is_terminated(cx: &@block_ctxt) -> bool {\n-    ret cx.terminated;\n-}\n+fn is_terminated(cx: &@block_ctxt) -> bool { ret cx.terminated; }\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n@@ -424,23 +418,21 @@ tag block_parent { parent_none; parent_some(@block_ctxt); }\n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n-fn extend_path(cx: @local_ctxt, name: &istr) -> @local_ctxt {\n+fn extend_path(cx: @local_ctxt, name: &str) -> @local_ctxt {\n     ret @{path: cx.path + [name] with *cx};\n }\n \n fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n     ret {bcx: bcx, val: val};\n }\n \n-fn ty_str(tn: type_names, t: TypeRef) -> istr {\n+fn ty_str(tn: type_names, t: TypeRef) -> str {\n     ret lib::llvm::type_to_str(tn, t);\n }\n \n fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n \n-fn val_str(tn: type_names, v: ValueRef) -> istr {\n-    ret ty_str(tn, val_ty(v));\n-}\n+fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n \n // Returns the nth element of the given LLVM structure type.\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n@@ -456,8 +448,8 @@ fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n       parent_none. {\n-        cx.fcx.lcx.ccx.sess.bug(~\"trans::find_scope_cx() \" +\n-                                ~\"called on parentless block_ctxt\");\n+        cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n+                                    \"called on parentless block_ctxt\");\n       }\n     }\n }\n@@ -543,20 +535,16 @@ fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n fn T_struct(elts: &[TypeRef]) -> TypeRef {\n-    ret llvm::LLVMStructType(to_ptr(elts),\n-                             std::vec::len(elts), False);\n+    ret llvm::LLVMStructType(to_ptr(elts), std::vec::len(elts), False);\n }\n \n-fn T_named_struct(name: &istr) -> TypeRef {\n+fn T_named_struct(name: &str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret str::as_buf(name, { |buf|\n-        llvm::LLVMStructCreateNamed(c, buf)\n-    });\n+    ret str::as_buf(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n }\n \n fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n-    llvm::LLVMStructSetBody(t, to_ptr(elts),\n-                            std::vec::len(elts), False);\n+    llvm::LLVMStructSetBody(t, to_ptr(elts), std::vec::len(elts), False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -566,25 +554,25 @@ fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n // existing objects, use ccx.rust_object_type.  Calling\n // T_rust_object() again will return a different one.\n fn T_rust_object() -> TypeRef {\n-    let t = T_named_struct(~\"rust_object\");\n+    let t = T_named_struct(\"rust_object\");\n     let e = T_ptr(T_empty_struct());\n     set_struct_body(t, [e, e]);\n     ret t;\n }\n \n fn T_task() -> TypeRef {\n-    let t = T_named_struct(~\"task\");\n+    let t = T_named_struct(\"task\");\n \n-     // Refcount\n-     // Delegate pointer\n-     // Stack segment pointer\n-     // Runtime SP\n-     // Rust SP\n-     // GC chain\n+    // Refcount\n+    // Delegate pointer\n+    // Stack segment pointer\n+    // Runtime SP\n+    // Rust SP\n+    // GC chain\n \n \n-     // Domain pointer\n-     // Crate cache pointer\n+    // Domain pointer\n+    // Crate cache pointer\n \n     let elems =\n         [T_int(), T_int(), T_int(), T_int(), T_int(), T_int(), T_int(),\n@@ -605,23 +593,23 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n }\n \n fn T_glue_fn(cx: &crate_ctxt) -> TypeRef {\n-    let s = ~\"glue_fn\";\n+    let s = \"glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_cmp_glue_fn(cx: &crate_ctxt) -> TypeRef {\n-    let s = ~\"cmp_glue_fn\";\n+    let s = \"cmp_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_tydesc(taskptr_type: TypeRef) -> TypeRef {\n-    let tydesc = T_named_struct(~\"tydesc\");\n+    let tydesc = T_named_struct(\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n     let glue_fn_ty =\n@@ -652,9 +640,7 @@ fn T_vec(t: TypeRef) -> TypeRef {\n }\n \n // Note that the size of this one is in bytes.\n-fn T_opaque_vec() -> TypeRef {\n-    ret T_vec(T_i8());\n-}\n+fn T_opaque_vec() -> TypeRef { ret T_vec(T_i8()); }\n \n fn T_box(t: TypeRef) -> TypeRef { ret T_struct([T_int(), t]); }\n \n@@ -673,7 +659,7 @@ fn T_taskptr(cx: &crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: &type_names) -> TypeRef {\n-    let s = ~\"typaram\";\n+    let s = \"typaram\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_i8();\n     tn.associate(s, t);\n@@ -692,23 +678,23 @@ fn T_closure_ptr(cx: &crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint)\n }\n \n fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n-    let s = ~\"*closure\";\n+    let s = \"*closure\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_closure_ptr(cx, T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_tag(tn: &type_names, size: uint) -> TypeRef {\n-    let s = ~\"tag_\" + uint::to_str(size, 10u);\n+    let s = \"tag_\" + uint::to_str(size, 10u);\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_struct([T_int(), T_array(T_i8(), size)]);\n     tn.associate(s, t);\n     ret t;\n }\n \n fn T_opaque_tag(tn: &type_names) -> TypeRef {\n-    let s = ~\"opaque_tag\";\n+    let s = \"opaque_tag\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_struct([T_int(), T_i8()]);\n     tn.associate(s, t);\n@@ -754,16 +740,12 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(s: &istr) -> ValueRef {\n-    ret str::as_buf(s, { |buf|\n-        llvm::LLVMConstRealOfString(T_float(), buf)\n-    });\n+fn C_float(s: &str) -> ValueRef {\n+    ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(T_float(), buf) });\n }\n \n-fn C_floating(s: &istr, t: TypeRef) -> ValueRef {\n-    ret str::as_buf(s, { |buf|\n-        llvm::LLVMConstRealOfString(t, buf)\n-    });\n+fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n+    ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n }\n \n fn C_nil() -> ValueRef {\n@@ -787,24 +769,27 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n-    let sc = str::as_buf(s, { |buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s), False)\n-    });\n-    let g = str::as_buf(cx.names.next(~\"str\"), { |buf|\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf)\n-    });\n+fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n+    let sc =\n+        str::as_buf(s,\n+                    {|buf|\n+                        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+                    });\n+    let g =\n+        str::as_buf(cx.names.next(\"str\"),\n+                    {|buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf) });\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n     llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     ret g;\n }\n \n // Returns a Plain Old LLVM String:\n-fn C_postr(s: &istr) -> ValueRef {\n-    ret str::as_buf(s, { |buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s), False)\n-    });\n+fn C_postr(s: &str) -> ValueRef {\n+    ret str::as_buf(s,\n+                    {|buf|\n+                        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+                    });\n }\n \n fn C_zero_byte_arr(size: uint) -> ValueRef {\n@@ -836,9 +821,11 @@ fn C_bytes(bytes: &[u8]) -> ValueRef {\n \n fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = str::as_buf(ccx.names.next(~\"shape\"), { |buf|\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n-    });\n+    let llglobal =\n+        str::as_buf(ccx.names.next(\"shape\"),\n+                    {|buf|\n+                        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n+                    });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n     llvm::LLVMSetGlobalConstant(llglobal, True);\n     llvm::LLVMSetLinkage(llglobal,\n@@ -847,14 +834,16 @@ fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n }\n \n \n-pure fn valid_variant_index(ix:uint, cx:@block_ctxt, tag_id: &ast::def_id,\n+pure fn valid_variant_index(ix: uint, cx: @block_ctxt, tag_id: &ast::def_id,\n                             variant_id: &ast::def_id) -> bool {\n+\n     // Handwaving: it's ok to pretend this code is referentially\n     // transparent, because the relevant parts of the type context don't\n     // change. (We're not adding new variants during trans.)\n-    unchecked {\n-      let variant = ty::tag_variant_with_id(bcx_tcx(cx), tag_id, variant_id);\n-      ix < vec::len(variant.args)\n+    unchecked{\n+        let variant =\n+            ty::tag_variant_with_id(bcx_tcx(cx), tag_id, variant_id);\n+        ix < vec::len(variant.args)\n     }\n }\n "}, {"sha": "ed2ee1ba74dd1abf6ee1f2b7632508744f14795a", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -37,7 +37,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     let llctor_decl;\n     alt ccx.item_ids.find(ctor_id) {\n       some(x) { llctor_decl = x; }\n-      _ { cx.ccx.sess.span_fatal(sp, ~\"unbound llctor_decl in trans_obj\"); }\n+      _ { cx.ccx.sess.span_fatal(sp, \"unbound llctor_decl in trans_obj\"); }\n     }\n \n     // Much like trans_fn, we must create an LLVM function, but since we're\n@@ -79,8 +79,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-    let pair_vtbl =\n-        GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     // Make a vtable for this object: a static array of pointers to functions.\n@@ -135,8 +134,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         bcx = body_tydesc.bcx;\n         let ti = none::<@tydesc_info>;\n \n-        let r = GEP_tup_like(bcx, body_ty, body,\n-                             [0, abi::obj_body_elt_typarams]);\n+        let r =\n+            GEP_tup_like(bcx, body_ty, body, [0, abi::obj_body_elt_typarams]);\n         bcx = r.bcx;\n         let body_typarams = r.val;\n \n@@ -186,7 +185,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n               }\n               none. {\n                 bcx_ccx(bcx).sess.span_fatal(f.ty.span,\n-                                             ~\"internal error in trans_obj\");\n+                                             \"internal error in trans_obj\");\n               }\n             }\n         }\n@@ -285,8 +284,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     add_clean_temp(bcx, pair, t);\n \n     // Grab onto the first and second elements of the pair.\n-    let pair_vtbl =\n-        GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     vtbl = PointerCast(bcx, vtbl, T_ptr(T_empty_struct()));\n@@ -370,8 +368,9 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n                 GEP_tup_like(bcx, body_ty, body,\n                              [0, abi::obj_body_elt_inner_obj]);\n             bcx = body_inner_obj.bcx;\n-            bcx = copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n-                           inner_obj_ty);\n+            bcx =\n+                copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n+                         inner_obj_ty);\n           }\n         }\n \n@@ -435,7 +434,7 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n         ret some(fwding_mthd(fm));\n       }\n       normal_mthd(_) {\n-        cx.ccx.sess.bug(~\"create_vtbl(): shouldn't be any \\\n+        cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n                         normal_mthds in meths here\");\n       }\n     }\n@@ -485,7 +484,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n             }\n           }\n           _ {\n-            cx.ccx.sess.bug(~\"create_vtbl(): trying to extend a \\\n+            cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \\\n                             non-object\");\n           }\n         }\n@@ -526,7 +525,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n       }\n     }\n \n-    ret finish_vtbl(cx, llmethods, ~\"vtbl\");\n+    ret finish_vtbl(cx, llmethods, \"vtbl\");\n }\n \n // create_backwarding_vtbl: Create a vtable for the inner object of an\n@@ -549,7 +548,7 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(~\"create_backwarding_vtbl(): trying to extend a \\\n+        cx.ccx.sess.bug(\"create_backwarding_vtbl(): trying to extend a \\\n                             non-object\");\n       }\n     }\n@@ -560,19 +559,20 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n         // being forwarded to.\n         llmethods += [process_bkwding_mthd(cx, sp, @m, [], outer_obj_ty, [])];\n     }\n-    ret finish_vtbl(cx, llmethods, ~\"backwarding_vtbl\");\n+    ret finish_vtbl(cx, llmethods, \"backwarding_vtbl\");\n }\n \n // finish_vtbl: Given a vector of vtable entries, create the table in\n // read-only memory and return a pointer to it.\n-fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &istr) ->\n+fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &str) ->\n    ValueRef {\n     let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(\n-        cx.ccx, cx.path + [name]);\n-    let gvar = str::as_buf(vtbl_name, { |buf|\n-        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n-    });\n+    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [name]);\n+    let gvar =\n+        str::as_buf(vtbl_name,\n+                    {|buf|\n+                        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n+                    });\n     llvm::LLVMSetInitializer(gvar, vtbl);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n     llvm::LLVMSetLinkage(gvar,\n@@ -600,22 +600,19 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path\n-        + [~\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n \n     // Make up a name for the backwarding function.\n-    let fn_name: istr = ~\"backwarding_fn\";\n-    let s: istr =\n-        mangle_internal_name_by_path_and_seq(\n-            mcx.ccx, mcx.path, fn_name);\n+    let fn_name: str = \"backwarding_fn\";\n+    let s: str =\n+        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n \n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llbackwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(\n-            cx.ccx.llmod, s, llbackwarding_fn_ty);\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n \n     // Create a new function context and block context for the backwarding\n     // function, holding onto a pointer to the first block.\n@@ -630,8 +627,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Cast to self-stack's type.\n     let llenv =\n         PointerCast(bcx, fcx.llenv,\n-            T_ptr(T_struct([cx.ccx.rust_object_type,\n-                            T_ptr(cx.ccx.rust_object_type)])));\n+                    T_ptr(T_struct([cx.ccx.rust_object_type,\n+                                    T_ptr(cx.ccx.rust_object_type)])));\n     let llself_obj_ptr = GEP(bcx, llenv, [C_int(0), C_int(1)]);\n     llself_obj_ptr = Load(bcx, llself_obj_ptr);\n \n@@ -656,7 +653,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(~\"process_bkwding_mthd(): non-object type passed \\\n+        cx.ccx.sess.bug(\"process_bkwding_mthd(): non-object type passed \\\n                         as outer_obj_ty\");\n       }\n     }\n@@ -731,22 +728,19 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n-    let mcx: @local_ctxt = @{path: cx.path\n-        + [~\"method\", m.ident] with *cx};\n+    let mcx: @local_ctxt = @{path: cx.path + [\"method\", m.ident] with *cx};\n \n     // Make up a name for the forwarding function.\n-    let fn_name: istr = ~\"forwarding_fn\";\n-    let s: istr =\n-        mangle_internal_name_by_path_and_seq(\n-            mcx.ccx, mcx.path, fn_name);\n+    let fn_name: str = \"forwarding_fn\";\n+    let s: str =\n+        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n \n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llforwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(\n-            cx.ccx.llmod, s, llforwarding_fn_ty);\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n \n     // Create a new function context and block context for the forwarding\n     // function, holding onto a pointer to the first block.\n@@ -782,8 +776,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Now, reach into the box and grab the body.\n     let llself_obj_body =\n-        GEP(bcx, llself_obj_box,\n-                      [C_int(0), C_int(abi::box_rc_field_body)]);\n+        GEP(bcx, llself_obj_box, [C_int(0), C_int(abi::box_rc_field_body)]);\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n     // cast to.\n@@ -811,8 +804,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // method's entry out of the vtable so that the forwarding function can\n     // call it.\n     let llinner_obj_vtbl =\n-        GEP(bcx, llinner_obj.val,\n-                      [C_int(0), C_int(abi::obj_field_vtbl)]);\n+        GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     llinner_obj_vtbl = Load(bcx, llinner_obj_vtbl);\n \n     let llinner_obj_body =\n@@ -827,7 +819,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(~\"process_fwding_mthd(): non-object type passed \\\n+        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n                         as target_obj_ty\");\n       }\n     }\n@@ -846,8 +838,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         ty::ty_fn_proto(bcx_tcx(bcx), orig_mthd_ty), true,\n                         m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n-    llorig_mthd =\n-        PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n+    llorig_mthd = PointerCast(bcx, llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = Load(bcx, llorig_mthd);\n \n     // Set up the self-stack.\n@@ -860,8 +851,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                             llinner_obj_body);\n \n     // Cast self_stack back to pointer-to-object-type to make LLVM happy.\n-    self_stack =\n-        PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n+    self_stack = PointerCast(bcx, self_stack, T_ptr(cx.ccx.rust_object_type));\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n@@ -930,11 +920,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       }\n     }\n     let mcx: @local_ctxt =\n-        @{path: cx.path + [~\"method\", m.node.ident] with *cx};\n-    let s: istr = mangle_internal_name_by_path(mcx.ccx,\n-                                               mcx.path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(\n-        cx.ccx.llmod, s, llfnty);\n+        @{path: cx.path + [\"method\", m.node.ident] with *cx};\n+    let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n+    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that"}, {"sha": "03daddb0a080886e726fe3f91d59588e9a805686", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 115, "deletions": 98, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,12 +3,11 @@ import std::option::none;\n import syntax::ast;\n import lib::llvm::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import trans::{call_memmove, trans_shared_malloc, llsize_of,\n-               type_of_or_i8, incr_ptr, INIT, copy_val, load_if_immediate,\n-               alloca, size_of, llderivedtydescs_block_ctxt,\n-               lazily_emit_tydesc_glue, get_tydesc, load_inbounds,\n-               move_val_if_temp, trans_lval, node_id_type,\n-               new_sub_block_ctxt, tps_normal, do_spill_noroot};\n+import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n+               incr_ptr, INIT, copy_val, load_if_immediate, alloca, size_of,\n+               llderivedtydescs_block_ctxt, lazily_emit_tydesc_glue,\n+               get_tydesc, load_inbounds, move_val_if_temp, trans_lval,\n+               node_id_type, new_sub_block_ctxt, tps_normal, do_spill_noroot};\n import trans_build::*;\n import trans_common::*;\n \n@@ -18,14 +17,14 @@ fn get_fill(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n fn get_alloc(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n     Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::vec_elt_alloc)]))\n }\n-fn get_dataptr(bcx: &@block_ctxt, vpt: ValueRef,\n-               unit_ty: TypeRef) -> ValueRef {\n+fn get_dataptr(bcx: &@block_ctxt, vpt: ValueRef, unit_ty: TypeRef) ->\n+   ValueRef {\n     let ptr = InBoundsGEP(bcx, vpt, [C_int(0), C_uint(abi::vec_elt_elems)]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n-fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef)\n-    -> ValueRef {\n+fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef) ->\n+   ValueRef {\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n@@ -34,53 +33,58 @@ fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef)\n fn alloc_raw(bcx: &@block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n     let llvecty = T_opaque_vec();\n     let vecsize = Add(bcx, alloc, llsize_of(llvecty));\n-    let {bcx, val: vecptr} =\n+    let {bcx: bcx, val: vecptr} =\n         trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    Store(bcx, fill, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_fill)]));\n-    Store(bcx, alloc, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n+    Store(bcx, fill,\n+          InBoundsGEP(bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_fill)]));\n+    Store(bcx, alloc,\n+          InBoundsGEP(bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n     ret {bcx: bcx, val: vecptr};\n }\n \n-type alloc_result = {bcx: @block_ctxt,\n-                     val: ValueRef,\n-                     unit_ty: ty::t,\n-                     llunitsz: ValueRef,\n-                     llunitty: TypeRef};\n+type alloc_result =\n+    {bcx: @block_ctxt,\n+     val: ValueRef,\n+     unit_ty: ty::t,\n+     llunitsz: ValueRef,\n+     llunitty: TypeRef};\n \n fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let llvecty = T_vec(llunitty);\n-    let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+    let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n     let fill = Mul(bcx, C_uint(elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(4), unit_sz) } else { fill };\n-    let {bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n+    let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n     add_clean_temp(bcx, vptr, vec_ty);\n-    ret {bcx: bcx, val: vptr, unit_ty: unit_ty,\n-         llunitsz: unit_sz, llunitty: llunitty};\n+    ret {bcx: bcx,\n+         val: vptr,\n+         unit_ty: unit_ty,\n+         llunitsz: unit_sz,\n+         llunitty: llunitty};\n }\n \n fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n     let vptr = Load(bcx, vptrptr);\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n-    let {bcx, val: newptr} = trans_shared_malloc(bcx, val_ty(vptr), size);\n+    let {bcx: bcx, val: newptr} =\n+        trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n     Store(bcx, fill,\n           InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n     Store(bcx, newptr, vptrptr);\n     ret bcx;\n }\n-fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t)\n-    -> @block_ctxt {\n+fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n+   @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let vptr = Load(bcx, vptrptr);\n-    let drop_cx = new_sub_block_ctxt(bcx, ~\"drop\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n+    let drop_cx = new_sub_block_ctxt(bcx, \"drop\");\n+    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n@@ -92,10 +96,14 @@ fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t)\n     ret next_cx;\n }\n \n-fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr],\n-              id: ast::node_id) -> result {\n+fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n+   result {\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n-    let {bcx, val: vptr, llunitsz, unit_ty, llunitty} =\n+    let {bcx: bcx,\n+         val: vptr,\n+         llunitsz: llunitsz,\n+         unit_ty: unit_ty,\n+         llunitty: llunitty} =\n         alloc(bcx, vec_ty, vec::len(args));\n \n     // Store the individual elements.\n@@ -104,24 +112,24 @@ fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr],\n     for e in args {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.res.bcx;\n-        let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n-        } else {\n-            InBoundsGEP(bcx, dataptr, [C_uint(i)])\n-        };\n+        let lleltptr =\n+            if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+                InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n+            } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n         bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n         i += 1u;\n     }\n     ret rslt(bcx, vptr);\n }\n-fn trans_istr(bcx: &@block_ctxt, s: istr) -> result {\n+fn trans_str(bcx: &@block_ctxt, s: str) -> result {\n     let veclen = std::str::byte_len(s) + 1u; // +1 for \\0\n-    let {bcx, val: sptr, _} =\n-        alloc(bcx, ty::mk_istr(bcx_tcx(bcx)), veclen);\n+    let {bcx: bcx, val: sptr, _} =\n+        alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n \n     let llcstr = C_cstr(bcx_ccx(bcx), s);\n-    let bcx = call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()),\n-                           llcstr, C_uint(veclen)).bcx;\n+    let bcx =\n+        call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n+                     C_uint(veclen)).bcx;\n \n     ret rslt(bcx, sptr);\n }\n@@ -135,12 +143,13 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n         lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n         rhs = PointerCast(cx, rhs, T_ptr(T_opaque_vec()));\n     }\n-    let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n-      ty::ty_istr. { true }\n-      ty::ty_vec(_) { false }\n-    };\n+    let strings =\n+        alt ty::struct(bcx_tcx(cx), vec_ty) {\n+          ty::ty_str. { true }\n+          ty::ty_vec(_) { false }\n+        };\n \n-    let {bcx, val: unit_sz} = size_of(cx, unit_ty);\n+    let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n     let llunitty = type_of_or_i8(cx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n@@ -161,75 +170,82 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n-    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill, { | &bcx, addr, _ty |\n-        let write_ptr = Load(bcx, write_ptr_ptr);\n-        let bcx = copy_val(bcx, INIT, write_ptr,\n-                           load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-        if dynamic {\n-            // We have to increment by the dynamically-computed size.\n-            incr_ptr(bcx, write_ptr, unit_sz, write_ptr_ptr);\n-        } else {\n-            incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n-        }\n-        ret bcx;\n-    });\n+    let bcx =\n+        iter_vec_raw(bcx, rhs, vec_ty, rfill,\n+                     // We have to increment by the dynamically-computed size.\n+                     {|&bcx, addr, _ty|\n+                         let write_ptr = Load(bcx, write_ptr_ptr);\n+                         let bcx =\n+                             copy_val(bcx, INIT, write_ptr,\n+                                      load_if_immediate(bcx, addr, unit_ty),\n+                                      unit_ty);\n+                         if dynamic {\n+                             incr_ptr(bcx, write_ptr, unit_sz, write_ptr_ptr);\n+                         } else {\n+                             incr_ptr(bcx, write_ptr, C_int(1),\n+                                      write_ptr_ptr);\n+                         }\n+                         ret bcx;\n+                     });\n     ret rslt(bcx, C_nil());\n }\n \n fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: &[@ast::expr]) -> @block_ctxt {\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n-    let {bcx, val: td} =\n+    let {bcx: bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, tps_normal, ti).result;\n     trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n         bcx = e_bcx;\n         let r = trans::spill_if_immediate(bcx, elt, elt_ty);\n-        let spilled = r.val; bcx = r.bcx;\n+        let spilled = r.val;\n+        bcx = r.bcx;\n         Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n              [bcx.fcx.lltaskptr, opaque_v, td,\n               PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n     ret bcx;\n }\n \n-fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n-             rhs: ValueRef) -> result {\n-    let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n-      ty::ty_istr. { true }\n-      ty::ty_vec(_) { false }\n-    };\n+fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef, rhs: ValueRef)\n+   -> result {\n+    let strings =\n+        alt ty::struct(bcx_tcx(bcx), vec_ty) {\n+          ty::ty_str. { true }\n+          ty::ty_vec(_) { false }\n+        };\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let {bcx, val: llunitsz} = size_of(bcx, unit_ty);\n+    let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n     let lhs_fill = get_fill(bcx, lhs);\n     if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n-    let {bcx, val: new_vec} = alloc_raw(bcx, new_fill, new_fill);\n+    let {bcx: bcx, val: new_vec} = alloc_raw(bcx, new_fill, new_fill);\n     let new_vec = PointerCast(bcx, new_vec, T_ptr(T_vec(llunitty)));\n     add_clean_temp(bcx, new_vec, vec_ty);\n \n-    let write_ptr_ptr = do_spill_noroot(bcx,\n-                                        get_dataptr(bcx, new_vec, llunitty));\n-    let copy_fn = bind fn(bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n-                          write_ptr_ptr: ValueRef, unit_ty: ty::t,\n-                          llunitsz: ValueRef) -> @block_ctxt {\n-        let write_ptr = Load(bcx, write_ptr_ptr);\n-        let bcx = copy_val(bcx, INIT, write_ptr,\n-                           load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            // We have to increment by the dynamically-computed size.\n-            incr_ptr(bcx, write_ptr, llunitsz, write_ptr_ptr);\n-        } else {\n-            incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n-        }\n-        ret bcx;\n-    } (_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n+    let write_ptr_ptr =\n+        do_spill_noroot(bcx, get_dataptr(bcx, new_vec, llunitty));\n+    let copy_fn =\n+        bind fn (bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n+                 write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n+                -> @block_ctxt {\n+                 let write_ptr = Load(bcx, write_ptr_ptr);\n+                 let bcx =\n+                     copy_val(bcx, INIT, write_ptr,\n+                              load_if_immediate(bcx, addr, unit_ty), unit_ty);\n+                 if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+                     // We have to increment by the dynamically-computed size.\n+                     incr_ptr(bcx, write_ptr, llunitsz, write_ptr_ptr);\n+                 } else { incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr); }\n+                 ret bcx;\n+             }(_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n     let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n     let bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n@@ -241,10 +257,10 @@ type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n type iter_vec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n-                 fill: ValueRef, f: &iter_vec_block) -> @block_ctxt {\n+                fill: ValueRef, f: &iter_vec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+    let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n     let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n@@ -255,28 +271,29 @@ fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let data_ptr_ptr = do_spill_noroot(bcx, data_ptr);\n \n     // Now perform the iteration.\n-    let header_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_loop_header\");\n+    let header_cx = new_sub_block_ctxt(bcx, \"iter_vec_loop_header\");\n     Br(bcx, header_cx.llbb);\n     let data_ptr = Load(header_cx, data_ptr_ptr);\n-    let not_yet_at_end = ICmp(header_cx, lib::llvm::LLVMIntULT,\n-                              data_ptr, data_end_ptr);\n-    let body_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_loop_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_next\");\n+    let not_yet_at_end =\n+        ICmp(header_cx, lib::llvm::LLVMIntULT, data_ptr, data_end_ptr);\n+    let body_cx = new_sub_block_ctxt(bcx, \"iter_vec_loop_body\");\n+    let next_cx = new_sub_block_ctxt(bcx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n-    let increment = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        unit_sz\n-    } else { C_int(1) };\n+    let increment =\n+        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+            unit_sz\n+        } else { C_int(1) };\n     incr_ptr(body_cx, data_ptr, increment, data_ptr_ptr);\n     Br(body_cx, header_cx.llbb);\n \n     ret next_cx;\n }\n \n fn iter_vec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-             f: &iter_vec_block) -> @block_ctxt {\n-    let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n-                                     T_ptr(T_ptr(T_opaque_vec()))));\n+            f: &iter_vec_block) -> @block_ctxt {\n+    let vptr =\n+        Load(bcx, PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec()))));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n "}, {"sha": "f88d803b7bf6bc9f10e488c50ec89b467bb2af45", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -239,8 +239,8 @@ fn implies(a: t, b: t) -> bool {\n     ret tritv_doesntcare(tmp);\n }\n \n-fn trit_str(t: trit) -> istr {\n-    alt t { dont_care. { ~\"?\" } ttrue. { ~\"1\" } tfalse. { ~\"0\" } }\n+fn trit_str(t: trit) -> str {\n+    alt t { dont_care. { \"?\" } ttrue. { \"1\" } tfalse. { \"0\" } }\n }\n //\n // Local Variables:"}, {"sha": "5a97d6bc0aeb51c40993e28f13f1d739d4906af3", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -32,12 +32,12 @@ fn collect_ids_block(b: &blk, rs: @mutable [node_id]) { *rs += [b.node.id]; }\n fn collect_ids_stmt(s: &@stmt, rs: @mutable [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) {\n-        log ~\"node_id \" + int::str(id);\n+        log \"node_id \" + int::str(id);\n         log_stmt(*s);;\n         *rs += [id];\n       }\n       stmt_expr(_, id) {\n-        log ~\"node_id \" + int::str(id);\n+        log \"node_id \" + int::str(id);\n         log_stmt(*s);;\n         *rs += [id];\n       }\n@@ -62,7 +62,7 @@ fn node_ids_in_fn(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n \n fn init_vecs(ccx: &crate_ctxt, node_ids: &[node_id], len: uint) {\n     for i: node_id in node_ids {\n-        log int::str(i) + ~\" |-> \" + uint::str(len);\n+        log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }"}, {"sha": "65015b4fea1335b0503311e4b7340b4a4c0d02e7", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 81, "deletions": 86, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -55,48 +55,46 @@ tag oper_type {\n }\n \n /* logging funs */\n-fn def_id_to_str(d: def_id) -> istr {\n-    ret int::str(d.crate) + ~\",\" + int::str(d.node);\n+fn def_id_to_str(d: def_id) -> str {\n+    ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n-fn comma_str(args: &[@constr_arg_use]) -> istr {\n-    let rslt = ~\"\";\n+fn comma_str(args: &[@constr_arg_use]) -> str {\n+    let rslt = \"\";\n     let comma = false;\n     for a: @constr_arg_use in args {\n-        if comma { rslt += ~\", \"; } else { comma = true; }\n+        if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n-          carg_base. { rslt += ~\"*\"; }\n+          carg_base. { rslt += \"*\"; }\n           carg_ident(i) { rslt += i.ident; }\n           carg_lit(l) { rslt += lit_to_str(l); }\n         }\n     }\n     ret rslt;\n }\n \n-fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> istr {\n+fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n     alt c.node {\n       ninit(_, i) {\n-        ret ~\"init(\" + i + ~\" [\" +\n-            tcx.sess.span_str(c.span) + ~\"])\";\n+        ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n       }\n       npred(p, _, args) {\n-        ret path_to_str(p) + ~\"(\" +\n-            comma_str(args) + ~\")\" + ~\"[\" +\n-                tcx.sess.span_str(c.span) + ~\"]\";\n+        ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n+                tcx.sess.span_str(c.span) + \"]\";\n       }\n     }\n }\n \n-fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> istr {\n-    let s = ~\"\";\n+fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n+    let s = \"\";\n     let comma = false;\n     for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n           dont_care. { }\n           t {\n             s +=\n-                if comma { ~\", \" } else { comma = true; ~\"\" } +\n-                    if t == tfalse { ~\"!\" } else { ~\"\" } +\n+                if comma { \", \" } else { comma = true; \"\" } +\n+                    if t == tfalse { \"!\" } else { \"\" } +\n                     constraint_to_str(fcx.ccx.tcx, p.c);\n           }\n         }\n@@ -107,8 +105,8 @@ fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> istr {\n fn log_tritv(fcx: &fn_ctxt, v: &tritv::t) { log tritv_to_str(fcx, v); }\n \n fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n-                           actual: &tritv::t) -> istr {\n-    let s: istr = ~\"\";\n+                           actual: &tritv::t) -> str {\n+    let s: str = \"\";\n     for c: norm_constraint in constraints(fcx) {\n         if tritv_get(expected, c.bit_num) == ttrue &&\n                tritv_get(actual, c.bit_num) != ttrue {\n@@ -120,12 +118,12 @@ fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n \n fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(v: &[uint]) -> istr {\n-    let rslt = ~\"\";\n+fn tos(v: &[uint]) -> str {\n+    let rslt = \"\";\n     for i: uint in v {\n         if i == 0u {\n-            rslt += ~\"0\";\n-        } else if i == 1u { rslt += ~\"1\"; } else { rslt += ~\"?\"; }\n+            rslt += \"0\";\n+        } else if i == 1u { rslt += \"1\"; } else { rslt += \"?\"; }\n     }\n     ret rslt;\n }\n@@ -170,11 +168,11 @@ fn log_states_err(pp: &pre_and_post_state) {\n     log_cond_err(p2);\n }\n \n-fn print_ident(i: &ident) { log ~\" \" + i + ~\" \"; }\n+fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n \n fn print_idents(idents: &mutable [ident]) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n-    log ~\"an ident: \" + vec::pop::<ident>(idents);\n+    log \"an ident: \" + vec::pop::<ident>(idents);\n     print_idents(idents);\n }\n \n@@ -272,15 +270,15 @@ So we need context. And so it seems clearer to just have separate\n constraints.\n */\n type fn_info =\n+    /* list, accumulated during pre/postcondition\n+    computation, of all local variables that may be\n+    used */\n+    // Doesn't seem to work without the @ -- bug\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: controlflow,\n      i_return: tsconstr,\n      i_diverge: tsconstr,\n-     /* list, accumulated during pre/postcondition\n-     computation, of all local variables that may be\n-     used */\n-     // Doesn't seem to work without the @ -- bug\n      used_vars: @mutable [node_id]};\n \n fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n@@ -330,8 +328,7 @@ fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t<ts_ann> {\n fn node_id_to_ts_ann(ccx: &crate_ctxt, id: node_id) -> ts_ann {\n     alt get_ts_ann(ccx, id) {\n       none. {\n-        log_err ~\"node_id_to_ts_ann: no ts_ann for node_id \"\n-            + int::str(id);\n+        log_err \"node_id_to_ts_ann: no ts_ann for node_id \" + int::str(id);\n         fail;\n       }\n       some(t) { ret t; }\n@@ -533,8 +530,7 @@ fn constraints_expr(cx: &ty::ctxt, e: @expr) -> [@ty::constr] {\n fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n     alt cx.def_map.find(id) {\n       none. {\n-        log_err ~\"node_id_to_def: node_id \"\n-            + int::str(id) + ~\" has no def\";\n+        log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n         fail;\n       }\n       some(d) { ret d; }\n@@ -579,26 +575,23 @@ fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n // should freeze it at some earlier point.\n fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n               occ: &[@constr_arg_use]) -> uint {\n-    log ~\"match_args: looking at \" +\n-            constr_args_to_str(fn (i: &inst) -> istr {\n-                ret i.ident;\n-            }, occ);\n+    log \"match_args: looking at \" +\n+            constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n     for pd: pred_args in *occs {\n-        log ~\"match_args: candidate \" + pred_args_to_str(pd);\n+        log \"match_args: candidate \" + pred_args_to_str(pd);\n         fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n         if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n     }\n-    fcx.ccx.tcx.sess.bug(~\"match_args: no match for occurring args\");\n+    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n \n fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n     alt tcx.def_map.find(t) {\n       none. {\n-        tcx.sess.bug(~\"node_id_for_constr: bad node_id \"\n-                     + int::str(t));\n+        tcx.sess.bug(\"node_id_for_constr: bad node_id \" + int::str(t));\n       }\n       some(def_fn(i, _)) { ret i; }\n-      _ { tcx.sess.bug(~\"node_id_for_constr: pred is not a function\"); }\n+      _ { tcx.sess.bug(\"node_id_for_constr: pred is not a function\"); }\n     }\n }\n \n@@ -612,21 +605,20 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n                         carg_ident({ident: p.node.idents[0], node: id.node}));\n           }\n           some(_) {\n-            tcx.sess.bug(~\"exprs_to_constr_args: non-local variable \" +\n-                             ~\"as pred arg\");\n+            tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n+                             \"as pred arg\");\n           }\n           none {\n-            tcx.sess.bug(~\"exprs_to_constr_args: NONE \" +\n-                             ~\"as pred arg\");\n+            tcx.sess.bug(\"exprs_to_constr_args: NONE \" + \"as pred arg\");\n \n           }\n         }\n       }\n       expr_lit(l) { ret @respan(e.span, carg_lit(l)); }\n       _ {\n         tcx.sess.span_fatal(e.span,\n-                            ~\"Arguments to constrained functions must be \" +\n-                                ~\"literals or local variables\");\n+                            \"Arguments to constrained functions must be \" +\n+                                \"literals or local variables\");\n       }\n     }\n }\n@@ -649,25 +641,23 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n           }\n           _ {\n             tcx.sess.span_fatal(operator.span,\n-                                ~\"Internal error: \" +\n-                                    ~\" ill-formed operator \\\n+                                \"Internal error: \" +\n+                                    \" ill-formed operator \\\n                                             in predicate\");\n           }\n         }\n       }\n       _ {\n         tcx.sess.span_fatal(e.span,\n-                            ~\"Internal error: \" + ~\" ill-formed predicate\");\n+                            \"Internal error: \" + \" ill-formed predicate\");\n       }\n     }\n }\n \n-fn pred_args_to_str(p: &pred_args) -> istr {\n-    ~\"<\" + uint::str(p.node.bit_num) + ~\", \" +\n-        constr_args_to_str(fn (i: &inst) -> istr {\n-            ret i.ident;\n-        }, p.node.args)\n-        + ~\">\"\n+fn pred_args_to_str(p: &pred_args) -> str {\n+    \"<\" + uint::str(p.node.bit_num) + \", \" +\n+        constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, p.node.args)\n+        + \">\"\n }\n \n fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n@@ -687,7 +677,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n         if i < num_actuals {\n             ret expr_to_constr_arg(cx, actuals[i]);\n         } else {\n-            cx.sess.span_fatal(a.span, ~\"Constraint argument out of bounds\");\n+            cx.sess.span_fatal(a.span, \"Constraint argument out of bounds\");\n         }\n       }\n       carg_base. { ret @respan(a.span, carg_base); }\n@@ -766,18 +756,18 @@ fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> istr {\n-    let rslt = ~\"<\";\n+fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n+    let rslt = \"<\";\n     for i: constr_arg_general_<inst> in stuff {\n         rslt +=\n-            ~\" \" +\n+            \" \" +\n                 alt i {\n                   carg_ident(p) { p.ident }\n-                  carg_base. { ~\"*\" }\n-                  carg_lit(_) { ~\"[lit]\" }\n-                } + ~\" \";\n+                  carg_base. { \"*\" }\n+                  carg_lit(_) { \"[lit]\" }\n+                } + \" \";\n     }\n-    rslt += ~\">\";\n+    rslt += \">\";\n     rslt\n }\n \n@@ -814,7 +804,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n \n fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n     alt vec::last(p.node.idents) {\n-      none. { cx.sess.span_fatal(p.span, ~\"Malformed path\"); }\n+      none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n       some(i) { ret i; }\n     }\n }\n@@ -829,13 +819,13 @@ fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n       }\n       some(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"local_node_id_to_def_id: id \\\n+                                    \"local_node_id_to_def_id: id \\\n                isn't a local\");\n       }\n       none. {\n         // should really be bug. span_bug()?\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"local_node_id_to_def_id: id \\\n+                                    \"local_node_id_to_def_id: id \\\n                is unbound\");\n       }\n     }\n@@ -848,7 +838,9 @@ fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t<def> {\n fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t<def_id> {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(id)) | some(def_arg(id, _)) | some(def_binding(id)) |\n-      some(def_upvar(id, _, _)) { some(id) }\n+      some(def_upvar(id, _, _)) {\n+        some(id)\n+      }\n       _ { none }\n     }\n }\n@@ -1048,23 +1040,27 @@ fn do_nothing<T>(_f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n \n \n fn args_to_constr_args(tcx: &ty::ctxt, args: &[arg],\n-                       indices:&[@sp_constr_arg<uint>]) -> [@constr_arg_use] {\n+                       indices: &[@sp_constr_arg<uint>]) ->\n+   [@constr_arg_use] {\n     let actuals: [@constr_arg_use] = [];\n     let num_args = vec::len(args);\n-    for a:@sp_constr_arg<uint> in indices {\n-        actuals += [@respan(a.span, alt a.node {\n-          carg_base. { carg_base }\n-          carg_ident(i) {\n-            if i < num_args {\n-                carg_ident({ident: args[i].ident, node:args[i].id})\n-            }\n-            else {\n-                tcx.sess.span_bug(a.span, ~\"Index out of bounds in \\\n+    for a: @sp_constr_arg<uint> in indices {\n+        actuals +=\n+            [@respan(a.span,\n+                     alt a.node {\n+                       carg_base. { carg_base }\n+                       carg_ident(i) {\n+                         if i < num_args {\n+                             carg_ident({ident: args[i].ident,\n+                                         node: args[i].id})\n+                         } else {\n+                             tcx.sess.span_bug(a.span,\n+                                               \"Index out of bounds in \\\n                   constraint arg\");\n-            }\n-          }\n-          carg_lit(l) { carg_lit(l) }\n-        })];\n+                         }\n+                       }\n+                       carg_lit(l) { carg_lit(l) }\n+                     })];\n     }\n     ret actuals;\n }\n@@ -1073,7 +1069,7 @@ fn ast_constr_to_ts_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n    tsconstr {\n     let tconstr = ty::ast_constr_to_constr(tcx, c);\n     ret npred(tconstr.node.path, tconstr.node.id,\n-         args_to_constr_args(tcx, args, tconstr.node.args));\n+              args_to_constr_args(tcx, args, tconstr.node.args));\n }\n \n fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n@@ -1109,9 +1105,8 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n       }\n       _ {\n         // Shouldn't happen; callee should be ty_fn.\n-        fcx.ccx.tcx.sess.bug(\n-            ~\"non-fn callee type in callee_modes: \" +\n-            util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n+        fcx.ccx.tcx.sess.bug(\"non-fn callee type in callee_modes: \" +\n+                                 util::ppaux::ty_to_str(fcx.ccx.tcx, ty));\n       }\n     }\n }"}, {"sha": "8c37df3cec49b800e8aa09ea0ab4e0922fc92a1c", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -36,17 +36,17 @@ fn bit_num(fcx: &fn_ctxt, c: &tsconstr) -> uint {\n         alt rslt {\n           cinit(n, _, _) { ret n; }\n           _ {\n-            fcx.ccx.tcx.sess.bug(~\"bit_num: asked for init constraint,\" +\n-                                     ~\" found a pred constraint\");\n+            fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\" +\n+                                     \" found a pred constraint\");\n           }\n         }\n       }\n       npred(_, _, args) {\n         alt rslt {\n           cpred(_, descs) { ret match_args(fcx, descs, args); }\n           _ {\n-            fcx.ccx.tcx.sess.bug(~\"bit_num: asked for pred constraint,\" +\n-                                     ~\" found an init constraint\");\n+            fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\" +\n+                                     \" found an init constraint\");\n           }\n         }\n       }\n@@ -205,12 +205,12 @@ fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n               }\n               some(_) {/* ignore args (for now...) */ }\n               _ {\n-                fcx.ccx.tcx.sess.bug(~\"clear_in_poststate_expr: \\\n+                fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n                                    unbound var\");\n               }\n             }\n           }\n-          _ { fcx.ccx.tcx.sess.bug(~\"clear_in_poststate_expr\"); }\n+          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n         }\n       }\n       _ {/* do nothing */ }"}, {"sha": "8348fc2740993a868ec759e82bc541dd709b20aa", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -55,9 +55,7 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n           ninit(id, v) {\n             if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8\n                {\n-                fcx.ccx.tcx.sess.span_warn(c.c.span,\n-                                           ~\"unused variable \"\n-                                           + v);\n+                fcx.ccx.tcx.sess.span_warn(c.c.span, \"unused variable \" + v);\n             }\n           }\n           _ {/* ignore pred constraints */ }\n@@ -82,15 +80,15 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     */\n \n     if !implies(pres, prec) {\n-        let s = ~\"\";\n+        let s = \"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         s +=\n-            ~\"Unsatisfied precondition constraint (for example, \" + diff +\n-                ~\") for expression:\\n\";\n+            \"Unsatisfied precondition constraint (for example, \" + diff +\n+                \") for expression:\\n\";\n         s += syntax::print::pprust::expr_to_str(e);\n-        s += ~\"\\nPrecondition:\\n\";\n+        s += \"\\nPrecondition:\\n\";\n         s += tritv_to_str(fcx, prec);\n-        s += ~\"\\nPrestate:\\n\";\n+        s += \"\\nPrestate:\\n\";\n         s += tritv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_fatal(e.span, s);\n     }\n@@ -114,15 +112,15 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     */\n \n     if !implies(pres, prec) {\n-        let ss = ~\"\";\n+        let ss = \"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         ss +=\n-            ~\"Unsatisfied precondition constraint (for example, \" + diff +\n-                ~\") for statement:\\n\";\n+            \"Unsatisfied precondition constraint (for example, \" + diff +\n+                \") for statement:\\n\";\n         ss += syntax::print::pprust::stmt_to_str(*s);\n-        ss += ~\"\\nPrecondition:\\n\";\n+        ss += \"\\nPrecondition:\\n\";\n         ss += tritv_to_str(fcx, prec);\n-        ss += ~\"\\nPrestate: \\n\";\n+        ss += \"\\nPrestate: \\n\";\n         ss += tritv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n     }\n@@ -150,14 +148,12 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n            !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n            f.decl.cf == return {\n         fcx.ccx.tcx.sess.span_err(f.body.span,\n-                                  ~\"In function \" +\n-                                  fcx.name +\n-                                      ~\", not all control paths \\\n+                                  \"In function \" + fcx.name +\n+                                      \", not all control paths \\\n                                         return a value\");\n-        fcx.ccx.tcx.sess.span_fatal(\n-            f.decl.output.span,\n-            ~\"see declared return type of '\" +\n-            ty_to_str(f.decl.output) + ~\"'\");\n+        fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n+                                    \"see declared return type of '\" +\n+                                        ty_to_str(f.decl.output) + \"'\");\n     } else if f.decl.cf == noreturn {\n \n         // check that this really always fails\n@@ -166,9 +162,9 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n \n         if !promises(fcx, post, fcx.enclosing.i_diverge) {\n             fcx.ccx.tcx.sess.span_fatal(f.body.span,\n-                                        ~\"In non-returning function \" +\n+                                        \"In non-returning function \" +\n                                             fcx.name +\n-                                            ~\", some control paths may \\\n+                                            \", some control paths may \\\n                                            return to the caller\");\n         }\n     }\n@@ -197,11 +193,8 @@ fn fn_states(f: &_fn, tps: &[ast::ty_param], sp: &span, i: &fn_ident,\n \n     assert (ccx.fm.contains_key(id));\n     let f_info = ccx.fm.get(id);\n-    let name = option::from_maybe(~\"anon\", i);\n-    let fcx = {enclosing: f_info,\n-               id: id,\n-               name: name,\n-               ccx: ccx};\n+    let name = option::from_maybe(\"anon\", i);\n+    let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n     check_fn_states(fcx, f, tps, id, sp, i);\n }\n "}, {"sha": "bac29c049daa285d7544a670c48d1f32672aebe9", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -18,7 +18,7 @@ type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(id) { id } };\n-        log ~\"collect_local: pushing \" + ident;;\n+        log \"collect_local: pushing \" + ident;;\n         *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n     }\n     visit::visit_local(loc, cx, v);\n@@ -30,6 +30,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n       expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]; }\n \n \n+\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands) {\n@@ -61,17 +62,16 @@ fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n \n fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n    -> uint {\n-    log constraint_to_str(tcx, c) + ~\" |-> \"\n-        + std::uint::str(next);\n+    log constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n     alt c.node {\n       ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n       npred(p, d_id, args) {\n         alt tbl.find(d_id) {\n           some(ct) {\n             alt ct {\n               cinit(_, _, _) {\n-                tcx.sess.bug(~\"add_constraint: same def_id used\" +\n-                                 ~\" as a variable and a pred\");\n+                tcx.sess.bug(\"add_constraint: same def_id used\" +\n+                                 \" as a variable and a pred\");\n               }\n               cpred(_, pds) {\n                 *pds += [respan(c.span, {args: args, bit_num: next})];\n@@ -130,7 +130,7 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n     // and the name of the function, with a '!' appended to it, for the\n     // \"diverges\" constraint\n     let diverges_id = ccx.tcx.sess.next_node_id();\n-    let diverges_name = name + ~\"!\";\n+    let diverges_name = name + \"!\";\n     add_constraint(cx.tcx, respan(f_sp, ninit(diverges_id, diverges_name)),\n                    next, res_map);\n \n@@ -147,9 +147,8 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n          i_diverge: ninit(diverges_id, diverges_name),\n          used_vars: v};\n     ccx.fm.insert(id, rslt);\n-    log name + ~\" has \"\n-                      + std::uint::str(num_constraints(rslt))\n-                      + ~\" constraints\";\n+    log name + \" has \" + std::uint::str(num_constraints(rslt)) +\n+            \" constraints\";\n }\n \n "}, {"sha": "ac96fb3cde98d8c4d854959dccea3457876665a1", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -69,11 +69,11 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n                  {constrs: @new_def_hash::<constraint>(),\n                   num_constraints: 0u,\n                   cf: return,\n-                  i_return: ninit(0, ~\"\"),\n-                  i_diverge: ninit(0, ~\"\"),\n+                  i_return: ninit(0, \"\"),\n+                  i_diverge: ninit(0, \"\"),\n                   used_vars: v},\n              id: 0,\n-             name: ~\"\",\n+             name: \"\",\n              ccx: ccx};\n         find_pre_post_expr(fake_fcx, e);\n       }\n@@ -373,7 +373,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n-            handle_var_def(fcx, rslt, def, ~\"upvar\");\n+            handle_var_def(fcx, rslt, def, \"upvar\");\n         }\n       }\n       expr_block(b) {\n@@ -481,7 +481,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         for def in *freevars::get_freevars(fcx.ccx.tcx, body.node.id) {\n-            handle_var_def(fcx, rslt, def, ~\"upvar\");\n+            handle_var_def(fcx, rslt, def, \"upvar\");\n         }\n       }\n       expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n@@ -545,6 +545,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n \n \n \n+\n       expr_bind(operator, maybe_args) {\n         let args = [];\n         let cmodes = callee_modes(fcx, operator.id);\n@@ -563,7 +564,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n       expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_anon_obj(anon_obj) {\n         alt anon_obj.inner_obj {\n           some(ex) {\n@@ -614,7 +615,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                               pat_bind(n) { n }\n                               _ {\n                                 fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                          ~\"Impossible LHS\");\n+                                                          \"Impossible LHS\");\n                               }\n                             };\n                         alt p {\n@@ -651,7 +652,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n                           }\n                           _ {\n                             fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                      ~\"Impossible LHS\");\n+                                                      \"Impossible LHS\");\n                           }\n                         }\n                     }"}, {"sha": "af14db2e9c878ba1beaa6b626a8e0b44698b8854", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -358,7 +358,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_log(_, ex) {\n         ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n       }\n-      expr_mac(_) { fcx.ccx.tcx.sess.bug(~\"unexpanded macro\"); }\n+      expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_put(maybe_e) {\n         alt maybe_e {\n           some(arg) {\n@@ -751,6 +751,7 @@ fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n     // Treat the tail expression as a return statement\n     alt f.body.node.expr {\n       some(tailexpr) {\n+\n         // We don't want to clear the diverges bit for bottom typed things,\n         // which really do diverge. I feel like there is a cleaner way\n         // to do this than checking the type."}, {"sha": "60a724de5242733972800aafec0f1463d66ea734", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -55,6 +55,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n           ttrue. { dont_care }\n           tfalse. { ttrue }\n \n+\n           /* internally contradictory, but\n              I guess it'll get flagged? */\n           dont_care. {\n@@ -66,6 +67,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n         alt b {\n           ttrue. { tfalse }\n \n+\n           /* see above comment */\n           _ {\n             tfalse\n@@ -83,6 +85,7 @@ fn trit_or(a: trit, b: trit) -> trit {\n         alt b {\n           ttrue. { dont_care }\n \n+\n           /* FIXME: ?????? */\n           _ {\n             tfalse\n@@ -101,17 +104,20 @@ fn trit_and(a: trit, b: trit) -> trit {\n     alt a {\n       dont_care. { b }\n \n+\n       // also seems wrong for case b = ttrue\n       ttrue. {\n         alt b {\n           dont_care. { ttrue }\n \n+\n           // ??? Seems wrong\n           ttrue. {\n             ttrue\n           }\n \n \n+\n           // false wins, since if something is uninit\n           // on one path, we care\n           // (Rationale: it's always safe to assume that\n@@ -124,6 +130,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n       }\n \n \n+\n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n       tfalse. {\n@@ -261,15 +268,15 @@ fn to_vec(v: &t) -> [uint] {\n     ret rslt;\n }\n \n-fn to_str(v: &t) -> istr {\n+fn to_str(v: &t) -> str {\n     let i: uint = 0u;\n-    let rs: istr = ~\"\";\n+    let rs: str = \"\";\n     while i < v.nbits {\n         rs +=\n             alt tritv_get(v, i) {\n-              dont_care. { ~\"?\" }\n-              ttrue. { ~\"1\" }\n-              tfalse. { ~\"0\" }\n+              dont_care. { \"?\" }\n+              ttrue. { \"1\" }\n+              tfalse. { \"0\" }\n             };\n         i += 1u;\n     }"}, {"sha": "180b082a36b82144777661eccbf4bbe388f3ee76", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 134, "deletions": 128, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -67,7 +67,7 @@ export mk_fn;\n export mk_imm_box;\n export mk_mut_ptr;\n export mk_int;\n-export mk_istr;\n+export mk_str;\n export mk_vec;\n export mk_mach;\n export mk_native;\n@@ -121,7 +121,7 @@ export ty_fn_abi;\n export ty_fn_proto;\n export ty_fn_ret;\n export ty_int;\n-export ty_istr;\n+export ty_str;\n export ty_vec;\n export ty_machine;\n export ty_native;\n@@ -211,7 +211,7 @@ type ctxt =\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n-      short_names_cache: hashmap<t, @istr>,\n+      short_names_cache: hashmap<t, @str>,\n       has_pointer_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, ast::kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>};\n@@ -230,7 +230,7 @@ fn method_ty_to_fn_ty(cx: &ctxt, m: method) -> t {\n // Never construct these manually. These are interned.\n type raw_t =\n     {struct: sty,\n-     cname: option::t<istr>,\n+     cname: option::t<str>,\n      hash: uint,\n      has_params: bool,\n      has_vars: bool};\n@@ -249,7 +249,7 @@ tag sty {\n     ty_uint;\n     ty_machine(ast::ty_mach);\n     ty_char;\n-    ty_istr;\n+    ty_str;\n     ty_tag(def_id, [t]);\n     ty_box(mt);\n     ty_uniq(t);\n@@ -331,7 +331,7 @@ const idx_f64: uint = 14u;\n \n const idx_char: uint = 15u;\n \n-const idx_istr: uint = 16u;\n+const idx_str: uint = 16u;\n \n const idx_type: uint = 17u;\n \n@@ -363,7 +363,7 @@ fn populate_type_store(cx: &ctxt) {\n     intern(cx, ty_machine(ast::ty_f32), none);\n     intern(cx, ty_machine(ast::ty_f64), none);\n     intern(cx, ty_char, none);\n-    intern(cx, ty_istr, none);\n+    intern(cx, ty_str, none);\n     intern(cx, ty_type, none);\n     intern(cx, ty_bot, none);\n     assert (vec::len(cx.ts.vect) == idx_first_others);\n@@ -401,16 +401,16 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n           short_names_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           has_pointer_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          ast_ty_to_ty_cache: map::mk_hashmap(ast_util::hash_ty,\n-                                              ast_util::eq_ty)};\n+          ast_ty_to_ty_cache:\n+              map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty)};\n     populate_type_store(cx);\n     ret cx;\n }\n \n \n // Type constructors\n-fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<istr>) -> @raw_t {\n-    let cname: option::t<istr> = none;\n+fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n+    let cname: option::t<str> = none;\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n     let has_vars: bool = false;\n@@ -442,7 +442,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<istr>) -> @raw_t {\n       ty_uint. {/* no-op */ }\n       ty_machine(_) {/* no-op */ }\n       ty_char. {/* no-op */ }\n-      ty_istr. {/* no-op */ }\n+      ty_str. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_param(_, _) { has_params = true; }\n@@ -486,11 +486,11 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<istr>) -> @raw_t {\n           has_vars: has_vars};\n }\n \n-fn intern(cx: &ctxt, st: &sty, cname: &option::t<istr>) {\n+fn intern(cx: &ctxt, st: &sty, cname: &option::t<str>) {\n     interner::intern(*cx.ts, mk_raw_ty(cx, st, cname));\n }\n \n-fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<istr>) -> t {\n+fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<str>) -> t {\n     let raw_type = mk_raw_ty(cx, st, cname);\n     ret interner::intern(*cx.ts, raw_type);\n }\n@@ -529,7 +529,7 @@ fn mk_mach(_cx: &ctxt, tm: &ast::ty_mach) -> t {\n \n fn mk_char(_cx: &ctxt) -> t { ret idx_char; }\n \n-fn mk_istr(_cx: &ctxt) -> t { ret idx_istr; }\n+fn mk_str(_cx: &ctxt) -> t { ret idx_str; }\n \n fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &[t]) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n@@ -559,8 +559,8 @@ fn mk_constr(cx: &ctxt, t: t, cs: &[@type_constr]) -> t {\n \n fn mk_tup(cx: &ctxt, ts: &[t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n \n-fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: t,\n-         cf: &controlflow, constrs: &[@constr]) -> t {\n+fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: t, cf: &controlflow,\n+         constrs: &[@constr]) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n@@ -590,13 +590,11 @@ fn mk_iter_body_fn(cx: &ctxt, output: t) -> t {\n }\n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(cx: &ctxt, typ: t) -> sty {\n-    ret interner::get(*cx.ts, typ).struct;\n-}\n+fn struct(cx: &ctxt, typ: t) -> sty { ret interner::get(*cx.ts, typ).struct; }\n \n \n // Returns the canonical name of the given type.\n-fn cname(cx: &ctxt, typ: t) -> option::t<istr> {\n+fn cname(cx: &ctxt, typ: t) -> option::t<str> {\n     ret interner::get(*cx.ts, typ).cname;\n }\n \n@@ -614,7 +612,7 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_float. {/* no-op */ }\n       ty_machine(_) {/* no-op */ }\n       ty_char. {/* no-op */ }\n-      ty_istr. {/* no-op */ }\n+      ty_str. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n@@ -677,7 +675,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_float. {/* no-op */ }\n       ty_machine(_) {/* no-op */ }\n       ty_char. {/* no-op */ }\n-      ty_istr. {/* no-op */ }\n+      ty_str. {/* no-op */ }\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) {\n@@ -771,7 +769,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n \n // Type utilities\n \n-fn rename(cx: &ctxt, typ: t, new_cname: &istr) -> t {\n+fn rename(cx: &ctxt, typ: t, new_cname: &str) -> t {\n     ret gen_ty_full(cx, struct(cx, typ), some(new_cname));\n }\n \n@@ -819,25 +817,21 @@ fn type_is_copyable(cx: &ctxt, ty: t) -> bool {\n \n fn type_is_sequence(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_istr. { ret true; }\n+      ty_str. { ret true; }\n       ty_vec(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n fn type_is_str(cx: &ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n-      ty_istr. { ret true; }\n-      _ { ret false; }\n-    }\n+    alt struct(cx, ty) { ty_str. { ret true; } _ { ret false; } }\n }\n \n fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     alt struct(cx, ty) {\n-      ty_istr. { ret mk_mach(cx, ast::ty_u8); }\n+      ty_str. { ret mk_mach(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n-      _ { cx.sess.bug(\n-          ~\"sequence_element_type called on non-sequence value\"); }\n+      _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n \n@@ -856,9 +850,8 @@ fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n       _ {\n-        cx.sess.bug(~\"get_element_type called on type \" +\n-                    ty_to_str(cx, ty) +\n-                        ~\" - expected a \\\n+        cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n+                        \" - expected a \\\n             tuple or record\");\n       }\n     }\n@@ -871,26 +864,24 @@ fn type_is_box(cx: &ctxt, ty: t) -> bool {\n }\n \n fn type_is_boxed(cx: &ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n-      ty_box(_) { ret true; }\n-      _ { ret false; }\n-    }\n+    alt struct(cx, ty) { ty_box(_) { ret true; } _ { ret false; } }\n }\n \n fn type_is_vec(cx: &ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n-      ty_vec(_) { true }\n-      ty_istr. { true }\n-      _ { false }\n-    };\n+          ty_vec(_) { true }\n+          ty_str. { true }\n+          _ { false }\n+        };\n }\n \n fn type_is_unique(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_uniq(_) { ret true; }\n       ty_vec(_) { true }\n-      ty_istr. { true }\n-      _ { ret false; } }\n+      ty_str. { true }\n+      _ { ret false; }\n+    }\n }\n \n fn type_is_scalar(cx: &ctxt, ty: t) -> bool {\n@@ -917,8 +908,12 @@ fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n \n     let result = false;\n     alt struct(cx, ty) {\n+\n       // scalar types\n-      ty_nil. {/* no-op */ }\n+      ty_nil. {\n+        /* no-op */\n+\n+      }\n       ty_bot. {/* no-op */ }\n       ty_bool. {/* no-op */ }\n       ty_int. {/* no-op */ }\n@@ -980,26 +975,30 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n     alt struct(cx, ty) {\n \n \n+\n       // Scalar types are unique-kind, no substructure.\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n       ty_machine(_) | ty_char. | ty_native(_) {\n         // no-op\n       }\n \n \n+\n       // A handful of other built-in are unique too.\n-      ty_type. | ty_istr. | ty_native_fn(_, _, _) {\n+      ty_type. | ty_str. | ty_native_fn(_, _, _) {\n         // no-op\n       }\n \n \n+\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) {\n         result = kind_shared;\n       }\n \n \n+\n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n@@ -1012,13 +1011,15 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n       }\n \n \n+\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) {\n         result = ast::kind_shared;\n       }\n \n \n+\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_vec(tm) {\n@@ -1028,6 +1029,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n       }\n \n \n+\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         for f: field in flds {\n@@ -1036,6 +1038,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n         }\n       }\n \n+\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         for ty: t in tys {\n@@ -1045,6 +1048,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n       }\n \n \n+\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1060,29 +1064,34 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n       }\n \n \n+\n       // Resources are always pinned.\n       ty_res(did, inner, tps) {\n         result = ast::kind_pinned;\n       }\n \n \n+\n       ty_var(_) {\n         fail;\n       }\n \n \n+\n       ty_param(_, k) {\n         result = kind::lower_kind(result, k);\n       }\n \n \n+\n       ty_constr(t, _) {\n         result = type_kind(cx, t);\n       }\n \n \n+\n       _ {\n-        cx.sess.bug(~\"missed case: \" + ty_to_str(cx, ty));\n+        cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n       }\n     }\n \n@@ -1098,8 +1107,8 @@ fn type_is_native(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_native(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_structurally_contains(cx: &ctxt, ty: t,\n-                              test: fn(&sty) -> bool) -> bool {\n+fn type_structurally_contains(cx: &ctxt, ty: t, test: fn(&sty) -> bool) ->\n+   bool {\n     let sty = struct(cx, ty);\n     if test(sty) { ret true; }\n     alt sty {\n@@ -1209,20 +1218,23 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n \n+\n       // Scalar types\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n       ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n         result = true;\n       }\n \n \n+\n       // Boxed types\n-      ty_istr. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n+      ty_str. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _, _) | ty_obj(_) {\n         result = false;\n       }\n \n \n+\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1248,6 +1260,7 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n \n \n+\n       ty_var(_) {\n         fail \"ty_var in type_is_pod\";\n       }\n@@ -1369,7 +1382,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         }\n       }\n       ty_char. { ret 15u; }\n-      ty_istr. { ret 17u; }\n+      ty_str. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n         for typ: t in tys { h += h << 5u + hash_ty(typ); }\n@@ -1389,6 +1402,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       }\n \n \n+\n       // ???\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n@@ -1419,7 +1433,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n }\n \n-fn hash_type_info(st: &sty, cname_opt: &option::t<istr>) -> uint {\n+fn hash_type_info(st: &sty, cname_opt: &option::t<str>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n@@ -1511,10 +1525,9 @@ fn node_id_to_ty_param_substs_opt_and_ty(cx: &ctxt, id: &ast::node_id) ->\n     // Pull out the node type table.\n     alt smallintmap::find(*cx.node_types, id as uint) {\n       none. {\n-        cx.sess.bug(~\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n-                    ~\"an untyped node (\" +\n-                    std::int::to_str(id, 10u) +\n-                    ~\")\");\n+        cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n+                        \"an untyped node (\" + std::int::to_str(id, 10u) +\n+                        \")\");\n       }\n       some(tpot) { ret tpot; }\n     }\n@@ -1589,29 +1602,29 @@ fn ty_fn_args(cx: &ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n       ty::ty_native_fn(_, a, _) { ret a; }\n-      _ { cx.sess.bug(~\"ty_fn_args() called on non-fn type\"); }\n+      _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_proto(cx: &ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n-      _ { cx.sess.bug(~\"ty_fn_proto() called on non-fn type\"); }\n+      _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_abi(cx: &ctxt, fty: t) -> ast::native_abi {\n     alt struct(cx, fty) {\n       ty::ty_native_fn(a, _, _) { ret a; }\n-      _ { cx.sess.bug(~\"ty_fn_abi() called on non-native-fn type\"); }\n+      _ { cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\"); }\n     }\n }\n \n fn ty_fn_ret(cx: &ctxt, fty: t) -> t {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, r, _, _) { ret r; }\n       ty::ty_native_fn(_, _, r) { ret r; }\n-      _ { cx.sess.bug(~\"ty_fn_ret() called on non-fn type\"); }\n+      _ { cx.sess.bug(\"ty_fn_ret() called on non-fn type\"); }\n     }\n }\n \n@@ -1625,7 +1638,7 @@ fn is_fn_ty(cx: &ctxt, fty: t) -> bool {\n \n // Just checks whether it's a fn that returns bool,\n // not its purity.\n-fn is_pred_ty(cx: &ctxt, fty:t) -> bool {\n+fn is_pred_ty(cx: &ctxt, fty: t) -> bool {\n     is_fn_ty(cx, fty) && type_is_bool(cx, ty_fn_ret(cx, fty))\n }\n \n@@ -1685,15 +1698,14 @@ fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n              fields: &[field]) -> uint {\n     let i: uint = 0u;\n     for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, ~\"unknown field '\" +\n-                    id + ~\"' of record\");\n+    sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n               meths: &[method]) -> uint {\n     let i: uint = 0u;\n     for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, ~\"unknown method '\" + id + ~\"' of obj\");\n+    sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n fn sort_methods(meths: &[method]) -> [method] {\n@@ -1729,12 +1741,11 @@ fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n             // variables, so in this case we have to be sure to die.\n             tcx.sess.span_fatal(\n                 s,\n-                ~\"Type inference failed because I \\\n+                \"Type inference failed because I \\\n                  could not find a type\\n that's both of the form \"\n                 + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n-                ~\" and of the form \" +\n-                ty_to_str(tcx, rt) +\n-                ~\". Such a type would have to be infinitely \\\n+                \" and of the form \" + ty_to_str(tcx, rt) +\n+                \". Such a type would have to be infinitely \\\n                  large.\");\n           }\n           _ { ret true; }\n@@ -1927,9 +1938,9 @@ mod unify {\n \n             let result_mode;\n             if expected_input.mode != actual_input.mode {\n-                ret fn_common_res_err(\n-                    ures_err(terr_mode_mismatch(expected_input.mode,\n-                                                actual_input.mode)));\n+                ret fn_common_res_err(ures_err(\n+                    terr_mode_mismatch(expected_input.mode,\n+                                       actual_input.mode)));\n             } else { result_mode = expected_input.mode; }\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n@@ -1956,6 +1967,7 @@ mod unify {\n         alt expected_cf {\n           ast::return. { }\n \n+\n           // ok\n           ast::noreturn. {\n             alt actual_cf {\n@@ -2069,6 +2081,7 @@ mod unify {\n         alt struct(cx.tcx, actual) {\n \n \n+\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n@@ -2117,6 +2130,7 @@ mod unify {\n           ty::ty_nil. { ret struct_cmp(cx, expected, actual); }\n \n \n+\n           // _|_ unifies with anything\n           ty::ty_bot. {\n             ret ures_ok(actual);\n@@ -2127,7 +2141,7 @@ mod unify {\n           ty::ty_machine(_) { ret struct_cmp(cx, expected, actual); }\n           ty::ty_float. { ret struct_cmp(cx, expected, actual); }\n           ty::ty_char. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_istr. { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_str. { ret struct_cmp(cx, expected, actual); }\n           ty::ty_type. { ret struct_cmp(cx, expected, actual); }\n           ty::ty_native(ex_id) {\n             alt struct(cx.tcx, actual) {\n@@ -2410,18 +2424,16 @@ mod unify {\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;\n         while i < vec::len::<ufind::node>(vb.sets.nodes) {\n-            let sets = ~\"\";\n+            let sets = \"\";\n             let j = 0u;\n             while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n                 j += 1u;\n             }\n             let typespec;\n             alt smallintmap::find::<t>(vb.types, i) {\n-              none. { typespec = ~\"\"; }\n-              some(typ) {\n-                typespec = ~\" =\" + ty_to_str(tcx, typ);\n-              }\n+              none. { typespec = \"\"; }\n+              some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n             }\n             log_err #fmt[\"set %u:%s%s\", i, typespec, sets];\n             i += 1u;\n@@ -2478,54 +2490,49 @@ mod unify {\n     }\n }\n \n-fn type_err_to_str(err: &ty::type_err) -> istr {\n+fn type_err_to_str(err: &ty::type_err) -> str {\n     alt err {\n-      terr_mismatch. { ret ~\"types differ\"; }\n+      terr_mismatch. { ret \"types differ\"; }\n       terr_controlflow_mismatch. {\n-        ret ~\"returning function used where non-returning function\" +\n-                ~\" was expected\";\n+        ret \"returning function used where non-returning function\" +\n+                \" was expected\";\n       }\n-      terr_box_mutability. { ret ~\"boxed values differ in mutability\"; }\n-      terr_vec_mutability. { ret ~\"vectors differ in mutability\"; }\n+      terr_box_mutability. { ret \"boxed values differ in mutability\"; }\n+      terr_vec_mutability. { ret \"vectors differ in mutability\"; }\n       terr_tuple_size(e_sz, a_sz) {\n-        ret ~\"expected a tuple with \" +\n-            uint::to_str(e_sz, 10u) +\n-            ~\" elements but found one with \" +\n-            uint::to_str(a_sz, 10u) +\n-            ~\" elements\";\n+        ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n+                \" elements but found one with \" + uint::to_str(a_sz, 10u) +\n+                \" elements\";\n       }\n       terr_record_size(e_sz, a_sz) {\n-        ret ~\"expected a record with \" +\n-            uint::to_str(e_sz, 10u) +\n-            ~\" fields but found one with \" +\n-            uint::to_str(a_sz, 10u) +\n-            ~\" fields\";\n+        ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n+                \" fields but found one with \" + uint::to_str(a_sz, 10u) +\n+                \" fields\";\n       }\n-      terr_record_mutability. { ret ~\"record elements differ in mutability\"; }\n+      terr_record_mutability. { ret \"record elements differ in mutability\"; }\n       terr_record_fields(e_fld, a_fld) {\n-        ret ~\"expected a record with field '\" + e_fld +\n-                ~\"' but found one with field '\" + a_fld + ~\"'\";\n+        ret \"expected a record with field '\" + e_fld +\n+                \"' but found one with field '\" + a_fld + \"'\";\n       }\n-      terr_arg_count. { ret ~\"incorrect number of function parameters\"; }\n-      terr_meth_count. { ret ~\"incorrect number of object methods\"; }\n+      terr_arg_count. { ret \"incorrect number of function parameters\"; }\n+      terr_meth_count. { ret \"incorrect number of object methods\"; }\n       terr_obj_meths(e_meth, a_meth) {\n-        ret ~\"expected an obj with method '\" + e_meth +\n-                ~\"' but found one with method '\" + a_meth + ~\"'\";\n+        ret \"expected an obj with method '\" + e_meth +\n+                \"' but found one with method '\" + a_meth + \"'\";\n       }\n       terr_mode_mismatch(e_mode, a_mode) {\n-        ret ~\"expected argument mode \" + mode_str_1(e_mode) + ~\" but found \" +\n+        ret \"expected argument mode \" + mode_str_1(e_mode) + \" but found \" +\n                 mode_str_1(a_mode);\n       }\n       terr_constr_len(e_len, a_len) {\n-        ret ~\"Expected a type with \" +\n-            uint::str(e_len) +\n-            ~\" constraints, but found one with \" +\n-            uint::str(a_len) + ~\" constraints\";\n+        ret \"Expected a type with \" + uint::str(e_len) +\n+                \" constraints, but found one with \" + uint::str(a_len) +\n+                \" constraints\";\n       }\n       terr_constr_mismatch(e_constr, a_constr) {\n-        ret ~\"Expected a type with constraint \" + ty_constr_to_str(e_constr) +\n-            ~\" but found one with constraint \" +\n-            ty_constr_to_str(a_constr);\n+        ret \"Expected a type with constraint \" + ty_constr_to_str(e_constr) +\n+                \" but found one with constraint \" +\n+                ty_constr_to_str(a_constr);\n       }\n     }\n }\n@@ -2543,8 +2550,7 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int, typ: t,\n         if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids[index]);\n         } else {\n-            cx.sess.span_fatal(\n-                sp, ~\"Unbound type parameter in callee's type\");\n+            cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n         }\n     }\n     let new_typ =\n@@ -2595,7 +2601,7 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n     let item =\n         alt cx.items.find(id.node) {\n           some(i) { i }\n-          none. { cx.sess.bug(~\"expected to find cached node_item\") }\n+          none. { cx.sess.bug(\"expected to find cached node_item\") }\n         };\n     alt item {\n       ast_map::node_item(item) {\n@@ -2634,7 +2640,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;\n     }\n-    cx.sess.bug(~\"tag_variant_with_id(): no variant exists with that ID\");\n+    cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");\n }\n \n \n@@ -2662,8 +2668,8 @@ fn ret_ty_of_fn_ty(cx: ctxt, a_ty: t) -> t {\n       ty::ty_fn(_, _, ret_ty, _, _) { ret ret_ty; }\n       ty::ty_native_fn(_, _, ret_ty) { ret ret_ty; }\n       _ {\n-        cx.sess.bug(~\"ret_ty_of_fn_ty() called on non-function type: \" +\n-                    ty_to_str(cx, a_ty));\n+        cx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \" +\n+                        ty_to_str(cx, a_ty));\n       }\n     }\n }\n@@ -2734,7 +2740,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n           ty_machine(ast::ty_f64.) { tycat_float }\n           ty_char. { tycat_int }\n           ty_ptr(_) { tycat_int }\n-          ty_istr. { tycat_str }\n+          ty_str. { tycat_str }\n           ty_vec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }\n           ty_tup(_) { tycat_struct }\n@@ -2750,13 +2756,13 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n     /*.          add,     shift,   bit\n       .             sub,     rel,     logic\n       .                mult,    eq,         */\n-     /*other*/\n-     /*bool*/\n-     /*int*/\n-     /*float*/\n-     /*str*/\n-     /*vec*/\n-     /*bot*/\n+    /*other*/\n+    /*bool*/\n+    /*int*/\n+    /*float*/\n+    /*str*/\n+    /*vec*/\n+    /*bot*/\n     let tbl =\n         [[f, f, f, f, t, t, f, f], [f, f, f, f, t, t, t, t],\n          [t, t, t, t, t, t, t, f], [t, t, t, f, t, t, f, f],\n@@ -2776,11 +2782,11 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n                                id: pred_id});\n       }\n       _ {\n-        tcx.sess.span_fatal(c.span,\n-                            ~\"Predicate \" +\n-                            path_to_str(c.node.path) +\n-                            ~\" is unbound or bound to a non-function or an \\\n-                             impure function\");\n+        tcx.sess.span_fatal(\n+            c.span,\n+            \"Predicate \" + path_to_str(c.node.path) +\n+            \" is unbound or bound to a non-function or an \\\n+            impure function\");\n       }\n     }\n }"}, {"sha": "0174c1f8c3ef9e4baedd6311cacbb4d406dd1bc2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 191, "deletions": 202, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -88,7 +88,7 @@ fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n       some(x) { x }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"internal error looking up a local var\")\n+                                    \"internal error looking up a local var\")\n       }\n     }\n }\n@@ -98,15 +98,15 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n       some(x) { x }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    ~\"internal error looking up a definition\")\n+                                    \"internal error looking up a definition\")\n       }\n     }\n }\n \n fn ident_for_local(loc: &@ast::local) -> ast::ident {\n     ret alt loc.node.pat.node {\n           ast::pat_bind(name) { name }\n-          _ { ~\"local\" }\n+          _ { \"local\" }\n         }; // FIXME DESTR\n }\n \n@@ -145,14 +145,14 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n         ret {kinds: no_kinds, ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n-        fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found type\");\n+        fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n       }\n       ast::def_upvar(_, inner, _) {\n         ret ty_param_kinds_and_ty_for_def(fcx, sp, *inner);\n       }\n       _ {\n         // FIXME: handle other names.\n-        fcx.ccx.tcx.sess.unimpl(~\"definition variant\");\n+        fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n       }\n     }\n }\n@@ -175,15 +175,15 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         if param_var_len == 0u {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                ~\"this item does not take type parameters\");\n+                \"this item does not take type parameters\");\n         } else if ty_substs_len > param_var_len {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                ~\"too many type parameter provided for this item\");\n+                \"too many type parameter provided for this item\");\n         } else if ty_substs_len < param_var_len {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp,\n-                ~\"not enough type parameters provided for this item\");\n+                \"not enough type parameters provided for this item\");\n         }\n         let ty_substs: [ty::t] = [];\n         let i = 0u;\n@@ -197,7 +197,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n         ty_substs_opt = some::<[ty::t]>(ty_substs);\n         if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        ~\"this item does not take type \\\n+                                        \"this item does not take type \\\n                                       parameters\");\n         }\n     } else {\n@@ -229,7 +229,7 @@ fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) -> ty::t {\n       fix_err(_) {\n         fcx.ccx.tcx.sess.span_fatal(\n             sp,\n-            ~\"the type of this value must be known in this context\");\n+            \"the type of this value must be known in this context\");\n       }\n     }\n }\n@@ -272,7 +272,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       some(some(ty)) { ret ty; }\n       some(none.) {\n         tcx.sess.span_fatal(ast_ty.span,\n-                            ~\"illegal recursive type \\\n+                            \"illegal recursive type \\\n                               insert a tag in the cycle, \\\n                               if this is desired)\");\n       }\n@@ -307,7 +307,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         }\n         if vec::len(param_bindings) != vec::len(ty_param_kinds_and_ty.kinds) {\n             tcx.sess.span_fatal(sp,\n-                                ~\"Wrong number of type arguments for a \\\n+                                \"Wrong number of type arguments for a \\\n                                  polymorphic type\");\n         }\n         let typ =\n@@ -316,7 +316,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         ret typ;\n     }\n     let typ;\n-    let cname = none::<istr>;\n+    let cname = none::<str>;\n     alt ast_ty.node {\n       ast::ty_nil. { typ = ty::mk_nil(tcx); }\n       ast::ty_bot. { typ = ty::mk_bot(tcx); }\n@@ -326,7 +326,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       ast::ty_float. { typ = ty::mk_float(tcx); }\n       ast::ty_machine(tm) { typ = ty::mk_mach(tcx, tm); }\n       ast::ty_char. { typ = ty::mk_char(tcx); }\n-      ast::ty_istr. { typ = ty::mk_istr(tcx); }\n+      ast::ty_str. { typ = ty::mk_str(tcx); }\n       ast::ty_box(mt) {\n         typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n@@ -370,11 +370,10 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n           some(ast::def_ty_arg(id, k)) { typ = ty::mk_param(tcx, id, k); }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                ~\"found type name used as a variable\");\n+                                \"found type name used as a variable\");\n           }\n           _ {\n-            tcx.sess.span_fatal(\n-                ast_ty.span, ~\"internal error in instantiate\");\n+            tcx.sess.span_fatal(ast_ty.span, \"internal error in instantiate\");\n           }\n         }\n         cname = some(path_to_str(path));\n@@ -411,14 +410,12 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n       }\n       ast::ty_infer. {\n-        tcx.sess.span_bug(ast_ty.span, ~\"found ty_infer in unexpected place\");\n+        tcx.sess.span_bug(ast_ty.span, \"found ty_infer in unexpected place\");\n       }\n     }\n     alt cname {\n       none. {/* no-op */ }\n-      some(cname_str) {\n-        typ = ty::rename(tcx, typ, cname_str);\n-      }\n+      some(cname_str) { typ = ty::rename(tcx, typ, cname_str); }\n     }\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n     ret typ;\n@@ -590,10 +587,7 @@ mod collect {\n           some(ast_map::node_native_item(native_item)) {\n             tpt = ty_of_native_item(cx, native_item, ast::native_abi_cdecl);\n           }\n-          _ {\n-            cx.tcx.sess.fatal(\n-                ~\"internal error \" + std::int::str(id.node));\n-          }\n+          _ { cx.tcx.sess.fatal(\"internal error \" + std::int::str(id.node)); }\n         }\n         ret tpt;\n     }\n@@ -871,9 +865,9 @@ mod collect {\n         let visit =\n             visit::mk_simple_visitor(@{visit_item: bind convert(cx, abi, _),\n                                        visit_native_item:\n-                                       bind convert_native(cx, abi, _)\n-                                           with\n-                                           *visit::default_simple_visitor()});\n+                                           bind convert_native(cx, abi, _)\n+                                          with\n+                                          *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n     }\n }\n@@ -965,14 +959,13 @@ mod demand {\n        ty::t {\n         full(fcx, sp, expected, actual, [], false).ty\n     }\n-    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: ty::t,\n-                    actual: ty::t) -> ty::t {\n+    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t)\n+       -> ty::t {\n         full(fcx, sp, expected, actual, [], true).ty\n     }\n \n-    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: ty::t,\n-                   actual: ty::t, ty_param_substs_0: &[ty::t]) ->\n-       ty_param_substs_and_ty {\n+    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t,\n+                   ty_param_substs_0: &[ty::t]) -> ty_param_substs_and_ty {\n         full(fcx, sp, expected, actual, ty_param_substs_0, false)\n     }\n \n@@ -1013,14 +1006,12 @@ mod demand {\n           ures_err(err) {\n             let e_err = resolve_type_vars_if_possible(fcx, expected);\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n-            fcx.ccx.tcx.sess.span_err(\n-                sp,\n-                ~\"mismatched types: expected \" +\n-                ty_to_str(fcx.ccx.tcx, e_err) +\n-                ~\" but found \" +\n-                ty_to_str(fcx.ccx.tcx, a_err) + ~\" (\"\n-                + ty::type_err_to_str(err)\n-                + ~\")\");\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                                      \"mismatched types: expected \" +\n+                                          ty_to_str(fcx.ccx.tcx, e_err) +\n+                                          \" but found \" +\n+                                          ty_to_str(fcx.ccx.tcx, a_err) + \" (\"\n+                                          + ty::type_err_to_str(err) + \")\");\n             ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n@@ -1083,7 +1074,7 @@ mod writeback {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n             fcx.ccx.tcx.sess.span_err(sp,\n-                                      ~\"cannot determine a type \\\n+                                      \"cannot determine a type \\\n                                            for this expression\");\n             ret none;\n           }\n@@ -1135,7 +1126,7 @@ mod writeback {\n                 resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n           }\n-          _ {}\n+          _ { }\n         }\n         visit::visit_expr(e, wbcx, v);\n     }\n@@ -1159,7 +1150,7 @@ mod writeback {\n           fix_ok(lty) { write::ty_only(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n           fix_err(_) {\n             wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n-                                           ~\"cannot determine a type \\\n+                                           \"cannot determine a type \\\n                                                 for this local variable\");\n             wbcx.success = false;\n           }\n@@ -1307,7 +1298,7 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n // AST fragment checking\n fn check_lit(ccx: @crate_ctxt, lit: &@ast::lit) -> ty::t {\n     alt lit.node {\n-      ast::lit_str(_) { ret ty::mk_istr(ccx.tcx); }\n+      ast::lit_str(_) { ret ty::mk_str(ccx.tcx); }\n       ast::lit_char(_) { ret ty::mk_char(ccx.tcx); }\n       ast::lit_int(_) { ret ty::mk_int(ccx.tcx); }\n       ast::lit_float(_) { ret ty::mk_float(ccx.tcx); }\n@@ -1381,10 +1372,9 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                         #fmt[\"this pattern has %u field%s, but the \\\n                                        corresponding variant has %u field%s\",\n                              subpats_len,\n-                             if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n-                             arg_len, if arg_len == 1u { ~\"\" } else { ~\"s\" }];\n-                    fcx.ccx.tcx.sess.span_fatal(\n-                        pat.span, s);\n+                             if subpats_len == 1u { \"\" } else { \"s\" },\n+                             arg_len, if arg_len == 1u { \"\" } else { \"s\" }];\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                 }\n \n                 // TODO: vec::iter2\n@@ -1401,10 +1391,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                     #fmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n-                         subpats_len,\n-                         if subpats_len == 1u {\n-                             ~\"\"\n-                         } else { ~\"s\" }]);\n+                                                 subpats_len,\n+                                                 if subpats_len == 1u {\n+                                                     \"\"\n+                                                 } else { \"s\" }]);\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n@@ -1414,7 +1404,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n                 #fmt[\"mismatched types: expected %s, found tag\",\n-                     ty_to_str(fcx.ccx.tcx, expected)]);\n+                     ty_to_str(fcx.ccx.tcx,\n+                               expected)]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1427,7 +1418,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n                 #fmt[\"mismatched types: expected %s, found record\",\n-                     ty_to_str(fcx.ccx.tcx, expected)]);\n+                                             ty_to_str(fcx.ccx.tcx,\n+                                                       expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n@@ -1438,9 +1430,9 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     ex_f_count, f_count]);\n+                                             ex_f_count, f_count]);\n         }\n-        fn matches(name: &istr, f: &ty::field) -> bool {\n+        fn matches(name: &str, f: &ty::field) -> bool {\n             ret str::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n@@ -1464,7 +1456,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n                 #fmt[\"mismatched types: expected %s, found tuple\",\n-                     ty_to_str(fcx.ccx.tcx, expected)]);\n+                                             ty_to_str(fcx.ccx.tcx,\n+                                                       expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n@@ -1474,7 +1467,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                     vec::len(ex_elts), e_count]);\n+                                             vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n         for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n@@ -1487,11 +1480,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             write::ty_only_fixup(fcx, pat.id, expected);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected \" +\n-                ty_to_str(fcx.ccx.tcx, expected) +\n-                ~\" found box\");\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                                        \"mismatched types: expected \" +\n+                                            ty_to_str(fcx.ccx.tcx, expected) +\n+                                            \" found box\");\n           }\n         }\n       }\n@@ -1503,7 +1495,7 @@ fn require_impure(sess: &session::session, f_purity: &ast::purity,\n     alt f_purity {\n       ast::impure_fn. { ret; }\n       ast::pure_fn. {\n-        sess.span_fatal(sp, ~\"Found impure expression in pure function decl\");\n+        sess.span_fatal(sp, \"Found impure expression in pure function decl\");\n       }\n     }\n }\n@@ -1518,7 +1510,7 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n           _ {\n             ccx.tcx.sess.span_fatal(\n                 sp,\n-                ~\"Pure function calls function not known to be pure\");\n+                \"Pure function calls function not known to be pure\");\n           }\n         }\n       }\n@@ -1569,14 +1561,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             if call_kind != kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    ~\"calling iter outside of for each loop\");\n+                    \"calling iter outside of for each loop\");\n             }\n           }\n           _ {\n             if call_kind == kind_for_each {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    ~\"calling non-iter as sequence of for each loop\");\n+                    \"calling non-iter as sequence of for each loop\");\n             }\n           }\n         }\n@@ -1589,30 +1581,28 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 arg_tys\n               }\n               _ {\n-                fcx.ccx.tcx.sess.span_fatal(\n-                    f.span,\n-                    ~\"mismatched types: \\\n+                fcx.ccx.tcx.sess.span_fatal(f.span,\n+                                            \"mismatched types: \\\n                      expected function or native \\\n                      function but found \"\n-                    + ty_to_str(fcx.ccx.tcx, fty))\n+                                                + ty_to_str(fcx.ccx.tcx, fty))\n               }\n             };\n \n         // Check that the correct number of arguments were supplied.\n         let expected_arg_count = vec::len(arg_tys);\n         let supplied_arg_count = vec::len(args);\n         if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp,\n-                #fmt[\"this function takes %u \\\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                                      #fmt[\"this function takes %u \\\n                       parameter%s but %u parameter%s supplied\",\n-                      expected_arg_count,\n-                      if expected_arg_count == 1u {\n-                          ~\"\"\n-                      } else { ~\"s\" }, supplied_arg_count,\n-                      if supplied_arg_count == 1u {\n-                          ~\" was\"\n-                      } else { ~\"s were\" }]);\n+                                           expected_arg_count,\n+                                           if expected_arg_count == 1u {\n+                                               \"\"\n+                                           } else { \"s\" }, supplied_arg_count,\n+                                           if supplied_arg_count == 1u {\n+                                               \" was\"\n+                                           } else { \"s were\" }]);\n             // HACK: build an arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ty::mo_val, ty: ty::mk_bot(fcx.ccx.tcx)};\n@@ -1753,9 +1743,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let binopstr = ast_util::binop_to_str(binop);\n             let t_str = ty_to_str(fcx.ccx.tcx, resolved_t);\n             let errmsg =\n-                ~\"binary operation \" + binopstr +\n-                ~\" cannot be applied to type `\" +\n-                t_str + ~\"`\";\n+                \"binary operation \" + binopstr +\n+                    \" cannot be applied to type `\" + t_str + \"`\";\n             fcx.ccx.tcx.sess.span_err(span, errmsg);\n         }\n     }\n@@ -1804,41 +1793,39 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                        vec::len(variants[0].args) != 1u {\n                     tcx.sess.span_fatal(\n                         expr.span,\n-                        ~\"can only dereference tags \" +\n-                        ~\"with a single variant which has a \"\n-                        + ~\"single argument\");\n+                        \"can only dereference tags \" +\n+                        \"with a single variant which has a \"\n+                        + \"single argument\");\n                 }\n                 oper_t =\n                     ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n               }\n               ty::ty_ptr(inner) { oper_t = inner.ty; }\n               _ {\n-                tcx.sess.span_fatal(\n-                    expr.span,\n-                    ~\"dereferencing non-\" +\n-                    ~\"dereferenceable type: \" +\n-                    ty_to_str(tcx, oper_t));\n+                tcx.sess.span_fatal(expr.span,\n+                                    \"dereferencing non-\" +\n+                                        \"dereferenceable type: \" +\n+                                        ty_to_str(tcx, oper_t));\n               }\n             }\n           }\n           ast::not. {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n-                tcx.sess.span_err(\n-                    expr.span,\n-                    #fmt[\"mismatched types: expected bool \\\n+                tcx.sess.span_err(expr.span,\n+                                  #fmt[\"mismatched types: expected bool \\\n                           or integer but found %s\",\n-                         ty_to_str(tcx, oper_t)]);\n+                                       ty_to_str(tcx, oper_t)]);\n             }\n           }\n           ast::neg. {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n                      ty::type_is_fp(tcx, oper_t)) {\n                 tcx.sess.span_err(expr.span,\n-                                  ~\"applying unary minus to \\\n+                                  \"applying unary minus to \\\n                    non-numeric type \"\n-                                  + ty_to_str(tcx, oper_t));\n+                                      + ty_to_str(tcx, oper_t));\n             }\n           }\n         }\n@@ -1855,20 +1842,18 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             // supplied some, that's an error.\n             if vec::len::<@ast::ty>(pth.node.types) > 0u {\n                 tcx.sess.span_fatal(expr.span,\n-                                    ~\"this kind of value does not \\\n+                                    \"this kind of value does not \\\n                                      take type parameters\");\n             }\n             write::ty_only_fixup(fcx, id, tpt.ty);\n         }\n       }\n-      ast::expr_mac(_) { tcx.sess.bug(~\"unexpanded macro\"); }\n+      ast::expr_mac(_) { tcx.sess.bug(\"unexpanded macro\"); }\n       ast::expr_fail(expr_opt) {\n         bot = true;\n         alt expr_opt {\n           none. {/* do nothing */ }\n-          some(e) {\n-            check_expr_with(fcx, e, ty::mk_istr(tcx));\n-          }\n+          some(e) { check_expr_with(fcx, e, ty::mk_str(tcx)); }\n         }\n         write::bot_ty(tcx, id);\n       }\n@@ -1881,7 +1866,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n-                                  ~\"ret; in function returning non-nil\");\n+                                  \"ret; in function returning non-nil\");\n             }\n           }\n           some(e) { check_expr_with(fcx, e, fcx.ret_ty); }\n@@ -1891,14 +1876,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n       ast::expr_put(expr_opt) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         if fcx.proto != ast::proto_iter {\n-            tcx.sess.span_err(expr.span, ~\"put in non-iterator\");\n+            tcx.sess.span_err(expr.span, \"put in non-iterator\");\n         }\n         alt expr_opt {\n           none. {\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n-                                  ~\"put; in iterator yielding non-nil\");\n+                                  \"put; in iterator yielding non-nil\");\n             }\n           }\n           some(e) { bot = check_expr_with(fcx, e, fcx.ret_ty); }\n@@ -1967,12 +1952,12 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n-          ty::ty_istr. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n+          ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           _ {\n             tcx.sess.span_fatal(\n                 expr.span,\n-                ~\"mismatched types: expected vector or string but \"\n-                + ~\"found \" + ty_to_str(tcx, ety));\n+                \"mismatched types: expected vector or string but \"\n+                + \"found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -1986,7 +1971,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n-                                ~\"sequence in for each loop not a call\");\n+                                \"sequence in for each loop not a call\");\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq), body, id);\n@@ -2017,10 +2002,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let arm_non_bot = false;\n         for arm: ast::arm in arms {\n             alt arm.guard {\n-              some(e) {\n-                check_expr_with(fcx, e, ty::mk_bool(tcx));\n-              }\n-              none. {}\n+              some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n+              none. { }\n             }\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n             let bty = block_ty(tcx, arm.body);\n@@ -2054,10 +2037,11 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n       }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking\n-        let fcx_for_block = alt b.node.rules {\n-          ast::unchecked. { @{ purity: ast::impure_fn with *fcx } }\n-          _               { fcx }\n-        };\n+        let fcx_for_block =\n+            alt b.node.rules {\n+              ast::unchecked. { @{purity: ast::impure_fn with *fcx} }\n+              _ { fcx }\n+            };\n         bot = check_block(fcx_for_block, b);\n         let typ =\n             alt b.node.expr {\n@@ -2124,9 +2108,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                     this_obj_sty = some(structure_of(fcx, expr.span, tpt.ty));\n                   }\n                   none. {\n-                    tcx.sess.bug(~\"didn't find \" +\n-                                 int::str(did.node) +\n-                                 ~\" in type cache\");\n+                    tcx.sess.bug(\"didn't find \" + int::str(did.node) +\n+                                     \" in type cache\");\n                   }\n                 }\n               }\n@@ -2135,7 +2118,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           }\n           none. {\n             // Shouldn't happen.\n-            tcx.sess.span_err(expr.span, ~\"self-call in non-object context\");\n+            tcx.sess.span_err(expr.span, \"self-call in non-object context\");\n           }\n         }\n \n@@ -2166,10 +2149,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         if !(type_is_scalar(fcx, expr.span, expr_ty(tcx, e)) &&\n                  type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n-                              ~\"non-scalar cast: \" +\n-                              ty_to_str(tcx, expr_ty(tcx, e))\n-                              + ~\" as \" +\n-                              ty_to_str(tcx, t_1));\n+                              \"non-scalar cast: \" +\n+                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_1));\n         }\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n@@ -2217,7 +2199,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n                 tcx.sess.span_fatal(expr.span,\n-                                    ~\"record update has non-record base\");\n+                                    \"record update has non-record base\");\n               }\n             }\n             write::ty_only_fixup(fcx, id, bexpr_t);\n@@ -2231,8 +2213,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n-                                        ~\"unknown field in record update: \" +\n-                                        f.node.ident);\n+                                        \"unknown field in record update: \" +\n+                                            f.node.ident);\n                 }\n             }\n           }\n@@ -2246,15 +2228,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           ty::ty_rec(fields) {\n             let ix: uint = ty::field_idx(tcx.sess, expr.span, field, fields);\n             if ix >= vec::len::<ty::field>(fields) {\n-                tcx.sess.span_fatal(expr.span, ~\"bad index on record\");\n+                tcx.sess.span_fatal(expr.span, \"bad index on record\");\n             }\n             write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n                 ty::method_idx(tcx.sess, expr.span, field, methods);\n             if ix >= vec::len::<ty::method>(methods) {\n-                tcx.sess.span_fatal(expr.span, ~\"bad index on obj\");\n+                tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n             }\n             let meth = methods[ix];\n             let t =\n@@ -2279,20 +2261,20 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let idx_t = expr_ty(tcx, idx);\n         if !type_is_integral(fcx, idx.span, idx_t) {\n             tcx.sess.span_err(idx.span,\n-                              ~\"mismatched types: expected \\\n+                              \"mismatched types: expected \\\n                                integer but found \"\n-                              + ty_to_str(tcx, idx_t));\n+                                  + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n-          ty::ty_istr. {\n+          ty::ty_str. {\n             let typ = ty::mk_mach(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n-                                ~\"vector-indexing bad type: \" +\n-                                ty_to_str(tcx, base_t));\n+                                \"vector-indexing bad type: \" +\n+                                    ty_to_str(tcx, base_t));\n           }\n         }\n       }\n@@ -2362,9 +2344,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         // The user is trying to extend a non-object.\n                         tcx.sess.span_fatal(\n                             e.span,\n-                                syntax::print::pprust::expr_to_str(e)\n+                            syntax::print::pprust::expr_to_str(e)\n                             +\n-                            ~\" does not have object type\");\n+                            \" does not have object type\");\n                       }\n                     }\n                   }\n@@ -2391,9 +2373,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         if new_type != m {\n                             ccx.tcx.sess.span_fatal(\n                                 om.span,\n-                                ~\"Attempted to override method \"\n+                                \"Attempted to override method \"\n                                 + m.ident +\n-                                ~\" with one of a different type\");\n+                                \" with one of a different type\");\n                         }\n                         ret none;\n                     }\n@@ -2435,7 +2417,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         check_expr_with(fcx, x, t);\n         write::ty_only_fixup(fcx, id, ty::mk_uniq(tcx, t));\n       }\n-      _ { tcx.sess.unimpl(~\"expr type in typeck::check_expr\"); }\n+      _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n     if bot { write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx)); }\n \n@@ -2468,8 +2450,8 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n \n     alt fcx.locals.find(local.node.id) {\n       none. {\n-        fcx.ccx.tcx.sess.bug(~\"check_decl_local: local id not found \" +\n-                             ident_for_local(local));\n+        fcx.ccx.tcx.sess.bug(\"check_decl_local: local id not found \" +\n+                                 ident_for_local(local));\n       }\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n@@ -2518,7 +2500,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n                  }\n                  _ { false }\n                } {\n-            fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n+            fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n             warned = true;\n         }\n         bot |= check_stmt(fcx, s);\n@@ -2527,7 +2509,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n       none. { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n       some(e) {\n         if bot && !warned {\n-            fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n+            fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n         }\n         bot |= check_expr(fcx, e);\n         let ety = expr_ty(fcx.ccx.tcx, e);\n@@ -2569,8 +2551,9 @@ fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n     alt e.node {\n       ast::expr_call(operator, operands) {\n         if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n-            fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                 ~\"Operator in constraint has non-boolean return type\");\n+            fcx.ccx.tcx.sess.span_fatal(\n+                operator.span,\n+                \"Operator in constraint has non-boolean return type\");\n         }\n \n         alt operator.node {\n@@ -2581,85 +2564,91 @@ fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n               }\n               _ {\n                 fcx.ccx.tcx.sess.span_fatal(operator.span,\n-                                            ~\"Impure function as operator \\\n+                                            \"Impure function as operator \\\n in constraint\");\n               }\n             }\n             for operand: @ast::expr in operands {\n                 if !ast_util::is_constraint_arg(operand) {\n                     let s =\n-                        ~\"Constraint args must be \\\n+                        \"Constraint args must be \\\n slot variables or literals\";\n                     fcx.ccx.tcx.sess.span_fatal(e.span, s);\n                 }\n             }\n           }\n           _ {\n             let s =\n-                ~\"In a constraint, expected the \\\n+                \"In a constraint, expected the \\\n constraint name to be an explicit name\";\n             fcx.ccx.tcx.sess.span_fatal(e.span, s);\n           }\n         }\n       }\n-      _ { fcx.ccx.tcx.sess.span_fatal(\n-          e.span, ~\"check on non-predicate\"); }\n+      _ { fcx.ccx.tcx.sess.span_fatal(e.span, \"check on non-predicate\"); }\n     }\n     ret bot;\n }\n \n-fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args:[ast::arg]) {\n+fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     let c_args;\n     let num_args = vec::len(args);\n     for c: @ast::constr in cs {\n         c_args = [];\n         for a: @spanned<ast::fn_constr_arg> in c.node.args {\n-            c_args += [@(alt a.node {\n-              ast::carg_base. {\n-                // \"base\" should not occur in a fn type thing, as of\n-                // yet, b/c we don't allow constraints on the return type\n-\n-                fcx.ccx.tcx.sess.span_bug(a.span, ~\"check_constraints:\\\n+            c_args +=\n+                [\n+                 // \"base\" should not occur in a fn type thing, as of\n+                 // yet, b/c we don't allow constraints on the return type\n+\n+                 // Works b/c no higher-order polymorphism\n+                 /*\n+                 This is kludgy, and we probably shouldn't be assigning\n+                 node IDs here, but we're creating exprs that are\n+                 ephemeral, just for the purposes of typechecking. So\n+                 that's my justification.\n+                 */\n+                 @alt a.node {\n+                    ast::carg_base. {\n+                      fcx.ccx.tcx.sess.span_bug(a.span,\n+                                                \"check_constraints:\\\n                     unexpected carg_base\");\n-              }\n-              ast::carg_lit(l) {\n-                let tmp_node_id = fcx.ccx.tcx.sess.next_node_id();\n-                {id:tmp_node_id, node: ast::expr_lit(l), span:a.span} }\n-              ast::carg_ident(i) {\n-                if i < num_args {\n-                    let p : ast::path_ =\n-                        {global:false, idents:[(args[i]).ident],\n-                         // Works b/c no higher-order polymorphism\n-                         types:[]};\n-                    /*\n-                    This is kludgy, and we probably shouldn't be assigning\n-                    node IDs here, but we're creating exprs that are\n-                    ephemeral, just for the purposes of typechecking. So\n-                    that's my justification.\n-                    */\n-                    let arg_occ_node_id = fcx.ccx.tcx.sess.next_node_id();\n-                    fcx.ccx.tcx.def_map.insert\n-                        (arg_occ_node_id, ast::def_arg(local_def(args[i].id),\n-                                                       args[i].mode));\n-                    {id:arg_occ_node_id,\n-                     node: ast::expr_path(respan(a.span, p)),\n-                     span:a.span}\n-                }\n-                else {\n-                    fcx.ccx.tcx.sess.span_bug(a.span, ~\"check_constraints:\\\n+                    }\n+                    ast::carg_lit(l) {\n+                      let tmp_node_id = fcx.ccx.tcx.sess.next_node_id();\n+                      {id: tmp_node_id, node: ast::expr_lit(l), span: a.span}\n+                    }\n+                    ast::carg_ident(i) {\n+                      if i < num_args {\n+                          let p: ast::path_ =\n+                              {global: false,\n+                               idents: [args[i].ident],\n+                               types: []};\n+                          let arg_occ_node_id =\n+                              fcx.ccx.tcx.sess.next_node_id();\n+                          fcx.ccx.tcx.def_map.insert(\n+                              arg_occ_node_id,\n+                              ast::def_arg(local_def(args[i].id),\n+                                           args[i].mode));\n+                          {id: arg_occ_node_id,\n+                           node: ast::expr_path(respan(a.span, p)),\n+                           span: a.span}\n+                      } else {\n+                          fcx.ccx.tcx.sess.span_bug(a.span,\n+                                                    \"check_constraints:\\\n                      carg_ident index out of bounds\");\n-                }\n-              }\n-            })]\n+                      }\n+                    }\n+                  }]\n         }\n         let p_op: ast::expr_ = ast::expr_path(c.node.path);\n-        let oper: @ast::expr = @{id:c.node.id,\n-                                 node: p_op, span:c.span};\n+        let oper: @ast::expr = @{id: c.node.id, node: p_op, span: c.span};\n         // Another ephemeral expr\n         let call_expr_id = fcx.ccx.tcx.sess.next_node_id();\n-        let call_expr = @{id: call_expr_id,\n-                          node: ast::expr_call(oper, c_args),\n-                          span: c.span};\n+        let call_expr =\n+            @{id: call_expr_id,\n+              node: ast::expr_call(oper, c_args),\n+              span: c.span};\n         check_pred_expr(fcx, call_expr);\n     }\n }\n@@ -2688,14 +2677,14 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     // function result type, if there is a tail expr.\n     // We don't do this check for an iterator, as the tail expr doesn't\n     // have to have the result type of the iterator.\n-    alt (body.node.expr) {\n+    alt body.node.expr {\n       some(tail_expr) {\n         if f.proto != ast::proto_iter {\n             let tail_expr_ty = expr_ty(ccx.tcx, tail_expr);\n             demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n         }\n       }\n-      none. {}\n+      none. { }\n     }\n \n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n@@ -2742,7 +2731,7 @@ fn arg_is_argv_ty(tcx: &ty::ctxt, a: &ty::arg) -> bool {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm { ret false; }\n         alt ty::struct(tcx, mt.ty) {\n-          ty::ty_istr. { ret true; }\n+          ty::ty_str. { ret true; }\n           _ { ret false; }\n         }\n       }\n@@ -2762,15 +2751,15 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n         if !ok {\n             let span = ast_map::node_span(tcx.items.get(main_id));\n             tcx.sess.span_err(span,\n-                              ~\"wrong type in main function: found \" +\n-                              ty_to_str(tcx, main_t));\n+                              \"wrong type in main function: found \" +\n+                                  ty_to_str(tcx, main_t));\n         }\n       }\n       _ {\n         let span = ast_map::node_span(tcx.items.get(main_id));\n         tcx.sess.span_bug(span,\n-                          ~\"main has a non-function type: found\" +\n-                          ty_to_str(tcx, main_t));\n+                          \"main has a non-function type: found\" +\n+                              ty_to_str(tcx, main_t));\n       }\n     }\n }\n@@ -2779,7 +2768,7 @@ fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n     if !tcx.sess.get_opts().library {\n         alt tcx.sess.get_main_id() {\n           some(id) { check_main_fn_ty(tcx, id); }\n-          none. { tcx.sess.span_err(crate.span, ~\"main function not found\"); }\n+          none. { tcx.sess.span_err(crate.span, \"main function not found\"); }\n         }\n     }\n }"}, {"sha": "aecd78262ef15bee06df798e8724cdf6bb503cc2", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,7 +6,7 @@ import codemap::filename;\n \n type spanned<T> = {node: T, span: span};\n \n-type ident = istr;\n+type ident = str;\n \n // Functions may or may not have names.\n type fn_ident = option::t<ident>;\n@@ -43,7 +43,7 @@ tag def {\n     def_use(def_id);\n     def_native_ty(def_id);\n     def_native_fn(def_id);\n-    def_upvar(def_id, @def, bool /* writable */);\n+    def_upvar(def_id, @def, /* writable */bool);\n }\n \n // The set of meta_items that define the compilation environment of the crate,\n@@ -78,8 +78,8 @@ tag meta_item_ {\n \n type blk = spanned<blk_>;\n \n-type blk_ = {stmts: [@stmt], expr: option::t<@expr>,\n-    id: node_id, rules: check_mode};\n+type blk_ =\n+    {stmts: [@stmt], expr: option::t<@expr>, id: node_id, rules: check_mode};\n \n type pat = {id: node_id, node: pat_, span: span};\n \n@@ -229,7 +229,7 @@ tag blk_sort {\n type mac = spanned<mac_>;\n \n tag mac_ {\n-    mac_invoc(path, @expr, option::t<istr>);\n+    mac_invoc(path, @expr, option::t<str>);\n     mac_embed_type(@ty);\n     mac_embed_block(blk);\n     mac_ellipsis;\n@@ -238,13 +238,13 @@ tag mac_ {\n type lit = spanned<lit_>;\n \n tag lit_ {\n-    lit_str(istr);\n+    lit_str(str);\n     lit_char(char);\n     lit_int(int);\n     lit_uint(uint);\n     lit_mach_int(ty_mach, int);\n-    lit_float(istr);\n-    lit_mach_float(ty_mach, istr);\n+    lit_float(str);\n+    lit_mach_float(ty_mach, str);\n     lit_nil;\n     lit_bool(bool);\n }\n@@ -292,6 +292,7 @@ tag ty_ {\n              ret/fail/break/cont. there is no syntax\n              for this type. */\n \n+\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n@@ -301,7 +302,7 @@ tag ty_ {\n     ty_float;\n     ty_machine(ty_mach);\n     ty_char;\n-    ty_istr;\n+    ty_str;\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ptr(mt);\n@@ -379,6 +380,7 @@ tag controlflow {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n \n+\n     return; // everything else\n }\n \n@@ -412,7 +414,7 @@ tag native_abi {\n }\n \n type native_mod =\n-    {native_name: istr,\n+    {native_name: str,\n      abi: native_abi,\n      view_items: [@view_item],\n      items: [@native_item]};\n@@ -467,9 +469,11 @@ tag item_ {\n     item_tag([variant], [ty_param]);\n     item_obj(_obj, [ty_param], /* constructor id */node_id);\n     item_res(_fn,\n-              /* dtor */\n+\n+             /* dtor */\n              node_id,\n-              /* dtor id */\n+\n+             /* dtor id */\n              [ty_param],\n \n              /* ctor id */\n@@ -485,7 +489,7 @@ type native_item =\n \n tag native_item_ {\n     native_item_ty;\n-    native_item_fn(option::t<istr>, fn_decl, [ty_param]);\n+    native_item_fn(option::t<str>, fn_decl, [ty_param]);\n }\n \n //"}, {"sha": "c5d769c12996a3e26f543df7631512a5d73e2f92", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -13,11 +13,9 @@ fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n-fn path_name(p: &path) -> istr { path_name_i(p.node.idents) }\n+fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n \n-fn path_name_i(idents: &[ident]) -> istr {\n-    str::connect(idents, ~\"::\")\n-}\n+fn path_name_i(idents: &[ident]) -> str { str::connect(idents, \"::\") }\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n@@ -45,7 +43,7 @@ fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-type pat_id_map = std::map::hashmap<istr, node_id>;\n+type pat_id_map = std::map::hashmap<str, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n@@ -82,59 +80,59 @@ fn pat_binding_ids(pat: &@pat) -> [node_id] {\n     ret found;\n }\n \n-fn binop_to_str(op: binop) -> istr {\n+fn binop_to_str(op: binop) -> str {\n     alt op {\n-      add. { ret ~\"+\"; }\n-      sub. { ret ~\"-\"; }\n-      mul. { ret ~\"*\"; }\n-      div. { ret ~\"/\"; }\n-      rem. { ret ~\"%\"; }\n-      and. { ret ~\"&&\"; }\n-      or. { ret ~\"||\"; }\n-      bitxor. { ret ~\"^\"; }\n-      bitand. { ret ~\"&\"; }\n-      bitor. { ret ~\"|\"; }\n-      lsl. { ret ~\"<<\"; }\n-      lsr. { ret ~\">>\"; }\n-      asr. { ret ~\">>>\"; }\n-      eq. { ret ~\"==\"; }\n-      lt. { ret ~\"<\"; }\n-      le. { ret ~\"<=\"; }\n-      ne. { ret ~\"!=\"; }\n-      ge. { ret ~\">=\"; }\n-      gt. { ret ~\">\"; }\n+      add. { ret \"+\"; }\n+      sub. { ret \"-\"; }\n+      mul. { ret \"*\"; }\n+      div. { ret \"/\"; }\n+      rem. { ret \"%\"; }\n+      and. { ret \"&&\"; }\n+      or. { ret \"||\"; }\n+      bitxor. { ret \"^\"; }\n+      bitand. { ret \"&\"; }\n+      bitor. { ret \"|\"; }\n+      lsl. { ret \"<<\"; }\n+      lsr. { ret \">>\"; }\n+      asr. { ret \">>>\"; }\n+      eq. { ret \"==\"; }\n+      lt. { ret \"<\"; }\n+      le. { ret \"<=\"; }\n+      ne. { ret \"!=\"; }\n+      ge. { ret \">=\"; }\n+      gt. { ret \">\"; }\n     }\n }\n \n pure fn lazy_binop(b: binop) -> bool {\n     alt b { and. { true } or. { true } _ { false } }\n }\n \n-fn unop_to_str(op: unop) -> istr {\n+fn unop_to_str(op: unop) -> str {\n     alt op {\n-      box(mt) { if mt == mut { ret ~\"@mutable \"; } ret ~\"@\"; }\n-      deref. { ret ~\"*\"; }\n-      not. { ret ~\"!\"; }\n-      neg. { ret ~\"-\"; }\n+      box(mt) { if mt == mut { ret \"@mutable \"; } ret \"@\"; }\n+      deref. { ret \"*\"; }\n+      not. { ret \"!\"; }\n+      neg. { ret \"-\"; }\n     }\n }\n \n fn is_path(e: &@expr) -> bool {\n     ret alt e.node { expr_path(_) { true } _ { false } };\n }\n \n-fn ty_mach_to_str(tm: ty_mach) -> istr {\n+fn ty_mach_to_str(tm: ty_mach) -> str {\n     alt tm {\n-      ty_u8. { ret ~\"u8\"; }\n-      ty_u16. { ret ~\"u16\"; }\n-      ty_u32. { ret ~\"u32\"; }\n-      ty_u64. { ret ~\"u64\"; }\n-      ty_i8. { ret ~\"i8\"; }\n-      ty_i16. { ret ~\"i16\"; }\n-      ty_i32. { ret ~\"i32\"; }\n-      ty_i64. { ret ~\"i64\"; }\n-      ty_f32. { ret ~\"f32\"; }\n-      ty_f64. { ret ~\"f64\"; }\n+      ty_u8. { ret \"u8\"; }\n+      ty_u16. { ret \"u16\"; }\n+      ty_u32. { ret \"u32\"; }\n+      ty_u64. { ret \"u64\"; }\n+      ty_i8. { ret \"i8\"; }\n+      ty_i16. { ret \"i16\"; }\n+      ty_i32. { ret \"i32\"; }\n+      ty_i64. { ret \"i64\"; }\n+      ty_f32. { ret \"f32\"; }\n+      ty_f64. { ret \"f64\"; }\n     }\n }\n \n@@ -190,8 +188,8 @@ fn block_from_expr(e: @expr) -> blk {\n     ret {node: blk_, span: e.span};\n }\n \n-fn checked_blk(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id)\n-    -> blk_ {\n+fn checked_blk(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n+   blk_ {\n     ret {stmts: stmts1, expr: expr1, id: id1, rules: checked};\n }\n "}, {"sha": "edb414b4e9b57a126ff096396c5b67a7254f0ea0", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,7 +7,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n \n-type filename = istr;\n+type filename = str;\n \n type file_pos = {ch: uint, byte: uint};\n \n@@ -66,46 +66,45 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n }\n \n tag opt_span {\n-     //hack (as opposed to option::t), to make `span` compile\n+\n+    //hack (as opposed to option::t), to make `span` compile\n     os_none;\n     os_some(@span);\n }\n type span = {lo: uint, hi: uint, expanded_from: opt_span};\n \n-fn span_to_str(sp: &span, cm: &codemap) -> istr {\n+fn span_to_str(sp: &span, cm: &codemap) -> str {\n     let cur = sp;\n-    let res = ~\"\";\n+    let res = \"\";\n     let prev_file = none;\n     while true {\n         let lo = lookup_char_pos(cm, cur.lo);\n         let hi = lookup_char_pos(cm, cur.hi);\n         res +=\n             #fmt[\"%s:%u:%u: %u:%u\",\n                  if some(lo.filename) == prev_file {\n-                     ~\"-\"\n-                 } else {\n-                     lo.filename\n-                 }, lo.line, lo.col, hi.line, hi.col];\n+                     \"-\"\n+                 } else { lo.filename }, lo.line, lo.col, hi.line, hi.col];\n         alt cur.expanded_from {\n           os_none. { break; }\n           os_some(new_sp) {\n             cur = *new_sp;\n             prev_file = some(lo.filename);\n-            res += ~\"<<\";\n+            res += \"<<\";\n           }\n         }\n     }\n \n     ret res;\n }\n \n-fn emit_diagnostic(sp: &option::t<span>, msg: &istr, kind: &istr, color: u8,\n+fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n                    cm: &codemap) {\n-    let ss = ~\"\";\n+    let ss = \"\";\n     let maybe_lines: option::t<@file_lines> = none;\n     alt sp {\n       some(ssp) {\n-        ss = span_to_str(ssp, cm) + ~\" \";\n+        ss = span_to_str(ssp, cm) + \" \";\n         maybe_lines = some(span_to_lines(ssp, cm));\n       }\n       none. { }\n@@ -114,9 +113,9 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &istr, kind: &istr, color: u8,\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(#fmt[~\"%s:\", kind]);\n+    io::stdout().write_str(#fmt[\"%s:\", kind]);\n     if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n-    io::stdout().write_str(#fmt[~\" %s\\n\", msg]);\n+    io::stdout().write_str(#fmt[\" %s\\n\", msg]);\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -128,7 +127,7 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n       some(lines) {\n         // If we're not looking at a real file then we can't re-open it to\n         // pull out the lines\n-        if lines.name == ~\"-\" { ret; }\n+        if lines.name == \"-\" { ret; }\n \n         // FIXME: reading in the entire file is the worst possible way to\n         //        get access to the necessary lines.\n@@ -145,19 +144,18 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         }\n         // Print the offending lines\n         for line: uint in display_lines {\n-            io::stdout().write_str(\n-                #fmt[~\"%s:%u \", fm.name, line + 1u]);\n+            io::stdout().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n             let s = get_line(fm, line as int, file);\n-            if !str::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n+            if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n             io::stdout().write_str(s);\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n-            let s = #fmt[~\"%s:%u \", fm.name, last_line + 1u];\n+            let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n             let indent = str::char_len(s);\n-            let out = ~\"\";\n-            while indent > 0u { out += ~\" \"; indent -= 1u; }\n-            out += ~\"...\\n\";\n+            let out = \"\";\n+            while indent > 0u { out += \" \"; indent -= 1u; }\n+            out += \"...\\n\";\n             io::stdout().write_str(out);\n         }\n \n@@ -173,34 +171,34 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n \n             // indent past |name:## | and the 0-offset column location\n             let left = str::char_len(fm.name) + digits + lo.col + 3u;\n-            let s = ~\"\";\n+            let s = \"\";\n             while left > 0u { str::push_char(s, ' '); left -= 1u; }\n \n-            s += ~\"^\";\n+            s += \"^\";\n             let hi = lookup_char_pos(cm, option::get(sp).hi);\n             if hi.col != lo.col {\n                 // the ^ already takes up one space\n                 let width = hi.col - lo.col - 1u;\n                 while width > 0u { str::push_char(s, '~'); width -= 1u; }\n             }\n-            io::stdout().write_str(s + ~\"\\n\");\n+            io::stdout().write_str(s + \"\\n\");\n         }\n       }\n       _ { }\n     }\n }\n \n-fn emit_warning(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n-    emit_diagnostic(sp, msg, ~\"warning\", 11u8, cm);\n+fn emit_warning(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+    emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n }\n-fn emit_error(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n-    emit_diagnostic(sp, msg, ~\"error\", 9u8, cm);\n+fn emit_error(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+    emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n }\n-fn emit_note(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n-    emit_diagnostic(sp, msg, ~\"note\", 10u8, cm);\n+fn emit_note(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+    emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n }\n \n-type file_lines = {name: istr, lines: [uint]};\n+type file_lines = {name: str, lines: [uint]};\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n@@ -212,7 +210,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     ret @{name: lo.filename, lines: lines};\n }\n \n-fn get_line(fm: filemap, line: int, file: &istr) -> istr {\n+fn get_line(fm: filemap, line: int, file: &str) -> str {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end: uint;\n     if line as uint < vec::len(fm.lines) - 1u {\n@@ -229,10 +227,8 @@ fn get_line(fm: filemap, line: int, file: &istr) -> istr {\n     ret str::slice(file, begin, end);\n }\n \n-fn get_filemap(cm: codemap, filename: istr) -> filemap {\n-    for fm: filemap in cm.files {\n-        if fm.name == filename { ret fm; }\n-    }\n+fn get_filemap(cm: codemap, filename: str) -> filemap {\n+    for fm: filemap in cm.files { if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "298f90237bcd22bc6f0a010a4fad600405aeae19", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,10 +8,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn(&ext_ctxt, span, @ast::expr, &option::t<istr>) -> @ast::expr;\n-type macro_def = {ident: istr, ext: syntax_extension};\n+    fn(&ext_ctxt, span, @ast::expr, &option::t<str>) -> @ast::expr;\n+type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn(&ext_ctxt, span, @ast::expr, &option::t<istr>) -> macro_def;\n+    fn(&ext_ctxt, span, @ast::expr, &option::t<str>) -> macro_def;\n \n tag syntax_extension {\n     normal(syntax_expander);\n@@ -20,25 +20,25 @@ tag syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-fn syntax_expander_table() -> hashmap<istr, syntax_extension> {\n+fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n     let syntax_expanders = new_str_hash::<syntax_extension>();\n-    syntax_expanders.insert(~\"fmt\", normal(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(~\"env\", normal(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(~\"macro\",\n+    syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));\n-    syntax_expanders.insert(~\"concat_idents\",\n+    syntax_expanders.insert(\"concat_idents\",\n                             normal(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ident_to_str\",\n+    syntax_expanders.insert(\"ident_to_str\",\n                             normal(ext::ident_to_str::expand_syntax_ext));\n-    syntax_expanders.insert(~\"log_syntax\",\n+    syntax_expanders.insert(\"log_syntax\",\n                             normal(ext::log_syntax::expand_syntax_ext));\n     ret syntax_expanders;\n }\n \n obj ext_ctxt(sess: @session,\n-             crate_file_name_hack: istr,\n+             crate_file_name_hack: str,\n              mutable backtrace: codemap::opt_span) {\n-    fn crate_file_name() -> istr { ret crate_file_name_hack; }\n+    fn crate_file_name() -> str { ret crate_file_name_hack; }\n \n     fn session() -> @session { ret sess; }\n \n@@ -58,30 +58,27 @@ obj ext_ctxt(sess: @session,\n             let tmp = pre;\n             backtrace = tmp;\n           }\n-          _ { self.bug(~\"tried to pop without a push\"); }\n+          _ { self.bug(\"tried to pop without a push\"); }\n         }\n     }\n \n-    fn span_fatal(sp: span, msg: istr) -> ! {\n+    fn span_fatal(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n         sess.span_fatal(sp, msg);\n     }\n-    fn span_err(sp: span, msg: istr) {\n+    fn span_err(sp: span, msg: str) {\n         self.print_backtrace();\n         sess.span_err(sp, msg);\n     }\n-    fn span_unimpl(sp: span, msg: istr) -> ! {\n+    fn span_unimpl(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n         sess.span_unimpl(sp, msg);\n     }\n-    fn span_bug(sp: span, msg: istr) -> ! {\n+    fn span_bug(sp: span, msg: str) -> ! {\n         self.print_backtrace();\n         sess.span_bug(sp, msg);\n     }\n-    fn bug(msg: istr) -> ! {\n-        self.print_backtrace();\n-        sess.bug(msg);\n-    }\n+    fn bug(msg: str) -> ! { self.print_backtrace(); sess.bug(msg); }\n     fn next_id() -> ast::node_id { ret sess.next_node_id(); }\n \n }\n@@ -96,11 +93,10 @@ fn mk_ctxt(sess: &session) -> ext_ctxt {\n     // super-ugly and needs a better solution.\n     let crate_file_name_hack = sess.get_codemap().files[0].name;\n \n-    ret ext_ctxt(@sess, crate_file_name_hack,\n-                 codemap::os_none);\n+    ret ext_ctxt(@sess, crate_file_name_hack, codemap::os_none);\n }\n \n-fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &istr) -> istr {\n+fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> str {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n@@ -112,8 +108,7 @@ fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &istr) -> istr {\n     }\n }\n \n-fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr,\n-                 error: &istr) -> ast::ident {\n+fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n         if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {"}, {"sha": "53ee6cb03979514c066a26474f8d42cc21eafa5f", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,17 +3,17 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n+                     _body: &option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, ~\"#concat_idents requires a vector argument .\")\n+            cx.span_fatal(sp, \"#concat_idents requires a vector argument .\")\n           }\n         };\n-    let res: ast::ident = ~\"\";\n+    let res: ast::ident = \"\";\n     for e: @ast::expr in args {\n-        res += expr_to_ident(cx, e, ~\"expected an ident\");\n+        res += expr_to_ident(cx, e, \"expected an ident\");\n     }\n \n     ret @{id: cx.next_id(),"}, {"sha": "081bfd80c1d2236357535d69171c077472f4f090", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,30 +12,28 @@ import base::*;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n+                     _body: &option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, ~\"#env requires arguments of the form `[...]`.\")\n+            cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) != 1u {\n-        cx.span_fatal(sp, ~\"malformed #env call\");\n+        cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n+    let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt generic_os::getenv(var) {\n-      option::none. { ret make_new_str(cx, sp, ~\"\"); }\n-      option::some(s) {\n-        ret make_new_str(cx, sp, s);\n-      }\n+      option::none. { ret make_new_str(cx, sp, \"\"); }\n+      option::some(s) { ret make_new_str(cx, sp, s); }\n     }\n }\n \n-fn make_new_str(cx: &ext_ctxt, sp: codemap::span, s: &istr) -> @ast::expr {\n+fn make_new_str(cx: &ext_ctxt, sp: codemap::span, s: &str) -> @ast::expr {\n     ret make_new_lit(cx, sp, ast::lit_str(s));\n }\n //"}, {"sha": "7037139bd932be84a7b82269dcbd424cf41e6d0b", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -15,7 +15,7 @@ import syntax::fold::*;\n import syntax::ext::base::*;\n \n \n-fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n+fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n                e: &expr_, fld: ast_fold, orig: &fn(&expr_, ast_fold) -> expr_)\n    -> expr_ {\n     ret alt e {\n@@ -27,8 +27,7 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                 alt exts.find(extname) {\n                   none. {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"macro undefined: '%s'\",\n-                                       extname])\n+                                  #fmt[\"macro undefined: '%s'\", extname])\n                   }\n                   some(normal(ext)) {\n                     let expanded = ext(cx, pth.span, args, body);\n@@ -42,14 +41,12 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                   }\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n-                    exts.insert(\n-                        named_extension.ident,\n-                        named_extension.ext);\n+                    exts.insert(named_extension.ident, named_extension.ext);\n                     ast::expr_rec([], none)\n                   }\n                 }\n               }\n-              _ { cx.span_bug(mac.span, ~\"naked syntactic bit\") }\n+              _ { cx.span_bug(mac.span, \"naked syntactic bit\") }\n             }\n           }\n           _ { orig(e, fld) }"}, {"sha": "aef3cc46902679524fa470cb270ea7b4c0c8ba50", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -16,26 +16,24 @@ import codemap::span;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n+                     _body: &option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(\n-                sp, ~\"#fmt requires arguments of the form `[...]`.\")\n+            cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) == 0u {\n-        cx.span_fatal(sp, ~\"#fmt requires a format string\");\n+        cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    ~\"first argument to #fmt must be a \"\n-                    + ~\"string literal.\");\n+                    \"first argument to #fmt must be a \" + \"string literal.\");\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n     log fmt;\n-    fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: &istr) -> ! {\n+    fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n@@ -52,7 +50,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         let sp_lit = @{node: lit, span: sp};\n         ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n     }\n-    fn make_new_str(cx: &ext_ctxt, sp: span, s: &istr) -> @ast::expr {\n+    fn make_new_str(cx: &ext_ctxt, sp: span, s: &str) -> @ast::expr {\n         let lit = ast::lit_str(s);\n         ret make_new_lit(cx, sp, lit);\n     }\n@@ -103,14 +101,13 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n         fn compiling_std(cx: &ext_ctxt) -> bool {\n-            ret str::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n+            ret str::find(cx.crate_file_name(), \"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n-            ret [~\"extfmt\", ~\"rt\", ident];\n-        } else { ret [~\"std\", ~\"extfmt\", ~\"rt\", ident]; }\n+            ret [\"extfmt\", \"rt\", ident];\n+        } else { ret [\"std\", \"extfmt\", \"rt\", ident]; }\n     }\n-    fn make_rt_path_expr(cx: &ext_ctxt, sp: span,\n-                         ident: &istr) -> @ast::expr {\n+    fn make_rt_path_expr(cx: &ext_ctxt, sp: span, ident: &str) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n         ret make_path_expr(cx, sp, path);\n     }\n@@ -123,11 +120,11 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             for f: flag in flags {\n                 let fstr;\n                 alt f {\n-                  flag_left_justify. { fstr = ~\"flag_left_justify\"; }\n-                  flag_left_zero_pad. { fstr = ~\"flag_left_zero_pad\"; }\n-                  flag_space_for_sign. { fstr = ~\"flag_space_for_sign\"; }\n-                  flag_sign_always. { fstr = ~\"flag_sign_always\"; }\n-                  flag_alternate. { fstr = ~\"flag_alternate\"; }\n+                  flag_left_justify. { fstr = \"flag_left_justify\"; }\n+                  flag_left_zero_pad. { fstr = \"flag_left_zero_pad\"; }\n+                  flag_space_for_sign. { fstr = \"flag_space_for_sign\"; }\n+                  flag_sign_always. { fstr = \"flag_sign_always\"; }\n+                  flag_alternate. { fstr = \"flag_alternate\"; }\n                 }\n                 flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n@@ -136,47 +133,47 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             // this is a hack placeholder flag\n \n             if vec::len::<@ast::expr>(flagexprs) == 0u {\n-                flagexprs += [make_rt_path_expr(cx, sp, ~\"flag_none\")];\n+                flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n         fn make_count(cx: &ext_ctxt, sp: span, cnt: &count) -> @ast::expr {\n             alt cnt {\n               count_implied. {\n-                ret make_rt_path_expr(cx, sp, ~\"count_implied\");\n+                ret make_rt_path_expr(cx, sp, \"count_implied\");\n               }\n               count_is(c) {\n                 let count_lit = make_new_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, ~\"count_is\");\n+                let count_is_path = make_path_vec(cx, \"count_is\");\n                 let count_is_args = [count_lit];\n                 ret make_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n+              _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n             let rt_type;\n             alt t {\n               ty_hex(c) {\n                 alt c {\n-                  case_upper. { rt_type = ~\"ty_hex_upper\"; }\n-                  case_lower. { rt_type = ~\"ty_hex_lower\"; }\n+                  case_upper. { rt_type = \"ty_hex_upper\"; }\n+                  case_lower. { rt_type = \"ty_hex_lower\"; }\n                 }\n               }\n-              ty_bits. { rt_type = ~\"ty_bits\"; }\n-              ty_octal. { rt_type = ~\"ty_octal\"; }\n-              _ { rt_type = ~\"ty_default\"; }\n+              ty_bits. { rt_type = \"ty_bits\"; }\n+              ty_octal. { rt_type = \"ty_octal\"; }\n+              _ { rt_type = \"ty_default\"; }\n             }\n             ret make_rt_path_expr(cx, sp, rt_type);\n         }\n         fn make_conv_rec(cx: &ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n-                              [{ident: ~\"flags\", ex: flags_expr},\n-                               {ident: ~\"width\", ex: width_expr},\n-                               {ident: ~\"precision\", ex: precision_expr},\n-                               {ident: ~\"ty\", ex: ty_expr}]);\n+                              [{ident: \"flags\", ex: flags_expr},\n+                               {ident: \"width\", ex: width_expr},\n+                               {ident: \"precision\", ex: precision_expr},\n+                               {ident: \"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -185,9 +182,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: &istr,\n-                      cnv: &conv, arg: @ast::expr) -> @ast::expr {\n-        let fname = ~\"conv_\" + conv_type;\n+    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: &str, cnv: &conv,\n+                      arg: @ast::expr) -> @ast::expr {\n+        let fname = \"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];\n@@ -205,7 +202,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { ret false; }\n             }\n         }\n-        let unsupported = ~\"conversion not supported in #fmt string\";\n+        let unsupported = \"conversion not supported in #fmt string\";\n         alt cnv.param {\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -216,15 +213,15 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               flag_sign_always. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  ~\"+ flag only valid in \" +\n-                                      ~\"signed #fmt conversion\");\n+                                  \"+ flag only valid in \" +\n+                                      \"signed #fmt conversion\");\n                 }\n               }\n               flag_space_for_sign. {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  ~\"space flag only valid in \" +\n-                                      ~\"signed #fmt conversions\");\n+                                  \"space flag only valid in \" +\n+                                      \"signed #fmt conversions\");\n                 }\n               }\n               flag_left_zero_pad. { }\n@@ -242,28 +239,26 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.ty {\n-          ty_str. { ret make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n+          ty_str. { ret make_conv_call(cx, arg.span, \"str\", cnv, arg); }\n           ty_int(sign) {\n             alt sign {\n-              signed. { ret make_conv_call(cx, arg.span, ~\"int\", cnv, arg); }\n+              signed. { ret make_conv_call(cx, arg.span, \"int\", cnv, arg); }\n               unsigned. {\n-                ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n               }\n             }\n           }\n-          ty_bool. { ret make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n-          ty_char. { ret make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n-          ty_hex(_) { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_bits. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n-          ty_octal. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_bool. { ret make_conv_call(cx, arg.span, \"bool\", cnv, arg); }\n+          ty_char. { ret make_conv_call(cx, arg.span, \"char\", cnv, arg); }\n+          ty_hex(_) { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n+          ty_bits. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n+          ty_octal. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n     }\n     fn log_conv(c: conv) {\n         alt c.param {\n-          some(p) {\n-            log ~\"param: \" + std::int::to_str(p, 10u);\n-          }\n+          some(p) { log \"param: \" + std::int::to_str(p, 10u); }\n           _ { log \"param: none\"; }\n         }\n         for f: flag in c.flags {\n@@ -276,21 +271,17 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             }\n         }\n         alt c.width {\n-          count_is(i) { log ~\"width: count is \"\n-              + std::int::to_str(i, 10u); }\n+          count_is(i) { log \"width: count is \" + std::int::to_str(i, 10u); }\n           count_is_param(i) {\n-            log ~\"width: count is param \"\n-                + std::int::to_str(i, 10u);\n+            log \"width: count is param \" + std::int::to_str(i, 10u);\n           }\n           count_is_next_param. { log \"width: count is next param\"; }\n           count_implied. { log \"width: count is implied\"; }\n         }\n         alt c.precision {\n-          count_is(i) { log ~\"prec: count is \"\n-              + std::int::to_str(i, 10u); }\n+          count_is(i) { log \"prec: count is \" + std::int::to_str(i, 10u); }\n           count_is_param(i) {\n-            log ~\"prec: count is param \"\n-                + std::int::to_str(i, 10u);\n+            log \"prec: count is param \" + std::int::to_str(i, 10u);\n           }\n           count_is_next_param. { log \"prec: count is next param\"; }\n           count_implied. { log \"prec: count is implied\"; }\n@@ -317,7 +308,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     let fmt_sp = args[0].span;\n     let n = 0u;\n-    let tmp_expr = make_new_str(cx, sp, ~\"\");\n+    let tmp_expr = make_new_str(cx, sp, \"\");\n     let nargs = vec::len::<@ast::expr>(args);\n     for pc: piece in pieces {\n         alt pc {\n@@ -329,8 +320,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              ~\"not enough arguments to #fmt \" +\n-                                  ~\"for the given format string\");\n+                              \"not enough arguments to #fmt \" +\n+                                  \"for the given format string\");\n             }\n             log \"Building conversion:\";\n             log_conv(conv);"}, {"sha": "1cf015fcaf0b82e5dcc4d71c9847649f36b2340f", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,20 +5,20 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n+                     _body: &option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n-            cx.span_fatal(sp, ~\"#ident_to_str requires a vector argument .\")\n+            cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\")\n           }\n         };\n     if vec::len::<@ast::expr>(args) != 1u {\n-        cx.span_fatal(sp, ~\"malformed #ident_to_str call\");\n+        cx.span_fatal(sp, \"malformed #ident_to_str call\");\n     }\n \n     ret make_new_lit(cx, sp,\n                      ast::lit_str(expr_to_ident(cx, args[0u],\n-                                                ~\"expected an ident\")));\n+                                                \"expected an ident\")));\n \n }"}, {"sha": "50e7e307bdc52978728858a5643b66bede980d28", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,11 +4,10 @@ import syntax::ast;\n import std::str;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<istr>) -> @ast::expr {\n+                     _body: &option::t<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n-    std::io::stdout().write_line(\n-        print::pprust::expr_to_str(arg));\n+    std::io::stdout().write_line(print::pprust::expr_to_str(arg));\n \n     //trivial expression\n     ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};"}, {"sha": "4e76ec0d787e65d8a947da97d349b9f8b1a82361", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 59, "deletions": 68, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -57,29 +57,29 @@ tag matchable {\n }\n \n /* for when given an incompatible bit of AST */\n-fn match_error(cx: &ext_ctxt, m: &matchable, expected: &istr) -> ! {\n+fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n     alt m {\n       match_expr(x) {\n         cx.span_fatal(x.span,\n-                      ~\"this argument is an expr, expected \" + expected);\n+                      \"this argument is an expr, expected \" + expected);\n       }\n       match_path(x) {\n         cx.span_fatal(x.span,\n-                      ~\"this argument is a path, expected \" + expected);\n+                      \"this argument is a path, expected \" + expected);\n       }\n       match_ident(x) {\n         cx.span_fatal(x.span,\n-                      ~\"this argument is an ident, expected \" + expected);\n+                      \"this argument is an ident, expected \" + expected);\n       }\n       match_ty(x) {\n         cx.span_fatal(x.span,\n-                      ~\"this argument is a type, expected \" + expected);\n+                      \"this argument is a type, expected \" + expected);\n       }\n       match_block(x) {\n         cx.span_fatal(x.span,\n-                      ~\"this argument is a block, expected \" + expected);\n+                      \"this argument is a block, expected \" + expected);\n       }\n-      match_exact. { cx.bug(~\"what is a match_exact doing in a bindings?\"); }\n+      match_exact. { cx.bug(\"what is a match_exact doing in a bindings?\"); }\n     }\n }\n \n@@ -102,7 +102,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr]) ->\n             alt m.node {\n               ast::mac_ellipsis. {\n                 if res != none {\n-                    cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n+                    cx.span_fatal(m.span, \"only one ellipsis allowed\");\n                 }\n                 res =\n                     some({pre: vec::slice(elts, 0u, idx - 1u),\n@@ -190,8 +190,7 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n     }\n     let never_mind: bool = false;\n-    for each pair: @{key: ident,\n-                     val: selector} in b.real_binders.items() {\n+    for each pair: @{key: ident, val: selector} in b.real_binders.items() {\n         alt pair.val(match_expr(e)) {\n           none. { never_mind = true; }\n           some(mtc) { res.insert(pair.key, mtc); }\n@@ -252,8 +251,8 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n         ret alt follow(m, idx_path) {\n               seq(_, sp) {\n                 cx.span_fatal(sp,\n-                              ~\"syntax matched under ... but not \" +\n-                                  ~\"used that way.\")\n+                              \"syntax matched under ... but not \" +\n+                                  \"used that way.\")\n               }\n               leaf(m) { ret some(m) }\n             }\n@@ -267,9 +266,7 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n     let idents: hashmap<ident, ()> = new_str_hash::<()>();\n     fn mark_ident(i: &ident, _fld: ast_fold, b: &bindings,\n                   idents: &hashmap<ident, ()>) -> ident {\n-        if b.contains_key(i) {\n-            idents.insert(i, ());\n-        }\n+        if b.contains_key(i) { idents.insert(i, ()); }\n         ret i;\n     }\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n@@ -309,13 +306,10 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #fmt[\"'%s' occurs %u times, but \",\n-                                     fv, len] +\n-                                    #fmt[\"'%s' occurs %u times\",\n-                                         old_name,\n+                                #fmt[\"'%s' occurs %u times, but \", fv, len] +\n+                                    #fmt[\"'%s' occurs %u times\", old_name,\n                                          old_len];\n-                            cx.span_fatal(\n-                                repeat_me.span, msg);\n+                            cx.span_fatal(repeat_me.span, msg);\n                         }\n                       }\n                     }\n@@ -325,8 +319,8 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             alt repeat {\n               none. {\n                 cx.span_fatal(repeat_me.span,\n-                              ~\"'...' surrounds an expression without any\" +\n-                                  ~\" repeating syntax variables\");\n+                              \"'...' surrounds an expression without any\" +\n+                                  \" repeating syntax variables\");\n               }\n               some({rep_count: rc, _}) {\n                 /* Whew, we now know how how many times to repeat */\n@@ -354,7 +348,7 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     i: &ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n-          some(m) { match_error(cx, m, ~\"an identifier\") }\n+          some(m) { match_error(cx, m, \"an identifier\") }\n           none. { i }\n         }\n }\n@@ -369,7 +363,7 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             {global: false, idents: [id.node], types: []}\n           }\n           some(match_path(a_pth)) { a_pth.node }\n-          some(m) { match_error(cx, m, ~\"a path\") }\n+          some(m) { match_error(cx, m, \"a path\") }\n           none. { p }\n         }\n }\n@@ -394,7 +388,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n               }\n               some(match_path(a_pth)) { expr_path(a_pth) }\n               some(match_expr(a_exp)) { a_exp.node }\n-              some(m) { match_error(cx, m, ~\"an expression\") }\n+              some(m) { match_error(cx, m, \"an expression\") }\n               none. { orig(e, fld) }\n             }\n           }\n@@ -411,7 +405,7 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n               some(id) {\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) { ty.node }\n-                  some(m) { match_error(cx, m, ~\"a type\") }\n+                  some(m) { match_error(cx, m, \"a type\") }\n                   none. { orig(t, fld) }\n                 }\n               }\n@@ -431,14 +425,14 @@ fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     orig: fn(&blk_, ast_fold) -> blk_) -> blk_ {\n     ret alt block_to_ident(blk) {\n           some(id) {\n-            alt follow_for_trans(cx, b.find(\n-                id), idx_path) {\n+            alt follow_for_trans(cx, b.find(id), idx_path) {\n               some(match_block(new_blk)) { new_blk.node }\n \n \n+\n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n-                match_error(cx, m, ~\"a block\")\n+                match_error(cx, m, \"a block\")\n               }\n               none. { orig(blk, fld) }\n             }\n@@ -469,12 +463,12 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n \n                 if vec::len(post) > 0u {\n                     cx.span_unimpl(e.span,\n-                                   ~\"matching after `...` not yet supported\");\n+                                   \"matching after `...` not yet supported\");\n                 }\n               }\n               {pre: pre, rep: none., post: post} {\n                 if post != [] {\n-                    cx.bug(~\"elts_to_ell provided an invalid result\");\n+                    cx.bug(\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);\n                 p_t_s_r_actual_vector(cx, pre, false, s, b);\n@@ -483,6 +477,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n           }\n \n \n+\n           /* TODO: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n@@ -494,7 +489,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n                       match_expr(e) {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n-                      _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                      _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n             b.literal_ast_matchers += [bind select(cx, _, e)];\n@@ -530,14 +525,13 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n         fn select(cx: &ext_ctxt, m: &matchable) -> match_result {\n             ret alt m {\n                   match_expr(e) { some(leaf(specialize_match(m))) }\n-                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         if b.real_binders.contains_key(p_id) {\n-            cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n+            cx.span_fatal(p.span, \"duplicate binding identifier\");\n         }\n-        b.real_binders.insert(p_id,\n-                              compose_sels(s, bind select(cx, _)));\n+        b.real_binders.insert(p_id, compose_sels(s, bind select(cx, _)));\n       }\n       none. { }\n     }\n@@ -560,16 +554,15 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n               }\n-              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n             }\n     }\n-    fn no_des(cx: &ext_ctxt, sp: &span, syn: &istr) -> ! {\n-        cx.span_fatal(sp, ~\"destructuring \"\n-                      + syn + ~\" is not yet supported\");\n+    fn no_des(cx: &ext_ctxt, sp: &span, syn: &str) -> ! {\n+        cx.span_fatal(sp, \"destructuring \" + syn + \" is not yet supported\");\n     }\n     alt mac.node {\n-      ast::mac_ellipsis. { cx.span_fatal(mac.span, ~\"misused `...`\"); }\n-      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n+      ast::mac_ellipsis. { cx.span_fatal(mac.span, \"misused `...`\"); }\n+      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, \"macro calls\"); }\n       ast::mac_embed_type(ty) {\n         alt ty.node {\n           ast::ty_path(pth, _) {\n@@ -583,13 +576,12 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                         }\n                 }\n                 let final_step = bind select_pt_1(cx, _, select_pt_2);\n-                b.real_binders.insert(\n-                    id, compose_sels(s, final_step));\n+                b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n-              none. { no_des(cx, pth.span, ~\"under `#<>`\"); }\n+              none. { no_des(cx, pth.span, \"under `#<>`\"); }\n             }\n           }\n-          _ { no_des(cx, ty.span, ~\"under `#<>`\"); }\n+          _ { no_des(cx, ty.span, \"under `#<>`\"); }\n         }\n       }\n       ast::mac_embed_block(blk) {\n@@ -604,10 +596,9 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                     }\n             }\n             let final_step = bind select_pt_1(cx, _, select_pt_2);\n-            b.real_binders.insert(id,\n-                                  compose_sels(s, final_step));\n+            b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n-          none. { no_des(cx, blk.span, ~\"under `#{}`\"); }\n+          none. { no_des(cx, blk.span, \"under `#{}`\"); }\n         }\n       }\n     }\n@@ -635,7 +626,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                   _ { none }\n                 }\n               }\n-              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n@@ -680,7 +671,7 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n                       _ { none }\n                     }\n                   }\n-                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n@@ -690,25 +681,25 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n }\n \n fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                     _body: &option::t<istr>) -> base::macro_def {\n+                     _body: &option::t<str>) -> base::macro_def {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n           _ {\n             cx.span_fatal(sp,\n-                          ~\"#macro requires arguments of the form `[...]`.\")\n+                          \"#macro requires arguments of the form `[...]`.\")\n           }\n         };\n \n-    let macro_name: option::t<istr> = none;\n+    let macro_name: option::t<str> = none;\n     let clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n           expr_vec(elts, mut) {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n-                              ~\"extension clause must consist of [\" +\n-                                  ~\"macro invocation, expansion body]\");\n+                              \"extension clause must consist of [\" +\n+                                  \"macro invocation, expansion body]\");\n             }\n \n \n@@ -723,15 +714,15 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                           some(other_id) {\n                             if id != other_id {\n                                 cx.span_fatal(pth.span,\n-                                              ~\"macro name must be \" +\n-                                                  ~\"consistent\");\n+                                              \"macro name must be \" +\n+                                                  \"consistent\");\n                             }\n                           }\n                         }\n                       }\n                       none. {\n                         cx.span_fatal(pth.span,\n-                                      ~\"macro name must not be a path\");\n+                                      \"macro name must not be a path\");\n                       }\n                     }\n                     clauses +=\n@@ -744,14 +735,14 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n               }\n               _ {\n                 cx.span_fatal(elts[0u].span,\n-                              ~\"extension clause must\" +\n-                                  ~\" start with a macro invocation.\");\n+                              \"extension clause must\" +\n+                                  \" start with a macro invocation.\");\n               }\n             }\n           }\n           _ {\n             cx.span_fatal((*arg).span,\n-                          ~\"extension must be [clause, \" + ~\" ...]\");\n+                          \"extension must be [clause, \" + \" ...]\");\n           }\n         }\n     }\n@@ -763,22 +754,22 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                some(id) { id }\n                none. {\n                  cx.span_fatal(sp,\n-                               ~\"macro definition must have \" +\n-                                   ~\"at least one clause\")\n+                               \"macro definition must have \" +\n+                                   \"at least one clause\")\n                }\n              },\n          ext: normal(ext)};\n \n     fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                         _body: &option::t<istr>,\n-                         clauses: [@clause]) -> @expr {\n+                         _body: &option::t<str>, clauses: [@clause]) ->\n+       @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body) }\n               none. { cont; }\n             }\n         }\n-        cx.span_fatal(sp, ~\"no clauses match macro invocation\");\n+        cx.span_fatal(sp, \"no clauses match macro invocation\");\n     }\n }\n "}, {"sha": "6535ecfe58645f409cb546af1822ff72a1cb0c4f", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -19,50 +19,42 @@ tag eval_mode { mode_depend; mode_parse; }\n type ctx =\n     @{p: parser,\n       mode: eval_mode,\n-      mutable deps: [istr],\n+      mutable deps: [str],\n       sess: parser::parse_sess,\n       mutable chpos: uint,\n       mutable byte_pos: uint,\n       cfg: ast::crate_cfg};\n \n fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n-                         prefix: &istr,\n-                         view_items: &mutable [@ast::view_item],\n+                         prefix: &str, view_items: &mutable [@ast::view_item],\n                          items: &mutable [@ast::item]) {\n     for sub_cdir: @ast::crate_directive in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: &[@ast::crate_directive],\n-                                prefix: &istr) -> ast::_mod {\n+                                prefix: &str) -> ast::_mod {\n     let view_items: [@ast::view_item] = [];\n     let items: [@ast::item] = [];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret {view_items: view_items, items: items};\n }\n \n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &istr,\n+fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &str,\n                         view_items: &mutable [@ast::view_item],\n                         items: &mutable [@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, file_opt, attrs) {\n-        let file_path = id + ~\".rs\";\n-        alt file_opt {\n-          some(f) {\n-            file_path = f;\n-          }\n-          none. { }\n-        }\n-        let full_path = if std::fs::path_is_absolute(file_path) {\n-            file_path\n-        } else {\n-            prefix + std::fs::path_sep() + file_path\n-        };\n+        let file_path = id + \".rs\";\n+        alt file_opt { some(f) { file_path = f; } none. { } }\n+        let full_path =\n+            if std::fs::path_is_absolute(file_path) {\n+                file_path\n+            } else { prefix + std::fs::path_sep() + file_path };\n         if cx.mode == mode_depend { cx.deps += [full_path]; ret; }\n         let p0 =\n-            new_parser_from_file(cx.sess, cx.cfg,\n-                                 full_path, cx.chpos,\n+            new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos,\n                                  cx.byte_pos, SOURCE_FILE);\n         let inner_attrs = parse_inner_attrs_and_next(p0);\n         let mod_attrs = attrs + inner_attrs.inner;\n@@ -79,18 +71,11 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &istr,\n       }\n       ast::cdir_dir_mod(id, dir_opt, cdirs, attrs) {\n         let path = id;\n-        alt dir_opt {\n-          some(d) {\n-            path = d;\n-          }\n-          none. { }\n-        }\n+        alt dir_opt { some(d) { path = d; } none. { } }\n         let full_path =\n             if std::fs::path_is_absolute(path) {\n                 path\n-            } else {\n-            prefix + std::fs::path_sep() + path\n-        };\n+            } else { prefix + std::fs::path_sep() + path };\n         let m0 = eval_crate_directives_to_mod(cx, cdirs, full_path);\n         let i =\n             @{ident: id,"}, {"sha": "f0d5bfeb72975443d85fd022a51d78d984103158", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 61, "deletions": 78, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -19,29 +19,29 @@ type reader =\n         fn next() -> char;\n         fn init();\n         fn bump();\n-        fn get_str_from(uint) -> istr;\n-        fn get_interner() -> @interner::interner<istr>;\n+        fn get_str_from(uint) -> str;\n+        fn get_interner() -> @interner::interner<str>;\n         fn get_chpos() -> uint;\n         fn get_byte_pos() -> uint;\n         fn get_col() -> uint;\n         fn get_filemap() -> codemap::filemap;\n-        fn err(&istr);\n+        fn err(&str);\n     };\n \n-fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n-              itr: @interner::interner<istr>) -> reader {\n+fn new_reader(cm: &codemap::codemap, src: &str, filemap: codemap::filemap,\n+              itr: @interner::interner<str>) -> reader {\n     obj reader(cm: codemap::codemap,\n-               src: istr,\n+               src: str,\n                len: uint,\n                mutable col: uint,\n                mutable pos: uint,\n                mutable ch: char,\n                mutable chpos: uint,\n-               mutable strs: [istr],\n+               mutable strs: [str],\n                fm: codemap::filemap,\n-               itr: @interner::interner<istr>) {\n+               itr: @interner::interner<str>) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n-        fn get_str_from(start: uint) -> istr {\n+        fn get_str_from(start: uint) -> str {\n             // I'm pretty skeptical about this subtraction. What if there's a\n             // multi-byte character before the mark?\n             ret str::slice(src, start - 1u, pos - 1u);\n@@ -74,16 +74,14 @@ fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n                 ch = next.ch;\n             } else { ch = -1 as char; }\n         }\n-        fn get_interner() -> @interner::interner<istr> { ret itr; }\n+        fn get_interner() -> @interner::interner<str> { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(m: &istr) {\n-            codemap::emit_error(\n-                some(ast_util::mk_sp(chpos, chpos)),\n-                m, cm);\n+        fn err(m: &str) {\n+            codemap::emit_error(some(ast_util::mk_sp(chpos, chpos)), m, cm);\n         }\n     }\n-    let strs: [istr] = [];\n+    let strs: [str] = [];\n     let rd =\n         reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n                filemap.start_pos.ch, strs, filemap, itr);\n@@ -148,9 +146,7 @@ fn consume_any_line_comment(rdr: &reader) {\n fn consume_block_comment(rdr: &reader) {\n     let level: int = 1;\n     while level > 0 {\n-        if rdr.is_eof() {\n-            rdr.err(~\"unterminated block comment\"); fail;\n-        }\n+        if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n         if rdr.curr() == '/' && rdr.next() == '*' {\n             rdr.bump();\n             rdr.bump();\n@@ -168,15 +164,15 @@ fn consume_block_comment(rdr: &reader) {\n     be consume_whitespace_and_comments(rdr);\n }\n \n-fn digits_to_string(s: &istr) -> int {\n+fn digits_to_string(s: &str) -> int {\n     let accum_int: int = 0;\n     for c: u8 in s { accum_int *= 10; accum_int += dec_digit_val(c as char); }\n     ret accum_int;\n }\n \n-fn scan_exponent(rdr: &reader) -> option::t<istr> {\n+fn scan_exponent(rdr: &reader) -> option::t<str> {\n     let c = rdr.curr();\n-    let rslt = ~\"\";\n+    let rslt = \"\";\n     if c == 'e' || c == 'E' {\n         rslt += str::unsafe_from_bytes([c as u8]);\n         rdr.bump();\n@@ -188,13 +184,13 @@ fn scan_exponent(rdr: &reader) -> option::t<istr> {\n         let exponent = scan_dec_digits(rdr);\n         if str::byte_len(exponent) > 0u {\n             ret some(rslt + exponent);\n-        } else { rdr.err(~\"scan_exponent: bad fp literal\"); fail; }\n-    } else { ret none::<istr>; }\n+        } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n+    } else { ret none::<str>; }\n }\n \n-fn scan_dec_digits(rdr: &reader) -> istr {\n+fn scan_dec_digits(rdr: &reader) -> str {\n     let c = rdr.curr();\n-    let rslt: istr = ~\"\";\n+    let rslt: str = \"\";\n     while is_dec_digit(c) || c == '_' {\n         if c != '_' { rslt += str::unsafe_from_bytes([c as u8]); }\n         rdr.bump();\n@@ -205,7 +201,7 @@ fn scan_dec_digits(rdr: &reader) -> istr {\n \n fn scan_number(c: char, rdr: &reader) -> token::token {\n     let accum_int = 0;\n-    let dec_str: istr = ~\"\";\n+    let dec_str: str = \"\";\n     let is_dec_integer: bool = false;\n     let n = rdr.next();\n     if c == '0' && n == 'x' {\n@@ -276,7 +272,7 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n \n         rdr.bump();\n         let dec_part = scan_dec_digits(rdr);\n-        let float_str = dec_str + ~\".\" + dec_part;\n+        let float_str = dec_str + \".\" + dec_part;\n         c = rdr.curr();\n         let exponent_str = scan_exponent(rdr);\n         alt exponent_str { some(s) { float_str += s; } none. { } }\n@@ -302,17 +298,15 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n \n             }\n         } else {\n-            ret token::LIT_FLOAT(interner::intern::<istr>(\n-                *rdr.get_interner(),\n-                float_str));\n+            ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n+                                                         float_str));\n         }\n     }\n     let maybe_exponent = scan_exponent(rdr);\n     alt maybe_exponent {\n       some(s) {\n-        ret token::LIT_FLOAT(interner::intern::<istr>(\n-            *rdr.get_interner(),\n-            dec_str + s));\n+        ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n+                                                     dec_str + s));\n       }\n       none. { ret token::LIT_INT(accum_int); }\n     }\n@@ -324,8 +318,7 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n         let n = rdr.curr();\n         rdr.bump();\n         if !is_hex_digit(n) {\n-            rdr.err(\n-                    #fmt[\"illegal numeric character escape: %d\", n as int]);\n+            rdr.err(#fmt[\"illegal numeric character escape: %d\", n as int]);\n             fail;\n         }\n         accum_int *= 16;\n@@ -344,19 +337,18 @@ fn next_token(rdr: &reader) -> {tok: token::token, chpos: uint, bpos: uint} {\n }\n \n fn next_token_inner(rdr: &reader) -> token::token {\n-    let accum_str = ~\"\";\n+    let accum_str = \"\";\n     let c = rdr.curr();\n     if is_alpha(c) || c == '_' {\n         while is_alnum(c) || c == '_' {\n             str::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n-        if str::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n+        if str::eq(accum_str, \"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && rdr.next() == ':';\n-        ret token::IDENT(interner::intern::<istr>(\n-            *rdr.get_interner(),\n-            accum_str), is_mod_name);\n+        ret token::IDENT(interner::intern::<str>(*rdr.get_interner(),\n+                                                 accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) { ret scan_number(c, rdr); }\n     fn binop(rdr: &reader, op: token::binop) -> token::token {\n@@ -369,6 +361,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n     alt c {\n \n \n+\n       // One-byte tokens.\n       '?' {\n         rdr.bump();\n@@ -408,6 +401,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       }\n \n \n+\n       // Multi-byte tokens.\n       '=' {\n         rdr.bump();\n@@ -468,15 +462,13 @@ fn next_token_inner(rdr: &reader) -> token::token {\n               'u' { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n-                rdr.err(\n-                    #fmt[\"unknown character escape: %d\",\n-                                         c2 as int]);\n+                rdr.err(#fmt[\"unknown character escape: %d\", c2 as int]);\n                 fail;\n               }\n             }\n         }\n         if rdr.curr() != '\\'' {\n-            rdr.err(~\"unterminated character constant\");\n+            rdr.err(\"unterminated character constant\");\n             fail;\n         }\n         rdr.bump(); // advance curr past token\n@@ -509,9 +501,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 {\n-                    rdr.err(\n-                        #fmt[\"unknown string escape: %d\",\n-                                             c2 as int]);\n+                    rdr.err(#fmt[\"unknown string escape: %d\", c2 as int]);\n                     fail;\n                   }\n                 }\n@@ -520,9 +510,8 @@ fn next_token_inner(rdr: &reader) -> token::token {\n             }\n         }\n         rdr.bump();\n-        ret token::LIT_STR(interner::intern::<istr>(\n-            *rdr.get_interner(),\n-            accum_str));\n+        ret token::LIT_STR(interner::intern::<str>(*rdr.get_interner(),\n+                                                   accum_str));\n       }\n       '-' {\n         if rdr.next() == '>' {\n@@ -549,11 +538,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       '/' { ret binop(rdr, token::SLASH); }\n       '^' { ret binop(rdr, token::CARET); }\n       '%' { ret binop(rdr, token::PERCENT); }\n-      c {\n-        rdr.err(\n-            #fmt[\"unkown start of token: %d\", c as int]);\n-        fail;\n-      }\n+      c { rdr.err(#fmt[\"unkown start of token: %d\", c as int]); fail; }\n     }\n }\n \n@@ -564,10 +549,10 @@ tag cmnt_style {\n     blank_line; // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-type cmnt = {style: cmnt_style, lines: [istr], pos: uint};\n+type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n \n-fn read_to_eol(rdr: &reader) -> istr {\n-    let val = ~\"\";\n+fn read_to_eol(rdr: &reader) -> str {\n+    let val = \"\";\n     while rdr.curr() != '\\n' && !rdr.is_eof() {\n         str::push_char(val, rdr.curr());\n         rdr.bump();\n@@ -576,7 +561,7 @@ fn read_to_eol(rdr: &reader) -> istr {\n     ret val;\n }\n \n-fn read_one_line_comment(rdr: &reader) -> istr {\n+fn read_one_line_comment(rdr: &reader) -> str {\n     let val = read_to_eol(rdr);\n     assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n     ret val;\n@@ -594,7 +579,7 @@ fn consume_non_eol_whitespace(rdr: &reader) {\n \n fn push_blank_line_comment(rdr: &reader, comments: &mutable [cmnt]) {\n     log \">>> blank-line comment\";\n-    let v: [istr] = [];\n+    let v: [str] = [];\n     comments += [{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n@@ -611,7 +596,7 @@ fn consume_whitespace_counting_blank_lines(rdr: &reader,\n fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> line comments\";\n     let p = rdr.get_chpos();\n-    let lines: [istr] = [];\n+    let lines: [str] = [];\n     while rdr.curr() == '/' && rdr.next() == '/' {\n         let line = read_one_line_comment(rdr);\n         log line;\n@@ -624,52 +609,52 @@ fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n          pos: p};\n }\n \n-fn all_whitespace(s: &istr, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n     let i: uint = begin;\n     while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mutable [istr], s: &istr,\n+fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n                                         col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n         if col < str::byte_len(s) {\n             s1 = str::slice(s, col, str::byte_len(s));\n-        } else { s1 = ~\"\"; }\n+        } else { s1 = \"\"; }\n     } else { s1 = s; }\n-    log ~\"pushing line: \" + s1;\n+    log \"pushing line: \" + s1;\n     lines += [s1];\n }\n \n fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> block comment\";\n     let p = rdr.get_chpos();\n-    let lines: [istr] = [];\n+    let lines: [str] = [];\n     let col: uint = rdr.get_col();\n     rdr.bump();\n     rdr.bump();\n-    let curr_line = ~\"/*\";\n+    let curr_line = \"/*\";\n     let level: int = 1;\n     while level > 0 {\n         log #fmt[\"=== block comment level %d\", level];\n-        if rdr.is_eof() { rdr.err(~\"unterminated block comment\"); fail; }\n+        if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n         if rdr.curr() == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n-            curr_line = ~\"\";\n+            curr_line = \"\";\n             rdr.bump();\n         } else {\n             str::push_char(curr_line, rdr.curr());\n             if rdr.curr() == '/' && rdr.next() == '*' {\n                 rdr.bump();\n                 rdr.bump();\n-                curr_line += ~\"*\";\n+                curr_line += \"*\";\n                 level += 1;\n             } else {\n                 if rdr.curr() == '*' && rdr.next() == '/' {\n                     rdr.bump();\n                     rdr.bump();\n-                    curr_line += ~\"/\";\n+                    curr_line += \"/\";\n                     level -= 1;\n                 } else { rdr.bump(); }\n             }\n@@ -717,16 +702,14 @@ fn is_lit(t: &token::token) -> bool {\n         }\n }\n \n-type lit = {lit: istr, pos: uint};\n+type lit = {lit: str, pos: uint};\n \n-fn gather_comments_and_literals(cm: &codemap::codemap, path: &istr,\n+fn gather_comments_and_literals(cm: &codemap::codemap, path: &str,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n     let src = str::unsafe_from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<istr>(str::hash, str::eq);\n-    let rdr = new_reader(cm, src,\n-                         codemap::new_filemap(\n-                             path, 0u, 0u), itr);\n+    let itr = @interner::mk::<str>(str::hash, str::eq);\n+    let rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n     let comments: [cmnt] = [];\n     let literals: [lit] = [];\n     let first_read: bool = true;\n@@ -748,7 +731,7 @@ fn gather_comments_and_literals(cm: &codemap::codemap, path: &istr,\n         if is_lit(tok.tok) {\n             literals += [{lit: rdr.get_str_from(tok.bpos), pos: tok.chpos}];\n         }\n-        log ~\"tok: \" + token::to_str(rdr, tok.tok);\n+        log \"tok: \" + token::to_str(rdr, tok.tok);\n         first_read = false;\n     }\n     ret {cmnts: comments, lits: literals};"}, {"sha": "9e45df8d11182138f8a222660fc70e4173c90f08", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 221, "deletions": 271, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -37,8 +37,8 @@ type parser =\n         fn bump();\n         fn swap(token::token, uint, uint);\n         fn look_ahead(uint) -> token::token;\n-        fn fatal(&istr) -> ! ;\n-        fn warn(&istr);\n+        fn fatal(&str) -> ! ;\n+        fn warn(&str);\n         fn restrict(restriction);\n         fn get_restriction() -> restriction;\n         fn get_file_type() -> file_type;\n@@ -49,22 +49,21 @@ type parser =\n         fn get_last_lo_pos() -> uint;\n         fn get_last_hi_pos() -> uint;\n         fn get_prec_table() -> @[op_spec];\n-        fn get_str(token::str_num) -> istr;\n+        fn get_str(token::str_num) -> str;\n         fn get_reader() -> lexer::reader;\n         fn get_filemap() -> codemap::filemap;\n-        fn get_bad_expr_words() -> hashmap<istr, ()>;\n+        fn get_bad_expr_words() -> hashmap<str, ()>;\n         fn get_chpos() -> uint;\n         fn get_byte_pos() -> uint;\n         fn get_id() -> node_id;\n         fn get_sess() -> parse_sess;\n     };\n \n-fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &istr,\n+fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &str,\n                         chpos: uint, byte_pos: uint, ftype: file_type) ->\n    parser {\n     let src = io::read_whole_file_str(path);\n-    let filemap = codemap::new_filemap(\n-        path, chpos, byte_pos);\n+    let filemap = codemap::new_filemap(path, chpos, byte_pos);\n     sess.cm.files += [filemap];\n     let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n@@ -83,7 +82,7 @@ fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n                      mutable restr: restriction,\n                      rdr: lexer::reader,\n                      precs: @[op_spec],\n-                     bad_words: hashmap<istr, ()>) {\n+                     bad_words: hashmap<str, ()>) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             last_tok_span = tok_span;\n@@ -109,14 +108,12 @@ fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n             }\n             ret buffer[distance - 1u].tok;\n         }\n-        fn fatal(m: &istr) -> ! {\n-            codemap::emit_error(some(self.get_span()),\n-                                m, sess.cm);\n+        fn fatal(m: &str) -> ! {\n+            codemap::emit_error(some(self.get_span()), m, sess.cm);\n             fail;\n         }\n-        fn warn(m: &istr) {\n-            codemap::emit_warning(some(self.get_span()),\n-                                  m, sess.cm);\n+        fn warn(m: &str) {\n+            codemap::emit_warning(some(self.get_span()), m, sess.cm);\n         }\n         fn restrict(r: restriction) { restr = r; }\n         fn get_restriction() -> restriction { ret restr; }\n@@ -128,12 +125,12 @@ fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n         fn get_file_type() -> file_type { ret ftype; }\n         fn get_cfg() -> ast::crate_cfg { ret cfg; }\n         fn get_prec_table() -> @[op_spec] { ret precs; }\n-        fn get_str(i: token::str_num) -> istr {\n+        fn get_str(i: token::str_num) -> str {\n             ret interner::get(*rdr.get_interner(), i);\n         }\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n-        fn get_bad_expr_words() -> hashmap<istr, ()> { ret bad_words; }\n+        fn get_bad_expr_words() -> hashmap<str, ()> { ret bad_words; }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n         fn get_byte_pos() -> uint { ret rdr.get_byte_pos(); }\n         fn get_id() -> node_id { ret next_node_id(sess); }\n@@ -148,48 +145,48 @@ fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n // These are the words that shouldn't be allowed as value identifiers,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n-fn bad_expr_word_table() -> hashmap<istr, ()> {\n+fn bad_expr_word_table() -> hashmap<str, ()> {\n     let words = new_str_hash();\n-    words.insert(~\"mod\", ());\n-    words.insert(~\"if\", ());\n-    words.insert(~\"else\", ());\n-    words.insert(~\"while\", ());\n-    words.insert(~\"do\", ());\n-    words.insert(~\"alt\", ());\n-    words.insert(~\"for\", ());\n-    words.insert(~\"each\", ());\n-    words.insert(~\"break\", ());\n-    words.insert(~\"cont\", ());\n-    words.insert(~\"put\", ());\n-    words.insert(~\"ret\", ());\n-    words.insert(~\"be\", ());\n-    words.insert(~\"fail\", ());\n-    words.insert(~\"type\", ());\n-    words.insert(~\"resource\", ());\n-    words.insert(~\"check\", ());\n-    words.insert(~\"assert\", ());\n-    words.insert(~\"claim\", ());\n-    words.insert(~\"prove\", ());\n-    words.insert(~\"native\", ());\n-    words.insert(~\"fn\", ());\n-    words.insert(~\"lambda\", ());\n-    words.insert(~\"pure\", ());\n-    words.insert(~\"iter\", ());\n-    words.insert(~\"block\", ());\n-    words.insert(~\"import\", ());\n-    words.insert(~\"export\", ());\n-    words.insert(~\"let\", ());\n-    words.insert(~\"const\", ());\n-    words.insert(~\"log\", ());\n-    words.insert(~\"log_err\", ());\n-    words.insert(~\"tag\", ());\n-    words.insert(~\"obj\", ());\n-    words.insert(~\"copy\", ());\n+    words.insert(\"mod\", ());\n+    words.insert(\"if\", ());\n+    words.insert(\"else\", ());\n+    words.insert(\"while\", ());\n+    words.insert(\"do\", ());\n+    words.insert(\"alt\", ());\n+    words.insert(\"for\", ());\n+    words.insert(\"each\", ());\n+    words.insert(\"break\", ());\n+    words.insert(\"cont\", ());\n+    words.insert(\"put\", ());\n+    words.insert(\"ret\", ());\n+    words.insert(\"be\", ());\n+    words.insert(\"fail\", ());\n+    words.insert(\"type\", ());\n+    words.insert(\"resource\", ());\n+    words.insert(\"check\", ());\n+    words.insert(\"assert\", ());\n+    words.insert(\"claim\", ());\n+    words.insert(\"prove\", ());\n+    words.insert(\"native\", ());\n+    words.insert(\"fn\", ());\n+    words.insert(\"lambda\", ());\n+    words.insert(\"pure\", ());\n+    words.insert(\"iter\", ());\n+    words.insert(\"block\", ());\n+    words.insert(\"import\", ());\n+    words.insert(\"export\", ());\n+    words.insert(\"let\", ());\n+    words.insert(\"const\", ());\n+    words.insert(\"log\", ());\n+    words.insert(\"log_err\", ());\n+    words.insert(\"tag\", ());\n+    words.insert(\"obj\", ());\n+    words.insert(\"copy\", ());\n     ret words;\n }\n \n fn unexpected(p: &parser, t: token::token) -> ! {\n-    let s: istr = ~\"unexpected token: \";\n+    let s: str = \"unexpected token: \";\n     s += token::to_str(p.get_reader(), t);\n     p.fatal(s);\n }\n@@ -198,9 +195,9 @@ fn expect(p: &parser, t: token::token) {\n     if p.peek() == t {\n         p.bump();\n     } else {\n-        let s: istr = ~\"expecting \";\n+        let s: str = \"expecting \";\n         s += token::to_str(p.get_reader(), t);\n-        s += ~\", found \";\n+        s += \", found \";\n         s += token::to_str(p.get_reader(), p.peek());\n         p.fatal(s);\n     }\n@@ -214,9 +211,9 @@ fn expect_gt(p: &parser) {\n     } else if p.peek() == token::BINOP(token::ASR) {\n         p.swap(token::BINOP(token::LSR), p.get_lo_pos() + 1u, p.get_hi_pos());\n     } else {\n-        let s: istr = ~\"expecting \";\n+        let s: str = \"expecting \";\n         s += token::to_str(p.get_reader(), token::GT);\n-        s += ~\", found \";\n+        s += \", found \";\n         s += token::to_str(p.get_reader(), p.peek());\n         p.fatal(s);\n     }\n@@ -228,11 +225,8 @@ fn spanned<@T>(lo: uint, hi: uint, node: &T) -> spanned<T> {\n \n fn parse_ident(p: &parser) -> ast::ident {\n     alt p.peek() {\n-      token::IDENT(i, _) {\n-        p.bump();\n-        ret p.get_str(i);\n-      }\n-      _ { p.fatal(~\"expecting ident\"); }\n+      token::IDENT(i, _) { p.bump(); ret p.get_str(i); }\n+      _ { p.fatal(\"expecting ident\"); }\n     }\n }\n \n@@ -245,14 +239,14 @@ fn eat(p: &parser, tok: &token::token) -> bool {\n     ret if p.peek() == tok { p.bump(); true } else { false };\n }\n \n-fn is_word(p: &parser, word: &istr) -> bool {\n+fn is_word(p: &parser, word: &str) -> bool {\n     ret alt p.peek() {\n           token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n           _ { false }\n         };\n }\n \n-fn eat_word(p: &parser, word: &istr) -> bool {\n+fn eat_word(p: &parser, word: &str) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         if str::eq(word, p.get_str(sid)) {\n@@ -264,10 +258,10 @@ fn eat_word(p: &parser, word: &istr) -> bool {\n     }\n }\n \n-fn expect_word(p: &parser, word: &istr) {\n+fn expect_word(p: &parser, word: &str) {\n     if !eat_word(p, word) {\n-        p.fatal(~\"expecting \" + word + ~\", found \" +\n-                token::to_str(p.get_reader(), p.peek()));\n+        p.fatal(\"expecting \" + word + \", found \" +\n+                    token::to_str(p.get_reader(), p.peek()));\n     }\n }\n \n@@ -276,7 +270,7 @@ fn check_bad_word(p: &parser) {\n       token::IDENT(sid, false) {\n         let w = p.get_str(sid);\n         if p.get_bad_expr_words().contains_key(w) {\n-            p.fatal(~\"found \" + w + ~\" in expression position\");\n+            p.fatal(\"found \" + w + \" in expression position\");\n         }\n       }\n       _ { }\n@@ -294,7 +288,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n         let mode = ast::val;\n         if p.peek() == token::BINOP(token::AND) {\n             p.bump();\n-            mode = ast::alias(eat_word(p, ~\"mutable\"));\n+            mode = ast::alias(eat_word(p, \"mutable\"));\n         }\n         let t = parse_ty(p, false);\n         ret spanned(lo, t.span.hi, {mode: mode, ty: t});\n@@ -323,11 +317,11 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n }\n \n fn parse_proto(p: &parser) -> ast::proto {\n-    if eat_word(p, ~\"iter\") {\n+    if eat_word(p, \"iter\") {\n         ret ast::proto_iter;\n-    } else if eat_word(p, ~\"fn\") {\n+    } else if eat_word(p, \"fn\") {\n         ret ast::proto_fn;\n-    } else if eat_word(p, ~\"block\") {\n+    } else if eat_word(p, \"block\") {\n         ret ast::proto_block;\n     } else { unexpected(p, p.peek()); }\n }\n@@ -377,8 +371,7 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n fn ident_index(p: &parser, args: &[ast::arg], i: &ast::ident) -> uint {\n     let j = 0u;\n     for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n-    p.fatal(~\"Unbound variable \" +\n-            i + ~\" in constraint arg\");\n+    p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n fn parse_type_constr_arg(p: &parser) -> @ast::ty_constr_arg {\n@@ -467,7 +460,7 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n                                            idents: pth.node.idents,\n                                            types: seq}), ann));\n       }\n-      _ { p.fatal(~\"type parameter instantiation only allowed for paths\"); }\n+      _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n     }\n }\n \n@@ -484,43 +477,41 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n     let t: ast::ty_;\n     // FIXME: do something with this\n \n-    if eat_word(p, ~\"bool\") {\n+    if eat_word(p, \"bool\") {\n         t = ast::ty_bool;\n-    } else if eat_word(p, ~\"int\") {\n+    } else if eat_word(p, \"int\") {\n         t = ast::ty_int;\n-    } else if eat_word(p, ~\"uint\") {\n+    } else if eat_word(p, \"uint\") {\n         t = ast::ty_uint;\n-    } else if eat_word(p, ~\"float\") {\n+    } else if eat_word(p, \"float\") {\n         t = ast::ty_float;\n-    } else if eat_word(p, ~\"str\") {\n-        t = ast::ty_istr;\n-    } else if eat_word(p, ~\"istr\") {\n-        t = ast::ty_istr;\n-    } else if eat_word(p, ~\"char\") {\n+    } else if eat_word(p, \"str\") {\n+        t = ast::ty_str;\n+    } else if eat_word(p, \"char\") {\n         t = ast::ty_char;\n         /*\n             } else if (eat_word(p, \"task\")) {\n                 t = ast::ty_task;\n         */\n-    } else if eat_word(p, ~\"i8\") {\n+    } else if eat_word(p, \"i8\") {\n         t = ast::ty_machine(ast::ty_i8);\n-    } else if eat_word(p, ~\"i16\") {\n+    } else if eat_word(p, \"i16\") {\n         t = ast::ty_machine(ast::ty_i16);\n-    } else if eat_word(p, ~\"i32\") {\n+    } else if eat_word(p, \"i32\") {\n         t = ast::ty_machine(ast::ty_i32);\n-    } else if eat_word(p, ~\"i64\") {\n+    } else if eat_word(p, \"i64\") {\n         t = ast::ty_machine(ast::ty_i64);\n-    } else if eat_word(p, ~\"u8\") {\n+    } else if eat_word(p, \"u8\") {\n         t = ast::ty_machine(ast::ty_u8);\n-    } else if eat_word(p, ~\"u16\") {\n+    } else if eat_word(p, \"u16\") {\n         t = ast::ty_machine(ast::ty_u16);\n-    } else if eat_word(p, ~\"u32\") {\n+    } else if eat_word(p, \"u32\") {\n         t = ast::ty_machine(ast::ty_u32);\n-    } else if eat_word(p, ~\"u64\") {\n+    } else if eat_word(p, \"u64\") {\n         t = ast::ty_machine(ast::ty_u64);\n-    } else if eat_word(p, ~\"f32\") {\n+    } else if eat_word(p, \"f32\") {\n         t = ast::ty_machine(ast::ty_f32);\n-    } else if eat_word(p, ~\"f64\") {\n+    } else if eat_word(p, \"f64\") {\n         t = ast::ty_machine(ast::ty_f64);\n     } else if p.peek() == token::LPAREN {\n         p.bump();\n@@ -567,33 +558,33 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n         t = ast::ty_vec(parse_mt(p));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n-    } else if eat_word(p, ~\"fn\") {\n+    } else if eat_word(p, \"fn\") {\n         t = parse_ty_fn(ast::proto_fn, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if eat_word(p, ~\"block\") {\n+    } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if eat_word(p, ~\"iter\") {\n+    } else if eat_word(p, \"iter\") {\n         t = parse_ty_fn(ast::proto_iter, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n-    } else if eat_word(p, ~\"obj\") {\n+    } else if eat_word(p, \"obj\") {\n         t = parse_ty_obj(p, hi);\n-    } else if eat_word(p, ~\"mutable\") {\n-        p.warn(~\"ignoring deprecated 'mutable' type constructor\");\n+    } else if eat_word(p, \"mutable\") {\n+        p.warn(\"ignoring deprecated 'mutable' type constructor\");\n         let typ = parse_ty(p, false);\n         t = typ.node;\n         hi = typ.span.hi;\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n-    } else { p.fatal(~\"expecting type\"); }\n+    } else { p.fatal(\"expecting type\"); }\n     ret parse_ty_postfix(t, p, colons_before_params);\n }\n \n fn parse_arg_mode(p: &parser) -> ast::mode {\n     if eat(p, token::BINOP(token::AND)) {\n-        ast::alias(eat_word(p, ~\"mutable\"))\n+        ast::alias(eat_word(p, \"mutable\"))\n     } else if eat(p, token::BINOP(token::MINUS)) {\n         ast::move\n     } else { ast::val }\n@@ -685,9 +676,9 @@ fn parse_seq<T>(bra: token::token, ket: token::token,\n fn parse_lit(p: &parser) -> ast::lit {\n     let sp = p.get_span();\n     let lit: ast::lit_ = ast::lit_nil;\n-    if eat_word(p, ~\"true\") {\n+    if eat_word(p, \"true\") {\n         lit = ast::lit_bool(true);\n-    } else if eat_word(p, ~\"false\") {\n+    } else if eat_word(p, \"false\") {\n         lit = ast::lit_bool(false);\n     } else {\n         alt p.peek() {\n@@ -706,10 +697,7 @@ fn parse_lit(p: &parser) -> ast::lit {\n             lit = ast::lit_mach_float(tm, p.get_str(s));\n           }\n           token::LIT_CHAR(c) { p.bump(); lit = ast::lit_char(c); }\n-          token::LIT_STR(s) {\n-            p.bump();\n-            lit = ast::lit_str(p.get_str(s));\n-          }\n+          token::LIT_STR(s) { p.bump(); lit = ast::lit_str(p.get_str(s)); }\n           token::LPAREN. {\n             p.bump();\n             expect(p, token::RPAREN);\n@@ -777,7 +765,7 @@ fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n }\n \n fn parse_mutability(p: &parser) -> ast::mutability {\n-    if eat_word(p, ~\"mutable\") {\n+    if eat_word(p, \"mutable\") {\n         if p.peek() == token::QUES { p.bump(); ret ast::maybe_mut; }\n         ret ast::mut;\n     }\n@@ -825,12 +813,12 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         } else { ret mk_expr(p, lo, hi, ast::expr_tup(es)); }\n     } else if p.peek() == token::LBRACE {\n         p.bump();\n-        if is_word(p, ~\"mutable\") ||\n+        if is_word(p, \"mutable\") ||\n                is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n             let fields = [parse_field(p, token::COLON)];\n             let base = none;\n             while p.peek() != token::RBRACE {\n-                if eat_word(p, ~\"with\") { base = some(parse_expr(p)); break; }\n+                if eat_word(p, \"with\") { base = some(parse_expr(p)); break; }\n                 expect(p, token::COMMA);\n                 fields += [parse_field(p, token::COLON)];\n             }\n@@ -843,27 +831,27 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n             let blk = parse_block_tail(p, lo, ast::checked);\n             ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n-    } else if eat_word(p, ~\"if\") {\n+    } else if eat_word(p, \"if\") {\n         ret parse_if_expr(p);\n-    } else if eat_word(p, ~\"for\") {\n+    } else if eat_word(p, \"for\") {\n         ret parse_for_expr(p);\n-    } else if eat_word(p, ~\"while\") {\n+    } else if eat_word(p, \"while\") {\n         ret parse_while_expr(p);\n-    } else if eat_word(p, ~\"do\") {\n+    } else if eat_word(p, \"do\") {\n         ret parse_do_while_expr(p);\n-    } else if eat_word(p, ~\"alt\") {\n+    } else if eat_word(p, \"alt\") {\n         ret parse_alt_expr(p);\n         /*\n             } else if (eat_word(p, \"spawn\")) {\n                 ret parse_spawn_expr(p);\n         */\n-    } else if eat_word(p, ~\"fn\") {\n+    } else if eat_word(p, \"fn\") {\n         ret parse_fn_expr(p, ast::proto_fn);\n-    } else if eat_word(p, ~\"block\") {\n+    } else if eat_word(p, \"block\") {\n         ret parse_fn_expr(p, ast::proto_block);\n-    } else if eat_word(p, ~\"lambda\") {\n+    } else if eat_word(p, \"lambda\") {\n         ret parse_fn_expr(p, ast::proto_closure);\n-    } else if eat_word(p, ~\"unchecked\") {\n+    } else if eat_word(p, \"unchecked\") {\n         expect(p, token::LBRACE);\n         let blk = parse_block_tail(p, lo, ast::unchecked);\n         ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n@@ -890,18 +878,8 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis)\n     } else if p.peek() == token::TILDE {\n         p.bump();\n-        alt p.peek() {\n-          token::LIT_STR(s) {\n-            let sp = p.get_span();\n-            p.bump();\n-            let lit =\n-                @{node: ast::lit_str(p.get_str(s)),\n-                  span: sp};\n-            ex = ast::expr_lit(lit);\n-          }\n-          _ { ex = ast::expr_uniq(parse_expr(p)); }\n-        }\n-    } else if eat_word(p, ~\"obj\") {\n+        ex = ast::expr_uniq(parse_expr(p));\n+    } else if eat_word(p, \"obj\") {\n         // Anonymous object\n \n         // Only make people type () if they're actually adding new fields\n@@ -916,7 +894,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         let inner_obj: option::t<@ast::expr> = none;\n         expect(p, token::LBRACE);\n         while p.peek() != token::RBRACE {\n-            if eat_word(p, ~\"with\") {\n+            if eat_word(p, \"with\") {\n                 inner_obj = some(parse_expr(p));\n             } else { meths += [parse_method(p)]; }\n         }\n@@ -930,7 +908,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         // \"spanned\".\n         let ob = {fields: fields, methods: meths, inner_obj: inner_obj};\n         ex = ast::expr_anon_obj(ob);\n-    } else if eat_word(p, ~\"bind\") {\n+    } else if eat_word(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(p: &parser) -> option::t<@ast::expr> {\n             alt p.peek() {\n@@ -947,53 +925,53 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         let ex_ext = parse_syntax_ext(p);\n         hi = ex_ext.span.hi;\n         ex = ex_ext.node;\n-    } else if eat_word(p, ~\"fail\") {\n+    } else if eat_word(p, \"fail\") {\n         if can_begin_expr(p.peek()) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_fail(some(e));\n         } else { ex = ast::expr_fail(none); }\n-    } else if eat_word(p, ~\"log\") {\n+    } else if eat_word(p, \"log\") {\n         let e = parse_expr(p);\n         ex = ast::expr_log(1, e);\n         hi = e.span.hi;\n-    } else if eat_word(p, ~\"log_err\") {\n+    } else if eat_word(p, \"log_err\") {\n         let e = parse_expr(p);\n         ex = ast::expr_log(0, e);\n         hi = e.span.hi;\n-    } else if eat_word(p, ~\"assert\") {\n+    } else if eat_word(p, \"assert\") {\n         let e = parse_expr(p);\n         ex = ast::expr_assert(e);\n         hi = e.span.hi;\n-    } else if eat_word(p, ~\"check\") {\n+    } else if eat_word(p, \"check\") {\n         /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::checked, e);\n-    } else if eat_word(p, ~\"claim\") {\n+    } else if eat_word(p, \"claim\") {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::unchecked, e);\n-    } else if eat_word(p, ~\"ret\") {\n+    } else if eat_word(p, \"ret\") {\n         if can_begin_expr(p.peek()) {\n             let e = parse_expr(p);\n             hi = e.span.hi;\n             ex = ast::expr_ret(some(e));\n         } else { ex = ast::expr_ret(none); }\n-    } else if eat_word(p, ~\"break\") {\n+    } else if eat_word(p, \"break\") {\n         ex = ast::expr_break;\n         hi = p.get_hi_pos();\n-    } else if eat_word(p, ~\"cont\") {\n+    } else if eat_word(p, \"cont\") {\n         ex = ast::expr_cont;\n         hi = p.get_hi_pos();\n-    } else if eat_word(p, ~\"put\") {\n+    } else if eat_word(p, \"put\") {\n         alt p.peek() {\n           token::SEMI. { ex = ast::expr_put(none); }\n           _ {\n@@ -1002,19 +980,19 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n             ex = ast::expr_put(some(e));\n           }\n         }\n-    } else if eat_word(p, ~\"be\") {\n+    } else if eat_word(p, \"be\") {\n         let e = parse_expr(p);\n \n         // FIXME: Is this the right place for this check?\n         if /*check*/ast_util::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n-        } else { p.fatal(~\"Non-call expression in tail call\"); }\n-    } else if eat_word(p, ~\"copy\") {\n+        } else { p.fatal(\"Non-call expression in tail call\"); }\n+    } else if eat_word(p, \"copy\") {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n         hi = e.span.hi;\n-    } else if eat_word(p, ~\"self\") {\n+    } else if eat_word(p, \"self\") {\n         expect(p, token::DOT);\n         // The rest is a call expression.\n         let f: @ast::expr = parse_self_method(p);\n@@ -1024,8 +1002,8 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n     } else if p.peek() == token::MOD_SEP ||\n-                  is_ident(p.peek()) && !is_word(p, ~\"true\") &&\n-                      !is_word(p, ~\"false\") {\n+                  is_ident(p.peek()) && !is_word(p, \"true\") &&\n+                      !is_word(p, \"false\") {\n         check_bad_word(p);\n         let pth = parse_path_and_ty_param_substs(p);\n         hi = pth.span.hi;\n@@ -1047,7 +1025,7 @@ fn parse_syntax_ext(p: &parser) -> @ast::expr {\n fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n     let pth = parse_path(p);\n     if vec::len(pth.node.idents) == 0u {\n-        p.fatal(~\"expected a syntax expander name\");\n+        p.fatal(\"expected a syntax expander name\");\n     }\n     //temporary for a backwards-compatible cycle:\n     let es =\n@@ -1105,9 +1083,7 @@ fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n               token::IDENT(i, _) {\n                 hi = p.get_hi_pos();\n                 p.bump();\n-                e = mk_expr(p, lo, hi,\n-                            ast::expr_field(\n-                                e, p.get_str(i)));\n+                e = mk_expr(p, lo, hi, ast::expr_field(e, p.get_str(i)));\n               }\n               t { unexpected(p, t); }\n             }\n@@ -1119,8 +1095,8 @@ fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n }\n \n fn parse_prefix_expr(p: &parser) -> @ast::expr {\n-    if eat_word(p, ~\"mutable\") {\n-        p.warn(~\"ignoring deprecated 'mutable' prefix operator\");\n+    if eat_word(p, \"mutable\") {\n+        p.warn(\"ignoring deprecated 'mutable' prefix operator\");\n     }\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n@@ -1223,7 +1199,7 @@ fn parse_more_binops(p: &parser, lhs: @ast::expr, min_prec: int) ->\n             ret parse_more_binops(p, bin, min_prec);\n         }\n     }\n-    if as_prec > min_prec && eat_word(p, ~\"as\") {\n+    if as_prec > min_prec && eat_word(p, \"as\") {\n         let rhs = parse_ty(p, true);\n         let _as =\n             mk_expr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n@@ -1286,7 +1262,7 @@ fn parse_if_expr_1(p: &parser) ->\n     let thn = parse_block(p);\n     let els: option::t<@ast::expr> = none;\n     let hi = thn.span.hi;\n-    if eat_word(p, ~\"else\") {\n+    if eat_word(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n@@ -1295,7 +1271,7 @@ fn parse_if_expr_1(p: &parser) ->\n }\n \n fn parse_if_expr(p: &parser) -> @ast::expr {\n-    if eat_word(p, ~\"check\") {\n+    if eat_word(p, \"check\") {\n         let q = parse_if_expr_1(p);\n         ret mk_expr(p, q.lo, q.hi, ast::expr_if_check(q.cond, q.then, q.els));\n     } else {\n@@ -1321,7 +1297,7 @@ fn parse_fn_block_expr(p: &parser) -> @ast::expr {\n }\n \n fn parse_else_expr(p: &parser) -> @ast::expr {\n-    if eat_word(p, ~\"if\") {\n+    if eat_word(p, \"if\") {\n         ret parse_if_expr(p);\n     } else {\n         let blk = parse_block(p);\n@@ -1331,9 +1307,9 @@ fn parse_else_expr(p: &parser) -> @ast::expr {\n \n fn parse_for_expr(p: &parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n-    let is_each = eat_word(p, ~\"each\");\n+    let is_each = eat_word(p, \"each\");\n     let decl = parse_local(p, false);\n-    expect_word(p, ~\"in\");\n+    expect_word(p, \"in\");\n     let seq = parse_expr(p);\n     let body = parse_block(p);\n     let hi = body.span.hi;\n@@ -1353,7 +1329,7 @@ fn parse_while_expr(p: &parser) -> @ast::expr {\n fn parse_do_while_expr(p: &parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let body = parse_block(p);\n-    expect_word(p, ~\"while\");\n+    expect_word(p, \"while\");\n     let cond = parse_expr(p);\n     let hi = cond.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n@@ -1367,9 +1343,7 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     while p.peek() != token::RBRACE {\n         let pats = parse_pats(p);\n         let guard = none;\n-        if eat_word(p, ~\"when\") {\n-            guard = some(parse_expr(p));\n-        }\n+        if eat_word(p, \"when\") { guard = some(parse_expr(p)); }\n         let blk = parse_block(p);\n         arms += [{pats: pats, guard: guard, body: blk}];\n     }\n@@ -1402,6 +1376,7 @@ fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n       }\n \n \n+\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n@@ -1447,8 +1422,8 @@ fn parse_pat(p: &parser) -> @ast::pat {\n             if p.peek() == token::UNDERSCORE {\n                 p.bump();\n                 if p.peek() != token::RBRACE {\n-                    p.fatal(~\"expecting }, found \" +\n-                            token::to_str(p.get_reader(), p.peek()));\n+                    p.fatal(\"expecting }, found \" +\n+                                token::to_str(p.get_reader(), p.peek()));\n                 }\n                 etc = true;\n                 break;\n@@ -1461,8 +1436,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 subpat = parse_pat(p);\n             } else {\n                 if p.get_bad_expr_words().contains_key(fieldname) {\n-                    p.fatal(~\"found \" + fieldname\n-                            + ~\" in binding position\");\n+                    p.fatal(\"found \" + fieldname + \" in binding position\");\n                 }\n                 subpat =\n                     @{id: p.get_id(),\n@@ -1495,23 +1469,8 @@ fn parse_pat(p: &parser) -> @ast::pat {\n             pat = ast::pat_tup(fields);\n         }\n       }\n-      token::TILDE. {\n-        p.bump();\n-        alt p.peek() {\n-          token::LIT_STR(s) {\n-            let sp = p.get_span();\n-            p.bump();\n-            let lit =\n-                @{node: ast::lit_str(p.get_str(s)),\n-                  span: sp};\n-            hi = lit.span.hi;\n-            pat = ast::pat_lit(lit);\n-          }\n-          _ { p.fatal(~\"expected string literal\"); }\n-        }\n-      }\n       tok {\n-        if !is_ident(tok) || is_word(p, ~\"true\") || is_word(p, ~\"false\") {\n+        if !is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\") {\n             let lit = parse_lit(p);\n             hi = lit.span.hi;\n             pat = ast::pat_lit(@lit);\n@@ -1580,7 +1539,7 @@ fn parse_crate_stmt(p: &parser) -> @ast::stmt {\n \n fn parse_source_stmt(p: &parser) -> @ast::stmt {\n     let lo = p.get_lo_pos();\n-    if eat_word(p, ~\"let\") {\n+    if eat_word(p, \"let\") {\n         let decl = parse_let(p);\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n@@ -1600,7 +1559,7 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n         if vec::len(item_attrs) > 0u {\n             alt maybe_item {\n               some(_) {/* fallthrough */ }\n-              _ { ret p.fatal(~\"expected item\"); }\n+              _ { ret p.fatal(\"expected item\"); }\n             }\n         }\n \n@@ -1616,7 +1575,7 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n             let e = parse_expr(p);\n             ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n           }\n-          _ { p.fatal(~\"expected statement\"); }\n+          _ { p.fatal(\"expected statement\"); }\n         }\n     }\n }\n@@ -1677,6 +1636,7 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n       }\n \n \n+\n       // We should not be calling this on a cdir.\n       ast::stmt_crate_directive(cdir) {\n         fail;\n@@ -1686,10 +1646,9 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n \n fn parse_block(p: &parser) -> ast::blk {\n     let lo = p.get_lo_pos();\n-    if eat_word(p, ~\"unchecked\") {\n+    if eat_word(p, \"unchecked\") {\n         be parse_block_tail(p, lo, ast::unchecked);\n-    }\n-    else {\n+    } else {\n         expect(p, token::LBRACE);\n         be parse_block_tail(p, lo, ast::checked);\n     }\n@@ -1716,8 +1675,8 @@ fn parse_block_tail(p: &parser, lo: uint, s: ast::check_mode) -> ast::blk {\n                   token::RBRACE. { expr = some(e); }\n                   t {\n                     if stmt_ends_with_semi(*stmt) {\n-                        p.fatal(~\"expected ';' or '}' after \" +\n-                                    ~\"expression but found \" +\n+                        p.fatal(\"expected ';' or '}' after \" +\n+                                    \"expression but found \" +\n                                     token::to_str(p.get_reader(), t));\n                     }\n                     stmts += [stmt];\n@@ -1935,7 +1894,7 @@ fn parse_mod_items(p: &parser, term: token::token,\n         alt parse_item(p, attrs) {\n           some(i) { items += [i]; }\n           _ {\n-            p.fatal(~\"expected item but found \" +\n+            p.fatal(\"expected item but found \" +\n                         token::to_str(p.get_reader(), p.peek()));\n           }\n         }\n@@ -1985,10 +1944,7 @@ fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n     let t = parse_fn_header(p);\n     let decl = parse_fn_decl(p, ast::impure_fn, ast::il_normal);\n     let link_name = none;\n-    if p.peek() == token::EQ {\n-        p.bump();\n-        link_name = some(parse_str(p));\n-    }\n+    if p.peek() == token::EQ { p.bump(); link_name = some(parse_str(p)); }\n     let hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,\n@@ -2000,15 +1956,14 @@ fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n \n fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::native_item {\n-    if eat_word(p, ~\"type\") {\n+    if eat_word(p, \"type\") {\n         ret parse_item_native_type(p, attrs);\n-    } else if eat_word(p, ~\"fn\") {\n+    } else if eat_word(p, \"fn\") {\n         ret parse_item_native_fn(p, attrs);\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_native_mod_items(p: &parser, native_name: &istr,\n-                          abi: ast::native_abi,\n+fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n                           first_item_attrs: &[ast::attribute]) ->\n    ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n@@ -2032,20 +1987,20 @@ fn parse_native_mod_items(p: &parser, native_name: &istr,\n fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let abi = ast::native_abi_cdecl;\n-    if !is_word(p, ~\"mod\") {\n+    if !is_word(p, \"mod\") {\n         let t = parse_str(p);\n-        if str::eq(t, ~\"cdecl\") {\n-        } else if str::eq(t, ~\"rust\") {\n+        if str::eq(t, \"cdecl\") {\n+        } else if str::eq(t, \"rust\") {\n             abi = ast::native_abi_rust;\n-        } else if str::eq(t, ~\"llvm\") {\n+        } else if str::eq(t, \"llvm\") {\n             abi = ast::native_abi_llvm;\n-        } else if str::eq(t, ~\"rust-intrinsic\") {\n+        } else if str::eq(t, \"rust-intrinsic\") {\n             abi = ast::native_abi_rust_intrinsic;\n-        } else if str::eq(t, ~\"x86stdcall\") {\n+        } else if str::eq(t, \"x86stdcall\") {\n             abi = ast::native_abi_x86stdcall;\n-        } else { p.fatal(~\"unsupported abi: \" + t); }\n+        } else { p.fatal(\"unsupported abi: \" + t); }\n     }\n-    expect_word(p, ~\"mod\");\n+    expect_word(p, \"mod\");\n     let id = parse_ident(p);\n     let native_name;\n     if p.peek() == token::EQ {\n@@ -2087,8 +2042,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     // Newtype syntax\n     if p.peek() == token::EQ {\n         if p.get_bad_expr_words().contains_key(id) {\n-            p.fatal(~\"found \" + id\n-                    + ~\" in tag constructor position\");\n+            p.fatal(\"found \" + id + \" in tag constructor position\");\n         }\n         p.bump();\n         let ty = parse_ty(p, false);\n@@ -2125,13 +2079,12 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n             }\n             expect(p, token::SEMI);\n             p.get_id();\n-            let vr = {name: p.get_str(name),\n-                      args: args, id: p.get_id()};\n+            let vr = {name: p.get_str(name), args: args, id: p.get_id()};\n             variants += [spanned(vlo, vhi, vr)];\n           }\n           token::RBRACE. {/* empty */ }\n           _ {\n-            p.fatal(~\"expected name of variant or '}' but found \" +\n+            p.fatal(\"expected name of variant or '}' but found \" +\n                         token::to_str(p.get_reader(), tok));\n           }\n         }\n@@ -2142,42 +2095,42 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n }\n \n fn parse_auth(p: &parser) -> ast::_auth {\n-    if eat_word(p, ~\"unsafe\") {\n+    if eat_word(p, \"unsafe\") {\n         ret ast::auth_unsafe;\n     } else { unexpected(p, p.peek()); }\n }\n \n fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t<@ast::item> {\n-    if eat_word(p, ~\"const\") {\n+    if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n-    } else if eat_word(p, ~\"inline\") {\n-        expect_word(p, ~\"fn\");\n+    } else if eat_word(p, \"inline\") {\n+        expect_word(p, \"fn\");\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n                                        attrs, ast::il_inline));\n-    } else if is_word(p, ~\"fn\") && p.look_ahead(1u) != token::LPAREN {\n+    } else if is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n                                        attrs, ast::il_normal));\n-    } else if eat_word(p, ~\"pure\") {\n-        expect_word(p, ~\"fn\");\n+    } else if eat_word(p, \"pure\") {\n+        expect_word(p, \"fn\");\n         ret some(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn, attrs,\n                                        ast::il_normal));\n-    } else if eat_word(p, ~\"iter\") {\n+    } else if eat_word(p, \"iter\") {\n         ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n                                        attrs, ast::il_normal));\n-    } else if eat_word(p, ~\"mod\") {\n+    } else if eat_word(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n-    } else if eat_word(p, ~\"native\") {\n+    } else if eat_word(p, \"native\") {\n         ret some(parse_item_native_mod(p, attrs));\n     }\n-    if eat_word(p, ~\"type\") {\n+    if eat_word(p, \"type\") {\n         ret some(parse_item_type(p, attrs));\n-    } else if eat_word(p, ~\"tag\") {\n+    } else if eat_word(p, \"tag\") {\n         ret some(parse_item_tag(p, attrs));\n-    } else if is_word(p, ~\"obj\") && p.look_ahead(1u) != token::LPAREN {\n+    } else if is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_obj(p, attrs));\n-    } else if eat_word(p, ~\"resource\") {\n+    } else if eat_word(p, \"resource\") {\n         ret some(parse_item_res(p, attrs));\n     } else { ret none; }\n }\n@@ -2297,25 +2250,27 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n         alt p.peek() {\n           token::SEMI. { break; }\n           token::MOD_SEP. {\n-            if glob { p.fatal(~\"cannot path into a glob\"); }\n+            if glob { p.fatal(\"cannot path into a glob\"); }\n             if option::is_some(from_idents) {\n-                p.fatal(~\"cannot path into import list\");\n+                p.fatal(\"cannot path into import list\");\n             }\n             p.bump();\n           }\n-          _ { p.fatal(~\"expecting '::' or ';'\"); }\n+          _ { p.fatal(\"expecting '::' or ';'\"); }\n         }\n         alt p.peek() {\n           token::IDENT(_, _) { identifiers += [parse_ident(p)]; }\n \n \n+\n           //the lexer can't tell the different kinds of stars apart ) :\n           token::BINOP(token::STAR.) {\n             glob = true;\n             p.bump();\n           }\n \n \n+\n           token::LBRACE. {\n             fn parse_import_ident(p: &parser) -> ast::import_ident {\n                 let lo = p.get_lo_pos();\n@@ -2327,22 +2282,23 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n                 parse_seq(token::LBRACE, token::RBRACE, some(token::COMMA),\n                           parse_import_ident, p).node;\n             if vec::is_empty(from_idents_) {\n-                p.fatal(~\"at least one import is required\");\n+                p.fatal(\"at least one import is required\");\n             }\n             from_idents = some(from_idents_);\n           }\n \n \n+\n           _ {\n-            p.fatal(~\"expecting an identifier, or '*'\");\n+            p.fatal(\"expecting an identifier, or '*'\");\n           }\n         }\n     }\n     alt def_ident {\n       some(i) {\n-        if glob { p.fatal(~\"globbed imports can't be renamed\"); }\n+        if glob { p.fatal(\"globbed imports can't be renamed\"); }\n         if option::is_some(from_idents) {\n-            p.fatal(~\"can't rename import list\");\n+            p.fatal(\"can't rename import list\");\n         }\n         ret ast::view_item_import(i, identifiers, p.get_id());\n       }\n@@ -2367,10 +2323,9 @@ fn parse_full_import_name(p: &parser, def_ident: &ast::ident) ->\n     alt p.peek() {\n       token::IDENT(i, _) {\n         p.bump();\n-        ret parse_rest_import_name(\n-            p, p.get_str(i), some(def_ident));\n+        ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n       }\n-      _ { p.fatal(~\"expecting an identifier\"); }\n+      _ { p.fatal(\"expecting an identifier\"); }\n     }\n }\n \n@@ -2383,13 +2338,10 @@ fn parse_import(p: &parser) -> ast::view_item_ {\n             p.bump();\n             ret parse_full_import_name(p, p.get_str(i));\n           }\n-          _ {\n-            ret parse_rest_import_name(\n-                p, p.get_str(i), none);\n-          }\n+          _ { ret parse_rest_import_name(p, p.get_str(i), none); }\n         }\n       }\n-      _ { p.fatal(~\"expecting an identifier\"); }\n+      _ { p.fatal(\"expecting an identifier\"); }\n     }\n }\n \n@@ -2403,11 +2355,11 @@ fn parse_export(p: &parser) -> ast::view_item_ {\n fn parse_view_item(p: &parser) -> @ast::view_item {\n     let lo = p.get_lo_pos();\n     let the_item =\n-        if eat_word(p, ~\"use\") {\n+        if eat_word(p, \"use\") {\n             parse_use(p)\n-        } else if eat_word(p, ~\"import\") {\n+        } else if eat_word(p, \"import\") {\n             parse_import(p)\n-        } else if eat_word(p, ~\"export\") { parse_export(p) } else { fail };\n+        } else if eat_word(p, \"export\") { parse_export(p) } else { fail };\n     let hi = p.get_lo_pos();\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, the_item);\n@@ -2417,8 +2369,8 @@ fn is_view_item(p: &parser) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         let st = p.get_str(sid);\n-        ret str::eq(st, ~\"use\") || str::eq(st, ~\"import\") ||\n-                str::eq(st, ~\"export\");\n+        ret str::eq(st, \"use\") || str::eq(st, \"import\") ||\n+                str::eq(st, \"export\");\n       }\n       _ { ret false; }\n     }\n@@ -2436,21 +2388,19 @@ fn parse_native_view(p: &parser) -> [@ast::view_item] {\n     ret items;\n }\n \n-fn parse_crate_from_source_file(input: &istr, cfg: &ast::crate_cfg,\n+fn parse_crate_from_source_file(input: &str, cfg: &ast::crate_cfg,\n                                 sess: &parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, 0u, 0u, SOURCE_FILE);\n     ret parse_crate_mod(p, cfg);\n }\n \n-fn parse_crate_from_source_str(name: &istr, source: &istr,\n-                               cfg: &ast::crate_cfg,\n+fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n                                sess: &parse_sess) -> @ast::crate {\n     let ftype = SOURCE_FILE;\n     let filemap = codemap::new_filemap(name, 0u, 0u);\n     sess.cm.files += [filemap];\n     let itr = @interner::mk(str::hash, str::eq);\n-    let rdr = lexer::new_reader(sess.cm, source,\n-                                filemap, itr);\n+    let rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n     let p = new_parser(sess, cfg, rdr, ftype);\n     ret parse_crate_mod(p, cfg);\n }\n@@ -2468,7 +2418,7 @@ fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) -> @ast::crate {\n                   config: p.get_cfg()});\n }\n \n-fn parse_str(p: &parser) -> istr {\n+fn parse_str(p: &parser) -> str {\n     alt p.peek() {\n       token::LIT_STR(s) { p.bump(); ret p.get_str(s); }\n       _ { fail; }\n@@ -2489,8 +2439,8 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n     let expect_mod = vec::len(outer_attrs) > 0u;\n \n     let lo = p.get_lo_pos();\n-    if expect_mod || is_word(p, ~\"mod\") {\n-        expect_word(p, ~\"mod\");\n+    if expect_mod || is_word(p, \"mod\") {\n+        expect_word(p, \"mod\");\n         let id = parse_ident(p);\n         let file_opt =\n             alt p.peek() {\n@@ -2500,6 +2450,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n         alt p.peek() {\n \n \n+\n           // mod x = \"foo.rs\";\n           token::SEMI. {\n             let hi = p.get_hi_pos();\n@@ -2508,6 +2459,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n           }\n \n \n+\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE. {\n             p.bump();\n@@ -2523,7 +2475,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n           }\n           t { unexpected(p, t); }\n         }\n-    } else if eat_word(p, ~\"auth\") {\n+    } else if eat_word(p, \"auth\") {\n         let n = parse_path(p);\n         expect(p, token::EQ);\n         let a = parse_auth(p);\n@@ -2533,7 +2485,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n     } else if is_view_item(p) {\n         let vi = parse_view_item(p);\n         ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-    } else { ret p.fatal(~\"expected crate directive\"); }\n+    } else { ret p.fatal(\"expected crate directive\"); }\n }\n \n fn parse_crate_directives(p: &parser, term: token::token,\n@@ -2544,7 +2496,7 @@ fn parse_crate_directives(p: &parser, term: token::token,\n     // seeing the terminator next, so if we do see it then fail the same way\n     // parse_crate_directive would\n     if vec::len(first_outer_attr) > 0u && p.peek() == term {\n-        expect_word(p, ~\"mod\");\n+        expect_word(p, \"mod\");\n     }\n \n     let cdirs: [@ast::crate_directive] = [];\n@@ -2555,17 +2507,16 @@ fn parse_crate_directives(p: &parser, term: token::token,\n     ret cdirs;\n }\n \n-fn parse_crate_from_crate_file(input: &istr, cfg: &ast::crate_cfg,\n+fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n                                sess: &parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, 0u, 0u, CRATE_FILE);\n     let lo = p.get_lo_pos();\n-    let prefix =\n-        std::fs::dirname(p.get_filemap().name);\n+    let prefix = std::fs::dirname(p.get_filemap().name);\n     let leading_attrs = parse_inner_attrs_and_next(p);\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n     let cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n-    let deps: [istr] = [];\n+    let deps: [str] = [];\n     let cx =\n         @{p: p,\n           mode: eval::mode_parse,\n@@ -2584,15 +2535,14 @@ fn parse_crate_from_crate_file(input: &istr, cfg: &ast::crate_cfg,\n                   config: p.get_cfg()});\n }\n \n-fn parse_crate_from_file(input: &istr, cfg: &ast::crate_cfg,\n-                         sess: &parse_sess) -> @ast::crate {\n-    if str::ends_with(input, ~\".rc\") {\n+fn parse_crate_from_file(input: &str, cfg: &ast::crate_cfg, sess: &parse_sess)\n+   -> @ast::crate {\n+    if str::ends_with(input, \".rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n-    } else if str::ends_with(input, ~\".rs\") {\n+    } else if str::ends_with(input, \".rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n-        codemap::emit_error(none, ~\"unknown input file type: \"\n-                            + input,\n+        codemap::emit_error(none, \"unknown input file type: \" + input,\n                             sess.cm);\n         fail\n     }"}, {"sha": "153f5236c4ba45d4469cf8dc5366318de342c5b2", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -84,62 +84,64 @@ tag token {\n     EOF;\n }\n \n-fn binop_to_str(o: binop) -> istr {\n+fn binop_to_str(o: binop) -> str {\n     alt o {\n-      PLUS. { ret ~\"+\"; }\n-      MINUS. { ret ~\"-\"; }\n-      STAR. { ret ~\"*\"; }\n-      SLASH. { ret ~\"/\"; }\n-      PERCENT. { ret ~\"%\"; }\n-      CARET. { ret ~\"^\"; }\n-      AND. { ret ~\"&\"; }\n-      OR. { ret ~\"|\"; }\n-      LSL. { ret ~\"<<\"; }\n-      LSR. { ret ~\">>\"; }\n-      ASR. { ret ~\">>>\"; }\n+      PLUS. { ret \"+\"; }\n+      MINUS. { ret \"-\"; }\n+      STAR. { ret \"*\"; }\n+      SLASH. { ret \"/\"; }\n+      PERCENT. { ret \"%\"; }\n+      CARET. { ret \"^\"; }\n+      AND. { ret \"&\"; }\n+      OR. { ret \"|\"; }\n+      LSL. { ret \"<<\"; }\n+      LSR. { ret \">>\"; }\n+      ASR. { ret \">>>\"; }\n     }\n }\n \n-fn to_str(r: lexer::reader, t: token) -> istr {\n+fn to_str(r: lexer::reader, t: token) -> str {\n     alt t {\n-      EQ. { ret ~\"=\"; }\n-      LT. { ret ~\"<\"; }\n-      LE. { ret ~\"<=\"; }\n-      EQEQ. { ret ~\"==\"; }\n-      NE. { ret ~\"!=\"; }\n-      GE. { ret ~\">=\"; }\n-      GT. { ret ~\">\"; }\n-      NOT. { ret ~\"!\"; }\n-      TILDE. { ret ~\"~\"; }\n-      OROR. { ret ~\"||\"; }\n-      ANDAND. { ret ~\"&&\"; }\n+      EQ. { ret \"=\"; }\n+      LT. { ret \"<\"; }\n+      LE. { ret \"<=\"; }\n+      EQEQ. { ret \"==\"; }\n+      NE. { ret \"!=\"; }\n+      GE. { ret \">=\"; }\n+      GT. { ret \">\"; }\n+      NOT. { ret \"!\"; }\n+      TILDE. { ret \"~\"; }\n+      OROR. { ret \"||\"; }\n+      ANDAND. { ret \"&&\"; }\n       BINOP(op) { ret binop_to_str(op); }\n-      BINOPEQ(op) { ret binop_to_str(op) + ~\"=\"; }\n+      BINOPEQ(op) { ret binop_to_str(op) + \"=\"; }\n+\n \n \n       /* Structural symbols */\n       AT. {\n-        ret ~\"@\";\n+        ret \"@\";\n       }\n-      DOT. { ret ~\".\"; }\n-      ELLIPSIS. { ret ~\"...\"; }\n-      COMMA. { ret ~\",\"; }\n-      SEMI. { ret ~\";\"; }\n-      COLON. { ret ~\":\"; }\n-      MOD_SEP. { ret ~\"::\"; }\n-      QUES. { ret ~\"?\"; }\n-      RARROW. { ret ~\"->\"; }\n-      LARROW. { ret ~\"<-\"; }\n-      DARROW. { ret ~\"<->\"; }\n-      LPAREN. { ret ~\"(\"; }\n-      RPAREN. { ret ~\")\"; }\n-      LBRACKET. { ret ~\"[\"; }\n-      RBRACKET. { ret ~\"]\"; }\n-      LBRACE. { ret ~\"{\"; }\n-      RBRACE. { ret ~\"}\"; }\n-      POUND. { ret ~\"#\"; }\n-      POUND_LBRACE. { ret ~\"#{\"; }\n-      POUND_LT. { ret ~\"#<\"; }\n+      DOT. { ret \".\"; }\n+      ELLIPSIS. { ret \"...\"; }\n+      COMMA. { ret \",\"; }\n+      SEMI. { ret \";\"; }\n+      COLON. { ret \":\"; }\n+      MOD_SEP. { ret \"::\"; }\n+      QUES. { ret \"?\"; }\n+      RARROW. { ret \"->\"; }\n+      LARROW. { ret \"<-\"; }\n+      DARROW. { ret \"<->\"; }\n+      LPAREN. { ret \"(\"; }\n+      RPAREN. { ret \")\"; }\n+      LBRACKET. { ret \"[\"; }\n+      RBRACKET. { ret \"]\"; }\n+      LBRACE. { ret \"{\"; }\n+      RBRACE. { ret \"}\"; }\n+      POUND. { ret \"#\"; }\n+      POUND_LBRACE. { ret \"#{\"; }\n+      POUND_LT. { ret \"#<\"; }\n+\n \n \n       /* Literals */\n@@ -148,39 +150,35 @@ fn to_str(r: lexer::reader, t: token) -> istr {\n       }\n       LIT_UINT(u) { ret uint::to_str(u, 10u); }\n       LIT_MACH_INT(tm, i) {\n-        ret int::to_str(i, 10u) + ~\"_\" + ty_mach_to_str(tm);\n+        ret int::to_str(i, 10u) + \"_\" + ty_mach_to_str(tm);\n       }\n       LIT_MACH_FLOAT(tm, s) {\n-        ret interner::get::<istr>(\n-            *r.get_interner(), s) + ~\"_\" +\n-            ty_mach_to_str(tm);\n-      }\n-      LIT_FLOAT(s) {\n-        ret interner::get::<istr>(*r.get_interner(), s);\n+        ret interner::get::<str>(*r.get_interner(), s) + \"_\" +\n+                ty_mach_to_str(tm);\n       }\n+      LIT_FLOAT(s) { ret interner::get::<str>(*r.get_interner(), s); }\n       LIT_STR(s) { // FIXME: escape.\n-        ret ~\"\\\"\" +\n-            interner::get::<istr>(*r.get_interner(), s)\n-            + ~\"\\\"\";\n+        ret \"\\\"\" + interner::get::<str>(*r.get_interner(), s) + \"\\\"\";\n       }\n       LIT_CHAR(c) {\n         // FIXME: escape.\n-        let tmp = ~\"'\";\n+        let tmp = \"'\";\n         str::push_char(tmp, c);\n         str::push_byte(tmp, '\\'' as u8);\n         ret tmp;\n       }\n-      LIT_BOOL(b) { if b { ret ~\"true\"; } else { ret ~\"false\"; } }\n+      LIT_BOOL(b) { if b { ret \"true\"; } else { ret \"false\"; } }\n+\n \n \n       /* Name components */\n       IDENT(s, _) {\n-        ret interner::get::<istr>(*r.get_interner(), s);\n+        ret interner::get::<str>(*r.get_interner(), s);\n       }\n-      IDX(i) { ret ~\"_\" + int::to_str(i, 10u); }\n-      UNDERSCORE. { ret ~\"_\"; }\n-      BRACEQUOTE(_) { ret ~\"<bracequote>\"; }\n-      EOF. { ret ~\"<eof>\"; }\n+      IDX(i) { ret \"_\" + int::to_str(i, 10u); }\n+      UNDERSCORE. { ret \"_\"; }\n+      BRACEQUOTE(_) { ret \"<bracequote>\"; }\n+      EOF. { ret \"<eof>\"; }\n     }\n }\n "}, {"sha": "fad670fbefbf90a85f4ce682b88c16f7be5cfa9e", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -61,35 +61,33 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-tag token { STRING(istr, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n+tag token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n \n-fn tok_str(t: token) -> istr {\n+fn tok_str(t: token) -> str {\n     alt t {\n-      STRING(s, len) {\n-        ret #fmt[~\"STR(%s,%d)\", s, len];\n-      }\n-      BREAK(_) { ret ~\"BREAK\"; }\n-      BEGIN(_) { ret ~\"BEGIN\"; }\n-      END. { ret ~\"END\"; }\n-      EOF. { ret ~\"EOF\"; }\n+      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n+      BREAK(_) { ret \"BREAK\"; }\n+      BEGIN(_) { ret \"BEGIN\"; }\n+      END. { ret \"END\"; }\n+      EOF. { ret \"EOF\"; }\n     }\n }\n \n fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n-           right: uint, lim: uint) -> istr {\n+           right: uint, lim: uint) -> str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n     let i = left;\n     let L = lim;\n-    let s = ~\"[\";\n+    let s = \"[\";\n     while i != right && L != 0u {\n         L -= 1u;\n-        if i != left { s += ~\", \"; }\n-        s += #fmt[~\"%d=%s\", szs[i], tok_str(toks[i])];\n+        if i != left { s += \", \"; }\n+        s += #fmt[\"%d=%s\", szs[i], tok_str(toks[i])];\n         i += 1u;\n         i %= n;\n     }\n-    s += ~\"]\";\n+    s += \"]\";\n     ret s;\n }\n \n@@ -104,7 +102,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n \n     let n: uint = 3u * linewidth;\n-    log #fmt[~\"mk_printer %u\", linewidth];\n+    log #fmt[\"mk_printer %u\", linewidth];\n     let token: [mutable token] = vec::init_elt_mut(EOF, n);\n     let size: [mutable int] = vec::init_elt_mut(0, n);\n     let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n@@ -244,7 +242,7 @@ obj printer(out: io::writer,\n     fn replace_last_token(t: token) { token[right] = t; }\n \n     fn pretty_print(t: token) {\n-        log #fmt[~\"pp [%u,%u]\", left, right];\n+        log #fmt[\"pp [%u,%u]\", left, right];\n         alt t {\n           EOF. {\n             if !scan_stack_empty {\n@@ -260,17 +258,17 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt[~\"pp BEGIN/buffer [%u,%u]\", left, right];\n+            log #fmt[\"pp BEGIN/buffer [%u,%u]\", left, right];\n             token[right] = t;\n             size[right] = -right_total;\n             self.scan_push(right);\n           }\n           END. {\n             if scan_stack_empty {\n-                log #fmt[~\"pp END/print [%u,%u]\", left, right];\n+                log #fmt[\"pp END/print [%u,%u]\", left, right];\n                 self.print(t, 0);\n             } else {\n-                log #fmt[~\"pp END/buffer [%u,%u]\", left, right];\n+                log #fmt[\"pp END/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = -1;\n@@ -284,7 +282,7 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #fmt[~\"pp BREAK/buffer [%u,%u]\", left, right];\n+            log #fmt[\"pp BREAK/buffer [%u,%u]\", left, right];\n             self.check_stack(0);\n             self.scan_push(right);\n             token[right] = t;\n@@ -293,10 +291,10 @@ obj printer(out: io::writer,\n           }\n           STRING(s, len) {\n             if scan_stack_empty {\n-                log #fmt[~\"pp STRING/print [%u,%u]\", left, right];\n+                log #fmt[\"pp STRING/print [%u,%u]\", left, right];\n                 self.print(t, len);\n             } else {\n-                log #fmt[~\"pp STRING/buffer [%u,%u]\", left, right];\n+                log #fmt[\"pp STRING/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = len;\n@@ -307,10 +305,10 @@ obj printer(out: io::writer,\n         }\n     }\n     fn check_stream() {\n-        log #fmt[~\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+        log #fmt[\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n                  left, right, left_total, right_total];\n         if right_total - left_total > space {\n-            log #fmt[~\"scan window is %d, longer than space on line (%d)\",\n+            log #fmt[\"scan window is %d, longer than space on line (%d)\",\n                      right_total - left_total, space];\n             if !scan_stack_empty {\n                 if left == scan_stack[bottom] {\n@@ -392,7 +390,7 @@ obj printer(out: io::writer,\n     }\n     fn print_newline(amount: int) {\n         log #fmt[\"NEWLINE %d\", amount];\n-        out.write_str(~\"\\n\");\n+        out.write_str(\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n@@ -406,16 +404,15 @@ obj printer(out: io::writer,\n         if n != 0u { top = print_stack[n - 1u]; }\n         ret top;\n     }\n-    fn write_str(s: &istr) {\n+    fn write_str(s: &str) {\n         while pending_indentation > 0 {\n-            out.write_str(~\" \");\n+            out.write_str(\" \");\n             pending_indentation -= 1;\n         }\n         out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        log #fmt[\"print %s %d (remaining line space=%d)\",\n-                 tok_str(x), L,\n+        log #fmt[\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n                  space];\n         log buf_str(token, size, left, right, 6u);\n         alt x {\n@@ -495,15 +492,15 @@ fn end(p: printer) { p.pretty_print(END); }\n \n fn eof(p: printer) { p.pretty_print(EOF); }\n \n-fn word(p: printer, wrd: &istr) {\n+fn word(p: printer, wrd: &str) {\n     p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n }\n \n-fn huge_word(p: printer, wrd: &istr) {\n+fn huge_word(p: printer, wrd: &str) {\n     p.pretty_print(STRING(wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: &istr) { p.pretty_print(STRING(wrd, 0)); }\n+fn zero_word(p: printer, wrd: &str) { p.pretty_print(STRING(wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "442756a790d410478449f0fd917e26a3482a0607", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 259, "deletions": 294, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -74,11 +74,10 @@ const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: &codemap, crate: @ast::crate, filename: &istr,\n+fn print_crate(cm: &codemap, crate: @ast::crate, filename: &str,\n                in: io::reader, out: io::writer, ann: &pp_ann) {\n     let boxes: [pp::breaks] = [];\n-    let r = lexer::gather_comments_and_literals(\n-        cm, filename, in);\n+    let r = lexer::gather_comments_and_literals(cm, filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n           cm: some(cm),\n@@ -93,30 +92,30 @@ fn print_crate(cm: &codemap, crate: @ast::crate, filename: &istr,\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: &@ast::ty) -> istr { be to_str(ty, print_type); }\n+fn ty_to_str(ty: &@ast::ty) -> str { be to_str(ty, print_type); }\n \n-fn pat_to_str(pat: &@ast::pat) -> istr { be to_str(pat, print_pat); }\n+fn pat_to_str(pat: &@ast::pat) -> str { be to_str(pat, print_pat); }\n \n-fn expr_to_str(e: &@ast::expr) -> istr { be to_str(e, print_expr); }\n+fn expr_to_str(e: &@ast::expr) -> str { be to_str(e, print_expr); }\n \n-fn stmt_to_str(s: &ast::stmt) -> istr { be to_str(s, print_stmt); }\n+fn stmt_to_str(s: &ast::stmt) -> str { be to_str(s, print_stmt); }\n \n-fn item_to_str(i: &@ast::item) -> istr { be to_str(i, print_item); }\n+fn item_to_str(i: &@ast::item) -> str { be to_str(i, print_item); }\n \n-fn path_to_str(p: &ast::path) -> istr {\n+fn path_to_str(p: &ast::path) -> str {\n     be to_str(p, bind print_path(_, _, false));\n }\n \n-fn fun_to_str(f: &ast::_fn, name: &ast::ident,\n-              params: &[ast::ty_param]) -> istr {\n+fn fun_to_str(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) ->\n+   str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n-fn block_to_str(blk: &ast::blk) -> istr {\n+fn block_to_str(blk: &ast::blk) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     // containing cbox, will be closed by print-block at }\n@@ -130,29 +129,29 @@ fn block_to_str(blk: &ast::blk) -> istr {\n     ret writer.get_str();\n }\n \n-fn meta_item_to_str(mi: &ast::meta_item) -> istr {\n+fn meta_item_to_str(mi: &ast::meta_item) -> str {\n     ret to_str(@mi, print_meta_item);\n }\n \n-fn attribute_to_str(attr: &ast::attribute) -> istr {\n+fn attribute_to_str(attr: &ast::attribute) -> str {\n     be to_str(attr, print_attribute);\n }\n \n fn cbox(s: &ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n \n fn box(s: &ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n \n-fn nbsp(s: &ps) { word(s.s, ~\" \"); }\n+fn nbsp(s: &ps) { word(s.s, \" \"); }\n \n-fn word_nbsp(s: &ps, w: &istr) { word(s.s, w); nbsp(s); }\n+fn word_nbsp(s: &ps, w: &str) { word(s.s, w); nbsp(s); }\n \n-fn word_space(s: &ps, w: &istr) { word(s.s, w); space(s.s); }\n+fn word_space(s: &ps, w: &str) { word(s.s, w); space(s.s); }\n \n-fn popen(s: &ps) { word(s.s, ~\"(\"); }\n+fn popen(s: &ps) { word(s.s, \"(\"); }\n \n-fn pclose(s: &ps) { word(s.s, ~\")\"); }\n+fn pclose(s: &ps) { word(s.s, \")\"); }\n \n-fn head(s: &ps, w: &istr) {\n+fn head(s: &ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -162,14 +161,14 @@ fn head(s: &ps, w: &istr) {\n }\n \n fn bopen(s: &ps) {\n-    word(s.s, ~\"{\");\n+    word(s.s, \"{\");\n     end(s); // close the head-box\n }\n \n fn bclose_(s: &ps, span: codemap::span, indented: uint) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n-    word(s.s, ~\"}\");\n+    word(s.s, \"}\");\n     end(s); // close the outer-box\n }\n fn bclose(s: &ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n@@ -204,19 +203,19 @@ fn break_offset_if_not_bol(s: &ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-fn synth_comment(s: &ps, text: &istr) {\n-    word(s.s, ~\"/*\");\n+fn synth_comment(s: &ps, text: &str) {\n+    word(s.s, \"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n-    word(s.s, ~\"*/\");\n+    word(s.s, \"*/\");\n }\n \n fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN)) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN in elts {\n-        if first { first = false; } else { word_space(s, ~\",\"); }\n+        if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n     end(s);\n@@ -233,7 +232,7 @@ fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN),\n         op(s, elt);\n         i += 1u;\n         if i < len {\n-            word(s.s, ~\",\");\n+            word(s.s, \",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n                                          some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n@@ -268,78 +267,76 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n-      ast::ty_nil. { word(s.s, ~\"()\"); }\n-      ast::ty_bool. { word(s.s, ~\"bool\"); }\n-      ast::ty_bot. { word(s.s, ~\"!\"); }\n-      ast::ty_int. { word(s.s, ~\"int\"); }\n-      ast::ty_uint. { word(s.s, ~\"uint\"); }\n-      ast::ty_float. { word(s.s, ~\"float\"); }\n-      ast::ty_machine(tm) {\n-        word(s.s, ast_util::ty_mach_to_str(tm));\n-      }\n-      ast::ty_char. { word(s.s, ~\"char\"); }\n-      ast::ty_istr. { word(s.s, ~\"str\"); }\n-      ast::ty_box(mt) { word(s.s, ~\"@\"); print_mt(s, mt); }\n+      ast::ty_nil. { word(s.s, \"()\"); }\n+      ast::ty_bool. { word(s.s, \"bool\"); }\n+      ast::ty_bot. { word(s.s, \"!\"); }\n+      ast::ty_int. { word(s.s, \"int\"); }\n+      ast::ty_uint. { word(s.s, \"uint\"); }\n+      ast::ty_float. { word(s.s, \"float\"); }\n+      ast::ty_machine(tm) { word(s.s, ast_util::ty_mach_to_str(tm)); }\n+      ast::ty_char. { word(s.s, \"char\"); }\n+      ast::ty_str. { word(s.s, \"str\"); }\n+      ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n       ast::ty_vec(mt) {\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         alt mt.mut {\n-          ast::mut. { word_space(s, ~\"mutable\"); }\n-          ast::maybe_mut. { word_space(s, ~\"mutable?\"); }\n+          ast::mut. { word_space(s, \"mutable\"); }\n+          ast::maybe_mut. { word_space(s, \"mutable?\"); }\n           ast::imm. { }\n         }\n         print_type(s, mt.ty);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n-      ast::ty_ptr(mt) { word(s.s, ~\"*\"); print_mt(s, mt); }\n-      ast::ty_task. { word(s.s, ~\"task\"); }\n+      ast::ty_ptr(mt) { word(s.s, \"*\"); print_mt(s, mt); }\n+      ast::ty_task. { word(s.s, \"task\"); }\n       ast::ty_port(t) {\n-        word(s.s, ~\"port<\");\n+        word(s.s, \"port<\");\n         print_type(s, t);\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n       }\n       ast::ty_chan(t) {\n-        word(s.s, ~\"chan<\");\n+        word(s.s, \"chan<\");\n         print_type(s, t);\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n       }\n       ast::ty_rec(fields) {\n-        word(s.s, ~\"{\");\n+        word(s.s, \"{\");\n         fn print_field(s: &ps, f: &ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mut);\n             word(s.s, f.node.ident);\n-            word_space(s, ~\":\");\n+            word_space(s, \":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n         }\n         fn get_span(f: &ast::ty_field) -> codemap::span { ret f.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::ty_tup(elts) {\n         popen(s);\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        print_ty_fn(s, proto, none::<istr>, inputs, output, cf, constrs);\n+        print_ty_fn(s, proto, none::<str>, inputs, output, cf, constrs);\n       }\n       ast::ty_obj(methods) {\n-        head(s, ~\"obj\");\n+        head(s, \"obj\");\n         bopen(s);\n         for m: ast::ty_method in methods {\n             hardbreak_if_not_bol(s);\n             cbox(s, indent_unit);\n             maybe_print_comment(s, m.span.lo);\n             print_ty_fn(s, m.node.proto, some(m.node.ident), m.node.inputs,\n                         m.node.output, m.node.cf, m.node.constrs);\n-            word(s.s, ~\";\");\n+            word(s.s, \";\");\n             end(s);\n         }\n         bclose(s, ty.span);\n       }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n-      ast::ty_type. { word(s.s, ~\"type\"); }\n+      ast::ty_type. { word(s.s, \"type\"); }\n       ast::ty_constr(t, cs) {\n         print_type(s, t);\n         space(s.s);\n@@ -357,29 +354,26 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n       ast::native_item_ty. {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n-        word_nbsp(s, ~\"type\");\n+        word_nbsp(s, \"type\");\n         word(s.s, item.ident);\n         end(s); // end the inner ibox\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer ibox\n \n       }\n \n \n \n+\n       ast::native_item_fn(lname, decl, typarams) {\n         print_fn(s, decl, ast::proto_fn, item.ident, typarams,\n                  decl.constraints);\n         alt lname {\n           none. { }\n-          some(ss) {\n-            space(s.s);\n-            word_space(s, ~\"=\");\n-            print_string(s, ss);\n-          }\n+          some(ss) { space(s.s); word_space(s, \"=\"); print_string(s, ss); }\n         }\n         end(s); // end head-ibox\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n     }\n@@ -393,46 +387,46 @@ fn print_item(s: &ps, item: &@ast::item) {\n     s.ann.pre(ann_node);\n     alt item.node {\n       ast::item_const(ty, expr) {\n-        head(s, ~\"const\");\n-        word_space(s, item.ident + ~\":\");\n+        head(s, \"const\");\n+        word_space(s, item.ident + \":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n \n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, expr);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer cbox\n \n       }\n       ast::item_fn(_fn, typarams) {\n         print_fn(s, _fn.decl, _fn.proto, item.ident, typarams,\n                  _fn.decl.constraints);\n-        word(s.s, ~\" \");\n+        word(s.s, \" \");\n         print_block(s, _fn.body);\n       }\n       ast::item_mod(_mod) {\n-        head(s, ~\"mod\");\n+        head(s, \"mod\");\n         word_nbsp(s, item.ident);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n       ast::item_native_mod(nmod) {\n-        head(s, ~\"native\");\n+        head(s, \"native\");\n         alt nmod.abi {\n-          ast::native_abi_llvm. { word_nbsp(s, ~\"\\\"llvm\\\"\"); }\n-          ast::native_abi_rust. { word_nbsp(s, ~\"\\\"rust\\\"\"); }\n-          ast::native_abi_cdecl. { word_nbsp(s, ~\"\\\"cdecl\\\"\"); }\n+          ast::native_abi_llvm. { word_nbsp(s, \"\\\"llvm\\\"\"); }\n+          ast::native_abi_rust. { word_nbsp(s, \"\\\"rust\\\"\"); }\n+          ast::native_abi_cdecl. { word_nbsp(s, \"\\\"cdecl\\\"\"); }\n           ast::native_abi_rust_intrinsic. {\n-            word_nbsp(s, ~\"\\\"rust-intrinsic\\\"\");\n+            word_nbsp(s, \"\\\"rust-intrinsic\\\"\");\n           }\n-          ast::native_abi_x86stdcall. { word_nbsp(s, ~\"\\\"x86stdcall\\\"\"); }\n+          ast::native_abi_x86stdcall. { word_nbsp(s, \"\\\"x86stdcall\\\"\"); }\n         }\n-        word_nbsp(s, ~\"mod\");\n+        word_nbsp(s, \"mod\");\n         word_nbsp(s, item.ident);\n         if !str::eq(nmod.native_name, item.ident) {\n-            word_space(s, ~\"=\");\n+            word_space(s, \"=\");\n             print_string(s, nmod.native_name);\n             nbsp(s);\n         }\n@@ -443,15 +437,15 @@ fn print_item(s: &ps, item: &@ast::item) {\n       ast::item_ty(ty, params) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n-        word_nbsp(s, ~\"type\");\n+        word_nbsp(s, \"type\");\n         word(s.s, item.ident);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n         space(s.s);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_type(s, ty);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer ibox\n       }\n       ast::item_tag(variants, params) {\n@@ -461,15 +455,15 @@ fn print_item(s: &ps, item: &@ast::item) {\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n-            word_space(s, ~\"tag\");\n-        } else { head(s, ~\"tag\"); }\n+            word_space(s, \"tag\");\n+        } else { head(s, \"tag\"); }\n         word(s.s, item.ident);\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n-            word_space(s, ~\"=\");\n+            word_space(s, \"=\");\n             print_type(s, variants[0].node.args[0].ty);\n-            word(s.s, ~\";\");\n+            word(s.s, \";\");\n             end(s);\n         } else {\n             bopen(s);\n@@ -485,21 +479,21 @@ fn print_item(s: &ps, item: &@ast::item) {\n                     commasep(s, consistent, v.node.args, print_variant_arg);\n                     pclose(s);\n                 }\n-                word(s.s, ~\";\");\n+                word(s.s, \";\");\n                 maybe_print_trailing_comment(s, v.span, none::<uint>);\n             }\n             bclose(s, item.span);\n         }\n       }\n       ast::item_obj(_obj, params, _) {\n-        head(s, ~\"obj\");\n+        head(s, \"obj\");\n         word(s.s, item.ident);\n         print_type_params(s, params);\n         popen(s);\n         fn print_field(s: &ps, field: &ast::obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, field.ident + ~\":\");\n+            word_space(s, field.ident + \":\");\n             print_type(s, field.ty);\n             end(s);\n         }\n@@ -514,17 +508,17 @@ fn print_item(s: &ps, item: &@ast::item) {\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n                      meth.node.ident, typarams, []);\n-            word(s.s, ~\" \");\n+            word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n         bclose(s, item.span);\n       }\n       ast::item_res(dt, dt_id, tps, ct_id) {\n-        head(s, ~\"resource\");\n+        head(s, \"resource\");\n         word(s.s, item.ident);\n         print_type_params(s, tps);\n         popen(s);\n-        word_space(s, dt.decl.inputs[0].ident + ~\":\");\n+        word_space(s, dt.decl.inputs[0].ident + \":\");\n         print_type(s, dt.decl.inputs[0].ty);\n         pclose(s);\n         space(s.s);\n@@ -551,7 +545,7 @@ fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n         alt attr.node.style {\n           ast::attr_inner. {\n             print_attribute(s, attr);\n-            word(s.s, ~\";\");\n+            word(s.s, \";\");\n             count += 1;\n           }\n           _ {/* fallthrough */ }\n@@ -563,9 +557,9 @@ fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n fn print_attribute(s: &ps, attr: &ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n-    word(s.s, ~\"#[\");\n+    word(s.s, \"#[\");\n     print_meta_item(s, @attr.node.value);\n-    word(s.s, ~\"]\");\n+    word(s.s, \"]\");\n }\n \n fn print_stmt(s: &ps, st: &ast::stmt) {\n@@ -574,7 +568,7 @@ fn print_stmt(s: &ps, st: &ast::stmt) {\n       ast::stmt_decl(decl, _) { print_decl(s, decl); }\n       ast::stmt_expr(expr, _) { space_if_not_bol(s); print_expr(s, expr); }\n     }\n-    if parse::parser::stmt_ends_with_semi(st) { word(s.s, ~\";\"); }\n+    if parse::parser::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, none::<uint>);\n }\n \n@@ -586,16 +580,13 @@ tag embed_type { block_macro; block_block_fn; block_normal; }\n \n fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n                                  indented: uint) {\n-    alt blk.node.rules {\n-      ast::unchecked. { word(s.s, ~\"unchecked\"); }\n-      _ {}\n-    }\n+    alt blk.node.rules { ast::unchecked. { word(s.s, \"unchecked\"); } _ { } }\n \n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n     alt embedded {\n-      block_macro. { word(s.s, ~\"#{\"); end(s); }\n+      block_macro. { word(s.s, \"#{\"); end(s); }\n       block_block_fn. { end(s); }\n       block_normal. { bopen(s); }\n     }\n@@ -649,7 +640,7 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n               _ { false }\n             };\n \n-        if last_expr_is_block && next_expr_is_ambig { word(s.s, ~\";\"); }\n+        if last_expr_is_block && next_expr_is_ambig { word(s.s, \";\"); }\n \n         fn expr_is_ambig(ex: @ast::expr) -> bool {\n             // We're going to walk the expression to the 'left' looking for\n@@ -712,8 +703,8 @@ fn print_maybe_parens_discrim(s: &ps, e: &@ast::expr) {\n \n fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n             elseopt: &option::t<@ast::expr>, chk: bool) {\n-    head(s, ~\"if\");\n-    if chk { word_nbsp(s, ~\"check\"); }\n+    head(s, \"if\");\n+    if chk { word_nbsp(s, \"check\"); }\n     print_maybe_parens_discrim(s, test);\n     space(s.s);\n     print_block(s, blk);\n@@ -723,23 +714,25 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n             alt _else.node {\n \n \n+\n               // \"another else-if\"\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, ~\" else if \");\n+                word(s.s, \" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n                 print_block(s, t);\n                 do_else(s, e);\n               }\n \n \n+\n               // \"final else\"\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, ~\" else \");\n+                word(s.s, \" else \");\n                 print_block(s, b);\n               }\n             }\n@@ -753,21 +746,21 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n fn print_mac(s: &ps, m: &ast::mac) {\n     alt m.node {\n       ast::mac_invoc(path, arg, body) {\n-        word(s.s, ~\"#\");\n+        word(s.s, \"#\");\n         print_path(s, path, false);\n-        alt arg.node { ast::expr_vec(_, _) { } _ { word(s.s, ~\" \"); } }\n+        alt arg.node { ast::expr_vec(_, _) { } _ { word(s.s, \" \"); } }\n         print_expr(s, arg);\n         // FIXME: extension 'body'\n       }\n       ast::mac_embed_type(ty) {\n-        word(s.s, ~\"#<\");\n+        word(s.s, \"#<\");\n         print_type(s, ty);\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n       }\n       ast::mac_embed_block(blk) {\n         print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n       }\n-      ast::mac_ellipsis. { word(s.s, ~\"...\"); }\n+      ast::mac_ellipsis. { word(s.s, \"...\"); }\n     }\n }\n \n@@ -779,38 +772,38 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n     alt expr.node {\n       ast::expr_vec(exprs, mut) {\n         ibox(s, indent_unit);\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         if mut == ast::mut {\n-            word(s.s, ~\"mutable\");\n+            word(s.s, \"mutable\");\n             if vec::len(exprs) > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, exprs);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n         end(s);\n       }\n       ast::expr_rec(fields, wth) {\n         fn print_field(s: &ps, field: &ast::field) {\n             ibox(s, indent_unit);\n-            if field.node.mut == ast::mut { word_nbsp(s, ~\"mutable\"); }\n+            if field.node.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n             word(s.s, field.node.ident);\n-            word_space(s, ~\":\");\n+            word_space(s, \":\");\n             print_expr(s, field.node.expr);\n             end(s);\n         }\n         fn get_span(field: &ast::field) -> codemap::span { ret field.span; }\n-        word(s.s, ~\"{\");\n+        word(s.s, \"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         alt wth {\n           some(expr) {\n             if vec::len(fields) > 0u { space(s.s); }\n             ibox(s, indent_unit);\n-            word_space(s, ~\"with\");\n+            word_space(s, \"with\");\n             print_expr(s, expr);\n             end(s);\n           }\n           _ { }\n         }\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::expr_tup(exprs) {\n         popen(s);\n@@ -824,17 +817,17 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         pclose(s);\n       }\n       ast::expr_self_method(ident) {\n-        word(s.s, ~\"self.\");\n+        word(s.s, \"self.\");\n         print_ident(s, ident);\n       }\n       ast::expr_bind(func, args) {\n         fn print_opt(s: &ps, expr: &option::t<@ast::expr>) {\n             alt expr {\n               some(expr) { print_expr(s, expr); }\n-              _ { word(s.s, ~\"_\"); }\n+              _ { word(s.s, \"_\"); }\n             }\n         }\n-        word_nbsp(s, ~\"bind\");\n+        word_nbsp(s, \"bind\");\n         print_expr(s, func);\n         popen(s);\n         commasep(s, inconsistent, args, print_opt);\n@@ -855,7 +848,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n       ast::expr_cast(expr, ty) {\n         print_maybe_parens(s, expr, parse::parser::as_prec);\n         space(s.s);\n-        word_space(s, ~\"as\");\n+        word_space(s, \"as\");\n         print_type(s, ty);\n       }\n       ast::expr_if(test, blk, elseopt) {\n@@ -867,42 +860,42 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n       ast::expr_ternary(test, then, els) {\n         print_expr(s, test);\n         space(s.s);\n-        word_space(s, ~\"?\");\n+        word_space(s, \"?\");\n         print_expr(s, then);\n         space(s.s);\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         print_expr(s, els);\n       }\n       ast::expr_while(test, blk) {\n-        head(s, ~\"while\");\n+        head(s, \"while\");\n         print_maybe_parens_discrim(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_for(decl, expr, blk) {\n-        head(s, ~\"for\");\n+        head(s, \"for\");\n         print_for_decl(s, decl, expr);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_for_each(decl, expr, blk) {\n-        head(s, ~\"for each\");\n+        head(s, \"for each\");\n         print_for_decl(s, decl, expr);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_do_while(blk, expr) {\n-        head(s, ~\"do\");\n+        head(s, \"do\");\n         space(s.s);\n         print_block(s, blk);\n         space(s.s);\n-        word_space(s, ~\"while\");\n+        word_space(s, \"while\");\n         print_expr(s, expr);\n       }\n       ast::expr_alt(expr, arms) {\n         cbox(s, alt_indent_unit);\n         ibox(s, 4u);\n-        word_nbsp(s, ~\"alt\");\n+        word_nbsp(s, \"alt\");\n         print_maybe_parens_discrim(s, expr);\n         space(s.s);\n         bopen(s);\n@@ -914,17 +907,13 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             for p: @ast::pat in arm.pats {\n                 if first {\n                     first = false;\n-                } else { space(s.s); word_space(s, ~\"|\"); }\n+                } else { space(s.s); word_space(s, \"|\"); }\n                 print_pat(s, p);\n             }\n             space(s.s);\n             alt arm.guard {\n-              some(e) {\n-                word_space(s, ~\"when\");\n-                print_expr(s, e);\n-                space(s.s);\n-              }\n-              none. {}\n+              some(e) { word_space(s, \"when\"); print_expr(s, e); space(s.s); }\n+              none. { }\n             }\n             print_possibly_embedded_block(s, arm.body, block_normal,\n                                           alt_indent_unit);\n@@ -940,7 +929,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             cbox(s, indent_unit);\n             // head-box, will be closed by print-block at start\n             ibox(s, 0u);\n-            word(s.s, ~\"{\");\n+            word(s.s, \"{\");\n             print_fn_block_args(s, f.decl);\n             print_possibly_embedded_block(s, f.body, block_block_fn,\n                                           indent_unit);\n@@ -958,102 +947,100 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         ibox(s, 0u);\n         print_block(s, blk);\n       }\n-      ast::expr_copy(e) { word_space(s, ~\"copy\"); print_expr(s, e); }\n+      ast::expr_copy(e) { word_space(s, \"copy\"); print_expr(s, e); }\n       ast::expr_move(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, ~\"<-\");\n+        word_space(s, \"<-\");\n         print_expr(s, rhs);\n       }\n       ast::expr_assign(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_swap(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, ~\"<->\");\n+        word_space(s, \"<->\");\n         print_expr(s, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n         word(s.s, ast_util::binop_to_str(op));\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_field(expr, id) {\n         print_expr_parens_if_unary(s, expr);\n-        word(s.s, ~\".\");\n+        word(s.s, \".\");\n         word(s.s, id);\n       }\n       ast::expr_index(expr, index) {\n         print_expr_parens_if_unary(s, expr);\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         print_expr(s, index);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n       ast::expr_path(path) { print_path(s, path, true); }\n       ast::expr_fail(maybe_fail_val) {\n-        word(s.s, ~\"fail\");\n+        word(s.s, \"fail\");\n         alt maybe_fail_val {\n-          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n-      ast::expr_break. { word(s.s, ~\"break\"); }\n-      ast::expr_cont. { word(s.s, ~\"cont\"); }\n+      ast::expr_break. { word(s.s, \"break\"); }\n+      ast::expr_cont. { word(s.s, \"cont\"); }\n       ast::expr_ret(result) {\n-        word(s.s, ~\"ret\");\n+        word(s.s, \"ret\");\n         alt result {\n-          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n       ast::expr_put(result) {\n-        word(s.s, ~\"put\");\n+        word(s.s, \"put\");\n         alt result {\n-          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n-      ast::expr_be(result) { word_nbsp(s, ~\"be\"); print_expr(s, result); }\n+      ast::expr_be(result) { word_nbsp(s, \"be\"); print_expr(s, result); }\n       ast::expr_log(lvl, expr) {\n-        alt lvl {\n-          1 { word_nbsp(s, ~\"log\"); } 0 { word_nbsp(s, ~\"log_err\"); }\n-        }\n+        alt lvl { 1 { word_nbsp(s, \"log\"); } 0 { word_nbsp(s, \"log_err\"); } }\n         print_expr(s, expr);\n       }\n       ast::expr_check(m, expr) {\n         alt m {\n-          ast::unchecked. { word_nbsp(s, ~\"claim\"); }\n-          ast::checked. { word_nbsp(s, ~\"check\"); }\n+          ast::unchecked. { word_nbsp(s, \"claim\"); }\n+          ast::checked. { word_nbsp(s, \"check\"); }\n         }\n         popen(s);\n         print_expr(s, expr);\n         pclose(s);\n       }\n       ast::expr_assert(expr) {\n-        word_nbsp(s, ~\"assert\");\n+        word_nbsp(s, \"assert\");\n         popen(s);\n         print_expr(s, expr);\n         pclose(s);\n       }\n       ast::expr_mac(m) { print_mac(s, m); }\n       ast::expr_anon_obj(anon_obj) {\n-        head(s, ~\"obj\");\n+        head(s, \"obj\");\n \n         // Fields\n         popen(s);\n         fn print_field(s: &ps, field: &ast::anon_obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, field.ident + ~\":\");\n+            word_space(s, field.ident + \":\");\n             print_type(s, field.ty);\n             space(s.s);\n-            word_space(s, ~\"=\");\n+            word_space(s, \"=\");\n             print_expr(s, field.expr);\n             end(s);\n         }\n@@ -1077,18 +1064,18 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n                      meth.node.ident, typarams, []);\n-            word(s.s, ~\" \");\n+            word(s.s, \" \");\n             print_block(s, meth.node.meth.body);\n         }\n \n         // With object\n         alt anon_obj.inner_obj {\n           none. { }\n-          some(e) { space(s.s); word_space(s, ~\"with\"); print_expr(s, e); }\n+          some(e) { space(s.s); word_space(s, \"with\"); print_expr(s, e); }\n         }\n         bclose(s, expr.span);\n       }\n-      ast::expr_uniq(expr) { word(s.s, ~\"~\"); print_expr(s, expr); }\n+      ast::expr_uniq(expr) { word(s.s, \"~\"); print_expr(s, expr); }\n     }\n     s.ann.post(ann_node);\n     end(s);\n@@ -1105,7 +1092,7 @@ fn print_local_decl(s: &ps, loc: &@ast::local) {\n     print_pat(s, loc.node.pat);\n     alt loc.node.ty.node {\n       ast::ty_infer. { }\n-      _ { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n+      _ { word_space(s, \":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n@@ -1115,7 +1102,7 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n       ast::decl_local(locs) {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n-        word_nbsp(s, ~\"let\");\n+        word_nbsp(s, \"let\");\n         fn print_local(s: &ps, loc: &@ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n@@ -1124,8 +1111,8 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n               some(init) {\n                 nbsp(s);\n                 alt init.op {\n-                  ast::init_assign. { word_space(s, ~\"=\"); }\n-                  ast::init_move. { word_space(s, ~\"<-\"); }\n+                  ast::init_assign. { word_space(s, \"=\"); }\n+                  ast::init_move. { word_space(s, \"<-\"); }\n                 }\n                 print_expr(s, init.expr);\n               }\n@@ -1139,30 +1126,28 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n     }\n }\n \n-fn print_ident(s: &ps, ident: &ast::ident) {\n-    word(s.s, ident);\n-}\n+fn print_ident(s: &ps, ident: &ast::ident) { word(s.s, ident); }\n \n fn print_for_decl(s: &ps, loc: &@ast::local, coll: &@ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n-    word_space(s, ~\"in\");\n+    word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n fn print_path(s: &ps, path: &ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.node.global { word(s.s, ~\"::\"); }\n+    if path.node.global { word(s.s, \"::\"); }\n     let first = true;\n     for id: ast::ident in path.node.idents {\n-        if first { first = false; } else { word(s.s, ~\"::\"); }\n+        if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n     if vec::len(path.node.types) > 0u {\n-        if colons_before_params { word(s.s, ~\"::\"); }\n-        word(s.s, ~\"<\");\n+        if colons_before_params { word(s.s, \"::\"); }\n+        word(s.s, \"<\");\n         commasep(s, inconsistent, path.node.types, print_type);\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n     }\n }\n \n@@ -1171,7 +1156,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n     let ann_node = node_pat(s, pat);\n     s.ann.pre(ann_node);\n     alt pat.node {\n-      ast::pat_wild. { word(s.s, ~\"_\"); }\n+      ast::pat_wild. { word(s.s, \"_\"); }\n       ast::pat_bind(id) { word(s.s, id); }\n       ast::pat_lit(lit) { print_literal(s, lit); }\n       ast::pat_tag(path, args) {\n@@ -1180,31 +1165,31 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n             popen(s);\n             commasep(s, inconsistent, args, print_pat);\n             pclose(s);\n-        } else { word(s.s, ~\".\"); }\n+        } else { word(s.s, \".\"); }\n       }\n       ast::pat_rec(fields, etc) {\n-        word(s.s, ~\"{\");\n+        word(s.s, \"{\");\n         fn print_field(s: &ps, f: &ast::field_pat) {\n             cbox(s, indent_unit);\n             word(s.s, f.ident);\n-            word_space(s, ~\":\");\n+            word_space(s, \":\");\n             print_pat(s, f.pat);\n             end(s);\n         }\n         fn get_span(f: &ast::field_pat) -> codemap::span { ret f.pat.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         if etc {\n-            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n-            word(s.s, ~\"_\");\n+            if vec::len(fields) != 0u { word_space(s, \",\"); }\n+            word(s.s, \"_\");\n         }\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::pat_tup(elts) {\n         popen(s);\n         commasep(s, inconsistent, elts, print_pat);\n         pclose(s);\n       }\n-      ast::pat_box(inner) { word(s.s, ~\"@\"); print_pat(s, inner); }\n+      ast::pat_box(inner) { word(s.s, \"@\"); print_pat(s, inner); }\n     }\n     s.ann.post(ann_node);\n }\n@@ -1213,7 +1198,7 @@ fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: &ast::ident,\n             typarams: &[ast::ty_param], constrs: [@ast::constr]) {\n     alt decl.purity {\n       ast::impure_fn. { head(s, proto_to_str(proto)); }\n-      _ { head(s, ~\"pure fn\"); }\n+      _ { head(s, \"pure fn\"); }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n@@ -1225,7 +1210,7 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     popen(s);\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n-        word_space(s, x.ident + ~\":\");\n+        word_space(s, x.ident + \":\");\n         print_alias(s, x.mode);\n         print_type(s, x.ty);\n         end(s);\n@@ -1236,50 +1221,50 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n-        word_space(s, ~\"->\");\n+        word_space(s, \"->\");\n         print_type(s, decl.output);\n     }\n }\n \n fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n-    word(s.s, ~\"|\");\n+    word(s.s, \"|\");\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n         print_alias(s, x.mode);\n         word(s.s, x.ident);\n         end(s);\n     }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n-    word(s.s, ~\"|\");\n+    word(s.s, \"|\");\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n fn print_alias(s: &ps, m: ast::mode) {\n     alt m {\n-      ast::alias(true) { word_space(s, ~\"&mutable\"); }\n-      ast::alias(false) { word(s.s, ~\"&\"); }\n-      ast::move. { word(s.s, ~\"-\"); }\n+      ast::alias(true) { word_space(s, \"&mutable\"); }\n+      ast::alias(false) { word(s.s, \"&\"); }\n+      ast::move. { word(s.s, \"-\"); }\n       ast::val. { }\n     }\n }\n \n fn print_kind(s: &ps, kind: ast::kind) {\n     alt kind {\n-      ast::kind_unique. { word(s.s, ~\"~\"); }\n-      ast::kind_shared. { word(s.s, ~\"@\"); }\n+      ast::kind_unique. { word(s.s, \"~\"); }\n+      ast::kind_shared. { word(s.s, \"@\"); }\n       _ {/* fallthrough */ }\n     }\n }\n \n fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n     if vec::len(params) > 0u {\n-        word(s.s, ~\"<\");\n+        word(s.s, \"<\");\n         fn printParam(s: &ps, param: &ast::ty_param) {\n             print_kind(s, param.kind);\n             word(s.s, param.ident);\n         }\n         commasep(s, inconsistent, params, printParam);\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n     }\n }\n \n@@ -1289,7 +1274,7 @@ fn print_meta_item(s: &ps, item: &@ast::meta_item) {\n       ast::meta_word(name) { word(s.s, name); }\n       ast::meta_name_value(name, value) {\n         word_space(s, name);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, items) {\n@@ -1307,7 +1292,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     alt item.node {\n       ast::view_item_use(id, mta, _) {\n-        head(s, ~\"use\");\n+        head(s, \"use\");\n         word(s.s, id);\n         if vec::len(mta) > 0u {\n             popen(s);\n@@ -1316,47 +1301,43 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n         }\n       }\n       ast::view_item_import(id, ids, _) {\n-        head(s, ~\"import\");\n+        head(s, \"import\");\n         if !str::eq(id, ids[vec::len(ids) - 1u]) {\n             word_space(s, id);\n-            word_space(s, ~\"=\");\n+            word_space(s, \"=\");\n         }\n         let first = true;\n         for elt: ast::ident in ids {\n-            if first { first = false; } else { word(s.s, ~\"::\"); }\n+            if first { first = false; } else { word(s.s, \"::\"); }\n             word(s.s, elt);\n         }\n       }\n       ast::view_item_import_from(mod_path, idents, _) {\n-        head(s, ~\"import\");\n-        for elt: ast::ident in mod_path {\n-            word(s.s, elt); word(s.s, ~\"::\");\n-        }\n-        word(s.s, ~\"{\");\n+        head(s, \"import\");\n+        for elt: ast::ident in mod_path { word(s.s, elt); word(s.s, \"::\"); }\n+        word(s.s, \"{\");\n         commasep(s, inconsistent, idents,\n                  fn (s: &ps, w: &ast::import_ident) {\n                      word(s.s, w.node.name)\n                  });\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::view_item_import_glob(ids, _) {\n-        head(s, ~\"import\");\n+        head(s, \"import\");\n         let first = true;\n         for elt: ast::ident in ids {\n-            if first { first = false; } else { word(s.s, ~\"::\"); }\n+            if first { first = false; } else { word(s.s, \"::\"); }\n             word(s.s, elt);\n         }\n-        word(s.s, ~\"::*\");\n+        word(s.s, \"::*\");\n       }\n       ast::view_item_export(ids, _) {\n-        head(s, ~\"export\");\n+        head(s, \"export\");\n         commasep(s, inconsistent, ids,\n-                 fn (s: &ps, w: &ast::ident) {\n-                     word(s.s, w)\n-                 });\n+                 fn (s: &ps, w: &ast::ident) { word(s.s, w) });\n       }\n     }\n-    word(s.s, ~\";\");\n+    word(s.s, \";\");\n     end(s); // end inner head-block\n \n     end(s); // end outer head-block\n@@ -1380,6 +1361,7 @@ fn need_parens(expr: &@ast::expr, outer_prec: int) -> bool {\n       ast::expr_ternary(_, _, _) { parse::parser::ternary_prec < outer_prec }\n \n \n+\n       // This may be too conservative in some cases\n       ast::expr_assign(_, _) {\n         true\n@@ -1406,8 +1388,8 @@ fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n \n fn print_mutability(s: &ps, mut: &ast::mutability) {\n     alt mut {\n-      ast::mut. { word_nbsp(s, ~\"mutable\"); }\n-      ast::maybe_mut. { word_nbsp(s, ~\"mutable?\"); }\n+      ast::mut. { word_nbsp(s, \"mutable\"); }\n+      ast::maybe_mut. { word_nbsp(s, \"mutable?\"); }\n       ast::imm. {/* nothing */ }\n     }\n }\n@@ -1422,13 +1404,7 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n                cf: &ast::controlflow, constrs: &[@ast::constr]) {\n     ibox(s, indent_unit);\n     word(s.s, proto_to_str(proto));\n-    alt id {\n-      some(id) {\n-        word(s.s, ~\" \");\n-        word(s.s, id);\n-      }\n-      _ { }\n-    }\n+    alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n     fn print_arg(s: &ps, input: &ast::ty_arg) {\n@@ -1441,10 +1417,10 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n     if output.node != ast::ty_nil {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n-        word_space(s, ~\"->\");\n+        word_space(s, \"->\");\n         alt cf {\n           ast::return. { print_type(s, output); }\n-          ast::noreturn. { word_nbsp(s, ~\"!\"); }\n+          ast::noreturn. { word_nbsp(s, \"!\"); }\n         }\n         end(s);\n     }\n@@ -1495,25 +1471,19 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt next_lit(s) {\n       some(lt) {\n-        if lt.pos == lit.span.lo {\n-            word(s.s, lt.lit);\n-            s.cur_lit += 1u;\n-            ret;\n-        }\n+        if lt.pos == lit.span.lo { word(s.s, lt.lit); s.cur_lit += 1u; ret; }\n       }\n       _ { }\n     }\n     alt lit.node {\n-      ast::lit_str(st) {\n-        print_string(s, st);\n-      }\n+      ast::lit_str(st) { print_string(s, st); }\n       ast::lit_char(ch) {\n         word(s.s,\n-             ~\"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n-                 ~\"'\");\n+             \"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n+                 \"'\");\n       }\n       ast::lit_int(val) { word(s.s, int::str(val)); }\n-      ast::lit_uint(val) { word(s.s, uint::str(val) + ~\"u\"); }\n+      ast::lit_uint(val) { word(s.s, uint::str(val) + \"u\"); }\n       ast::lit_float(fstr) { word(s.s, fstr); }\n       ast::lit_mach_int(mach, val) {\n         word(s.s, int::str(val as int));\n@@ -1524,14 +1494,14 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n         word(s.s, val);\n         word(s.s, ast_util::ty_mach_to_str(mach));\n       }\n-      ast::lit_nil. { word(s.s, ~\"()\"); }\n+      ast::lit_nil. { word(s.s, \"()\"); }\n       ast::lit_bool(val) {\n-        if val { word(s.s, ~\"true\"); } else { word(s.s, ~\"false\"); }\n+        if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n       }\n     }\n }\n \n-fn lit_to_str(l: &@ast::lit) -> istr { be to_str(l, print_literal); }\n+fn lit_to_str(l: &@ast::lit) -> str { be to_str(l, print_literal); }\n \n fn next_lit(s: &ps) -> option::t<lexer::lit> {\n     alt s.literals {\n@@ -1568,26 +1538,22 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       }\n       lexer::isolated. {\n         pprust::hardbreak_if_not_bol(s);\n-        for line: istr in cmnt.lines {\n+        for line: str in cmnt.lines {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if str::is_not_empty(line) {\n-                word(s.s, line);\n-            }\n+            if str::is_not_empty(line) { word(s.s, line); }\n             hardbreak(s.s);\n         }\n       }\n       lexer::trailing. {\n-        word(s.s, ~\" \");\n+        word(s.s, \" \");\n         if vec::len(cmnt.lines) == 1u {\n             word(s.s, cmnt.lines[0]);\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for line: istr in cmnt.lines {\n-                if str::is_not_empty(line) {\n-                    word(s.s, line);\n-                }\n+            for line: str in cmnt.lines {\n+                if str::is_not_empty(line) { word(s.s, line); }\n                 hardbreak(s.s);\n             }\n             end(s);\n@@ -1597,7 +1563,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n-              pp::STRING(s, _) { s == ~\";\" }\n+              pp::STRING(s, _) { s == \";\" }\n               _ { false }\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s) }\n@@ -1606,24 +1572,24 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n     }\n }\n \n-fn print_string(s: &ps, st: &istr) {\n-    word(s.s, ~\"\\\"\");\n+fn print_string(s: &ps, st: &str) {\n+    word(s.s, \"\\\"\");\n     word(s.s, escape_str(st, '\"'));\n-    word(s.s, ~\"\\\"\");\n+    word(s.s, \"\\\"\");\n }\n \n-fn escape_str(st: &istr, to_escape: char) -> istr {\n-    let out: istr = ~\"\";\n+fn escape_str(st: &str, to_escape: char) -> str {\n+    let out: str = \"\";\n     let len = str::byte_len(st);\n     let i = 0u;\n     while i < len {\n         alt st[i] as char {\n-          '\\n' { out += ~\"\\\\n\"; }\n-          '\\t' { out += ~\"\\\\t\"; }\n-          '\\r' { out += ~\"\\\\r\"; }\n-          '\\\\' { out += ~\"\\\\\\\\\"; }\n+          '\\n' { out += \"\\\\n\"; }\n+          '\\t' { out += \"\\\\t\"; }\n+          '\\r' { out += \"\\\\r\"; }\n+          '\\\\' { out += \"\\\\\\\\\"; }\n           cur {\n-            if cur == to_escape { out += ~\"\\\\\"; }\n+            if cur == to_escape { out += \"\\\\\"; }\n             // FIXME some (or all?) non-ascii things should be escaped\n \n             str::push_char(out, cur);\n@@ -1634,7 +1600,7 @@ fn escape_str(st: &istr, to_escape: char) -> istr {\n     ret out;\n }\n \n-fn to_str<T>(t: &T, f: fn(&ps, &T)) -> istr {\n+fn to_str<T>(t: &T, f: fn(&ps, &T)) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n@@ -1655,23 +1621,22 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n \n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n-fn constr_args_to_str<T>(f: &fn(&T) -> istr, args: &[@ast::sp_constr_arg<T>])\n-   -> istr {\n+fn constr_args_to_str<T>(f: &fn(&T) -> str, args: &[@ast::sp_constr_arg<T>])\n+   -> str {\n     let comma = false;\n-    let s = ~\"(\";\n+    let s = \"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n-        if comma { s += ~\", \"; } else { comma = true; }\n+        if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str::<T>(f, a.node);\n     }\n-    s += ~\")\";\n+    s += \")\";\n     ret s;\n }\n \n-fn constr_arg_to_str<T>(f: &fn(&T) -> istr,\n-                        c: &ast::constr_arg_general_<T>) ->\n-   istr {\n+fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n+   str {\n     alt c {\n-      ast::carg_base. { ret ~\"*\"; }\n+      ast::carg_base. { ret \"*\"; }\n       ast::carg_ident(i) { ret f(i); }\n       ast::carg_lit(l) { ret lit_to_str(l); }\n     }\n@@ -1680,68 +1645,68 @@ fn constr_arg_to_str<T>(f: &fn(&T) -> istr,\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(i: &uint) -> istr { ret uint::str(i); }\n+fn uint_to_str(i: &uint) -> str { ret uint::str(i); }\n \n-fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> istr {\n+fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(uint_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> istr {\n-    let s = ~\"\";\n+fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n+    let s = \"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n+        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ast_ty_fn_constr_to_str(c);\n     }\n     ret s;\n }\n \n-fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> istr {\n+fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> str {\n     decl.inputs[idx].ident\n }\n \n-fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> istr {\n+fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n     let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(arg_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> istr {\n-    let s = ~\"\";\n+fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> str {\n+    let s = \"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n+        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ast_fn_constr_to_str(decl, c);\n     }\n     ret s;\n }\n \n-fn proto_to_str(p: &ast::proto) -> istr {\n+fn proto_to_str(p: &ast::proto) -> str {\n     ret alt p {\n-          ast::proto_fn. { ~\"fn\" }\n-          ast::proto_iter. { ~\"iter\" }\n-          ast::proto_block. { ~\"block\" }\n-          ast::proto_closure. { ~\"lambda\" }\n+          ast::proto_fn. { \"fn\" }\n+          ast::proto_iter. { \"iter\" }\n+          ast::proto_block. { \"block\" }\n+          ast::proto_closure. { \"lambda\" }\n         };\n }\n \n-fn ty_constr_to_str(c: &@ast::ty_constr) -> istr {\n-    fn ty_constr_path_to_str(p: &ast::path) -> istr { ~\"*.\" + path_to_str(p) }\n+fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n+    fn ty_constr_path_to_str(p: &ast::path) -> str { \"*.\" + path_to_str(p) }\n \n     ret path_to_str(c.node.path) +\n             constr_args_to_str::<ast::path>(ty_constr_path_to_str,\n                                             c.node.args);\n }\n \n \n-fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> istr {\n-    let s = ~\"\";\n+fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> str {\n+    let s = \"\";\n     let colon = true;\n     for c: @ast::ty_constr in constrs {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n+        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ty_constr_to_str(c);\n     }\n     ret s;"}, {"sha": "e075b1d821c288ef7d09878f0fa7a503eb03a444", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -120,7 +120,7 @@ fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n       ty_uint. {/* no-op */ }\n       ty_machine(_) {/* no-op */ }\n       ty_char. {/* no-op */ }\n-      ty_istr. {/* no-op */ }\n+      ty_str. {/* no-op */ }\n       ty_box(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_vec(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_ptr(mt) { v.visit_ty(mt.ty, e, v); }"}, {"sha": "ba86b99261f56989f96cd91aab45649c65076e47", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -104,10 +104,7 @@ fn local_rhs_span(l: &@ast::local, def: &span) -> span {\n fn lit_eq(l: &@ast::lit, m: &@ast::lit) -> bool {\n     alt l.node {\n       ast::lit_str(s) {\n-        alt m.node {\n-          ast::lit_str(t) { ret s == t }\n-          _ { ret false; }\n-        }\n+        alt m.node { ast::lit_str(t) { ret s == t } _ { ret false; } }\n       }\n       ast::lit_char(c) {\n         alt m.node { ast::lit_char(d) { ret c == d; } _ { ret false; } }\n@@ -144,28 +141,28 @@ fn lit_eq(l: &@ast::lit, m: &@ast::lit) -> bool {\n \n tag call_kind { kind_call; kind_spawn; kind_bind; kind_for_each; }\n \n-fn call_kind_str(c: call_kind) -> istr {\n+fn call_kind_str(c: call_kind) -> str {\n     alt c {\n-      kind_call. { ~\"Call\" }\n-      kind_spawn. { ~\"Spawn\" }\n-      kind_bind. { ~\"Bind\" }\n-      kind_for_each. { ~\"For-Each\" }\n+      kind_call. { \"Call\" }\n+      kind_spawn. { \"Spawn\" }\n+      kind_bind. { \"Bind\" }\n+      kind_for_each. { \"For-Each\" }\n     }\n }\n \n fn is_main_name(path: &[ast::ident]) -> bool {\n-    str::eq(option::get(std::vec::last(path)), ~\"main\")\n+    str::eq(option::get(std::vec::last(path)), \"main\")\n }\n \n // FIXME mode this to std::float when editing the stdlib no longer\n // requires a snapshot\n-fn float_to_str(num: float, digits: uint) -> istr {\n-    let accum = if num < 0.0 { num = -num; ~\"-\" } else { ~\"\" };\n+fn float_to_str(num: float, digits: uint) -> str {\n+    let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n     let trunc = num as uint;\n     let frac = num - (trunc as float);\n     accum += uint::str(trunc);\n     if frac == 0.0 || digits == 0u { ret accum; }\n-    accum += ~\".\";\n+    accum += \".\";\n     while digits > 0u && frac > 0.0 {\n         frac *= 10.0;\n         let digit = frac as uint;"}, {"sha": "7b2ce09451833a500fd43febb191e1c36e0f72a5", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 62, "deletions": 74, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -21,32 +21,31 @@ import syntax::ast;\n import middle::ast_map;\n import metadata::csearch;\n \n-fn mode_str(m: &ty::mode) -> istr {\n+fn mode_str(m: &ty::mode) -> str {\n     alt m {\n-      mo_val. { ~\"\" }\n-      mo_alias(false) { ~\"&\" }\n-      mo_alias(true) { ~\"&mutable \" }\n-      mo_move. { ~\"-\" }\n+      mo_val. { \"\" }\n+      mo_alias(false) { \"&\" }\n+      mo_alias(true) { \"&mutable \" }\n+      mo_move. { \"-\" }\n     }\n }\n \n-fn mode_str_1(m: &ty::mode) -> istr {\n-    alt m { mo_val. { ~\"val\" } _ { mode_str(m) } }\n+fn mode_str_1(m: &ty::mode) -> str {\n+    alt m { mo_val. { \"val\" } _ { mode_str(m) } }\n }\n \n-fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> istr {\n-    ret alt i {\n-      none. { ~\"anon\" + int::str(id) }\n-      some(s) { s }\n-    };\n+fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {\n+    ret alt i { none. { \"anon\" + int::str(id) } some(s) { s } };\n }\n \n-fn get_id_ident(cx: &ctxt, id: ast::def_id) -> istr {\n+fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate {\n         alt cx.ext_map.find(id) {\n-          some(j) { str::connect(j, ~\"::\") }\n-          _ { fail (~\"get_id_ident: can't find item in ext_map, id.crate = \"\n-                    + int::str(id.crate)) }\n+          some(j) { str::connect(j, \"::\") }\n+          _ {\n+            fail \"get_id_ident: can't find item in ext_map, id.crate = \" +\n+                     int::str(id.crate)\n+          }\n         }\n     } else {\n         alt cx.items.find(id.node) {\n@@ -56,90 +55,79 @@ fn get_id_ident(cx: &ctxt, id: ast::def_id) -> istr {\n     }\n }\n \n-fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n+fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n     fn fn_input_to_str(cx: &ctxt, input: &{mode: middle::ty::mode, ty: t}) ->\n-       istr {\n+       str {\n         let s = mode_str(input.mode);\n         ret s + ty_to_str(cx, input.ty);\n     }\n     fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n                  inputs: &[arg], output: t, cf: ast::controlflow,\n-                 constrs: &[@constr]) -> istr {\n+                 constrs: &[@constr]) -> str {\n         let s = proto_to_str(proto);\n-        alt ident {\n-          some(i) {\n-            s += ~\" \";\n-            s += i;\n-          }\n-          _ { }\n-        }\n-        s += ~\"(\";\n+        alt ident { some(i) { s += \" \"; s += i; } _ { } }\n+        s += \"(\";\n         let strs = [];\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n-        s += str::connect(strs, ~\", \");\n-        s += ~\")\";\n+        s += str::connect(strs, \", \");\n+        s += \")\";\n         if struct(cx, output) != ty_nil {\n             alt cf {\n-              ast::noreturn. { s += ~\" -> !\"; }\n-              ast::return. { s += ~\" -> \" + ty_to_str(cx, output); }\n+              ast::noreturn. { s += \" -> !\"; }\n+              ast::return. { s += \" -> \" + ty_to_str(cx, output); }\n             }\n         }\n         s += constrs_str(constrs);\n         ret s;\n     }\n-    fn method_to_str(cx: &ctxt, m: &method) -> istr {\n+    fn method_to_str(cx: &ctxt, m: &method) -> str {\n         ret fn_to_str(cx, m.proto, some::<ast::ident>(m.ident), m.inputs,\n-                      m.output, m.cf, m.constrs) + ~\";\";\n+                      m.output, m.cf, m.constrs) + \";\";\n     }\n-    fn field_to_str(cx: &ctxt, f: &field) -> istr {\n-        ret f.ident + ~\": \" + mt_to_str(cx, f.mt);\n+    fn field_to_str(cx: &ctxt, f: &field) -> str {\n+        ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n-    fn mt_to_str(cx: &ctxt, m: &mt) -> istr {\n+    fn mt_to_str(cx: &ctxt, m: &mt) -> str {\n         let mstr;\n         alt m.mut {\n-          ast::mut. { mstr = ~\"mutable \"; }\n-          ast::imm. { mstr = ~\"\"; }\n-          ast::maybe_mut. { mstr = ~\"mutable? \"; }\n+          ast::mut. { mstr = \"mutable \"; }\n+          ast::imm. { mstr = \"\"; }\n+          ast::maybe_mut. { mstr = \"mutable? \"; }\n         }\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n-    alt cname(cx, typ) {\n-      some(cs) {\n-        ret cs;\n-      }\n-      _ { }\n-    }\n+    alt cname(cx, typ) { some(cs) { ret cs; } _ { } }\n     ret alt struct(cx, typ) {\n-          ty_native(_) { ~\"native\" }\n-          ty_nil. { ~\"()\" }\n-          ty_bot. { ~\"_|_\" }\n-          ty_bool. { ~\"bool\" }\n-          ty_int. { ~\"int\" }\n-          ty_float. { ~\"float\" }\n-          ty_uint. { ~\"uint\" }\n+          ty_native(_) { \"native\" }\n+          ty_nil. { \"()\" }\n+          ty_bot. { \"_|_\" }\n+          ty_bool. { \"bool\" }\n+          ty_int. { \"int\" }\n+          ty_float. { \"float\" }\n+          ty_uint. { \"uint\" }\n           ty_machine(tm) { ty_mach_to_str(tm) }\n-          ty_char. { ~\"char\" }\n-          ty_istr. { ~\"istr\" }\n-          ty_box(tm) { ~\"@\" + mt_to_str(cx, tm) }\n-          ty_uniq(t) { ~\"~\" + ty_to_str(cx, t) }\n-          ty_vec(tm) { ~\"[\" + mt_to_str(cx, tm) + ~\"]\" }\n-          ty_type. { ~\"type\" }\n+          ty_char. { \"char\" }\n+          ty_str. { \"str\" }\n+          ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n+          ty_uniq(t) { \"~\" + ty_to_str(cx, t) }\n+          ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n+          ty_type. { \"type\" }\n           ty_rec(elems) {\n-            let strs: [istr] = [];\n+            let strs: [str] = [];\n             for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n-            ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n+            \"{\" + str::connect(strs, \",\") + \"}\"\n           }\n           ty_tup(elems) {\n             let strs = [];\n             for elem in elems { strs += [ty_to_str(cx, elem)]; }\n-            ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n+            \"(\" + str::connect(strs, \",\") + \")\"\n           }\n           ty_tag(id, tps) {\n             let s = get_id_ident(cx, id);\n             if vec::len::<t>(tps) > 0u {\n-                let strs: [istr] = [];\n+                let strs: [str] = [];\n                 for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n-                s += ~\"[\" + str::connect(strs, ~\",\") + ~\"]\";\n+                s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n             s\n           }\n@@ -153,42 +141,42 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n           ty_obj(meths) {\n             let strs = [];\n             for m: method in meths { strs += [method_to_str(cx, m)]; }\n-            ~\"obj {\\n\\t\" + str::connect(strs, ~\"\\n\\t\") + ~\"\\n}\"\n+            \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n           }\n           ty_res(id, _, _) { get_id_ident(cx, id) }\n-          ty_var(v) { ~\"<T\" + int::str(v) + ~\">\" }\n+          ty_var(v) { \"<T\" + int::str(v) + \">\" }\n           ty_param(id, _) {\n-            ~\"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+            \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n           }\n           _ { ty_to_short_str(cx, typ) }\n         }\n }\n \n-fn ty_to_short_str(cx: &ctxt, typ: t) -> istr {\n+fn ty_to_short_str(cx: &ctxt, typ: t) -> str {\n     let s = encoder::encoded_ty(cx, typ);\n     if str::byte_len(s) >= 32u { s = str::substr(s, 0u, 32u); }\n     ret s;\n }\n \n-fn constr_to_str(c: &@constr) -> istr {\n+fn constr_to_str(c: &@constr) -> str {\n     ret path_to_str(c.node.path) +\n-        pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n+            pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(constrs: &[@constr]) -> istr {\n-    let s = ~\"\";\n+fn constrs_str(constrs: &[@constr]) -> str {\n+    let s = \"\";\n     let colon = true;\n     for c: @constr in constrs {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n+        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }\n     ret s;\n }\n \n fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n-   -> istr {\n+   -> str {\n     ret path_to_str(c.node.path) +\n-        constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n+            constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n }\n \n // Local Variables:"}, {"sha": "163004c4605946701bddb1e14c749eb1d3cb9da1", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -20,7 +20,6 @@ def scrub(b):\n run_pass = os.path.abspath(run_pass)\n stage2_tests = []\n take_args = {}\n-take_iargs = {}\n \n for t in os.listdir(run_pass):\n     if t.endswith(\".rs\") and not (\n@@ -32,9 +31,6 @@ def scrub(b):\n             stage2_tests.append(t)\n             if \"main(args: [str])\" in s:\n                 take_args[t] = True\n-            # FIXME: Transitional. Remove me\n-            if \"main(args: [istr])\" in s:\n-                take_iargs[t] = True\n         f.close()\n \n stage2_tests.sort()\n@@ -62,11 +58,9 @@ def scrub(b):\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(~\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n     if t in take_args:\n         d.write(\"    t_%d::main([\\\"arg0\\\"]);\\n\" % i)\n-    elif t in take_iargs:\n-        d.write(\"    t_%d::main([~\\\"arg0\\\"]);\\n\" % i)\n     else:\n         d.write(\"    t_%d::main();\\n\" % i)\n     i += 1"}, {"sha": "3012873178245420d9bd0dd696dca55b5d736b3b", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -20,28 +20,28 @@ import rustc::syntax::codemap;\n import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n-fn write_file(filename: &istr, content: &istr) {\n+fn write_file(filename: &str, content: &str) {\n     io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n     // Work around https://github.com/graydon/rust/issues/726\n-    std::run::run_program(~\"chmod\", [~\"644\", filename]);\n+    std::run::run_program(\"chmod\", [\"644\", filename]);\n }\n \n-fn file_contains(filename: &istr, needle: &istr) -> bool {\n+fn file_contains(filename: &str, needle: &str) -> bool {\n     let contents = io::read_whole_file_str(filename);\n     ret str::find(contents, needle) != -1;\n }\n \n-fn contains(haystack: &istr, needle: &istr) -> bool {\n+fn contains(haystack: &str, needle: &str) -> bool {\n     str::find(haystack, needle) != -1\n }\n \n-fn find_rust_files(files: &mutable [istr], path: &istr) {\n-    if str::ends_with(path, ~\".rs\") {\n-        if file_contains(path, ~\"xfail-test\") {\n+fn find_rust_files(files: &mutable [str], path: &str) {\n+    if str::ends_with(path, \".rs\") {\n+        if file_contains(path, \"xfail-test\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";\n         } else { files += [path]; }\n     } else if fs::file_is_dir(path)\n-        && str::find(path, ~\"compile-fail\") == -1 {\n+        && str::find(path, \"compile-fail\") == -1 {\n         for p in fs::list_dir(path) {\n             find_rust_files(files, p);\n         }\n@@ -150,28 +150,28 @@ iter under(n: uint) -> uint {\n \n fn devnull() -> io::writer { std::io::string_writer().get_writer() }\n \n-fn as_str(f: fn(io::writer)) -> istr {\n+fn as_str(f: fn(io::writer)) -> str {\n     let w = std::io::string_writer();\n     f(w.get_writer());\n     ret w.get_str();\n }\n \n fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n-                         filename: &istr) {\n+                         filename: &str) {\n     let exprs = steal_exprs(crate);\n     let exprsL = vec::len(exprs);\n     if exprsL < 100u {\n         for each i: uint in under(uint::min(exprsL, 20u)) {\n-            log_err ~\"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n+            log_err \"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n             for each j: uint in under(uint::min(exprsL, 5u)) {\n-                log_err ~\"With... \" + pprust::expr_to_str(@exprs[j]);\n+                log_err \"With... \" + pprust::expr_to_str(@exprs[j]);\n                 let crate2 = @replace_expr_in_crate(crate, i, exprs[j].node);\n                 // It would be best to test the *crate* for stability, but testing the\n                 // string for stability is easier and ok for now.\n                 let str3 =\n                     as_str(bind pprust::print_crate(codemap, crate2,\n                                                     filename,\n-                                                    io::string_reader(~\"\"), _,\n+                                                    io::string_reader(\"\"), _,\n                                                     pprust::no_ann()));\n                 // 1u would be sane here, but the pretty-printer currently has lots of whitespace and paren issues,\n                 // and https://github.com/graydon/rust/issues/766 is hilarious.\n@@ -186,70 +186,70 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n // - that would find many \"false positives\" or unimportant bugs\n // - that would be tricky, requiring use of tasks or serialization or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: &istr) {\n-    let filename = ~\"test.rs\";\n+fn check_whole_compiler(code: &str) {\n+    let filename = \"test.rs\";\n     write_file(filename, code);\n     let p =\n         std::run::program_output(\n-            ~\"/Users/jruderman/code/rust/build/stage1/rustc\",\n-            [~\"-c\", filename]);\n+            \"/Users/jruderman/code/rust/build/stage1/rustc\",\n+            [\"-c\", filename]);\n \n     //log_err #fmt(\"Status: %d\", p.status);\n     //log_err \"Output: \" + p.out;\n-    if p.err != ~\"\" {\n-        if contains(p.err, ~\"argument of incompatible type\") {\n+    if p.err != \"\" {\n+        if contains(p.err, \"argument of incompatible type\") {\n             log_err \"https://github.com/graydon/rust/issues/769\";\n         } else if contains(p.err,\n-                           ~\"Cannot create binary operator with two operands of differing type\")\n+                           \"Cannot create binary operator with two operands of differing type\")\n          {\n             log_err \"https://github.com/graydon/rust/issues/770\";\n-        } else if contains(p.err, ~\"May only branch on boolean predicates!\") {\n+        } else if contains(p.err, \"May only branch on boolean predicates!\") {\n             log_err \"https://github.com/graydon/rust/issues/770 or https://github.com/graydon/rust/issues/776\";\n-        } else if contains(p.err, ~\"Invalid constantexpr cast!\") &&\n-                      contains(code, ~\"!\") {\n+        } else if contains(p.err, \"Invalid constantexpr cast!\") &&\n+                      contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777\";\n         } else if contains(p.err,\n-                           ~\"Both operands to ICmp instruction are not of the same type!\")\n-                      && contains(code, ~\"!\") {\n+                           \"Both operands to ICmp instruction are not of the same type!\")\n+                      && contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777 #issuecomment-1678487\";\n-        } else if contains(p.err, ~\"Ptr must be a pointer to Val type!\") &&\n-                      contains(code, ~\"!\") {\n+        } else if contains(p.err, \"Ptr must be a pointer to Val type!\") &&\n+                      contains(code, \"!\") {\n             log_err \"https://github.com/graydon/rust/issues/779\";\n-        } else if contains(p.err, ~\"Calling a function with bad signature!\") &&\n-                      (contains(code, ~\"iter\") || contains(code, ~\"range\")) {\n+        } else if contains(p.err, \"Calling a function with bad signature!\") &&\n+                      (contains(code, \"iter\") || contains(code, \"range\")) {\n             log_err \"https://github.com/graydon/rust/issues/771 - calling an iter fails\";\n-        } else if contains(p.err, ~\"Calling a function with a bad signature!\")\n-                      && contains(code, ~\"empty\") {\n+        } else if contains(p.err, \"Calling a function with a bad signature!\")\n+                      && contains(code, \"empty\") {\n             log_err \"https://github.com/graydon/rust/issues/775 - possibly a modification of run-pass/import-glob-crate.rs\";\n-        } else if contains(p.err, ~\"Invalid type for pointer element!\") &&\n-                      contains(code, ~\"put\") {\n+        } else if contains(p.err, \"Invalid type for pointer element!\") &&\n+                      contains(code, \"put\") {\n             log_err \"https://github.com/graydon/rust/issues/773 - put put ()\";\n-        } else if contains(p.err, ~\"pointer being freed was not allocated\") &&\n-                      contains(p.out, ~\"Out of stack space, sorry\") {\n+        } else if contains(p.err, \"pointer being freed was not allocated\") &&\n+                      contains(p.out, \"Out of stack space, sorry\") {\n             log_err \"https://github.com/graydon/rust/issues/768 + https://github.com/graydon/rust/issues/778\"\n         } else {\n-            log_err ~\"Stderr: \" + p.err;\n+            log_err \"Stderr: \" + p.err;\n             fail \"Unfamiliar error message\";\n         }\n-    } else if contains(p.out, ~\"non-exhaustive match failure\") &&\n-                  contains(p.out, ~\"alias.rs\") {\n+    } else if contains(p.out, \"non-exhaustive match failure\") &&\n+                  contains(p.out, \"alias.rs\") {\n         log_err \"https://github.com/graydon/rust/issues/772\";\n-    } else if contains(p.out, ~\"non-exhaustive match failure\") &&\n-                  contains(p.out, ~\"trans.rs\") && contains(code, ~\"put\") {\n+    } else if contains(p.out, \"non-exhaustive match failure\") &&\n+                  contains(p.out, \"trans.rs\") && contains(code, \"put\") {\n         log_err \"https://github.com/graydon/rust/issues/774\";\n-    } else if contains(p.out, ~\"Out of stack space, sorry\") {\n+    } else if contains(p.out, \"Out of stack space, sorry\") {\n         log_err \"Possibly a variant of https://github.com/graydon/rust/issues/768\";\n     } else if p.status == 256 {\n-        if !contains(p.out, ~\"error:\") {\n+        if !contains(p.out, \"error:\") {\n             fail \"Exited with status 256 without a span-error\";\n         }\n     } else if p.status == 11 {\n         log_err \"What is this I don't even\";\n     } else if p.status != 0 { fail \"Unfamiliar status code\"; }\n }\n \n-fn parse_and_print(code: &istr) -> istr {\n-    let filename = ~\"tmp.rs\";\n+fn parse_and_print(code: &str) -> str {\n+    let filename = \"tmp.rs\";\n     let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n     //write_file(filename, code);\n     let crate = parser::parse_crate_from_source_str(\n@@ -260,19 +260,19 @@ fn parse_and_print(code: &istr) -> istr {\n                                         pprust::no_ann()));\n }\n \n-fn content_is_dangerous_to_modify(code: &istr) -> bool {\n+fn content_is_dangerous_to_modify(code: &str) -> bool {\n     let dangerous_patterns =\n-        [~\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n-         ~\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n-         ~\"#\", // strange representation of the arguments to #fmt, for example\n-         ~\" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n-         ~\"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n+        [\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n+         \"#macro\", // not safe to steal things inside of it, because they have a special syntax\n+         \"#\", // strange representation of the arguments to #fmt, for example\n+         \" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n+         \"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n \n-    for p: istr in dangerous_patterns { if contains(code, p) { ret true; } }\n+    for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_confusing(code: &istr) ->\n+fn content_is_confusing(code: &str) ->\n    bool { // https://github.com/graydon/rust/issues/671\n           // https://github.com/graydon/rust/issues/669\n           // https://github.com/graydon/rust/issues/669\n@@ -282,16 +282,16 @@ fn content_is_confusing(code: &istr) ->\n           // more precedence issues?\n \n     let confusing_patterns =\n-        [~\"#macro\", ~\"][]\", ~\"][mutable]\", ~\"][mutable ]\", ~\"self\", ~\"spawn\",\n-         ~\"bind\", ~\"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n-         ~\" : \", // https://github.com/graydon/rust/issues/760\n-         ~\"if ret\", ~\"alt ret\", ~\"if fail\", ~\"alt fail\"];\n+        [\"#macro\", \"][]\", \"][mutable]\", \"][mutable ]\", \"self\", \"spawn\",\n+         \"bind\", \"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n+         \" : \", // https://github.com/graydon/rust/issues/760\n+         \"if ret\", \"alt ret\", \"if fail\", \"alt fail\"];\n \n-    for p: istr in confusing_patterns { if contains(code, p) { ret true; } }\n+    for p: str in confusing_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn file_is_confusing(filename: &istr) -> bool {\n+fn file_is_confusing(filename: &str) -> bool {\n \n     // https://github.com/graydon/rust/issues/674\n \n@@ -302,16 +302,16 @@ fn file_is_confusing(filename: &istr) -> bool {\n     // which i can't reproduce using \"rustc\n     // --pretty normal\"???\n     let confusing_files =\n-        [~\"block-expr-precedence.rs\", ~\"nil-pattern.rs\",\n-         ~\"syntax-extension-fmt.rs\",\n-         ~\"newtype.rs\"]; // modifying it hits something like https://github.com/graydon/rust/issues/670\n+        [\"block-expr-precedence.rs\", \"nil-pattern.rs\",\n+         \"syntax-extension-fmt.rs\",\n+         \"newtype.rs\"]; // modifying it hits something like https://github.com/graydon/rust/issues/670\n \n     for f in confusing_files { if contains(filename, f) { ret true; } }\n \n     ret false;\n }\n \n-fn check_roundtrip_convergence(code: &istr, maxIters: uint) {\n+fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n \n     let i = 0u;\n     let new = code;\n@@ -329,16 +329,16 @@ fn check_roundtrip_convergence(code: &istr, maxIters: uint) {\n         log_err #fmt[\"Converged after %u iterations\", i];\n     } else {\n         log_err #fmt[\"Did not converge after %u iterations!\", i];\n-        write_file(~\"round-trip-a.rs\", old);\n-        write_file(~\"round-trip-b.rs\", new);\n-        std::run::run_program(~\"diff\",\n-                              [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n-                               ~\"round-trip-b.rs\"]);\n+        write_file(\"round-trip-a.rs\", old);\n+        write_file(\"round-trip-b.rs\", new);\n+        std::run::run_program(\"diff\",\n+                              [\"-w\", \"-u\", \"round-trip-a.rs\",\n+                               \"round-trip-b.rs\"]);\n         fail \"Mismatch\";\n     }\n }\n \n-fn check_convergence(files: &[istr]) {\n+fn check_convergence(files: &[str]) {\n     log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n@@ -352,14 +352,14 @@ fn check_convergence(files: &[istr]) {\n     }\n }\n \n-fn check_variants(files: &[istr]) {\n+fn check_variants(files: &[str]) {\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);\n             if content_is_dangerous_to_modify(s) || content_is_confusing(s) {\n                 cont;\n             }\n-            log_err ~\"check_variants: \" + file;\n+            log_err \"check_variants: \" + file;\n             let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n             let crate =\n                 parser::parse_crate_from_source_str(\n@@ -374,7 +374,7 @@ fn check_variants(files: &[istr]) {\n     }\n }\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     if vec::len(args) != 2u {\n         log_err #fmt[\"usage: %s <testdir>\", args[0]];\n         ret;"}, {"sha": "56d0d2ad97d7e2217a5005e0d0e5b0cd3b0d9aaf", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -64,6 +64,7 @@ fn vec_edits<T>(v: &[T], xs: &[T]) -> [[T]] {\n                   //if (Lv >= 3u) { edits += ~[vec_reverse(v)]; }\n \n \n+\n     }\n     for each i: uint in ix(0u, 1u, Lv) { edits += [vec_omit(v, i)]; }\n     for each i: uint in ix(0u, 1u, Lv) { edits += [vec_dup(v, i)]; }"}, {"sha": "8d8b036933d22e834819e56ce319e6c5f5251f96", "filename": "src/lib/aio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -45,6 +45,7 @@ tag request {\n type ctx = chan<request>;\n \n fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n+\n     // FIXME: This is broken. We're creating a vector, getting a pointer\n     // to its buffer, then dropping the vector. On top of that, the vector\n     // created by str::bytes is not null-terminated.\n@@ -97,8 +98,7 @@ fn accept_task(client: client, events: chan<server_event>) {\n fn server_task(ip: net::ip_addr, portnum: int, events: chan<server_event>,\n                server: chan<server>) {\n     let accepter = port();\n-    send(server,\n-         rustrt::aio_serve(ip_to_sbuf(ip), portnum, chan(accepter)));\n+    send(server, rustrt::aio_serve(ip_to_sbuf(ip), portnum, chan(accepter)));\n \n     let client: client;\n     while true {"}, {"sha": "019aa32f36a996cf928b0fd3da9eb3a22b84526e", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -151,11 +151,9 @@ fn to_vec(v: &t) -> [uint] {\n     ret vec::init_fn::<uint>(sub, v.nbits);\n }\n \n-fn to_str(v: &t) -> istr {\n-    let rs = ~\"\";\n-    for i: uint in to_vec(v) {\n-        if i == 1u { rs += ~\"1\"; } else { rs += ~\"0\"; }\n-    }\n+fn to_str(v: &t) -> str {\n+    let rs = \"\";\n+    for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n "}, {"sha": "f1ea9d485bc9a9b8a791b11ed4bc1b23562dfb06", "filename": "src/lib/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,8 +12,8 @@ native \"rust\" mod rustrt {\n     type void;\n     type rust_port;\n \n-    fn chan_id_send<~T>(target_task: task::task,\n-                        target_port: port_id, data: -T);\n+    fn chan_id_send<~T>(target_task: task::task, target_port: port_id,\n+                        data: -T);\n \n     fn new_port(unit_sz: uint) -> *rust_port;\n     fn del_port(po: *rust_port);"}, {"sha": "3cc75e2f3b6b8bbb7409be511713acc758f677f3", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -27,6 +27,7 @@ fn create<@T>() -> t<T> {\n \n \n \n+\n     fn grow<@T>(nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));"}, {"sha": "09d0bee1a601414b86c14a049ad4c58d39d981be", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -67,7 +67,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n       some(d) { ret d; }\n       none. {\n-        log_err ~\"failed to find block with tag \" + uint::to_str(tg, 10u);\n+        log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n         fail;\n       }\n     }"}, {"sha": "edd9912087264fd785608b2fbdefbeb4a5a12d27", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -67,30 +67,30 @@ mod ct {\n \n \n     // A fragment of the output sequence\n-    tag piece { piece_string(istr); piece_conv(conv); }\n-    type error_fn = fn(&istr) -> ! ;\n+    tag piece { piece_string(str); piece_conv(conv); }\n+    type error_fn = fn(&str) -> ! ;\n \n-    fn parse_fmt_string(s: &istr, error: error_fn) -> [piece] {\n+    fn parse_fmt_string(s: &str, error: error_fn) -> [piece] {\n         let pieces: [piece] = [];\n         let lim = str::byte_len(s);\n-        let buf = ~\"\";\n-        fn flush_buf(buf: &istr, pieces: &mutable [piece]) -> istr {\n+        let buf = \"\";\n+        fn flush_buf(buf: &str, pieces: &mutable [piece]) -> str {\n             if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n             }\n-            ret ~\"\";\n+            ret \"\";\n         }\n         let i = 0u;\n         while i < lim {\n             let curr = str::substr(s, i, 1u);\n-            if str::eq(curr, ~\"%\") {\n+            if str::eq(curr, \"%\") {\n                 i += 1u;\n                 if i >= lim {\n-                    error(~\"unterminated conversion at end of string\");\n+                    error(\"unterminated conversion at end of string\");\n                 }\n                 let curr2 = str::substr(s, i, 1u);\n-                if str::eq(curr2, ~\"%\") {\n+                if str::eq(curr2, \"%\") {\n                     i += 1u;\n                 } else {\n                     buf = flush_buf(buf, pieces);\n@@ -103,7 +103,7 @@ mod ct {\n         buf = flush_buf(buf, pieces);\n         ret pieces;\n     }\n-    fn peek_num(s: &istr, i: uint, lim: uint) ->\n+    fn peek_num(s: &str, i: uint, lim: uint) ->\n        option::t<{num: uint, next: uint}> {\n         if i >= lim { ret none; }\n         let c = s[i];\n@@ -118,7 +118,7 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_conversion(s: &istr, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_conversion(s: &str, i: uint, lim: uint, error: error_fn) ->\n        {piece: piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -133,7 +133,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: &istr, i: uint, lim: uint) ->\n+    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: option::t<int>, next: uint} {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -148,14 +148,14 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: &istr, i: uint, lim: uint) ->\n+    fn parse_flags(s: &str, i: uint, lim: uint) ->\n        {flags: [flag], next: uint} {\n         let noflags: [flag] = [];\n         if i >= lim { ret {flags: noflags, next: i}; }\n \n         // FIXME: This recursion generates illegal instructions if the return\n         // value isn't boxed. Only started happening after the ivec conversion\n-        fn more_(f: flag, s: &istr, i: uint, lim: uint) ->\n+        fn more_(f: flag, s: &str, i: uint, lim: uint) ->\n            @{flags: [flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n@@ -177,8 +177,8 @@ mod ct {\n                 *more(flag_alternate)\n             } else { {flags: noflags, next: i} };\n     }\n-    fn parse_count(s: &istr, i: uint,\n-                   lim: uint) -> {count: count, next: uint} {\n+    fn parse_count(s: &str, i: uint, lim: uint) ->\n+       {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n             } else if s[i] == '*' as u8 {\n@@ -198,7 +198,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: &istr, i: uint, lim: uint) ->\n+    fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n@@ -214,32 +214,32 @@ mod ct {\n                 }\n             } else { {count: count_implied, next: i} };\n     }\n-    fn parse_type(s: &istr, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_type(s: &str, i: uint, lim: uint, error: error_fn) ->\n        {ty: ty, next: uint} {\n-        if i >= lim { error(~\"missing type in conversion\"); }\n+        if i >= lim { error(\"missing type in conversion\"); }\n         let tstr = str::substr(s, i, 1u);\n         // TODO: Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n-            if str::eq(tstr, ~\"b\") {\n+            if str::eq(tstr, \"b\") {\n                 ty_bool\n-            } else if str::eq(tstr, ~\"s\") {\n+            } else if str::eq(tstr, \"s\") {\n                 ty_str\n-            } else if str::eq(tstr, ~\"c\") {\n+            } else if str::eq(tstr, \"c\") {\n                 ty_char\n-            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n+            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n                 ty_int(signed)\n-            } else if str::eq(tstr, ~\"u\") {\n+            } else if str::eq(tstr, \"u\") {\n                 ty_int(unsigned)\n-            } else if str::eq(tstr, ~\"x\") {\n+            } else if str::eq(tstr, \"x\") {\n                 ty_hex(case_lower)\n-            } else if str::eq(tstr, ~\"X\") {\n+            } else if str::eq(tstr, \"X\") {\n                 ty_hex(case_upper)\n-            } else if str::eq(tstr, ~\"t\") {\n+            } else if str::eq(tstr, \"t\") {\n                 ty_bits\n-            } else if str::eq(tstr, ~\"o\") {\n+            } else if str::eq(tstr, \"o\") {\n                 ty_octal\n-            } else { error(~\"unknown type in conversion: \" + tstr) };\n+            } else { error(\"unknown type in conversion: \" + tstr) };\n         ret {ty: t, next: i + 1u};\n     }\n }\n@@ -270,20 +270,20 @@ mod rt {\n     // instead just use a bool per flag\n     type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n-    fn conv_int(cv: &conv, i: int) -> istr {\n+    fn conv_int(cv: &conv, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let s = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                s = ~\"+\" + s;\n+                s = \"+\" + s;\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = ~\" \" + s;\n+                s = \" \" + s;\n             }\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-    fn conv_uint(cv: &conv, u: uint) -> istr {\n+    fn conv_uint(cv: &conv, u: uint) -> str {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n@@ -295,17 +295,17 @@ mod rt {\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n-    fn conv_bool(cv: &conv, b: bool) -> istr {\n-        let s = if b { ~\"true\" } else { ~\"false\" };\n+    fn conv_bool(cv: &conv, b: bool) -> str {\n+        let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n \n         ret conv_str(cv, s);\n     }\n-    fn conv_char(cv: &conv, c: char) -> istr {\n+    fn conv_char(cv: &conv, c: char) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-    fn conv_str(cv: &conv, s: &istr) -> istr {\n+    fn conv_str(cv: &conv, s: &str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n \n@@ -324,18 +324,18 @@ mod rt {\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> istr {\n+    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> str {\n         ret if num < 0 {\n-                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n     }\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> istr {\n+    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> str {\n         ret if prec == 0u && num == 0u {\n-                ~\"\"\n+                \"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n                 let len = str::char_len(s);\n@@ -354,13 +354,13 @@ mod rt {\n     }\n \n     // FIXME: This might be useful in str: but needs to be utf8 safe first\n-    fn str_init_elt(c: char, n_elts: uint) -> istr {\n+    fn str_init_elt(c: char, n_elts: uint) -> str {\n         let svec = vec::init_elt::<u8>(c as u8, n_elts);\n \n         ret str::unsafe_from_bytes(svec);\n     }\n     tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv, s: &istr, mode: pad_mode) -> istr {\n+    fn pad(cv: &conv, s: &str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n           count_implied. { ret s; }"}, {"sha": "3ab6d3f5786434a3e3a03225888512d0a74b5161", "filename": "src/lib/fs.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,15 +6,15 @@ native \"rust\" mod rustrt {\n     fn rust_file_is_dir(path: str::sbuf) -> int;\n }\n \n-fn path_sep() -> istr { ret str::from_char(os_fs::path_sep); }\n+fn path_sep() -> str { ret str::from_char(os_fs::path_sep); }\n \n-type path = istr;\n+type path = str;\n \n fn dirname(p: &path) -> path {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n-        if i == -1 { ret ~\".\"; }\n+        if i == -1 { ret \".\"; }\n     }\n     ret str::substr(p, 0u, i as uint);\n }\n@@ -42,36 +42,28 @@ fn connect(pre: &path, post: &path) -> path {\n }\n \n fn file_is_dir(p: &path) -> bool {\n-    ret str::as_buf(p, { |buf|\n-        rustrt::rust_file_is_dir(buf) != 0\n-    });\n+    ret str::as_buf(p, {|buf| rustrt::rust_file_is_dir(buf) != 0 });\n }\n \n-fn list_dir(p: &path) -> [istr] {\n+fn list_dir(p: &path) -> [str] {\n     let p = p;\n     let pl = str::byte_len(p);\n     if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n-    let full_paths: [istr] = [];\n-    for filename: istr in os_fs::list_dir(p) {\n-        if !str::eq(filename, ~\".\") {\n-            if !str::eq(filename, ~\"..\") { full_paths += [p + filename]; }\n+    let full_paths: [str] = [];\n+    for filename: str in os_fs::list_dir(p) {\n+        if !str::eq(filename, \".\") {\n+            if !str::eq(filename, \"..\") { full_paths += [p + filename]; }\n         }\n     }\n     ret full_paths;\n }\n \n-fn path_is_absolute(p: &path) -> bool {\n-    ret os_fs::path_is_absolute(p);\n-}\n+fn path_is_absolute(p: &path) -> bool { ret os_fs::path_is_absolute(p); }\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n // that start with a slash.\n fn make_absolute(p: &path) -> path {\n-    if path_is_absolute(p) {\n-        ret p;\n-    } else {\n-        ret connect(getcwd(), p);\n-    }\n+    if path_is_absolute(p) { ret p; } else { ret connect(getcwd(), p); }\n }\n \n // Local Variables:"}, {"sha": "3d4894c4367be43d260ba7855a63e224cd209a25", "filename": "src/lib/fun_treemap.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffun_treemap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,53 +29,41 @@ type treemap<@K, @V> = @tree_node<K, V>;\n \n fn init<@K, @V>() -> treemap<K, V> { @empty }\n \n-fn insert<@K, @V>(m : &treemap<K, V>, k : &K, v : &V) -> treemap<K,V> {\n+fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) -> treemap<K, V> {\n     @alt m {\n-      @empty. {\n-        node(@k, @v, @empty, @empty)\n-      }\n-      @node(@kk, vv, left, right) {\n-        if k < kk {\n-            node(@kk, vv, insert(left, k, v), right)\n-        } else if k == kk {\n-            node(@kk, @v, left, right)\n-        } else {\n-            node(@kk, vv, left, insert(right, k, v))\n-        }\n-      }\n-    }\n+       @empty. { node(@k, @v, @empty, @empty) }\n+       @node(@kk, vv, left, right) {\n+         if k < kk {\n+             node(@kk, vv, insert(left, k, v), right)\n+         } else if k == kk {\n+             node(@kk, @v, left, right)\n+         } else { node(@kk, vv, left, insert(right, k, v)) }\n+       }\n+     }\n }\n \n-fn find<@K, @V>(m : &treemap<K, V>, k : &K) -> option<V> {\n-  alt *m {\n-    empty. { none }\n-    node(@kk, @v, left, right) {\n-      if k == kk { some(v) }\n-      else if k < kk { find(left, k) }\n-      else { find(right, k) }\n+fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n+    alt *m {\n+      empty. { none }\n+      node(@kk, @v, left, right) {\n+        if k == kk {\n+            some(v)\n+        } else if k < kk { find(left, k) } else { find(right, k) }\n+      }\n     }\n-  }\n }\n \n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m : &treemap<K, V>, f : fn(&K, &V)) {\n-  alt *m {\n-    empty. { }\n-    node(@k, @v, _, _) {\n-      // copy v to make aliases work out\n-      let v1 = v;\n-      alt *m {\n-        node(_, _, left, _) {\n-          traverse(left, f);\n-        }\n-      }\n-      f(k, v1);\n-      alt *m {\n-        node(_, _, _, right) {\n-          traverse(right, f);\n-        }\n+fn traverse<@K, @V>(m: &treemap<K, V>, f: fn(&K, &V)) {\n+    alt *m {\n+      empty. { }\n+      node(@k, @v, _, _) {\n+        // copy v to make aliases work out\n+        let v1 = v;\n+        alt *m { node(_, _, left, _) { traverse(left, f); } }\n+        f(k, v1);\n+        alt *m { node(_, _, _, right) { traverse(right, f); } }\n       }\n     }\n-  }\n }"}, {"sha": "8a34f76a387bd792fbbd09d2bf79336384f16b21", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,40 +3,45 @@ import str::sbuf;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn getenv(n: &istr) -> option::t<istr> {\n-    let s = str::as_buf(n, { |buf|\n-        os::libc::getenv(buf)\n-    });\n+fn getenv(n: &str) -> option::t<str> {\n+    let s = str::as_buf(n, {|buf| os::libc::getenv(buf) });\n     ret if unsafe::reinterpret_cast(s) == 0 {\n-        option::none::<istr>\n-    } else {\n-        let s = unsafe::reinterpret_cast(s);\n-        option::some::<istr>(str::str_from_cstr(s))\n-    };\n+            option::none::<str>\n+        } else {\n+            let s = unsafe::reinterpret_cast(s);\n+            option::some::<str>(str::str_from_cstr(s))\n+        };\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn setenv(n: &istr, v: &istr) {\n+fn setenv(n: &str, v: &str) {\n     // FIXME (868)\n-    let _: () = str::as_buf(n, { |nbuf|\n-        // FIXME (868)\n-        let _: () = str::as_buf(v, { |vbuf|\n-            os::libc::setenv(nbuf, vbuf, 1);\n-        });\n-    });\n+    let _: () =\n+        str::as_buf(n,\n+                    // FIXME (868)\n+                    {|nbuf|\n+                        let _: () =\n+                            str::as_buf(v,\n+                                        {|vbuf|\n+                                            os::libc::setenv(nbuf, vbuf, 1);\n+                                        });\n+                    });\n }\n \n #[cfg(target_os = \"win32\")]\n-fn getenv(n: &istr) -> option::t<istr> {\n+fn getenv(n: &str) -> option::t<str> {\n     let nsize = 256u;\n     while true {\n         let v: [u8] = [];\n         vec::reserve(v, nsize);\n-        let res = str::as_buf(n, { |nbuf|\n-            let vbuf = vec::to_ptr(v);\n-            os::kernel32::GetEnvironmentVariableA(nbuf, vbuf, nsize)\n-        });\n+        let res =\n+            str::as_buf(n,\n+                        {|nbuf|\n+                            let vbuf = vec::to_ptr(v);\n+                            os::kernel32::GetEnvironmentVariableA(nbuf, vbuf,\n+                                                                  nsize)\n+                        });\n         if res == 0u {\n             ret option::none;\n         } else if res < nsize {\n@@ -48,10 +53,10 @@ fn getenv(n: &istr) -> option::t<istr> {\n }\n \n #[cfg(target_os = \"win32\")]\n-fn setenv(n: &istr, v: &istr) {\n+fn setenv(n: &str, v: &str) {\n     // FIXME (868)\n-    let _: () = str::as_buf(n, { |nbuf|\n-        let _: () = str::as_buf(v, { |vbuf|\n+    let _: () = str::as_buf(n, {|nbuf|\n+        let _: () = str::as_buf(v, {|vbuf|\n             os::kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n         });\n     });"}, {"sha": "c36f766a5dc4669c350419f375a76e0cc3a4d529", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,49 +29,49 @@ export opt_strs;\n export opt_maybe_str;\n export opt_default;\n \n-tag name { long(istr); short(char); }\n+tag name { long(str); short(char); }\n \n tag hasarg { yes; no; maybe; }\n \n tag occur { req; optional; multi; }\n \n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n-fn mkname(nm: &istr) -> name {\n+fn mkname(nm: &str) -> name {\n     ret if str::char_len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n-fn reqopt(name: &istr) -> opt {\n+fn reqopt(name: &str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n-fn optopt(name: &istr) -> opt {\n+fn optopt(name: &str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n-fn optflag(name: &istr) -> opt {\n+fn optflag(name: &str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n-fn optflagopt(name: &istr) -> opt {\n+fn optflagopt(name: &str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n-fn optmulti(name: &istr) -> opt {\n+fn optmulti(name: &str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n-tag optval { val(istr); given; }\n+tag optval { val(str); given; }\n \n-type match = {opts: [opt], vals: [mutable [optval]], free: [istr]};\n+type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n-fn is_arg(arg: &istr) -> bool {\n+fn is_arg(arg: &str) -> bool {\n     ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: &name) -> istr {\n+fn name_str(nm: &name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n@@ -83,50 +83,48 @@ fn find_opt(opts: &[opt], nm: &name) -> option::t<uint> {\n }\n \n tag fail_ {\n-    argument_missing(istr);\n-    unrecognized_option(istr);\n-    option_missing(istr);\n-    option_duplicated(istr);\n-    unexpected_argument(istr);\n+    argument_missing(str);\n+    unrecognized_option(str);\n+    option_missing(str);\n+    option_duplicated(str);\n+    unexpected_argument(str);\n }\n \n-fn fail_str(f: &fail_) -> istr {\n+fn fail_str(f: &fail_) -> str {\n     ret alt f {\n-          argument_missing(nm) {\n-            ~\"Argument to option '\" + nm + ~\"' missing.\" }\n-          unrecognized_option(nm) {\n-            ~\"Unrecognized option: '\" + nm + ~\"'.\" }\n-          option_missing(nm) { ~\"Required option '\" + nm + ~\"' missing.\" }\n+          argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n+          unrecognized_option(nm) { \"Unrecognized option: '\" + nm + \"'.\" }\n+          option_missing(nm) { \"Required option '\" + nm + \"' missing.\" }\n           option_duplicated(nm) {\n-            ~\"Option '\" + nm + ~\"' given more than once.\"\n+            \"Option '\" + nm + \"' given more than once.\"\n           }\n           unexpected_argument(nm) {\n-            ~\"Option \" + nm + ~\" does not take an argument.\"\n+            \"Option \" + nm + \" does not take an argument.\"\n           }\n         };\n }\n \n tag result { success(match); failure(fail_); }\n \n-fn getopts(args: &[istr], opts: &[opt]) -> result {\n+fn getopts(args: &[str], opts: &[opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n     let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n-    let free: [istr] = [];\n+    let free: [str] = [];\n     let l = vec::len(args);\n     let i = 0u;\n     while i < l {\n         let cur = args[i];\n         let curlen = str::byte_len(cur);\n         if !is_arg(cur) {\n             free += [cur];\n-        } else if str::eq(cur, ~\"--\") {\n+        } else if str::eq(cur, \"--\") {\n             let j = i + 1u;\n             while j < l { free += [args[j]]; j += 1u; }\n             break;\n         } else {\n             let names;\n-            let i_arg = option::none::<istr>;\n+            let i_arg = option::none::<str>;\n             if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let eq = str::index(tail, '=' as u8);\n@@ -135,9 +133,9 @@ fn getopts(args: &[istr], opts: &[opt]) -> result {\n                 } else {\n                     names = [long(str::slice(tail, 0u, eq as uint))];\n                     i_arg =\n-                        option::some::<istr>(str::slice(tail,\n-                                                        (eq as uint) + 1u,\n-                                                        curlen - 2u));\n+                        option::some::<str>(str::slice(tail,\n+                                                       (eq as uint) + 1u,\n+                                                       curlen - 2u));\n                 }\n             } else {\n                 let j = 1u;\n@@ -158,22 +156,22 @@ fn getopts(args: &[istr], opts: &[opt]) -> result {\n                 }\n                 alt opts[optid].hasarg {\n                   no. {\n-                    if !option::is_none::<istr>(i_arg) {\n+                    if !option::is_none::<str>(i_arg) {\n                         ret failure(unexpected_argument(name_str(nm)));\n                     }\n                     vals[optid] += [given];\n                   }\n                   maybe. {\n-                    if !option::is_none::<istr>(i_arg) {\n+                    if !option::is_none::<str>(i_arg) {\n                         vals[optid] += [val(option::get(i_arg))];\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vals[optid] += [given];\n                     } else { i += 1u; vals[optid] += [val(args[i])]; }\n                   }\n                   yes. {\n-                    if !option::is_none::<istr>(i_arg) {\n-                        vals[optid] += [val(option::get::<istr>(i_arg))];\n+                    if !option::is_none::<str>(i_arg) {\n+                        vals[optid] += [val(option::get::<str>(i_arg))];\n                     } else if i + 1u == l {\n                         ret failure(argument_missing(name_str(nm)));\n                     } else { i += 1u; vals[optid] += [val(args[i])]; }\n@@ -202,45 +200,45 @@ fn getopts(args: &[istr], opts: &[opt]) -> result {\n     ret success({opts: opts, vals: vals, free: free});\n }\n \n-fn opt_vals(m: &match, nm: &istr) -> [optval] {\n+fn opt_vals(m: &match, nm: &str) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n-          none. { log_err ~\"No option '\" + nm + ~\"' defined.\"; fail }\n+          none. { log_err \"No option '\" + nm + \"' defined.\"; fail }\n         };\n }\n \n-fn opt_val(m: &match, nm: &istr) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: &match, nm: &str) -> optval { ret opt_vals(m, nm)[0]; }\n \n-fn opt_present(m: &match, nm: &istr) -> bool {\n+fn opt_present(m: &match, nm: &str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n-fn opt_str(m: &match, nm: &istr) -> istr {\n+fn opt_str(m: &match, nm: &str) -> str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n-fn opt_strs(m: &match, nm: &istr) -> [istr] {\n-    let acc: [istr] = [];\n+fn opt_strs(m: &match, nm: &str) -> [str] {\n+    let acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n         alt v { val(s) { acc += [s]; } _ { } }\n     }\n     ret acc;\n }\n \n-fn opt_maybe_str(m: &match, nm: &istr) -> option::t<istr> {\n+fn opt_maybe_str(m: &match, nm: &str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<istr>; }\n-    ret alt vals[0] { val(s) { some::<istr>(s) } _ { none::<istr> } };\n+    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n+    ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n /// Returns none if the option was not present, `def` if the option was\n /// present but no argument was provided, and the argument if the option was\n /// present and an argument was provided.\n-fn opt_default(m: &match, nm: &istr, def: &istr) -> option::t<istr> {\n+fn opt_default(m: &match, nm: &str, def: &str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<istr>; }\n-    ret alt vals[0] { val(s) { some::<istr>(s) } _ { some::<istr>(def) } }\n+    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n+    ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n }\n // Local Variables:\n // mode: rust;"}, {"sha": "ef80852c8d35894e84e2319e4e658afedb4e37c7", "filename": "src/lib/int.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -41,13 +41,13 @@ iter range(lo: int, hi: int) -> int {\n     while lo_ < hi { put lo_; lo_ += 1; }\n }\n \n-fn to_str(n: int, radix: uint) -> istr {\n+fn to_str(n: int, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n     ret if n < 0 {\n-            ~\"-\" + uint::to_str(-n as uint, radix)\n+            \"-\" + uint::to_str(-n as uint, radix)\n         } else { uint::to_str(n as uint, radix) };\n }\n-fn str(i: int) -> istr { ret to_str(i, 10u); }\n+fn str(i: int) -> str { ret to_str(i, 10u); }\n \n fn pow(base: int, exponent: uint) -> int {\n     ret if exponent == 0u {"}, {"sha": "0889d3ec454a1ad1de2e2ddfa90ade55555ab042", "filename": "src/lib/io.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -40,8 +40,8 @@ type reader =\n         fn read_bytes(uint) -> [u8];\n         fn read_char() -> char;\n         fn eof() -> bool;\n-        fn read_line() -> istr;\n-        fn read_c_str() -> istr;\n+        fn read_line() -> str;\n+        fn read_c_str() -> str;\n         fn read_le_uint(uint) -> uint;\n         fn read_le_int(uint) -> int;\n         fn read_be_uint(uint) -> uint;\n@@ -60,8 +60,8 @@ obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] {\n         let buf = [];\n         vec::reserve::<u8>(buf, len);\n-        let read = os::libc::fread(vec::unsafe::to_ptr::<u8>(buf),\n-                                   1u, len, f);\n+        let read =\n+            os::libc::fread(vec::unsafe::to_ptr::<u8>(buf), 1u, len, f);\n         vec::unsafe::set_len::<u8>(buf, read);\n         ret buf;\n     }\n@@ -106,7 +106,7 @@ obj new_reader(rdr: buf_reader) {\n         ret val as char;\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n-    fn read_line() -> istr {\n+    fn read_line() -> str {\n         let buf: [u8] = [];\n         // No break yet in rustc\n \n@@ -119,7 +119,7 @@ obj new_reader(rdr: buf_reader) {\n         }\n         ret str::unsafe_from_bytes(buf);\n     }\n-    fn read_c_str() -> istr {\n+    fn read_c_str() -> str {\n         let buf: [u8] = [];\n         let go_on = true;\n         while go_on {\n@@ -174,13 +174,16 @@ fn stdin() -> reader {\n     ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), option::none));\n }\n \n-fn file_reader(path: &istr) -> reader {\n-    let f = str::as_buf(path, { |pathbuf|\n-        str::as_buf(~\"r\", { |modebuf|\n-            os::libc::fopen(pathbuf, modebuf)\n-        })\n-    });\n-    if f as uint == 0u { log_err ~\"error opening \" + path; fail; }\n+fn file_reader(path: &str) -> reader {\n+    let f =\n+        str::as_buf(path,\n+                    {|pathbuf|\n+                        str::as_buf(\"r\",\n+                                    {|modebuf|\n+                                        os::libc::fopen(pathbuf, modebuf)\n+                                    })\n+                    });\n+    if f as uint == 0u { log_err \"error opening \" + path; fail; }\n     ret new_reader(FILE_buf_reader(f, option::some(@FILE_res(f))));\n }\n \n@@ -219,7 +222,7 @@ fn new_byte_buf_reader(buf: &[u8]) -> buf_reader {\n     ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n }\n \n-fn string_reader(s: &istr) -> reader {\n+fn string_reader(s: &str) -> reader {\n     ret new_reader(new_byte_buf_reader(str::bytes(s)));\n }\n \n@@ -279,7 +282,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     }\n }\n \n-fn file_buf_writer(path: &istr, flags: &[fileflag]) -> buf_writer {\n+fn file_buf_writer(path: &str, flags: &[fileflag]) -> buf_writer {\n     let fflags: int =\n         os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n     for f: fileflag in flags {\n@@ -290,11 +293,13 @@ fn file_buf_writer(path: &istr, flags: &[fileflag]) -> buf_writer {\n           none. { }\n         }\n     }\n-    let fd = str::as_buf(path, { |pathbuf|\n-        os::libc::open(pathbuf, fflags,\n-                       os::libc_constants::S_IRUSR() |\n-                           os::libc_constants::S_IWUSR())\n-    });\n+    let fd =\n+        str::as_buf(path,\n+                    {|pathbuf|\n+                        os::libc::open(pathbuf, fflags,\n+                                       os::libc_constants::S_IRUSR() |\n+                                           os::libc_constants::S_IWUSR())\n+                    });\n     if fd < 0 {\n         log_err \"error opening file for writing\";\n         log_err sys::rustrt::last_os_error();\n@@ -308,8 +313,8 @@ type writer =\n     // function will be provided for general encoded string output\n     obj {\n         fn get_buf_writer() -> buf_writer;\n-        fn write_str(&istr);\n-        fn write_line(&istr);\n+        fn write_str(&str);\n+        fn write_line(&str);\n         fn write_char(char);\n         fn write_int(int);\n         fn write_uint(uint);\n@@ -334,20 +339,18 @@ fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n \n obj new_writer(out: buf_writer) {\n     fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: &istr) { out.write(str::bytes(s)); }\n-    fn write_line(s: &istr) {\n+    fn write_str(s: &str) { out.write(str::bytes(s)); }\n+    fn write_line(s: &str) {\n         out.write(str::bytes(s));\n-        out.write(str::bytes(~\"\\n\"));\n+        out.write(str::bytes(\"\\n\"));\n     }\n     fn write_char(ch: char) {\n         // FIXME needlessly consy\n \n         out.write(str::bytes(str::from_char(ch)));\n     }\n-    fn write_int(n: int) { out.write(str::bytes(\n-        int::to_str(n, 10u))); }\n-    fn write_uint(n: uint) { out.write(str::bytes(\n-        uint::to_str(n, 10u))); }\n+    fn write_int(n: int) { out.write(str::bytes(int::to_str(n, 10u))); }\n+    fn write_uint(n: uint) { out.write(str::bytes(uint::to_str(n, 10u))); }\n     fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n         out.write(uint_to_le_bytes(n, size));\n@@ -360,19 +363,22 @@ obj new_writer(out: buf_writer) {\n     }\n }\n \n-fn file_writer(path: &istr, flags: &[fileflag]) -> writer {\n+fn file_writer(path: &str, flags: &[fileflag]) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n \n // FIXME: fileflags\n-fn buffered_file_buf_writer(path: &istr) -> buf_writer {\n-    let f = str::as_buf(path, { |pathbuf|\n-        str::as_buf(~\"w\", { |modebuf|\n-            os::libc::fopen(pathbuf, modebuf)\n-        })\n-    });\n-    if f as uint == 0u { log_err ~\"error opening \" + path; fail; }\n+fn buffered_file_buf_writer(path: &str) -> buf_writer {\n+    let f =\n+        str::as_buf(path,\n+                    {|pathbuf|\n+                        str::as_buf(\"w\",\n+                                    {|modebuf|\n+                                        os::libc::fopen(pathbuf, modebuf)\n+                                    })\n+                    });\n+    if f as uint == 0u { log_err \"error opening \" + path; fail; }\n     ret FILE_writer(f, option::some(@FILE_res(f)));\n }\n \n@@ -384,7 +390,7 @@ fn stderr() -> writer { ret new_writer(fd_buf_writer(2, option::none)); }\n type str_writer =\n     obj {\n         fn get_writer() -> writer;\n-        fn get_str() -> istr;\n+        fn get_str() -> str;\n     };\n \n type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n@@ -427,7 +433,7 @@ fn string_writer() -> str_writer {\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n         fn get_writer() -> writer { ret wr; }\n-        fn get_str() -> istr { ret str::unsafe_from_bytes(buf.buf); }\n+        fn get_str() -> str { ret str::unsafe_from_bytes(buf.buf); }\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }\n@@ -447,11 +453,11 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     ret bpos as uint;\n }\n \n-fn read_whole_file_str(file: &istr) -> istr {\n+fn read_whole_file_str(file: &str) -> str {\n     str::unsafe_from_bytes(read_whole_file(file))\n }\n \n-fn read_whole_file(file: &istr) -> [u8] {\n+fn read_whole_file(file: &str) -> [u8] {\n \n     // FIXME: There's a lot of copying here\n     file_reader(file).read_whole_stream()"}, {"sha": "b393d9a1e08c211c7168dcd701289c746dca854e", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -50,11 +50,11 @@ mod libc_constants {\n     fn S_IWUSR() -> uint { ret 128u; }\n }\n \n-fn exec_suffix() -> istr { ret ~\"\"; }\n+fn exec_suffix() -> str { ret \"\"; }\n \n-fn target_os() -> istr { ret ~\"linux\"; }\n+fn target_os() -> str { ret \"linux\"; }\n \n-fn dylib_filename(base: &istr) -> istr { ret ~\"lib\" + base + ~\".so\"; }\n+fn dylib_filename(base: &str) -> str { ret \"lib\" + base + \".so\"; }\n \n fn pipe() -> {in: int, out: int} {\n     let fds = {mutable in: 0, mutable out: 0};\n@@ -63,9 +63,7 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret str::as_buf(~\"r\", { |modebuf|\n-        libc::fdopen(fd, modebuf)\n-    });\n+    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n }\n \n fn waitpid(pid: int) -> int {\n@@ -75,12 +73,10 @@ fn waitpid(pid: int) -> int {\n }\n \n native \"rust\" mod rustrt {\n-    fn rust_getcwd() -> istr;\n+    fn rust_getcwd() -> str;\n }\n \n-fn getcwd() -> istr {\n-    ret rustrt::rust_getcwd();\n-}\n+fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n \n // Local Variables:"}, {"sha": "e18fdd5b32f4bb5a4cdf069576d3b66c9fc95c62", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -47,11 +47,11 @@ mod libc_constants {\n     fn S_IWUSR() -> uint { ret 512u; }\n }\n \n-fn exec_suffix() -> istr { ret ~\"\"; }\n+fn exec_suffix() -> str { ret \"\"; }\n \n-fn target_os() -> istr { ret ~\"macos\"; }\n+fn target_os() -> str { ret \"macos\"; }\n \n-fn dylib_filename(base: &istr) -> istr { ret ~\"lib\" + base + ~\".dylib\"; }\n+fn dylib_filename(base: &str) -> str { ret \"lib\" + base + \".dylib\"; }\n \n fn pipe() -> {in: int, out: int} {\n     let fds = {mutable in: 0, mutable out: 0};\n@@ -60,9 +60,7 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret str::as_buf(~\"r\", { |modebuf|\n-        libc::fdopen(fd, modebuf)\n-    });\n+    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n }\n \n fn waitpid(pid: int) -> int {\n@@ -72,12 +70,10 @@ fn waitpid(pid: int) -> int {\n }\n \n native \"rust\" mod rustrt {\n-    fn rust_getcwd() -> istr;\n+    fn rust_getcwd() -> str;\n }\n \n-fn getcwd() -> istr {\n-    ret rustrt::rust_getcwd();\n-}\n+fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n \n // Local Variables:"}, {"sha": "d54eae03d105763a3421dcc4f2a290ce31bb661c", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -194,7 +194,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash<@V>() -> hashmap<istr, V> {\n+fn new_str_hash<@V>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n "}, {"sha": "be778d9858e859dcc03e27351e5d6513044129bd", "filename": "src/lib/net.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,7 +3,7 @@ import uint;\n \n tag ip_addr { ipv4(u8, u8, u8, u8); }\n \n-fn format_addr(ip: ip_addr) -> istr {\n+fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n       ipv4(a, b, c, d) {\n         #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n@@ -12,10 +12,8 @@ fn format_addr(ip: ip_addr) -> istr {\n     }\n }\n \n-fn parse_addr(ip: &istr) -> ip_addr {\n-    let parts = vec::map(\n-        { |&s| uint::from_str(s) },\n-        str::split(ip, ~\".\"[0]));\n+fn parse_addr(ip: &str) -> ip_addr {\n+    let parts = vec::map({|&s| uint::from_str(s) }, str::split(ip, \".\"[0]));\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)"}, {"sha": "8b4f06a6a9b22868880c0a2fc28358de8d98656b", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,9 +1,9 @@\n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: &istr) -> [istr];\n+    fn rust_list_files(path: &str) -> [str];\n }\n \n-fn list_dir(path: &istr) -> [istr] {\n+fn list_dir(path: &str) -> [str] {\n     ret rustrt::rust_list_files(path);\n \n     // FIXME: No idea why, but this appears to corrupt memory on OSX. I\n@@ -30,7 +30,7 @@ fn list_dir(path: &istr) -> [istr] {\n \n }\n \n-fn path_is_absolute(p: &istr) -> bool { ret str::char_at(p, 0u) == '/'; }\n+fn path_is_absolute(p: &str) -> bool { ret str::char_at(p, 0u) == '/'; }\n \n const path_sep: char = '/';\n "}, {"sha": "a4adaace38a9a43975628bbb962d11140c9f1128", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,29 +12,27 @@ native \"rust\" mod rustrt {\n        int;\n }\n \n-fn arg_vec(prog: &istr, args: &[@istr]) -> [sbuf] {\n-    let argptrs = str::as_buf(prog, { |buf| [buf] });\n-    for arg in args {\n-        argptrs += str::as_buf(*arg, { |buf| [buf] });\n-    }\n+fn arg_vec(prog: &str, args: &[@str]) -> [sbuf] {\n+    let argptrs = str::as_buf(prog, {|buf| [buf] });\n+    for arg in args { argptrs += str::as_buf(*arg, {|buf| [buf] }); }\n     argptrs += [unsafe::reinterpret_cast(0)];\n     ret argptrs;\n }\n \n-fn spawn_process(prog: &istr, args: &[istr], in_fd: int, out_fd: int,\n+fn spawn_process(prog: &str, args: &[str], in_fd: int, out_fd: int,\n                  err_fd: int) -> int {\n     // Note: we have to hold on to these vector references while we hold a\n     // pointer to their buffers\n     let prog = prog;\n-    let args = vec::map({ |&arg| @arg }, args);\n+    let args = vec::map({|&arg| @arg }, args);\n     let argv = arg_vec(prog, args);\n     let pid =\n-        rustrt::rust_run_program(vec::unsafe::to_ptr(argv),\n-                                 in_fd, out_fd, err_fd);\n+        rustrt::rust_run_program(vec::unsafe::to_ptr(argv), in_fd, out_fd,\n+                                 err_fd);\n     ret pid;\n }\n \n-fn run_program(prog: &istr, args: &[istr]) -> int {\n+fn run_program(prog: &str, args: &[str]) -> int {\n     ret os::waitpid(spawn_process(prog, args, 0, 0, 0));\n }\n \n@@ -51,7 +49,7 @@ type program =\n \n resource program_res(p: program) { p.destroy(); }\n \n-fn start_program(prog: &istr, args: &[istr]) -> @program_res {\n+fn start_program(prog: &str, args: &[str]) -> @program_res {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -102,17 +100,17 @@ fn start_program(prog: &istr, args: &[istr]) -> @program_res {\n                                  os::fd_FILE(pipe_err.in), false));\n }\n \n-fn read_all(rd: &io::reader) -> istr {\n-    let buf = ~\"\";\n+fn read_all(rd: &io::reader) -> str {\n+    let buf = \"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n         buf += str::unsafe_from_bytes(bytes);\n     }\n     ret buf;\n }\n \n-fn program_output(prog: &istr, args: &[istr]) ->\n-   {status: int, out: istr, err: istr} {\n+fn program_output(prog: &str, args: &[str]) ->\n+   {status: int, out: str, err: str} {\n     let pr = start_program(prog, args);\n     pr.close_input();\n     ret {status: pr.finish(),"}, {"sha": "25003a4b1284cf44c8c8693dc2d0b91fca3032a8", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,20 +6,21 @@\n export sha1;\n export mk_sha1;\n \n-type sha1 = obj {\n+type sha1 =\n     // Provide message input as bytes\n-    fn input(&[u8]);\n     // Provide message input as string\n-    fn input_str(&istr);\n     // Read the digest as a vector of 20 bytes. After calling this no further\n     // input may provided until reset is called\n-    fn result() -> [u8];\n     // Same as above, just a hex-string version.\n-    fn result_str() -> istr;\n     // Reset the sha1 state for reuse. This is called\n     // automatically during construction\n-    fn reset();\n-};\n+    obj {\n+        fn input(&[u8]);\n+        fn input_str(&str);\n+        fn result() -> [u8];\n+        fn result_str() -> str;\n+        fn reset();\n+    };\n \n \n // Some unexported constants\n@@ -215,14 +216,12 @@ fn mk_sha1() -> sha1 {\n             st.computed = false;\n         }\n         fn input(msg: &[u8]) { add_input(st, msg); }\n-        fn input_str(msg: &istr) { add_input(st, str::bytes(msg)); }\n+        fn input_str(msg: &str) { add_input(st, str::bytes(msg)); }\n         fn result() -> [u8] { ret mk_result(st); }\n-        fn result_str() -> istr {\n+        fn result_str() -> str {\n             let r = mk_result(st);\n-            let s = ~\"\";\n-            for b: u8 in r {\n-                s += uint::to_str(b as uint, 16u);\n-            }\n+            let s = \"\";\n+            for b: u8 in r { s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }\n     }"}, {"sha": "1d03f7681017ba2bf85e7385d4601ceec107d474", "filename": "src/lib/str.rs", "status": "modified", "additions": 96, "deletions": 116, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,20 +1,20 @@\n-export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n-index, rindex, find, starts_with, ends_with, substr, slice, split,\n-concat, connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n-unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars, to_chars,\n-char_len, char_at, bytes, is_ascii, shift_byte, pop_byte, unsafe_from_byte,\n-unsafe_from_bytes, from_char, char_range_at, str_from_cstr, sbuf,\n-as_buf, push_byte, utf8_char_width, safe_slice;\n+export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len, index,\n+       rindex, find, starts_with, ends_with, substr, slice, split, concat,\n+       connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n+       unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars,\n+       to_chars, char_len, char_at, bytes, is_ascii, shift_byte, pop_byte,\n+       unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n+       str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice;\n \n native \"rust\" mod rustrt {\n-    fn rust_istr_push(s: &mutable istr, ch: u8);\n+    fn rust_str_push(s: &mutable str, ch: u8);\n }\n \n-fn eq(a: &istr, b: &istr) -> bool { a == b }\n+fn eq(a: &str, b: &str) -> bool { a == b }\n \n-fn lteq(a: &istr, b: &istr) -> bool { a <= b }\n+fn lteq(a: &str, b: &str) -> bool { a <= b }\n \n-fn hash(s: &istr) -> uint {\n+fn hash(s: &str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n \n@@ -54,23 +54,19 @@ fn is_utf8(v: &[u8]) -> bool {\n     ret true;\n }\n \n-fn is_ascii(s: &istr) -> bool {\n+fn is_ascii(s: &str) -> bool {\n     let i: uint = byte_len(s);\n     while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n     ret true;\n }\n \n /// Returns true if the string has length 0\n-pure fn is_empty(s: &istr) -> bool {\n-    for c: u8 in s { ret false; } ret true;\n-}\n+pure fn is_empty(s: &str) -> bool { for c: u8 in s { ret false; } ret true; }\n \n /// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: &istr) -> bool {\n-    !is_empty(s)\n-}\n+pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n \n-fn is_whitespace(s: &istr) -> bool {\n+fn is_whitespace(s: &str) -> bool {\n     let i = 0u;\n     let len = char_len(s);\n     while i < len {\n@@ -80,74 +76,68 @@ fn is_whitespace(s: &istr) -> bool {\n     ret true;\n }\n \n-fn byte_len(s: &istr) -> uint {\n+fn byte_len(s: &str) -> uint {\n     let v: [u8] = unsafe::reinterpret_cast(s);\n     let vlen = vec::len(v);\n     unsafe::leak(v);\n     // There should always be a null terminator\n-    assert vlen > 0u;\n+    assert (vlen > 0u);\n     ret vlen - 1u;\n }\n \n-fn bytes(s: &istr) -> [u8] {\n+fn bytes(s: &str) -> [u8] {\n     let v = unsafe::reinterpret_cast(s);\n     let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n     unsafe::leak(v);\n     ret vcopy;\n }\n \n-fn unsafe_from_bytes(v: &[mutable? u8]) -> istr {\n+fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n     let vcopy: [u8] = v + [0u8];\n-    let scopy: istr = unsafe::reinterpret_cast(vcopy);\n+    let scopy: str = unsafe::reinterpret_cast(vcopy);\n     unsafe::leak(vcopy);\n     ret scopy;\n }\n \n-fn unsafe_from_byte(u: u8) -> istr {\n-    unsafe_from_bytes([u])\n-}\n+fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n-fn push_utf8_bytes(s: &mutable istr, ch: char) {\n+fn push_utf8_bytes(s: &mutable str, ch: char) {\n     let code = ch as uint;\n-    let bytes = if code < max_one_b {\n-        [code as u8]\n-    } else if code < max_two_b {\n-        [(code >> 6u & 31u | tag_two_b) as u8,\n-         (code & 63u | tag_cont) as u8]\n-    } else if code < max_three_b {\n-        [(code >> 12u & 15u | tag_three_b) as u8,\n-         (code >> 6u & 63u | tag_cont) as u8,\n-         (code & 63u | tag_cont) as u8]\n-    } else if code < max_four_b {\n-        [(code >> 18u & 7u | tag_four_b) as u8,\n-         (code >> 12u & 63u | tag_cont) as u8,\n-         (code >> 6u & 63u | tag_cont) as u8,\n-         (code & 63u | tag_cont) as u8]\n-    } else if code < max_five_b {\n-        [(code >> 24u & 3u | tag_five_b) as u8,\n-         (code >> 18u & 63u | tag_cont) as u8,\n-         (code >> 12u & 63u | tag_cont) as u8,\n-         (code >> 6u & 63u | tag_cont) as u8,\n-         (code & 63u | tag_cont) as u8]\n-    } else {\n-        [(code >> 30u & 1u | tag_six_b) as u8,\n-         (code >> 24u & 63u | tag_cont) as u8,\n-         (code >> 18u & 63u | tag_cont) as u8,\n-         (code >> 12u & 63u | tag_cont) as u8,\n-         (code >> 6u & 63u | tag_cont) as u8,\n-         (code & 63u | tag_cont) as u8]\n-    };\n+    let bytes =\n+        if code < max_one_b {\n+            [code as u8]\n+        } else if code < max_two_b {\n+            [code >> 6u & 31u | tag_two_b as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_three_b {\n+            [code >> 12u & 15u | tag_three_b as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_four_b {\n+            [code >> 18u & 7u | tag_four_b as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else if code < max_five_b {\n+            [code >> 24u & 3u | tag_five_b as u8,\n+             code >> 18u & 63u | tag_cont as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        } else {\n+            [code >> 30u & 1u | tag_six_b as u8,\n+             code >> 24u & 63u | tag_cont as u8,\n+             code >> 18u & 63u | tag_cont as u8,\n+             code >> 12u & 63u | tag_cont as u8,\n+             code >> 6u & 63u | tag_cont as u8, code & 63u | tag_cont as u8]\n+        };\n     push_bytes(s, bytes);\n }\n \n-fn from_char(ch: char) -> istr {\n-    let buf = ~\"\";\n+fn from_char(ch: char) -> str {\n+    let buf = \"\";\n     push_utf8_bytes(buf, ch);\n     ret buf;\n }\n \n-fn from_chars(chs: &[char]) -> istr {\n-    let buf = ~\"\";\n+fn from_chars(chs: &[char]) -> str {\n+    let buf = \"\";\n     for ch: char in chs { push_utf8_bytes(buf, ch); }\n     ret buf;\n }\n@@ -166,7 +156,7 @@ fn utf8_char_width(b: u8) -> uint {\n     ret 6u;\n }\n \n-fn char_range_at(s: &istr, i: uint) -> {ch: char, next: uint} {\n+fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -188,9 +178,9 @@ fn char_range_at(s: &istr, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n-fn char_at(s: &istr, i: uint) -> char { ret char_range_at(s, i).ch; }\n+fn char_at(s: &str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n-fn char_len(s: &istr) -> uint {\n+fn char_len(s: &str) -> uint {\n     let i = 0u;\n     let len = 0u;\n     let total = byte_len(s);\n@@ -204,7 +194,7 @@ fn char_len(s: &istr) -> uint {\n     ret len;\n }\n \n-fn to_chars(s: &istr) -> [char] {\n+fn to_chars(s: &str) -> [char] {\n     let buf: [char] = [];\n     let i = 0u;\n     let len = byte_len(s);\n@@ -216,9 +206,9 @@ fn to_chars(s: &istr) -> [char] {\n     ret buf;\n }\n \n-fn push_char(s: &mutable istr, ch: char) { s += from_char(ch); }\n+fn push_char(s: &mutable str, ch: char) { s += from_char(ch); }\n \n-fn pop_char(s: &mutable istr) -> char {\n+fn pop_char(s: &mutable str) -> char {\n     let end = byte_len(s);\n     while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n     assert (end > 0u);\n@@ -227,31 +217,31 @@ fn pop_char(s: &mutable istr) -> char {\n     ret ch;\n }\n \n-fn shift_char(s: &mutable istr) -> char {\n+fn shift_char(s: &mutable str) -> char {\n     let r = char_range_at(s, 0u);\n     s = substr(s, r.next, byte_len(s) - r.next);\n     ret r.ch;\n }\n \n-fn unshift_char(s: &mutable istr, ch: char) { s = from_char(ch) + s; }\n+fn unshift_char(s: &mutable str, ch: char) { s = from_char(ch) + s; }\n \n-fn index(s: &istr, c: u8) -> int {\n+fn index(s: &str, c: u8) -> int {\n     let i: int = 0;\n     for k: u8 in s { if k == c { ret i; } i += 1; }\n     ret -1;\n }\n \n-fn rindex(s: &istr, c: u8) -> int {\n+fn rindex(s: &str, c: u8) -> int {\n     let n: int = byte_len(s) as int;\n     while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n     ret n;\n }\n \n-fn find(haystack: &istr, needle: &istr) -> int {\n+fn find(haystack: &str, needle: &str) -> int {\n     let haystack_len: int = byte_len(haystack) as int;\n     let needle_len: int = byte_len(needle) as int;\n     if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: &istr, needle: &istr, i: int) -> bool {\n+    fn match_at(haystack: &str, needle: &str, i: int) -> bool {\n         let j: int = i;\n         for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n         ret true;\n@@ -264,15 +254,15 @@ fn find(haystack: &istr, needle: &istr) -> int {\n     ret -1;\n }\n \n-fn starts_with(haystack: &istr, needle: &istr) -> bool {\n+fn starts_with(haystack: &str, needle: &str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n     if needle_len == 0u { ret true; }\n     if needle_len > haystack_len { ret false; }\n     ret eq(substr(haystack, 0u, needle_len), needle);\n }\n \n-fn ends_with(haystack: &istr, needle: &istr) -> bool {\n+fn ends_with(haystack: &str, needle: &str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n     ret if needle_len == 0u {\n@@ -285,11 +275,11 @@ fn ends_with(haystack: &istr, needle: &istr) -> bool {\n         };\n }\n \n-fn substr(s: &istr, begin: uint, len: uint) -> istr {\n+fn substr(s: &str, begin: uint, len: uint) -> str {\n     ret slice(s, begin, begin + len);\n }\n \n-fn slice(s: &istr, begin: uint, end: uint) -> istr {\n+fn slice(s: &str, begin: uint, end: uint) -> str {\n     // FIXME: Typestate precondition\n     assert (begin <= end);\n     assert (end <= byte_len(s));\n@@ -298,78 +288,73 @@ fn slice(s: &istr, begin: uint, end: uint) -> istr {\n     let v2 = vec::slice(v, begin, end);\n     unsafe::leak(v);\n     v2 += [0u8];\n-    let s2: istr = unsafe::reinterpret_cast(v2);\n+    let s2: str = unsafe::reinterpret_cast(v2);\n     unsafe::leak(v2);\n     ret s2;\n }\n \n-fn safe_slice(s: &istr, begin: uint, end: uint)\n-    : uint::le(begin, end) -> istr {\n+fn safe_slice(s: &str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n     // would need some magic to make this a precondition\n     assert (end <= byte_len(s));\n     ret slice(s, begin, end);\n }\n \n-fn shift_byte(s: &mutable istr) -> u8 {\n+fn shift_byte(s: &mutable str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[0];\n     s = substr(s, 1u, len - 1u);\n     ret b;\n }\n \n-fn pop_byte(s: &mutable istr) -> u8 {\n+fn pop_byte(s: &mutable str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n     let b = s[len - 1u];\n     s = substr(s, 0u, len - 1u);\n     ret b;\n }\n \n-fn push_byte(s: &mutable istr, b: u8) {\n-    rustrt::rust_istr_push(s, b);\n-}\n+fn push_byte(s: &mutable str, b: u8) { rustrt::rust_str_push(s, b); }\n \n-fn push_bytes(s: &mutable istr, bytes: &[u8]) {\n-    for byte in bytes {\n-        rustrt::rust_istr_push(s, byte);\n-    }\n+fn push_bytes(s: &mutable str, bytes: &[u8]) {\n+    for byte in bytes { rustrt::rust_str_push(s, byte); }\n }\n \n-fn split(s: &istr, sep: u8) -> [istr] {\n-    let v: [istr] = [];\n-    let accum: istr = ~\"\";\n+fn split(s: &str, sep: u8) -> [str] {\n+    let v: [str] = [];\n+    let accum: str = \"\";\n     let ends_with_sep: bool = false;\n     for c: u8 in s {\n         if c == sep {\n             v += [accum];\n-            accum = ~\"\";\n+            accum = \"\";\n             ends_with_sep = true;\n         } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n }\n \n-fn concat(v: &[istr]) -> istr {\n-    let s: istr = ~\"\";\n-    for ss: istr in v { s += ss; }\n+fn concat(v: &[str]) -> str {\n+    let s: str = \"\";\n+    for ss: str in v { s += ss; }\n     ret s;\n }\n \n-fn connect(v: &[istr], sep: &istr) -> istr {\n-    let s: istr = ~\"\";\n+fn connect(v: &[str], sep: &str) -> str {\n+    let s: str = \"\";\n     let first: bool = true;\n-    for ss: istr in v {\n+    for ss: str in v {\n         if first { first = false; } else { s += sep; }\n         s += ss;\n     }\n     ret s;\n }\n \n // FIXME: This only handles ASCII\n-fn to_upper(s: &istr) -> istr {\n-    let outstr = ~\"\";\n+fn to_upper(s: &str) -> str {\n+    let outstr = \"\";\n     let ascii_a = 'a' as u8;\n     let ascii_z = 'z' as u8;\n     let diff = 32u8;\n@@ -384,11 +369,11 @@ fn to_upper(s: &istr) -> istr {\n }\n \n // FIXME: This is super-inefficient\n-fn replace(s: &istr, from: &istr, to: &istr) : is_not_empty(from) -> istr {\n+fn replace(s: &str, from: &str, to: &str) : is_not_empty(from) -> str {\n     // FIXME (694): Shouldn't have to check this\n     check (is_not_empty(from));\n     if byte_len(s) == 0u {\n-        ret ~\"\";\n+        ret \"\";\n     } else if starts_with(s, from) {\n         ret to + replace(slice(s, byte_len(from), byte_len(s)), from, to);\n     } else {\n@@ -398,11 +383,11 @@ fn replace(s: &istr, from: &istr, to: &istr) : is_not_empty(from) -> istr {\n }\n \n // FIXME: Also not efficient\n-fn char_slice(s: &istr, begin: uint, end: uint) -> istr {\n+fn char_slice(s: &str, begin: uint, end: uint) -> str {\n     from_chars(vec::slice(to_chars(s), begin, end))\n }\n \n-fn trim_left(s: &istr) -> istr {\n+fn trim_left(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n         let i = 0u;\n         while i < vec::len(s) {\n@@ -416,7 +401,7 @@ fn trim_left(s: &istr) -> istr {\n     ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n-fn trim_right(s: &istr) -> istr {\n+fn trim_right(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n         let i = vec::len(s);\n         while 0u < i {\n@@ -430,26 +415,21 @@ fn trim_right(s: &istr) -> istr {\n     ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n-fn trim(s: &istr) -> istr {\n-    trim_left(trim_right(s))\n-}\n+fn trim(s: &str) -> str { trim_left(trim_right(s)) }\n \n type sbuf = *u8;\n \n-fn buf(s: &istr) -> sbuf {\n+fn buf(s: &str) -> sbuf {\n     let saddr = ptr::addr_of(s);\n     let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n     let buf = vec::to_ptr(*vaddr);\n     ret buf;\n }\n \n-fn as_buf<T>(s: &istr, f: &block(sbuf) -> T) -> T {\n-    let buf = buf(s);\n-    f(buf)\n-}\n+fn as_buf<T>(s: &str, f: &block(sbuf) -> T) -> T { let buf = buf(s); f(buf) }\n \n-fn str_from_cstr(cstr: sbuf) -> istr {\n-    let res = ~\"\";\n+fn str_from_cstr(cstr: sbuf) -> str {\n+    let res = \"\";\n     let start = cstr;\n     let curr = start;\n     let i = 0u;\n@@ -459,4 +439,4 @@ fn str_from_cstr(cstr: sbuf) -> istr {\n         curr = ptr::offset(start, i);\n     }\n     ret res;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fc7116f58b902c74a9c89fe72556872e2f600cfa", "filename": "src/lib/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -122,7 +122,7 @@ fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n     // set up the task pointer\n     let task_ptr = rust_task_ptr(rustrt::get_task_pointer(id));\n     let regs = ptr::addr_of((**task_ptr).ctx.regs);\n-    (*regs).edx = cast(*task_ptr);\n+    (*regs).edx = cast(*task_ptr);;\n     (*regs).esp = cast((**task_ptr).stack_ptr);\n \n     assert (ptr::null() != (**task_ptr).stack_ptr);"}, {"sha": "cfec5ff6b8feb96947542cbdf24e549be02d2b3b", "filename": "src/lib/term.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -48,10 +48,10 @@ fn reset(writer: io::buf_writer) {\n }\n \n fn color_supported() -> bool {\n-    let supported_terms = [~\"xterm-color\", ~\"xterm\", ~\"screen-bce\"];\n-    ret alt generic_os::getenv(~\"TERM\") {\n+    let supported_terms = [\"xterm-color\", \"xterm\", \"screen-bce\"];\n+    ret alt generic_os::getenv(\"TERM\") {\n           option::some(env) {\n-            for term: istr in supported_terms {\n+            for term: str in supported_terms {\n                 if str::eq(term, env) { ret true; }\n             }\n             false"}, {"sha": "37fec12e9ce59e9b209a0eb94ce06456d2b4cb0f", "filename": "src/lib/test.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -35,7 +35,7 @@ native \"rust\" mod rustrt {\n // paths, i.e it should be a series of identifiers seperated by double\n // colons. This way if some test runner wants to arrange the tests\n // heirarchically it may.\n-type test_name = istr;\n+type test_name = str;\n \n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n@@ -49,7 +49,7 @@ type test_desc = {name: test_name, fn: test_fn, ignore: bool};\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: &[istr], tests: &[test_desc]) {\n+fn test_main(args: &[str], tests: &[test_desc]) {\n     check (vec::is_not_empty(args));\n     let opts =\n         alt parse_opts(args) {\n@@ -59,29 +59,27 @@ fn test_main(args: &[istr], tests: &[test_desc]) {\n     if !run_tests_console(opts, tests) { fail \"Some tests failed\"; }\n }\n \n-type test_opts = {filter: option::t<istr>, run_ignored: bool};\n+type test_opts = {filter: option::t<str>, run_ignored: bool};\n \n-type opt_res = either::t<test_opts, istr>;\n+type opt_res = either::t<test_opts, str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: &[istr]) : vec::is_not_empty(args) -> opt_res {\n+fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n \n     let args_ = vec::tail(args);\n-    let opts = [getopts::optflag(~\"ignored\")];\n+    let opts = [getopts::optflag(\"ignored\")];\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n-          getopts::failure(f) {\n-            ret either::right(getopts::fail_str(f))\n-          }\n+          getopts::failure(f) { ret either::right(getopts::fail_str(f)) }\n         };\n \n     let filter =\n         if vec::len(match.free) > 0u {\n             option::some(match.free[0])\n         } else { option::none };\n \n-    let run_ignored = getopts::opt_present(match, ~\"ignored\");\n+    let run_ignored = getopts::opt_present(match, \"ignored\");\n \n     let test_opts = {filter: filter, run_ignored: run_ignored};\n \n@@ -119,30 +117,26 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n-            st.out.write_line(\n-                #fmt[\"\\nrunning %u tests\", st.total]);\n-          }\n-          te_wait(test) {\n-            st.out.write_str(\n-                #fmt[\"test %s ... \", test.name]);\n+            st.out.write_line(#fmt[\"\\nrunning %u tests\", st.total]);\n           }\n+          te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n           te_result(test, result) {\n             alt result {\n               tr_ok. {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n               }\n               tr_failed. {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n                 st.failures += [test];\n               }\n               tr_ignored. {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n               }\n             }\n           }\n@@ -164,7 +158,7 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n     let success = st.failed == 0u;\n \n     if !success {\n-        st.out.write_line(~\"\\nfailures:\");\n+        st.out.write_line(\"\\nfailures:\");\n         for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n             st.out.write_line(#fmt[\"    %s\", testname]);\n@@ -176,25 +170,24 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n-    st.out.write_str(\n-            #fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+    st.out.write_str(#fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n                           st.failed, st.ignored]);\n \n     ret success;\n \n     fn write_ok(out: &io::writer, use_color: bool) {\n-        write_pretty(out, ~\"ok\", term::color_green, use_color);\n+        write_pretty(out, \"ok\", term::color_green, use_color);\n     }\n \n     fn write_failed(out: &io::writer, use_color: bool) {\n-        write_pretty(out, ~\"FAILED\", term::color_red, use_color);\n+        write_pretty(out, \"FAILED\", term::color_red, use_color);\n     }\n \n     fn write_ignored(out: &io::writer, use_color: bool) {\n-        write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_pretty(out: &io::writer, word: &istr, color: u8,\n+    fn write_pretty(out: &io::writer, word: &str, color: u8,\n                     use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out.get_buf_writer(), color);\n@@ -259,11 +252,11 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n             let filter_str =\n                 alt opts.filter {\n                   option::some(f) { f }\n-                  option::none. { ~\"\" }\n+                  option::none. { \"\" }\n                 };\n \n             let filter =\n-                bind fn (test: &test_desc, filter_str: &istr) ->\n+                bind fn (test: &test_desc, filter_str: &str) ->\n                         option::t<test_desc> {\n                          if str::find(test.name, filter_str) >= 0 {\n                              ret option::some(test);"}, {"sha": "cdf9a67042b154f321593c88737242a621a9598a", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -17,82 +17,49 @@ export insert;\n export find;\n export traverse;\n \n-tag tree_node<@K, @V> {\n-    empty;\n-    node(@K, @V, treemap<K, V>, treemap<K, V>);\n-}\n+tag tree_node<@K, @V> { empty; node(@K, @V, treemap<K, V>, treemap<K, V>); }\n \n type treemap<@K, @V> = @mutable tree_node<K, V>;\n \n-fn init<@K, @V>() -> treemap<K,V> { @mutable empty }\n+fn init<@K, @V>() -> treemap<K, V> { @mutable empty }\n \n-fn insert<@K, @V>(m : &treemap<K, V>, k : &K, v : &V) {\n+fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) {\n     alt m {\n-      @empty. {\n-        *m = node(@k, @v, @mutable empty, @mutable empty);\n-      }\n+      @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n       @node(@kk, _, _, _) {\n+\n         // We have to name left and right individually, because\n         // otherwise the alias checker complains.\n         if k < kk {\n-            alt m {\n-              @node(_, _, left, _) {\n-                insert(left, k, v);\n-              }\n-            }\n-        }\n-        else {\n-            alt m {\n-              @node(_, _, _, right) {\n-                insert(right, k, v);\n-              }\n-            }\n-        }\n+            alt m { @node(_, _, left, _) { insert(left, k, v); } }\n+        } else { alt m { @node(_, _, _, right) { insert(right, k, v); } } }\n       }\n     }\n }\n \n-fn find<@K, @V>(m : &treemap<K, V>, k : &K) -> option<V> {\n-  alt *m {\n-    empty. { none }\n-    node(@kk, @v, _, _) {\n-      if k == kk { some(v) }\n-      // Again, ugliness to unpack left and right individually.\n-      else if k < kk {\n-          alt *m {\n-            node(_, _, left, _) {\n-              find(left, k)\n-            }\n-          }\n-      }\n-      else {\n-          alt *m {\n-            node(_, _, _, right) {\n-              find(right, k)\n-            }\n-          }\n+fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n+    alt *m {\n+      empty. { none }\n+      node(@kk, @v, _, _) {\n+        if k == kk {\n+            some(v)\n+        } else if k < kk {\n+            // Again, ugliness to unpack left and right individually.\n+            alt *m { node(_, _, left, _) { find(left, k) } }\n+        } else { alt *m { node(_, _, _, right) { find(right, k) } } }\n       }\n     }\n-  }\n }\n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m : &treemap<K, V>, f : fn(&K, &V)) {\n-  alt *m {\n-    empty. { }\n-    node(k, v, _, _) {\n-      let k1 = k, v1 = v;\n-      alt *m {\n-        node(_, _, left, _) {\n-          traverse(left, f);\n-        }\n-      }\n-      f(*k1, *v1);\n-      alt *m {\n-        node(_, _, _, right) {\n-          traverse(right, f);\n-        }\n+fn traverse<@K, @V>(m: &treemap<K, V>, f: fn(&K, &V)) {\n+    alt *m {\n+      empty. { }\n+      node(k, v, _, _) {\n+        let k1 = k, v1 = v;\n+        alt *m { node(_, _, left, _) { traverse(left, f); } }\n+        f(*k1, *v1);\n+        alt *m { node(_, _, _, right) { traverse(right, f); } }\n       }\n     }\n-  }\n }"}, {"sha": "8082f7aef0d527805ca31c647bb53c8ccfc096fe", "filename": "src/lib/u64.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu64.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,36 +1,36 @@\n-fn to_str(n: u64, radix: uint) -> istr {\n+fn to_str(n: u64, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n \n     let r64 = radix as u64;\n \n-    fn digit(n: u64) -> istr {\n+    fn digit(n: u64) -> str {\n         ret alt n {\n-              0u64 { ~\"0\" }\n-              1u64 { ~\"1\" }\n-              2u64 { ~\"2\" }\n-              3u64 { ~\"3\" }\n-              4u64 { ~\"4\" }\n-              5u64 { ~\"5\" }\n-              6u64 { ~\"6\" }\n-              7u64 { ~\"7\" }\n-              8u64 { ~\"8\" }\n-              9u64 { ~\"9\" }\n-              10u64 { ~\"a\" }\n-              11u64 { ~\"b\" }\n-              12u64 { ~\"c\" }\n-              13u64 { ~\"d\" }\n-              14u64 { ~\"e\" }\n-              15u64 { ~\"f\" }\n+              0u64 { \"0\" }\n+              1u64 { \"1\" }\n+              2u64 { \"2\" }\n+              3u64 { \"3\" }\n+              4u64 { \"4\" }\n+              5u64 { \"5\" }\n+              6u64 { \"6\" }\n+              7u64 { \"7\" }\n+              8u64 { \"8\" }\n+              9u64 { \"9\" }\n+              10u64 { \"a\" }\n+              11u64 { \"b\" }\n+              12u64 { \"c\" }\n+              13u64 { \"d\" }\n+              14u64 { \"e\" }\n+              15u64 { \"f\" }\n               _ { fail }\n             };\n     }\n \n-    if n == 0u64 { ret ~\"0\"; }\n+    if n == 0u64 { ret \"0\"; }\n \n-    let s = ~\"\";\n+    let s = \"\";\n \n     while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n     ret s;\n }\n \n-fn str(n: u64) -> istr { ret to_str(n, 10u); }\n+fn str(n: u64) -> str { ret to_str(n, 10u); }"}, {"sha": "3553dc7e2cf870ca912d8ccbdfe227415a189e14", "filename": "src/lib/uint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -56,9 +56,9 @@ fn parse_buf(buf: &[u8], radix: uint) -> uint {\n     fail;\n }\n \n-fn from_str(s: &istr) -> uint { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: &str) -> uint { parse_buf(str::bytes(s), 10u) }\n \n-fn to_str(num: uint, radix: uint) -> istr {\n+fn to_str(num: uint, radix: uint) -> str {\n     let n = num;\n     assert (0u < radix && radix <= 16u);\n     fn digit(n: uint) -> char {\n@@ -82,18 +82,18 @@ fn to_str(num: uint, radix: uint) -> istr {\n               _ { fail }\n             };\n     }\n-    if n == 0u { ret ~\"0\"; }\n-    let s: istr = ~\"\";\n+    if n == 0u { ret \"0\"; }\n+    let s: str = \"\";\n     while n != 0u {\n         s += str::unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n-    let s1: istr = ~\"\";\n+    let s1: str = \"\";\n     let len: uint = str::byte_len(s);\n     while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n     ret s1;\n }\n-fn str(i: uint) -> istr { ret to_str(i, 10u); }\n+fn str(i: uint) -> str { ret to_str(i, 10u); }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "79e409d27fc636a85a7ca7ea22b67dac7c0805b7", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -11,6 +11,4 @@ native \"rust\" mod rustrt {\n // Casts the value at `src` to U. The two types must have the same length.\n fn reinterpret_cast<T, @U>(src: &T) -> U { ret rusti::cast(src); }\n \n-fn leak<@T>(thing: -T) {\n-    rustrt::leak(thing);\n-}\n\\ No newline at end of file\n+fn leak<@T>(thing: -T) { rustrt::leak(thing); }"}, {"sha": "1ec736c6e876c9364404091b039e0a765c18c59e", "filename": "src/lib/vec.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -262,8 +262,8 @@ fn position_pred<T>(f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n }\n \n pure fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n-    let xlen = unchecked { vec::len(xs) };\n-    let ylen = unchecked { vec::len(ys) };\n+    let xlen = unchecked{ vec::len(xs) };\n+    let ylen = unchecked{ vec::len(ys) };\n     xlen == ylen\n }\n \n@@ -311,39 +311,28 @@ fn reversed<@T>(v: &[T]) -> [T] {\n }\n \n // Generating vecs.\n-fn enum_chars(start:u8, end:u8) : u8::le(start, end) -> [char] {\n+fn enum_chars(start: u8, end: u8) : u8::le(start, end) -> [char] {\n     let i = start;\n     let r = [];\n-    while (i <= end) {\n-        r += [i as char];\n-        i += (1u as u8);\n-    }\n+    while i <= end { r += [i as char]; i += 1u as u8; }\n     ret r;\n }\n \n-fn enum_uints(start:uint, end:uint) : uint::le(start, end) -> [uint] {\n+fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n     let i = start;\n     let r = [];\n-    while (i <= end) {\n-        r += [i];\n-        i += 1u;\n-    }\n+    while i <= end { r += [i]; i += 1u; }\n     ret r;\n }\n \n // Iterate over a list with with the indexes\n iter iter2<@T>(v: &[T]) -> (uint, T) {\n     let i = 0u;\n-    for x in v {\n-        put (i, x);\n-        i += 1u;\n-    }\n+    for x in v { put (i, x); i += 1u; }\n }\n \n mod unsafe {\n-    type vec_repr = {mutable fill: uint,\n-                     mutable alloc: uint,\n-                     data: u8};\n+    type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n \n     fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n         ret rustrt::vec_from_buf_shared(ptr, elts);\n@@ -360,9 +349,7 @@ mod unsafe {\n     }\n }\n \n-fn to_ptr<T>(v: &[T]) -> *T {\n-    ret unsafe::to_ptr(v);\n-}\n+fn to_ptr<T>(v: &[T]) -> *T { ret unsafe::to_ptr(v); }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "8052d0280fe22dce3b2f45fb8d06986dde229431", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,16 +1,16 @@\n \n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: &istr) -> [istr];\n+    fn rust_list_files(path: &str) -> [str];\n     fn rust_file_is_dir(path: str) -> int;\n }\n \n-fn list_dir(path: &istr) -> [istr] {\n-    let path = path + ~\"*\";\n+fn list_dir(path: &str) -> [str] {\n+    let path = path + \"*\";\n     ret rustrt::rust_list_files(path);\n }\n \n-fn path_is_absolute(p: &istr) -> bool {\n+fn path_is_absolute(p: &str) -> bool {\n     ret str::char_at(p, 0u) == '/' ||\n             str::char_at(p, 1u) == ':' && str::char_at(p, 2u) == '\\\\';\n }"}, {"sha": "bf94439099f744c1232c3abd2c8321f47caa5dc2", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -40,16 +40,16 @@ mod libc_constants {\n }\n \n native \"x86stdcall\" mod kernel32 {\n-    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf,\n-                               nsize: uint) -> uint;\n+    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf, nsize: uint) ->\n+       uint;\n     fn SetEnvironmentVariableA(n: str::sbuf, v: str::sbuf) -> int;\n }\n \n-fn exec_suffix() -> istr { ret ~\".exe\"; }\n+fn exec_suffix() -> str { ret \".exe\"; }\n \n-fn target_os() -> istr { ret ~\"win32\"; }\n+fn target_os() -> str { ret \"win32\"; }\n \n-fn dylib_filename(base: &istr) -> istr { ret base + ~\".dll\"; }\n+fn dylib_filename(base: &str) -> str { ret base + \".dll\"; }\n \n fn pipe() -> {in: int, out: int} {\n     // Windows pipes work subtly differently than unix pipes, and their\n@@ -69,21 +69,17 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret str::as_buf(~\"r\", { |modebuf|\n-        libc::_fdopen(fd, modebuf)\n-    });\n+    ret str::as_buf(\"r\", {|modebuf| libc::_fdopen(fd, modebuf) });\n }\n \n native \"rust\" mod rustrt {\n     fn rust_process_wait(handle: int) -> int;\n-    fn rust_getcwd() -> istr;\n+    fn rust_getcwd() -> str;\n }\n \n fn waitpid(pid: int) -> int { ret rustrt::rust_process_wait(pid); }\n \n-fn getcwd() -> istr {\n-    ret rustrt::rust_getcwd();\n-}\n+fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "6d9243b8558c05c07fd4ee2c81149d4227e6e8e8", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -43,10 +43,10 @@ command_line_args : public kernel_owned<command_line_args>\n                            \"command line arg interior\");\n         args->fill = args->alloc = sizeof(rust_vec*) * argc;\n         for (int i = 0; i < argc; ++i) {\n-            rust_vec *str = make_istr(kernel, argv[i],\n-                                      strlen(argv[i]),\n-                                      \"command line arg\");\n-            ((rust_vec**)&args->data)[i] = str;\n+            rust_str *str = make_str(kernel, argv[i],\n+                                     strlen(argv[i]),\n+                                     \"command line arg\");\n+            ((rust_str**)&args->data)[i] = str;\n         }\n     }\n \n@@ -66,12 +66,6 @@ command_line_args : public kernel_owned<command_line_args>\n     }\n };\n \n-\n-// FIXME: Transitional. Please remove.\n-extern \"C\" CDECL void\n-set_main_takes_istr(uintptr_t flag) {\n-}\n-\n /**\n  * Main entry point into the Rust runtime. Here we create a Rust service,\n  * initialize the kernel, create the root domain and run it."}, {"sha": "f8fc85a0fe1586ed7d9b8b459cb2b1a83c9a4ccf", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,7 +7,7 @@\n \n /* Native builtins. */\n \n-extern \"C\" CDECL rust_vec*\n+extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n     LOG(task, task, \"last_os_error()\");\n \n@@ -40,15 +40,15 @@ last_os_error(rust_task *task) {\n     }\n #endif\n \n-    rust_vec * st = make_istr(task->kernel, buf, strlen(buf),\n-                              \"last_os_error\");\n+    rust_str * st = make_str(task->kernel, buf, strlen(buf),\n+                             \"last_os_error\");\n #ifdef __WIN32__\n     LocalFree((HLOCAL)buf);\n #endif\n     return st;\n }\n \n-extern \"C\" CDECL rust_vec *\n+extern \"C\" CDECL rust_str *\n rust_getcwd(rust_task *task) {\n     LOG(task, task, \"rust_getcwd()\");\n \n@@ -63,7 +63,7 @@ rust_getcwd(rust_task *task) {\n         return NULL;\n     }\n \n-    return make_istr(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd\");\n+    return make_str(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd\");\n }\n \n extern \"C\" CDECL\n@@ -127,7 +127,7 @@ vec_from_buf_shared(rust_task *task, type_desc *ty,\n }\n \n extern \"C\" CDECL void\n-rust_istr_push(rust_task* task, rust_vec** sp, uint8_t byte) {\n+rust_str_push(rust_task* task, rust_vec** sp, uint8_t byte) {\n     size_t fill = (*sp)->fill;\n     reserve_vec(task, sp, fill + 1);\n     (*sp)->data[fill-1] = byte;\n@@ -323,15 +323,15 @@ debug_ptrcast(rust_task *task,\n \n extern \"C\" CDECL rust_vec*\n rust_list_files(rust_task *task, rust_vec **path) {\n-    array_list<rust_vec*> strings;\n+    array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n     HANDLE hFind = FindFirstFile((char*)(*path)->data, &FindFileData);\n     if (hFind != INVALID_HANDLE_VALUE) {\n         do {\n-            rust_vec *str = make_istr(task->kernel, FindFileData.cFileName,\n-                                      strlen(FindFileData.cFileName),\n-                                      \"list_files_str\");\n+            rust_str *str = make_str(task->kernel, FindFileData.cFileName,\n+                                     strlen(FindFileData.cFileName),\n+                                     \"list_files_str\");\n             strings.push(str);\n         } while (FindNextFile(hFind, &FindFileData));\n         FindClose(hFind);\n@@ -341,7 +341,7 @@ rust_list_files(rust_task *task, rust_vec **path) {\n   if (dirp) {\n       struct dirent *dp;\n       while ((dp = readdir(dirp))) {\n-          rust_vec *str = make_istr(task->kernel, dp->d_name,\n+          rust_vec *str = make_str(task->kernel, dp->d_name,\n                                     strlen(dp->d_name),\n                                     \"list_files_str\");\n           strings.push(str);"}, {"sha": "662dbe9429af5a2dba99388aa9ed788c2961e8f0", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,10 +4,6 @@\n \n // Upcalls.\n \n-// FIXME: Transitional. Please remove\n-extern \"C\" CDECL char const *\n-str_buf(rust_task *task, void *s) { return NULL; }\n-\n #ifdef __i386__\n void\n check_stack(rust_task *task) {"}, {"sha": "50545b2131025f6dc810a56f4552bdb3b33fd72f", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -188,11 +188,13 @@ inline void reserve_vec(rust_task* task, rust_vec** vpp, size_t size) {\n     }\n }\n \n-inline rust_vec *\n-make_istr(rust_kernel* kernel, char* c, size_t strlen, const char* name) {\n+typedef rust_vec rust_str;\n+\n+inline rust_str *\n+make_str(rust_kernel* kernel, char* c, size_t strlen, const char* name) {\n     size_t str_fill = strlen + 1;\n     size_t str_alloc = str_fill;\n-    rust_vec *str = (rust_vec *)\n+    rust_str *str = (rust_str *)\n         kernel->malloc(vec_size<char>(str_fill), name);\n     str->fill = str_fill;\n     str->alloc = str_alloc;"}, {"sha": "56728c85985ce56e9e637fbf5137e8e9d25e88ea", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -47,20 +47,18 @@ rust_file_is_dir\n rust_get_stdin\n rust_get_stdout\n rust_get_stderr\n-rust_istr_push\n+rust_str_push\n rust_list_files\n rust_process_wait\n rust_ptr_eq\n rust_run_program\n rust_start\n rust_getcwd\n-set_main_takes_istr\n set_min_stack\n sched_threads\n size_of\n squareroot\n start_task\n-str_buf\n vec_reserve_shared\n vec_from_buf_shared\n task_sleep"}, {"sha": "fed4177e4659804cf8d4d01b5321d13c04acf518", "filename": "src/snapshots.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,8 @@\n+S 2011-09-02 1b67d21\n+  linux-i386 121ceb51d20ae5d10aded3f16a722f203af9e8b2\n+  macos-i386 49208265ecac4692699e55d7275dda97ab4d6872\n+  winnt-i386 edccc79edd5027e7bb8e794b1d15ff6709b3bd31\n+\n S 2011-09-01 6972f07\n   linux-i386 fbc5cd318fe1914663729bb07dd9ce125d95ec4e\n   macos-i386 e494a708408bc54e31ce009e78fb690a2f0b4d42"}, {"sha": "a1a3e1b984a5768b07cd371b5be211b46b835b81", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,28 +8,28 @@ use std;\n import std::int;\n import std::str;\n \n-fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n+fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n \n-fn b2() -> istr {\n-    ret ~\"Take one down and pass it around, # of beer on the wall.\";\n+fn b2() -> str {\n+    ret \"Take one down and pass it around, # of beer on the wall.\";\n }\n \n-fn b7() -> istr {\n-    ret ~\"No more bottles of beer on the wall, no more bottles of beer.\";\n+fn b7() -> str {\n+    ret \"No more bottles of beer on the wall, no more bottles of beer.\";\n }\n \n-fn b8() -> istr {\n-    ret ~\"Go to the store and buy some more, # of beer on the wall.\";\n+fn b8() -> str {\n+    ret \"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: &istr, n: int) -> istr {\n-    let b: istr = ~\"\";\n+fn sub(t: &str, n: int) -> str {\n+    let b: str = \"\";\n     let i: uint = 0u;\n-    let ns: istr;\n+    let ns: str;\n     alt n {\n-      0 { ns = ~\"no more bottles\"; }\n-      1 { ns = ~\"1 bottle\"; }\n-      _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n+      0 { ns = \"no more bottles\"; }\n+      1 { ns = \"1 bottle\"; }\n+      _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n     while i < str::byte_len(t) {\n         if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }"}, {"sha": "fdfce9dfae520711c735147491022ad44ef8ace6", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,12 +29,11 @@ fn show(b: bottle) {\n                 \"1 bottle of beer on the wall.\";\n       }\n       multiple(n) {\n-        let nb: istr = int::to_str(n, 10u);\n-        let mb: istr = int::to_str(n - 1, 10u);\n-        log nb + ~\" bottles of beer on the wall, \" + nb +\n-            ~\" bottles of beer,\";\n-        log ~\"Take one down and pass it around, \" + mb +\n-                ~\" bottles of beer on the wall.\";\n+        let nb: str = int::to_str(n, 10u);\n+        let mb: str = int::to_str(n - 1, 10u);\n+        log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n+        log \"Take one down and pass it around, \" + mb +\n+                \" bottles of beer on the wall.\";\n       }\n     }\n }"}, {"sha": "ae1c30fb9ec1f3b9e3541dfae15a764bb6a8c04a", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,28 +8,28 @@ use std;\n import std::int;\n import std::str;\n \n-fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n+fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n \n-fn b2() -> istr {\n-    ret ~\"Take one down and pass it around, # of beer on the wall.\";\n+fn b2() -> str {\n+    ret \"Take one down and pass it around, # of beer on the wall.\";\n }\n \n-fn b7() -> istr {\n-    ret ~\"No more bottles of beer on the wall, no more bottles of beer.\";\n+fn b7() -> str {\n+    ret \"No more bottles of beer on the wall, no more bottles of beer.\";\n }\n \n-fn b8() -> istr {\n-    ret ~\"Go to the store and buy some more, # of beer on the wall.\";\n+fn b8() -> str {\n+    ret \"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: &istr, n: int) -> istr {\n-    let b: istr = ~\"\";\n+fn sub(t: &str, n: int) -> str {\n+    let b: str = \"\";\n     let i: uint = 0u;\n-    let ns: istr;\n+    let ns: str;\n     alt n {\n-      0 { ns = ~\"no more bottles\"; }\n-      1 { ns = ~\"1 bottle\"; }\n-      _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n+      0 { ns = \"no more bottles\"; }\n+      1 { ns = \"1 bottle\"; }\n+      _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n     while i < str::byte_len(t) {\n         if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }"}, {"sha": "af5e22f48ea81443a531cc0214f4d0787fc9b97d", "filename": "src/test/bench/99bob-tail.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,12 +8,11 @@ import std::str;\n \n fn main() {\n     fn multiple(n: int) {\n-        let nb: istr = int::to_str(n, 10u);\n-        let mb: istr = int::to_str(n - 1, 10u);\n-        log nb + ~\" bottles of beer on the wall, \" + nb +\n-            ~\" bottles of beer,\";\n-        log ~\"Take one down and pass it around, \" + mb +\n-            ~\" bottles of beer on the wall.\";\n+        let nb: str = int::to_str(n, 10u);\n+        let mb: str = int::to_str(n - 1, 10u);\n+        log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n+        log \"Take one down and pass it around, \" + mb +\n+                \" bottles of beer on the wall.\";\n         log \"\";\n         if n > 3 { be multiple(n - 1); } else { be dual(); }\n     }"}, {"sha": "8e7b2cbe269d933198b5bfc442f6ef7558fc68c2", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -56,7 +56,7 @@ fn fannkuch(n: int) -> int {\n     ret flips;\n }\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     let n = 7;\n     log #fmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n }"}, {"sha": "99b06a984168ee690d01e8ceb0f3dda1e19f0b34", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -43,32 +43,31 @@ fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n     ret bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n \n-fn make_random_fasta(id: &istr, desc: &istr,\n-                     genelist: &[aminoacids], n: int) {\n-    log ~\">\" + id + ~\" \" + desc;\n+fn make_random_fasta(id: &str, desc: &str, genelist: &[aminoacids], n: int) {\n+    log \">\" + id + \" \" + desc;\n     let rng = myrandom(std::rand::mk_rng().next());\n-    let op: istr = ~\"\";\n+    let op: str = \"\";\n     for each i: uint in uint::range(0u, n as uint) {\n         str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-        if str::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n+        if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n     }\n     if str::byte_len(op) > 0u { log op; }\n }\n \n-fn make_repeat_fasta(id: &istr, desc: &istr, s: &istr, n: int) {\n-    log ~\">\" + id + ~\" \" + desc;\n-    let op: istr = ~\"\";\n+fn make_repeat_fasta(id: &str, desc: &str, s: &str, n: int) {\n+    log \">\" + id + \" \" + desc;\n+    let op: str = \"\";\n     let sl: uint = str::byte_len(s);\n     for each i: uint in uint::range(0u, n as uint) {\n         str::push_byte(op, s[i % sl]);\n-        if str::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n+        if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n     }\n     if str::byte_len(op) > 0u { log op; }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     let iub: [aminoacids] =\n         make_cumulative([acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),\n                          acid('t', 27u32), acid('B', 2u32), acid('D', 2u32),\n@@ -78,17 +77,16 @@ fn main(args: [istr]) {\n     let homosapiens: [aminoacids] =\n         make_cumulative([acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n                          acid('t', 30u32)]);\n-    let alu: istr =\n-        ~\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n-            ~\"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +\n-            ~\"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\" +\n-            ~\"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\" +\n-            ~\"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n-            ~\"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n-            ~\"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+    let alu: str =\n+        \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n+            \"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +\n+            \"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\" +\n+            \"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\" +\n+            \"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n+            \"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n+            \"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n     let n: int = 512;\n-    make_repeat_fasta(~\"ONE\", ~\"Homo sapiens alu\", alu, n * 2);\n-    make_random_fasta(~\"TWO\", ~\"IUB ambiguity codes\", iub, n * 3);\n-    make_random_fasta(~\"THREE\", ~\"Homo sapiens frequency\",\n-                      homosapiens, n * 5);\n+    make_repeat_fasta(\"ONE\", \"Homo sapiens alu\", alu, n * 2);\n+    make_random_fasta(\"TWO\", \"IUB ambiguity codes\", iub, n * 3);\n+    make_random_fasta(\"THREE\", \"Homo sapiens frequency\", homosapiens, n * 5);\n }"}, {"sha": "9551aa6b9825dc4bbedc4c7d1c98c4a1480683cc", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -49,14 +49,14 @@ fn fib(n: int) -> int {\n \n type config = {stress: bool};\n \n-fn parse_opts(argv: &[istr]) -> config {\n-    let opts = [getopts::optflag(~\"stress\")];\n+fn parse_opts(argv: &[str]) -> config {\n+    let opts = [getopts::optflag(\"stress\")];\n \n     let opt_args = vec::slice(argv, 1u, vec::len(argv));\n \n \n     alt getopts::getopts(opt_args, opts) {\n-      getopts::success(m) { ret {stress: getopts::opt_present(m, ~\"stress\")} }\n+      getopts::success(m) { ret {stress: getopts::opt_present(m, \"stress\")} }\n       getopts::failure(_) { fail; }\n     }\n }\n@@ -79,7 +79,7 @@ fn stress(num_tasks: int) {\n     for t in tasks { task::join(t); }\n }\n \n-fn main(argv: [istr]) {\n+fn main(argv: [str]) {\n     if vec::len(argv) == 1u {\n         assert (fib(8) == 21);\n         log fib(8);\n@@ -105,9 +105,8 @@ fn main(argv: [istr]) {\n \n                     let elapsed = stop - start;\n \n-                    out.write_line(\n-                            #fmt[\"%d\\t%d\\t%s\", n, fibn,\n-                                 u64::str(elapsed)]);\n+                    out.write_line(#fmt[\"%d\\t%d\\t%s\", n, fibn,\n+                                        u64::str(elapsed)]);\n                 }\n             }\n         }"}, {"sha": "ebe1abc493b3e8514409523bb6d4cff67cc9d175", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,12 +8,14 @@ fn f(n: uint) {\n     let i = 0u;\n     while i < n {\n         let thunk = g;\n-        task::join(task::spawn_joinable(thunk)); i += 1u; }\n+        task::join(task::spawn_joinable(thunk));\n+        i += 1u;\n+    }\n }\n \n fn g() { }\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     let n =\n         if vec::len(args) < 2u {\n             10u"}, {"sha": "b70bd24828a17c251295acd1ef219779b712c96d", "filename": "src/test/bench/task-perf-vector-party.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -16,13 +16,10 @@ fn f(n: uint) {\n     }\n }\n \n-fn main(args: [istr]) {\n-    let n = if vec::len(args) < 2u {\n-        100u\n-    } else {\n-        uint::parse_buf(str::bytes(args[1]), 10u)\n-    };\n-    for each i in uint::range(0u, 100u) {\n-        task::spawn(bind f(n));\n-    }\n-}\n\\ No newline at end of file\n+fn main(args: [str]) {\n+    let n =\n+        if vec::len(args) < 2u {\n+            100u\n+        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n+    for each i in uint::range(0u, 100u) { task::spawn(bind f(n)); }\n+}"}, {"sha": "adb5040fa256a6c565a5736e5d6efb2bff60335a", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -70,9 +70,10 @@ mod map_reduce {\n \n     tag reduce_proto<~V> { emit_val(V); done; ref; release; }\n \n-    fn start_mappers<~K1, ~K2, ~V>(map : mapper<K1, K2, V>,\n-                             ctrl: chan<ctrl_proto<K2, V>>, inputs: &[K1])\n-        -> [joinable_task] {\n+    fn start_mappers<~K1, ~K2,\n+                     ~V>(map: mapper<K1, K2, V>,\n+                         ctrl: chan<ctrl_proto<K2, V>>, inputs: &[K1]) ->\n+       [joinable_task] {\n         let tasks = [];\n         for i in inputs {\n             let m = map, c = ctrl, ii = i;\n@@ -81,18 +82,18 @@ mod map_reduce {\n         ret tasks;\n     }\n \n-    fn map_task<~K1, ~K2, ~V>(map : -mapper<K1,K2,V>,\n-                              ctrl: -chan<ctrl_proto<K2,V>>, input: -K1) {\n+    fn map_task<~K1, ~K2,\n+                ~V>(map: -mapper<K1, K2, V>, ctrl: -chan<ctrl_proto<K2, V>>,\n+                    input: -K1) {\n         // log_err \"map_task \" + input;\n         let intermediates = treemap::init();\n \n-        fn emit<~K2, ~V>(im: &treemap::treemap<K2, chan<reduce_proto<V>>>,\n-                         ctrl: &chan<ctrl_proto<K2,V>>, key: &K2, val: &V) {\n+        fn emit<~K2,\n+                ~V>(im: &treemap::treemap<K2, chan<reduce_proto<V>>>,\n+                    ctrl: &chan<ctrl_proto<K2, V>>, key: &K2, val: &V) {\n             let c;\n             alt treemap::find(im, key) {\n-              some(_c) {\n-                c = _c\n-              }\n+              some(_c) { c = _c }\n               none. {\n                 let p = port();\n                 send(ctrl, find_reducer(key, chan(p)));\n@@ -106,15 +107,16 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        fn finish<~K, ~V>(k : &K, v : &chan<reduce_proto<V>>) {\n+        fn finish<~K, ~V>(k: &K, v: &chan<reduce_proto<V>>) {\n             send(v, release);\n         }\n         treemap::traverse(intermediates, finish);\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task<~K, ~V>(reduce : -reducer<K,V>,\n-                           key: -K, out: -chan<chan<reduce_proto<V>>>) {\n+    fn reduce_task<~K,\n+                   ~V>(reduce: -reducer<K, V>, key: -K,\n+                       out: -chan<chan<reduce_proto<V>>>) {\n         let p = port();\n \n         send(out, chan(p));\n@@ -123,7 +125,7 @@ mod map_reduce {\n         let is_done = false;\n \n         fn get<~V>(p: &port<reduce_proto<V>>, ref_count: &mutable int,\n-               is_done: &mutable bool) -> option<V> {\n+                   is_done: &mutable bool) -> option<V> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n@@ -144,9 +146,9 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce<~K1, ~K2, ~V>(map : mapper<K1,K2,V>,\n-                               reduce : reducer<K2, V>,\n-                               inputs: &[K1]) {\n+    fn map_reduce<~K1, ~K2,\n+                  ~V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n+                      inputs: &[K1]) {\n         let ctrl = port();\n \n         // This task becomes the master control task. It task::_spawns\n@@ -177,8 +179,8 @@ mod map_reduce {\n                     let p = port();\n                     let r = reduce, kk = k;\n                     tasks +=\n-                        [task::spawn_joinable(bind reduce_task(r,\n-                                                               kk, chan(p)))];\n+                        [task::spawn_joinable(bind reduce_task(r, kk,\n+                                                               chan(p)))];\n                     c = recv(p);\n                     treemap::insert(reducers, k, c);\n                   }\n@@ -188,21 +190,18 @@ mod map_reduce {\n             }\n         }\n \n-        fn finish<~K, ~V>(k : &K, v : &chan<reduce_proto<V>>) {\n-            send(v, done);\n-        }\n+        fn finish<~K, ~V>(k: &K, v: &chan<reduce_proto<V>>) { send(v, done); }\n         treemap::traverse(reducers, finish);\n \n         for t in tasks { task::join(t); }\n     }\n }\n \n-fn main(argv: [istr]) {\n+fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(\n-            #fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program.\n@@ -227,20 +226,19 @@ fn main(argv: [istr]) {\n     let elapsed = stop - start;\n     elapsed /= 1000000u64;\n \n-    log_err ~\"MapReduce completed in \" +\n-        u64::str(elapsed) + ~\"ms\";\n+    log_err \"MapReduce completed in \" + u64::str(elapsed) + \"ms\";\n }\n \n-fn read_word(r: io::reader) -> option<istr> {\n-    let w = ~\"\";\n+fn read_word(r: io::reader) -> option<str> {\n+    let w = \"\";\n \n     while !r.eof() {\n         let c = r.read_char();\n \n \n         if is_word_char(c) {\n             w += str::from_char(c);\n-        } else { if w != ~\"\" { ret some(w); } }\n+        } else { if w != \"\" { ret some(w); } }\n     }\n     ret none;\n }"}, {"sha": "a90abd9e5264a778091cfdbcd0495dd2f746ff8d", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -29,7 +29,7 @@ import std::comm::port;\n import std::comm::recv;\n import std::comm::send;\n \n-fn map(filename: &istr, emit: map_reduce::putter) {\n+fn map(filename: &str, emit: map_reduce::putter) {\n     let f = io::file_reader(filename);\n \n \n@@ -38,7 +38,7 @@ fn map(filename: &istr, emit: map_reduce::putter) {\n     }\n }\n \n-fn reduce(word: &istr, get: map_reduce::getter) {\n+fn reduce(word: &str, get: map_reduce::getter) {\n     let count = 0;\n \n \n@@ -52,36 +52,36 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter = fn(&istr, int);\n+    type putter = fn(&str, int);\n \n-    type mapper = fn(&istr, putter);\n+    type mapper = fn(&str, putter);\n \n     type getter = fn() -> option<int>;\n \n-    type reducer = fn(&istr, getter);\n+    type reducer = fn(&str, getter);\n \n     tag ctrl_proto {\n-        find_reducer(istr, chan<chan<reduce_proto>>);\n+        find_reducer(str, chan<chan<reduce_proto>>);\n         mapper_done;\n     }\n \n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[istr])\n-        -> [joinable_task] {\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str]) ->\n+       [joinable_task] {\n         let tasks = [];\n-        for i: istr in inputs {\n+        for i: str in inputs {\n             tasks += [task::spawn_joinable(bind map_task(ctrl, i))];\n         }\n         ret tasks;\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: &istr) {\n+    fn map_task(ctrl: chan<ctrl_proto>, input: &str) {\n         // log_err \"map_task \" + input;\n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<istr, chan<reduce_proto>>,\n-                ctrl: chan<ctrl_proto>, key: &istr, val: int) {\n+        fn emit(im: &map::hashmap<str, chan<reduce_proto>>,\n+                ctrl: chan<ctrl_proto>, key: &str, val: int) {\n             let c;\n             alt im.find(key) {\n               some(_c) {\n@@ -101,15 +101,15 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        for each kv: @{key: istr, val: chan<reduce_proto>} in\n+        for each kv: @{key: str, val: chan<reduce_proto>} in\n                  intermediates.items() {\n             send(kv.val, release);\n         }\n \n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task(key: &istr, out: chan<chan<reduce_proto>>) {\n+    fn reduce_task(key: &str, out: chan<chan<reduce_proto>>) {\n         let p = port();\n \n         send(out, chan(p));\n@@ -139,13 +139,13 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce(inputs: &[istr]) {\n+    fn map_reduce(inputs: &[str]) {\n         let ctrl = port::<ctrl_proto>();\n \n         // This task becomes the master control task. It task::_spawns\n         // to do the rest.\n \n-        let reducers: map::hashmap<istr, chan<reduce_proto>>;\n+        let reducers: map::hashmap<str, chan<reduce_proto>>;\n \n         reducers = map::new_str_hash();\n \n@@ -171,8 +171,7 @@ mod map_reduce {\n                     // log_err \"creating new reducer for \" + k;\n                     let p = port();\n                     tasks +=\n-                        [task::spawn_joinable(\n-                            bind reduce_task(k, chan(p)))];\n+                        [task::spawn_joinable(bind reduce_task(k, chan(p)))];\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }\n@@ -182,7 +181,7 @@ mod map_reduce {\n             }\n         }\n \n-        for each kv: @{key: istr, val: chan<reduce_proto>} in reducers.items()\n+        for each kv: @{key: str, val: chan<reduce_proto>} in reducers.items()\n                  {\n             send(kv.val, done);\n         }\n@@ -191,12 +190,11 @@ mod map_reduce {\n     }\n }\n \n-fn main(argv: [istr]) {\n+fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(\n-            #fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program.\n@@ -216,19 +214,19 @@ fn main(argv: [istr]) {\n     let elapsed = stop - start;\n     elapsed /= 1000000u64;\n \n-    log_err ~\"MapReduce completed in \" + u64::str(elapsed) + ~\"ms\";\n+    log_err \"MapReduce completed in \" + u64::str(elapsed) + \"ms\";\n }\n \n-fn read_word(r: io::reader) -> option<istr> {\n-    let w = ~\"\";\n+fn read_word(r: io::reader) -> option<str> {\n+    let w = \"\";\n \n     while !r.eof() {\n         let c = r.read_char();\n \n \n         if is_word_char(c) {\n             w += str::from_char(c);\n-        } else { if w != ~\"\" { ret some(w); } }\n+        } else { if w != \"\" { ret some(w); } }\n     }\n     ret none;\n }"}, {"sha": "7c97308c5387c8d06a35feae7dfbebfcbe0f1ae1", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,4 +2,4 @@\n \n mod m1 { }\n \n-fn main(args: [istr]) { log m1::a; }\n+fn main(args: [str]) { log m1::a; }"}, {"sha": "e6596f17b6e05a55530d87a0ad83070fbe3de820", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,4 +4,4 @@ mod m1 {\n     mod a { }\n }\n \n-fn main(args: [istr]) { log m1::a; }\n+fn main(args: [str]) { log m1::a; }"}, {"sha": "65e0996fa627b4c41f452699a274d48c64f5b751", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:^ cannot be applied to type `istr`\n+// error-pattern:^ cannot be applied to type `str`\n \n fn main() { let x = \"a\" ^ \"b\"; }"}, {"sha": "f2796296da4e63e1ca96ea97a801d613ba882521", "filename": "src/test/compile-fail/block-require-return.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,5 +1,3 @@\n // error-pattern: not all control paths return\n fn force(f: &block() -> int) -> int { f() }\n-fn main() {\n-    log_err force({| | });\n-}\n+fn main() { log_err force({ | | }); }"}, {"sha": "945546fd6cb49f2da01ddbed0768cbba519c4cf9", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:malformed #env call\n \n-fn main() { #env[~\"one\", ~\"two\"]; }\n+fn main() { #env[\"one\", \"two\"]; }"}, {"sha": "8ea86d80a7b05d10f3d9b23361b85914d59f08a6", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:expected istr but found [int]\n+// error-pattern:expected str but found [int]\n fn main() { fail [0]; }"}, {"sha": "bd6cd7b8ff166dae0b4bb728690ed778027f8bf1", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,5 +5,5 @@ import std::str::*;\n fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n-    log_err safe_slice(~\"kitties\", a, b);\n+    log_err safe_slice(\"kitties\", a, b);\n }"}, {"sha": "f4375eaade38523bc791601acfdeadd24834ad0b", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,4 +4,4 @@ import zed::baz;\n mod zed {\n     fn bar() { log \"bar\"; }\n }\n-fn main(args: [istr]) { bar(); }\n+fn main(args: [str]) { bar(); }"}, {"sha": "89532f61fb1a68f6cefc33782c3af3cd5b476bf5", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,4 +4,4 @@ mod baz { }\n mod zed {\n     fn bar() { log \"bar3\"; }\n }\n-fn main(args: [istr]) { bar(); }\n+fn main(args: [str]) { bar(); }"}, {"sha": "680804c97b043fd15244df5388aca0f8facb34c7", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved modulename\n import main::bar;\n \n-fn main(args: [istr]) { log \"foo\"; }\n+fn main(args: [str]) { log \"foo\"; }"}, {"sha": "6daed215ddb534f078aed8ae685622dad7a961c3", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,4 +3,4 @@\n import zed::bar;\n import bar::zed;\n \n-fn main(args: [istr]) { log \"loop\"; }\n+fn main(args: [str]) { log \"loop\"; }"}, {"sha": "e30a2dbe7df9d3b4ea5de522c3a222f22527b75d", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:applying unary minus to non-numeric type istr\n+// error-pattern:applying unary minus to non-numeric type str\n \n fn main() { -\"foo\"; }"}, {"sha": "65e21baf78b05231f60284bba1a86ef04521cb7f", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     // the next statement, since it's not true in the\n     // prestate.\n     let d <- a;\n-    log safe_slice(~\"kitties\", b, d);\n+    log safe_slice(\"kitties\", b, d);\n }"}, {"sha": "47809cdcaf267ccc542d561ede66496d9bf75448", "filename": "src/test/compile-fail/nonsense-constraints.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,16 +3,11 @@\n use std;\n import std::uint;\n \n-fn enum_chars(start:u8, end:u8) : uint::le(start, end) -> [char] {\n+fn enum_chars(start: u8, end: u8) : uint::le(start, end) -> [char] {\n     let i = start;\n     let r = [];\n-    while (i <= end) {\n-        r += [i as char];\n-        i += (1u as u8);\n-    }\n+    while i <= end { r += [i as char]; i += 1u as u8; }\n     ret r;\n }\n \n-fn main() {\n-    log (enum_chars('a' as u8, 'z' as u8));\n-}\n\\ No newline at end of file\n+fn main() { log enum_chars('a' as u8, 'z' as u8); }"}, {"sha": "2226c5cbf32f8a406c9db6b22dc68b8897f7c653", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,4 +8,5 @@ fn main() {\n                    // is not a manifest call\n \n \n+\n }"}, {"sha": "51028a0362310c21d43cbc063452f62be07f3b7c", "filename": "src/test/compile-fail/zip-missing-check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,11 +7,11 @@ import std::vec::*;\n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;\n     // Silly, but necessary\n-    check u8::le(a, j);\n-    check uint::le(k, l);\n+    check (u8::le(a, j));\n+    check (uint::le(k, l));\n     let chars = enum_chars(a, j);\n-    let ints  = enum_uints(k, l);\n+    let ints = enum_uints(k, l);\n \n     let ps = zip(chars, ints);\n     fail \"the impossible happened\";\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ab0415fd7c12662afdde88131fa969781a290ef9", "filename": "src/test/compiletest/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcommon.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -16,17 +16,17 @@ type config =\n     // for running under valgrind\n     // Flags to pass to the compiler\n     // Explain what's going on\n-    {compile_lib_path: istr,\n-     run_lib_path: istr,\n-     rustc_path: istr,\n-     src_base: istr,\n-     build_base: istr,\n-     stage_id: istr,\n+    {compile_lib_path: str,\n+     run_lib_path: str,\n+     rustc_path: str,\n+     src_base: str,\n+     build_base: str,\n+     stage_id: str,\n      mode: mode,\n      run_ignored: bool,\n-     filter: option::t<istr>,\n-     runtool: option::t<istr>,\n-     rustcflags: option::t<istr>,\n+     filter: option::t<str>,\n+     runtool: option::t<str>,\n+     rustcflags: option::t<str>,\n      verbose: bool};\n \n type cx = {config: config, procsrv: procsrv::handle};"}, {"sha": "c931369cfc79513a0203da0a6ded57685667f5bb", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 57, "deletions": 80, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -21,58 +21,50 @@ import common::mode_pretty;\n import common::mode;\n import util::logv;\n \n-fn main(args: [istr]) {\n+fn main(args: [str]) {\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);\n }\n \n-fn parse_config(args: &[istr]) -> config {\n+fn parse_config(args: &[str]) -> config {\n     let opts =\n-        [getopts::reqopt(~\"compile-lib-path\"),\n-         getopts::reqopt(~\"run-lib-path\"),\n-         getopts::reqopt(~\"rustc-path\"),\n-         getopts::reqopt(~\"src-base\"),\n-         getopts::reqopt(~\"build-base\"),\n-         getopts::reqopt(~\"stage-id\"),\n-         getopts::reqopt(~\"mode\"),\n-         getopts::optflag(~\"ignored\"),\n-         getopts::optopt(~\"runtool\"),\n-         getopts::optopt(~\"rustcflags\"),\n-         getopts::optflag(~\"verbose\")];\n+        [getopts::reqopt(\"compile-lib-path\"), getopts::reqopt(\"run-lib-path\"),\n+         getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n+         getopts::reqopt(\"build-base\"), getopts::reqopt(\"stage-id\"),\n+         getopts::reqopt(\"mode\"), getopts::optflag(\"ignored\"),\n+         getopts::optopt(\"runtool\"), getopts::optopt(\"rustcflags\"),\n+         getopts::optflag(\"verbose\")];\n \n     check (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n-          getopts::failure(f) {\n-            fail getopts::fail_str(f)\n-          }\n+          getopts::failure(f) { fail getopts::fail_str(f) }\n         };\n \n-    ret {compile_lib_path: getopts::opt_str(match, ~\"compile-lib-path\"),\n-         run_lib_path: getopts::opt_str(match, ~\"run-lib-path\"),\n-         rustc_path: getopts::opt_str(match, ~\"rustc-path\"),\n-         src_base: getopts::opt_str(match, ~\"src-base\"),\n-         build_base: getopts::opt_str(match, ~\"build-base\"),\n-         stage_id: getopts::opt_str(match, ~\"stage-id\"),\n-         mode: str_mode(getopts::opt_str(match, ~\"mode\")),\n-         run_ignored: getopts::opt_present(match, ~\"ignored\"),\n+    ret {compile_lib_path: getopts::opt_str(match, \"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(match, \"run-lib-path\"),\n+         rustc_path: getopts::opt_str(match, \"rustc-path\"),\n+         src_base: getopts::opt_str(match, \"src-base\"),\n+         build_base: getopts::opt_str(match, \"build-base\"),\n+         stage_id: getopts::opt_str(match, \"stage-id\"),\n+         mode: str_mode(getopts::opt_str(match, \"mode\")),\n+         run_ignored: getopts::opt_present(match, \"ignored\"),\n          filter:\n              if vec::len(match.free) > 0u {\n                  option::some(match.free[0])\n              } else { option::none },\n-         runtool: getopts::opt_maybe_str(match, ~\"runtool\"),\n-         rustcflags: getopts::opt_maybe_str(match, ~\"rustcflags\"),\n-         verbose: getopts::opt_present(match, ~\"verbose\")};\n+         runtool: getopts::opt_maybe_str(match, \"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(match, \"rustcflags\"),\n+         verbose: getopts::opt_present(match, \"verbose\")};\n }\n \n fn log_config(config: &config) {\n     let c = config;\n     logv(c, #fmt[\"configuration:\"]);\n-    logv(c, #fmt[\"compile_lib_path: %s\",\n-                 config.compile_lib_path]);\n+    logv(c, #fmt[\"compile_lib_path: %s\", config.compile_lib_path]);\n     logv(c, #fmt[\"run_lib_path: %s\", config.run_lib_path]);\n     logv(c, #fmt[\"rustc_path: %s\", config.rustc_path]);\n     logv(c, #fmt[\"src_base: %s\", config.src_base]);\n@@ -87,33 +79,30 @@ fn log_config(config: &config) {\n     logv(c, #fmt[\"\\n\"]);\n }\n \n-fn opt_str(maybestr: option::t<istr>) -> istr {\n-    alt maybestr {\n-      option::some(s) { s }\n-      option::none. { ~\"(none)\" }\n-    }\n+fn opt_str(maybestr: option::t<str>) -> str {\n+    alt maybestr { option::some(s) { s } option::none. { \"(none)\" } }\n }\n \n-fn str_opt(maybestr: &istr) -> option::t<istr> {\n-    if maybestr != ~\"(none)\" { option::some(maybestr) } else { option::none }\n+fn str_opt(maybestr: &str) -> option::t<str> {\n+    if maybestr != \"(none)\" { option::some(maybestr) } else { option::none }\n }\n \n-fn str_mode(s: &istr) -> mode {\n+fn str_mode(s: &str) -> mode {\n     alt s {\n-      ~\"compile-fail\" { mode_compile_fail }\n-      ~\"run-fail\" { mode_run_fail }\n-      ~\"run-pass\" { mode_run_pass }\n-      ~\"pretty\" { mode_pretty }\n+      \"compile-fail\" { mode_compile_fail }\n+      \"run-fail\" { mode_run_fail }\n+      \"run-pass\" { mode_run_pass }\n+      \"pretty\" { mode_pretty }\n       _ { fail \"invalid mode\" }\n     }\n }\n \n-fn mode_str(mode: mode) -> istr {\n+fn mode_str(mode: mode) -> str {\n     alt mode {\n-      mode_compile_fail. { ~\"compile-fail\" }\n-      mode_run_fail. { ~\"run-fail\" }\n-      mode_run_pass. { ~\"run-pass\" }\n-      mode_pretty. { ~\"pretty\" }\n+      mode_compile_fail. { \"compile-fail\" }\n+      mode_run_fail. { \"run-fail\" }\n+      mode_run_pass. { \"run-pass\" }\n+      mode_pretty. { \"pretty\" }\n     }\n }\n \n@@ -126,13 +115,12 @@ fn run_tests(config: &config) {\n }\n \n fn test_opts(config: &config) -> test::test_opts {\n-    {\n-        filter: alt config.filter {\n-          option::some(s) { option::some(s) }\n-          option::none. { option::none }\n-        },\n-        run_ignored: config.run_ignored\n-    }\n+    {filter:\n+         alt config.filter {\n+           option::some(s) { option::some(s) }\n+           option::none. { option::none }\n+         },\n+     run_ignored: config.run_ignored}\n }\n \n type tests_and_conv_fn =\n@@ -142,7 +130,7 @@ fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     log #fmt[\"making tests from %s\", cx.config.src_base];\n     let configport = port::<[u8]>();\n     let tests = [];\n-    for file: istr in fs::list_dir(cx.config.src_base) {\n+    for file: str in fs::list_dir(cx.config.src_base) {\n         let file = file;\n         log #fmt[\"inspecting file %s\", file];\n         if is_test(cx.config, file) {\n@@ -152,13 +140,11 @@ fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     ret {tests: tests, to_task: bind closure_to_task(cx, configport, _)};\n }\n \n-fn is_test(config: &config, testfile: &istr) -> bool {\n+fn is_test(config: &config, testfile: &str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n-    let valid_extensions = alt config.mode {\n-      mode_pretty. { [~\".rs\"] }\n-      _ { [~\".rc\", ~\".rs\"] }\n-    };\n-    let invalid_prefixes = [~\".\", ~\"#\", ~\"~\"];\n+    let valid_extensions =\n+        alt config.mode { mode_pretty. { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n+    let invalid_prefixes = [\".\", \"#\", \"~\"];\n     let name = fs::basename(testfile);\n \n     let valid = false;\n@@ -174,14 +160,14 @@ fn is_test(config: &config, testfile: &istr) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: &cx, testfile: &istr, configport: &port<[u8]>) ->\n+fn make_test(cx: &cx, testfile: &str, configport: &port<[u8]>) ->\n    test::test_desc {\n     {name: make_test_name(cx.config, testfile),\n      fn: make_test_closure(testfile, chan(configport)),\n      ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n-fn make_test_name(config: &config, testfile: &istr) -> istr {\n+fn make_test_name(config: &config, testfile: &str) -> str {\n     #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n@@ -204,12 +190,12 @@ up. Then we'll spawn that data into another task and return the task.\n Really convoluted. Need to think up of a better definition for tests.\n */\n \n-fn make_test_closure(testfile: &istr, configchan: chan<[u8]>) ->\n+fn make_test_closure(testfile: &str, configchan: chan<[u8]>) ->\n    test::test_fn {\n     bind send_config(testfile, configchan)\n }\n \n-fn send_config(testfile: istr, configchan: chan<[u8]>) {\n+fn send_config(testfile: str, configchan: chan<[u8]>) {\n     send(configchan, str::bytes(testfile));\n }\n \n@@ -243,26 +229,17 @@ fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: &fn()) ->\n     let chan = cx.procsrv.chan;\n \n     let testthunk =\n-        bind run_test_task(compile_lib_path, run_lib_path,\n-                           rustc_path, src_base,\n-                           build_base, stage_id,\n-                           mode,\n-                           run_ignored,\n-                           filter,\n-                           runtool,\n-                           rustcflags,\n-                           verbose,\n-                           chan,\n+        bind run_test_task(compile_lib_path, run_lib_path, rustc_path,\n+                           src_base, build_base, stage_id, mode, run_ignored,\n+                           filter, runtool, rustcflags, verbose, chan,\n                            testfile);\n     ret task::spawn_joinable(testthunk);\n }\n \n-fn run_test_task(compile_lib_path: -istr, run_lib_path: -istr,\n-                 rustc_path: -istr,\n-                 src_base: -istr, build_base: -istr, stage_id: -istr,\n-                 mode: -istr,\n-                 run_ignored: -bool, opt_filter: -istr, opt_runtool: -istr,\n-                 opt_rustcflags: -istr, verbose: -bool,\n+fn run_test_task(compile_lib_path: -str, run_lib_path: -str, rustc_path: -str,\n+                 src_base: -str, build_base: -str, stage_id: -str, mode: -str,\n+                 run_ignored: -bool, opt_filter: -str, opt_runtool: -str,\n+                 opt_rustcflags: -str, verbose: -bool,\n                  procsrv_chan: -procsrv::reqchan, testfile: -[u8]) {\n \n     test::configure_test_task();"}, {"sha": "8a03378742b6b5f82dd794eefe24995923e09d48", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -11,24 +11,24 @@ export is_test_ignored;\n \n type test_props = {\n     // Lines that should be expected, in order, on standard out\n-    error_patterns: [istr],\n+    error_patterns: [str],\n     // Extra flags to pass to the compiler\n-    compile_flags: option::t<istr>,\n+    compile_flags: option::t<str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option::t<istr>,\n+    pp_exact: option::t<str>,\n     // FIXME: no-valgrind is a temporary directive until all of run-fail\n     // is valgrind-clean\n     no_valgrind: bool\n };\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: &istr) -> test_props {\n+fn load_props(testfile: &str) -> test_props {\n     let error_patterns = [];\n     let compile_flags = option::none;\n     let pp_exact = option::none;\n     let no_valgrind = false;\n-    for each ln: istr in iter_header(testfile) {\n+    for each ln: str in iter_header(testfile) {\n         alt parse_error_pattern(ln) {\n           option::some(ep) { error_patterns += [ep]; }\n           option::none. { }\n@@ -43,7 +43,7 @@ fn load_props(testfile: &istr) -> test_props {\n         }\n \n         if no_valgrind == false {\n-            no_valgrind = parse_name_directive(ln, ~\"no-valgrind\");\n+            no_valgrind = parse_name_directive(ln, \"no-valgrind\");\n         }\n     }\n     ret {\n@@ -54,46 +54,46 @@ fn load_props(testfile: &istr) -> test_props {\n     };\n }\n \n-fn is_test_ignored(config: &config, testfile: &istr) -> bool {\n+fn is_test_ignored(config: &config, testfile: &str) -> bool {\n     let found = false;\n-    for each ln: istr in iter_header(testfile) {\n+    for each ln: str in iter_header(testfile) {\n         // FIXME: Can't return or break from iterator\n-        found = found || parse_name_directive(ln, ~\"xfail-test\");\n+        found = found || parse_name_directive(ln, \"xfail-test\");\n         if (config.mode == common::mode_pretty) {\n-            found = found || parse_name_directive(ln, ~\"xfail-pretty\");\n+            found = found || parse_name_directive(ln, \"xfail-pretty\");\n         }\n     }\n     ret found;\n }\n \n-iter iter_header(testfile: &istr) -> istr {\n+iter iter_header(testfile: &str) -> str {\n     let rdr = io::file_reader(testfile);\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n \n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, ~\"fn\")\n-            || str::starts_with(ln, ~\"mod\") {\n+        if str::starts_with(ln, \"fn\")\n+            || str::starts_with(ln, \"mod\") {\n             break;\n         } else { put ln; }\n     }\n }\n \n-fn parse_error_pattern(line: &istr) -> option::t<istr> {\n-    parse_name_value_directive(line, ~\"error-pattern\")\n+fn parse_error_pattern(line: &str) -> option::t<str> {\n+    parse_name_value_directive(line, \"error-pattern\")\n }\n \n-fn parse_compile_flags(line: &istr) -> option::t<istr> {\n-    parse_name_value_directive(line, ~\"compile-flags\")\n+fn parse_compile_flags(line: &str) -> option::t<str> {\n+    parse_name_value_directive(line, \"compile-flags\")\n }\n \n-fn parse_pp_exact(line: &istr, testfile: &istr) -> option::t<istr> {\n-    alt parse_name_value_directive(line, ~\"pp-exact\") {\n+fn parse_pp_exact(line: &str, testfile: &str) -> option::t<str> {\n+    alt parse_name_value_directive(line, \"pp-exact\") {\n       option::some(s) { option::some(s) }\n       option::none. {\n-        if parse_name_directive(line, ~\"pp-exact\") {\n+        if parse_name_directive(line, \"pp-exact\") {\n             option::some(fs::basename(testfile))\n         } else {\n             option::none\n@@ -102,13 +102,13 @@ fn parse_pp_exact(line: &istr, testfile: &istr) -> option::t<istr> {\n     }\n }\n \n-fn parse_name_directive(line: &istr, directive: &istr) -> bool {\n+fn parse_name_directive(line: &str, directive: &str) -> bool {\n     str::find(line, directive) >= 0\n }\n \n-fn parse_name_value_directive(line: &istr,\n-                              directive: &istr) -> option::t<istr> {\n-    let keycolon = directive + ~\":\";\n+fn parse_name_value_directive(line: &str,\n+                              directive: &str) -> option::t<str> {\n+    let keycolon = directive + \":\";\n     if str::find(line, keycolon) >= 0 {\n         let colon = str::find(line, keycolon) as uint;\n         let value ="}, {"sha": "63a3807f6a5f0452742108d06601d13052013b7f", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -27,8 +27,9 @@ export reqchan;\n \n type reqchan = chan<request>;\n \n-type handle = {task: option::t<(task::task, port<task::task_notification>)>,\n-    chan: reqchan};\n+type handle =\n+    {task: option::t<(task::task, port<task::task_notification>)>,\n+     chan: reqchan};\n \n tag request { exec([u8], [u8], [[u8]], chan<response>); stop; }\n \n@@ -38,11 +39,11 @@ fn mk() -> handle {\n     let setupport = port();\n     let task =\n         task::spawn_joinable(bind fn (setupchan: chan<chan<request>>) {\n-            let reqport = port();\n-            let reqchan = chan(reqport);\n-            send(setupchan, reqchan);\n-            worker(reqport);\n-        }(chan(setupport)));\n+                                      let reqport = port();\n+                                      let reqchan = chan(reqport);\n+                                      send(setupchan, reqchan);\n+                                      worker(reqport);\n+                                  }(chan(setupport)));\n     ret {task: option::some(task), chan: recv(setupport)};\n }\n \n@@ -53,8 +54,8 @@ fn close(handle: &handle) {\n     task::join(option::get(handle.task));\n }\n \n-fn run(handle: &handle, lib_path: &istr, prog: &istr, args: &[istr],\n-       input: &option::t<istr>) -> {status: int, out: istr, err: istr} {\n+fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n+       input: &option::t<str>) -> {status: int, out: str, err: str} {\n     let p = port();\n     let ch = chan(p);\n     send(handle.chan,\n@@ -69,7 +70,7 @@ fn run(handle: &handle, lib_path: &istr, prog: &istr, args: &[istr],\n     ret {status: status, out: output, err: errput};\n }\n \n-fn writeclose(fd: int, s: &option::t<istr>) {\n+fn writeclose(fd: int, s: &option::t<str>) {\n     if option::is_some(s) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n         writer.write_str(option::get(s));\n@@ -78,11 +79,11 @@ fn writeclose(fd: int, s: &option::t<istr>) {\n     os::libc::close(fd);\n }\n \n-fn readclose(fd: int) -> istr {\n+fn readclose(fd: int) -> str {\n     // Copied from run::program_output\n     let file = os::fd_FILE(fd);\n     let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n-    let buf = ~\"\";\n+    let buf = \"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n         buf += str::unsafe_from_bytes(bytes);\n@@ -128,8 +129,7 @@ fn worker(p: port<request>) {\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n         let spawnproc =\n-            bind run::spawn_process(execparms.prog,\n-                                    execparms.args,\n+            bind run::spawn_process(execparms.prog, execparms.args,\n                                     pipe_in.in, pipe_out.out, pipe_err.out);\n         let pid = with_lib_path(execparms.lib_path, spawnproc);\n \n@@ -151,34 +151,30 @@ fn worker(p: port<request>) {\n     }\n }\n \n-fn with_lib_path<@T>(path: &istr, f: fn() -> T) -> T {\n+fn with_lib_path<@T>(path: &str, f: fn() -> T) -> T {\n     let maybe_oldpath = getenv(util::lib_path_env_var());\n     append_lib_path(path);\n     let res = f();\n     if option::is_some(maybe_oldpath) {\n         export_lib_path(option::get(maybe_oldpath));\n     } else {\n         // FIXME: This should really be unset but we don't have that yet\n-        export_lib_path(~\"\");\n+        export_lib_path(\"\");\n     }\n     ret res;\n }\n \n-fn append_lib_path(path: &istr) {\n-    export_lib_path(util::make_new_path(path));\n-}\n+fn append_lib_path(path: &str) { export_lib_path(util::make_new_path(path)); }\n \n-fn export_lib_path(path: &istr) {\n-    setenv(util::lib_path_env_var(), path);\n-}\n+fn export_lib_path(path: &str) { setenv(util::lib_path_env_var(), path); }\n \n-fn clone_vecstr(v: &[istr]) -> [[u8]] {\n+fn clone_vecstr(v: &[str]) -> [[u8]] {\n     let r = [];\n-    for t: istr in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n+    for t: str in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n     ret r;\n }\n \n-fn clone_vecu8str(v: &[[u8]]) -> [istr] {\n+fn clone_vecu8str(v: &[[u8]]) -> [str] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n         r += [str::unsafe_from_bytes(t)];"}, {"sha": "87ae7750e03645eaa8a903d297f6cf2bf43b7553", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 99, "deletions": 116, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -22,7 +22,7 @@ fn run(cx: &cx, _testfile: -[u8]) {\n     let testfile = str::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(~\"\\n\\n\");\n+        io::stdout().write_str(\"\\n\\n\");\n     }\n     log #fmt[\"running %s\", testfile];\n     let props = load_props(testfile);\n@@ -34,25 +34,25 @@ fn run(cx: &cx, _testfile: -[u8]) {\n     }\n }\n \n-fn run_cfail_test(cx: &cx, props: &test_props, testfile: &istr) {\n+fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n     let procres = compile_test(cx, props, testfile);\n \n     if procres.status == 0 {\n-        fatal_procres(~\"compile-fail test compiled successfully!\", procres);\n+        fatal_procres(\"compile-fail test compiled successfully!\", procres);\n     }\n \n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rfail_test(cx: &cx, props: &test_props, testfile: &istr) {\n+fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n     let procres = compile_test(cx, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(cx, props, testfile);\n \n     if procres.status == 0 {\n-        fatal_procres(~\"run-fail test didn't produce an error!\", procres);\n+        fatal_procres(\"run-fail test didn't produce an error!\", procres);\n     }\n \n     // This is the value valgrind returns on failure\n@@ -61,27 +61,27 @@ fn run_rfail_test(cx: &cx, props: &test_props, testfile: &istr) {\n     // exit code on the command-line (137)?\n     const valgrind_err: int = 9;\n     if procres.status == valgrind_err {\n-        fatal_procres(~\"run-fail test isn't valgrind-clean!\", procres);\n+        fatal_procres(\"run-fail test isn't valgrind-clean!\", procres);\n     }\n \n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rpass_test(cx: &cx, props: &test_props, testfile: &istr) {\n+fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n     let procres = compile_test(cx, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(cx, props, testfile);\n \n \n-    if procres.status != 0 { fatal_procres(~\"test run failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n+fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n     if option::is_some(props.pp_exact) {\n-        logv(cx.config, ~\"testing for exact pretty-printing\");\n-    } else { logv(cx.config, ~\"testing for converging pretty-printing\"); }\n+        logv(cx.config, \"testing for exact pretty-printing\");\n+    } else { logv(cx.config, \"testing for converging pretty-printing\"); }\n \n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none. { 2 } };\n@@ -94,9 +94,8 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n         let procres = print_source(cx, testfile, srcs[round]);\n \n         if procres.status != 0 {\n-            fatal_procres(\n-                    #fmt[\"pretty-printing failed in round %d\", round],\n-                    procres);\n+            fatal_procres(#fmt[\"pretty-printing failed in round %d\", round],\n+                          procres);\n         }\n \n         srcs += [procres.stdout];\n@@ -115,10 +114,10 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n \n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n-        let cr = ~\"\\r\";\n+        let cr = \"\\r\";\n         check (str::is_not_empty(cr));\n-        actual = str::replace(actual, cr, ~\"\");\n-        expected = str::replace(expected, cr, ~\"\");\n+        actual = str::replace(actual, cr, \"\");\n+        expected = str::replace(expected, cr, \"\");\n     }\n \n     compare_source(expected, actual);\n@@ -127,25 +126,25 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n     let procres = typecheck_source(cx, testfile, actual);\n \n     if procres.status != 0 {\n-        fatal_procres(~\"pretty-printed source does not typecheck\", procres);\n+        fatal_procres(\"pretty-printed source does not typecheck\", procres);\n     }\n \n     ret;\n \n-    fn print_source(cx: &cx, testfile: &istr, src: &istr) -> procres {\n+    fn print_source(cx: &cx, testfile: &str, src: &str) -> procres {\n         compose_and_run(cx, testfile, make_pp_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_pp_args(config: &config, _testfile: &istr) -> procargs {\n+    fn make_pp_args(config: &config, _testfile: &str) -> procargs {\n         let prog = config.rustc_path;\n-        let args = [~\"-\", ~\"--pretty\", ~\"normal\"];\n+        let args = [\"-\", \"--pretty\", \"normal\"];\n         ret {prog: prog, args: args};\n     }\n \n-    fn compare_source(expected: &istr, actual: &istr) {\n+    fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n-            error(~\"pretty-printed source does match expected source\");\n+            error(\"pretty-printed source does match expected source\");\n             let msg =\n                 #fmt[\"\\n\\\n expected:\\n\\\n@@ -157,41 +156,39 @@ actual:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                     expected,\n-                      actual];\n+                     expected, actual];\n             io::stdout().write_str(msg);\n             fail;\n         }\n     }\n \n-    fn typecheck_source(cx: &cx, testfile: &istr, src: &istr) -> procres {\n+    fn typecheck_source(cx: &cx, testfile: &str, src: &str) -> procres {\n         compose_and_run(cx, testfile, make_typecheck_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_typecheck_args(config: &config, _testfile: &istr) -> procargs {\n+    fn make_typecheck_args(config: &config, _testfile: &str) -> procargs {\n         let prog = config.rustc_path;\n-        let args = [~\"-\", ~\"--no-trans\", ~\"--lib\"];\n+        let args = [\"-\", \"--no-trans\", \"--lib\"];\n         ret {prog: prog, args: args};\n     }\n }\n \n-fn check_error_patterns(props: &test_props, testfile: &istr,\n+fn check_error_patterns(props: &test_props, testfile: &str,\n                         procres: &procres) {\n     if vec::is_empty(props.error_patterns) {\n-        fatal(~\"no error pattern specified in \" + testfile);\n+        fatal(\"no error pattern specified in \" + testfile);\n     }\n \n     if procres.status == 0 {\n-        fatal(~\"process did not return an error status\");\n+        fatal(\"process did not return an error status\");\n     }\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n-    for line: istr in str::split(procres.stdout, '\\n' as u8) {\n+    for line: str in str::split(procres.stdout, '\\n' as u8) {\n         if str::find(line, next_err_pat) > 0 {\n-            log #fmt[\"found error pattern %s\",\n-                      next_err_pat];\n+            log #fmt[\"found error pattern %s\", next_err_pat];\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n                 log \"found all error patterns\";\n@@ -205,83 +202,83 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(\n-            #fmt[\"error pattern '%s' not found!\",\n-                  missing_patterns[0]], procres);\n+        fatal_procres(#fmt[\"error pattern '%s' not found!\",\n+                           missing_patterns[0]], procres);\n     } else {\n-        for pattern: istr in missing_patterns {\n-            error(#fmt[\"error pattern '%s' not found!\",\n-                        pattern]);\n+        for pattern: str in missing_patterns {\n+            error(#fmt[\"error pattern '%s' not found!\", pattern]);\n         }\n-        fatal_procres(~\"multiple error patterns not found\", procres);\n+        fatal_procres(\"multiple error patterns not found\", procres);\n     }\n }\n \n-type procargs = {prog: istr, args: [istr]};\n+type procargs = {prog: str, args: [str]};\n \n-type procres = {status: int, stdout: istr, stderr: istr, cmdline: istr};\n+type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n-fn compile_test(cx: &cx, props: &test_props, testfile: &istr) -> procres {\n+fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n     compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n                     cx.config.compile_lib_path, option::none)\n }\n \n-fn exec_compiled_test(cx: &cx, props: &test_props, testfile: &istr) ->\n+fn exec_compiled_test(cx: &cx, props: &test_props, testfile: &str) ->\n    procres {\n     compose_and_run(cx, testfile, bind make_run_args(_, props, _),\n                     cx.config.run_lib_path, option::none)\n }\n \n-fn compose_and_run(cx: &cx, testfile: &istr,\n-                   make_args: fn(&config, &istr) -> procargs,\n-                   lib_path: &istr,\n-                   input: option::t<istr>) -> procres {\n+fn compose_and_run(cx: &cx, testfile: &str,\n+                   make_args: fn(&config, &str) -> procargs, lib_path: &str,\n+                   input: option::t<str>) -> procres {\n     let procargs = make_args(cx.config, testfile);\n     ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args,\n                        input);\n }\n \n-fn make_compile_args(config: &config, props: &test_props, testfile: &istr) ->\n+fn make_compile_args(config: &config, props: &test_props, testfile: &str) ->\n    procargs {\n     let prog = config.rustc_path;\n-    let args = [testfile, ~\"-o\", make_exe_name(config, testfile)];\n-    let rustcflags = alt config.rustcflags {\n-      option::some(s) { option::some(s) }\n-      option::none. { option::none }\n-    };\n+    let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n+    let rustcflags =\n+        alt config.rustcflags {\n+          option::some(s) { option::some(s) }\n+          option::none. { option::none }\n+        };\n     args += split_maybe_args(rustcflags);\n     args += split_maybe_args(props.compile_flags);\n     ret {prog: prog, args: args};\n }\n \n-fn make_exe_name(config: &config, testfile: &istr) -> istr {\n+fn make_exe_name(config: &config, testfile: &str) -> str {\n     output_base_name(config, testfile) + os::exec_suffix()\n }\n \n-fn make_run_args(config: &config, props: &test_props, testfile: &istr) ->\n+fn make_run_args(config: &config, props: &test_props, testfile: &str) ->\n    procargs {\n-    let toolargs = if !props.no_valgrind {\n-        // If we've got another tool to run under (valgrind),\n-        // then split apart its command\n-        let runtool = alt config.runtool {\n-          option::some(s) { option::some(s) }\n-          option::none. { option::none }\n-        };\n-        split_maybe_args(runtool)\n-    } else { [] };\n+    let toolargs =\n+        if !props.no_valgrind {\n+            // If we've got another tool to run under (valgrind),\n+            // then split apart its command\n+            let runtool =\n+                alt config.runtool {\n+                  option::some(s) { option::some(s) }\n+                  option::none. { option::none }\n+                };\n+            split_maybe_args(runtool)\n+        } else { [] };\n \n     let args = toolargs + [make_exe_name(config, testfile)];\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: &option::t<istr>) -> [istr] {\n-    fn rm_whitespace(v: &[istr]) -> [istr] {\n-        fn flt(s: &istr) -> option::t<istr> {\n+fn split_maybe_args(argstr: &option::t<str>) -> [str] {\n+    fn rm_whitespace(v: &[str]) -> [str] {\n+        fn flt(s: &str) -> option::t<str> {\n             if !is_whitespace(s) { option::some(s) } else { option::none }\n         }\n \n         // FIXME: This should be in std\n-        fn is_whitespace(s: &istr) -> bool {\n+        fn is_whitespace(s: &str) -> bool {\n             for c: u8 in s { if c != ' ' as u8 { ret false; } }\n             ret true;\n         }\n@@ -294,13 +291,12 @@ fn split_maybe_args(argstr: &option::t<istr>) -> [istr] {\n     }\n }\n \n-fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n-                  args: &[istr], input: option::t<istr>) -> procres {\n+fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n+                  args: &[str], input: option::t<str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config, #fmt[\"executing %s\",\n-                                  cmdline]);\n+            logv(cx.config, #fmt[\"executing %s\", cmdline]);\n             cmdline\n         };\n     let res = procsrv::run(cx.procsrv, lib_path, prog, args, input);\n@@ -311,66 +307,58 @@ fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n          cmdline: cmdline};\n }\n \n-fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n-    #fmt[\"%s %s %s\",\n-          lib_path_cmd_prefix(libpath),\n-          prog,\n-          str::connect(args, ~\" \")]\n+fn make_cmdline(libpath: &str, prog: &str, args: &[str]) -> str {\n+    #fmt[\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n+         str::connect(args, \" \")]\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: &istr) -> istr {\n-        #fmt[\"%s=\\\"%s\\\"\",\n-              util::lib_path_env_var(),\n-              util::make_new_path(path)]\n+fn lib_path_cmd_prefix(path: &str) -> str {\n+    #fmt[\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)]\n }\n \n-fn dump_output(config: &config, testfile: &istr, out: &istr, err: &istr) {\n-    dump_output_file(config, testfile, out, ~\"out\");\n-    dump_output_file(config, testfile, err, ~\"err\");\n+fn dump_output(config: &config, testfile: &str, out: &str, err: &str) {\n+    dump_output_file(config, testfile, out, \"out\");\n+    dump_output_file(config, testfile, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n #[cfg(target_os = \"win32\")]\n #[cfg(target_os = \"linux\")]\n-fn dump_output_file(config: &config, testfile: &istr, out: &istr,\n-                    extension: &istr) {\n+fn dump_output_file(config: &config, testfile: &str, out: &str,\n+                    extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer = io::file_writer(outfile,\n-                                 [io::create, io::truncate]);\n+    let writer = io::file_writer(outfile, [io::create, io::truncate]);\n     writer.write_str(out);\n }\n \n // FIXME (726): Can't use file_writer on mac\n #[cfg(target_os = \"macos\")]\n-fn dump_output_file(config: &config, testfile: &istr, out: &istr,\n-                    extension: &istr) {\n+fn dump_output_file(config: &config, testfile: &str, out: &str,\n+                    extension: &str) {\n }\n \n-fn make_out_name(config: &config, testfile: &istr,\n-                 extension: &istr) -> istr {\n-    output_base_name(config, testfile) + ~\".\" + extension\n+fn make_out_name(config: &config, testfile: &str, extension: &str) -> str {\n+    output_base_name(config, testfile) + \".\" + extension\n }\n \n-fn output_base_name(config: &config, testfile: &istr) -> istr {\n+fn output_base_name(config: &config, testfile: &str) -> str {\n     let base = config.build_base;\n     let filename =\n         {\n-            let parts = str::split(fs::basename(testfile),\n-                                    '.' as u8);\n+            let parts = str::split(fs::basename(testfile), '.' as u8);\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n-            str::connect(parts, ~\".\")\n+            str::connect(parts, \".\")\n         };\n-    #fmt[\"%s%s.%s\", base, filename,\n-                        config.stage_id]\n+    #fmt[\"%s%s.%s\", base, filename, config.stage_id]\n }\n \n-fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n+fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n-        let sep1 = #fmt[\"------%s------------------------------\", ~\"stdout\"];\n-        let sep2 = #fmt[\"------%s------------------------------\", ~\"stderr\"];\n-        let sep3 = ~\"------------------------------------------\";\n+        let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n+        let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n+        let sep3 = \"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n         io::stdout().write_line(sep2);\n@@ -379,13 +367,11 @@ fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n     }\n }\n \n-fn error(err: &istr) {\n-    io::stdout().write_line(#fmt[\"\\nerror: %s\", err]);\n-}\n+fn error(err: &str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n \n-fn fatal(err: &istr) -> ! { error(err); fail; }\n+fn fatal(err: &str) -> ! { error(err); fail; }\n \n-fn fatal_procres(err: &istr, procres: procres) -> ! {\n+fn fatal_procres(err: &str, procres: procres) -> ! {\n     let msg =\n         #fmt[\"\\n\\\n error: %s\\n\\\n@@ -399,10 +385,7 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                             err,\n-                             procres.cmdline,\n-                             procres.stdout,\n-                             procres.stderr];\n+             err, procres.cmdline, procres.stdout, procres.stderr];\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "769b409ea4316b12fc0b95b9cfeefffdc87dc6c6", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,29 +5,26 @@ import std::str;\n \n import common::config;\n \n-fn make_new_path(path: &istr) -> istr {\n+fn make_new_path(path: &str) -> str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     alt getenv(lib_path_env_var()) {\n-      option::some(curr) {\n-        #fmt[\"%s:%s\", path, curr] }\n+      option::some(curr) { #fmt[\"%s:%s\", path, curr] }\n       option::none. { path }\n     }\n }\n \n #[cfg(target_os = \"linux\")]\n-fn lib_path_env_var() -> istr { ~\"LD_LIBRARY_PATH\" }\n+fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"macos\")]\n-fn lib_path_env_var() -> istr { ~\"DYLD_LIBRARY_PATH\" }\n+fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"win32\")]\n-fn lib_path_env_var() -> istr { ~\"PATH\" }\n+fn lib_path_env_var() -> str { \"PATH\" }\n \n-fn logv(config: &config, s: &istr) {\n+fn logv(config: &config, s: &str) {\n     log s;\n-    if config.verbose {\n-        io::stdout().write_line(s);\n-    }\n+    if config.verbose { io::stdout().write_line(s); }\n }"}, {"sha": "b45e443759c51206c7ac13feeb8fc33c553407ae", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:wooooo\n // no-valgrind\n-fn main() { let a = 1; if 1 == 1 { a = 2; } fail ~\"woooo\" + ~\"o\"; }\n+fn main() { let a = 1; if 1 == 1 { a = 2; } fail \"woooo\" + \"o\"; }"}, {"sha": "90256271fd22ffce0cec1e07ab3943381f1f470b", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,4 +2,4 @@\n // no-valgrind\n use std;\n \n-fn main() { let str_var: istr = ~\"meh\"; fail #fmt[\"%s\", str_var]; }\n+fn main() { let str_var: str = \"meh\"; fail #fmt[\"%s\", str_var]; }"}, {"sha": "3499d44ceff428dfb5aa9ca87fcd103a5224d1d9", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     let a: uint = 4u;\n     let b: uint = 1u;\n     check (le(a, b));\n-    log_err safe_slice(~\"kitties\", a, b);\n+    log_err safe_slice(\"kitties\", a, b);\n }"}, {"sha": "dcc86fdd3c9b242f8100d8bcaf3af78b4bfd89e9", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -9,12 +9,12 @@ import std::vec::*;\n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 9u;\n     // Silly, but necessary\n-    check u8::le(a, j);\n-    check uint::le(k, l);\n+    check (u8::le(a, j));\n+    check (uint::le(k, l));\n     let chars = enum_chars(a, j);\n-    let ints  = enum_uints(k, l);\n+    let ints = enum_uints(k, l);\n \n-    check same_length(chars, ints);\n+    check (same_length(chars, ints));\n     let ps = zip(chars, ints);\n     fail \"the impossible happened\";\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e51263db8042e6d3f223332e5c73e27af2d1c6c9", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,31 +1,21 @@\n // Issue #53\n \n fn main() {\n-    alt ~\"test\" {\n-      ~\"not-test\" { fail; }\n-      ~\"test\" { }\n-      _ { fail; }\n-    }\n+    alt \"test\" { \"not-test\" { fail; } \"test\" { } _ { fail; } }\n \n-    tag t { tag1(istr); tag2; }\n+    tag t { tag1(str); tag2; }\n \n \n-    alt tag1(~\"test\") {\n+    alt tag1(\"test\") {\n       tag2. { fail; }\n-      tag1(~\"not-test\") { fail; }\n-      tag1(~\"test\") { }\n+      tag1(\"not-test\") { fail; }\n+      tag1(\"test\") { }\n       _ { fail; }\n     }\n \n-    let x = alt ~\"a\" {\n-      ~\"a\" { 1 }\n-      ~\"b\" { 2 }\n-    };\n-    assert x == 1;\n+    let x = alt \"a\" { \"a\" { 1 } \"b\" { 2 } };\n+    assert (x == 1);\n \n-    alt ~\"a\" {\n-      ~\"a\" { }\n-      ~\"b\" { }\n-    }\n+    alt \"a\" { \"a\" { } \"b\" { } }\n \n }"}, {"sha": "0bb536086ba44d0eeb776fe5eb8672218880926b", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,5 +1,5 @@\n-fn main(args: [istr]) {\n-    let vs: [istr] = [~\"hi\", ~\"there\", ~\"this\", ~\"is\", ~\"a\", ~\"vec\"];\n-    let vvs: [[istr]] = [args, vs];\n-    for vs: [istr] in vvs { for s: istr in vs { log s; } }\n+fn main(args: [str]) {\n+    let vs: [str] = [\"hi\", \"there\", \"this\", \"is\", \"a\", \"vec\"];\n+    let vvs: [[str]] = [args, vs];\n+    for vs: [str] in vvs { for s: str in vs { log s; } }\n }"}, {"sha": "0c4c49a0a3ddb910afe0e1d5966da54816450505", "filename": "src/test/run-pass/bug-862.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fbug-862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fbug-862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-862.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,8 +4,4 @@ fn f(i: int, j: int) : p(j) -> int { j }\n \n fn g(i: int, j: int) : p(j) -> int { f(i, j) }\n \n-fn main() {\n-    let x = 1;\n-    check p(x);\n-    log g(x, x);\n-}\n\\ No newline at end of file\n+fn main() { let x = 1; check (p(x)); log g(x, x); }"}, {"sha": "32c6ac2475b83c7e1ec553f87cd90d8957a8f941", "filename": "src/test/run-pass/check-pattern-bound.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,16 +1,10 @@\n use std;\n import std::option::*;\n \n-pure fn p(x:int) -> bool { true }\n+pure fn p(x: int) -> bool { true }\n \n-fn f(x:int) : p(x) { }\n+fn f(x: int) : p(x) { }\n \n fn main() {\n-    alt some(5) {\n-      some(y) {\n-        check p(y);\n-        f(y);\n-      }\n-      _ { fail \"yuck\"; }\n-    }\n+    alt some(5) { some(y) { check (p(y)); f(y); } _ { fail \"yuck\"; } }\n }"}, {"sha": "9a54dbd5c90f48311211a9d0e2baca278b47dee8", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,6 +3,6 @@\n use std;\n import std::task;\n \n-fn child2(s: -istr) { }\n+fn child2(s: -str) { }\n \n-fn main() { let x = task::spawn(bind child2(~\"hi\")); }\n+fn main() { let x = task::spawn(bind child2(\"hi\")); }"}, {"sha": "efd5d2bb04c5c201257c3837364d55d4d7bc8fcb", "filename": "src/test/run-pass/command-line-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1,3 @@\n \n \n-fn main(args: [istr]) { log args[0]; }\n+fn main(args: [str]) { log args[0]; }"}, {"sha": "56ebc914b9397615f324cdc4b867e4d7249f05af", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let c: uint = 17u;\n     check (le(a, b));\n     c <- a;\n-    log safe_slice(~\"kitties\", c, b);\n+    log safe_slice(\"kitties\", c, b);\n }"}, {"sha": "97285adae0ca50ea4f9e61902eee0f762993c112", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     let b: uint = 4u;\n     check (le(a, b));\n     let c <- a;\n-    log safe_slice(~\"kitties\", c, b);\n+    log safe_slice(\"kitties\", c, b);\n }"}, {"sha": "7b96a89bb168e5973302a9754c1cb6532c22d827", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     let b: uint = 1u;\n     check (le(b, a));\n     b <-> a;\n-    log safe_slice(~\"kitties\", a, b);\n+    log safe_slice(\"kitties\", a, b);\n }"}, {"sha": "71f151f5260935a5b987feb89a1d83514724863d", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     let b: uint = 4u;\n     check (le(a, b));\n     let c = b;\n-    log safe_slice(~\"kitties\", a, c);\n+    log safe_slice(\"kitties\", a, c);\n }"}, {"sha": "f9ea572a735a5624c2464507ad2174fbd745057a", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (le(a, b));\n-    log safe_slice(~\"kitties\", a, b);\n+    log safe_slice(\"kitties\", a, b);\n }"}, {"sha": "2da4a0296fd66e0079f95c52c183d3f52123b00a", "filename": "src/test/run-pass/guards.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fguards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fguards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,16 +1,13 @@\n fn main() {\n-    let a = alt 10 {\n-      x when x < 7 { 1 }\n-      x when x < 11 { 2 }\n-      10 { 3 }\n-      _ { 4 }\n-    };\n-    assert a == 2;\n+    let a =\n+        alt 10 { x when x < 7 { 1 } x when x < 11 { 2 } 10 { 3 } _ { 4 } };\n+    assert (a == 2);\n \n-    let b = alt {x: 10, y: 20} {\n-        x when x.x < 5 && x.y < 5 { 1 }\n-        {x, y} when x == 10 && y == 20 { 2 }\n-        {x, y} { 3 }\n-    };\n-    assert b == 2;\n+    let b =\n+        alt {x: 10, y: 20} {\n+          x when x.x < 5 && x.y < 5 { 1 }\n+          {x: x, y: y} when x == 10 && y == 20 { 2 }\n+          {x: x, y: y} { 3 }\n+        };\n+    assert (b == 2);\n }"}, {"sha": "6d5203f48849f6acd6490820e30125a44cee254f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -19,31 +19,29 @@ import std::comm::send;\n import std::comm::recv;\n import std::comm;\n \n-fn map(filename: &istr, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n+fn map(filename: &str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n \n mod map_reduce {\n     export putter;\n     export mapper;\n     export map_reduce;\n \n-    type putter = fn(&istr, &istr);\n+    type putter = fn(&str, &str);\n \n-    type mapper = fn(&istr, putter);\n+    type mapper = fn(&str, putter);\n \n     tag ctrl_proto { find_reducer([u8], chan<int>); mapper_done; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[istr]) {\n-        for i: istr in inputs {\n-            task::spawn(bind map_task(ctrl, i));\n-        }\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str]) {\n+        for i: str in inputs { task::spawn(bind map_task(ctrl, i)); }\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: -istr) {\n+    fn map_task(ctrl: chan<ctrl_proto>, input: -str) {\n \n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<istr, int>, ctrl: chan<ctrl_proto>,\n-                key: &istr, val: &istr) {\n+        fn emit(im: &map::hashmap<str, int>, ctrl: chan<ctrl_proto>,\n+                key: &str, val: &str) {\n             let c;\n             alt im.find(key) {\n               some(_c) { c = _c }\n@@ -63,13 +61,13 @@ mod map_reduce {\n         send(ctrl, mapper_done);\n     }\n \n-    fn map_reduce(inputs: &[istr]) {\n+    fn map_reduce(inputs: &[str]) {\n         let ctrl = port();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n \n-        let reducers: map::hashmap<istr, int>;\n+        let reducers: map::hashmap<str, int>;\n \n         reducers = map::new_str_hash();\n \n@@ -94,5 +92,5 @@ mod map_reduce {\n }\n \n fn main() {\n-    map_reduce::map_reduce([~\"../src/test/run-pass/hashmap-memory.rs\"]);\n+    map_reduce::map_reduce([\"../src/test/run-pass/hashmap-memory.rs\"]);\n }"}, {"sha": "9e263b734135b433446ed8b78d4e0487ca05f546", "filename": "src/test/run-pass/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport4.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,4 +5,4 @@ mod zed {\n     fn bar() { log \"bar\"; }\n }\n \n-fn main(args: [istr]) { let zed = 42; bar(); }\n+fn main(args: [str]) { let zed = 42; bar(); }"}, {"sha": "9f3ec6d2b459017e6204d9f9606a1bb47024febd", "filename": "src/test/run-pass/import5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport5.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -7,4 +7,4 @@ mod foo {\n     }\n }\n \n-fn main(args: [istr]) { bar(); }\n+fn main(args: [str]) { bar(); }"}, {"sha": "40c3d2357bf3be3ad837c2eeb23735d86f3f2b04", "filename": "src/test/run-pass/import7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fimport7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport7.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,4 +12,4 @@ mod bar {\n         mod zed { }\n     }\n }\n-fn main(args: [istr]) { baz(); }\n+fn main(args: [str]) { baz(); }"}, {"sha": "0306326e8246a340d07da22750625171ee40ff2a", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -36,8 +36,7 @@ fn packager(cb: chan<chan<[u8]>>, msg: chan<msg>) {\n fn main() {\n     let p: port<msg> = port();\n     let recv_reader: port<chan<[u8]>> = port();\n-    let pack =\n-        task::spawn(bind packager(chan(recv_reader), chan(p)));\n+    let pack = task::spawn(bind packager(chan(recv_reader), chan(p)));\n \n     let source_chan: chan<[u8]> = recv(recv_reader);\n     let prod = task::spawn(bind producer(source_chan));"}, {"sha": "affdbd06f17543006835ba49e5fbea7f2ccd0e25", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,60 +1,53 @@\n fn test_stack_assign() {\n-    let s: istr = ~\"a\";\n+    let s: str = \"a\";\n     log s;\n-    let t: istr = ~\"a\";\n-    assert s == t;\n-    let u: istr = ~\"b\";\n-    assert s != u;\n+    let t: str = \"a\";\n+    assert (s == t);\n+    let u: str = \"b\";\n+    assert (s != u);\n }\n \n-fn test_heap_lit() {\n-    ~\"a big string\";\n-}\n+fn test_heap_lit() { \"a big string\"; }\n \n fn test_heap_assign() {\n-    let s: istr = ~\"a big ol' string\";\n-    let t: istr = ~\"a big ol' string\";\n-    assert s == t;\n-    let u: istr = ~\"a bad ol' string\";\n-    assert s != u;\n+    let s: str = \"a big ol' string\";\n+    let t: str = \"a big ol' string\";\n+    assert (s == t);\n+    let u: str = \"a bad ol' string\";\n+    assert (s != u);\n }\n \n-fn test_heap_log() {\n-    let s = ~\"a big ol' string\";\n-    log s;\n-}\n+fn test_heap_log() { let s = \"a big ol' string\"; log s; }\n \n fn test_stack_add() {\n-    assert ~\"a\" + ~\"b\" == ~\"ab\";\n-    let s: istr = ~\"a\";\n-    assert s + s == ~\"aa\";\n-    assert ~\"\" + ~\"\" == ~\"\";\n+    assert (\"a\" + \"b\" == \"ab\");\n+    let s: str = \"a\";\n+    assert (s + s == \"aa\");\n+    assert (\"\" + \"\" == \"\");\n }\n \n-fn test_stack_heap_add() {\n-    assert ~\"a\" + ~\"bracadabra\" == ~\"abracadabra\";\n-}\n+fn test_stack_heap_add() { assert (\"a\" + \"bracadabra\" == \"abracadabra\"); }\n \n fn test_heap_add() {\n-    assert ~\"this should\" + ~\" totally work\" == ~\"this should totally work\";\n+    assert (\"this should\" + \" totally work\" == \"this should totally work\");\n }\n \n fn test_append() {\n-    let s = ~\"\";\n-    s += ~\"a\";\n-    assert s == ~\"a\";\n+    let s = \"\";\n+    s += \"a\";\n+    assert (s == \"a\");\n \n-    let s = ~\"a\";\n-    s += ~\"b\";\n+    let s = \"a\";\n+    s += \"b\";\n     log s;\n-    assert s == ~\"ab\";\n+    assert (s == \"ab\");\n \n-    let s = ~\"c\";\n-    s += ~\"offee\";\n-    assert s == ~\"coffee\";\n+    let s = \"c\";\n+    s += \"offee\";\n+    assert (s == \"coffee\");\n \n-    s += ~\"&tea\";\n-    assert s == ~\"coffee&tea\";\n+    s += \"&tea\";\n+    assert (s == \"coffee&tea\");\n }\n \n fn main() {\n@@ -66,4 +59,4 @@ fn main() {\n     test_stack_heap_add();\n     test_heap_add();\n     test_append();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3701d2290597082b4db8ff3ed43f64ea255d36d7", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -167,7 +167,7 @@ mod test_distinguish_syntax_ext {\n     use std;\n \n     fn f() {\n-        #fmt[\"test%s\", ~\"s\"];\n+        #fmt[\"test%s\", \"s\"];\n         #[attr = \"val\"]\n         fn g() { }\n     }"}, {"sha": "b450a34c4110d6e3f98748ec1a0431350f202915", "filename": "src/test/run-pass/iter-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-ret.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,4 +4,4 @@ iter x() -> int { }\n \n fn f() -> bool { for each i: int in x() { ret true; } ret false; }\n \n-fn main(args: [istr]) { f(); }\n+fn main(args: [str]) { f(); }"}, {"sha": "ec2403a91510bdc76e57e639e00a5950cd461110", "filename": "src/test/run-pass/main-ivec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmain-ivec.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,3 +1 @@\n-fn main(args: [istr]) {\n-    for s in args { log s }\n-}\n+fn main(args: [str]) { for s in args { log s } }"}, {"sha": "c0340387cfe9ca30a763246dbd8a58dba61c39cb", "filename": "src/test/run-pass/native2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fnative2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fnative2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative2.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -14,4 +14,4 @@ native \"cdecl\" mod libc = \"\" {\n \n native \"cdecl\" mod baz = \"\" { }\n \n-fn main(args: [istr]) { }\n+fn main(args: [str]) { }"}, {"sha": "9478735d9323295fc3c39376fb75c58432aa6820", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,30 +3,23 @@ use std;\n import std::list::*;\n \n pure fn pure_length_go<@T>(ls: &list<T>, acc: uint) -> uint {\n-    alt ls {\n-      nil. { acc }\n-      cons(_, tl) { pure_length_go(*tl, acc + 1u) }\n-    }\n+    alt ls { nil. { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n }\n \n-pure fn pure_length<@T>(ls: &list<T>) -> uint {\n-    pure_length_go(ls, 0u)\n-}\n+pure fn pure_length<@T>(ls: &list<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<@T>(ls: &list<T>) -> bool {\n-    pure_length(ls) > 0u\n-}\n+pure fn nonempty_list<@T>(ls: &list<T>) -> bool { pure_length(ls) > 0u }\n \n- // Of course, the compiler can't take advantage of the\n-    // knowledge that ls is a cons node. Future work.\n-    // Also, this is pretty contrived since nonempty_list\n-    // could be a \"tag refinement\", if we implement those.\n+// Of course, the compiler can't take advantage of the\n+// knowledge that ls is a cons node. Future work.\n+// Also, this is pretty contrived since nonempty_list\n+// could be a \"tag refinement\", if we implement those.\n fn safe_head<@T>(ls: &list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);\n     // Again, a way to eliminate such \"obvious\" checks seems\n     // desirable. (Tags could have postconditions.)\n-    check(nonempty_list(mylist));\n-    assert (*(safe_head(mylist)) == 1u);\n-}\n\\ No newline at end of file\n+    check (nonempty_list(mylist));\n+    assert (*safe_head(mylist) == 1u);\n+}"}, {"sha": "4fe43d181218c67c04e8fc156abd25fa67e6a7ad", "filename": "src/test/run-pass/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpath.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,4 +4,4 @@ mod foo {\n     fn bar(offset: uint) { }\n }\n \n-fn main(args: [istr]) { foo::bar(0u); }\n+fn main(args: [str]) { foo::bar(0u); }"}, {"sha": "14e5e2e44cf6591d4ee7eb07ff856a7adb89ab34", "filename": "src/test/run-pass/sio-client.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-client.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -13,9 +13,9 @@ fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n fn main() {\n   let cx: sio::ctx = sio::new();\n   let srv: sio::server = sio::create_server(\n-       cx, net::parse_addr(~\"0.0.0.0\"), 9090);\n+       cx, net::parse_addr(\"0.0.0.0\"), 9090);\n   let child = task::_spawn(bind connectTask(cx,\n-                                            net::parse_addr(~\"127.0.0.1\"),\n+                                            net::parse_addr(\"127.0.0.1\"),\n                                             9090));\n   let client: sio::client = sio::accept_from(srv);\n   task::join_id(child);"}, {"sha": "0085f4983f2cbf93efef992a7dee28690b431a7a", "filename": "src/test/run-pass/sio-read.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-read.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -15,9 +15,9 @@ fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n fn main() {\n   let cx: sio::ctx = sio::new();\n   let srv: sio::server = sio::create_server(\n-          cx, net::parse_addr(~\"0.0.0.0\"), 9090);\n+          cx, net::parse_addr(\"0.0.0.0\"), 9090);\n   let child = task::_spawn(bind connectTask(cx,\n-                                            net::parse_addr(~\"127.0.0.1\"),\n+                                            net::parse_addr(\"127.0.0.1\"),\n                                             9090));\n   let client: sio::client = sio::accept_from(srv);\n   sio::write_data(client, str::bytes(\"hello, world\\n\"));"}, {"sha": "1171971427ec8079a4142abdeb3b05dc84c79629", "filename": "src/test/run-pass/sio-srv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-srv.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,7 +6,7 @@ import std::net;\n fn main() {\n   let cx: sio::ctx = sio::new();\n   let srv: sio::server = sio::create_server(cx,\n-                                            net::parse_addr(~\"127.0.0.1\"),\n+                                            net::parse_addr(\"127.0.0.1\"),\n                                             9090);\n   sio::close_server(srv);\n   sio::destroy(cx);"}, {"sha": "cc372bc916d1af808d766938ea864e1bfb155655", "filename": "src/test/run-pass/sio-write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsio-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-write.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -13,9 +13,9 @@ fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n \n fn main() {\n   let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(cx, net::parse_addr(~\"0.0.0.0\"),\n+  let srv: sio::server = sio::create_server(cx, net::parse_addr(\"0.0.0.0\"),\n                                             9090);\n-  let child = task::_spawn(bind connectTask(cx, net::parse_addr(~\"127.0.0.1\"),\n+  let child = task::_spawn(bind connectTask(cx, net::parse_addr(\"127.0.0.1\"),\n                                             9090));\n   let client: sio::client = sio::accept_from(srv);\n   sio::write_data(client, str::bytes(\"hello, world\\n\"));"}, {"sha": "612fdecb4ab912631a1ec92e075251ee85a13843", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,12 +4,12 @@ use std;\n import std::task::yield;\n import std::task;\n \n-fn x(s: -istr, n: int) { log s; log n; }\n+fn x(s: -str, n: int) { log s; log n; }\n \n fn main() {\n-    task::spawn(bind x(~\"hello from first spawned fn\", 65));\n-    task::spawn(bind x(~\"hello from second spawned fn\", 66));\n-    task::spawn(bind x(~\"hello from third spawned fn\", 67));\n+    task::spawn(bind x(\"hello from first spawned fn\", 65));\n+    task::spawn(bind x(\"hello from second spawned fn\", 66));\n+    task::spawn(bind x(\"hello from third spawned fn\", 67));\n     let i: int = 30;\n     while i > 0 { i = i - 1; log \"parent sleeping\"; yield(); }\n }"}, {"sha": "38bf6afe1e5981fcc8156181b592beb621402d82", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,10 +2,7 @@ use std;\n import std::task::join;\n import std::task::spawn_joinable;\n \n-fn main() {\n-    let x = spawn_joinable(bind m::child(10));\n-    join(x);\n-}\n+fn main() { let x = spawn_joinable(bind m::child(10)); join(x); }\n \n mod m {\n     fn child(i: int) { log i; }"}, {"sha": "3a4ce18f3a285eb41416812dd6d660e9f62c5f01", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -12,9 +12,9 @@ import std::task;\n \n type ctx = comm::chan<int>;\n \n-fn iotask(cx: ctx, ip: -istr) { assert (str::eq(ip, ~\"localhost\")); }\n+fn iotask(cx: ctx, ip: -str) { assert (str::eq(ip, \"localhost\")); }\n \n fn main() {\n     let p = comm::port::<int>();\n-    task::spawn(bind iotask(comm::chan(p), ~\"localhost\"));\n+    task::spawn(bind iotask(comm::chan(p), \"localhost\"));\n }"}, {"sha": "50c599f42af322380baaabbbe80f987b8ae8f309", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,10 +4,7 @@ use std;\n \n import std::task;\n \n-fn main() {\n-    let t = task::spawn_joinable(bind child(10));\n-    task::join(t);\n-}\n+fn main() { let t = task::spawn_joinable(bind child(10)); task::join(t); }\n \n fn child(i: int) { log_err i; assert (i == 10); }\n "}, {"sha": "e1fa92738cb20e542ad60e5b0d6fd40093e3e456", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,22 +5,22 @@ use std;\n import std::str;\n \n fn test1() {\n-    let s: istr = ~\"hello\";\n-    s += ~\"world\";\n+    let s: str = \"hello\";\n+    s += \"world\";\n     log s;\n     assert (s[9] == 'd' as u8);\n }\n \n fn test2() {\n     // This tests for issue #163\n \n-    let ff: istr = ~\"abc\";\n-    let a: istr = ff + ~\"ABC\" + ff;\n-    let b: istr = ~\"ABC\" + ff + ~\"ABC\";\n+    let ff: str = \"abc\";\n+    let a: str = ff + \"ABC\" + ff;\n+    let b: str = \"ABC\" + ff + \"ABC\";\n     log a;\n     log b;\n-    assert (str::eq(a, ~\"abcABCabc\"));\n-    assert (str::eq(b, ~\"ABCabcABC\"));\n+    assert (str::eq(a, \"abcABCabc\"));\n+    assert (str::eq(b, \"ABCabcABC\"));\n }\n \n fn main() { test1(); test2(); }"}, {"sha": "15a130833219ced8dc7aaf02ac8aff9316e0144d", "filename": "src/test/run-pass/str-multiline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-multiline.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,13 +5,13 @@ use std;\n import std::str;\n \n fn main() {\n-    let a: istr = ~\"this \\\n+    let a: str = \"this \\\n is a test\";\n-    let b: istr =\n-        ~\"this \\\n+    let b: str =\n+        \"this \\\n                is \\\n                another \\\n                test\";\n-    assert (str::eq(a, ~\"this is a test\"));\n-    assert (str::eq(b, ~\"this is another test\"));\n+    assert (str::eq(a, \"this is a test\"));\n+    assert (str::eq(b, \"this is another test\"));\n }"}, {"sha": "94a9696adf069b04198157a5a2317216afeed56b", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,7 +3,7 @@ import std::str;\n \n fn main() {\n     // Make sure we properly handle repeated self-appends.\n-    let a: istr = ~\"A\";\n+    let a: str = \"A\";\n     let i = 20;\n     let expected_len = 1u;\n     while i > 0 {"}, {"sha": "88204cfffebdc0333d01ebaa8e80fd429823e20d", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 151, "deletions": 151, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,17 +1,17 @@\n use std;\n import std::str;\n \n-fn test(actual: &istr, expected: &istr) {\n+fn test(actual: &str, expected: &str) {\n     log actual;\n     log expected;\n     assert (str::eq(actual, expected));\n }\n \n fn main() {\n-    test(#fmt[~\"hello %d friends and %s things\", 10, ~\"formatted\"],\n-         ~\"hello 10 friends and formatted things\");\n+    test(#fmt[\"hello %d friends and %s things\", 10, \"formatted\"],\n+         \"hello 10 friends and formatted things\");\n \n-    test(#fmt[~\"test\"], ~\"test\");\n+    test(#fmt[\"test\"], \"test\");\n \n     // a quadratic optimization in LLVM (jump-threading) makes this test a\n     // bit slow to compile unless we break it up\n@@ -26,192 +26,192 @@ fn main() {\n fn part1() {\n     // Simple tests for types\n \n-    test(#fmt[~\"%d\", 1], ~\"1\");\n-    test(#fmt[~\"%i\", 2], ~\"2\");\n-    test(#fmt[~\"%i\", -1], ~\"-1\");\n-    test(#fmt[~\"%u\", 10u], ~\"10\");\n-    test(#fmt[~\"%s\", ~\"test\"], ~\"test\");\n-    test(#fmt[~\"%b\", true], ~\"true\");\n-    test(#fmt[~\"%b\", false], ~\"false\");\n-    test(#fmt[~\"%c\", 'A'], ~\"A\");\n-    test(#fmt[~\"%x\", 0xff_u], ~\"ff\");\n-    test(#fmt[~\"%X\", 0x12ab_u], ~\"12AB\");\n-    test(#fmt[~\"%o\", 10u], ~\"12\");\n-    test(#fmt[~\"%t\", 0b11010101_u], ~\"11010101\");\n+    test(#fmt[\"%d\", 1], \"1\");\n+    test(#fmt[\"%i\", 2], \"2\");\n+    test(#fmt[\"%i\", -1], \"-1\");\n+    test(#fmt[\"%u\", 10u], \"10\");\n+    test(#fmt[\"%s\", \"test\"], \"test\");\n+    test(#fmt[\"%b\", true], \"true\");\n+    test(#fmt[\"%b\", false], \"false\");\n+    test(#fmt[\"%c\", 'A'], \"A\");\n+    test(#fmt[\"%x\", 0xff_u], \"ff\");\n+    test(#fmt[\"%X\", 0x12ab_u], \"12AB\");\n+    test(#fmt[\"%o\", 10u], \"12\");\n+    test(#fmt[\"%t\", 0b11010101_u], \"11010101\");\n     // 32-bit limits\n \n-    test(#fmt[~\"%i\", -2147483648], ~\"-2147483648\");\n-    test(#fmt[~\"%i\", 2147483647], ~\"2147483647\");\n-    test(#fmt[~\"%u\", 4294967295u], ~\"4294967295\");\n-    test(#fmt[~\"%x\", 0xffffffff_u], ~\"ffffffff\");\n-    test(#fmt[~\"%o\", 0xffffffff_u], ~\"37777777777\");\n-    test(#fmt[~\"%t\", 0xffffffff_u], ~\"11111111111111111111111111111111\");\n+    test(#fmt[\"%i\", -2147483648], \"-2147483648\");\n+    test(#fmt[\"%i\", 2147483647], \"2147483647\");\n+    test(#fmt[\"%u\", 4294967295u], \"4294967295\");\n+    test(#fmt[\"%x\", 0xffffffff_u], \"ffffffff\");\n+    test(#fmt[\"%o\", 0xffffffff_u], \"37777777777\");\n+    test(#fmt[\"%t\", 0xffffffff_u], \"11111111111111111111111111111111\");\n }\n fn part2() {\n     // Widths\n \n-    test(#fmt[~\"%1d\", 500], ~\"500\");\n-    test(#fmt[~\"%10d\", 500], ~\"       500\");\n-    test(#fmt[~\"%10d\", -500], ~\"      -500\");\n-    test(#fmt[~\"%10u\", 500u], ~\"       500\");\n-    test(#fmt[~\"%10s\", ~\"test\"], ~\"      test\");\n-    test(#fmt[~\"%10b\", true], ~\"      true\");\n-    test(#fmt[~\"%10x\", 0xff_u], ~\"        ff\");\n-    test(#fmt[~\"%10X\", 0xff_u], ~\"        FF\");\n-    test(#fmt[~\"%10o\", 10u], ~\"        12\");\n-    test(#fmt[~\"%10t\", 0xff_u], ~\"  11111111\");\n-    test(#fmt[~\"%10c\", 'A'], ~\"         A\");\n+    test(#fmt[\"%1d\", 500], \"500\");\n+    test(#fmt[\"%10d\", 500], \"       500\");\n+    test(#fmt[\"%10d\", -500], \"      -500\");\n+    test(#fmt[\"%10u\", 500u], \"       500\");\n+    test(#fmt[\"%10s\", \"test\"], \"      test\");\n+    test(#fmt[\"%10b\", true], \"      true\");\n+    test(#fmt[\"%10x\", 0xff_u], \"        ff\");\n+    test(#fmt[\"%10X\", 0xff_u], \"        FF\");\n+    test(#fmt[\"%10o\", 10u], \"        12\");\n+    test(#fmt[\"%10t\", 0xff_u], \"  11111111\");\n+    test(#fmt[\"%10c\", 'A'], \"         A\");\n     // Left justify\n \n-    test(#fmt[~\"%-10d\", 500], ~\"500       \");\n-    test(#fmt[~\"%-10d\", -500], ~\"-500      \");\n-    test(#fmt[~\"%-10u\", 500u], ~\"500       \");\n-    test(#fmt[~\"%-10s\", ~\"test\"], ~\"test      \");\n-    test(#fmt[~\"%-10b\", true], ~\"true      \");\n-    test(#fmt[~\"%-10x\", 0xff_u], ~\"ff        \");\n-    test(#fmt[~\"%-10X\", 0xff_u], ~\"FF        \");\n-    test(#fmt[~\"%-10o\", 10u], ~\"12        \");\n-    test(#fmt[~\"%-10t\", 0xff_u], ~\"11111111  \");\n-    test(#fmt[~\"%-10c\", 'A'], ~\"A         \");\n+    test(#fmt[\"%-10d\", 500], \"500       \");\n+    test(#fmt[\"%-10d\", -500], \"-500      \");\n+    test(#fmt[\"%-10u\", 500u], \"500       \");\n+    test(#fmt[\"%-10s\", \"test\"], \"test      \");\n+    test(#fmt[\"%-10b\", true], \"true      \");\n+    test(#fmt[\"%-10x\", 0xff_u], \"ff        \");\n+    test(#fmt[\"%-10X\", 0xff_u], \"FF        \");\n+    test(#fmt[\"%-10o\", 10u], \"12        \");\n+    test(#fmt[\"%-10t\", 0xff_u], \"11111111  \");\n+    test(#fmt[\"%-10c\", 'A'], \"A         \");\n }\n \n fn part3() {\n     // Precision\n \n-    test(#fmt[~\"%.d\", 0], ~\"\");\n-    test(#fmt[~\"%.u\", 0u], ~\"\");\n-    test(#fmt[~\"%.x\", 0u], ~\"\");\n-    test(#fmt[~\"%.t\", 0u], ~\"\");\n-    test(#fmt[~\"%.d\", 10], ~\"10\");\n-    test(#fmt[~\"%.d\", -10], ~\"-10\");\n-    test(#fmt[~\"%.u\", 10u], ~\"10\");\n-    test(#fmt[~\"%.s\", ~\"test\"], ~\"\");\n-    test(#fmt[~\"%.x\", 127u], ~\"7f\");\n-    test(#fmt[~\"%.o\", 10u], ~\"12\");\n-    test(#fmt[~\"%.t\", 3u], ~\"11\");\n-    test(#fmt[~\"%.c\", 'A'], ~\"A\");\n-    test(#fmt[~\"%.0d\", 0], ~\"\");\n-    test(#fmt[~\"%.0u\", 0u], ~\"\");\n-    test(#fmt[~\"%.0x\", 0u], ~\"\");\n-    test(#fmt[~\"%.0t\", 0u], ~\"\");\n-    test(#fmt[~\"%.0d\", 10], ~\"10\");\n-    test(#fmt[~\"%.0d\", -10], ~\"-10\");\n-    test(#fmt[~\"%.0u\", 10u], ~\"10\");\n-    test(#fmt[~\"%.0s\", ~\"test\"], ~\"\");\n-    test(#fmt[~\"%.0x\", 127u], ~\"7f\");\n-    test(#fmt[~\"%.0o\", 10u], ~\"12\");\n-    test(#fmt[~\"%.0t\", 3u], ~\"11\");\n-    test(#fmt[~\"%.0c\", 'A'], ~\"A\");\n-    test(#fmt[~\"%.1d\", 0], ~\"0\");\n-    test(#fmt[~\"%.1u\", 0u], ~\"0\");\n-    test(#fmt[~\"%.1x\", 0u], ~\"0\");\n-    test(#fmt[~\"%.1t\", 0u], ~\"0\");\n-    test(#fmt[~\"%.1d\", 10], ~\"10\");\n-    test(#fmt[~\"%.1d\", -10], ~\"-10\");\n-    test(#fmt[~\"%.1u\", 10u], ~\"10\");\n-    test(#fmt[~\"%.1s\", ~\"test\"], ~\"t\");\n-    test(#fmt[~\"%.1x\", 127u], ~\"7f\");\n-    test(#fmt[~\"%.1o\", 10u], ~\"12\");\n-    test(#fmt[~\"%.1t\", 3u], ~\"11\");\n-    test(#fmt[~\"%.1c\", 'A'], ~\"A\");\n+    test(#fmt[\"%.d\", 0], \"\");\n+    test(#fmt[\"%.u\", 0u], \"\");\n+    test(#fmt[\"%.x\", 0u], \"\");\n+    test(#fmt[\"%.t\", 0u], \"\");\n+    test(#fmt[\"%.d\", 10], \"10\");\n+    test(#fmt[\"%.d\", -10], \"-10\");\n+    test(#fmt[\"%.u\", 10u], \"10\");\n+    test(#fmt[\"%.s\", \"test\"], \"\");\n+    test(#fmt[\"%.x\", 127u], \"7f\");\n+    test(#fmt[\"%.o\", 10u], \"12\");\n+    test(#fmt[\"%.t\", 3u], \"11\");\n+    test(#fmt[\"%.c\", 'A'], \"A\");\n+    test(#fmt[\"%.0d\", 0], \"\");\n+    test(#fmt[\"%.0u\", 0u], \"\");\n+    test(#fmt[\"%.0x\", 0u], \"\");\n+    test(#fmt[\"%.0t\", 0u], \"\");\n+    test(#fmt[\"%.0d\", 10], \"10\");\n+    test(#fmt[\"%.0d\", -10], \"-10\");\n+    test(#fmt[\"%.0u\", 10u], \"10\");\n+    test(#fmt[\"%.0s\", \"test\"], \"\");\n+    test(#fmt[\"%.0x\", 127u], \"7f\");\n+    test(#fmt[\"%.0o\", 10u], \"12\");\n+    test(#fmt[\"%.0t\", 3u], \"11\");\n+    test(#fmt[\"%.0c\", 'A'], \"A\");\n+    test(#fmt[\"%.1d\", 0], \"0\");\n+    test(#fmt[\"%.1u\", 0u], \"0\");\n+    test(#fmt[\"%.1x\", 0u], \"0\");\n+    test(#fmt[\"%.1t\", 0u], \"0\");\n+    test(#fmt[\"%.1d\", 10], \"10\");\n+    test(#fmt[\"%.1d\", -10], \"-10\");\n+    test(#fmt[\"%.1u\", 10u], \"10\");\n+    test(#fmt[\"%.1s\", \"test\"], \"t\");\n+    test(#fmt[\"%.1x\", 127u], \"7f\");\n+    test(#fmt[\"%.1o\", 10u], \"12\");\n+    test(#fmt[\"%.1t\", 3u], \"11\");\n+    test(#fmt[\"%.1c\", 'A'], \"A\");\n }\n fn part4() {\n-    test(#fmt[~\"%.5d\", 0], ~\"00000\");\n-    test(#fmt[~\"%.5u\", 0u], ~\"00000\");\n-    test(#fmt[~\"%.5x\", 0u], ~\"00000\");\n-    test(#fmt[~\"%.5t\", 0u], ~\"00000\");\n-    test(#fmt[~\"%.5d\", 10], ~\"00010\");\n-    test(#fmt[~\"%.5d\", -10], ~\"-00010\");\n-    test(#fmt[~\"%.5u\", 10u], ~\"00010\");\n-    test(#fmt[~\"%.5s\", ~\"test\"], ~\"test\");\n-    test(#fmt[~\"%.5x\", 127u], ~\"0007f\");\n-    test(#fmt[~\"%.5o\", 10u], ~\"00012\");\n-    test(#fmt[~\"%.5t\", 3u], ~\"00011\");\n-    test(#fmt[~\"%.5c\", 'A'], ~\"A\");\n+    test(#fmt[\"%.5d\", 0], \"00000\");\n+    test(#fmt[\"%.5u\", 0u], \"00000\");\n+    test(#fmt[\"%.5x\", 0u], \"00000\");\n+    test(#fmt[\"%.5t\", 0u], \"00000\");\n+    test(#fmt[\"%.5d\", 10], \"00010\");\n+    test(#fmt[\"%.5d\", -10], \"-00010\");\n+    test(#fmt[\"%.5u\", 10u], \"00010\");\n+    test(#fmt[\"%.5s\", \"test\"], \"test\");\n+    test(#fmt[\"%.5x\", 127u], \"0007f\");\n+    test(#fmt[\"%.5o\", 10u], \"00012\");\n+    test(#fmt[\"%.5t\", 3u], \"00011\");\n+    test(#fmt[\"%.5c\", 'A'], \"A\");\n     // Bool precision. I'm not sure if it's good or bad to have bool\n     // conversions support precision - it's not standard printf so we\n     // can do whatever. For now I'm making it behave the same as string\n     // conversions.\n \n-    test(#fmt[~\"%.b\", true], ~\"\");\n-    test(#fmt[~\"%.0b\", true], ~\"\");\n-    test(#fmt[~\"%.1b\", true], ~\"t\");\n+    test(#fmt[\"%.b\", true], \"\");\n+    test(#fmt[\"%.0b\", true], \"\");\n+    test(#fmt[\"%.1b\", true], \"t\");\n }\n \n fn part5() {\n     // Explicit + sign. Only for signed conversions\n \n-    test(#fmt[~\"%+d\", 0], ~\"+0\");\n-    test(#fmt[~\"%+d\", 1], ~\"+1\");\n-    test(#fmt[~\"%+d\", -1], ~\"-1\");\n+    test(#fmt[\"%+d\", 0], \"+0\");\n+    test(#fmt[\"%+d\", 1], \"+1\");\n+    test(#fmt[\"%+d\", -1], \"-1\");\n     // Leave space for sign\n \n-    test(#fmt[~\"% d\", 0], ~\" 0\");\n-    test(#fmt[~\"% d\", 1], ~\" 1\");\n-    test(#fmt[~\"% d\", -1], ~\"-1\");\n+    test(#fmt[\"% d\", 0], \" 0\");\n+    test(#fmt[\"% d\", 1], \" 1\");\n+    test(#fmt[\"% d\", -1], \"-1\");\n     // Plus overrides space\n \n-    test(#fmt[~\"% +d\", 0], ~\"+0\");\n-    test(#fmt[~\"%+ d\", 0], ~\"+0\");\n+    test(#fmt[\"% +d\", 0], \"+0\");\n+    test(#fmt[\"%+ d\", 0], \"+0\");\n     // 0-padding\n \n-    test(#fmt[~\"%05d\", 0], ~\"00000\");\n-    test(#fmt[~\"%05d\", 1], ~\"00001\");\n-    test(#fmt[~\"%05d\", -1], ~\"-0001\");\n-    test(#fmt[~\"%05u\", 1u], ~\"00001\");\n-    test(#fmt[~\"%05x\", 127u], ~\"0007f\");\n-    test(#fmt[~\"%05X\", 127u], ~\"0007F\");\n-    test(#fmt[~\"%05o\", 10u], ~\"00012\");\n-    test(#fmt[~\"%05t\", 3u], ~\"00011\");\n+    test(#fmt[\"%05d\", 0], \"00000\");\n+    test(#fmt[\"%05d\", 1], \"00001\");\n+    test(#fmt[\"%05d\", -1], \"-0001\");\n+    test(#fmt[\"%05u\", 1u], \"00001\");\n+    test(#fmt[\"%05x\", 127u], \"0007f\");\n+    test(#fmt[\"%05X\", 127u], \"0007F\");\n+    test(#fmt[\"%05o\", 10u], \"00012\");\n+    test(#fmt[\"%05t\", 3u], \"00011\");\n     // 0-padding a string is undefined but glibc does this:\n \n-    test(#fmt[~\"%05s\", ~\"test\"], ~\" test\");\n-    test(#fmt[~\"%05c\", 'A'], ~\"    A\");\n-    test(#fmt[~\"%05b\", true], ~\" true\");\n+    test(#fmt[\"%05s\", \"test\"], \" test\");\n+    test(#fmt[\"%05c\", 'A'], \"    A\");\n+    test(#fmt[\"%05b\", true], \" true\");\n     // Left-justify overrides 0-padding\n \n-    test(#fmt[~\"%-05d\", 0], ~\"0    \");\n-    test(#fmt[~\"%-05d\", 1], ~\"1    \");\n-    test(#fmt[~\"%-05d\", -1], ~\"-1   \");\n-    test(#fmt[~\"%-05u\", 1u], ~\"1    \");\n-    test(#fmt[~\"%-05x\", 127u], ~\"7f   \");\n-    test(#fmt[~\"%-05X\", 127u], ~\"7F   \");\n-    test(#fmt[~\"%-05o\", 10u], ~\"12   \");\n-    test(#fmt[~\"%-05t\", 3u], ~\"11   \");\n-    test(#fmt[~\"%-05s\", ~\"test\"], ~\"test \");\n-    test(#fmt[~\"%-05c\", 'A'], ~\"A    \");\n-    test(#fmt[~\"%-05b\", true], ~\"true \");\n+    test(#fmt[\"%-05d\", 0], \"0    \");\n+    test(#fmt[\"%-05d\", 1], \"1    \");\n+    test(#fmt[\"%-05d\", -1], \"-1   \");\n+    test(#fmt[\"%-05u\", 1u], \"1    \");\n+    test(#fmt[\"%-05x\", 127u], \"7f   \");\n+    test(#fmt[\"%-05X\", 127u], \"7F   \");\n+    test(#fmt[\"%-05o\", 10u], \"12   \");\n+    test(#fmt[\"%-05t\", 3u], \"11   \");\n+    test(#fmt[\"%-05s\", \"test\"], \"test \");\n+    test(#fmt[\"%-05c\", 'A'], \"A    \");\n+    test(#fmt[\"%-05b\", true], \"true \");\n }\n fn part6() {\n     // Precision overrides 0-padding\n \n-    test(#fmt[~\"%06.5d\", 0], ~\" 00000\");\n-    test(#fmt[~\"%06.5u\", 0u], ~\" 00000\");\n-    test(#fmt[~\"%06.5x\", 0u], ~\" 00000\");\n-    test(#fmt[~\"%06.5d\", 10], ~\" 00010\");\n-    test(#fmt[~\"%06.5d\", -10], ~\"-00010\");\n-    test(#fmt[~\"%06.5u\", 10u], ~\" 00010\");\n-    test(#fmt[~\"%06.5s\", ~\"test\"], ~\"  test\");\n-    test(#fmt[~\"%06.5c\", 'A'], ~\"     A\");\n-    test(#fmt[~\"%06.5x\", 127u], ~\" 0007f\");\n-    test(#fmt[~\"%06.5X\", 127u], ~\" 0007F\");\n-    test(#fmt[~\"%06.5o\", 10u], ~\" 00012\");\n+    test(#fmt[\"%06.5d\", 0], \" 00000\");\n+    test(#fmt[\"%06.5u\", 0u], \" 00000\");\n+    test(#fmt[\"%06.5x\", 0u], \" 00000\");\n+    test(#fmt[\"%06.5d\", 10], \" 00010\");\n+    test(#fmt[\"%06.5d\", -10], \"-00010\");\n+    test(#fmt[\"%06.5u\", 10u], \" 00010\");\n+    test(#fmt[\"%06.5s\", \"test\"], \"  test\");\n+    test(#fmt[\"%06.5c\", 'A'], \"     A\");\n+    test(#fmt[\"%06.5x\", 127u], \" 0007f\");\n+    test(#fmt[\"%06.5X\", 127u], \" 0007F\");\n+    test(#fmt[\"%06.5o\", 10u], \" 00012\");\n     // Signed combinations\n \n-    test(#fmt[~\"% 5d\", 1], ~\"    1\");\n-    test(#fmt[~\"% 5d\", -1], ~\"   -1\");\n-    test(#fmt[~\"%+5d\", 1], ~\"   +1\");\n-    test(#fmt[~\"%+5d\", -1], ~\"   -1\");\n-    test(#fmt[~\"% 05d\", 1], ~\" 0001\");\n-    test(#fmt[~\"% 05d\", -1], ~\"-0001\");\n-    test(#fmt[~\"%+05d\", 1], ~\"+0001\");\n-    test(#fmt[~\"%+05d\", -1], ~\"-0001\");\n-    test(#fmt[~\"%- 5d\", 1], ~\" 1   \");\n-    test(#fmt[~\"%- 5d\", -1], ~\"-1   \");\n-    test(#fmt[~\"%-+5d\", 1], ~\"+1   \");\n-    test(#fmt[~\"%-+5d\", -1], ~\"-1   \");\n-    test(#fmt[~\"%- 05d\", 1], ~\" 1   \");\n-    test(#fmt[~\"%- 05d\", -1], ~\"-1   \");\n-    test(#fmt[~\"%-+05d\", 1], ~\"+1   \");\n-    test(#fmt[~\"%-+05d\", -1], ~\"-1   \");\n+    test(#fmt[\"% 5d\", 1], \"    1\");\n+    test(#fmt[\"% 5d\", -1], \"   -1\");\n+    test(#fmt[\"%+5d\", 1], \"   +1\");\n+    test(#fmt[\"%+5d\", -1], \"   -1\");\n+    test(#fmt[\"% 05d\", 1], \" 0001\");\n+    test(#fmt[\"% 05d\", -1], \"-0001\");\n+    test(#fmt[\"%+05d\", 1], \"+0001\");\n+    test(#fmt[\"%+05d\", -1], \"-0001\");\n+    test(#fmt[\"%- 5d\", 1], \" 1   \");\n+    test(#fmt[\"%- 5d\", -1], \"-1   \");\n+    test(#fmt[\"%-+5d\", 1], \"+1   \");\n+    test(#fmt[\"%-+5d\", -1], \"-1   \");\n+    test(#fmt[\"%- 05d\", 1], \" 1   \");\n+    test(#fmt[\"%- 05d\", -1], \"-1   \");\n+    test(#fmt[\"%-+05d\", 1], \"+1   \");\n+    test(#fmt[\"%-+05d\", -1], \"-1   \");\n }"}, {"sha": "d76ee9ed12ae34cc72e03f859691df14d039706b", "filename": "src/test/run-pass/tag-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftag-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftag-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-in-block.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,4 +6,4 @@ fn foo() {\n     fn baz() { zed(nil); }\n }\n \n-fn main(args: [istr]) { }\n+fn main(args: [str]) { }"}, {"sha": "d0022341f8d1818691985628826f29d31e6f828c", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -4,10 +4,6 @@\n // -*- rust -*-\n tag colour { red(int, int); green; }\n \n-fn f() {\n-    let x = red(1, 2);\n-    let y = green;\n-    assert (x != y);\n-}\n+fn f() { let x = red(1, 2); let y = green; assert (x != y); }\n \n fn main() { f(); }"}, {"sha": "d272410be80b45a67703d7860bf7cf7279162ea9", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::task;\n-fn main() { task::spawn(bind child(~\"Hello\")); }\n+fn main() { task::spawn(bind child(\"Hello\")); }\n \n fn child(s: -str) {\n "}, {"sha": "8e03219708537ee27f143add106c8e24e825a06f", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -3,41 +3,21 @@\n \n use std;\n \n-fn test_break() {\n-    while true {\n-        let x: @int = break;\n-    }\n-}\n+fn test_break() { while true { let x: @int = break; } }\n \n-fn test_cont() {\n-    let i = 0;\n-    while i < 1 {\n-        i += 1;\n-        let x: @int = cont;\n-    }\n-}\n+fn test_cont() { let i = 0; while i < 1 { i += 1; let x: @int = cont; } }\n \n-fn test_ret() {\n-    let x: @int = ret;\n-}\n+fn test_ret() { let x: @int = ret; }\n \n fn test_fail() {\n-    fn f() {\n-        std::task::unsupervise();\n-        let x: @int = fail;\n-    }\n+    fn f() { std::task::unsupervise(); let x: @int = fail; }\n     let g = f;\n     std::task::spawn(g);\n }\n \n fn test_fail_indirect() {\n-    fn f() -> ! {\n-        fail;\n-    }\n-    fn g() {\n-        std::task::unsupervise();\n-        let x: @int = f();\n-    }\n+    fn f() -> ! { fail; }\n+    fn g() { std::task::unsupervise(); let x: @int = f(); }\n     let h = g;\n     std::task::spawn(h);\n }\n@@ -48,4 +28,4 @@ fn main() {\n     test_ret();\n     test_fail();\n     test_fail_indirect();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "be55ba86cac0b794e113b63098e33c4aa8f6971e", "filename": "src/test/run-pass/type-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftype-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftype-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,4 +2,4 @@\n \n type lteq<T> = fn(&T) -> bool;\n \n-fn main(args: [istr]) { }\n+fn main(args: [str]) { }"}, {"sha": "e608a9f9836ca55af7922267c1d92743193b3506", "filename": "src/test/run-pass/type-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftype-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Ftype-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-ptr.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,4 +2,4 @@ fn f(a: *int) -> *int { ret a; }\n \n fn g(a: *int) -> *int { let b = f(a); ret b; }\n \n-fn main(args: [istr]) { ret; }\n+fn main(args: [str]) { ret; }"}, {"sha": "d456f1f2e90ac5a0008a934b114b94ec56972f0a", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -6,35 +6,28 @@ import std::list::*;\n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n fn pure_foldl<@T, @U>(ls: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U {\n-    alt ls {\n-      nil. { u }\n-      cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n-    }\n+    alt ls { nil. { u } cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) } }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n // fn from a pure fn\n pure fn pure_length<@T>(ls: &list<T>) -> uint {\n     fn count<T>(_t: &T, u: &uint) -> uint { u + 1u }\n-    unchecked {\n-        pure_foldl(ls, 0u, count)\n-    }\n+    unchecked{ pure_foldl(ls, 0u, count) }\n }\n \n-pure fn nonempty_list<@T>(ls: &list<T>) -> bool {\n-    pure_length(ls) > 0u\n-}\n+pure fn nonempty_list<@T>(ls: &list<T>) -> bool { pure_length(ls) > 0u }\n \n- // Of course, the compiler can't take advantage of the\n-    // knowledge that ls is a cons node. Future work.\n-    // Also, this is pretty contrived since nonempty_list\n-    // could be a \"tag refinement\", if we implement those.\n+// Of course, the compiler can't take advantage of the\n+// knowledge that ls is a cons node. Future work.\n+// Also, this is pretty contrived since nonempty_list\n+// could be a \"tag refinement\", if we implement those.\n fn safe_head<@T>(ls: &list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);\n     // Again, a way to eliminate such \"obvious\" checks seems\n     // desirable. (Tags could have postconditions.)\n-    check(nonempty_list(mylist));\n-    assert (*(safe_head(mylist)) == 1u);\n-}\n\\ No newline at end of file\n+    check (nonempty_list(mylist));\n+    assert (*safe_head(mylist) == 1u);\n+}"}, {"sha": "e7f7f9a15246b13dce1bb3af2ab585c00ee4b2e7", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,7 +5,7 @@ import std::vec;\n fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n-    let s: istr = str::from_chars(chs);\n+    let s: str = str::from_chars(chs);\n \n     assert (str::byte_len(s) == 10u);\n     assert (str::char_len(s) == 4u);\n@@ -19,13 +19,13 @@ fn main() {\n     assert (!str::is_utf8([0xc0_u8]));\n     assert (!str::is_utf8([0xc0_u8, 0x10_u8]));\n \n-    let stack = ~\"a\u00d7c\u20ac\";\n+    let stack = \"a\u00d7c\u20ac\";\n     assert (str::pop_char(stack) == '\u20ac');\n     assert (str::pop_char(stack) == 'c');\n     str::push_char(stack, 'u');\n-    assert (str::eq(stack, ~\"a\u00d7u\"));\n+    assert (str::eq(stack, \"a\u00d7u\"));\n     assert (str::shift_char(stack) == 'a');\n     assert (str::shift_char(stack) == '\u00d7');\n     str::unshift_char(stack, '\u00df');\n-    assert (str::eq(stack, ~\"\u00dfu\"));\n+    assert (str::eq(stack, \"\u00dfu\"));\n }"}, {"sha": "8e023cf03da070da3a063fe1c721b5399a98c0e9", "filename": "src/test/run-pass/vec-self-append.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-self-append.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,31 +5,31 @@ fn test_heap_to_heap() {\n     // a spills onto the heap\n     let a = [0, 1, 2, 3, 4];\n     a += a;\n-    assert vec::len(a) == 10u;\n-    assert a[0] == 0;\n-    assert a[1] == 1;\n-    assert a[2] == 2;\n-    assert a[3] == 3;\n-    assert a[4] == 4;\n-    assert a[5] == 0;\n-    assert a[6] == 1;\n-    assert a[7] == 2;\n-    assert a[8] == 3;\n-    assert a[9] == 4;\n+    assert (vec::len(a) == 10u);\n+    assert (a[0] == 0);\n+    assert (a[1] == 1);\n+    assert (a[2] == 2);\n+    assert (a[3] == 3);\n+    assert (a[4] == 4);\n+    assert (a[5] == 0);\n+    assert (a[6] == 1);\n+    assert (a[7] == 2);\n+    assert (a[8] == 3);\n+    assert (a[9] == 4);\n }\n \n fn test_stack_to_heap() {\n     // a is entirely on the stack\n     let a = [0, 1, 2];\n     // a spills to the heap\n     a += a;\n-    assert vec::len(a) == 6u;\n-    assert a[0] == 0;\n-    assert a[1] == 1;\n-    assert a[2] == 2;\n-    assert a[3] == 0;\n-    assert a[4] == 1;\n-    assert a[5] == 2;\n+    assert (vec::len(a) == 6u);\n+    assert (a[0] == 0);\n+    assert (a[1] == 1);\n+    assert (a[2] == 2);\n+    assert (a[3] == 0);\n+    assert (a[4] == 1);\n+    assert (a[5] == 2);\n }\n \n fn test_loop() {\n@@ -46,8 +46,4 @@ fn test_loop() {\n     }\n }\n \n-fn main() {\n-    test_heap_to_heap();\n-    test_stack_to_heap();\n-    test_loop();\n-}\n+fn main() { test_heap_to_heap(); test_stack_to_heap(); test_loop(); }"}, {"sha": "6a2e9acfda316d88b489af45193843cbb2397bf2", "filename": "src/test/run-pass/while-cont.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fwhile-cont.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fwhile-cont.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-cont.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -1,10 +1,2 @@\n // Issue #825: Should recheck the loop contition after continuing\n-fn main() {\n-    let i = 1;\n-    while i > 0 {\n-        assert i > 0;\n-        log i;\n-        i -= 1;\n-        cont;\n-    }\n-}\n\\ No newline at end of file\n+fn main() { let i = 1; while i > 0 { assert (i > 0); log i; i -= 1; cont; } }"}, {"sha": "b2ccf09388372d9b3b7640cc299f8a7837db24c8", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -9,15 +9,15 @@ import std::vec::*;\n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;\n     // Silly, but necessary\n-    check u8::le(a, j);\n-    check uint::le(k, l);\n+    check (u8::le(a, j));\n+    check (uint::le(k, l));\n     let chars = enum_chars(a, j);\n-    let ints  = enum_uints(k, l);\n+    let ints = enum_uints(k, l);\n \n-    check same_length(chars, ints);\n+    check (same_length(chars, ints));\n     let ps = zip(chars, ints);\n \n-    check is_not_empty(ps);\n+    check (is_not_empty(ps));\n     assert (head(ps) == ('a', 1u));\n     assert (last_total(ps) == (j as char, 10u));\n }"}, {"sha": "9c31c5e6f7247bd420bdfa99ed742c5326fd94d8", "filename": "src/test/stdtest/comm.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fcomm.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -2,10 +2,7 @@ use std;\n import std::comm;\n \n #[test]\n-fn create_port_and_chan() {\n-    let p = comm::port::<int>();\n-    comm::chan(p);\n-}\n+fn create_port_and_chan() { let p = comm::port::<int>(); comm::chan(p); }\n \n #[test]\n fn send_recv_fn() {"}, {"sha": "36e8ae23c5d0e9da44ed98f81284b1b7f2d7d5ef", "filename": "src/test/stdtest/fs.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffs.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b", "patch": "@@ -5,28 +5,26 @@ import std::fs;\n #[test]\n fn test_connect() {\n     let slash = fs::path_sep();\n-    log_err fs::connect(~\"a\", ~\"b\");\n-    assert (fs::connect(~\"a\", ~\"b\") == ~\"a\" + slash + ~\"b\");\n-    assert (fs::connect(~\"a\" + slash, ~\"b\") == ~\"a\" + slash + ~\"b\");\n+    log_err fs::connect(\"a\", \"b\");\n+    assert (fs::connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n+    assert (fs::connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n }\n \n // Issue #712\n #[test]\n-fn test_list_dir_no_invalid_memory_access() { fs::list_dir(~\".\"); }\n+fn test_list_dir_no_invalid_memory_access() { fs::list_dir(\".\"); }\n \n #[test]\n fn list_dir() {\n-    let dirs = fs::list_dir(~\".\");\n+    let dirs = fs::list_dir(\".\");\n     // Just assuming that we've got some contents in the current directory\n-    assert std::vec::len(dirs) > 0u;\n+    assert (std::vec::len(dirs) > 0u);\n \n-    for dir in dirs {\n-        log dir;\n-    }\n+    for dir in dirs { log dir; }\n }\n \n #[test]\n fn file_is_dir() {\n-    assert fs::file_is_dir(~\".\");\n-    assert !fs::file_is_dir(~\"test/stdtest/fs.rs\");\n-}\n\\ No newline at end of file\n+    assert (fs::file_is_dir(\".\"));\n+    assert (!fs::file_is_dir(\"test/stdtest/fs.rs\"));\n+}"}, {"sha": "55d677291291acbf85b4f42c8305d5c2dc35baf4", "filename": "src/test/stdtest/getopts.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "61d3448a175e9827806f920c4117c61bc7d47a7a", "filename": "src/test/stdtest/int.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fint.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "08330c619fc7ed2ef1aabf88c7c3a84e28d5379b", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "67240a7c69b9c2f0243c5f6fd392ad2d84bd4bc0", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 70, "deletions": 74, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "9da7a12a0607ba993f08e3a66f42179503be3d1b", "filename": "src/test/stdtest/net.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fnet.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "49ebb217dbf84664610bae9bb2c7d4bd9846836d", "filename": "src/test/stdtest/os.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fos.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "911bc6b0dd9098e5711b70e852e7278204a445d2", "filename": "src/test/stdtest/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fpath.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "609adf3afe473dd8d780c7c9155d327f6815da72", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "b60a3935500c489c66e5cf17a4550af4c29b3a94", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "6b72be20dd50a6b901d923227b363424e6daf874", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "2852822f8d4ffb7eeb6e9d66e6ff3c9cb17eccc6", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 135, "deletions": 144, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "56cafe9217a0ef89f570f845456f75db328790cc", "filename": "src/test/stdtest/sys.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsys.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "8c1776aa36fc2551965645f7ac5d7284d5a2f2ee", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "eaecb80ba6bb2889a013eef4680382224fb22875", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "0f4119c6c3dca53b84fb0cdd6023590edcfbd3b3", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}, {"sha": "6194c461c151a9962cdc9abdd595216f539a2d3f", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f061591acec9f06445340cb32cf0e87929b6d9b/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=5f061591acec9f06445340cb32cf0e87929b6d9b"}]}