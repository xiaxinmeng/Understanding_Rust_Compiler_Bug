{"sha": "f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYTg0MGNjMzg1Nzk4ZmMyZTNlOWFjOWRkYjBkZDU3ZmQwYWM1MDk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-31T10:32:00Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-31T10:32:00Z"}, "message": "Lexer: extract string lexing to a separate file", "tree": {"sha": "702e0d346b4d5aab3fe16c554aa878d08aa527c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/702e0d346b4d5aab3fe16c554aa878d08aa527c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "html_url": "https://github.com/rust-lang/rust/commit/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5138bf11eb0c979c49f904010d2d3690bdf74c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5138bf11eb0c979c49f904010d2d3690bdf74c", "html_url": "https://github.com/rust-lang/rust/commit/9d5138bf11eb0c979c49f904010d2d3690bdf74c"}], "stats": {"total": 137, "additions": 88, "deletions": 49}, "files": [{"sha": "ccc25b8c950e454a6c8eac7475c3b99f3db52a71", "filename": "src/lexer/mod.rs", "status": "modified", "additions": 23, "deletions": 49, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509/src%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509/src%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fmod.rs?ref=f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "patch": "@@ -10,6 +10,9 @@ use self::classes::*;\n mod numbers;\n use self::numbers::scan_number;\n \n+mod strings;\n+use self::strings::{string_literal_start, scan_char, scan_byte_char_or_string};\n+\n pub fn next_token(text: &str) -> Token {\n     assert!(!text.is_empty());\n     let mut ptr = Ptr::new(text);\n@@ -101,7 +104,26 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             _ => NOT,\n         },\n \n-        '\\'' => return scan_char_or_lifetime(ptr),\n+        // If the character is an ident start not followed by another single\n+        // quote, then this is a lifetime name:\n+        '\\'' => return if ptr.next_is_p(is_ident_start) && !ptr.nnext_is('\\'') {\n+            ptr.bump();\n+            while ptr.next_is_p(is_ident_continue) {\n+                ptr.bump();\n+            }\n+            // lifetimes shouldn't end with a single quote\n+            // if we find one, then this is an invalid character literal\n+            if ptr.next_is('\\'') {\n+                ptr.bump();\n+                return CHAR; // TODO: error reporting\n+            }\n+            LIFETIME\n+        } else {\n+            scan_char(ptr);\n+            scan_literal_suffix(ptr);\n+            CHAR\n+        },\n+        'b' => return scan_byte_char_or_string(ptr),\n         _ => (),\n     }\n     ERROR\n@@ -120,57 +142,9 @@ fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     IDENT\n }\n \n-fn scan_char_or_lifetime(ptr: &mut Ptr) -> SyntaxKind {\n-    // Either a character constant 'a' OR a lifetime name 'abc\n-    let c = match ptr.bump() {\n-        Some(c) => c,\n-        None => return CHAR, // TODO: error reporting is upper in the stack\n-    };\n-\n-    // If the character is an ident start not followed by another single\n-    // quote, then this is a lifetime name:\n-    if is_ident_start(c) && !ptr.next_is('\\'') {\n-        while ptr.next_is_p(is_ident_continue) {\n-            ptr.bump();\n-        }\n-\n-        // lifetimes shouldn't end with a single quote\n-        // if we find one, then this is an invalid character literal\n-        if ptr.next_is('\\'') {\n-            ptr.bump();\n-            return CHAR;\n-        }\n-        return LIFETIME;\n-    }\n-    scan_char_or_byte(ptr);\n-    if !ptr.next_is('\\'') {\n-        return CHAR; // TODO: error reporting\n-    }\n-    ptr.bump();\n-    scan_literal_suffix(ptr);\n-    CHAR\n-}\n-\n fn scan_literal_suffix(ptr: &mut Ptr) {\n     if ptr.next_is_p(is_ident_start) {\n         ptr.bump();\n     }\n     ptr.bump_while(is_ident_continue);\n }\n-\n-fn scan_char_or_byte(ptr: &mut Ptr) {\n-    //FIXME: deal with escape sequencies\n-    ptr.bump();\n-}\n-\n-fn string_literal_start(c: char, c1: Option<char>, c2: Option<char>) -> bool {\n-    match (c, c1, c2) {\n-        ('r', Some('\"'), _) |\n-        ('r', Some('#'), _) |\n-        ('b', Some('\"'), _) |\n-        ('b', Some('\\''), _) |\n-        ('b', Some('r'), Some('\"')) |\n-        ('b', Some('r'), Some('#')) => true,\n-        _ => false\n-    }\n-}"}, {"sha": "40e5e45281e13c0de1ce38477e4409673940a775", "filename": "src/lexer/strings.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509/src%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509/src%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fstrings.rs?ref=f1a840cc385798fc2e3e9ac9ddb0dd57fd0ac509", "patch": "@@ -0,0 +1,65 @@\n+use {SyntaxKind};\n+use syntax_kinds::*;\n+\n+use lexer::ptr::Ptr;\n+\n+pub(crate) fn string_literal_start(c: char, c1: Option<char>, c2: Option<char>) -> bool {\n+    match (c, c1, c2) {\n+        ('r', Some('\"'), _) |\n+        ('r', Some('#'), _) |\n+        ('b', Some('\"'), _) |\n+        ('b', Some('\\''), _) |\n+        ('b', Some('r'), Some('\"')) |\n+        ('b', Some('r'), Some('#')) => true,\n+        _ => false\n+    }\n+}\n+\n+pub(crate) fn scan_char(ptr: &mut Ptr) {\n+    if ptr.bump().is_none() {\n+        return; // TODO: error reporting is upper in the stack\n+    }\n+    scan_char_or_byte(ptr);\n+    if !ptr.next_is('\\'') {\n+        return; // TODO: error reporting\n+    }\n+    ptr.bump();\n+}\n+\n+pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n+    // unwrapping and not-exhaustive match are ok\n+    // because of string_literal_start\n+    let c = ptr.bump().unwrap();\n+    match c {\n+        '\\'' => {\n+            scan_byte(ptr);\n+            CHAR\n+        }\n+        '\"' => {\n+            scan_byte_string(ptr);\n+            CHAR\n+        }\n+        'r' => {\n+            scan_raw_byte_string(ptr);\n+            CHAR\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+fn scan_byte(ptr: &mut Ptr) {\n+\n+}\n+\n+fn scan_byte_string(ptr: &mut Ptr) {\n+\n+}\n+\n+fn scan_raw_byte_string(ptr: &mut Ptr) {\n+\n+}\n+\n+fn scan_char_or_byte(ptr: &mut Ptr) {\n+    //FIXME: deal with escape sequencies\n+    ptr.bump();\n+}\n\\ No newline at end of file"}]}