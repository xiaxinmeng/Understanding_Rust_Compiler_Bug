{"sha": "2c4a75bf097104e3e08ee307deb34bed0b5531d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNGE3NWJmMDk3MTA0ZTNlMDhlZTMwN2RlYjM0YmVkMGI1NTMxZDQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T22:51:34Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-28T22:59:25Z"}, "message": "rustc_typeck: rename `LvaluePreference::PreferMutLvalue` to `Needs::MutPlace`.", "tree": {"sha": "7e9a143bb2ba6b6ba3ea5a6e9b5cd81317064533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e9a143bb2ba6b6ba3ea5a6e9b5cd81317064533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c4a75bf097104e3e08ee307deb34bed0b5531d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a75bf097104e3e08ee307deb34bed0b5531d4", "html_url": "https://github.com/rust-lang/rust/commit/2c4a75bf097104e3e08ee307deb34bed0b5531d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a75bf097104e3e08ee307deb34bed0b5531d4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "800166cf9697226910104c2812afe2bc1e2e5399", "url": "https://api.github.com/repos/rust-lang/rust/commits/800166cf9697226910104c2812afe2bc1e2e5399", "html_url": "https://github.com/rust-lang/rust/commit/800166cf9697226910104c2812afe2bc1e2e5399"}], "stats": {"total": 162, "additions": 80, "deletions": 82}, "files": [{"sha": "1a285cd869aecad1a376251aa7e80001b1d80617", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -15,7 +15,7 @@ use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use check::{FnCtxt, Expectation, Diverges, LvaluePreference};\n+use check::{FnCtxt, Expectation, Diverges, Needs};\n use check::coercion::CoerceMany;\n use util::nodemap::FxHashMap;\n \n@@ -584,7 +584,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         });\n         let discrim_ty;\n         if let Some(m) = contains_ref_bindings {\n-            discrim_ty = self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n+            discrim_ty = self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m));\n         } else {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in"}, {"sha": "5353d4cc672bc45eab6d3cd3aea47d41ae73cba9", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -10,7 +10,7 @@\n \n use astconv::AstConv;\n \n-use super::{FnCtxt, LvalueOp, LvaluePreference};\n+use super::{FnCtxt, LvalueOp, Needs};\n use super::method::MethodCallee;\n \n use rustc::infer::InferOk;\n@@ -162,19 +162,19 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, pref: LvaluePreference)\n+    pub fn adjust_steps(&self, needs: Needs)\n                         -> Vec<Adjustment<'tcx>> {\n-        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n+        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n+    pub fn adjust_steps_as_infer_ok(&self, needs: Needs)\n                                     -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n         let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, source, pref)\n+                self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n                         if let ty::TyRef(region, mt) = method.sig.output().sty {"}, {"sha": "76df9be48386d0df1678828d144c971003a646c5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{Expectation, FnCtxt, LvaluePreference, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n \n@@ -96,7 +96,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                let adjustments = autoderef.adjust_steps(Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                    let adjustments = autoderef.adjust_steps(Needs::None);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n                         call_expr,\n                         callee_expr,\n@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+            let mut adjustments = autoderef.adjust_steps(Needs::None);\n             adjustments.extend(autoref);\n             self.apply_adjustments(callee_expr, adjustments);\n             CallStep::Overloaded(method)"}, {"sha": "d0280bf0b30be058e53b8b47dc68174aae56f804", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{Diverges, FnCtxt, LvaluePreference};\n+use check::{Diverges, FnCtxt, Needs};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -409,9 +409,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        let needs = Needs::maybe_mut_place(mt_b.mutbl);\n         let InferOk { value: mut adjustments, obligations: o }\n-            = autoderef.adjust_steps_as_infer_ok(pref);\n+            = autoderef.adjust_steps_as_infer_ok(needs);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "691ce18c7382b40041845f5e927d9b026579a186", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -11,7 +11,7 @@\n use super::{probe, MethodCallee};\n \n use astconv::AstConv;\n-use check::{FnCtxt, LvalueOp, callee, LvaluePreference, PreferMutLvalue};\n+use check::{FnCtxt, LvalueOp, callee, Needs};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+        let mut adjustments = autoderef.adjust_steps(Needs::None);\n \n         let mut target = autoderef.unambiguous_final_ty();\n \n@@ -449,10 +449,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                            .adjustments_mut()\n                                            .remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n-                let pref = LvaluePreference::PreferMutLvalue;\n+                let needs = Needs::MutPlace;\n                 for adjustment in &mut adjustments {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, pref) {\n+                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n@@ -505,7 +505,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .ty;\n \n         let method = self.try_overloaded_lvalue_op(\n-            expr.span, base_ty, arg_tys, PreferMutLvalue, op);\n+            expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n         let method = match method {\n             Some(ok) => self.register_infer_ok_obligations(ok),\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")"}, {"sha": "4ccc88f9b159c6769b0f2a0d2f67ee62501d3a42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -77,7 +77,6 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n-use self::LvaluePreference::*;\n use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n@@ -369,16 +368,16 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum LvaluePreference {\n-    PreferMutLvalue,\n-    NoPreference\n+pub enum Needs {\n+    MutPlace,\n+    None\n }\n \n-impl LvaluePreference {\n-    fn from_mutbl(m: hir::Mutability) -> Self {\n+impl Needs {\n+    fn maybe_mut_place(m: hir::Mutability) -> Self {\n         match m {\n-            hir::MutMutable => PreferMutLvalue,\n-            hir::MutImmutable => NoPreference,\n+            hir::MutMutable => Needs::MutPlace,\n+            hir::MutImmutable => Needs::None,\n         }\n     }\n }\n@@ -2242,7 +2241,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        base_expr: &'gcx hir::Expr,\n                        base_ty: Ty<'tcx>,\n                        idx_ty: Ty<'tcx>,\n-                       lvalue_pref: LvaluePreference)\n+                       needs: Needs)\n                        -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n         // FIXME(#18741) -- this is almost but not quite the same as the\n@@ -2252,7 +2251,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(base_expr.span, base_ty);\n         let mut result = None;\n         while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, lvalue_pref, idx_ty);\n+            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n         }\n         autoderef.finalize();\n         result\n@@ -2267,7 +2266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expr: &hir::Expr,\n                       base_expr: &hir::Expr,\n                       autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n-                      lvalue_pref: LvaluePreference,\n+                      needs: Needs,\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n@@ -2295,13 +2294,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeded, install method in table\n             let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_lvalue_op(\n-                expr.span, self_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+                expr.span, self_ty, &[input_ty], needs, LvalueOp::Index);\n \n             let result = method.map(|ok| {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(lvalue_pref);\n+                let mut adjustments = autoderef.adjust_steps(needs);\n                 if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n@@ -2348,20 +2347,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 span: Span,\n                                 base_ty: Ty<'tcx>,\n                                 arg_tys: &[Ty<'tcx>],\n-                                lvalue_pref: LvaluePreference,\n+                                needs: Needs,\n                                 op: LvalueOp)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n     {\n         debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n                span,\n                base_ty,\n-               lvalue_pref,\n+               needs,\n                op);\n \n-        // Try Mut first, if preferred.\n+        // Try Mut first, if needed.\n         let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n-        let method = match (lvalue_pref, mut_tr) {\n-            (PreferMutLvalue, Some(trait_did)) => {\n+        let method = match (needs, mut_tr) {\n+            (Needs::MutPlace, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n             }\n             _ => None,\n@@ -2753,18 +2752,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_coercable_to_type_with_lvalue_pref(expr, expected, NoPreference)\n+        self.check_expr_coercable_to_type_with_needs(expr, expected, Needs::None)\n     }\n \n-    fn check_expr_coercable_to_type_with_lvalue_pref(&self,\n-                                                     expr: &'gcx hir::Expr,\n-                                                     expected: Ty<'tcx>,\n-                                                     lvalue_pref: LvaluePreference)\n-                                                     -> Ty<'tcx> {\n-        let ty = self.check_expr_with_expectation_and_lvalue_pref(\n+    fn check_expr_coercable_to_type_with_needs(&self,\n+                                               expr: &'gcx hir::Expr,\n+                                               expected: Ty<'tcx>,\n+                                               needs: Needs)\n+                                               -> Ty<'tcx> {\n+        let ty = self.check_expr_with_expectation_and_needs(\n             expr,\n             ExpectHasType(expected),\n-            lvalue_pref);\n+            needs);\n         self.demand_coerce(expr, ty, expected)\n     }\n \n@@ -2776,16 +2775,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_with_expectation(&self,\n                                    expr: &'gcx hir::Expr,\n                                    expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_lvalue_pref(expr, expected, NoPreference)\n+        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n     }\n \n     fn check_expr(&self, expr: &'gcx hir::Expr) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n-    fn check_expr_with_lvalue_pref(&self, expr: &'gcx hir::Expr,\n-                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_lvalue_pref(expr, NoExpectation, lvalue_pref)\n+    fn check_expr_with_needs(&self, expr: &'gcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n     }\n \n     // determine the `self` type, using fresh variables for all variables\n@@ -2868,9 +2866,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          span: Span,\n                          args: &'gcx [hir::Expr],\n                          expected: Expectation<'tcx>,\n-                         lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                         needs: Needs) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n+        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n@@ -2980,10 +2978,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n-                   lvalue_pref: LvaluePreference,\n+                   needs: Needs,\n                    base: &'gcx hir::Expr,\n                    field: &Spanned<ast::Name>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      expr_t);\n         let mut private_candidate = None;\n@@ -2998,7 +2996,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                            let adjustments = autoderef.adjust_steps(needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n@@ -3117,10 +3115,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Check tuple index expressions\n     fn check_tup_field(&self,\n                        expr: &'gcx hir::Expr,\n-                       lvalue_pref: LvaluePreference,\n+                       needs: Needs,\n                        base: &'gcx hir::Expr,\n                        idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      expr_t);\n         let mut private_candidate = None;\n@@ -3161,7 +3159,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                let adjustments = autoderef.adjust_steps(needs);\n                 self.apply_adjustments(base, adjustments);\n                 autoderef.finalize();\n                 return field_ty;\n@@ -3491,10 +3489,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `TyError`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_lvalue_pref(&self,\n+    fn check_expr_with_expectation_and_needs(&self,\n                                                    expr: &'gcx hir::Expr,\n                                                    expected: Expectation<'tcx>,\n-                                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                                                   needs: Needs) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n \n@@ -3507,7 +3505,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n+        let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n@@ -3541,7 +3539,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_kind(&self,\n                        expr: &'gcx hir::Expr,\n                        expected: Expectation<'tcx>,\n-                       lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                       needs: Needs) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n@@ -3575,13 +3573,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     NoExpectation\n                 }\n             };\n-            let lvalue_pref = match unop {\n-                hir::UnDeref => lvalue_pref,\n-                _ => NoPreference\n+            let needs = match unop {\n+                hir::UnDeref => needs,\n+                _ => Needs::None\n             };\n-            let mut oprnd_t = self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n+            let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n                                                                                expected_inner,\n-                                                                               lvalue_pref);\n+                                                                               needs);\n \n             if !oprnd_t.references_error() {\n                 oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n@@ -3590,7 +3588,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(mt) = oprnd_t.builtin_deref(true) {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, oprnd_t, lvalue_pref) {\n+                                expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n                                 self.apply_adjustments(oprnd, vec![Adjustment {\n@@ -3641,8 +3639,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => NoExpectation\n                 }\n             });\n-            let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n-            let ty = self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n+            let needs = Needs::maybe_mut_place(mutbl);\n+            let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n             let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n             if tm.ty.references_error() {\n@@ -3786,7 +3784,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.types.never\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n-            let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n+            let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n             let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n@@ -3887,7 +3885,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               self.check_call(expr, &callee, args, expected)\n           }\n           hir::ExprMethodCall(ref segment, span, ref args) => {\n-              self.check_method_call(expr, segment, span, args, expected, lvalue_pref)\n+              self.check_method_call(expr, segment, span, args, expected, needs)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -4030,13 +4028,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n-            self.check_field(expr, lvalue_pref, &base, field)\n+            self.check_field(expr, needs, &base, field)\n           }\n           hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, lvalue_pref, &base, idx)\n+            self.check_tup_field(expr, needs, &base, idx)\n           }\n           hir::ExprIndex(ref base, ref idx) => {\n-              let base_t = self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n+              let base_t = self.check_expr_with_needs(&base, needs);\n               let idx_t = self.check_expr(&idx);\n \n               if base_t.references_error() {\n@@ -4045,7 +4043,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   idx_t\n               } else {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n-                  match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n+                  match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                       Some((index_ty, element_ty)) => {\n                           self.demand_coerce(idx, idx_t, index_ty);\n                           element_ty\n@@ -4195,7 +4193,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // referent for the reference that results is *equal to* the\n             // type of the lvalue it is referencing, and not some\n             // supertype thereof.\n-            let init_ty = self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n+            let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {"}, {"sha": "3631b9799d5929463f4d749a3afb935c1937d2f6", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a75bf097104e3e08ee307deb34bed0b5531d4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=2c4a75bf097104e3e08ee307deb34bed0b5531d4", "patch": "@@ -10,7 +10,7 @@\n \n //! Code related to processing overloaded binary and unary operators.\n \n-use super::{FnCtxt, NoPreference, PreferMutLvalue};\n+use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n@@ -166,18 +166,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                op,\n                is_assign);\n \n-        let lhs_pref = match is_assign {\n-            IsAssign::Yes => PreferMutLvalue,\n-            IsAssign::No => NoPreference\n+        let lhs_needs = match is_assign {\n+            IsAssign::Yes => Needs::MutPlace,\n+            IsAssign::No => Needs::None\n         };\n         // Find a suitable supertype of the LHS expression's type, by coercing to\n         // a type variable, to pass as the `Self` to the trait, avoiding invariant\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_lvalue_pref(lhs_expr,\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n             self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n-            lhs_pref);\n+            lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n         // NB: As we have not yet type-checked the RHS, we don't have the"}]}