{"sha": "12fbabd27f700a59d0e7031f0839b220c3514bcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZmJhYmQyN2Y3MDBhNTlkMGU3MDMxZjA4MzliMjIwYzM1MTRiY2I=", "commit": {"author": {"name": "Dominik Stolz", "email": "d.stolz@tum.de", "date": "2021-03-25T21:46:37Z"}, "committer": {"name": "Dominik Stolz", "email": "d.stolz@tum.de", "date": "2021-08-01T07:45:00Z"}, "message": "Do not call getpid wrapper after fork in tests\n\nThe test calls libc::getpid() in the pre_exec hook and asserts that the returned value is different from the PID of the parent.\nHowever, libc::getpid() returns the wrong value.\nBefore version 2.25, glibc caches the PID of the current process with the goal of avoiding additional syscalls.\nThe cached value is only updated when the wrapper functions for fork or clone are called.\nIn PR #81825 we switch to directly using the clone3 syscall.\nThus, the cache is not updated and getpid returns the PID of the parent.\nsource: https://man7.org/linux/man-pages/man2/getpid.2.html#NOTES", "tree": {"sha": "e033d904569a3b5f39c3370153bf64c3e88e3013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e033d904569a3b5f39c3370153bf64c3e88e3013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12fbabd27f700a59d0e7031f0839b220c3514bcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12fbabd27f700a59d0e7031f0839b220c3514bcb", "html_url": "https://github.com/rust-lang/rust/commit/12fbabd27f700a59d0e7031f0839b220c3514bcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12fbabd27f700a59d0e7031f0839b220c3514bcb/comments", "author": {"login": "voidc", "id": 5302792, "node_id": "MDQ6VXNlcjUzMDI3OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5302792?v=4", "gravatar_id": "", "url": "https://api.github.com/users/voidc", "html_url": "https://github.com/voidc", "followers_url": "https://api.github.com/users/voidc/followers", "following_url": "https://api.github.com/users/voidc/following{/other_user}", "gists_url": "https://api.github.com/users/voidc/gists{/gist_id}", "starred_url": "https://api.github.com/users/voidc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/voidc/subscriptions", "organizations_url": "https://api.github.com/users/voidc/orgs", "repos_url": "https://api.github.com/users/voidc/repos", "events_url": "https://api.github.com/users/voidc/events{/privacy}", "received_events_url": "https://api.github.com/users/voidc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "voidc", "id": 5302792, "node_id": "MDQ6VXNlcjUzMDI3OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5302792?v=4", "gravatar_id": "", "url": "https://api.github.com/users/voidc", "html_url": "https://github.com/voidc", "followers_url": "https://api.github.com/users/voidc/followers", "following_url": "https://api.github.com/users/voidc/following{/other_user}", "gists_url": "https://api.github.com/users/voidc/gists{/gist_id}", "starred_url": "https://api.github.com/users/voidc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/voidc/subscriptions", "organizations_url": "https://api.github.com/users/voidc/orgs", "repos_url": "https://api.github.com/users/voidc/repos", "events_url": "https://api.github.com/users/voidc/events{/privacy}", "received_events_url": "https://api.github.com/users/voidc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3321d3eb3bdf8655993c4564ad6569c4c849b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3321d3eb3bdf8655993c4564ad6569c4c849b59", "html_url": "https://github.com/rust-lang/rust/commit/c3321d3eb3bdf8655993c4564ad6569c4c849b59"}], "stats": {"total": 42, "additions": 35, "deletions": 7}, "files": [{"sha": "10a8b19159e02bfb2542844c248f8cd2da03f252", "filename": "src/test/ui/command/command-pre-exec.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12fbabd27f700a59d0e7031f0839b220c3514bcb/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fbabd27f700a59d0e7031f0839b220c3514bcb/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs?ref=12fbabd27f700a59d0e7031f0839b220c3514bcb", "patch": "@@ -8,15 +8,30 @@\n // ignore-sgx no processes\n #![feature(process_exec, rustc_private)]\n \n-extern crate libc;\n-\n use std::env;\n use std::io::Error;\n use std::os::unix::process::CommandExt;\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::Arc;\n \n+#[cfg(not(target_os = \"linux\"))]\n+fn getpid() -> u32 {\n+    use std::process;\n+    process::id()\n+}\n+\n+/// We need to directly use the getpid syscall instead of using `process::id()`\n+/// because the libc wrapper might return incorrect values after a process was\n+/// forked.\n+#[cfg(target_os = \"linux\")]\n+fn getpid() -> u32 {\n+    extern crate libc;\n+    unsafe {\n+        libc::syscall(libc::SYS_getpid) as _\n+    }\n+}\n+\n fn main() {\n     if let Some(arg) = env::args().nth(1) {\n         match &arg[..] {\n@@ -68,14 +83,12 @@ fn main() {\n     };\n     assert_eq!(output.raw_os_error(), Some(102));\n \n-    let pid = unsafe { libc::getpid() };\n-    assert!(pid >= 0);\n+    let pid = getpid();\n     let output = unsafe {\n         Command::new(&me)\n             .arg(\"empty\")\n             .pre_exec(move || {\n-                let child = libc::getpid();\n-                assert!(child >= 0);\n+                let child = getpid();\n                 assert!(pid != child);\n                 Ok(())\n             })"}, {"sha": "ad749371beac041c4e56b691f5973ae772c18d3f", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12fbabd27f700a59d0e7031f0839b220c3514bcb/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12fbabd27f700a59d0e7031f0839b220c3514bcb/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=12fbabd27f700a59d0e7031f0839b220c3514bcb", "patch": "@@ -23,6 +23,21 @@ use std::sync::atomic::{AtomicU32, Ordering};\n \n use libc::c_int;\n \n+#[cfg(not(target_os = \"linux\"))]\n+fn getpid() -> u32 {\n+    process::id()\n+}\n+\n+/// We need to directly use the getpid syscall instead of using `process::id()`\n+/// because the libc wrapper might return incorrect values after a process was\n+/// forked.\n+#[cfg(target_os = \"linux\")]\n+fn getpid() -> u32 {\n+    unsafe {\n+        libc::syscall(libc::SYS_getpid) as _\n+    }\n+}\n+\n /// This stunt allocator allows us to spot heap allocations in the child.\n struct PidChecking<A> {\n     parent: A,\n@@ -44,7 +59,7 @@ impl<A> PidChecking<A> {\n     fn check(&self) {\n         let require_pid = self.require_pid.load(Ordering::Acquire);\n         if require_pid != 0 {\n-            let actual_pid = process::id();\n+            let actual_pid = getpid();\n             if require_pid != actual_pid {\n                 unsafe {\n                     libc::raise(libc::SIGUSR1);"}]}