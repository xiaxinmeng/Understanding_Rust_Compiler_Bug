{"sha": "ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYjU5MzM3OWMzYWIwNzU5NDBhM2ZiZjJlOTgwZWM1MjYwYjZjYTQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-20T13:59:57Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-20T14:08:09Z"}, "message": "refactor check_for_cast", "tree": {"sha": "5d7c76477914aaa2a09b1243ac1caa8554204d8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d7c76477914aaa2a09b1243ac1caa8554204d8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "html_url": "https://github.com/rust-lang/rust/commit/ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72a2d35f165a94e17cd17e56cb61e3dcbef7eb2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a2d35f165a94e17cd17e56cb61e3dcbef7eb2d", "html_url": "https://github.com/rust-lang/rust/commit/72a2d35f165a94e17cd17e56cb61e3dcbef7eb2d"}], "stats": {"total": 474, "additions": 265, "deletions": 209}, "files": [{"sha": "6e93f2273ab86de87ff23f2ef5545a1b1393c85f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 189, "deletions": 207, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -16,6 +16,8 @@ use rustc_span::Span;\n \n use super::method::probe;\n \n+use std::fmt;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n@@ -689,16 +691,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n-            // Shouldn't suggest `.into()` on `const`s.\n-            // FIXME(estebank): modify once we decide to suggest `as` casts\n-            return false;\n-        }\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n             return false;\n         }\n \n+        let src = if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+            src\n+        } else {\n+            return false;\n+        };\n+\n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch.\n         //\n@@ -727,6 +730,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             String::new()\n         };\n+\n         if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n@@ -768,222 +772,200 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             checked_ty, expected_ty,\n         );\n \n-        let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n-\n-        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-            let cast_suggestion = format!(\n-                \"{}{}{}{} as {}\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-                expected_ty,\n-            );\n-            let try_into_suggestion = format!(\n-                \"{}{}{}{}.try_into().unwrap()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let into_suggestion = format!(\n-                \"{}{}{}{}.into()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let suffix_suggestion = format!(\n-                \"{}{}{}{}\",\n-                if needs_paren { \"(\" } else { \"\" },\n-                if let (ty::Int(_) | ty::Uint(_), ty::Float(_)) =\n-                    (&expected_ty.kind, &checked_ty.kind,)\n-                {\n-                    // Remove fractional part from literal, for example `42.0f32` into `42`\n-                    let src = src.trim_end_matches(&checked_ty.to_string());\n-                    src.split('.').next().unwrap()\n+        let with_opt_paren: fn(&dyn fmt::Display) -> String =\n+            if expr.precedence().order() < PREC_POSTFIX {\n+                |s| format!(\"({})\", s)\n+            } else {\n+                |s| s.to_string()\n+            };\n+\n+        let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n+        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+        let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n+        let suffix_suggestion = with_opt_paren(&format_args!(\n+            \"{}{}\",\n+            if matches!(\n+                (&expected_ty.kind, &checked_ty.kind),\n+                (ty::Int(_) | ty::Uint(_), ty::Float(_))\n+            ) {\n+                // Remove fractional part from literal, for example `42.0f32` into `42`\n+                let src = src.trim_end_matches(&checked_ty.to_string());\n+                src.split('.').next().unwrap()\n+            } else {\n+                src.trim_end_matches(&checked_ty.to_string())\n+            },\n+            expected_ty,\n+        ));\n+        let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n+            if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n+        };\n+\n+        let is_const_context = self.tcx.hir().is_const_context(expr.hir_id);\n+        let suggest_to_change_suffix_or_into =\n+            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+                let msg = if literal_is_ty_suffixed(expr) {\n+                    &lit_msg\n+                } else if is_const_context {\n+                    // Do not recommend `into` or `try_into` in const contexts.\n+                    return;\n+                } else if is_fallible {\n+                    &try_msg\n                 } else {\n-                    src.trim_end_matches(&checked_ty.to_string())\n-                },\n-                expected_ty,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n-                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                    lit.node.is_suffixed()\n+                    &msg\n+                };\n+                let suggestion = if literal_is_ty_suffixed(expr) {\n+                    suffix_suggestion.clone()\n+                } else if is_fallible {\n+                    try_into_suggestion\n                 } else {\n-                    false\n-                }\n+                    into_suggestion.clone()\n+                };\n+                err.span_suggestion(expr.span, msg, suggestion, Applicability::MachineApplicable);\n             };\n \n-            let suggest_to_change_suffix_or_into =\n-                |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+        match (&expected_ty.kind, &checked_ty.kind) {\n+            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if exp < found => true,\n+                    (None, Some(8 | 16)) => false,\n+                    (None, _) | (_, None) => true,\n+                    _ => false,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Int(exp), &ty::Uint(found)) => {\n+                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n+                    (Some(exp), Some(found)) if found < exp => false,\n+                    (None, Some(8)) => false,\n+                    _ => true,\n+                };\n+                suggest_to_change_suffix_or_into(err, is_fallible);\n+                true\n+            }\n+            (&ty::Uint(_), &ty::Int(_)) => {\n+                suggest_to_change_suffix_or_into(err, true);\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+                if found.bit_width() < exp.bit_width() {\n+                    suggest_to_change_suffix_or_into(err, false);\n+                } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,\n-                        if literal_is_ty_suffixed(expr) {\n-                            &lit_msg\n-                        } else if is_fallible {\n-                            &try_msg\n-                        } else {\n-                            &msg\n-                        },\n-                        if literal_is_ty_suffixed(expr) {\n-                            suffix_suggestion.clone()\n-                        } else if is_fallible {\n-                            try_into_suggestion\n-                        } else {\n-                            into_suggestion.clone()\n-                        },\n+                        &lit_msg,\n+                        suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n-                };\n-\n-            match (&expected_ty.kind, &checked_ty.kind) {\n-                (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Int(exp), &ty::Uint(found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if found < exp => false,\n-                        (None, Some(8)) => false,\n-                        _ => true,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(_), &ty::Int(_)) => {\n-                    suggest_to_change_suffix_or_into(err, true);\n-                    true\n-                }\n-                (&ty::Float(ref exp), &ty::Float(ref found)) => {\n-                    if found.bit_width() < exp.bit_width() {\n-                        suggest_to_change_suffix_or_into(err, false);\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `f64` to `f32`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, producing the closest possible value\", cast_msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                } else if can_cast {\n+                    // Missing try_into implementation for `f64` to `f32`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n-                    if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `{float}` to `{integer}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, rounding the float towards zero\", msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n+                if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if can_cast {\n+                    // Missing try_into implementation for `{float}` to `{integer}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n-                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer,\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+                // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer,\n                                  rounded if necessary\",\n-                                cast_msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                            cast_msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Int(ref found)) => {\n-                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                &msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer, \\\n-                                 rounded if necessary\",\n-                                &msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+                // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            &msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer, \\\n+                                rounded if necessary\",\n+                            &msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                _ => false,\n+                true\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n }"}, {"sha": "7b9f086151a847ce8aeabf426e1ab13b5d618844", "filename": "src/test/ui/discrim/discrim-ill-typed.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fdiscrim%2Fdiscrim-ill-typed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fdiscrim%2Fdiscrim-ill-typed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiscrim%2Fdiscrim-ill-typed.stderr?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -3,48 +3,88 @@ error[E0308]: mismatched types\n    |\n LL |         OhNo = 0_u8,\n    |                ^^^^ expected `i8`, found `u8`\n+   |\n+help: change the type of the numeric literal from `u8` to `i8`\n+   |\n+LL |         OhNo = 0_i8,\n+   |                ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:30:16\n    |\n LL |         OhNo = 0_i8,\n    |                ^^^^ expected `u8`, found `i8`\n+   |\n+help: change the type of the numeric literal from `i8` to `u8`\n+   |\n+LL |         OhNo = 0_u8,\n+   |                ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:43:16\n    |\n LL |         OhNo = 0_u16,\n    |                ^^^^^ expected `i16`, found `u16`\n+   |\n+help: change the type of the numeric literal from `u16` to `i16`\n+   |\n+LL |         OhNo = 0_i16,\n+   |                ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:56:16\n    |\n LL |         OhNo = 0_i16,\n    |                ^^^^^ expected `u16`, found `i16`\n+   |\n+help: change the type of the numeric literal from `i16` to `u16`\n+   |\n+LL |         OhNo = 0_u16,\n+   |                ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:69:16\n    |\n LL |         OhNo = 0_u32,\n    |                ^^^^^ expected `i32`, found `u32`\n+   |\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |         OhNo = 0_i32,\n+   |                ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:82:16\n    |\n LL |         OhNo = 0_i32,\n    |                ^^^^^ expected `u32`, found `i32`\n+   |\n+help: change the type of the numeric literal from `i32` to `u32`\n+   |\n+LL |         OhNo = 0_u32,\n+   |                ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:95:16\n    |\n LL |         OhNo = 0_u64,\n    |                ^^^^^ expected `i64`, found `u64`\n+   |\n+help: change the type of the numeric literal from `u64` to `i64`\n+   |\n+LL |         OhNo = 0_i64,\n+   |                ^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/discrim-ill-typed.rs:108:16\n    |\n LL |         OhNo = 0_i64,\n    |                ^^^^^ expected `u64`, found `i64`\n+   |\n+help: change the type of the numeric literal from `i64` to `u64`\n+   |\n+LL |         OhNo = 0_u64,\n+   |                ^^^^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "836520a28ef349cbfa04f6721ec522ba38ed5504", "filename": "src/test/ui/issues/issue-8761.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fissues%2Fissue-8761.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fissues%2Fissue-8761.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8761.stderr?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -3,12 +3,22 @@ error[E0308]: mismatched types\n    |\n LL |     A = 1i64,\n    |         ^^^^ expected `isize`, found `i64`\n+   |\n+help: change the type of the numeric literal from `i64` to `isize`\n+   |\n+LL |     A = 1isize,\n+   |         ^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-8761.rs:5:9\n    |\n LL |     B = 2u8\n    |         ^^^ expected `isize`, found `u8`\n+   |\n+help: change the type of the numeric literal from `u8` to `isize`\n+   |\n+LL |     B = 2isize\n+   |         ^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d7f18e19b41bd417282ab314dadbc43a7a29fa0a", "filename": "src/test/ui/numeric/const-scope.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -3,6 +3,11 @@ error[E0308]: mismatched types\n    |\n LL | const C: i32 = 1i8;\n    |                ^^^ expected `i32`, found `i8`\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL | const C: i32 = 1i32;\n+   |                ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:2:15\n@@ -17,6 +22,11 @@ LL |     let c: i32 = 1i8;\n    |            ---   ^^^ expected `i32`, found `i8`\n    |            |\n    |            expected due to this\n+   |\n+help: change the type of the numeric literal from `i8` to `i32`\n+   |\n+LL |     let c: i32 = 1i32;\n+   |                  ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/const-scope.rs:6:17"}, {"sha": "7e30491f0bdbcdddc62a1b8b0e33f995df3ca32e", "filename": "src/test/ui/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.rs?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -22,6 +22,9 @@ fn main() {\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`, found `isize`\n+    let f = [0; 4u8];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`, found `u8`\n     struct G {\n         g: (),\n     }"}, {"sha": "6a081e23d9d375f6dfe51cbada2b04e0275f1398", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb593379c3ab075940a3fbf2e980ec5260b6ca4/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=ecb593379c3ab075940a3fbf2e980ec5260b6ca4", "patch": "@@ -29,7 +29,7 @@ LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:28:17\n+  --> $DIR/repeat_count.rs:31:17\n    |\n LL |     let g = [0; G { g: () }];\n    |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n@@ -46,7 +46,18 @@ error[E0308]: mismatched types\n LL |     let f = [0_usize; -1_isize];\n    |                       ^^^^^^^^ expected `usize`, found `isize`\n \n-error: aborting due to 8 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:25:17\n+   |\n+LL |     let f = [0; 4u8];\n+   |                 ^^^ expected `usize`, found `u8`\n+   |\n+help: change the type of the numeric literal from `u8` to `usize`\n+   |\n+LL |     let f = [0; 4usize];\n+   |                 ^^^^^^\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0435.\n For more information about an error, try `rustc --explain E0308`."}]}