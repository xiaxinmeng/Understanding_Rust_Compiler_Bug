{"sha": "d0e0f4021d10b546ebbb3b346296b36ec10ac957", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZTBmNDAyMWQxMGI1NDZlYmJiM2IzNDYyOTZiMzZlYzEwYWM5NTc=", "commit": {"author": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-04-07T17:47:58Z"}, "committer": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-04-07T18:02:11Z"}, "message": "Remove old mir-opt test format.", "tree": {"sha": "27bb624a3677aff232b7a51d36ec540bf755a8e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27bb624a3677aff232b7a51d36ec540bf755a8e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0e0f4021d10b546ebbb3b346296b36ec10ac957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e0f4021d10b546ebbb3b346296b36ec10ac957", "html_url": "https://github.com/rust-lang/rust/commit/d0e0f4021d10b546ebbb3b346296b36ec10ac957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0e0f4021d10b546ebbb3b346296b36ec10ac957/comments", "author": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea4aca19c14bd3424d100cf414723a3017f53ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4aca19c14bd3424d100cf414723a3017f53ce9", "html_url": "https://github.com/rust-lang/rust/commit/ea4aca19c14bd3424d100cf414723a3017f53ce9"}], "stats": {"total": 246, "additions": 2, "deletions": 244}, "files": [{"sha": "a0550466cf07b4c8b805d1fff53c9f3576ca52f0", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d0e0f4021d10b546ebbb3b346296b36ec10ac957/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0e0f4021d10b546ebbb3b346296b36ec10ac957/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=d0e0f4021d10b546ebbb3b346296b36ec10ac957", "patch": "@@ -1,9 +1,7 @@\n This folder contains tests for MIR optimizations.\n \n-There are two test formats. One allows specifying a pattern to look for in the MIR, which also\n-permits leaving placeholders, but requires you to manually change the pattern if anything changes.\n-The other emits MIR to extra files that you can automatically update by specifying `--bless` on\n-the command line (just like `ui` tests updating `.stderr` files).\n+The `mir-opt` test format emits MIR to extra files that you can automatically update by specifying\n+`--bless` on the command line (just like `ui` tests updating `.stderr` files).\n \n # `--bless`able test format\n \n@@ -39,79 +37,3 @@ This exists mainly for completeness and is rarely useful.\n ```\n // EMIT_MIR $file_name_of_some_mir_dump.before.mir\n ```\n-\n-# Inline test format\n-\n-```\n-(arbitrary rust code)\n-// END RUST SOURCE\n-// START $file_name_of_some_mir_dump_0\n-//  $expected_line_0\n-// (lines or elision)\n-// $expected_line_N\n-// END $file_name_of_some_mir_dump_0\n-// (lines or elision)\n-// START $file_name_of_some_mir_dump_N\n-//  $expected_line_0\n-// (lines or elision)\n-// $expected_line_N\n-// END $file_name_of_some_mir_dump_N\n-```\n-\n-All the test information is in comments so the test is runnable.\n-\n-For each $file_name, compiletest expects [$expected_line_0, ...,\n-$expected_line_N] to appear in the dumped MIR in order.  Currently it allows\n-other non-matched lines before and after, but not between $expected_lines,\n-should you want to skip lines, you must include an elision comment, of the form\n-(as a regex) `//\\s*...\\s*`. The lines will be skipped lazily, that is, if there\n-are two identical lines in the output that match the line after the elision\n-comment, the first one will be matched.\n-\n-Examples:\n-\n-The following blocks will not match the one after it.\n-\n-```\n-bb0: {\n-    StorageLive(_1);\n-    _1 = const true;\n-    StorageDead(_1);\n-}\n-```\n-\n-```\n-bb0: {\n-    StorageLive(_1);\n-    _1 = const true;\n-    goto -> bb1\n-}\n-bb1: {\n-    StorageDead(_1);\n-    return;\n-}\n-```\n-\n-But this will match the one above,\n-\n-```\n-bb0: {\n-    StorageLive(_1);\n-    _1 = const true;\n-    ...\n-    StorageDead(_1);\n-    ...\n-}\n-```\n-\n-Lines match ignoring whitespace, and the prefix \"//\" is removed.\n-\n-It also currently strips trailing comments -- partly because the full file path\n-in \"scope comments\" is unpredictable and partly because tidy complains about\n-the lines being too long.\n-\n-compiletest handles dumping the MIR before and after every pass for you.  The\n-test writer only has to specify the file names of the dumped files (not the\n-full path to the file) and what lines to expect.  There is an option to rustc\n-that tells it to dump the mir into some directly (rather then always dumping to\n-the current directory)."}, {"sha": "26a9cd119978d01d59eea0e73b125f9114505cba", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d0e0f4021d10b546ebbb3b346296b36ec10ac957/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e0f4021d10b546ebbb3b346296b36ec10ac957/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=d0e0f4021d10b546ebbb3b346296b36ec10ac957", "patch": "@@ -21,7 +21,6 @@ use std::collections::hash_map::DefaultHasher;\n use std::collections::{HashMap, HashSet, VecDeque};\n use std::env;\n use std::ffi::{OsStr, OsString};\n-use std::fmt;\n use std::fs::{self, create_dir_all, File, OpenOptions};\n use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n@@ -3156,36 +3155,6 @@ impl<'test> TestCx<'test> {\n                 }\n             }\n         }\n-\n-        if let Some(idx) = test_file_contents.find(\"// END RUST SOURCE\") {\n-            let (_, tests_text) = test_file_contents.split_at(idx + \"// END_RUST SOURCE\".len());\n-            let tests_text_str = String::from(tests_text);\n-            let mut curr_test: Option<&str> = None;\n-            let mut curr_test_contents = vec![ExpectedLine::Elision];\n-            for l in tests_text_str.lines() {\n-                debug!(\"line: {:?}\", l);\n-                if l.starts_with(\"// START \") {\n-                    let (_, t) = l.split_at(\"// START \".len());\n-                    curr_test = Some(t);\n-                } else if l.starts_with(\"// END\") {\n-                    let (_, t) = l.split_at(\"// END \".len());\n-                    if Some(t) != curr_test {\n-                        panic!(\"mismatched START END test name\");\n-                    }\n-                    self.compare_mir_test_output(curr_test.unwrap(), &curr_test_contents);\n-                    curr_test = None;\n-                    curr_test_contents.clear();\n-                    curr_test_contents.push(ExpectedLine::Elision);\n-                } else if l.is_empty() {\n-                    // ignore\n-                } else if l.starts_with(\"//\") && l.split_at(\"//\".len()).1.trim() == \"...\" {\n-                    curr_test_contents.push(ExpectedLine::Elision)\n-                } else if l.starts_with(\"// \") {\n-                    let (_, test_content) = l.split_at(\"// \".len());\n-                    curr_test_contents.push(ExpectedLine::Text(test_content));\n-                }\n-            }\n-        }\n     }\n \n     fn check_mir_test_timestamp(&self, test_name: &str, output_file: &Path) {\n@@ -3203,107 +3172,6 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn compare_mir_test_output(&self, test_name: &str, expected_content: &[ExpectedLine<&str>]) {\n-        let mut output_file = PathBuf::new();\n-        output_file.push(self.get_mir_dump_dir());\n-        output_file.push(test_name);\n-        debug!(\"comparing the contents of: {:?}\", output_file);\n-        debug!(\"with: {:?}\", expected_content);\n-        if !output_file.exists() {\n-            panic!(\"Output file `{}` from test does not exist\", output_file.display());\n-        }\n-        self.check_mir_test_timestamp(test_name, &output_file);\n-\n-        let dumped_string = fs::read_to_string(&output_file).unwrap();\n-        let mut dumped_lines =\n-            dumped_string.lines().map(|l| nocomment_mir_line(l)).filter(|l| !l.is_empty());\n-        let mut expected_lines = expected_content\n-            .iter()\n-            .filter(|&l| if let &ExpectedLine::Text(l) = l { !l.is_empty() } else { true })\n-            .peekable();\n-\n-        let compare = |expected_line, dumped_line| {\n-            let e_norm = normalize_mir_line(expected_line);\n-            let d_norm = normalize_mir_line(dumped_line);\n-            debug!(\"found: {:?}\", d_norm);\n-            debug!(\"expected: {:?}\", e_norm);\n-            e_norm == d_norm\n-        };\n-\n-        let error = |expected_line, extra_msg| {\n-            let normalize_all = dumped_string\n-                .lines()\n-                .map(nocomment_mir_line)\n-                .filter(|l| !l.is_empty())\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\");\n-            let f = |l: &ExpectedLine<_>| match l {\n-                &ExpectedLine::Elision => \"... (elided)\".into(),\n-                &ExpectedLine::Text(t) => t,\n-            };\n-            let expected_content =\n-                expected_content.iter().map(|l| f(l)).collect::<Vec<_>>().join(\"\\n\");\n-            panic!(\n-                \"Did not find expected line, error: {}\\n\\\n-                 Expected Line: {:?}\\n\\\n-                 Test Name: {}\\n\\\n-                 Expected:\\n{}\\n\\\n-                 Actual:\\n{}\",\n-                extra_msg, expected_line, test_name, expected_content, normalize_all\n-            );\n-        };\n-\n-        // We expect each non-empty line to appear consecutively, non-consecutive lines\n-        // must be separated by at least one Elision\n-        let mut start_block_line = None;\n-        while let Some(dumped_line) = dumped_lines.next() {\n-            match expected_lines.next() {\n-                Some(&ExpectedLine::Text(expected_line)) => {\n-                    let normalized_expected_line = normalize_mir_line(expected_line);\n-                    if normalized_expected_line.contains(\":{\") {\n-                        start_block_line = Some(expected_line);\n-                    }\n-\n-                    if !compare(expected_line, dumped_line) {\n-                        error!(\"{:?}\", start_block_line);\n-                        error(\n-                            expected_line,\n-                            format!(\n-                                \"Mismatch in lines\\n\\\n-                                 Current block: {}\\n\\\n-                                 Actual Line: {:?}\",\n-                                start_block_line.unwrap_or(\"None\"),\n-                                dumped_line\n-                            ),\n-                        );\n-                    }\n-                }\n-                Some(&ExpectedLine::Elision) => {\n-                    // skip any number of elisions in a row.\n-                    while let Some(&&ExpectedLine::Elision) = expected_lines.peek() {\n-                        expected_lines.next();\n-                    }\n-                    if let Some(&ExpectedLine::Text(expected_line)) = expected_lines.next() {\n-                        let mut found = compare(expected_line, dumped_line);\n-                        if found {\n-                            continue;\n-                        }\n-                        while let Some(dumped_line) = dumped_lines.next() {\n-                            found = compare(expected_line, dumped_line);\n-                            if found {\n-                                break;\n-                            }\n-                        }\n-                        if !found {\n-                            error(expected_line, \"ran out of mir dump to match against\".into());\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-        }\n-    }\n-\n     fn get_mir_dump_dir(&self) -> PathBuf {\n         let mut mir_dump_dir = PathBuf::from(self.config.build_base.as_path());\n         debug!(\"input_file: {:?}\", self.testpaths.file);\n@@ -3589,43 +3457,11 @@ enum TargetLocation {\n     ThisDirectory(PathBuf),\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n-enum ExpectedLine<T: AsRef<str>> {\n-    Elision,\n-    Text(T),\n-}\n-\n enum AllowUnused {\n     Yes,\n     No,\n }\n \n-impl<T> fmt::Debug for ExpectedLine<T>\n-where\n-    T: AsRef<str> + fmt::Debug,\n-{\n-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let &ExpectedLine::Text(ref t) = self {\n-            write!(formatter, \"{:?}\", t)\n-        } else {\n-            write!(formatter, \"\\\"...\\\" (Elision)\")\n-        }\n-    }\n-}\n-\n-fn normalize_mir_line(line: &str) -> String {\n-    nocomment_mir_line(line).replace(char::is_whitespace, \"\")\n-}\n-\n-fn nocomment_mir_line(line: &str) -> &str {\n-    if let Some(idx) = line.find(\"//\") {\n-        let (l, _) = line.split_at(idx);\n-        l.trim_end()\n-    } else {\n-        line\n-    }\n-}\n-\n fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n     use crate::read2::read2;\n     use std::mem::replace;"}]}