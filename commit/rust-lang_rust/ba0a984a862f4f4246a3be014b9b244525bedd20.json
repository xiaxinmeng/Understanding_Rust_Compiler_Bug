{"sha": "ba0a984a862f4f4246a3be014b9b244525bedd20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMGE5ODRhODYyZjRmNDI0NmEzYmUwMTRiOWIyNDQ1MjViZWRkMjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T20:25:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "core: Move intrinsic float functionality from std\n\nThe Float trait in libstd is quite a large trait which has dependencies on cmath\n(libm) and such, which libcore cannot satisfy. It also has many functions that\nlibcore can implement, however, as LLVM has intrinsics or they're just bit\ntwiddling.\n\nThis commit moves what it can of the Float trait from the standard library into\nlibcore to allow floats to be usable in the core library. The remaining\nfunctions are now resident in a FloatMath trait in the standard library (in the\nprelude now). Previous code which was generic over just the Float trait may now\nneed to be generic over the FloatMath trait.\n\n[breaking-change]", "tree": {"sha": "d4fe59c7f09d1063289618312e8decb8c27c04e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4fe59c7f09d1063289618312e8decb8c27c04e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba0a984a862f4f4246a3be014b9b244525bedd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0a984a862f4f4246a3be014b9b244525bedd20", "html_url": "https://github.com/rust-lang/rust/commit/ba0a984a862f4f4246a3be014b9b244525bedd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba0a984a862f4f4246a3be014b9b244525bedd20/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4994f3cd455333749b8613b8cfc002e7397bf236", "url": "https://api.github.com/repos/rust-lang/rust/commits/4994f3cd455333749b8613b8cfc002e7397bf236", "html_url": "https://github.com/rust-lang/rust/commit/4994f3cd455333749b8613b8cfc002e7397bf236"}], "stats": {"total": 1408, "additions": 712, "deletions": 696}, "files": [{"sha": "694f3e9fbd1f90ee2292975927d140421c4009a3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 271, "deletions": 1, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -12,7 +12,10 @@\n \n use default::Default;\n use intrinsics;\n-use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use mem;\n+use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use option::Option;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -225,3 +228,270 @@ impl Bounded for f32 {\n     #[inline]\n     fn max_value() -> f32 { MAX_VALUE }\n }\n+\n+impl Float for f32 {\n+    #[inline]\n+    fn nan() -> f32 { NAN }\n+\n+    #[inline]\n+    fn infinity() -> f32 { INFINITY }\n+\n+    #[inline]\n+    fn neg_infinity() -> f32 { NEG_INFINITY }\n+\n+    #[inline]\n+    fn neg_zero() -> f32 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(self) -> bool { self != self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n+        static EXP_MASK: u32 = 0x7f800000;\n+        static MAN_MASK: u32 = 0x007fffff;\n+\n+        let bits: u32 = unsafe { mem::transmute(self) };\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n+\n+    #[inline]\n+    fn digits(_: Option<f32>) -> uint { DIGITS }\n+\n+    #[inline]\n+    fn epsilon() -> f32 { EPSILON }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n+\n+    #[inline]\n+    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { mem::transmute(self) };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n+    /// Round half-way cases toward `NEG_INFINITY`\n+    #[inline]\n+    fn floor(self) -> f32 {\n+        unsafe { intrinsics::floorf32(self) }\n+    }\n+\n+    /// Round half-way cases toward `INFINITY`\n+    #[inline]\n+    fn ceil(self) -> f32 {\n+        unsafe { intrinsics::ceilf32(self) }\n+    }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline]\n+    fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline]\n+    fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n+\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f32;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n+    #[inline]\n+    fn fract(self) -> f32 { self - self.trunc() }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[inline]\n+    fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n+\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline]\n+    fn recip(self) -> f32 { 1.0 / self }\n+\n+    fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powf(self, n: f32) -> f32 {\n+        unsafe { intrinsics::powf32(self, n) }\n+    }\n+\n+    /// sqrt(2.0)\n+    #[inline]\n+    fn sqrt2() -> f32 { consts::SQRT2 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline]\n+    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n+\n+    #[inline]\n+    fn sqrt(self) -> f32 {\n+        unsafe { intrinsics::sqrtf32(self) }\n+    }\n+\n+    #[inline]\n+    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n+\n+    /// Archimedes' constant\n+    #[inline]\n+    fn pi() -> f32 { consts::PI }\n+\n+    /// 2.0 * pi\n+    #[inline]\n+    fn two_pi() -> f32 { consts::PI_2 }\n+\n+    /// pi / 2.0\n+    #[inline]\n+    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n+\n+    /// pi / 3.0\n+    #[inline]\n+    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n+\n+    /// pi / 4.0\n+    #[inline]\n+    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n+\n+    /// pi / 6.0\n+    #[inline]\n+    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n+\n+    /// pi / 8.0\n+    #[inline]\n+    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n+\n+    /// 1 .0/ pi\n+    #[inline]\n+    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline]\n+    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n+\n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f32 { consts::E }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f32 { consts::LOG2_E }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f32 { consts::LOG10_E }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f32 { consts::LN_2 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f32 { consts::LN_10 }\n+\n+    /// Returns the exponential of the number\n+    #[inline]\n+    fn exp(self) -> f32 {\n+        unsafe { intrinsics::expf32(self) }\n+    }\n+\n+    /// Returns 2 raised to the power of the number\n+    #[inline]\n+    fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number\n+    #[inline]\n+    fn ln(self) -> f32 {\n+        unsafe { intrinsics::logf32(self) }\n+    }\n+\n+    /// Returns the logarithm of the number with respect to an arbitrary base\n+    #[inline]\n+    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n+\n+    /// Returns the base 2 logarithm of the number\n+    #[inline]\n+    fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n+\n+    /// Returns the base 10 logarithm of the number\n+    #[inline]\n+    fn log10(self) -> f32 {\n+        unsafe { intrinsics::log10f32(self) }\n+    }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline]\n+    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline]\n+    fn to_radians(self) -> f32 {\n+        let value: f32 = Float::pi();\n+        self * (value / 180.0f32)\n+    }\n+}"}, {"sha": "2c802f5d059f1f3dcb7226321f0142a887b16396", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 274, "deletions": 1, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -12,7 +12,10 @@\n \n use default::Default;\n use intrinsics;\n-use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use mem;\n+use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use option::Option;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -225,3 +228,273 @@ impl Bounded for f64 {\n     #[inline]\n     fn max_value() -> f64 { MAX_VALUE }\n }\n+\n+impl Float for f64 {\n+    #[inline]\n+    fn nan() -> f64 { NAN }\n+\n+    #[inline]\n+    fn infinity() -> f64 { INFINITY }\n+\n+    #[inline]\n+    fn neg_infinity() -> f64 { NEG_INFINITY }\n+\n+    #[inline]\n+    fn neg_zero() -> f64 { -0.0 }\n+\n+    /// Returns `true` if the number is NaN\n+    #[inline]\n+    fn is_nan(self) -> bool { self != self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline]\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline]\n+    fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline]\n+    fn is_normal(self) -> bool {\n+        self.classify() == FPNormal\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n+        static EXP_MASK: u64 = 0x7ff0000000000000;\n+        static MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        let bits: u64 = unsafe { mem::transmute(self) };\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0)        => FPZero,\n+            (_, 0)        => FPSubnormal,\n+            (0, EXP_MASK) => FPInfinite,\n+            (_, EXP_MASK) => FPNaN,\n+            _             => FPNormal,\n+        }\n+    }\n+\n+    #[inline]\n+    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n+\n+    #[inline]\n+    fn digits(_: Option<f64>) -> uint { DIGITS }\n+\n+    #[inline]\n+    fn epsilon() -> f64 { EPSILON }\n+\n+    #[inline]\n+    fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n+\n+    #[inline]\n+    fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n+\n+    #[inline]\n+    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n+\n+    #[inline]\n+    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n+\n+    #[inline]\n+    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { mem::transmute(self) };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n+    /// Round half-way cases toward `NEG_INFINITY`\n+    #[inline]\n+    fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n+\n+    /// Round half-way cases toward `INFINITY`\n+    #[inline]\n+    fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline]\n+    fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline]\n+    fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n+\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f64;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n+    #[inline]\n+    fn fract(self) -> f64 { self - self.trunc() }\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[inline]\n+    fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n+\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline]\n+    fn recip(self) -> f64 { 1.0 / self }\n+\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n+\n+    /// sqrt(2.0)\n+    #[inline]\n+    fn sqrt2() -> f64 { consts::SQRT2 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline]\n+    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n+\n+    #[inline]\n+    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n+\n+    /// Archimedes' constant\n+    #[inline]\n+    fn pi() -> f64 { consts::PI }\n+\n+    /// 2.0 * pi\n+    #[inline]\n+    fn two_pi() -> f64 { consts::PI_2 }\n+\n+    /// pi / 2.0\n+    #[inline]\n+    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n+\n+    /// pi / 3.0\n+    #[inline]\n+    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n+\n+    /// pi / 4.0\n+    #[inline]\n+    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n+\n+    /// pi / 6.0\n+    #[inline]\n+    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n+\n+    /// pi / 8.0\n+    #[inline]\n+    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n+\n+    /// 1.0 / pi\n+    #[inline]\n+    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline]\n+    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n+\n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f64 { consts::E }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f64 { consts::LOG2_E }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f64 { consts::LOG10_E }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f64 { consts::LN_2 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f64 { consts::LN_10 }\n+\n+    /// Returns the exponential of the number\n+    #[inline]\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n+\n+    /// Returns 2 raised to the power of the number\n+    #[inline]\n+    fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number\n+    #[inline]\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n+\n+    /// Returns the logarithm of the number with respect to an arbitrary base\n+    #[inline]\n+    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n+\n+    /// Returns the base 2 logarithm of the number\n+    #[inline]\n+    fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n+\n+    /// Returns the base 10 logarithm of the number\n+    #[inline]\n+    fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n+\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline]\n+    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline]\n+    fn to_radians(self) -> f64 {\n+        let value: f64 = Float::pi();\n+        self * (value / 180.0)\n+    }\n+}\n+"}, {"sha": "47be5df67eabdb345c963e9cc58ccd9dfcaf8c39", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -874,3 +874,157 @@ pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n     assert_eq!(ten.div(&two),  ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n+\n+/// Used for representing the classification of floating point numbers\n+#[deriving(Eq, Show)]\n+pub enum FPCategory {\n+    /// \"Not a Number\", often obtained by dividing by zero\n+    FPNaN,\n+    /// Positive or negative infinity\n+    FPInfinite ,\n+    /// Positive or negative zero\n+    FPZero,\n+    /// De-normalized floating point representation (less precise than `FPNormal`)\n+    FPSubnormal,\n+    /// A regular floating point number\n+    FPNormal,\n+}\n+\n+/// Operations on primitive floating point numbers.\n+// FIXME(#5527): In a future version of Rust, many of these functions will\n+//               become constants.\n+//\n+// FIXME(#8888): Several of these functions have a parameter named\n+//               `unused_self`. Removing it requires #8888 to be fixed.\n+pub trait Float: Signed + Primitive {\n+    /// Returns the NaN value.\n+    fn nan() -> Self;\n+    /// Returns the infinite value.\n+    fn infinity() -> Self;\n+    /// Returns the negative infinite value.\n+    fn neg_infinity() -> Self;\n+    /// Returns -0.0.\n+    fn neg_zero() -> Self;\n+\n+    /// Returns true if this value is NaN and false otherwise.\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    fn is_infinite(self) -> bool;\n+    /// Returns true if this number is neither infinite nor NaN.\n+    fn is_finite(self) -> bool;\n+    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    fn is_normal(self) -> bool;\n+    /// Returns the category that this number falls into.\n+    fn classify(self) -> FPCategory;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Returns the number of binary digits of mantissa that this type supports.\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the number of base-10 digits of precision that this type supports.\n+    fn digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    fn epsilon() -> Self;\n+    /// Returns the minimum binary exponent that this type can represent.\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum binary exponent that this type can represent.\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the minimum base-10 exponent that this type can represent.\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum base-10 exponent that this type can represent.\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the smallest normalized positive number that this type can represent.\n+    fn min_pos_value(unused_self: Option<Self>) -> Self;\n+\n+    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    fn integer_decode(self) -> (u64, i16, i8);\n+\n+    /// Return the largest integer less than or equal to a number.\n+    fn floor(self) -> Self;\n+    /// Return the smallest integer greater than or equal to a number.\n+    fn ceil(self) -> Self;\n+    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// `0.0`.\n+    fn round(self) -> Self;\n+    /// Return the integer part of a number.\n+    fn trunc(self) -> Self;\n+    /// Return the fractional part of a number.\n+    fn fract(self) -> Self;\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    fn recip(self) -> Self;\n+\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    fn powf(self, n: Self) -> Self;\n+\n+    /// sqrt(2.0).\n+    fn sqrt2() -> Self;\n+    /// 1.0 / sqrt(2.0).\n+    fn frac_1_sqrt2() -> Self;\n+\n+    /// Take the square root of a number.\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    fn rsqrt(self) -> Self;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Archimedes' constant.\n+    fn pi() -> Self;\n+    /// 2.0 * pi.\n+    fn two_pi() -> Self;\n+    /// pi / 2.0.\n+    fn frac_pi_2() -> Self;\n+    /// pi / 3.0.\n+    fn frac_pi_3() -> Self;\n+    /// pi / 4.0.\n+    fn frac_pi_4() -> Self;\n+    /// pi / 6.0.\n+    fn frac_pi_6() -> Self;\n+    /// pi / 8.0.\n+    fn frac_pi_8() -> Self;\n+    /// 1.0 / pi.\n+    fn frac_1_pi() -> Self;\n+    /// 2.0 / pi.\n+    fn frac_2_pi() -> Self;\n+    /// 2.0 / sqrt(pi).\n+    fn frac_2_sqrtpi() -> Self;\n+\n+    /// Euler's number.\n+    fn e() -> Self;\n+    /// log2(e).\n+    fn log2_e() -> Self;\n+    /// log10(e).\n+    fn log10_e() -> Self;\n+    /// ln(2.0).\n+    fn ln_2() -> Self;\n+    /// ln(10.0).\n+    fn ln_10() -> Self;\n+\n+    /// Returns `e^(self)`, (the exponential function).\n+    fn exp(self) -> Self;\n+    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    fn exp2(self) -> Self;\n+    /// Returns the natural logarithm of the number.\n+    fn ln(self) -> Self;\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n+    fn log(self, base: Self) -> Self;\n+    /// Returns the base 2 logarithm of the number.\n+    fn log2(self) -> Self;\n+    /// Returns the base 10 logarithm of the number.\n+    fn log10(self) -> Self;\n+\n+    /// Convert radians to degrees.\n+    fn to_degrees(self) -> Self;\n+    /// Convert degrees to radians.\n+    fn to_radians(self) -> Self;\n+}"}, {"sha": "2fc46628616fc289e611929418296385369ba6fe", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -78,15 +78,15 @@ impl<T: Clone + Num> Complex<T> {\n     }\n }\n \n-impl<T: Clone + Float> Complex<T> {\n+impl<T: Clone + FloatMath> Complex<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n         self.re.hypot(self.im)\n     }\n }\n \n-impl<T: Clone + Float> Complex<T> {\n+impl<T: Clone + FloatMath> Complex<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {"}, {"sha": "cf02d5b0d5f0ad953b859ffa31f6123a4c761d56", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 267, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -18,7 +18,6 @@ use prelude::*;\n use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n-use mem;\n use num::strconv;\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num;\n@@ -69,82 +68,7 @@ mod cmath {\n     }\n }\n \n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { NAN }\n-\n-    #[inline]\n-    fn infinity() -> f32 { INFINITY }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 { NEG_INFINITY }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(self) -> bool { self != self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> FPCategory {\n-        static EXP_MASK: u32 = 0x7f800000;\n-        static MAN_MASK: u32 = 0x007fffff;\n-\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n-\n-    #[inline]\n-    fn digits(_: Option<f32>) -> uint { DIGITS }\n-\n-    #[inline]\n-    fn epsilon() -> f32 { EPSILON }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n-\n-    #[inline]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n-\n+impl FloatMath for f32 {\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -166,61 +90,13 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     #[inline]\n     fn next_after(self, other: f32) -> f32 {\n         unsafe { cmath::nextafterf(self, other) }\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(self) -> f32 {\n-        unsafe { intrinsics::floorf32(self) }\n-    }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(self) -> f32 {\n-        unsafe { intrinsics::ceilf32(self) }\n-    }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(self) -> f32 {\n-        unsafe { intrinsics::roundf32(self) }\n-    }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(self) -> f32 {\n-        unsafe { intrinsics::truncf32(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f32;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f32 { self - self.trunc() }\n-\n     #[inline]\n     fn max(self, other: f32) -> f32 {\n         unsafe { cmath::fmaxf(self, other) }\n@@ -231,43 +107,6 @@ impl Float for f32 {\n         unsafe { cmath::fminf(self, other) }\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 {\n-        unsafe { intrinsics::fmaf32(self, a, b) }\n-    }\n-\n-    /// The reciprocal (multiplicative inverse) of the number\n-    #[inline]\n-    fn recip(self) -> f32 { 1.0 / self }\n-\n-    fn powi(self, n: i32) -> f32 {\n-        unsafe { intrinsics::powif32(self, n) }\n-    }\n-\n-    #[inline]\n-    fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n-    }\n-\n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f32 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f32 { consts::FRAC_1_SQRT2 }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 {\n-        unsafe { intrinsics::sqrtf32(self) }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n-\n     #[inline]\n     fn cbrt(self) -> f32 {\n         unsafe { cmath::cbrtf(self) }\n@@ -278,46 +117,6 @@ impl Float for f32 {\n         unsafe { cmath::hypotf(self, other) }\n     }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f32 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f32 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f32 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f32 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f32 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f32 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f32 { consts::FRAC_PI_8 }\n-\n-    /// 1 .0/ pi\n-    #[inline]\n-    fn frac_1_pi() -> f32 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f32 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f32 { consts::FRAC_2_SQRTPI }\n-\n     #[inline]\n     fn sin(self) -> f32 {\n         unsafe { intrinsics::sinf32(self) }\n@@ -359,67 +158,13 @@ impl Float for f32 {\n         (self.sin(), self.cos())\n     }\n \n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f32 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f32 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f32 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f32 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f32 { consts::LN_10 }\n-\n-    /// Returns the exponential of the number\n-    #[inline]\n-    fn exp(self) -> f32 {\n-        unsafe { intrinsics::expf32(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number\n-    #[inline]\n-    fn exp2(self) -> f32 {\n-        unsafe { intrinsics::exp2f32(self) }\n-    }\n-\n     /// Returns the exponential of the number, minus `1`, in a way that is\n     /// accurate even if the number is close to zero\n     #[inline]\n     fn exp_m1(self) -> f32 {\n         unsafe { cmath::expm1f(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n-    #[inline]\n-    fn ln(self) -> f32 {\n-        unsafe { intrinsics::logf32(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number\n-    #[inline]\n-    fn log2(self) -> f32 {\n-        unsafe { intrinsics::log2f32(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number\n-    #[inline]\n-    fn log10(self) -> f32 {\n-        unsafe { intrinsics::log10f32(self) }\n-    }\n-\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately\n     #[inline]\n@@ -486,17 +231,6 @@ impl Float for f32 {\n     fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Converts to degrees, assuming the number is in radians\n-    #[inline]\n-    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n-\n-    /// Converts to radians, assuming the number is in degrees\n-    #[inline]\n-    fn to_radians(self) -> f32 {\n-        let value: f32 = Float::pi();\n-        self * (value / 180.0f32)\n-    }\n }\n \n //"}, {"sha": "41aeb27362e7f4722b4a4c038f4e9e75f2ca6a44", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 3, "deletions": 272, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -15,11 +15,8 @@\n use prelude::*;\n \n use from_str::FromStr;\n-use intrinsics;\n-use libc::{c_int};\n-use mem;\n-use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{strconv};\n+use libc::c_int;\n+use num::strconv;\n use num;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n@@ -77,82 +74,7 @@ mod cmath {\n     }\n }\n \n-impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 { NAN }\n-\n-    #[inline]\n-    fn infinity() -> f64 { INFINITY }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 { NEG_INFINITY }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 { -0.0 }\n-\n-    /// Returns `true` if the number is NaN\n-    #[inline]\n-    fn is_nan(self) -> bool { self != self }\n-\n-    /// Returns `true` if the number is infinite\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> FPCategory {\n-        static EXP_MASK: u64 = 0x7ff0000000000000;\n-        static MAN_MASK: u64 = 0x000fffffffffffff;\n-\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n-        }\n-    }\n-\n-    #[inline]\n-    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n-\n-    #[inline]\n-    fn digits(_: Option<f64>) -> uint { DIGITS }\n-\n-    #[inline]\n-    fn epsilon() -> f64 { EPSILON }\n-\n-    #[inline]\n-    fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n-\n-    #[inline]\n-    fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n-\n-    #[inline]\n-    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n-\n-    #[inline]\n-    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n-\n-    #[inline]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n-\n+impl FloatMath for f64 {\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -174,61 +96,13 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     #[inline]\n     fn next_after(self, other: f64) -> f64 {\n         unsafe { cmath::nextafter(self, other) }\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(self) -> f64 {\n-        unsafe { intrinsics::floorf64(self) }\n-    }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(self) -> f64 {\n-        unsafe { intrinsics::ceilf64(self) }\n-    }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(self) -> f64 {\n-        unsafe { intrinsics::roundf64(self) }\n-    }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(self) -> f64 {\n-        unsafe { intrinsics::truncf64(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f64;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f64 { self - self.trunc() }\n-\n     #[inline]\n     fn max(self, other: f64) -> f64 {\n         unsafe { cmath::fmax(self, other) }\n@@ -239,44 +113,6 @@ impl Float for f64 {\n         unsafe { cmath::fmin(self, other) }\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 {\n-        unsafe { intrinsics::fmaf64(self, a, b) }\n-    }\n-\n-    /// The reciprocal (multiplicative inverse) of the number\n-    #[inline]\n-    fn recip(self) -> f64 { 1.0 / self }\n-\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f64 {\n-        unsafe { intrinsics::powif64(self, n) }\n-    }\n-\n-    /// sqrt(2.0)\n-    #[inline]\n-    fn sqrt2() -> f64 { consts::SQRT2 }\n-\n-    /// 1.0 / sqrt(2.0)\n-    #[inline]\n-    fn frac_1_sqrt2() -> f64 { consts::FRAC_1_SQRT2 }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 {\n-        unsafe { intrinsics::sqrtf64(self) }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n-\n     #[inline]\n     fn cbrt(self) -> f64 {\n         unsafe { cmath::cbrt(self) }\n@@ -287,46 +123,6 @@ impl Float for f64 {\n         unsafe { cmath::hypot(self, other) }\n     }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f64 { consts::PI }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f64 { consts::PI_2 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f64 { consts::FRAC_PI_2 }\n-\n-    /// pi / 3.0\n-    #[inline]\n-    fn frac_pi_3() -> f64 { consts::FRAC_PI_3 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f64 { consts::FRAC_PI_4 }\n-\n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f64 { consts::FRAC_PI_6 }\n-\n-    /// pi / 8.0\n-    #[inline]\n-    fn frac_pi_8() -> f64 { consts::FRAC_PI_8 }\n-\n-    /// 1.0 / pi\n-    #[inline]\n-    fn frac_1_pi() -> f64 { consts::FRAC_1_PI }\n-\n-    /// 2.0 / pi\n-    #[inline]\n-    fn frac_2_pi() -> f64 { consts::FRAC_2_PI }\n-\n-    /// 2.0 / sqrt(pi)\n-    #[inline]\n-    fn frac_2_sqrtpi() -> f64 { consts::FRAC_2_SQRTPI }\n-\n     #[inline]\n     fn sin(self) -> f64 {\n         unsafe { intrinsics::sinf64(self) }\n@@ -368,67 +164,13 @@ impl Float for f64 {\n         (self.sin(), self.cos())\n     }\n \n-    /// Euler's number\n-    #[inline]\n-    fn e() -> f64 { consts::E }\n-\n-    /// log2(e)\n-    #[inline]\n-    fn log2_e() -> f64 { consts::LOG2_E }\n-\n-    /// log10(e)\n-    #[inline]\n-    fn log10_e() -> f64 { consts::LOG10_E }\n-\n-    /// ln(2.0)\n-    #[inline]\n-    fn ln_2() -> f64 { consts::LN_2 }\n-\n-    /// ln(10.0)\n-    #[inline]\n-    fn ln_10() -> f64 { consts::LN_10 }\n-\n-    /// Returns the exponential of the number\n-    #[inline]\n-    fn exp(self) -> f64 {\n-        unsafe { intrinsics::expf64(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number\n-    #[inline]\n-    fn exp2(self) -> f64 {\n-        unsafe { intrinsics::exp2f64(self) }\n-    }\n-\n     /// Returns the exponential of the number, minus `1`, in a way that is\n     /// accurate even if the number is close to zero\n     #[inline]\n     fn exp_m1(self) -> f64 {\n         unsafe { cmath::expm1(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n-    #[inline]\n-    fn ln(self) -> f64 {\n-        unsafe { intrinsics::logf64(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number\n-    #[inline]\n-    fn log2(self) -> f64 {\n-        unsafe { intrinsics::log2f64(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number\n-    #[inline]\n-    fn log10(self) -> f64 {\n-        unsafe { intrinsics::log10f64(self) }\n-    }\n-\n     /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately\n     #[inline]\n@@ -495,17 +237,6 @@ impl Float for f64 {\n     fn atanh(self) -> f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-\n-    /// Converts to degrees, assuming the number is in radians\n-    #[inline]\n-    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n-\n-    /// Converts to radians, assuming the number is in degrees\n-    #[inline]\n-    fn to_radians(self) -> f64 {\n-        let value: f64 = Float::pi();\n-        self * (value / 180.0)\n-    }\n }\n \n //"}, {"sha": "3178fcbd66fdb8958e423a352f41942b134f2e33", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 150, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -30,71 +30,13 @@ pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n+pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n+pub use core::num::{FPNormal, Float};\n \n pub mod strconv;\n \n-/// Used for representing the classification of floating point numbers\n-#[deriving(Eq, Show)]\n-pub enum FPCategory {\n-    /// \"Not a Number\", often obtained by dividing by zero\n-    FPNaN,\n-    /// Positive or negative infinity\n-    FPInfinite ,\n-    /// Positive or negative zero\n-    FPZero,\n-    /// De-normalized floating point representation (less precise than `FPNormal`)\n-    FPSubnormal,\n-    /// A regular floating point number\n-    FPNormal,\n-}\n-\n-/// Operations on primitive floating point numbers.\n-// FIXME(#5527): In a future version of Rust, many of these functions will\n-//               become constants.\n-//\n-// FIXME(#8888): Several of these functions have a parameter named\n-//               `unused_self`. Removing it requires #8888 to be fixed.\n-pub trait Float: Signed + Primitive {\n-    /// Returns the NaN value.\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    fn neg_infinity() -> Self;\n-    /// Returns -0.0.\n-    fn neg_zero() -> Self;\n-\n-    /// Returns true if this value is NaN and false otherwise.\n-    fn is_nan(self) -> bool;\n-    /// Returns true if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    fn is_infinite(self) -> bool;\n-    /// Returns true if this number is neither infinite nor NaN.\n-    fn is_finite(self) -> bool;\n-    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(self) -> bool;\n-    /// Returns the category that this number falls into.\n-    fn classify(self) -> FPCategory;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Returns the number of binary digits of mantissa that this type supports.\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n-    fn digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n-    fn min_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum binary exponent that this type can represent.\n-    fn max_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-\n+/// Mathematical operations on primitive floating point numbers.\n+pub trait FloatMath: Float {\n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n     fn ldexp(x: Self, exp: int) -> Self;\n@@ -105,82 +47,22 @@ pub trait Float: Signed + Primitive {\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n     fn frexp(self) -> (Self, int);\n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     fn next_after(self, other: Self) -> Self;\n \n-    /// Return the largest integer less than or equal to a number.\n-    fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    fn round(self) -> Self;\n-    /// Return the integer part of a number.\n-    fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n-    fn fract(self) -> Self;\n-\n     /// Returns the maximum of the two numbers.\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n     fn min(self, other: Self) -> Self;\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(self) -> Self;\n-\n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n-    fn powf(self, n: Self) -> Self;\n-\n-    /// sqrt(2.0).\n-    fn sqrt2() -> Self;\n-    /// 1.0 / sqrt(2.0).\n-    fn frac_1_sqrt2() -> Self;\n-\n-    /// Take the square root of a number.\n-    fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(self) -> Self;\n     /// Take the cubic root of a number.\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n     fn hypot(self, other: Self) -> Self;\n \n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Archimedes' constant.\n-    fn pi() -> Self;\n-    /// 2.0 * pi.\n-    fn two_pi() -> Self;\n-    /// pi / 2.0.\n-    fn frac_pi_2() -> Self;\n-    /// pi / 3.0.\n-    fn frac_pi_3() -> Self;\n-    /// pi / 4.0.\n-    fn frac_pi_4() -> Self;\n-    /// pi / 6.0.\n-    fn frac_pi_6() -> Self;\n-    /// pi / 8.0.\n-    fn frac_pi_8() -> Self;\n-    /// 1.0 / pi.\n-    fn frac_1_pi() -> Self;\n-    /// 2.0 / pi.\n-    fn frac_2_pi() -> Self;\n-    /// 2.0 / sqrt(pi).\n-    fn frac_2_sqrtpi() -> Self;\n-\n     /// Computes the sine of a number (in radians).\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n@@ -206,32 +88,9 @@ pub trait Float: Signed + Primitive {\n     /// `(sin(x), cos(x))`.\n     fn sin_cos(self) -> (Self, Self);\n \n-    /// Euler's number.\n-    fn e() -> Self;\n-    /// log2(e).\n-    fn log2_e() -> Self;\n-    /// log10(e).\n-    fn log10_e() -> Self;\n-    /// ln(2.0).\n-    fn ln_2() -> Self;\n-    /// ln(10.0).\n-    fn ln_10() -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    fn exp(self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(self) -> Self;\n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n     fn exp_m1(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    fn log10(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n     fn ln_1p(self) -> Self;\n@@ -248,11 +107,6 @@ pub trait Float: Signed + Primitive {\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n     fn atanh(self) -> Self;\n-\n-    /// Convert radians to degrees.\n-    fn to_degrees(self) -> Self;\n-    /// Convert degrees to radians.\n-    fn to_radians(self) -> Self;\n }\n \n /// A generic trait for converting a value to a string with a radix (base)"}, {"sha": "b3c768a519924c05f1cc63a10785374d8c8335c7", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0a984a862f4f4246a3be014b9b244525bedd20/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=ba0a984a862f4f4246a3be014b9b244525bedd20", "patch": "@@ -38,7 +38,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: Float + FromPrimitive>{\n+pub trait Stats <T: FloatMath + FromPrimitive>{\n \n     /// Sum of the samples.\n     ///\n@@ -143,7 +143,7 @@ pub struct Summary<T> {\n     pub iqr: T,\n }\n \n-impl<T: Float + FromPrimitive> Summary<T> {\n+impl<T: FloatMath + FromPrimitive> Summary<T> {\n \n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n@@ -164,7 +164,7 @@ impl<T: Float + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<'a,T: Float + FromPrimitive> Stats<T> for &'a [T] {\n+impl<'a,T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     // FIXME #11059 handle NaN, inf and overflow\n     #[allow(deprecated_owned_vector)]"}]}