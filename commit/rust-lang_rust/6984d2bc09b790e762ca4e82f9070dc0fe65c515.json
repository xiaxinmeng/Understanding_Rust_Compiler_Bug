{"sha": "6984d2bc09b790e762ca4e82f9070dc0fe65c515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ODRkMmJjMDliNzkwZTc2MmNhNGU4MmY5MDcwZGMwZmU2NWM1MTU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-26T12:26:43Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-26T12:33:51Z"}, "message": "added helpful links to lints that have wiki entries", "tree": {"sha": "2ed88daf6166d5473c5f3f626322cd567c28be0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ed88daf6166d5473c5f3f626322cd567c28be0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6984d2bc09b790e762ca4e82f9070dc0fe65c515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6984d2bc09b790e762ca4e82f9070dc0fe65c515", "html_url": "https://github.com/rust-lang/rust/commit/6984d2bc09b790e762ca4e82f9070dc0fe65c515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6984d2bc09b790e762ca4e82f9070dc0fe65c515/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e341715cdec721b8af9c3f1125285309f4c07c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e341715cdec721b8af9c3f1125285309f4c07c2", "html_url": "https://github.com/rust-lang/rust/commit/5e341715cdec721b8af9c3f1125285309f4c07c2"}], "stats": {"total": 233, "additions": 150, "deletions": 83}, "files": [{"sha": "0ec2f94cab8aaea58adb07077607492c9891b400", "filename": "src/approx_const.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -3,7 +3,7 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use std::f64::consts as f64;\n \n-use utils::span_lint;\n+use utils::span_help_and_lint;\n \n declare_lint! {\n     pub APPROX_CONSTANT,\n@@ -40,7 +40,8 @@ fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n     match lit.node {\n         LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n         LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+        LitFloatUnsuffixed(ref str) => \n+            check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n }\n@@ -49,13 +50,18 @@ fn check_known_consts(cx: &Context, span: Span, str: &str, module: &str) {\n     if let Ok(value) = str.parse::<f64>() {\n         for &(constant, name) in KNOWN_CONSTS {\n             if within_epsilon(constant, value) {\n-                span_lint(cx, APPROX_CONSTANT, span, &format!(\n-                    \"approximate value of `{}::{}` found. Consider using it directly\", module, &name));\n+                span_help_and_lint(cx, APPROX_CONSTANT, span, &format!(\n+                    \"approximate value of `{}::{}` found. \\\n+                    Consider using it directly\", module, &name),\n+                    \"for further information see https://github.com/\\\n+                     Manishearth/rust-clippy/wiki#approx_constant\");\n             }\n         }\n     }\n }\n \n fn within_epsilon(target: f64, value: f64) -> bool {\n-    f64::abs(value - target) < f64::abs((if target > value { target } else { value })) / EPSILON_DIVISOR\n+    f64::abs(value - target) < f64::abs(if target > value { \n+                                            target \n+                                        } else { value }) / EPSILON_DIVISOR\n }"}, {"sha": "a9ee9402e28467028e015151e97e702bbf0479c9", "filename": "src/attrs.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -4,7 +4,7 @@ use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, match_path, span_lint};\n+use utils::{in_macro, match_path, span_help_and_lint};\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"`#[inline(always)]` is a bad idea in most cases\" }\n@@ -98,10 +98,12 @@ fn check_attrs(cx: &Context, info: Option<&ExpnInfo>, ident: &Ident,\n             if values.len() != 1 || inline != &\"inline\" { continue; }\n             if let MetaWord(ref always) = values[0].node {\n                 if always != &\"always\" { continue; }\n-                span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n+                span_help_and_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n                     \"you have declared `#[inline(always)]` on `{}`. This \\\n                      is usually a bad idea. Are you sure?\",\n-                    ident.name));\n+                    ident.name),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#inline_always\");\n             }\n         }\n     }"}, {"sha": "6817dd3d97b71a6ad0a26705cea9c2545d81be56", "filename": "src/bit_mask.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -5,7 +5,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_comparison_binop;\n use syntax::codemap::Span;\n \n-use utils::span_lint;\n+use utils::span_help_and_lint;\n \n declare_lint! {\n     pub BAD_BIT_MASK,\n@@ -100,38 +100,50 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         BiEq | BiNe => match bit_op {\n             BiBitAnd => if mask_value & cmp_value != mask_value {\n                 if cmp_value != 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                    span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                         \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                        mask_value, cmp_value));\n+                        mask_value, cmp_value),\n+                        \"for further information see https://github.com/\\\n+                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n                 }\n             } else {\n                 if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span,\n-                              &format!(\"&-masking with zero\"));\n+                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n+                        \"&-masking with zero\",\n+                        \"for further information see https://github.com/\\\n+                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n                 }\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                    mask_value, cmp_value));\n+                    mask_value, cmp_value),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n             },\n             _ => ()\n         },\n         BiLt | BiGe => match bit_op {\n             BiBitAnd => if mask_value < cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                    mask_value, cmp_value));\n+                    mask_value, cmp_value),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n             } else {\n                 if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span,\n-                              &format!(\"&-masking with zero\"));\n+                    span_help_and_lint(cx, BAD_BIT_MASK, *span,\n+                        \"&-masking with zero\",\n+                        \"for further information see https://github.com/\\\n+                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n                 }\n             },\n             BiBitOr => if mask_value >= cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                    mask_value, cmp_value));\n+                    mask_value, cmp_value),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n             } else {\n                 check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -141,19 +153,25 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n         },\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                    mask_value, cmp_value));\n+                    mask_value, cmp_value),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n             } else {\n                 if mask_value == 0 {\n-                    span_lint(cx, BAD_BIT_MASK, *span,\n-                              &format!(\"&-masking with zero\"));\n+                    span_help_and_lint(cx, BAD_BIT_MASK, *span, \n+                        \"&-masking with zero\",\n+                        \"for further information see https://github.com/\\\n+                        Manishearth/rust-clippy/wiki#bad_bit_mask\");\n                 }\n             },\n             BiBitOr => if mask_value > cmp_value {\n-                span_lint(cx, BAD_BIT_MASK, *span, &format!(\n+                span_help_and_lint(cx, BAD_BIT_MASK, *span, &format!(\n                     \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                    mask_value, cmp_value));\n+                    mask_value, cmp_value),\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#bad_bit_mask\");\n             } else {\n                 check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n             },\n@@ -167,17 +185,21 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_,\n \n fn check_ineffective_lt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if c.is_power_of_two() && m < c {\n-        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c));\n+            op, m, c),\n+            \"for further information see https://github.com/\\\n+            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n     }\n }\n \n fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n-        span_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n+        span_help_and_lint(cx, INEFFECTIVE_BIT_MASK, span, &format!(\n             \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-            op, m, c));\n+            op, m, c),\n+            \"for further information see https://github.com/\\\n+            Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n     }\n }\n "}, {"sha": "d3d99e93b0bea0f14ae074e2932598bbf3fab490", "filename": "src/misc.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -6,7 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n \n-use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, span_help_and_lint, walk_ptrs_ty};\n use consts::constant;\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n@@ -65,8 +65,10 @@ impl LintPass for CmpNan {\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n     path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n-        span_lint(cx, CMP_NAN, span,\n-                  \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        span_help_and_lint(cx, CMP_NAN, span,\n+            \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n+            \"for further information see https://github.com/\\\n+            Manishearth/rust-clippy/wiki#cmp_nan\");\n     });\n }\n \n@@ -124,9 +126,11 @@ impl LintPass for Precedence {\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-                span_lint(cx, PRECEDENCE, expr.span,\n+                span_help_and_lint(cx, PRECEDENCE, expr.span,\n                     \"operator precedence can trip the unwary. Consider adding parentheses \\\n-                     to the subexpression\");\n+                     to the subexpression\",\n+                    \"for further information see https://github.com/\\\n+                     Manishearth/rust-clippy/wiki#precedence\");\n             }\n         }\n     }"}, {"sha": "e4b14c22115ea091ac70a929e766cca0c9669a5f", "filename": "src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -60,7 +60,7 @@ impl ReturnPass {\n     fn emit_return_lint(&mut self, cx: &Context, spans: (Span, Span)) {\n         span_lint(cx, NEEDLESS_RETURN, spans.0, &format!(\n             \"unneeded return statement. Consider using `{}` \\\n-             without the trailing semicolon\",\n+             without the return and trailing semicolon\",\n             snippet(cx, spans.1, \"..\")))\n     }\n "}, {"sha": "717c06a4c14e1593aa6a92fff42cf9bc44d7eeb6", "filename": "src/shadow.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -6,7 +6,7 @@ use syntax::visit::FnKind;\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{in_external_macro, snippet, span_lint};\n+use utils::{in_external_macro, snippet, span_help_and_lint};\n \n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n@@ -114,26 +114,34 @@ fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n         &Option<T>) where T: Deref<Target=Expr> {\n     if let &Some(ref expr) = init {\n         if is_self_shadow(name, expr) {\n-            span_lint(cx, SHADOW_SAME, span, &format!(\n+            span_help_and_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n-                snippet(cx, expr.span, \"..\")));\n+                snippet(cx, expr.span, \"..\")),\n+                \"for further information see \\\n+                https://github.com/Manishearth/rust-clippy/wiki#shadow_same\");\n         } else {\n             if contains_self(name, expr) {\n-                span_lint(cx, SHADOW_REUSE, span, &format!(\n+                span_help_and_lint(cx, SHADOW_REUSE, span, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")));\n+                    snippet(cx, expr.span, \"..\")),\n+                    \"for further information see https://\\\n+                    github.com/Manishearth/rust-clippy/wiki#shadow_reuse\");\n             } else {\n-                span_lint(cx, SHADOW_UNRELATED, span, &format!(\n+                span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n                     \"{} is shadowed by {} in this declaration\",\n                     snippet(cx, lspan, \"_\"),\n-                    snippet(cx, expr.span, \"..\")));\n+                    snippet(cx, expr.span, \"..\")),\n+                    \"for further information see https://github.com\\\n+                    /Manishearth/rust-clippy/wiki#shadow_unrelated\");\n             }\n         }\n     } else {\n-        span_lint(cx, SHADOW_UNRELATED, span, &format!(\n-            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")));\n+        span_help_and_lint(cx, SHADOW_UNRELATED, span, &format!(\n+            \"{} is shadowed in this declaration\", snippet(cx, lspan, \"_\")),\n+            \"for further information see \\\n+            https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated\");\n     }\n }\n "}, {"sha": "8e10cfaa72cff8e01482796e92194675fbec74b1", "filename": "src/strings.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_help_and_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n declare_lint! {\n@@ -45,16 +45,19 @@ impl LintPass for StringAdd {\n                         }\n                     }\n                 }\n-                //TODO check for duplicates\n-                 span_lint(cx, STRING_ADD, e.span,\n-                        \"you added something to a string. \\\n-                         Consider using `String::push_str()` instead\")\n+                span_help_and_lint(cx, STRING_ADD, e.span,\n+                    \"you added something to a string. \\\n+                     Consider using `String::push_str()` instead\",\n+                    \"for further information see https://github.com/\\\n+                     Manishearth/rust-clippy/wiki#string_add\")\n             }\n         } else if let &ExprAssign(ref target, ref  src) = &e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n-                span_lint(cx, STRING_ADD_ASSIGN, e.span,\n+                span_help_and_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\")\n+                     Consider using `String::push_str()` instead\",\n+                    \"for further information see https://github.com/\\\n+                    Manishearth/rust-clippy/wiki#string_add_assign\")\n             }\n         }\n     }"}, {"sha": "700666d0542dd4f748e556bde34086f5e51e7260", "filename": "src/types.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6984d2bc09b790e762ca4e82f9070dc0fe65c515/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=6984d2bc09b790e762ca4e82f9070dc0fe65c515", "patch": "@@ -32,14 +32,17 @@ impl LintPass for TypePass {\n                     span_help_and_lint(\n                         cx, BOX_VEC, ast_ty.span,\n                         \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation. \\\n+                         for further information see https://github.com/\\\n+                         Manishearth/rust-clippy/wiki#box_vec\");\n                 }\n             }\n             else if match_type(cx, ty, &LL_PATH) {\n                 span_help_and_lint(\n                     cx, LINKEDLIST, ast_ty.span,\n                     \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                    \"a RingBuf might work\");\n+                    \"a RingBuf might work; for further information see \\\n+                     https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask\");\n             }\n         }\n     }\n@@ -141,13 +144,15 @@ fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast\n     let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n                          else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n                          else {int_ty_to_nbits(cast_from).to_string()};\n-    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-              &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n-                        ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n-                       cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n-                       if arch_dependent {arch_dependent_str} else {\"\"},\n-                       from_nbits_str,\n-                       mantissa_nbits));\n+    span_help_and_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+        &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n+            ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n+            cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n+            if arch_dependent {arch_dependent_str} else {\"\"},\n+            from_nbits_str,\n+            mantissa_nbits),\n+        \"for further information see https://github.com/\\\n+        Manishearth/rust-clippy/wiki#cast_precision_loss\");\n }\n \n enum ArchSuffix {\n@@ -181,22 +186,26 @@ fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS,\n                 ),\n         };\n     if span_truncation {\n-        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                  &format!(\"casting {} to {} may truncate the value{}\",\n-                           cast_from, cast_to,\n-                           match suffix_truncation {\n-                               ArchSuffix::_32 => arch_32_suffix,\n-                               ArchSuffix::_64 => arch_64_suffix,\n-                               ArchSuffix::None => \"\" }));\n+        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+            &format!(\"casting {} to {} may truncate the value{}\",\n+               cast_from, cast_to,\n+               match suffix_truncation {\n+                   ArchSuffix::_32 => arch_32_suffix,\n+                   ArchSuffix::_64 => arch_64_suffix,\n+                   ArchSuffix::None => \"\" }),\n+            \"for further information see https://github.com/\\\n+            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n     }\n     if span_wrap {\n-        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-                  &format!(\"casting {} to {} may wrap around the value{}\",\n-                           cast_from, cast_to,\n-                           match suffix_wrap {\n-                               ArchSuffix::_32 => arch_32_suffix,\n-                               ArchSuffix::_64 => arch_64_suffix,\n-                               ArchSuffix::None => \"\" }));\n+        span_help_and_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+            &format!(\"casting {} to {} may wrap around the value{}\",\n+                cast_from, cast_to,\n+                match suffix_wrap {\n+                    ArchSuffix::_32 => arch_32_suffix,\n+                    ArchSuffix::_64 => arch_64_suffix,\n+                    ArchSuffix::None => \"\" }),\n+            \"for further information see https://github.com/\\\n+            Manishearth/rust-clippy/wiki#cast_possible_wrap\");\n     }\n }\n \n@@ -221,24 +230,37 @@ impl LintPass for CastPass {\n                         }\n                     },\n                     (false, true) => {\n-                        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n+                        span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                            &format!(\"casting {} to {} may truncate the value\", \n+                                  cast_from, cast_to),\n+                            \"for further information see https://github.com/\\\n+                            Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n                         if !cast_to.is_signed() {\n-                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\", \n+                                    cast_from, cast_to),\n+                                \"for further information see https://github.com/\\\n+                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n                         }\n                     },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n-                            span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                            span_help_and_lint(cx, CAST_SIGN_LOSS, expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\", \n+                                    cast_from, cast_to),\n+                                \"for further information see https://github.com/\\\n+                                Manishearth/rust-clippy/wiki#cast_sign_loss\");\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),\n                                 &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may truncate the value\");\n+                            span_help_and_lint(cx, CAST_POSSIBLE_TRUNCATION, \n+                                expr.span, \n+                                \"casting f64 to f32 may truncate the value\",\n+                                \"for further information see https://github.com/\\\n+                                Manishearth/rust-clippy/wiki#cast_possible_truncation\");\n                         }\n                     }\n                 }"}]}