{"sha": "58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YWYwYzdiNjQ4ZGQ4Y2NmMWYxZDQyNzdjY2Y0ZDgwNGVkNGE5OTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T23:52:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-24T23:52:07Z"}, "message": "Rollup merge of #48296 - ishitatsuyuki:exp-unblow, r=nikomatsakis\n\nFix exponential projection complexity on nested types\n\nThis implements solution 1 from https://github.com/rust-lang/rust/issues/38528#issuecomment-366263076.\n\nThe code quality is currently extremely poor, but we can improve them during review.\n\nBlocking issues:\n\n- we probably don't want a quadratic deduplication for obligations.\n- is there an alternative to deduplication?\n\nBased on #48315.\n\nNeeds changelog. Noticable improvement on compile time is expected.\n\nFix #38528\nClose #39684\nClose #43757", "tree": {"sha": "c956132beac0d44f9aacf484f89d1abdcce09bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c956132beac0d44f9aacf484f89d1abdcce09bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakfqnCRBK7hj4Ov3rIwAAdHIIABJFZLnYIDBRdHb5MG83ZaFd\nFj/avb+IaI4KyF0X4F2Q5NKf3vZZq2xFybyfCjUC2FIbkxQBwCEyBaVehwFVKEW5\nYFIZoQrFzPkDzh0dWjgw7lbEcason+vBxHu3xWdrE3Q6U1NVBE7v8cqI9cTb21Jn\nrrNx4Lm2YgLZKmX5m/wWZV/ZdyhObdnRtVoKJ5Du8qnPIF1cZjwKh2I6bE6CMxZ2\npA/dNHfwfAAP17J13zBhNnC3cDbj4G7MYlsBfbMNyaEJjnImNB9EZ/Xmzbb3/ABM\n2TtPayC0aPrVpP2bGrOnJW1XqxNH2Tl5n/OpLqFk3bwNdTDwVN9lGWg3WikEhDs=\n=CNxT\n-----END PGP SIGNATURE-----\n", "payload": "tree c956132beac0d44f9aacf484f89d1abdcce09bd8\nparent 0957572109490e023104e1bb81dc2622322bdb53\nparent 5a2bec9f453f94a64b3d62bb546eed666969d9cf\nauthor Manish Goregaokar <manishsmail@gmail.com> 1519516327 -0800\ncommitter GitHub <noreply@github.com> 1519516327 -0800\n\nRollup merge of #48296 - ishitatsuyuki:exp-unblow, r=nikomatsakis\n\nFix exponential projection complexity on nested types\n\nThis implements solution 1 from https://github.com/rust-lang/rust/issues/38528#issuecomment-366263076.\n\nThe code quality is currently extremely poor, but we can improve them during review.\n\nBlocking issues:\n\n- we probably don't want a quadratic deduplication for obligations.\n- is there an alternative to deduplication?\n\nBased on #48315.\n\nNeeds changelog. Noticable improvement on compile time is expected.\n\nFix #38528\nClose #39684\nClose #43757\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "html_url": "https://github.com/rust-lang/rust/commit/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0957572109490e023104e1bb81dc2622322bdb53", "url": "https://api.github.com/repos/rust-lang/rust/commits/0957572109490e023104e1bb81dc2622322bdb53", "html_url": "https://github.com/rust-lang/rust/commit/0957572109490e023104e1bb81dc2622322bdb53"}, {"sha": "5a2bec9f453f94a64b3d62bb546eed666969d9cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2bec9f453f94a64b3d62bb546eed666969d9cf", "html_url": "https://github.com/rust-lang/rust/commit/5a2bec9f453f94a64b3d62bb546eed666969d9cf"}], "stats": {"total": 284, "additions": 133, "deletions": 151}, "files": [{"sha": "49f43b18e61987fd005f1aec103f9fe530cdbc65", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -73,7 +73,7 @@ pub enum IntercrateMode {\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -85,7 +85,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -113,7 +113,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -215,7 +215,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BlockTailExpression(ast::NodeId),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -304,7 +304,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -374,13 +374,13 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }"}, {"sha": "1778a8d693a832fc6c1e9a2a010e12eacca3a8d6", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 112, "deletions": 109, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -16,6 +16,7 @@ use super::translate_substs;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n+use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n@@ -101,7 +102,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>\n }\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     // from a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n@@ -110,12 +111,59 @@ enum ProjectionTyCandidate<'tcx> {\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n     // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n-    Select,\n+    Select(Selection<'tcx>),\n }\n \n-struct ProjectionTyCandidateSet<'tcx> {\n-    vec: Vec<ProjectionTyCandidate<'tcx>>,\n-    ambiguous: bool\n+enum ProjectionTyCandidateSet<'tcx> {\n+    None,\n+    Single(ProjectionTyCandidate<'tcx>),\n+    Ambiguous,\n+    Error(SelectionError<'tcx>),\n+}\n+\n+impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+    fn mark_ambiguous(&mut self) {\n+        *self = ProjectionTyCandidateSet::Ambiguous;\n+    }\n+\n+    fn mark_error(&mut self, err: SelectionError<'tcx>) {\n+        *self = ProjectionTyCandidateSet::Error(err);\n+    }\n+\n+    // Returns true if the push was successful, or false if the candidate\n+    // was discarded -- this could be because of ambiguity, or because\n+    // a higher-priority candidate is already there.\n+    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n+        use self::ProjectionTyCandidateSet::*;\n+        use self::ProjectionTyCandidate::*;\n+        match self {\n+            None => {\n+                *self = Single(candidate);\n+                true\n+            }\n+            Single(current) => {\n+                // No duplicates are expected.\n+                assert_ne!(current, &candidate);\n+                // Prefer where-clauses. As in select, if there are multiple\n+                // candidates, we prefer where-clause candidates over impls.  This\n+                // may seem a bit surprising, since impls are the source of\n+                // \"truth\" in some sense, but in fact some of the impls that SEEM\n+                // applicable are not, because of nested obligations. Where\n+                // clauses are the safer choice. See the comment on\n+                // `select::SelectionCandidate` and #21974 for more details.\n+                match (current, candidate) {\n+                    (ParamEnv(..), ParamEnv(..)) => { *self = Ambiguous; }\n+                    (ParamEnv(..), _) => {}\n+                    (_, ParamEnv(..)) => { unreachable!(); }\n+                    (_, _) => { *self = Ambiguous; }\n+                }\n+                false\n+            }\n+            Ambiguous | Error(..) => {\n+                false\n+            }\n+        }\n+    }\n }\n \n /// Evaluates constraints of the form:\n@@ -803,11 +851,11 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    let mut candidates = ProjectionTyCandidateSet {\n-        vec: Vec::new(),\n-        ambiguous: false,\n-    };\n+    let mut candidates = ProjectionTyCandidateSet::None;\n \n+    // Make sure that the following procedures are kept in order. ParamEnv\n+    // needs to be first because it has highest priority, and Select checks\n+    // the return value of push_candidate which assumes it's ran at last.\n     assemble_candidates_from_param_env(selcx,\n                                        obligation,\n                                        &obligation_trait_ref,\n@@ -818,67 +866,27 @@ fn project_type<'cx, 'gcx, 'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n-    if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                   obligation,\n-                                                   &obligation_trait_ref,\n-                                                   &mut candidates) {\n-        return Err(ProjectionTyError::TraitSelectionError(e));\n-    }\n-\n-    debug!(\"{} candidates, ambiguous={}\",\n-           candidates.vec.len(),\n-           candidates.ambiguous);\n-\n-    // Inherent ambiguity that prevents us from even enumerating the\n-    // candidates.\n-    if candidates.ambiguous {\n-        return Err(ProjectionTyError::TooManyCandidates);\n-    }\n-\n-    // Drop duplicates.\n-    //\n-    // Note: `candidates.vec` seems to be on the critical path of the\n-    // compiler. Replacing it with an HashSet was also tried, which would\n-    // render the following dedup unnecessary. The original comment indicated\n-    // that it was 9% slower, but that data is now obsolete and a new\n-    // benchmark should be performed.\n-    candidates.vec.sort_unstable();\n-    candidates.vec.dedup();\n-\n-    // Prefer where-clauses. As in select, if there are multiple\n-    // candidates, we prefer where-clause candidates over impls.  This\n-    // may seem a bit surprising, since impls are the source of\n-    // \"truth\" in some sense, but in fact some of the impls that SEEM\n-    // applicable are not, because of nested obligations. Where\n-    // clauses are the safer choice. See the comment on\n-    // `select::SelectionCandidate` and #21974 for more details.\n-    if candidates.vec.len() > 1 {\n-        debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n-        candidates.vec.retain(|c| match *c {\n-            ProjectionTyCandidate::ParamEnv(..) => true,\n-            ProjectionTyCandidate::TraitDef(..) |\n-            ProjectionTyCandidate::Select => false,\n-        });\n-        debug!(\"resulting candidate set: {:?}\", candidates.vec);\n-        if candidates.vec.len() != 1 {\n-            return Err(ProjectionTyError::TooManyCandidates);\n-        }\n-    }\n-\n-    assert!(candidates.vec.len() <= 1);\n+    assemble_candidates_from_impls(selcx,\n+                                   obligation,\n+                                   &obligation_trait_ref,\n+                                   &mut candidates);\n+\n+    match candidates {\n+        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n+            confirm_candidate(selcx,\n+                              obligation,\n+                              &obligation_trait_ref,\n+                              candidate))),\n+        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+            selcx.tcx().mk_projection(\n+                obligation.predicate.item_def_id,\n+                obligation.predicate.substs))),\n+        // Error occurred while trying to processing impls.\n+        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        // Inherent ambiguity that prevents us from even enumerating the\n+        // candidates.\n+        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n \n-    match candidates.vec.pop() {\n-        Some(candidate) => {\n-            Ok(ProjectedTy::Progress(\n-                confirm_candidate(selcx,\n-                                  obligation,\n-                                  &obligation_trait_ref,\n-                                  candidate)))\n-        }\n-        None => Ok(ProjectedTy::NoProgress(\n-                    selcx.tcx().mk_projection(\n-                        obligation.predicate.item_def_id,\n-                        obligation.predicate.substs)))\n     }\n }\n \n@@ -928,7 +936,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n         ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n-            candidate_set.ambiguous = true;\n+            candidate_set.mark_ambiguous();\n             return;\n         }\n         _ => { return; }\n@@ -962,7 +970,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n                predicate);\n         match predicate {\n-            ty::Predicate::Projection(ref data) => {\n+            ty::Predicate::Projection(data) => {\n                 let same_def_id =\n                     data.0.projection_ty.item_def_id == obligation.predicate.item_def_id;\n \n@@ -985,10 +993,10 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                        data, is_match, same_def_id);\n \n                 if is_match {\n-                    candidate_set.vec.push(ctor(data.clone()));\n+                    candidate_set.push_candidate(ctor(data));\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }\n@@ -998,37 +1006,36 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-    -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    selcx.infcx().probe(|_| {\n+    let _ = selcx.infcx().commit_if_ok(|_| {\n         let vtable = match selcx.select(&trait_obligation) {\n             Ok(Some(vtable)) => vtable,\n             Ok(None) => {\n-                candidate_set.ambiguous = true;\n-                return Ok(());\n+                candidate_set.mark_ambiguous();\n+                return Err(());\n             }\n             Err(e) => {\n                 debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n                        e);\n-                return Err(e);\n+                candidate_set.mark_error(e);\n+                return Err(());\n             }\n         };\n \n-        match vtable {\n+        let eligible = match &vtable {\n             super::VtableClosure(_) |\n             super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n             super::VtableObject(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n                        vtable);\n-\n-                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+                true\n             }\n-            super::VtableImpl(ref impl_data) => {\n+            super::VtableImpl(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // trans (i.e., projection mode is not \"any\"), and the\n@@ -1072,27 +1079,25 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     node_item.item.defaultness.has_value()\n                 } else {\n                     node_item.item.defaultness.is_default() ||\n-                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                        selcx.tcx().impl_is_default(node_item.node.def_id())\n                 };\n \n                 // Only reveal a specializable default if we're past type-checking\n                 // and the obligations is monomorphic, otherwise passes such as\n                 // transmute checking and polymorphic MIR optimizations could\n                 // get a result which isn't correct for all monomorphizations.\n-                let new_candidate = if !is_default {\n-                    Some(ProjectionTyCandidate::Select)\n+                if !is_default {\n+                    true\n                 } else if obligation.param_env.reveal == Reveal::All {\n                     assert!(!poly_trait_ref.needs_infer());\n                     if !poly_trait_ref.needs_subst() {\n-                        Some(ProjectionTyCandidate::Select)\n+                        true\n                     } else {\n-                        None\n+                        false\n                     }\n                 } else {\n-                    None\n-                };\n-\n-                candidate_set.vec.extend(new_candidate);\n+                    false\n+                }\n             }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n@@ -1120,6 +1125,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // in the compiler: a trait predicate (`T : SomeTrait`) and a\n                 // projection. And the projection where clause is handled\n                 // in `assemble_candidates_from_param_env`.\n+                false\n             }\n             super::VtableAutoImpl(..) |\n             super::VtableBuiltin(..) => {\n@@ -1129,10 +1135,18 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     \"Cannot project an associated type from `{:?}`\",\n                     vtable);\n             }\n-        }\n+        };\n \n-        Ok(())\n-    })\n+        if eligible {\n+            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    });\n }\n \n fn confirm_candidate<'cx, 'gcx, 'tcx>(\n@@ -1152,30 +1166,19 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Select => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref)\n+        ProjectionTyCandidate::Select(vtable) => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n         }\n     }\n }\n \n fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    vtable: Selection<'tcx>)\n     -> Progress<'tcx>\n {\n-    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let vtable = match selcx.select(&trait_obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        _ => {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Failed to select `{:?}`\",\n-                trait_obligation);\n-        }\n-    };\n-\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),"}, {"sha": "fca7c3bcb8e25bc6ff9b9691eb466c81a7bca440", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -53,7 +53,7 @@ use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use lint;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n     phantom: PhantomData<&'tcx i32>,\n@@ -3303,7 +3303,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let predicates = predicates.predicates.iter().flat_map(|predicate| {\n+        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain(\n@@ -3314,6 +3314,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     predicate: predicate.value\n                 }))\n         }).collect();\n+        // We are performing deduplication here to avoid exponential blowups\n+        // (#38528) from happening, but the real cause of the duplication is\n+        // unknown. What we know is that the deduplication avoids exponential\n+        // amount of predicates being propogated when processing deeply nested\n+        // types.\n+        let mut seen = FxHashSet();\n+        predicates.retain(|i| seen.insert(i.clone()));\n         self.infcx().plug_leaks(skol_map, snapshot, predicates)\n     }\n }"}, {"sha": "3ab2cd274b90ea98ad80a8d4998a9a0f6e00a6ec", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -39,7 +39,6 @@ use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n use std::cmp;\n-use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n@@ -498,20 +497,6 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> Ord for TyS<'tcx> {\n-    #[inline]\n-    fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        // (self as *const _).cmp(other as *const _)\n-        (self as *const TyS<'tcx>).cmp(&(other as *const TyS<'tcx>))\n-    }\n-}\n-impl<'tcx> PartialOrd for TyS<'tcx> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n@@ -581,19 +566,6 @@ impl<T> PartialEq for Slice<T> {\n }\n impl<T> Eq for Slice<T> {}\n \n-impl<T> Ord for Slice<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Slice<T>) -> Ordering {\n-        (&self.0 as *const [T]).cmp(&(&other.0 as *const [T]))\n-    }\n-}\n-impl<T> PartialOrd for Slice<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n impl<T> Hash for Slice<T> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self.as_ptr(), self.len()).hash(s)\n@@ -1128,7 +1100,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1532,7 +1504,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n pub enum AdtKind { Struct, Union, Enum }\n \n bitflags! {"}, {"sha": "503418b044f4f603e1de9b799a25bc53ed8cb8db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -645,7 +645,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -745,7 +745,7 @@ impl<T> Binder<T> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,"}, {"sha": "80b113dfdf5a5f2b6404ce66ed4ed53c47fc93a1", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=58af0c7b648dd8ccf1f1d4277ccf4d804ed4a996", "patch": "@@ -29,7 +29,7 @@ use std::mem;\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty` or `Region`) it points to.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZero<usize>,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>"}]}