{"sha": "4f326dd6504b6848e7b9cc831940d5452d873f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMzI2ZGQ2NTA0YjY4NDhlN2I5Y2M4MzE5NDBkNTQ1MmQ4NzNmNTY=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-25T22:10:25Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-25T22:28:57Z"}, "message": "Remove deprecated modes from SHA1 and MD4 in libstd", "tree": {"sha": "71b34f4c65dd88db3aa9c92adf50bc40dfd1da9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b34f4c65dd88db3aa9c92adf50bc40dfd1da9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f326dd6504b6848e7b9cc831940d5452d873f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f326dd6504b6848e7b9cc831940d5452d873f56", "html_url": "https://github.com/rust-lang/rust/commit/4f326dd6504b6848e7b9cc831940d5452d873f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f326dd6504b6848e7b9cc831940d5452d873f56/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b26084475c488af920da14052db6461512bbfe2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26084475c488af920da14052db6461512bbfe2b", "html_url": "https://github.com/rust-lang/rust/commit/b26084475c488af920da14052db6461512bbfe2b"}], "stats": {"total": 83, "additions": 46, "deletions": 37}, "files": [{"sha": "a427232467022e5a47bcc747ee2ea480e04dc5f0", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f326dd6504b6848e7b9cc831940d5452d873f56/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f326dd6504b6848e7b9cc831940d5452d873f56/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=4f326dd6504b6848e7b9cc831940d5452d873f56", "patch": "@@ -1,11 +1,14 @@\n-fn md4(msg: ~[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n     let orig_len: u64 = (vec::len(msg) * 8u) as u64;\n \n     // pad message\n-    let mut msg = vec::append(msg, ~[0x80u8]);\n+    let mut msg = vec::append(vec::from_slice(msg), ~[0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n         vec::push(msg, 0u8);\n@@ -82,7 +85,7 @@ fn md4(msg: ~[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     return {a: a, b: b, c: c, d: d};\n }\n \n-fn md4_str(msg: ~[u8]) -> ~str {\n+fn md4_str(msg: &[u8]) -> ~str {\n     let {a, b, c, d} = md4(msg);\n     fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n@@ -100,7 +103,7 @@ fn md4_str(msg: ~[u8]) -> ~str {\n     result\n }\n \n-fn md4_text(msg: ~str) -> ~str { md4_str(str::to_bytes(msg)) }\n+fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {"}, {"sha": "e3c1b173c1943b2cdacef061a58f5df5ac626e77", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4f326dd6504b6848e7b9cc831940d5452d873f56/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f326dd6504b6848e7b9cc831940d5452d873f56/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4f326dd6504b6848e7b9cc831940d5452d873f56", "patch": "@@ -12,6 +12,9 @@\n  * the `reset` method.\n  */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n  * implementation, which is written for clarity, not speed. At some\n@@ -22,9 +25,9 @@ export sha1;\n /// The SHA-1 interface\n trait sha1 {\n     /// Provide message input as bytes\n-    fn input(~[u8]);\n+    fn input((&[u8]));\n     /// Provide message input as string\n-    fn input_str(~str);\n+    fn input_str((&str));\n     /**\n      * Read the digest as a vector of 20 bytes. After calling this no further\n      * input may be provided until reset is called.\n@@ -60,7 +63,7 @@ fn sha1() -> sha1 {\n          mut computed: bool,\n          work_buf: @~[mut u32]};\n \n-    fn add_input(st: sha1state, msg: ~[u8]) {\n+    fn add_input(st: &sha1state, msg: &[u8]) {\n         assert (!st.computed);\n         for vec::each(msg) |element| {\n             st.msg_block[st.msg_block_idx] = element;\n@@ -76,7 +79,7 @@ fn sha1() -> sha1 {\n             if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n         }\n     }\n-    fn process_msg_block(st: sha1state) {\n+    fn process_msg_block(st: &sha1state) {\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(*st.work_buf) == work_buf_len);\n         let mut t: int; // Loop counter\n@@ -155,10 +158,10 @@ fn sha1() -> sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         return word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: sha1state) -> ~[u8] {\n-        if !st.computed { pad_msg(st); st.computed = true; }\n+    fn mk_result(st: &sha1state) -> ~[u8] {\n+        if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each_mut(st.h) |ptr_hpart| {\n+        for vec::each_mut((*st).h) |ptr_hpart| {\n             let hpart = *ptr_hpart;\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n@@ -178,40 +181,40 @@ fn sha1() -> sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-    fn pad_msg(st: sha1state) {\n-        assert (vec::len(st.msg_block) == msg_block_len);\n+    fn pad_msg(st: &sha1state) {\n+        assert (vec::len((*st).msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n          * the initial padding bits and length.  If so, we will pad the\n          * block, process it, and then continue padding into a second block.\n          */\n-        if st.msg_block_idx > 55u {\n-            st.msg_block[st.msg_block_idx] = 0x80u8;\n-            st.msg_block_idx += 1u;\n-            while st.msg_block_idx < msg_block_len {\n-                st.msg_block[st.msg_block_idx] = 0u8;\n-                st.msg_block_idx += 1u;\n+        if (*st).msg_block_idx > 55u {\n+            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n+            (*st).msg_block_idx += 1u;\n+            while (*st).msg_block_idx < msg_block_len {\n+                (*st).msg_block[(*st).msg_block_idx] = 0u8;\n+                (*st).msg_block_idx += 1u;\n             }\n             process_msg_block(st);\n         } else {\n-            st.msg_block[st.msg_block_idx] = 0x80u8;\n-            st.msg_block_idx += 1u;\n+            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n+            (*st).msg_block_idx += 1u;\n         }\n-        while st.msg_block_idx < 56u {\n-            st.msg_block[st.msg_block_idx] = 0u8;\n-            st.msg_block_idx += 1u;\n+        while (*st).msg_block_idx < 56u {\n+            (*st).msg_block[(*st).msg_block_idx] = 0u8;\n+            (*st).msg_block_idx += 1u;\n         }\n \n         // Store the message length as the last 8 octets\n-        st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n-        st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n-        st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n-        st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n-        st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n-        st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n-        st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n-        st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n+        (*st).msg_block[56] = ((*st).len_high >> 24u32 & 0xFFu32) as u8;\n+        (*st).msg_block[57] = ((*st).len_high >> 16u32 & 0xFFu32) as u8;\n+        (*st).msg_block[58] = ((*st).len_high >> 8u32 & 0xFFu32) as u8;\n+        (*st).msg_block[59] = ((*st).len_high & 0xFFu32) as u8;\n+        (*st).msg_block[60] = ((*st).len_low >> 24u32 & 0xFFu32) as u8;\n+        (*st).msg_block[61] = ((*st).len_low >> 16u32 & 0xFFu32) as u8;\n+        (*st).msg_block[62] = ((*st).len_low >> 8u32 & 0xFFu32) as u8;\n+        (*st).msg_block[63] = ((*st).len_low & 0xFFu32) as u8;\n         process_msg_block(st);\n     }\n \n@@ -228,13 +231,16 @@ fn sha1() -> sha1 {\n             self.h[4] = 0xC3D2E1F0u32;\n             self.computed = false;\n         }\n-        fn input(msg: ~[u8]) { add_input(self, msg); }\n-        fn input_str(msg: ~str) { add_input(self, str::to_bytes(msg)); }\n-        fn result() -> ~[u8] { return mk_result(self); }\n+        fn input(msg: &[u8]) { add_input(&self, msg); }\n+        fn input_str(msg: &str) {\n+            let bs = str::to_bytes(msg);\n+            add_input(&self, bs);\n+        }\n+        fn result() -> ~[u8] { return mk_result(&self); }\n         fn result_str() -> ~str {\n-            let r = mk_result(self);\n+            let rr = mk_result(&self);\n             let mut s = ~\"\";\n-            for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+            for vec::each(rr) |b| { s += uint::to_str(b as uint, 16u); }\n             return s;\n         }\n     }"}]}