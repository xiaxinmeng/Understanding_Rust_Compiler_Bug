{"sha": "14b674ab9d1f0b71763a168bd764eb7d53154008", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YjY3NGFiOWQxZjBiNzE3NjNhMTY4YmQ3NjRlYjdkNTMxNTQwMDg=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-02T02:18:32Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-07T21:28:16Z"}, "message": "Factored out context-dependent help for error reporting.", "tree": {"sha": "f505ffd3bbfe22c371fc90ca9395fcba48132ddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f505ffd3bbfe22c371fc90ca9395fcba48132ddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14b674ab9d1f0b71763a168bd764eb7d53154008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14b674ab9d1f0b71763a168bd764eb7d53154008", "html_url": "https://github.com/rust-lang/rust/commit/14b674ab9d1f0b71763a168bd764eb7d53154008", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14b674ab9d1f0b71763a168bd764eb7d53154008/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e2d96e88c660c574723dfc6cf8aab084917cb8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2d96e88c660c574723dfc6cf8aab084917cb8c", "html_url": "https://github.com/rust-lang/rust/commit/0e2d96e88c660c574723dfc6cf8aab084917cb8c"}], "stats": {"total": 378, "additions": 195, "deletions": 183}, "files": [{"sha": "1a5fce14fa8fdc1cc770ae6fefdd8e3757b0d1cd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 195, "deletions": 183, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/14b674ab9d1f0b71763a168bd764eb7d53154008/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b674ab9d1f0b71763a168bd764eb7d53154008/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=14b674ab9d1f0b71763a168bd764eb7d53154008", "patch": "@@ -3124,6 +3124,193 @@ impl<'a> Resolver<'a> {\n         )\n     }\n \n+    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n+    /// function.\n+    /// Returns `true` if able to provide context-dependent help.\n+    fn smart_resolve_context_dep_help(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+        source: PathSource,\n+        def: Def,\n+        path_str: &str,\n+        fallback_label: &str,\n+    ) -> bool {\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+\n+        match (def, source) {\n+            (Def::Macro(..), _) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"use `!` to invoke the macro\",\n+                    format!(\"{}!\", path_str),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Def::TyAlias(..), PathSource::Trait(_)) => {\n+                err.span_label(span, \"type aliases cannot be used as traits\");\n+                if nightly_options::is_nightly_build() {\n+                    err.note(\"did you mean to use a trait alias?\");\n+                }\n+            }\n+            (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n+                ExprKind::Field(_, ident) => {\n+                    err.span_suggestion(\n+                        parent.span,\n+                        \"use the path separator to refer to an item\",\n+                        format!(\"{}::{}\", path_str, ident),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ExprKind::MethodCall(ref segment, ..) => {\n+                    let span = parent.span.with_hi(segment.ident.span.hi());\n+                    err.span_suggestion(\n+                        span,\n+                        \"use the path separator to refer to an item\",\n+                        format!(\"{}::{}\", path_str, segment.ident),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => return false,\n+            },\n+            (Def::Enum(..), PathSource::TupleStruct)\n+                | (Def::Enum(..), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def) {\n+                    err.note(&format!(\"did you mean to use one \\\n+                                        of the following variants?\\n{}\",\n+                        variants.iter()\n+                            .map(|suggestion| path_names_to_string(suggestion))\n+                            .map(|suggestion| format!(\"- `{}`\", suggestion))\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")));\n+                } else {\n+                    err.note(\"did you mean to use one of the enum's variants?\");\n+                }\n+            },\n+            (Def::Struct(def_id), _) if ns == ValueNS => {\n+                if let Some((ctor_def, ctor_vis))\n+                        = self.struct_constructors.get(&def_id).cloned() {\n+                    let accessible_ctor = self.is_accessible(ctor_vis);\n+                    if is_expected(ctor_def) && !accessible_ctor {\n+                        err.span_label(span, format!(\"constructor is not visible \\\n+                                                      here due to private fields\"));\n+                    }\n+                } else {\n+                    // HACK(estebank): find a better way to figure out that this was a\n+                    // parser issue where a struct literal is being used on an expression\n+                    // where a brace being opened means a block is being started. Look\n+                    // ahead for the next text to see if `span` is followed by a `{`.\n+                    let sm = self.session.source_map();\n+                    let mut sp = span;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                    }\n+                    let followed_by_brace = match sm.span_to_snippet(sp) {\n+                        Ok(ref snippet) if snippet == \"{\" => true,\n+                        _ => false,\n+                    };\n+                    // In case this could be a struct literal that needs to be surrounded\n+                    // by parenthesis, find the appropriate span.\n+                    let mut i = 0;\n+                    let mut closing_brace = None;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet == \"}\" {\n+                                    let sp = span.to(sp);\n+                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                                        closing_brace = Some((sp, snippet));\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                        i += 1;\n+                        // The bigger the span, the more likely we're incorrect --\n+                        // bound it to 100 chars long.\n+                        if i > 100 {\n+                            break;\n+                        }\n+                    }\n+                    match source {\n+                        PathSource::Expr(Some(parent)) => {\n+                            match parent.node {\n+                                ExprKind::MethodCall(ref path_assignment, _)  => {\n+                                    err.span_suggestion(\n+                                        sm.start_point(parent.span)\n+                                            .to(path_assignment.ident.span),\n+                                        \"use `::` to access an associated function\",\n+                                        format!(\"{}::{}\",\n+                                                path_str,\n+                                                path_assignment.ident),\n+                                        Applicability::MaybeIncorrect\n+                                    );\n+                                },\n+                                _ => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                                path_str),\n+                                    );\n+                                },\n+                            }\n+                        },\n+                        PathSource::Expr(None) if followed_by_brace == true => {\n+                            if let Some((sp, snippet)) = closing_brace {\n+                                err.span_suggestion(\n+                                    sp,\n+                                    \"surround the struct literal with parenthesis\",\n+                                    format!(\"({})\", snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\"did you mean `({} {{ /* fields */ }})`?\",\n+                                            path_str),\n+                                );\n+                            }\n+                        },\n+                        _ => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                        path_str),\n+                            );\n+                        },\n+                    }\n+                }\n+            }\n+            (Def::Union(..), _) |\n+            (Def::Variant(..), _) |\n+            (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n+                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                             path_str));\n+            }\n+            (Def::SelfTy(..), _) if ns == ValueNS => {\n+                err.span_label(span, fallback_label);\n+                err.note(\"can't use `Self` as a constructor, you must use the \\\n+                          implemented struct\");\n+            }\n+            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n+                err.note(\"can't use a type alias as a constructor\");\n+            }\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n     fn smart_resolve_report_errors(\n@@ -3137,7 +3324,7 @@ impl<'a> Resolver<'a> {\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n-        \n+\n         // Make the base error.\n         let expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n@@ -3317,188 +3504,13 @@ impl<'a> Resolver<'a> {\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(def) = def {\n-            match (def, source) {\n-                (Def::Macro(..), _) => {\n-                    err.span_suggestion(\n-                        span,\n-                        \"use `!` to invoke the macro\",\n-                        format!(\"{}!\", path_str),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return (err, candidates);\n-                }\n-                (Def::TyAlias(..), PathSource::Trait(_)) => {\n-                    err.span_label(span, \"type aliases cannot be used as traits\");\n-                    if nightly_options::is_nightly_build() {\n-                        err.note(\"did you mean to use a trait alias?\");\n-                    }\n-                    return (err, candidates);\n-                }\n-                (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n-                    ExprKind::Field(_, ident) => {\n-                        err.span_suggestion(\n-                            parent.span,\n-                            \"use the path separator to refer to an item\",\n-                            format!(\"{}::{}\", path_str, ident),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return (err, candidates);\n-                    }\n-                    ExprKind::MethodCall(ref segment, ..) => {\n-                        let span = parent.span.with_hi(segment.ident.span.hi());\n-                        err.span_suggestion(\n-                            span,\n-                            \"use the path separator to refer to an item\",\n-                            format!(\"{}::{}\", path_str, segment.ident),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return (err, candidates);\n-                    }\n-                    _ => {}\n-                },\n-                (Def::Enum(..), PathSource::TupleStruct)\n-                    | (Def::Enum(..), PathSource::Expr(..))  => {\n-                    if let Some(variants) = self.collect_enum_variants(def) {\n-                        err.note(&format!(\"did you mean to use one \\\n-                                           of the following variants?\\n{}\",\n-                            variants.iter()\n-                                .map(|suggestion| path_names_to_string(suggestion))\n-                                .map(|suggestion| format!(\"- `{}`\", suggestion))\n-                                .collect::<Vec<_>>()\n-                                .join(\"\\n\")));\n-\n-                    } else {\n-                        err.note(\"did you mean to use one of the enum's variants?\");\n-                    }\n-                    return (err, candidates);\n-                },\n-                (Def::Struct(def_id), _) if ns == ValueNS => {\n-                    if let Some((ctor_def, ctor_vis))\n-                            = self.struct_constructors.get(&def_id).cloned() {\n-                        let accessible_ctor = self.is_accessible(ctor_vis);\n-                        if is_expected(ctor_def) && !accessible_ctor {\n-                            err.span_label(span, format!(\"constructor is not visible \\\n-                                                          here due to private fields\"));\n-                        }\n-                    } else {\n-                        // HACK(estebank): find a better way to figure out that this was a\n-                        // parser issue where a struct literal is being used on an expression\n-                        // where a brace being opened means a block is being started. Look\n-                        // ahead for the next text to see if `span` is followed by a `{`.\n-                        let sm = self.session.source_map();\n-                        let mut sp = span;\n-                        loop {\n-                            sp = sm.next_point(sp);\n-                            match sm.span_to_snippet(sp) {\n-                                Ok(ref snippet) => {\n-                                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                                        break;\n-                                    }\n-                                }\n-                                _ => break,\n-                            }\n-                        }\n-                        let followed_by_brace = match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) if snippet == \"{\" => true,\n-                            _ => false,\n-                        };\n-                        // In case this could be a struct literal that needs to be surrounded\n-                        // by parenthesis, find the appropriate span.\n-                        let mut i = 0;\n-                        let mut closing_brace = None;\n-                        loop {\n-                            sp = sm.next_point(sp);\n-                            match sm.span_to_snippet(sp) {\n-                                Ok(ref snippet) => {\n-                                    if snippet == \"}\" {\n-                                        let sp = span.to(sp);\n-                                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                                            closing_brace = Some((sp, snippet));\n-                                        }\n-                                        break;\n-                                    }\n-                                }\n-                                _ => break,\n-                            }\n-                            i += 1;\n-                            // The bigger the span, the more likely we're\n-                            // incorrect. Bound it to 100 chars long.\n-                            if i > 100 {\n-                                break;\n-                            }\n-                        }\n-                        match source {\n-                            PathSource::Expr(Some(parent)) => {\n-                                match parent.node {\n-                                    ExprKind::MethodCall(ref path_assignment, _)  => {\n-                                        err.span_suggestion(\n-                                            sm.start_point(parent.span)\n-                                                .to(path_assignment.ident.span),\n-                                            \"use `::` to access an associated function\",\n-                                            format!(\"{}::{}\",\n-                                                    path_str,\n-                                                    path_assignment.ident),\n-                                            Applicability::MaybeIncorrect\n-                                        );\n-                                        return (err, candidates);\n-                                    },\n-                                    _ => {\n-                                        err.span_label(\n-                                            span,\n-                                            format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                    path_str),\n-                                        );\n-                                        return (err, candidates);\n-                                    },\n-                                }\n-                            },\n-                            PathSource::Expr(None) if followed_by_brace == true => {\n-                                if let Some((sp, snippet)) = closing_brace {\n-                                    err.span_suggestion(\n-                                        sp,\n-                                        \"surround the struct literal with parenthesis\",\n-                                        format!(\"({})\", snippet),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                } else {\n-                                    err.span_label(\n-                                        span,\n-                                        format!(\"did you mean `({} {{ /* fields */ }})`?\",\n-                                                path_str),\n-                                    );\n-                                }\n-                                return (err, candidates);\n-                            },\n-                            _ => {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                            path_str),\n-                                );\n-                                return (err, candidates);\n-                            },\n-                        }\n-                    }\n-                    return (err, candidates);\n-                }\n-                (Def::Union(..), _) |\n-                (Def::Variant(..), _) |\n-                (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n-                    err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                 path_str));\n-                    return (err, candidates);\n-                }\n-                (Def::SelfTy(..), _) if ns == ValueNS => {\n-                    err.span_label(span, fallback_label);\n-                    err.note(\"can't use `Self` as a constructor, you must use the \\\n-                              implemented struct\");\n-                    return (err, candidates);\n-                }\n-                (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n-                    err.note(\"can't use a type alias as a constructor\");\n-                    return (err, candidates);\n-                }\n-                _ => {}\n+            if self.smart_resolve_context_dep_help(&mut err,\n+                                                   span,\n+                                                   source,\n+                                                   def,\n+                                                   &path_str,\n+                                                   &fallback_label) {\n+                return (err, candidates);\n             }\n         }\n "}]}