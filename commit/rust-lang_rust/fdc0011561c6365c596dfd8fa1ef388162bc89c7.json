{"sha": "fdc0011561c6365c596dfd8fa1ef388162bc89c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYzAwMTE1NjFjNjM2NWM1OTZkZmQ4ZmExZWYzODgxNjJiYzg5Yzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T14:51:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T14:51:02Z"}, "message": "Auto merge of #64736 - Nashenas88:mir_predecessors_cache_cleanup, r=oli-obk\n\nRemove interior mutability in mir predecessors cache", "tree": {"sha": "2bac948dc85b60aa5550f443d3d5247a740c2d37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bac948dc85b60aa5550f443d3d5247a740c2d37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdc0011561c6365c596dfd8fa1ef388162bc89c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc0011561c6365c596dfd8fa1ef388162bc89c7", "html_url": "https://github.com/rust-lang/rust/commit/fdc0011561c6365c596dfd8fa1ef388162bc89c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdc0011561c6365c596dfd8fa1ef388162bc89c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2da942f32802c8233a09744024dfbc34431adf65", "url": "https://api.github.com/repos/rust-lang/rust/commits/2da942f32802c8233a09744024dfbc34431adf65", "html_url": "https://github.com/rust-lang/rust/commit/2da942f32802c8233a09744024dfbc34431adf65"}, {"sha": "3eaad564d25402013bdf5591c453c916b49cdf93", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eaad564d25402013bdf5591c453c916b49cdf93", "html_url": "https://github.com/rust-lang/rust/commit/3eaad564d25402013bdf5591c453c916b49cdf93"}], "stats": {"total": 1532, "additions": 942, "deletions": 590}, "files": [{"sha": "364a35f1b6faa1ed0328b2d7c1790ea26b0a6342", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -23,17 +23,17 @@ macro_rules! arena_types {\n             [] generics: rustc::ty::Generics,\n             [] trait_def: rustc::ty::TraitDef,\n             [] adt_def: rustc::ty::AdtDef,\n-            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n-            [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::BodyCache<$tcx>>,\n+            [] mir: rustc::mir::BodyCache<$tcx>,\n             [] steal_promoted: rustc::ty::steal::Steal<\n                 rustc_index::vec::IndexVec<\n                     rustc::mir::Promoted,\n-                    rustc::mir::Body<$tcx>\n+                    rustc::mir::BodyCache<$tcx>\n                 >\n             >,\n             [] promoted: rustc_index::vec::IndexVec<\n                 rustc::mir::Promoted,\n-                rustc::mir::Body<$tcx>\n+                rustc::mir::BodyCache<$tcx>\n             >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,"}, {"sha": "b8ef4f753f368105aec7e4d678373152f6fdba6a", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 251, "deletions": 23, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,16 +1,19 @@\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use crate::ich::StableHashingContext;\n-use crate::mir::{Body, BasicBlock};\n+use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n+use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use std::iter;\n+use std::ops::{Deref, DerefMut, Index, IndexMut};\n+use std::vec::IntoIter;\n \n #[derive(Clone, Debug)]\n pub struct Cache {\n-    predecessors: RwLock<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n+    predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>,\n }\n \n-\n impl rustc_serialize::Encodable for Cache {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&(), s)\n@@ -31,39 +34,264 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n \n impl Cache {\n     pub fn new() -> Self {\n-        Cache {\n-            predecessors: RwLock::new(None)\n+        Self {\n+            predecessors: None,\n         }\n     }\n \n-    pub fn invalidate(&self) {\n+    pub fn invalidate_predecessors(&mut self) {\n         // FIXME: consider being more fine-grained\n-        *self.predecessors.borrow_mut() = None;\n+        self.predecessors = None;\n     }\n \n-    pub fn predecessors(\n-        &self,\n-        body: &Body<'_>\n-    ) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n-        if self.predecessors.borrow().is_none() {\n-            *self.predecessors.borrow_mut() = Some(calculate_predecessors(body));\n+    pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n+        if self.predecessors.is_none() {\n+            let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n+            for (bb, data) in body.basic_blocks().iter_enumerated() {\n+                if let Some(ref term) = data.terminator {\n+                    for &tgt in term.successors() {\n+                        result[tgt].push(bb);\n+                    }\n+                }\n+            }\n+\n+            self.predecessors = Some(result)\n         }\n+    }\n+\n+    /// This will recompute the predecessors cache if it is not available\n+    fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.ensure_predecessors(body);\n+        self.predecessors.as_ref().unwrap()\n+    }\n+\n+    fn unwrap_predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        &self.predecessors.as_ref().unwrap()[bb]\n+    }\n \n-        ReadGuard::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n+    fn unwrap_predecessor_locations<'a>(\n+        &'a self,\n+        loc: Location,\n+        body: &'a Body<'a>\n+    ) -> impl Iterator<Item = Location> + 'a {\n+        let if_zero_locations = if loc.statement_index == 0 {\n+            let predecessor_blocks = self.unwrap_predecessors_for(loc.block);\n+            let num_predecessor_blocks = predecessor_blocks.len();\n+            Some(\n+                (0..num_predecessor_blocks)\n+                    .map(move |i| predecessor_blocks[i])\n+                    .map(move |bb| body.terminator_loc(bb)),\n+            )\n+        } else {\n+            None\n+        };\n+\n+        let if_not_zero_locations = if loc.statement_index == 0 {\n+            None\n+        } else {\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n+        };\n+\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n+    }\n+\n+    pub fn basic_blocks_mut<'a, 'tcx>(\n+        &mut self,\n+        body: &'a mut Body<'tcx>\n+    ) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        &mut body.basic_blocks\n+    }\n+\n+    pub fn basic_blocks_and_local_decls_mut<'a, 'tcx>(\n+        &mut self,\n+        body: &'a mut Body<'tcx>\n+    ) -> (&'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &'a mut LocalDecls<'tcx>) {\n+        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        (&mut body.basic_blocks, &mut body.local_decls)\n     }\n }\n \n-fn calculate_predecessors(body: &Body<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n-    let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n-        if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors() {\n-                result[tgt].push(bb);\n-            }\n+#[derive(Clone, Debug, HashStable, RustcEncodable, RustcDecodable, TypeFoldable)]\n+pub struct BodyCache<'tcx> {\n+    cache: Cache,\n+    body: Body<'tcx>,\n+}\n+\n+impl BodyCache<'tcx> {\n+    pub fn new(body: Body<'tcx>) -> Self {\n+        Self {\n+            cache: Cache::new(),\n+            body,\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! read_only {\n+    ($body:expr) => {\n+        {\n+            $body.ensure_predecessors();\n+            $body.unwrap_read_only()\n+        }\n+    };\n+}\n+\n+impl BodyCache<'tcx> {\n+    pub fn ensure_predecessors(&mut self) {\n+        self.cache.ensure_predecessors(&self.body);\n+    }\n+\n+    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.cache.predecessors(&self.body)\n+    }\n+\n+    pub fn unwrap_read_only(&self) -> ReadOnlyBodyCache<'_, 'tcx> {\n+        ReadOnlyBodyCache::new(&self.cache, &self.body)\n+    }\n+\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.cache.basic_blocks_mut(&mut self.body)\n+    }\n+\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n+        self.cache.basic_blocks_and_local_decls_mut(&mut self.body)\n+    }\n+}\n+\n+impl<'tcx> Index<BasicBlock> for BodyCache<'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n+    }\n+}\n+\n+impl<'tcx> IndexMut<BasicBlock> for BodyCache<'tcx> {\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n+        &mut self.basic_blocks_mut()[index]\n+    }\n+}\n+\n+impl<'tcx> Deref for BodyCache<'tcx> {\n+    type Target = Body<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.body\n+    }\n+}\n+\n+impl<'tcx> DerefMut for BodyCache<'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.body\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct ReadOnlyBodyCache<'a, 'tcx> {\n+    cache: &'a Cache,\n+    body: &'a Body<'tcx>,\n+}\n+\n+impl ReadOnlyBodyCache<'a, 'tcx> {\n+    fn new(cache: &'a Cache, body: &'a Body<'tcx>) -> Self {\n+        assert!(\n+            cache.predecessors.is_some(),\n+            \"Cannot construct ReadOnlyBodyCache without computed predecessors\");\n+        Self {\n+            cache,\n+            body,\n         }\n     }\n \n-    result\n+    pub fn predecessors(&self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.cache.predecessors.as_ref().unwrap()\n+    }\n+\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        self.cache.unwrap_predecessors_for(bb)\n+    }\n+\n+    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n+        self.cache.unwrap_predecessor_locations(loc, self.body)\n+    }\n+\n+    pub fn body(&self) -> &'a Body<'tcx> {\n+        self.body\n+    }\n+\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n+    }\n+\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n+}\n+\n+impl graph::DirectedGraph for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl graph::GraphPredecessors<'graph> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl graph::WithPredecessors for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn predecessors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'_>>::Iter {\n+        self.cache.unwrap_predecessors_for(node).to_vec().into_iter()\n+    }\n+}\n+\n+impl graph::WithNumNodes for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn num_nodes(&self) -> usize {\n+        self.body.num_nodes()\n+    }\n+}\n+\n+impl graph::WithStartNode for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn start_node(&self) -> Self::Node {\n+        self.body.start_node()\n+    }\n+}\n+\n+impl graph::WithSuccessors for ReadOnlyBodyCache<'a, 'tcx> {\n+    fn successors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'_>>::Iter {\n+        self.body.successors(node)\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = iter::Cloned<Successors<'b>>;\n+}\n+\n+\n+impl Deref for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Target = Body<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.body\n+    }\n+}\n+\n+impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n+    }\n }\n \n CloneTypeFoldableAndLiftImpls! {"}, {"sha": "df5d4997e089aac8cbd297b8ff5054ab1fb5d41e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 87, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -21,25 +21,25 @@ use crate::ty::{\n use polonius_engine::Atom;\n use rustc_index::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::{self, GraphSuccessors};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::sync::MappedReadGuard;\n use rustc_macros::HashStable;\n use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::{Index, IndexMut};\n+use std::ops::Index;\n use std::slice;\n-use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n+pub use crate::mir::cache::{BodyCache, ReadOnlyBodyCache};\n+pub use crate::read_only;\n \n mod cache;\n pub mod interpret;\n@@ -108,7 +108,7 @@ pub struct Body<'tcx> {\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue.\n-    pub generator_drop: Option<Box<Body<'tcx>>>,\n+    pub generator_drop: Option<Box<BodyCache<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n@@ -154,9 +154,6 @@ pub struct Body<'tcx> {\n \n     /// A span representing this MIR, for error reporting.\n     pub span: Span,\n-\n-    /// A cache for various calculations.\n-    cache: cache::Cache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -193,7 +190,6 @@ impl<'tcx> Body<'tcx> {\n             spread_arg: None,\n             var_debug_info,\n             span,\n-            cache: cache::Cache::new(),\n             control_flow_destroyed,\n         }\n     }\n@@ -203,58 +199,6 @@ impl<'tcx> Body<'tcx> {\n         &self.basic_blocks\n     }\n \n-    #[inline]\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        self.cache.invalidate();\n-        &mut self.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        self.cache.invalidate();\n-        (&mut self.basic_blocks, &mut self.local_decls)\n-    }\n-\n-    #[inline]\n-    pub fn predecessors(&self) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n-        self.cache.predecessors(self)\n-    }\n-\n-    #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> MappedReadGuard<'_, Vec<BasicBlock>> {\n-        MappedReadGuard::map(self.predecessors(), |p| &p[bb])\n-    }\n-\n-    #[inline]\n-    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.predecessors_for(loc.block);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| self.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n-\n-    #[inline]\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-\n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n@@ -355,7 +299,7 @@ impl<'tcx> Body<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_statement_nop(&mut self, location: Location) {\n-        let block = &mut self[location.block];\n+        let block = &mut self.basic_blocks[location.block];\n         debug_assert!(location.statement_index < block.statements.len());\n         block.statements[location.statement_index].make_nop()\n     }\n@@ -415,13 +359,6 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n-    #[inline]\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks_mut()[index]\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n@@ -2618,15 +2555,6 @@ impl<'tcx> graph::WithStartNode for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    fn predecessors(\n-        &self,\n-        node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).clone().into_iter()\n-    }\n-}\n-\n impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     fn successors(\n         &self,\n@@ -2636,11 +2564,6 @@ impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     }\n }\n \n-impl<'a, 'b> graph::GraphPredecessors<'b> for Body<'a> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n@@ -2675,21 +2598,25 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(\n+        &self,\n+        other: Location,\n+        body: ReadOnlyBodyCache<'_, 'tcx>\n+    ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n             return true;\n         }\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).clone();\n+        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).to_vec();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.append(&mut body.predecessors_for(block).clone());\n+                queue.extend(body.predecessors_for(block).iter().cloned());\n             } else {\n                 continue;\n             }"}, {"sha": "47a1d67d5d6dbea8305db373f2b359d4807a43a5", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -65,13 +65,25 @@ use syntax_pos::Span;\n // variant argument) that does not require visiting, as in\n // `is_cleanup` above.\n \n+macro_rules! body_cache_type {\n+    (mut $a:lifetime, $tcx:lifetime) => {\n+        &mut BodyCache<$tcx>\n+    };\n+    ($a:lifetime, $tcx:lifetime) => {\n+        ReadOnlyBodyCache<$a, $tcx>\n+    };\n+}\n+\n macro_rules! make_mir_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_body(&mut self, body: & $($mutability)? Body<'tcx>) {\n+            fn visit_body(\n+                &mut self,\n+                body: body_cache_type!($($mutability)? '_, 'tcx)\n+            ) {\n                 self.super_body(body);\n             }\n \n@@ -240,11 +252,14 @@ macro_rules! make_mir_visitor {\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n-            fn super_body(&mut self,\n-                         body: & $($mutability)? Body<'tcx>) {\n+            fn super_body(\n+                &mut self,\n+                $($mutability)? body: body_cache_type!($($mutability)? '_, 'tcx)\n+            ) {\n+                let span = body.span;\n                 if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n-                        span: body.span,\n+                        span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n                     }));\n                 }\n@@ -260,6 +275,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n+                let body: & $($mutability)? Body<'_> = & $($mutability)? body;\n                 for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n@@ -790,7 +806,11 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {\n+            fn visit_location(\n+                &mut self,\n+                body: body_cache_type!($($mutability)? '_, 'tcx),\n+                location: Location\n+            ) {\n                 let basic_block = & $($mutability)? body[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {"}, {"sha": "a6d7e5c9291dcc48037e3fc351468ff424d74359", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -106,44 +106,54 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyCache<'tcx>> {}\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::BodyCache<'tcx>> {\n             no_hash\n         }\n \n         query mir_validated(_: DefId) ->\n             (\n-                &'tcx Steal<mir::Body<'tcx>>,\n-                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+                &'tcx Steal<mir::BodyCache<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::BodyCache<'tcx>>>\n             ) {\n             no_hash\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n+        query optimized_mir(key: DefId) -> &'tcx mir::BodyCache<'tcx> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n-                let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n-                                                            .try_load_query_result(tcx, id);\n-                mir.map(|x| &*tcx.arena.alloc(x))\n+                let mir: Option<crate::mir::BodyCache<'tcx>>\n+                    = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                mir.map(|x| {\n+                    let cache = tcx.arena.alloc(x);\n+                    cache.ensure_predecessors();\n+                    &*cache\n+                })\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::BodyCache<'tcx>> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let promoted: Option<\n                     rustc_index::vec::IndexVec<\n                         crate::mir::Promoted,\n-                        crate::mir::Body<'tcx>\n+                        crate::mir::BodyCache<'tcx>\n                     >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n-                promoted.map(|p| &*tcx.arena.alloc(p))\n+                promoted.map(|p| {\n+                    let cache = tcx.arena.alloc(p);\n+                    for body in cache.iter_mut() {\n+                        body.ensure_predecessors();\n+                    }\n+                    &*cache\n+                })\n             }\n         }\n     }\n@@ -502,7 +512,7 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyCache<'tcx> {\n             no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }"}, {"sha": "6a0002cd80fd040428f11ba69538f08a559a305d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -22,7 +22,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::{BodyCache, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -1083,17 +1083,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self.hir_map\n     }\n \n-    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n+    pub fn alloc_steal_mir(self, mir: BodyCache<'tcx>) -> &'tcx Steal<BodyCache<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, BodyCache<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, BodyCache<'tcx>>> {\n         self.arena.alloc(Steal::new(promoted))\n     }\n \n-    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, BodyCache<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, BodyCache<'tcx>> {\n         self.arena.alloc(promoted)\n     }\n "}, {"sha": "c9a934e9ebd8490ff86cbfb73096bf596cf1501e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -18,7 +18,7 @@ use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n-use crate::mir::Body;\n+use crate::mir::ReadOnlyBodyCache;\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::mir::GeneratorLayout;\n use crate::session::CrateDisambiguator;\n@@ -2985,10 +2985,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> ReadOnlyBodyCache<'tcx, 'tcx> {\n         match instance {\n             ty::InstanceDef::Item(did) => {\n-                self.optimized_mir(did)\n+                self.optimized_mir(did).unwrap_read_only()\n             }\n             ty::InstanceDef::VtableShim(..) |\n             ty::InstanceDef::ReifyShim(..) |\n@@ -2998,7 +2998,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::InstanceDef::ClosureOnceShim { .. } |\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) => {\n-                self.mir_shims(instance)\n+                self.mir_shims(instance).unwrap_read_only()\n             }\n         }\n     }"}, {"sha": "e460a4a2e8c97a57bb7ea2082571e9e467451828", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -374,7 +374,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let lldecl = cx.get_fn(instance);\n \n     let mir = cx.tcx().instance_mir(instance.def);\n-    mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n+    mir::codegen_mir::<Bx>(cx, lldecl, mir, instance, sig);\n }\n \n /// Creates the `main` function which will initialize the rust runtime and call"}, {"sha": "f15456e0ff841033c732f8eda6d22ab5bfe39d77", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -29,7 +29,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n         // of putting everything in allocas just so we can use llvm.dbg.declare.\n         if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-            if mir.local_kind(local) == mir::LocalKind::Arg {\n+            if fx.mir.local_kind(local) == mir::LocalKind::Arg {\n                 analyzer.not_ssa(local);\n                 continue;\n             }\n@@ -70,9 +70,10 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n+        let dominators = fx.mir.dominators();\n         let mut analyzer = LocalAnalyzer {\n             fx,\n-            dominators: fx.mir.dominators(),\n+            dominators,\n             non_ssa_locals: BitSet::new_empty(fx.mir.local_decls.len()),\n             first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n@@ -130,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, &*self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "23a5b0cf32ac2260da8553738d972e6a3c267f1f", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     // a loop.\n     fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n         &self,\n-        mir: &'b mir::Body<'tcx>,\n+        mir: mir::ReadOnlyBodyCache<'b, 'tcx>,\n         bx: &mut Bx,\n         targets: &[mir::BasicBlock],\n     ) {\n@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).ty;\n+        let ty = location.ty(&*self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -510,7 +510,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(self.mir, bx.tcx());\n+            let op_ty = op_arg.ty(&*self.mir, bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n@@ -569,7 +569,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n                 helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n+                helper.funclet_br(self, &mut bx, target)\n             }\n             return;\n         }\n@@ -791,7 +791,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bb: mir::BasicBlock,\n     ) {\n         let mut bx = self.build_block(bb);\n-        let data = &self.mir[bb];\n+        let mir = self.mir;\n+        let data = &mir[bb];\n \n         debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n@@ -1050,7 +1051,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     fn landing_pad_uncached(\n         &mut self,\n-        target_bb: Bx::BasicBlock\n+        target_bb: Bx::BasicBlock,\n     ) -> Bx::BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")"}, {"sha": "8b60904081e6667c04b9fd0e438f8a8ef621d450", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnAbiExt};\n-use rustc::mir::{self, Body};\n+use rustc::mir::{self, Body, ReadOnlyBodyCache};\n use rustc_target::abi::call::{FnAbi, PassMode};\n use crate::base;\n use crate::traits::*;\n@@ -21,7 +21,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: &'a mir::Body<'tcx>,\n+    mir: mir::ReadOnlyBodyCache<'a, 'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -122,7 +122,7 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     llfn: Bx::Function,\n-    mir: &'a Body<'tcx>,\n+    mir: ReadOnlyBodyCache<'a, 'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n@@ -132,7 +132,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     debug!(\"fn_abi: {:?}\", fn_abi);\n \n     let debug_context =\n-        cx.create_function_debug_context(instance, sig, llfn, mir);\n+        cx.create_function_debug_context(instance, sig, llfn, &mir);\n \n     let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n@@ -155,8 +155,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n         }).collect();\n \n-    let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n-\n+    let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n+    let mir_body: &Body<'_> = mir.body();\n     let mut fx = FunctionCx {\n         instance,\n         mir,\n@@ -171,7 +171,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         funclets,\n         locals: IndexVec::new(),\n         debug_context,\n-        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir),\n+        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir_body),\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);\n@@ -181,7 +181,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let args = arg_local_refs(&mut bx, &fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n-            let decl = &mir.local_decls[local];\n+            let decl = &mir_body.local_decls[local];\n             let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n@@ -207,7 +207,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let retptr = allocate_local(mir::RETURN_PLACE);\n         iter::once(retptr)\n             .chain(args.into_iter())\n-            .chain(mir.vars_and_temps_iter().map(allocate_local))\n+            .chain(mir_body.vars_and_temps_iter().map(allocate_local))\n             .collect()\n     };\n \n@@ -226,8 +226,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         debug_context.source_locations_enabled = true;\n     }\n \n-    let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n+    let rpo = traversal::reverse_postorder(&mir_body);\n+    let mut visited = BitSet::new_empty(mir_body.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -237,7 +237,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n-    for bb in mir.basic_blocks().indices() {\n+    for bb in mir_body.basic_blocks().indices() {\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"codegen_mir: block {:?} was not visited\", bb);\n@@ -248,8 +248,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    mir: &'a Body<'tcx>,\n+fn create_funclets<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    mir: &'b Body<'tcx>,\n     bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>,"}, {"sha": "9dd4d0ec22f233ca7753dcaeedf9ad12c77a7b20", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -591,7 +591,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(\n+            place_ref.base,\n+            place_ref.projection,\n+            &*self.mir,\n+            tcx,\n+        );\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "3bae027e7634db9f40afac41fe1eeb1721959731", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -710,7 +710,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "5fb58eea3819d84ffaa720043e17d9125a5944ce", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -7,32 +7,33 @@\n use rustc_index::vec::{Idx, IndexVec};\n use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n+use std::borrow::BorrowMut;\n \n #[cfg(test)]\n mod tests;\n \n-pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n+pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     let start_node = graph.start_node();\n-    let rpo = reverse_post_order(graph, start_node);\n+    let rpo = reverse_post_order(&graph, start_node);\n     dominators_given_rpo(graph, &rpo)\n }\n \n-fn dominators_given_rpo<G: ControlFlowGraph>(\n-    graph: &G,\n+fn dominators_given_rpo<G: ControlFlowGraph + BorrowMut<G>>(\n+    mut graph: G,\n     rpo: &[G::Node],\n ) -> Dominators<G::Node> {\n-    let start_node = graph.start_node();\n+    let start_node = graph.borrow().start_node();\n     assert_eq!(rpo[0], start_node);\n \n     // compute the post order index (rank) for each node\n     let mut post_order_rank: IndexVec<G::Node, usize> =\n-        (0..graph.num_nodes()).map(|_| 0).collect();\n+        (0..graph.borrow().num_nodes()).map(|_| 0).collect();\n     for (index, node) in rpo.iter().rev().cloned().enumerate() {\n         post_order_rank[node] = index;\n     }\n \n     let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n-        (0..graph.num_nodes()).map(|_| None).collect();\n+        (0..graph.borrow().num_nodes()).map(|_| None).collect();\n     immediate_dominators[start_node] = Some(start_node);\n \n     let mut changed = true;\n@@ -41,7 +42,7 @@ fn dominators_given_rpo<G: ControlFlowGraph>(\n \n         for &node in &rpo[1..] {\n             let mut new_idom = None;\n-            for pred in graph.predecessors(node) {\n+            for pred in graph.borrow_mut().predecessors(node) {\n                 if immediate_dominators[pred].is_some() {\n                     // (*) dominators for `pred` have been calculated\n                     new_idom = Some(if let Some(new_idom) = new_idom {"}, {"sha": "42db642cd4ddb1f4461167fe78bad30b353a16e5", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -18,12 +18,11 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc::dep_graph::{self, DepNodeIndex};\n use rustc::middle::lang_items;\n-use rustc::mir::{self, interpret};\n+use rustc::mir::{self, BodyCache, interpret, Promoted};\n use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::mir::{Body, Promoted};\n use rustc::util::common::record_time;\n use rustc::util::captures::Captures;\n \n@@ -1080,26 +1079,32 @@ impl<'a, 'tcx> CrateMetadata {\n             self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.root.per_def.mir.get(self, id)\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> BodyCache<'tcx> {\n+        let mut cache = self.root.per_def.mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n-            .decode((self, tcx))\n+            .decode((self, tcx));\n+        cache.ensure_predecessors();\n+        cache\n     }\n \n     fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.root.per_def.promoted_mir.get(self, id)\n+    ) -> IndexVec<Promoted, BodyCache<'tcx>> {\n+        let mut cache = self.root.per_def.promoted_mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n-            .decode((self, tcx))\n+            .decode((self, tcx));\n+        for body in cache.iter_mut() {\n+            body.ensure_predecessors();\n+        }\n+        cache\n     }\n \n     fn mir_const_qualif(&self, id: DefIndex) -> mir::ConstQualifs {"}, {"sha": "fdf43f06eb10f65dcbb4b2606db21cf07acfb42f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -276,8 +276,8 @@ define_per_def_tables! {\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n     inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    mir: Table<DefIndex, Lazy!(mir::BodyCache<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::BodyCache<'tcx>>)>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "802464ce86b8641ae6e2bde4f044120c2be8e263", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -5,7 +5,7 @@ use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{PlaceContext, Visitor, NonUseContext, MutatingUseContext};\n-use rustc::mir::{self, Location, Body, Local};\n+use rustc::mir::{self, Location, Body, Local, ReadOnlyBodyCache};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_index::vec::IndexVec;\n@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        body: &Body<'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -106,7 +106,8 @@ impl LocalsStateAtExit {\n         if locals_are_invalidated_at_exit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n-            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(body.local_decls.len()));\n+            let mut has_storage_dead\n+                = HasStorageDead(BitSet::new_empty(body.local_decls.len()));\n             has_storage_dead.visit_body(body);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {\n@@ -123,13 +124,13 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'tcx>,\n-        body: &Body<'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {\n         let mut visitor = GatherBorrows {\n             tcx,\n-            body,\n+            body: &body,\n             idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n@@ -139,7 +140,7 @@ impl<'tcx> BorrowSet<'tcx> {\n                 LocalsStateAtExit::build(locals_are_invalidated_at_exit, body, move_data),\n         };\n \n-        for (block, block_data) in traversal::preorder(body) {\n+        for (block, block_data) in traversal::preorder(&body) {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n "}, {"sha": "73a9fd81c9b4f3fcc7b31969a87b008f9f254726", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -205,9 +205,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            let ty =\n-                Place::ty_from(used_place.base, used_place.projection, self.body, self.infcx.tcx)\n-                    .ty;\n+            let ty = Place::ty_from(\n+                used_place.base,\n+                used_place.projection,\n+                &*self.body,\n+                self.infcx.tcx\n+            ).ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -222,7 +225,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(&*self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -314,7 +317,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         ).add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -356,7 +359,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -578,7 +581,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             first_borrow_desc,\n@@ -619,7 +622,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place_base, place_projection| {\n-            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n+            let ty = Place::ty_from(\n+                place_base,\n+                place_projection,\n+                &*self.body,\n+                self.infcx.tcx\n+            ).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n         let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n@@ -965,7 +973,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else {\n                 explanation.add_explanation_to_diagnostic(\n                     self.infcx.tcx,\n-                    self.body,\n+                    &self.body,\n                     &self.local_names,\n                     &mut err,\n                     \"\",\n@@ -991,7 +999,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n \n             explanation.add_explanation_to_diagnostic(\n-                self.infcx.tcx, self.body, &self.local_names, &mut err, \"\", None);\n+                self.infcx.tcx, &self.body, &self.local_names, &mut err, \"\", None);\n         }\n \n         err\n@@ -1051,7 +1059,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1138,7 +1146,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.body,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1174,11 +1182,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         // FIXME use a better heuristic than Spans\n-        let reference_desc = if return_span == self.body.source_info(borrow.reserve_location).span {\n-            \"reference to\"\n-        } else {\n-            \"value referencing\"\n-        };\n+        let reference_desc\n+            = if return_span == self.body.source_info(borrow.reserve_location).span {\n+                \"reference to\"\n+            } else {\n+                \"value referencing\"\n+            };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n@@ -1372,10 +1381,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n-        let body = self.body;\n-\n         let mut stack = Vec::new();\n-        stack.extend(body.predecessor_locations(location).map(|predecessor| {\n+        stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n             let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n@@ -1394,7 +1401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             // check for moves\n-            let stmt_kind = body[location.block]\n+            let stmt_kind = self.body[location.block]\n                 .statements\n                 .get(location.statement_index)\n                 .map(|s| &s.kind);\n@@ -1449,7 +1456,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut any_match = false;\n             drop_flag_effects::for_location_inits(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body,\n                 self.move_data,\n                 location,\n                 |m| {\n@@ -1462,7 +1469,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(body.predecessor_locations(location).map(|predecessor| {\n+            stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n                 let back_edge = location.dominates(predecessor, &self.dominators);\n                 (predecessor, is_back_edge || back_edge)\n             }));\n@@ -1514,7 +1521,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, loan, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                self.body,\n+                &self.body,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -1625,15 +1632,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, proj_base, self.body, tcx).ty.is_box(),\n+                                Place::ty_from(\n+                                    &place.base,\n+                                    proj_base,\n+                                    &*self.body,\n+                                    tcx\n+                                ).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(\n+                            &place.base,\n+                            proj_base,\n+                            &*self.body,\n+                            tcx\n+                        ).ty;\n                         match base_ty.kind {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1678,7 +1695,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n         let mut visitor = FakeReadCauseFinder { place, cause: None };\n-        visitor.visit_body(&self.body);\n+        visitor.visit_body(self.body);\n         match visitor.cause {\n             Some(FakeReadCause::ForMatchGuard) => Some(\"match guard\"),\n             Some(FakeReadCause::ForIndex) => Some(\"indexing expression\"),\n@@ -1736,7 +1753,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // Next, look through the rest of the block, checking if we are assigning the\n             // `target` (that is, the place that contains our borrow) to anything.\n             let mut annotated_closure = None;\n-            for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n+            for stmt in &self.body[location.block].statements[location.statement_index + 1..]\n+            {\n                 debug!(\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt"}, {"sha": "cc15d236b2325865fb90702ee5e8173430189659", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -369,8 +369,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty =\n-                        Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n+                    let base_ty = Place::ty_from(\n+                        place.base,\n+                        place.projection,\n+                        &*self.body,\n+                        self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -498,9 +501,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         },\n                         ..\n                     }) = bbd.terminator {\n-                        if let Some(source)\n-                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n-                        {\n+                        if let Some(source) = BorrowedContentSource::from_call(\n+                            func.ty(&*self.body, tcx),\n+                            tcx\n+                        ) {\n                             return source;\n                         }\n                     }\n@@ -512,7 +516,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, self.body, tcx).ty;\n+        let base_ty = Place::ty_from(\n+            deref_base.base,\n+            deref_base.projection,\n+            &*self.body,\n+            tcx\n+        ).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "da08de7690ab22043472a446912af1686bc832f9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -9,8 +9,8 @@ use rustc::lint::builtin::UNUSED_MUT;\n use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceElem,\n-    PlaceRef, Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, BodyCache, Mutability, Operand, Place, PlaceBase,\n+    PlaceElem, PlaceRef, ReadOnlyBodyCache, Static, StaticKind, read_only\n };\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -102,7 +102,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n-    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    input_promoted: &IndexVec<Promoted, BodyCache<'tcx>>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -162,16 +162,22 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let mut body: Body<'tcx> = input_body.clone();\n-    let mut promoted: IndexVec<Promoted, Body<'tcx>> = input_promoted.clone();\n+    let body_clone: Body<'tcx> = input_body.clone();\n+    let mut promoted = input_promoted.clone();\n+    let mut body = BodyCache::new(body_clone);\n     let free_regions =\n         nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n-    let body = &body; // no further changes\n-    let location_table = &LocationTable::new(body);\n+    let body = read_only!(body); // no further changes\n+    let promoted: IndexVec<_, _> = promoted\n+        .iter_mut()\n+        .map(|body| read_only!(body))\n+        .collect();\n+\n+    let location_table = &LocationTable::new(&body);\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(body, tcx) {\n+        match MoveData::gather_moves(&body, tcx) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -184,17 +190,17 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n+        tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n@@ -222,29 +228,29 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, body, param_env, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, &body, param_env, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, body, &mdpe),\n+        EverInitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -336,7 +342,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n     let used_mut = mbcx.used_mut;\n-    for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n+    for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local))\n+    {\n         let local_decl = &mbcx.body.local_decls[local];\n         let lint_root = match &mbcx.body.source_scopes[local_decl.source_info.scope].local_data {\n             ClearCrossCrate::Set(data) => data.lint_root,\n@@ -398,7 +405,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    body: &'cx Body<'tcx>,\n+    body: ReadOnlyBodyCache<'cx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n@@ -489,7 +496,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn body(&self) -> &'cx Body<'tcx> {\n-        self.body\n+        self.body.body()\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -639,7 +646,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(&*self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -984,6 +991,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n+        let body: &Body<'_> = &body;\n         let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n@@ -1334,7 +1342,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => bug!(\"temporary initialized in arguments\"),\n                         };\n \n-                        let bbd = &self.body[loc.block];\n+                        let body = self.body;\n+                        let bbd = &body[loc.block];\n                         let stmt = &bbd.statements[loc.statement_index];\n                         debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n@@ -1453,7 +1462,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n             self.param_env,\n-            self.body,\n+            &self.body,\n             place,\n             borrow.kind,\n             root_place,\n@@ -1744,7 +1753,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body(), tcx).ty;\n                     match base_ty.kind {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n@@ -1851,7 +1860,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.kind\n+                    Place::ty_from(base.base, base.projection, this.body(), tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -2121,7 +2130,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind {\n@@ -2261,7 +2270,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place_projection {\n             [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, base, self.body(), tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {"}, {"sha": "388a8abd5fc1ff582db9919f05486cfb9bd62785", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(&*self.body, self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(self.body, self.infcx.tcx).ty,\n+            move_place.ty(&*self.body, self.infcx.tcx).ty,\n         );\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(&*self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(&*self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),"}, {"sha": "e135f8d1be98d3d0070bbdd796ef0a051b26a1ba", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, Body, ClearCrossCrate, Local, LocalInfo, Location};\n+use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location, ReadOnlyBodyCache};\n use rustc::mir::{Mutability, Place, PlaceRef, PlaceBase, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_index::vec::Idx;\n@@ -61,8 +61,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, proj_base, self.body, self.infcx.tcx).ty\n-                ));\n+                    Place::ty_from(\n+                        &the_place_err.base,\n+                        proj_base,\n+                        &*self.body,\n+                        self.infcx.tcx\n+                    ).ty));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n@@ -111,7 +115,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Place::ty_from(\n                             the_place_err.base,\n                             the_place_err.projection,\n-                            self.body,\n+                            &*self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -225,7 +229,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -300,7 +304,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -529,7 +533,7 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_ty_info: Option<Span>,"}, {"sha": "43aabac00bcfad9582625c5562c7219921772840", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -237,7 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n-        let body = self.body;\n+        let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n@@ -297,9 +297,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n-                            self.body,\n-                        &self.local_names,\n-                        &self.upvars,\n+                            &self.body,\n+                            &self.local_names,\n+                            &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n                             borrow_region_vid,"}, {"sha": "98679f236db50142a4bc2a2acaa1319cd3b11078", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -11,7 +11,7 @@ use crate::borrow_check::path_utils::*;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Body, Place, Rvalue};\n+use rustc::mir::{BasicBlock, Location, Body, Place, ReadOnlyBodyCache, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n@@ -22,7 +22,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -38,7 +38,7 @@ pub(super) fn generate_invalidates<'tcx>(\n             param_env,\n             tcx,\n             location_table,\n-            body,\n+            body: &body,\n             dominators,\n         };\n         ig.visit_body(body);"}, {"sha": "16182fe24fa4f171f2487da2502800bea44d39ad", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -12,7 +12,8 @@ use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Local, Location, Body, LocalKind, BasicBlock, Promoted};\n+                 Local, Location, Body, BodyCache, LocalKind, BasicBlock,\n+                 Promoted, ReadOnlyBodyCache};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_index::vec::IndexVec;\n use rustc_errors::Diagnostic;\n@@ -54,8 +55,8 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    body: &mut BodyCache<'tcx>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n@@ -157,8 +158,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    body: &Body<'tcx>,\n-    promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n+    promoted: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     local_names: &IndexVec<Local, Option<Symbol>>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n@@ -180,7 +181,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     let universal_regions = Rc::new(universal_regions);\n \n-    let elements = &Rc::new(RegionValueElements::new(body));\n+    let elements\n+        = &Rc::new(RegionValueElements::new(&body));\n \n     // Run the MIR type-checker.\n     let MirTypeckResults {\n@@ -205,7 +207,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n-        populate_polonius_move_facts(all_facts, move_data, location_table, body);\n+        populate_polonius_move_facts(all_facts, move_data, location_table, &body);\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -238,7 +240,6 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_regions,\n         placeholder_indices,\n         universal_region_relations,\n-        body,\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n@@ -253,7 +254,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         param_env,\n         &mut all_facts,\n         location_table,\n-        &body,\n+        body,\n         borrow_set,\n     );\n \n@@ -283,7 +284,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, body, local_names, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n@@ -297,7 +298,13 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // We also have a `#[rustc_nll]` annotation that causes us to dump\n     // information\n-    dump_annotation(infcx, &body, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n+    dump_annotation(\n+        infcx,\n+        &body,\n+        def_id,\n+        &regioncx,\n+        &closure_region_requirements,\n+        errors_buffer);\n \n     (regioncx, polonius_output, closure_region_requirements)\n }"}, {"sha": "bd9e97e5b633b6fca17f68e0fd77efb45aae06c5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -239,7 +239,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n-        _body: &Body<'tcx>,\n         outlives_constraints: OutlivesConstraintSet,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<"}, {"sha": "b4414c514c5325d81d6e22af4f3a0cc24bb51e0b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{BasicBlock, Location, Body};\n+use rustc::mir::{BasicBlock, Location, Body, ReadOnlyBodyCache};\n use rustc::ty::{self, RegionVid};\n use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_data_structures::fx::FxHashMap;\n@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        body: &Body<'_>,\n+        body: ReadOnlyBodyCache<'_, '_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {"}, {"sha": "db15d2c54fdbcf94bca0a26846853e2ec5c5b298", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::mir::{Body, Location, PlaceElem, Promoted};\n+use rustc::mir::{BodyCache, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_index::vec::IndexVec;\n@@ -9,8 +9,8 @@ use rustc_index::vec::IndexVec;\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    body: &mut BodyCache<'tcx>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);"}, {"sha": "d6aa31449daa72d7c68f9ce57311807753b7bd6c", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Body, Local, Location};\n+use rustc::mir::{Local, Location, ReadOnlyBodyCache};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::vec_linked_list as vll;\n \n@@ -60,7 +60,7 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        body: &Body<'_>,\n+        body: ReadOnlyBodyCache<'_, '_>,\n     ) -> Self {\n         let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {"}, {"sha": "dfd505f6b613a72d00ab16907add8a8f39c79ca3", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -7,7 +7,7 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use rustc::mir::{Body, Local};\n+use rustc::mir::{Body, Local, ReadOnlyBodyCache};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n@@ -28,7 +28,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -41,10 +41,9 @@ pub(super) fn generate<'tcx>(\n         &typeck.borrowck_context.universal_regions,\n         &typeck.borrowck_context.constraints.outlives_constraints,\n     );\n-    let live_locals = compute_live_locals(typeck.tcx(), &free_regions, body);\n+    let live_locals = compute_live_locals(typeck.tcx(), &free_regions, &body);\n     let facts_enabled = AllFacts::enabled(typeck.tcx());\n \n-\n     let polonius_drop_used = if facts_enabled {\n         let mut drop_used = Vec::new();\n         polonius::populate_access_facts("}, {"sha": "e67de6c99f026b400621bf92332e32756ed59ca6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -3,7 +3,7 @@ use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{LookupResult, MoveData};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n-use rustc::mir::{Body, Local, Location, Place};\n+use rustc::mir::{Local, Location, Place, ReadOnlyBodyCache};\n use rustc::ty::subst::GenericArg;\n use rustc::ty::Ty;\n \n@@ -97,7 +97,7 @@ fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty\n \n pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n     drop_used: &mut Vec<(Local, Location)>,"}, {"sha": "229cbed64c27225d5bcff0e4810ebd16ed14e4c5", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -7,7 +7,7 @@ use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n+use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, ReadOnlyBodyCache};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n@@ -32,7 +32,7 @@ use std::rc::Rc;\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -71,7 +71,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    body: &'me Body<'tcx>,\n+    body: ReadOnlyBodyCache<'me, 'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,\n@@ -302,7 +302,8 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n         }\n \n-        for &pred_block in self.cx.body.predecessors_for(block).iter() {\n+        let body = self.cx.body;\n+        for &pred_block in body.predecessors_for(block).iter() {\n             debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)"}, {"sha": "a554867389e120f7a24a98f5ea0dcef3070361f8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 102, "deletions": 77, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,57 +1,59 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n \n-use crate::borrow_check::borrow_set::BorrowSet;\n-use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n-use crate::borrow_check::nll::member_constraints::MemberConstraintSet;\n-use crate::borrow_check::nll::facts::AllFacts;\n-use crate::borrow_check::nll::region_infer::values::LivenessValues;\n-use crate::borrow_check::nll::region_infer::values::PlaceholderIndex;\n-use crate::borrow_check::nll::region_infer::values::PlaceholderIndices;\n-use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n-use crate::borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use crate::borrow_check::nll::renumber;\n-use crate::borrow_check::nll::type_check::free_region_relations::{\n-    CreateResult, UniversalRegionRelations,\n-};\n-use crate::borrow_check::nll::universal_regions::{DefiningTy, UniversalRegions};\n-use crate::borrow_check::nll::ToRegionVid;\n-use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n-use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::FlowAtLocation;\n-use crate::dataflow::MaybeInitializedPlaces;\n+use std::{fmt, iter, mem};\n+use std::rc::Rc;\n+\n use either::Either;\n+\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::mir::*;\n use rustc::mir::interpret::PanicInfo;\n use rustc::mir::tcx::PlaceTy;\n-use rustc::mir::visit::{PlaceContext, Visitor, NonMutatingUseContext};\n-use rustc::mir::*;\n+use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc::traits::{self, ObligationCause, PredicateObligations};\n+use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n-use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{self, ObligationCause, PredicateObligations};\n-use rustc::ty::adjustment::{PointerCast};\n-use rustc::ty::cast::CastTy;\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind, UserSubsts};\n use rustc::ty::{\n-    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, UserType,\n-    CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n+    TyCtxt, UserType,\n     UserTypeAnnotationIndex,\n };\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_index::vec::{IndexVec, Idx};\n+use rustc::ty::adjustment::PointerCast;\n+use rustc::ty::cast::CastTy;\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::VariantIdx;\n-use std::rc::Rc;\n-use std::{fmt, iter, mem};\n-use syntax_pos::{Span, DUMMY_SP};\n-\n+use rustc::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_error_codes::*;\n+use rustc_index::vec::{Idx, IndexVec};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use crate::borrow_check::borrow_set::BorrowSet;\n+use crate::borrow_check::location::LocationTable;\n+use crate::borrow_check::nll::constraints::{OutlivesConstraint, OutlivesConstraintSet};\n+use crate::borrow_check::nll::facts::AllFacts;\n+use crate::borrow_check::nll::member_constraints::MemberConstraintSet;\n+use crate::borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use crate::borrow_check::nll::region_infer::values::LivenessValues;\n+use crate::borrow_check::nll::region_infer::values::PlaceholderIndex;\n+use crate::borrow_check::nll::region_infer::values::PlaceholderIndices;\n+use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n+use crate::borrow_check::nll::renumber;\n+use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::nll::type_check::free_region_relations::{\n+    CreateResult, UniversalRegionRelations,\n+};\n+use crate::borrow_check::nll::universal_regions::{DefiningTy, UniversalRegions};\n+use crate::dataflow::FlowAtLocation;\n+use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::move_paths::MoveData;\n+use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n@@ -115,8 +117,8 @@ mod relate_tys;\n pub(crate) fn type_check<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &Body<'tcx>,\n-    promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n+    promoted: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -168,8 +170,17 @@ pub(crate) fn type_check<'tcx>(\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n-            cx.equate_inputs_and_outputs(body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n+            cx.equate_inputs_and_outputs(\n+                &body,\n+                universal_regions,\n+                &normalized_inputs_and_output);\n+            liveness::generate(\n+                &mut cx,\n+                body,\n+                elements,\n+                flow_inits,\n+                move_data,\n+                location_table);\n \n             translate_outlives_facts(cx.borrowck_context);\n         },\n@@ -185,17 +196,17 @@ fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n+    body: ReadOnlyBodyCache<'a, 'tcx>,\n+    promoted: &'a IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'tcx>) -> R,\n-) -> R where {\n+) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        body,\n+        body.body(),\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -204,7 +215,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, body.body(), promoted);\n         verifier.visit_body(body);\n         verifier.errors_reported\n     };\n@@ -261,7 +272,7 @@ enum FieldAccessError {\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n-    promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -385,7 +396,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, body: &Body<'tcx>) {\n+    fn visit_body(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>) {\n         self.sanitize_type(&\"return type\", body.return_ty());\n         for local_decl in &body.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n@@ -401,7 +412,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n         body: &'b Body<'tcx>,\n-        promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n+        promoted: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n     ) -> Self {\n         TypeVerifier {\n             body,\n@@ -464,10 +475,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 match kind {\n                     StaticKind::Promoted(promoted, _) => {\n                         if !self.errors_reported {\n-                            let promoted_body = &self.promoted[*promoted];\n-                            self.sanitize_promoted(promoted_body, location);\n+                            let promoted_body_cache = self.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_body_cache, location);\n \n-                            let promoted_ty = promoted_body.return_ty();\n+                            let promoted_ty = promoted_body_cache.return_ty();\n                             check_err(self, place, promoted_ty, san_ty);\n                         }\n                     }\n@@ -535,20 +546,24 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         place_ty\n     }\n \n-    fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n+    fn sanitize_promoted(\n+        &mut self,\n+        promoted_body: ReadOnlyBodyCache<'b, 'tcx>,\n+        location: Location\n+    ) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, promoted_body);\n+        let parent_body = mem::replace(&mut self.body, promoted_body.body());\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n         let mut liveness_constraints = LivenessValues::new(\n-            Rc::new(RegionValueElements::new(promoted_body)),\n+            Rc::new(RegionValueElements::new(&promoted_body)),\n         );\n         // Don't try to add borrow_region facts for the promoted MIR\n \n@@ -1361,7 +1376,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n+    fn check_stmt(\n+        &mut self,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n+        stmt: &Statement<'tcx>,\n+        location: Location)\n+    {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n@@ -1393,9 +1413,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(body, tcx).ty;\n+                let place_ty = place.ty(&*body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(body, tcx);\n+                let rv_ty = rv.ty(&*body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1447,7 +1467,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(body, tcx).ty;\n+                let place_type = place.ty(&*body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1469,7 +1489,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n-                let place_ty = place.ty(body, tcx).ty;\n+                let place_ty = place.ty(&*body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1972,20 +1992,25 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+    fn check_rvalue(\n+        &mut self,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location)\n+    {\n         let tcx = self.tcx();\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n-                self.check_aggregate_rvalue(body, rvalue, ak, ops, location)\n+                self.check_aggregate_rvalue(&body, rvalue, ak, ops, location)\n             }\n \n             Rvalue::Repeat(operand, len) => if *len > 1 {\n                 if let Operand::Move(_) = operand {\n                     // While this is located in `nll::typeck` this error is not an NLL error, it's\n                     // a required check to make sure that repeated elements implement `Copy`.\n                     let span = body.source_info(location).span;\n-                    let ty = operand.ty(body, tcx);\n+                    let ty = operand.ty(&*body, tcx);\n                     if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                         // To determine if `const_in_array_repeat_expressions` feature gate should\n                         // be mentioned, need to check if the rvalue is promotable.\n@@ -2039,7 +2064,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2068,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(body, tcx).kind {\n+                        let sig = match op.ty(&*body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2094,7 +2119,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2126,7 +2151,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(&*body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2137,7 +2162,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body, tcx).kind {\n+                        let ty_from = match op.ty(&*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mutable,\n@@ -2185,7 +2210,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n-                        let ty_from = op.ty(body, tcx);\n+                        let ty_from = op.ty(&*body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n@@ -2247,7 +2272,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(body, tcx);\n+                        let ty_from = op.ty(&*body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2305,7 +2330,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(body, location, region, borrowed_place);\n+                self.add_reborrow_constraint(&body, location, region, borrowed_place);\n             }\n \n             Rvalue::BinaryOp(BinOp::Eq, left, right)\n@@ -2314,9 +2339,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(body, tcx);\n+                let ty_left = left.ty(&*body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(body, tcx);\n+                    let ty_right = right.ty(&*body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,\n@@ -2741,12 +2766,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, body: &Body<'tcx>) {\n+    fn typeck_mir(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>) {\n         self.last_span = body.span;\n         debug!(\"run_on_mir: {:?}\", body.span);\n \n         for (local, local_decl) in body.local_decls.iter_enumerated() {\n-            self.check_local(body, local, local_decl);\n+            self.check_local(&body, local, local_decl);\n         }\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n@@ -2762,8 +2787,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 location.statement_index += 1;\n             }\n \n-            self.check_terminator(body, block_data.terminator(), location);\n-            self.check_iscleanup(body, block_data);\n+            self.check_terminator(&body, block_data.terminator(), location);\n+            self.check_iscleanup(&body, block_data);\n         }\n     }\n "}, {"sha": "06b9d4dbde00345f499b3632b1efe33bb8e09faa", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -11,7 +11,7 @@ use super::MirBorrowckCtxt;\n \n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{Body, Place, PlaceBase, PlaceRef, ProjectionElem};\n+use rustc::mir::{Place, PlaceBase, PlaceRef, ProjectionElem, ReadOnlyBodyCache};\n \n pub trait IsPrefixOf<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool;\n@@ -26,7 +26,7 @@ impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n }\n \n pub(super) struct Prefixes<'cx, 'tcx> {\n-    body: &'cx Body<'tcx>,\n+    body: ReadOnlyBodyCache<'cx, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n     next: Option<PlaceRef<'cx, 'tcx>>,\n@@ -143,7 +143,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.base, proj_base, &*self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) |\n                         ty::Ref("}, {"sha": "b84461d6b9275480a0b5b872ed2501e423b9eb6e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -24,7 +24,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n+pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyCache<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -196,6 +196,8 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n         lints::check(tcx, &body, def_id);\n \n+        let mut body = BodyCache::new(body);\n+        body.ensure_predecessors();\n         body\n     })\n }"}, {"sha": "a3eac1eecf0e21605ee6d3ca3daa40fef94f2eba", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -354,7 +354,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => body,\n+            Ok(body) => body.body(),\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n                     return Err(\n@@ -731,7 +731,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, body)\n+        |body| eval_body_using_ecx(&mut ecx, cid, body.body())\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "7e7652cdab5ce099f8ca03781bbff250da481b58", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -98,7 +98,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n             // Add successor BBs to the work list, if necessary.\n             let bb_data = &body[bb];\n             assert!(hi == bb_data.statements.len());\n-            for &succ_bb in bb_data.terminator.as_ref().unwrap().successors() {\n+            for &succ_bb in bb_data.terminator().successors() {\n                 visited.entry(succ_bb)\n                     .and_modify(|lo| {\n                         // `succ_bb` has been seen before. If it wasn't\n@@ -153,8 +153,8 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n \n         Borrows {\n-            tcx: tcx,\n-            body: body,\n+            tcx,\n+            body,\n             param_env,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,"}, {"sha": "0fb912b5fcbd8f5a9323575ed7034a6a8647502e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -71,7 +71,7 @@ pub struct MaybeInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        MaybeInitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -122,7 +122,7 @@ pub struct MaybeUninitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        MaybeUninitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -172,7 +172,7 @@ pub struct DefinitelyInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        DefinitelyInitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -217,7 +217,7 @@ pub struct EverInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> EverInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        EverInitializedPlaces { tcx, body, mdpe }\n     }\n }\n "}, {"sha": "c4b97d12e6270730b17183f051026104bd4b07cf", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -75,24 +75,26 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n pub struct RequiresStorage<'mir, 'tcx> {\n-    body: &'mir Body<'tcx>,\n+    body: ReadOnlyBodyCache<'mir, 'tcx>,\n     borrowed_locals:\n         RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n }\n \n impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n     pub fn new(\n-        body: &'mir Body<'tcx>,\n+        body: ReadOnlyBodyCache<'mir, 'tcx>,\n         borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n     ) -> Self {\n         RequiresStorage {\n             body,\n-            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body)),\n+            borrowed_locals: RefCell::new(\n+                DataflowResultsCursor::new(borrowed_locals, body.body())\n+            ),\n         }\n     }\n \n     pub fn body(&self) -> &Body<'tcx> {\n-        self.body\n+        &self.body\n     }\n }\n "}, {"sha": "9af47f3e77f93f73cc5d9abb7cf467d7145b32dc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -312,7 +312,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n         promoted: Option<mir::Promoted>,\n-    ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n+    ) -> InterpResult<'tcx, mir::ReadOnlyBodyCache<'tcx, 'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if did.is_local()\n@@ -323,11 +323,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n+            return Ok(self.tcx.promoted_mir(did)[promoted].unwrap_read_only());\n         }\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n-                Ok(self.tcx.optimized_mir(did))\n+                Ok(self.tcx.optimized_mir(did).unwrap_read_only())\n             } else {\n                 throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },"}, {"sha": "4fe53cf35e5113b957cf2f952c7faf9a1678c13a", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1255,7 +1255,7 @@ fn collect_neighbours<'tcx>(\n         body: &body,\n         output,\n         param_substs: instance.substs,\n-    }.visit_body(&body);\n+    }.visit_body(body);\n }\n \n fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {"}, {"sha": "680f75eb84e2c29514061198beef925af3cad9dd", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx BodyCache<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -125,6 +125,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n+    result.ensure_predecessors();\n     tcx.arena.alloc(result)\n }\n \n@@ -164,7 +165,9 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> Body<'tcx> {\n+fn build_drop_shim<'tcx>(\n+    tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>\n+) -> BodyCache<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -196,12 +199,14 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let mut body = new_body(\n+    let body = new_body(\n         blocks,\n         local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n         span);\n \n+    let mut body = BodyCache::new(body);\n+\n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n         let dropee_ptr = Place::from(Local::new(1+0));\n@@ -314,7 +319,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> BodyCache<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let param_env = tcx.param_env(def_id);\n@@ -343,7 +348,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n         }\n     };\n \n-    builder.into_mir()\n+    BodyCache::new(builder.into_mir())\n }\n \n struct CloneShimBuilder<'tcx> {\n@@ -704,7 +709,7 @@ fn build_call_shim<'tcx>(\n     rcvr_adjustment: Adjustment,\n     call_kind: CallKind,\n     untuple_args: Option<&[Ty<'tcx>]>,\n-) -> Body<'tcx> {\n+) -> BodyCache<'tcx> {\n     debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n@@ -839,10 +844,10 @@ fn build_call_shim<'tcx>(\n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n     }\n-    body\n+    BodyCache::new(body)\n }\n \n-pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n+pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &BodyCache<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)\n@@ -926,5 +931,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         |_, _| Ok(()),\n     );\n \n+    let mut body = BodyCache::new(body);\n+    body.ensure_predecessors();\n     tcx.arena.alloc(body)\n }"}, {"sha": "35238e2d08a2e4a2547d4a2026bc4409738d05d3", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -31,15 +31,16 @@ pub use self::AddCallGuards::*;\n  */\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         self.add_call_guards(body);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, body: &mut Body<'_>) {\n-        let pred_count: IndexVec<_, _> =\n-            body.predecessors().iter().map(|ps| ps.len()).collect();\n+    pub fn add_call_guards(&self, body: &mut BodyCache<'_>) {\n+        let pred_count: IndexVec<_, _> = body.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();"}, {"sha": "98c6a5ed07780d0d27de277b16ed54757ec43078", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -40,13 +40,15 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n+pub fn add_moves_for_packed_drops<'tcx>(\n+    tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>, def_id: DefId\n+) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }"}, {"sha": "e6ad37ae11362481903beec44a2d16385ca97d9f", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -59,7 +59,7 @@ fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n }\n \n impl<'tcx> MirPass<'tcx> for AddRetag {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "7095b3fa0aa83d88e7e78704ceaced6b29e86d04", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -20,7 +20,7 @@ pub mod validation;\n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n-    pub body: &'mir mir::Body<'tcx>,\n+    pub body: mir::ReadOnlyBodyCache<'mir, 'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -31,7 +31,7 @@ impl Item<'mir, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        body: &'mir mir::Body<'tcx>,\n+        body: mir::ReadOnlyBodyCache<'mir, 'tcx>,\n     ) -> Self {\n         let param_env = tcx.param_env(def_id);\n         let const_kind = ConstKind::for_item(tcx, def_id);"}, {"sha": "62b4a4ccc9894182ed1dff542cde6d27c723c31d", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -51,7 +51,7 @@ pub trait Qualif {\n             });\n             let qualif = base_qualif && Self::in_any_value_of_ty(\n                 cx,\n-                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                Place::ty_from(place.base, proj_base, &*cx.body, cx.tcx)\n                     .projection_ty(cx.tcx, elem)\n                     .ty,\n             );\n@@ -155,7 +155,7 @@ pub trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n                     if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, &*cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n@@ -221,7 +221,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.body, cx.tcx);\n+                        let ty = rvalue.ty(&*cx.body, cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n                         return true;\n                     }"}, {"sha": "9004c5be987fd6ea20bfe3bf4bc88fcf2fda8514", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -77,7 +77,7 @@ where\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n-        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(&*self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_call(\n             self.item,\n             &|l| self.qualifs_per_local.contains(l),"}, {"sha": "9d477bfbae81f22ef4bfe471d2a198f131f12fc0", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -39,9 +39,9 @@ impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n     ) -> Self {\n         let analysis = FlowSensitiveAnalysis::new(q, item);\n         let results =\n-            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+            dataflow::Engine::new(item.tcx, &item.body, item.def_id, dead_unwinds, analysis)\n                 .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+        let cursor = dataflow::ResultsCursor::new(item.body.body(), results);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n         for (local, decl) in item.body.local_decls.iter_enumerated() {\n@@ -172,17 +172,17 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let indirectly_mutable = old_dataflow::do_dataflow(\n             item.tcx,\n-            item.body,\n+            &*item.body,\n             item.def_id,\n             &item.tcx.get_attrs(item.def_id),\n             &dead_unwinds,\n-            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body.body(), item.param_env),\n             |_, local| old_dataflow::DebugFormatted::new(&local),\n         );\n \n         let indirectly_mutable = old_dataflow::DataflowResultsCursor::new(\n             indirectly_mutable,\n-            item.body,\n+            item.body.body(),\n         );\n \n         let qualifs = Qualifs {\n@@ -208,7 +208,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         if use_min_const_fn_checks {\n             // Enforce `min_const_fn` for stable `const fn`s.\n             use crate::transform::qualify_min_const_fn::is_min_const_fn;\n-            if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+            if let Err((span, err)) = is_min_const_fn(tcx, def_id, &body) {\n                 error_min_const_fn_violation(tcx, span, err);\n                 return;\n             }\n@@ -230,7 +230,7 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         if should_check_for_sync {\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            check_return_ty_is_sync(tcx, body, hir_id);\n+            check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }\n \n@@ -304,7 +304,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, &*self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -342,7 +342,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n             => {\n-                let ty = place.ty(self.body, self.tcx).ty;\n+                let ty = place.ty(&*self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n@@ -390,7 +390,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n+                let operand_ty = operand.ty(&*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -401,7 +401,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -475,7 +475,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n@@ -499,7 +499,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -548,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(self.body, self.tcx);\n+                let fn_ty = func.ty(&*self.body, self.tcx);\n \n                 let def_id = match fn_ty.kind {\n                     ty::FnDef(def_id, _) => def_id,\n@@ -609,7 +609,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop = dropped_place\n-                    .ty(self.body, self.tcx)\n+                    .ty(&*self.body, self.tcx)\n                     .ty\n                     .needs_drop(self.tcx, self.param_env);\n "}, {"sha": "2c45dcfbe2665c077c70617c29ed0e290170e02a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -528,6 +528,9 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n         hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n+    // mir_built ensures that body has a computed cache, so we don't (and can't) attempt to\n+    // recompute it here.\n+    let body = body.unwrap_read_only();\n     checker.visit_body(body);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);"}, {"sha": "d9dd7c9d847760f634b6209895d6452302b0b864", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -16,7 +16,7 @@\n //! [`FakeRead`]: rustc::mir::StatementKind::FakeRead\n //! [`Nop`]: rustc::mir::StatementKind::Nop\n \n-use rustc::mir::{BorrowKind, Rvalue, Location, Body};\n+use rustc::mir::{BodyCache, BorrowKind, Rvalue, Location};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -29,7 +29,9 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n     }"}, {"sha": "a99ca71d167e19d00259aea23d865f5438ed0975", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -7,9 +7,10 @@ use std::cell::Cell;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n-    StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n-    BinOp, SourceScope, SourceScopeData, LocalDecl, BasicBlock, RETURN_PLACE,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, BodyCache, Operand, Local, UnOp,\n+    Rvalue, StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate,\n+    SourceInfo, BinOp, SourceScope, SourceScopeData, LocalDecl, BasicBlock, ReadOnlyBodyCache,\n+    read_only, RETURN_PLACE\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -41,7 +42,9 @@ const MAX_ALLOC_LIMIT: u64 = 1024;\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -92,7 +95,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(\n-            body,\n+            read_only!(body),\n             dummy_body,\n             tcx,\n             source\n@@ -293,7 +296,7 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body: &Body<'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n@@ -687,7 +690,7 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(body: &Body<'_>) -> IndexVec<Local, bool> {\n+    fn check(body: ReadOnlyBodyCache<'_, '_>) -> IndexVec<Local, bool> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(true, &body.local_decls),\n             found_assignment: IndexVec::from_elem(false, &body.local_decls),"}, {"sha": "5e4caf2f36d2d6de17dc99d38d2ebef4b8ea8eb3", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -19,7 +19,10 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{Constant, Local, LocalKind, Location, Place, Body, Operand, Rvalue, StatementKind};\n+use rustc::mir::{\n+    Constant, Local, LocalKind, Location, Place, Body, BodyCache, Operand, Rvalue,\n+    StatementKind, read_only\n+};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -28,7 +31,9 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n@@ -37,10 +42,10 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n \n         let mut def_use_analysis = DefUseAnalysis::new(body);\n         loop {\n-            def_use_analysis.analyze(body);\n+            def_use_analysis.analyze(read_only!(body));\n \n             if eliminate_self_assignments(body, &def_use_analysis) {\n-                def_use_analysis.analyze(body);\n+                def_use_analysis.analyze(read_only!(body));\n             }\n \n             let mut changed = false;\n@@ -97,7 +102,10 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                                     let maybe_action = match operand {\n                                         Operand::Copy(ref src_place) |\n                                         Operand::Move(ref src_place) => {\n-                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                            Action::local_copy(\n+                                                &body,\n+                                                &def_use_analysis,\n+                                                src_place)\n                                         }\n                                         Operand::Constant(ref src_constant) => {\n                                             Action::constant(src_constant)\n@@ -126,8 +134,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                 }\n \n-                changed =\n-                    action.perform(body, &def_use_analysis, dest_local, location, tcx) || changed;\n+                changed = action.perform(body, &def_use_analysis, dest_local, location, tcx)\n+                    || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n                 break\n@@ -242,7 +250,7 @@ impl<'tcx> Action<'tcx> {\n     }\n \n     fn perform(self,\n-               body: &mut Body<'tcx>,\n+               body: &mut BodyCache<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n                location: Location,\n@@ -270,7 +278,8 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n+                def_use_analysis\n+                    .replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");"}, {"sha": "933936e7efff73d64f67f415d24b221b23765dfd", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -6,7 +6,9 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "13b3bb6da4ef99b588748afda3de6a0aa1b0482a", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use rustc::mir::Body;\n+use rustc::mir::{Body, BodyCache};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -18,8 +18,9 @@ impl<'tcx> MirPass<'tcx> for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n-    }\n+    fn run_pass(\n+        &self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut BodyCache<'tcx>\n+    ) {}\n }\n \n pub struct Disambiguator {"}, {"sha": "42daba93bd293059a98fc0d9117fa8642949b631", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -21,7 +21,7 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();"}, {"sha": "882e67432a5ed4b00c712a3110e25385decf6f78", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -62,7 +62,7 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n pub struct EraseRegions;\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "e55737e8859eff230f70e8c8a485fe710214bace", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -368,7 +368,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                 VariantIdx::new(RETURNED) // state for returned\n             };\n             data.statements.push(self.set_discr(state, source_info));\n-            data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n+            data.terminator_mut().kind = TerminatorKind::Return;\n         }\n \n         self.super_basic_block_data(block, data);\n@@ -378,7 +378,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n fn make_generator_state_argument_indirect<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) {\n     let gen_ty = body.local_decls.raw[1].ty;\n \n@@ -401,7 +401,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n     DerefArgVisitor { tcx }.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -418,7 +418,7 @@ fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n     let source_info = source_info(body);\n@@ -481,20 +481,21 @@ struct LivenessInfo {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> LivenessInfo {\n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n+    let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let storage_live_analysis = MaybeStorageLive::new(body);\n+    let storage_live_analysis = MaybeStorageLive::new(body_ref);\n     let storage_live_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, storage_live_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, storage_live_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body);\n+    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body_ref);\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n@@ -503,19 +504,20 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n+    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body_ref);\n     let borrowed_locals_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body);\n+    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body_ref);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n     let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n     let requires_storage_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, requires_storage_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut requires_storage_cursor = DataflowResultsCursor::new(&requires_storage_results, body);\n+    let mut requires_storage_cursor\n+        = DataflowResultsCursor::new(&requires_storage_results, body_ref);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -526,7 +528,7 @@ fn locals_live_across_suspend_points(\n         tcx,\n         \"generator_liveness\",\n         source,\n-        body,\n+        body_ref,\n         &liveness,\n     );\n \n@@ -593,7 +595,7 @@ fn locals_live_across_suspend_points(\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n-        body,\n+        body_ref,\n         &live_locals,\n         &ignored,\n         requires_storage_results);\n@@ -749,7 +751,7 @@ fn compute_layout<'tcx>(\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n     movable: bool,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n@@ -758,7 +760,7 @@ fn compute_layout<'tcx>(\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n-    } = locals_live_across_suspend_points(tcx, body, source, movable);\n+    } = locals_live_across_suspend_points(tcx, read_only!(body), source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -828,7 +830,7 @@ fn compute_layout<'tcx>(\n }\n \n fn insert_switch<'tcx>(\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     cases: Vec<(usize, BasicBlock)>,\n     transform: &TransformVisitor<'tcx>,\n     default: TerminatorKind<'tcx>,\n@@ -859,7 +861,9 @@ fn insert_switch<'tcx>(\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(\n+    tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut BodyCache<'tcx>\n+) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -872,7 +876,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n     let gen = self_arg();\n \n     let mut elaborator = DropShimElaborator {\n-        body: body,\n+        body,\n         patch: MirPatch::new(body),\n         tcx,\n         param_env\n@@ -924,9 +928,9 @@ fn create_generator_drop_shim<'tcx>(\n     def_id: DefId,\n     source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n-    body: &Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     drop_clean: BasicBlock,\n-) -> Body<'tcx> {\n+) -> BodyCache<'tcx> {\n     let mut body = body.clone();\n \n     let source_info = source_info(&body);\n@@ -992,7 +996,9 @@ fn create_generator_drop_shim<'tcx>(\n     body\n }\n \n-fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+fn insert_term_block<'tcx>(\n+    body: &mut BodyCache<'tcx>, kind: TerminatorKind<'tcx>\n+) -> BasicBlock {\n     let term_block = BasicBlock::new(body.basic_blocks().len());\n     let source_info = source_info(body);\n     body.basic_blocks_mut().push(BasicBlockData {\n@@ -1008,7 +1014,7 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n \n fn insert_panic_block<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n     let assert_block = BasicBlock::new(body.basic_blocks().len());\n@@ -1042,7 +1048,7 @@ fn create_generator_resume_function<'tcx>(\n     transform: TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) {\n     // Poison the generator when it unwinds\n     for block in body.basic_blocks_mut() {\n@@ -1095,7 +1101,7 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n     }\n }\n \n-fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n+fn insert_clean_drop(body: &mut BodyCache<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n@@ -1119,7 +1125,7 @@ fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n }\n \n fn create_cases<'tcx, F>(\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n     target: F,\n ) -> Vec<(usize, BasicBlock)>\n@@ -1163,7 +1169,9 @@ where\n }\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {\n@@ -1252,12 +1260,12 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,\n-            &transform,\n-            def_id,\n-            source,\n-            gen_ty,\n-            &body,\n-            drop_clean);\n+                                                   &transform,\n+                                                   def_id,\n+                                                   source,\n+                                                   gen_ty,\n+                                                   body,\n+                                                   drop_clean);\n \n         body.generator_drop = Some(box drop_shim);\n "}, {"sha": "79cb7fb0b7692b3fabc63158834a8cee39e5280a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -38,7 +38,9 @@ struct CallSite<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for Inline {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n@@ -51,7 +53,7 @@ struct Inliner<'tcx> {\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n+    fn run_pass(&self, caller_body: &mut BodyCache<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -75,9 +77,9 @@ impl Inliner<'tcx> {\n         {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n-                                                                    bb_data,\n-                                                                    caller_body,\n-                                                                    param_env) {\n+                                                                     bb_data,\n+                                                                     caller_body,\n+                                                                     param_env) {\n                     callsites.push_back(callsite);\n                 }\n             }\n@@ -136,7 +138,8 @@ impl Inliner<'tcx> {\n                 debug!(\"attempting to inline callsite {:?} - success\", callsite);\n \n                 // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n+                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start)\n+                {\n                     if let Some(new_callsite) = self.get_valid_function_call(bb,\n                                                                              bb_data,\n                                                                              caller_body,\n@@ -377,8 +380,8 @@ impl Inliner<'tcx> {\n \n     fn inline_call(&self,\n                    callsite: CallSite<'tcx>,\n-                   caller_body: &mut Body<'tcx>,\n-                   mut callee_body: Body<'tcx>) -> bool {\n+                   caller_body: &mut BodyCache<'tcx>,\n+                   mut callee_body: BodyCache<'tcx>) -> bool {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n@@ -445,7 +448,7 @@ impl Inliner<'tcx> {\n                         BorrowKind::Mut { allow_two_phase_borrow: false },\n                         destination.0);\n \n-                    let ty = dest.ty(caller_body, self.tcx);\n+                    let ty = dest.ty(&**caller_body, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -514,7 +517,7 @@ impl Inliner<'tcx> {\n         &self,\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n-        caller_body: &mut Body<'tcx>,\n+        caller_body: &mut BodyCache<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -543,12 +546,14 @@ impl Inliner<'tcx> {\n         // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n         if tcx.is_closure(callsite.callee) {\n             let mut args = args.into_iter();\n-            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n-            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n+            let self_\n+                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n+            let tuple\n+                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(&**caller_body, tcx).ty.kind {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n@@ -585,7 +590,7 @@ impl Inliner<'tcx> {\n         &self,\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n-        caller_body: &mut Body<'tcx>,\n+        caller_body: &mut BodyCache<'tcx>,\n     ) -> Local {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n@@ -603,7 +608,7 @@ impl Inliner<'tcx> {\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n-        let ty = arg.ty(caller_body, self.tcx);\n+        let ty = arg.ty(&**caller_body, self.tcx);\n \n         let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let arg_tmp = caller_body.local_decls.push(arg_tmp);"}, {"sha": "bd237b58132989287281eeed4b70640a6d53dc50", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,7 +1,8 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{\n-    Constant, Location, Place, PlaceBase, PlaceRef, Body, Operand, ProjectionElem, Rvalue, Local\n+    Constant, Location, Place, PlaceBase, PlaceRef, Body, BodyCache, Operand, ProjectionElem,\n+    Rvalue, Local, read_only\n };\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n@@ -13,7 +14,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -23,8 +24,9 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n+            let read_only_cache = read_only!(body);\n             let mut optimization_finder = OptimizationFinder::new(body, tcx);\n-            optimization_finder.visit_body(body);\n+            optimization_finder.visit_body(read_only_cache);\n             optimization_finder.optimizations\n         };\n "}, {"sha": "df4cb7615336af3c6d810cffaf201ea38fd8b05b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,7 +1,7 @@\n use crate::{build, shim};\n use rustc_index::vec::IndexVec;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::{Body, MirPhase, Promoted, ConstQualifs};\n+use rustc::mir::{BodyCache, MirPhase, Promoted, ConstQualifs};\n use rustc::ty::{TyCtxt, InstanceDef, TypeFoldable};\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n@@ -97,7 +97,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -144,12 +144,12 @@ pub trait MirPass<'tcx> {\n         default_name::<Self>()\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     instance: InstanceDef<'tcx>,\n     promoted: Option<Promoted>,\n     mir_phase: MirPhase,\n@@ -205,7 +205,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     }\n \n     let item = check_consts::Item {\n-        body,\n+        body: body.unwrap_read_only(),\n         tcx,\n         def_id,\n         const_kind,\n@@ -220,7 +220,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     validator.qualifs_in_return_place().into()\n }\n \n-fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -231,13 +231,14 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n+    body.ensure_predecessors();\n     tcx.alloc_steal_mir(body)\n }\n \n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n+) -> (&'tcx Steal<BodyCache<'tcx>>, &'tcx Steal<IndexVec<Promoted, BodyCache<'tcx>>>) {\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n     let _ = tcx.mir_const_qualif(def_id);\n@@ -249,13 +250,14 @@ fn mir_validated(\n         &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n+\n     let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n fn run_optimization_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     def_id: DefId,\n     promoted: Option<Promoted>,\n ) {\n@@ -317,7 +319,7 @@ fn run_optimization_passes<'tcx>(\n     ]);\n }\n \n-fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyCache<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const\n@@ -333,10 +335,11 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     let (body, _) = tcx.mir_validated(def_id);\n     let mut body = body.steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n+    body.ensure_predecessors();\n     tcx.arena.alloc(body)\n }\n \n-fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n+fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyCache<'_>> {\n     if tcx.is_constructor(def_id) {\n         return tcx.intern_promoted(IndexVec::new());\n     }\n@@ -347,6 +350,7 @@ fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promot\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n         run_optimization_passes(tcx, &mut body, def_id, Some(p));\n+        body.ensure_predecessors();\n     }\n \n     tcx.intern_promoted(promoted)"}, {"sha": "5e1d29d47ade9090605ff1a156df719262beb996", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -17,12 +17,12 @@ impl<'tcx> NoLandingPads<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         NoLandingPads::new(tcx).visit_body(body);\n     }"}, {"sha": "c99824bd35647488f45cc363c3f15736fd48728d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -41,11 +41,11 @@ use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn}\n /// newly created `StaticKind::Promoted`.\n #[derive(Default)]\n pub struct PromoteTemps<'tcx> {\n-    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+    pub promoted_fragments: Cell<IndexVec<Promoted, BodyCache<'tcx>>>,\n }\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         //\n         // This does not include MIR that failed const-checking, which we still try to promote.\n@@ -63,7 +63,8 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let mut rpo = traversal::reverse_postorder(body);\n         let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+        let promotable_candidates\n+            = validate_candidates(tcx, read_only!(body), def_id, &temps, &all_candidates);\n \n         let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -346,10 +347,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             while let [proj_base @ .., elem] = place_projection {\n                                 // FIXME(eddyb) this is probably excessive, with\n                                 // the exception of `union` member accesses.\n-                                let ty =\n-                                    Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n-                                        .projection_ty(self.tcx, elem)\n-                                        .ty;\n+                                let ty = Place::ty_from(\n+                                        &place.base,\n+                                        proj_base,\n+                                        &*self.body,\n+                                        self.tcx\n+                                    )\n+                                    .projection_ty(self.tcx, elem)\n+                                    .ty;\n                                 if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n                                     has_mut_interior = false;\n                                     break;\n@@ -368,7 +373,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(self.body, self.tcx).ty;\n+                            let ty = place.ty(&*self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -517,7 +522,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n+                                Place::ty_from(place.base, proj_base, &*self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -566,7 +571,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n+                let operand_ty = operand.ty(&*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -580,7 +585,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -615,7 +620,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(self.body, self.tcx).ty;\n+                    let ty = place.ty(&*self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -642,7 +647,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty =\n-                        Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                        Place::ty_from(&place.base, proj_base, &*self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef {\n                             base: &place.base,\n@@ -668,7 +673,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, self.body, self.tcx)\n+                        let ty = Place::ty_from(place.base, proj_base, &*self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -701,7 +706,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(self.body, self.tcx);\n+        let fn_ty = callee.ty(&*self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n@@ -737,7 +742,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     def_id: DefId,\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n@@ -770,8 +775,8 @@ pub fn validate_candidates(\n \n struct Promoter<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    source: &'a mut Body<'tcx>,\n-    promoted: Body<'tcx>,\n+    source: &'a mut BodyCache<'tcx>,\n+    promoted: BodyCache<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n@@ -919,7 +924,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         def_id: DefId,\n         candidate: Candidate,\n         next_promoted_id: usize,\n-    ) -> Option<Body<'tcx>> {\n+    ) -> Option<BodyCache<'tcx>> {\n         let mut operand = {\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n@@ -1040,11 +1045,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n \n pub fn promote_candidates<'tcx>(\n     def_id: DefId,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-) -> IndexVec<Promoted, Body<'tcx>> {\n+) -> IndexVec<Promoted, BodyCache<'tcx>> {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n@@ -1076,7 +1081,7 @@ pub fn promote_candidates<'tcx>(\n         ).collect();\n \n         let promoter = Promoter {\n-            promoted: Body::new(\n+            promoted: BodyCache::new(Body::new(\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?\n@@ -1088,7 +1093,7 @@ pub fn promote_candidates<'tcx>(\n                 body.span,\n                 vec![],\n                 body.generator_kind,\n-            ),\n+            )),\n             tcx,\n             source: body,\n             temps: &mut temps,\n@@ -1145,11 +1150,11 @@ pub fn promote_candidates<'tcx>(\n crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n-    body: &Body<'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> bool {\n-    let mut rpo = traversal::reverse_postorder(body);\n-    let (temps, _) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+    let mut rpo = traversal::reverse_postorder(&body);\n+    let (temps, _) = collect_temps_and_candidates(tcx, &body, &mut rpo);\n     let validator = Validator {\n         item: Item::new(tcx, mir_def_id, body),\n         temps: &temps,"}, {"sha": "c636aba9fc607fd4b6bf405deec4065341e6cf2e", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -9,7 +9,7 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n@@ -19,7 +19,7 @@ pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>)\n }\n \n impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }\n@@ -84,7 +84,7 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n+    fn remove_nop_landing_pads(&self, body: &mut BodyCache<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n             let patch = MirPatch::new(body);"}, {"sha": "794ced1cb0ef54e2debf353c1f5f8dabdb92890d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -5,7 +5,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Body, Location, Local};\n+use rustc::mir::{self, Body, BodyCache, Location, Local};\n use rustc_index::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n@@ -26,7 +26,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -64,10 +64,20 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(\n+                tcx,\n+                body,\n+                def_id,\n+                &attributes,\n+                &flow_def_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n+            sanity_check_via_rustc_peek(\n+                tcx,\n+                body,\n+                def_id,\n+                &attributes,\n+                &flow_indirectly_mut);\n         }\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");"}, {"sha": "900752d3ce06c2068bbcb526c140644e4c72afdd", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -43,7 +43,7 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(body: &mut Body<'_>) {\n+pub fn simplify_cfg(body: &mut BodyCache<'_>) {\n     CfgSimplifier::new(body).simplify();\n     remove_dead_blocks(body);\n \n@@ -56,7 +56,9 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -68,7 +70,7 @@ pub struct CfgSimplifier<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(body: &'a mut Body<'tcx>) -> Self {\n+    pub fn new(body: &'a mut BodyCache<'tcx>) -> Self {\n         let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n@@ -124,8 +126,9 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n                     changed |= inner_changed;\n                 }\n \n-                self.basic_blocks[bb].statements.extend(new_stmts);\n-                self.basic_blocks[bb].terminator = Some(terminator);\n+                let data = &mut self.basic_blocks[bb];\n+                data.statements.extend(new_stmts);\n+                data.terminator = Some(terminator);\n \n                 changed |= inner_changed;\n             }\n@@ -259,7 +262,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(body: &mut Body<'_>) {\n+pub fn remove_dead_blocks(body: &mut BodyCache<'_>) {\n     let mut seen = BitSet::new_empty(body.basic_blocks().len());\n     for (bb, _) in traversal::preorder(body) {\n         seen.insert(bb.index());\n@@ -273,8 +276,8 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n     for alive_index in seen.iter() {\n         replacements[alive_index] = BasicBlock::new(used_blocks);\n         if alive_index != used_blocks {\n-            // Swap the next alive block data with the current available slot. Since alive_index is\n-            // non-decreasing this is a valid operation.\n+            // Swap the next alive block data with the current available slot. Since\n+            // alive_index is non-decreasing this is a valid operation.\n             basic_blocks.raw.swap(alive_index, used_blocks);\n         }\n         used_blocks += 1;\n@@ -292,14 +295,17 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n+    ) {\n         trace!(\"running SimplifyLocals on {:?}\", source);\n         let locals = {\n+            let read_only_cache = read_only!(body);\n             let mut marker = DeclMarker {\n                 locals: BitSet::new_empty(body.local_decls.len()),\n                 body,\n             };\n-            marker.visit_body(body);\n+            marker.visit_body(read_only_cache);\n             // Return pointer and arguments are always live\n             marker.locals.insert(RETURN_PLACE);\n             for arg in body.args_iter() {"}, {"sha": "c8d0f37f9a509cbe105df7aea37007d09bb2afbf", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -19,7 +19,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let param_env = tcx.param_env(src.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();"}, {"sha": "2235de9a1533a16ecb1b91e5b017ab0eb6b73235", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -33,7 +33,7 @@ use itertools::Itertools as _;\n pub struct SimplifyArmIdentity;\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for bb in basic_blocks {\n             // Need 3 statements:\n@@ -151,7 +151,7 @@ fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarFie\n pub struct SimplifyBranchSame;\n \n impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let mut did_remove_blocks = false;\n         let bbs = body.basic_blocks_mut();\n         for bb_idx in bbs.indices() {"}, {"sha": "3fc76ef6b00e000a548ccbaf80329951fb6551ce", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -37,12 +37,14 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {\n-            let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx, param_env};\n-            visitor.visit_body(body);\n+            let read_only_cache = read_only!(body);\n+            let mut visitor\n+                = UniformArrayMoveOutVisitor{ body, patch: &mut patch, tcx, param_env};\n+            visitor.visit_body(read_only_cache);\n         }\n         patch.apply(body);\n     }\n@@ -184,15 +186,16 @@ pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {\n+            let read_only_cache = read_only!(body);\n             let mut visitor = RestoreDataCollector {\n                 locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n                 candidates: vec![],\n             };\n-            visitor.visit_body(body);\n+            visitor.visit_body(read_only_cache);\n \n             for candidate in &visitor.candidates {\n                 let statement = &body[candidate.block].statements[candidate.statement_index];\n@@ -217,8 +220,12 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty =\n-                                Place::ty_from(src_place.base, src_place.projection, body, tcx).ty;\n+                            let src_ty = Place::ty_from(\n+                                src_place.base,\n+                                src_place.projection,\n+                                &**body,\n+                                tcx\n+                            ).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.kind {\n                                 size_o.try_eval_usize(tcx, param_env)\n                             } else {"}, {"sha": "de070d75ad8e2a88d9f1e4260728e3890c7051b4", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -2,7 +2,8 @@\n \n use crate::transform::{MirPass, MirSource};\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n+    BasicBlock, BasicBlockData, Body, BodyCache, Local, Operand, Rvalue, StatementKind,\n+    TerminatorKind,\n };\n use rustc::ty::layout::{Abi, TyLayout, Variants};\n use rustc::ty::{Ty, TyCtxt};\n@@ -65,7 +66,7 @@ fn variant_discriminants<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         if source.promoted.is_some() {\n             return;\n         }"}, {"sha": "f94bea2002461d70422903bc00d436c4bf234426", "filename": "src/librustc_mir/util/collect_writes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::{Local, Location};\n-use rustc::mir::Body;\n+use rustc::mir::ReadOnlyBodyCache;\n use rustc::mir::visit::PlaceContext;\n use rustc::mir::visit::Visitor;\n \n@@ -9,10 +9,10 @@ crate trait FindAssignments {\n     fn find_assignments(&self, local: Local) -> Vec<Location>;\n }\n \n-impl<'tcx> FindAssignments for Body<'tcx>{\n+impl<'a, 'tcx> FindAssignments for ReadOnlyBodyCache<'a, 'tcx>{\n     fn find_assignments(&self, local: Local) -> Vec<Location>{\n             let mut visitor = FindLocalAssignmentVisitor{ needle: local, locations: vec![]};\n-            visitor.visit_body(self);\n+            visitor.visit_body(*self);\n             visitor.locations\n     }\n }"}, {"sha": "1907e9bdc9746a3d27657abfea5ecd22b99ea4ee", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -1,6 +1,6 @@\n //! Def-use analysis.\n \n-use rustc::mir::{Body, Local, Location, PlaceElem, VarDebugInfo};\n+use rustc::mir::{Body, BodyCache, Local, Location, PlaceElem, ReadOnlyBodyCache, VarDebugInfo};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n use rustc_index::vec::IndexVec;\n@@ -30,7 +30,7 @@ impl DefUseAnalysis {\n         }\n     }\n \n-    pub fn analyze(&mut self, body: &Body<'_>) {\n+    pub fn analyze(&mut self, body: ReadOnlyBodyCache<'_, '_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n@@ -55,11 +55,11 @@ impl DefUseAnalysis {\n     fn mutate_defs_and_uses(\n         &self,\n         local: Local,\n-        body: &mut Body<'tcx>,\n+        body: &mut BodyCache<'tcx>,\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {\n-        let mut visitor = MutateUseVisitor::new(local, new_local, body, tcx);\n+        let mut visitor = MutateUseVisitor::new(local, new_local, tcx);\n         let info = &self.info[local];\n         for place_use in &info.defs_and_uses {\n             visitor.visit_location(body, place_use.location)\n@@ -73,7 +73,7 @@ impl DefUseAnalysis {\n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          body: &mut Body<'tcx>,\n+                                          body: &mut BodyCache<'tcx>,\n                                           new_local: Local,\n                                           tcx: TyCtxt<'tcx>) {\n         self.mutate_defs_and_uses(local, body, new_local, tcx)\n@@ -156,7 +156,6 @@ impl MutateUseVisitor<'tcx> {\n     fn new(\n         query: Local,\n         new_local: Local,\n-        _: &Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n     ) -> MutateUseVisitor<'tcx> {\n         MutateUseVisitor { query, new_local, tcx }"}, {"sha": "334975373e5f35f65d08ef7b9775b0e4a223f13f", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -57,7 +57,7 @@ pub struct LivenessResult {\n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n pub fn liveness_of_locals(\n-    body: &Body<'_>,\n+    body: ReadOnlyBodyCache<'_, '_>,\n ) -> LivenessResult {\n     let num_live_vars = body.local_decls.len();\n \n@@ -83,8 +83,9 @@ pub fn liveness_of_locals(\n     // FIXME(ecstaticmorse): Reverse post-order on the reverse CFG may generate a better iteration\n     // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n     // any benefits. Benchmark this and find out.\n-    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks().len());\n-    for (bb, _) in traversal::postorder(body) {\n+    let mut dirty_queue: WorkQueue<BasicBlock>\n+        = WorkQueue::with_none(body.basic_blocks().len());\n+    for (bb, _) in traversal::postorder(&body) {\n         dirty_queue.insert(bb);\n     }\n "}, {"sha": "47bb0b699c048537e8fd4fb6b578c916202c256d", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdc0011561c6365c596dfd8fa1ef388162bc89c7/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=fdc0011561c6365c596dfd8fa1ef388162bc89c7", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, body: &mut Body<'tcx>) {\n+    pub fn apply(self, body: &mut BodyCache<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n             body.make_statement_nop(loc);"}]}