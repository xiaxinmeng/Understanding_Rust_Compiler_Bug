{"sha": "bebbbb61a7037147ead32e322258b56bcd349245", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYmJiYjYxYTcwMzcxNDdlYWQzMmUzMjIyNThiNTZiY2QzNDkyNDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T15:52:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T15:52:22Z"}, "message": "Update expand macro tests", "tree": {"sha": "01b1785d385bb79bf0bade969a61186be2217bb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01b1785d385bb79bf0bade969a61186be2217bb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bebbbb61a7037147ead32e322258b56bcd349245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bebbbb61a7037147ead32e322258b56bcd349245", "html_url": "https://github.com/rust-lang/rust/commit/bebbbb61a7037147ead32e322258b56bcd349245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bebbbb61a7037147ead32e322258b56bcd349245/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14bf5bb7ee01e89d31d05e1ef08ccde85809fb7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14bf5bb7ee01e89d31d05e1ef08ccde85809fb7a", "html_url": "https://github.com/rust-lang/rust/commit/14bf5bb7ee01e89d31d05e1ef08ccde85809fb7a"}], "stats": {"total": 241, "additions": 115, "deletions": 126}, "files": [{"sha": "043515f541f76dad4e6b68ede29b4a9a5daa3a37", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 115, "deletions": 126, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/bebbbb61a7037147ead32e322258b56bcd349245/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bebbbb61a7037147ead32e322258b56bcd349245/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=bebbbb61a7037147ead32e322258b56bcd349245", "patch": "@@ -2,7 +2,9 @@ use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_node_at_offset, SyntaxRewriter},\n-    ast, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T,\n+    ast, AstNode, NodeOrToken, SyntaxKind,\n+    SyntaxKind::*,\n+    SyntaxNode, WalkEvent, T,\n };\n \n use crate::FilePosition;\n@@ -65,8 +67,6 @@ fn expand_macro_recur(\n // FIXME: It would also be cool to share logic here and in the mbe tests,\n // which are pretty unreadable at the moment.\n fn insert_whitespaces(syn: SyntaxNode) -> String {\n-    use SyntaxKind::*;\n-\n     let mut res = String::new();\n     let mut token_iter = syn\n         .preorder_with_tokens()\n@@ -120,175 +120,164 @@ fn insert_whitespaces(syn: SyntaxNode) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_snapshot;\n+    use expect::{expect, Expect};\n \n     use crate::mock_analysis::analysis_and_position;\n \n-    use super::*;\n-\n-    fn check_expand_macro(fixture: &str) -> ExpandedMacro {\n-        let (analysis, pos) = analysis_and_position(fixture);\n-        analysis.expand_macro(pos).unwrap().unwrap()\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let (analysis, pos) = analysis_and_position(ra_fixture);\n+        let expansion = analysis.expand_macro(pos).unwrap().unwrap();\n+        let actual = format!(\"{}\\n{}\", expansion.name, expansion.expansion);\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n     fn macro_expand_recursive_expansion() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        macro_rules! bar {\n-            () => { fn  b() {} }\n-        }\n-        macro_rules! foo {\n-            () => { bar!(); }\n-        }\n-        macro_rules! baz {\n-            () => { foo!(); }\n-        }\n-        f<|>oo!();\n-        \"#,\n+macro_rules! bar {\n+    () => { fn  b() {} }\n+}\n+macro_rules! foo {\n+    () => { bar!(); }\n+}\n+macro_rules! baz {\n+    () => { foo!(); }\n+}\n+f<|>oo!();\n+\"#,\n+            expect![[r#\"\n+                foo\n+                fn b(){}\n+            \"#]],\n         );\n-\n-        assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"\n-fn b(){}\n-\"###);\n     }\n \n     #[test]\n     fn macro_expand_multiple_lines() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        macro_rules! foo {\n-            () => {\n-                fn some_thing() -> u32 {\n-                    let a = 0;\n-                    a + 10\n-                }\n-            }\n+macro_rules! foo {\n+    () => {\n+        fn some_thing() -> u32 {\n+            let a = 0;\n+            a + 10\n         }\n-        f<|>oo!();\n+    }\n+}\n+f<|>oo!();\n         \"#,\n+            expect![[r#\"\n+            foo\n+            fn some_thing() -> u32 {\n+              let a = 0;\n+              a+10\n+            }\"#]],\n         );\n-\n-        assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"\n-fn some_thing() -> u32 {\n-  let a = 0;\n-  a+10\n-}\n-\"###);\n     }\n \n     #[test]\n     fn macro_expand_match_ast() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        macro_rules! match_ast {\n-            (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+macro_rules! match_ast {\n+    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+    (match ($node:expr) {\n+        $( ast::$ast:ident($it:ident) => $res:block, )*\n+        _ => $catch_all:expr $(,)?\n+    }) => {{\n+        $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n+        { $catch_all }\n+    }};\n+}\n \n-            (match ($node:expr) {\n-                $( ast::$ast:ident($it:ident) => $res:block, )*\n-                _ => $catch_all:expr $(,)?\n-            }) => {{\n-                $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n-                { $catch_all }\n-            }};\n+fn main() {\n+    mat<|>ch_ast! {\n+        match container {\n+            ast::TraitDef(it) => {},\n+            ast::ImplDef(it) => {},\n+            _ => { continue },\n         }\n-\n-        fn main() {\n-            mat<|>ch_ast! {\n-                match container {\n-                    ast::TraitDef(it) => {},\n-                    ast::ImplDef(it) => {},\n-                    _ => { continue },\n-                }\n-            }\n-        }\n-        \"#,\n-        );\n-\n-        assert_eq!(res.name, \"match_ast\");\n-        assert_snapshot!(res.expansion, @r###\"\n-{\n-  if let Some(it) = ast::TraitDef::cast(container.clone()){}\n-  else if let Some(it) = ast::ImplDef::cast(container.clone()){}\n-  else {\n-    {\n-      continue\n     }\n-  }\n }\n-\"###);\n+\"#,\n+            expect![[r#\"\n+       match_ast\n+       {\n+         if let Some(it) = ast::TraitDef::cast(container.clone()){}\n+         else if let Some(it) = ast::ImplDef::cast(container.clone()){}\n+         else {\n+           {\n+             continue\n+           }\n+         }\n+       }\"#]],\n+        );\n     }\n \n     #[test]\n     fn macro_expand_match_ast_inside_let_statement() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        macro_rules! match_ast {\n-            (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n-            (match ($node:expr) {}) => {{}};\n-        }\n+macro_rules! match_ast {\n+    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+    (match ($node:expr) {}) => {{}};\n+}\n \n-        fn main() {\n-            let p = f(|it| {\n-                let res = mat<|>ch_ast! { match c {}};\n-                Some(res)\n-            })?;\n-        }\n-        \"#,\n+fn main() {\n+    let p = f(|it| {\n+        let res = mat<|>ch_ast! { match c {}};\n+        Some(res)\n+    })?;\n+}\n+\"#,\n+            expect![[r#\"\n+                match_ast\n+                {}\n+            \"#]],\n         );\n-\n-        assert_eq!(res.name, \"match_ast\");\n-        assert_snapshot!(res.expansion, @r###\"{}\"###);\n     }\n \n     #[test]\n     fn macro_expand_inner_macro_fail_to_expand() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        macro_rules! bar {\n-            (BAD) => {};\n-        }\n-        macro_rules! foo {\n-            () => {bar!()};\n-        }\n+macro_rules! bar {\n+    (BAD) => {};\n+}\n+macro_rules! foo {\n+    () => {bar!()};\n+}\n \n-        fn main() {\n-            let res = fo<|>o!();\n-        }\n-        \"#,\n+fn main() {\n+    let res = fo<|>o!();\n+}\n+\"#,\n+            expect![[r#\"\n+                foo\n+            \"#]],\n         );\n-\n-        assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"\"###);\n     }\n \n     #[test]\n     fn macro_expand_with_dollar_crate() {\n-        let res = check_expand_macro(\n+        check(\n             r#\"\n-        //- /lib.rs\n-        #[macro_export]\n-        macro_rules! bar {\n-            () => {0};\n-        }\n-        macro_rules! foo {\n-            () => {$crate::bar!()};\n-        }\n+#[macro_export]\n+macro_rules! bar {\n+    () => {0};\n+}\n+macro_rules! foo {\n+    () => {$crate::bar!()};\n+}\n \n-        fn main() {\n-            let res = fo<|>o!();\n-        }\n-        \"#,\n+fn main() {\n+    let res = fo<|>o!();\n+}\n+\"#,\n+            expect![[r#\"\n+                foo\n+                0 \"#]],\n         );\n-\n-        assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"0\"###);\n     }\n }"}]}