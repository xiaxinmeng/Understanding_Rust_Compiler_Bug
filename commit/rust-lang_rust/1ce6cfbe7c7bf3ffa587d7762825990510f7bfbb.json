{"sha": "1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZTZjZmJlN2M3YmYzZmZhNTg3ZDc3NjI4MjU5OTA1MTBmN2JmYmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-07T14:29:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-07T14:32:11Z"}, "message": "use a precedence table for operator parsing", "tree": {"sha": "e864a14ba9c63b7fc6f134fd070d5bc08fd9a0d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e864a14ba9c63b7fc6f134fd070d5bc08fd9a0d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb", "html_url": "https://github.com/rust-lang/rust/commit/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f017a9e71fde98dbfdb2edb9fbc2af8781611664", "url": "https://api.github.com/repos/rust-lang/rust/commits/f017a9e71fde98dbfdb2edb9fbc2af8781611664", "html_url": "https://github.com/rust-lang/rust/commit/f017a9e71fde98dbfdb2edb9fbc2af8781611664"}], "stats": {"total": 196, "additions": 65, "deletions": 131}, "files": [{"sha": "5b677e9bef2b83b2d770e6204761576b3996fed4", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 65, "deletions": 131, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=1ce6cfbe7c7bf3ffa587d7762825990510f7bfbb", "patch": "@@ -35,6 +35,7 @@ state type parser =\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n           fn next_def_id() -> ast.def_id;\n+          fn get_prec_table() -> vec[op_spec];\n     };\n \n impure fn new_parser(session.session sess,\n@@ -50,7 +51,8 @@ impure fn new_parser(session.session sess,\n                            mutable ast.def_num def,\n                            mutable restriction res,\n                            ast.crate_num crate,\n-                           lexer.reader rdr)\n+                           lexer.reader rdr,\n+                           vec[op_spec] precs)\n         {\n             fn peek() -> token.token {\n                 ret tok;\n@@ -100,6 +102,9 @@ impure fn new_parser(session.session sess,\n                 ret env;\n             }\n \n+            fn get_prec_table() -> vec[op_spec] {\n+                ret precs;\n+            }\n         }\n     auto ftype = SOURCE_FILE;\n     if (_str.ends_with(path, \".rc\")) {\n@@ -109,7 +114,8 @@ impure fn new_parser(session.session sess,\n     auto rdr = lexer.new_reader(srdr, path);\n     auto npos = rdr.get_curr_pos();\n     ret stdio_parser(sess, env, ftype, lexer.next_token(rdr),\n-                     npos, npos, 0, UNRESTRICTED, crate, rdr);\n+                     npos, npos, 0, UNRESTRICTED, crate, rdr,\n+                     prec_table());\n }\n \n impure fn unexpected(parser p, token.token t) {\n@@ -975,144 +981,72 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ex);\n }\n \n-impure fn parse_binops(parser p,\n-                   (impure fn(parser) -> @ast.expr) sub,\n-                   vec[tup(token.binop, ast.binop)] ops)\n+type op_spec = rec(token.token tok, ast.binop op, int prec);\n+\n+fn prec_table() -> vec[op_spec] {\n+    ret vec(rec(tok=token.BINOP(token.STAR), op=ast.mul, prec=11),\n+            rec(tok=token.BINOP(token.SLASH), op=ast.div, prec=11),\n+            rec(tok=token.BINOP(token.PERCENT), op=ast.rem, prec=11),\n+            rec(tok=token.BINOP(token.PLUS), op=ast.add, prec=10),\n+            rec(tok=token.BINOP(token.MINUS), op=ast.sub, prec=10),\n+            rec(tok=token.BINOP(token.LSL), op=ast.lsl, prec=9),\n+            rec(tok=token.BINOP(token.LSR), op=ast.lsr, prec=9),\n+            rec(tok=token.BINOP(token.ASR), op=ast.asr, prec=9),\n+            rec(tok=token.BINOP(token.AND), op=ast.bitand, prec=8),\n+            rec(tok=token.BINOP(token.CARET), op=ast.bitxor, prec=6),\n+            rec(tok=token.BINOP(token.OR), op=ast.bitor, prec=6),\n+            // ast.mul is a bogus placeholder here, AS is special\n+            // cased in parse_more_binops\n+            rec(tok=token.AS, op=ast.mul, prec=5),\n+            rec(tok=token.LT, op=ast.lt, prec=4),\n+            rec(tok=token.LE, op=ast.le, prec=4),\n+            rec(tok=token.GE, op=ast.ge, prec=4),\n+            rec(tok=token.GT, op=ast.gt, prec=4),\n+            rec(tok=token.EQEQ, op=ast.eq, prec=3),\n+            rec(tok=token.NE, op=ast.ne, prec=3),\n+            rec(tok=token.ANDAND, op=ast.and, prec=2),\n+            rec(tok=token.OROR, op=ast.or, prec=1));\n+}\n+\n+impure fn parse_binops(parser p) -> @ast.expr {\n+    ret parse_more_binops(p, parse_prefix_expr(p), 0);\n+}\n+\n+impure fn parse_more_binops(parser p, @ast.expr lhs, int min_prec)\n     -> @ast.expr {\n-    auto lo = p.get_span();\n-    auto hi = lo;\n-    auto e = sub(p);\n-    auto more = true;\n-    while (more) {\n-        more = false;\n-        for (tup(token.binop, ast.binop) pair in ops) {\n-            alt (p.peek()) {\n-                case (token.BINOP(?op)) {\n-                    if (pair._0 == op) {\n-                        p.bump();\n-                        auto rhs = sub(p);\n-                        hi = rhs.span;\n-                        auto exp = ast.expr_binary(pair._1, e, rhs,\n-                                                   ast.ann_none);\n-                        e = @spanned(lo, hi, exp);\n-                        more = true;\n-                    }\n+    // Magic nonsense to work around rustboot bug\n+    fn op_eq(token.token a, token.token b) -> bool {\n+        if (a == b) {ret true;}\n+        else {ret false;}\n+    }\n+    auto peeked = p.peek();\n+    for (op_spec cur in p.get_prec_table()) {\n+        if (cur.prec > min_prec && op_eq(cur.tok, peeked)) {\n+            p.bump();\n+            alt (cur.tok) {\n+                case (token.AS) {\n+                    auto rhs = parse_ty(p);\n+                    auto _as = ast.expr_cast(lhs, rhs, ast.ann_none);\n+                    auto span = @spanned(lhs.span, rhs.span, _as);\n+                    ret parse_more_binops(p, span, min_prec);\n+                }\n+                case (_) {\n+                    auto rhs = parse_more_binops(p, parse_prefix_expr(p),\n+                                                 cur.prec);\n+                    auto bin = ast.expr_binary(cur.op, lhs, rhs,\n+                                               ast.ann_none);\n+                    auto span = @spanned(lhs.span, rhs.span, bin);\n+                    ret parse_more_binops(p, span, min_prec);\n                 }\n-                case (_) { /* fall through */ }\n-            }\n-        }\n-    }\n-    ret e;\n-}\n-\n-impure fn parse_binary_exprs(parser p,\n-                            (impure fn(parser) -> @ast.expr) sub,\n-                            vec[tup(token.token, ast.binop)] ops)\n-    -> @ast.expr {\n-    auto lo = p.get_span();\n-    auto hi = lo;\n-    auto e = sub(p);\n-    auto more = true;\n-    while (more) {\n-        more = false;\n-        for (tup(token.token, ast.binop) pair in ops) {\n-            if (pair._0 == p.peek()) {\n-                p.bump();\n-                auto rhs = sub(p);\n-                hi = rhs.span;\n-                auto exp = ast.expr_binary(pair._1, e, rhs, ast.ann_none);\n-                e = @spanned(lo, hi, exp);\n-                more = true;\n-            }\n-        }\n-    }\n-    ret e;\n-}\n-\n-impure fn parse_factor_expr(parser p) -> @ast.expr {\n-    auto sub = parse_prefix_expr;\n-    ret parse_binops(p, sub, vec(tup(token.STAR, ast.mul),\n-                                 tup(token.SLASH, ast.div),\n-                                 tup(token.PERCENT, ast.rem)));\n-}\n-\n-impure fn parse_term_expr(parser p) -> @ast.expr {\n-    auto sub = parse_factor_expr;\n-    ret parse_binops(p, sub, vec(tup(token.PLUS, ast.add),\n-                                 tup(token.MINUS, ast.sub)));\n-}\n-\n-impure fn parse_shift_expr(parser p) -> @ast.expr {\n-    auto sub = parse_term_expr;\n-    ret parse_binops(p, sub, vec(tup(token.LSL, ast.lsl),\n-                                 tup(token.LSR, ast.lsr),\n-                                 tup(token.ASR, ast.asr)));\n-}\n-\n-impure fn parse_bitand_expr(parser p) -> @ast.expr {\n-    auto sub = parse_shift_expr;\n-    ret parse_binops(p, sub, vec(tup(token.AND, ast.bitand)));\n-}\n-\n-impure fn parse_bitxor_expr(parser p) -> @ast.expr {\n-    auto sub = parse_bitand_expr;\n-    ret parse_binops(p, sub, vec(tup(token.CARET, ast.bitxor)));\n-}\n-\n-impure fn parse_bitor_expr(parser p) -> @ast.expr {\n-    auto sub = parse_bitxor_expr;\n-    ret parse_binops(p, sub, vec(tup(token.OR, ast.bitor)));\n-}\n-\n-impure fn parse_cast_expr(parser p) -> @ast.expr {\n-    auto lo = p.get_span();\n-    auto e = parse_bitor_expr(p);\n-    auto hi = e.span;\n-    while (true) {\n-        alt (p.peek()) {\n-            case (token.AS) {\n-                p.bump();\n-                auto t = parse_ty(p);\n-                hi = t.span;\n-                e = @spanned(lo, hi, ast.expr_cast(e, t, ast.ann_none));\n-            }\n-\n-            case (_) {\n-                ret e;\n             }\n         }\n     }\n-    ret e;\n-}\n-\n-impure fn parse_relational_expr(parser p) -> @ast.expr {\n-    auto sub = parse_cast_expr;\n-    ret parse_binary_exprs(p, sub, vec(tup(token.LT, ast.lt),\n-                                       tup(token.LE, ast.le),\n-                                       tup(token.GE, ast.ge),\n-                                       tup(token.GT, ast.gt)));\n-}\n-\n-\n-impure fn parse_equality_expr(parser p) -> @ast.expr {\n-    auto sub = parse_relational_expr;\n-    ret parse_binary_exprs(p, sub, vec(tup(token.EQEQ, ast.eq),\n-                                       tup(token.NE, ast.ne)));\n-}\n-\n-impure fn parse_and_expr(parser p) -> @ast.expr {\n-    auto sub = parse_equality_expr;\n-    ret parse_binary_exprs(p, sub, vec(tup(token.ANDAND, ast.and)));\n-}\n-\n-impure fn parse_or_expr(parser p) -> @ast.expr {\n-    auto sub = parse_and_expr;\n-    ret parse_binary_exprs(p, sub, vec(tup(token.OROR, ast.or)));\n+    ret lhs;\n }\n \n impure fn parse_assign_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n-    auto lhs = parse_or_expr(p);\n+    auto lhs = parse_binops(p);\n     alt (p.peek()) {\n         case (token.EQ) {\n             p.bump();"}]}