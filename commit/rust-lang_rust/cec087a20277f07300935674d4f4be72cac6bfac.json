{"sha": "cec087a20277f07300935674d4f4be72cac6bfac", "node_id": "C_kwDOAAsO6NoAKGNlYzA4N2EyMDI3N2YwNzMwMDkzNTY3NGQ0ZjRiZTcyY2FjNmJmYWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-05T11:57:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-05T11:57:33Z"}, "message": "Rollup merge of #102496 - compiler-errors:into-suggestion, r=davidtwco\n\nSuggest `.into()` when all other coercion suggestions fail\n\nAlso removes some bogus suggestions because we now short-circuit when offering coercion suggestions(instead of, for example, suggesting every one that could possibly apply)\n\nFixes #102415", "tree": {"sha": "51eae936b846f874b05d3124524c25e4ee15840d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51eae936b846f874b05d3124524c25e4ee15840d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cec087a20277f07300935674d4f4be72cac6bfac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPXEtCRBK7hj4Ov3rIwAAbOwIAEoWHpZGqASyFXHdO3+GPWKf\ng9g/8odTfQZ3kH//8N92Q4h5BxRotRh1whd+NV6kmjiQ1V9oUfx6z2r8/kXQi+rF\nAL78i9ErOlazCfBKeFtDRJTZZLX6GKIC9SasXVmkYe8ZXJKcV1vkuGeSbaGbFfkf\nHFa2/OoRk00BuJWlVtnaT0W/Ie6vMpseGxGzrxOlAPAnSAF/yAQWZj9gACuMRanI\nqGvySv/mu6ESqRPATExjLV0HTclYK/ndlhCmZ4LXwKld6/62tPKDhI0ifFHjTAyC\nNhS+SRm+Ymhnn5KpOLFuIljFgmTBAtQJClfQ2vc2QUdKatUXnPIeWTOR8v8tg+M=\n=4b2F\n-----END PGP SIGNATURE-----\n", "payload": "tree 51eae936b846f874b05d3124524c25e4ee15840d\nparent 814b827efe3369ca4ae155adf2f9f299549b795f\nparent 28eda9b18ac3c492b6934283b39953aab337351f\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1664971053 +0530\ncommitter GitHub <noreply@github.com> 1664971053 +0530\n\nRollup merge of #102496 - compiler-errors:into-suggestion, r=davidtwco\n\nSuggest `.into()` when all other coercion suggestions fail\n\nAlso removes some bogus suggestions because we now short-circuit when offering coercion suggestions(instead of, for example, suggesting every one that could possibly apply)\n\nFixes #102415\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cec087a20277f07300935674d4f4be72cac6bfac", "html_url": "https://github.com/rust-lang/rust/commit/cec087a20277f07300935674d4f4be72cac6bfac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cec087a20277f07300935674d4f4be72cac6bfac/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "814b827efe3369ca4ae155adf2f9f299549b795f", "url": "https://api.github.com/repos/rust-lang/rust/commits/814b827efe3369ca4ae155adf2f9f299549b795f", "html_url": "https://github.com/rust-lang/rust/commit/814b827efe3369ca4ae155adf2f9f299549b795f"}, {"sha": "28eda9b18ac3c492b6934283b39953aab337351f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28eda9b18ac3c492b6934283b39953aab337351f", "html_url": "https://github.com/rust-lang/rust/commit/28eda9b18ac3c492b6934283b39953aab337351f"}], "stats": {"total": 273, "additions": 207, "deletions": 66}, "files": [{"sha": "d396c801c09ccda7c6659e9f89408f4f11a20c7e", "filename": "compiler/rustc_hir_analysis/src/check/demand.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -32,17 +32,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error: Option<TypeError<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n-        self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty);\n-        if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n-            return;\n-        }\n-        self.suggest_no_capture_closure(err, expected, expr_ty);\n-        self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n-        self.suggest_missing_parentheses(err, expr);\n-        self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected);\n-        self.suggest_copied_or_cloned(err, expr, expr_ty, expected);\n+\n+        // Use `||` to give these suggestions a precedence\n+        let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n+            || self.suggest_compatible_variants(err, expr, expected, expr_ty)\n+            || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n+            || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n+            || self.suggest_no_capture_closure(err, expected, expr_ty)\n+            || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n+            || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n+            || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n+            || self.suggest_into(err, expr, expr_ty, expected);\n+\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n@@ -286,7 +288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if let hir::ExprKind::Field(base, ident) = expr.kind {\n                 let base_ty = self.typeck_results.borrow().expr_ty(base);\n@@ -299,7 +301,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"\",\n                         Applicability::MaybeIncorrect,\n                     );\n-                    return\n+                    return true;\n                 }\n             }\n \n@@ -338,7 +340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } else if self.tcx.is_diagnostic_item(sym::Option, expected_adt.did()) {\n                                 vec![\"None\", \"Some(())\"]\n                             } else {\n-                                return;\n+                                return false;\n                             };\n                             if let Some(indent) =\n                                 self.tcx.sess.source_map().indentation_before(span.shrink_to_lo())\n@@ -358,7 +360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            return;\n+                            return true;\n                         }\n                     }\n                 }\n@@ -445,6 +447,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggestions_for(&**variant, *ctor_kind, *field_name),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n                 _ => {\n                     // More than one matching variant.\n@@ -460,9 +463,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             }\n         }\n+\n+        false\n     }\n \n     fn suggest_non_zero_new_unwrap(\n@@ -471,19 +477,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         let tcx = self.tcx;\n         let (adt, unwrap) = match expected.kind() {\n             // In case Option<NonZero*> is wanted, but * is provided, suggest calling new\n             ty::Adt(adt, substs) if tcx.is_diagnostic_item(sym::Option, adt.did()) => {\n                 // Unwrap option\n-                let ty::Adt(adt, _) = substs.type_at(0).kind() else { return };\n+                let ty::Adt(adt, _) = substs.type_at(0).kind() else { return false; };\n \n                 (adt, \"\")\n             }\n             // In case NonZero* is wanted, but * is provided also add `.unwrap()` to satisfy types\n             ty::Adt(adt, _) => (adt, \".unwrap()\"),\n-            _ => return,\n+            _ => return false,\n         };\n \n         let map = [\n@@ -502,7 +508,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some((s, _)) = map\n             .iter()\n             .find(|&&(s, t)| self.tcx.is_diagnostic_item(s, adt.did()) && self.can_coerce(expr_ty, t))\n-            else { return };\n+            else { return false; };\n \n         let path = self.tcx.def_path_str(adt.non_enum_variant().def_id);\n \n@@ -514,6 +520,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ],\n             Applicability::MaybeIncorrect,\n         );\n+\n+        true\n     }\n \n     pub fn get_conversion_methods("}, {"sha": "09890c55cd36a1a7ecfd44f3d4407e090bf31026", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -3,7 +3,7 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use hir::def_id::DefId;\n-use rustc_ast::util::parser::ExprPrecedence;\n+use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-    ) {\n+    ) -> bool {\n         let expr = expr.peel_blocks();\n         if let Some((sp, msg, suggestion, applicability, verbose)) =\n             self.check_ref(expr, found, expected)\n@@ -337,14 +337,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n+            return true;\n         } else if self.suggest_else_fn_with_closure(err, expr, found, expected)\n         {\n+            return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = &found.kind()\n             && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n         {\n             err.span_label(sp, format!(\"{found} defined here\"));\n-        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            return true;\n+        } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            return true;\n+        } else {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n                 let mut suggestions = methods.iter()\n@@ -395,6 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggestions,\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             } else if let ty::Adt(found_adt, found_substs) = found.kind()\n                 && self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n@@ -419,9 +425,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt)),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             }\n         }\n+\n+        false\n     }\n \n     /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n@@ -432,13 +441,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n-            return;\n+            return false;\n         }\n         if !expected.is_box() || found.is_box() {\n-            return;\n+            return false;\n         }\n         let boxed_found = self.tcx.mk_box(found);\n         if self.can_coerce(boxed_found, expected) {\n@@ -456,6 +465,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                  https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n                  https://doc.rust-lang.org/std/boxed/index.html\",\n             );\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -466,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if let (ty::FnPtr(_), ty::Closure(def_id, _)) = (expected.kind(), found.kind()) {\n             if let Some(upvars) = self.tcx.upvars_mentioned(*def_id) {\n                 // Report upto four upvars being captured to reduce the amount error messages\n@@ -490,8 +502,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     multi_span,\n                     \"closures can only be coerced to `fn` types if they do not capture any variables\"\n                 );\n+                return true;\n             }\n         }\n+        false\n     }\n \n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n@@ -893,11 +907,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-    ) {\n+    ) -> bool {\n         let sp = self.tcx.sess.source_map().start_point(expr.span);\n         if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n             // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -910,7 +927,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mut expr: &hir::Expr<'_>,\n         mut expr_ty: Ty<'tcx>,\n         mut expected_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         loop {\n             match (&expr.kind, expr_ty.kind(), expected_ty.kind()) {\n                 (\n@@ -924,9 +941,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 (hir::ExprKind::Block(blk, _), _, _) => {\n                     self.suggest_block_to_brackets(diag, *blk, expr_ty, expected_ty);\n-                    break;\n+                    break true;\n                 }\n-                _ => break,\n+                _ => break false,\n             }\n         }\n     }\n@@ -937,11 +954,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n-    ) {\n-        let ty::Adt(adt_def, substs) = expr_ty.kind() else { return; };\n-        let ty::Adt(expected_adt_def, expected_substs) = expected_ty.kind() else { return; };\n+    ) -> bool {\n+        let ty::Adt(adt_def, substs) = expr_ty.kind() else { return false; };\n+        let ty::Adt(expected_adt_def, expected_substs) = expected_ty.kind() else { return false; };\n         if adt_def != expected_adt_def {\n-            return;\n+            return false;\n         }\n \n         let mut suggest_copied_or_cloned = || {\n@@ -960,6 +977,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \".copied()\",\n                         Applicability::MachineApplicable,\n                     );\n+                    return true;\n                 } else if let Some(clone_did) = self.tcx.lang_items().clone_trait()\n                     && rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions(\n                         self,\n@@ -977,21 +995,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \".cloned()\",\n                         Applicability::MachineApplicable,\n                     );\n+                    return true;\n                 }\n             }\n+            false\n         };\n \n         if let Some(result_did) = self.tcx.get_diagnostic_item(sym::Result)\n             && adt_def.did() == result_did\n             // Check that the error types are equal\n             && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1)).is_ok()\n         {\n-            suggest_copied_or_cloned();\n+            return suggest_copied_or_cloned();\n         } else if let Some(option_did) = self.tcx.get_diagnostic_item(sym::Option)\n             && adt_def.did() == option_did\n         {\n-            suggest_copied_or_cloned();\n+            return suggest_copied_or_cloned();\n+        }\n+\n+        false\n+    }\n+\n+    pub(crate) fn suggest_into(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let expr = expr.peel_blocks();\n+\n+        // We have better suggestions for scalar interconversions...\n+        if expr_ty.is_scalar() && expected_ty.is_scalar() {\n+            return false;\n         }\n+\n+        // Don't suggest turning a block into another type (e.g. `{}.into()`)\n+        if matches!(expr.kind, hir::ExprKind::Block(..)) {\n+            return false;\n+        }\n+\n+        // We'll later suggest `.as_ref` when noting the type error,\n+        // so skip if we will suggest that instead.\n+        if self.should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n+            return false;\n+        }\n+\n+        if let Some(into_def_id) = self.tcx.get_diagnostic_item(sym::Into)\n+            && self.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n+                self.misc(expr.span),\n+                self.param_env,\n+                ty::Binder::dummy(ty::TraitRef {\n+                    def_id: into_def_id,\n+                    substs: self.tcx.mk_substs_trait(expr_ty, &[expected_ty.into()]),\n+                })\n+                .to_poly_trait_predicate()\n+                .to_predicate(self.tcx),\n+            ))\n+        {\n+            let sugg = if expr.precedence().order() >= PREC_POSTFIX {\n+                vec![(expr.span.shrink_to_hi(), \".into()\".to_owned())]\n+            } else {\n+                vec![(expr.span.shrink_to_lo(), \"(\".to_owned()), (expr.span.shrink_to_hi(), \").into()\".to_owned())]\n+            };\n+            diag.multipart_suggestion(\n+                format!(\"call `Into::into` on this expression to convert `{expr_ty}` into `{expected_ty}`\"),\n+                sugg,\n+                Applicability::MaybeIncorrect\n+            );\n+            return true;\n+        }\n+\n+        false\n     }\n \n     /// Suggest wrapping the block in square brackets instead of curly braces"}, {"sha": "9d56764d4897048ab97fbef070b7afe718d9627e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -2158,8 +2158,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n         diag: &mut Diagnostic,\n     ) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+        {\n+            diag.span_suggestion(\n+                span,\n+                msg,\n+                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (exp_found.expected.kind(), exp_found.found.kind())\n+            (expected.kind(), found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 if exp_def == &found_def {\n@@ -2197,21 +2211,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 _ => show_suggestion = false,\n                             }\n                         }\n-                        if let (Ok(snippet), true) =\n-                            (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n-                        {\n-                            diag.span_suggestion(\n-                                span,\n-                                *msg,\n-                                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                                Applicability::MachineApplicable,\n-                            );\n+                        if show_suggestion {\n+                            return Some(*msg);\n                         }\n                     }\n                 }\n             }\n         }\n+        None\n     }\n \n     pub fn report_and_explain_type_error("}, {"sha": "2b6314c38ceb6db64784caf2ccccb336e726a09b", "filename": "src/test/ui/parser/expr-as-stmt-2.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -36,11 +36,6 @@ LL | /     &&\n LL | |     if let Some(y) = a { true } else { false }\n    | |______________________________________________^ expected `bool`, found `&&bool`\n    |\n-help: consider removing the `&&`\n-   |\n-LL -     &&\n-LL +     if let Some(y) = a { true } else { false }\n-   |\n help: parentheses are required to parse this as an expression\n    |\n LL |     (if let Some(x) = a { true } else { false })"}, {"sha": "6da4ac34067e9bc8e74a4e888c1e82f29000a96c", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -170,11 +170,6 @@ LL | fn revenge_from_mars() -> bool {\n LL |     { true } && { true }\n    |              ^^^^^^^^^^^ expected `bool`, found `&&bool`\n    |\n-help: consider removing the `&&`\n-   |\n-LL -     { true } && { true }\n-LL +     { true } { true }\n-   |\n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) && { true }\n@@ -201,10 +196,6 @@ LL |     { true } || { true }\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/expr-as-stmt.rs:51:14: 51:16]`\n-help: use parentheses to call this closure\n-   |\n-LL |     { true } (|| { true })()\n-   |              +           +++\n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) || { true }"}, {"sha": "6050963c4ee80a4b46cd5efeb0ccdd02986480bb", "filename": "src/test/ui/suggestions/boxed-variant-field.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -9,7 +9,6 @@ fn foo(x: Ty) -> Ty {\n         Ty::List(elem) => foo(elem),\n         //~^ ERROR mismatched types\n         //~| HELP consider unboxing the value\n-        //~| HELP try wrapping\n     }\n }\n "}, {"sha": "9ae36a06a7155d4807961d49e36d028d803bfc46", "filename": "src/test/ui/suggestions/boxed-variant-field.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -17,10 +17,6 @@ help: consider unboxing the value\n    |\n LL |         Ty::List(elem) => foo(*elem),\n    |                               +\n-help: try wrapping the expression in `Ty::List`\n-   |\n-LL |         Ty::List(elem) => foo(Ty::List(elem)),\n-   |                               +++++++++    +\n \n error: aborting due to previous error\n "}, {"sha": "1c9a9e0aaf561e8596d83edc39adce4776cfe452", "filename": "src/test/ui/suggestions/into-convert.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -0,0 +1,26 @@\n+use std::path::{Path, PathBuf};\n+use std::sync::atomic::AtomicU32;\n+use std::sync::Arc;\n+\n+fn main() {\n+    let x: A = B;\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `B` into `A`\n+\n+    let y: Arc<Path> = PathBuf::new();\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `PathBuf` into `Arc<Path>`\n+\n+    let z: AtomicU32 = 1;\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `{integer}` into `AtomicU32`\n+}\n+\n+struct A;\n+struct B;\n+\n+impl From<B> for A {\n+    fn from(_: B) -> Self {\n+        A\n+    }\n+}"}, {"sha": "d43104a2172400350e4d01a8e8036864edf0e547", "filename": "src/test/ui/suggestions/into-convert.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cec087a20277f07300935674d4f4be72cac6bfac/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr?ref=cec087a20277f07300935674d4f4be72cac6bfac", "patch": "@@ -0,0 +1,44 @@\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:6:16\n+   |\n+LL |     let x: A = B;\n+   |            -   ^ expected struct `A`, found struct `B`\n+   |            |\n+   |            expected due to this\n+   |\n+help: call `Into::into` on this expression to convert `B` into `A`\n+   |\n+LL |     let x: A = B.into();\n+   |                 +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:10:24\n+   |\n+LL |     let y: Arc<Path> = PathBuf::new();\n+   |            ---------   ^^^^^^^^^^^^^^ expected struct `Arc`, found struct `PathBuf`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `Arc<Path>`\n+              found struct `PathBuf`\n+help: call `Into::into` on this expression to convert `PathBuf` into `Arc<Path>`\n+   |\n+LL |     let y: Arc<Path> = PathBuf::new().into();\n+   |                                      +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:14:24\n+   |\n+LL |     let z: AtomicU32 = 1;\n+   |            ---------   ^ expected struct `AtomicU32`, found integer\n+   |            |\n+   |            expected due to this\n+   |\n+help: call `Into::into` on this expression to convert `{integer}` into `AtomicU32`\n+   |\n+LL |     let z: AtomicU32 = 1.into();\n+   |                         +++++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}