{"sha": "c9d9c249ec95afa53a1862fcb99bf04c339b126c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZDljMjQ5ZWM5NWFmYTUzYTE4NjJmY2I5OWJmMDRjMzM5YjEyNmM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-02T13:21:05Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-08T14:21:58Z"}, "message": "Insert fields from TypeAndMut into TyRef to allow layout optimization", "tree": {"sha": "2aec350a3f6269393099b1e8aa457157da1392f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aec350a3f6269393099b1e8aa457157da1392f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9d9c249ec95afa53a1862fcb99bf04c339b126c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d9c249ec95afa53a1862fcb99bf04c339b126c", "html_url": "https://github.com/rust-lang/rust/commit/c9d9c249ec95afa53a1862fcb99bf04c339b126c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9d9c249ec95afa53a1862fcb99bf04c339b126c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "710b4ad2a5cc8e70b42d6d85ebe4eacc5b65548b", "url": "https://api.github.com/repos/rust-lang/rust/commits/710b4ad2a5cc8e70b42d6d85ebe4eacc5b65548b", "html_url": "https://github.com/rust-lang/rust/commit/710b4ad2a5cc8e70b42d6d85ebe4eacc5b65548b"}], "stats": {"total": 483, "additions": 242, "deletions": 241}, "files": [{"sha": "d0d0ab093c87ffbd976c77489d6beebc9a7f89da", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -888,9 +888,10 @@ for ty::TypeVariants<'gcx>\n             TyRawPtr(pointee_ty) => {\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyRef(region, pointee_ty) => {\n+            TyRef(region, pointee_ty, mutbl) => {\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n+                mutbl.hash_stable(hcx, hasher);\n             }\n             TyFnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);"}, {"sha": "da93156b0b0bd53c2acfd930d7346b08bbbca934", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -665,21 +665,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         fn push_ty_ref<'tcx>(\n             r: &ty::Region<'tcx>,\n-            tnm: &ty::TypeAndMut<'tcx>,\n+            ty: Ty<'tcx>,\n+            mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n             let r = &format!(\"{}\", r);\n             s.push_highlighted(format!(\n                 \"&{}{}{}\",\n                 r,\n                 if r == \"\" { \"\" } else { \" \" },\n-                if tnm.mutbl == hir::MutMutable {\n+                if mutbl == hir::MutMutable {\n                     \"mut \"\n                 } else {\n                     \"\"\n                 }\n             ));\n-            s.push_normal(format!(\"{}\", tnm.ty));\n+            s.push_normal(format!(\"{}\", ty));\n         }\n \n         match (&t1.sty, &t2.sty) {\n@@ -803,24 +804,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::TyRef(r1, ref tnm1), _) if equals(&tnm1.ty, &t2) => {\n+            (&ty::TyRef(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, tnm1, &mut values.0);\n+                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(format!(\"{}\", t2));\n                 values\n             }\n-            (_, &ty::TyRef(r2, ref tnm2)) if equals(&t1, &tnm2.ty) => {\n+            (_, &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(format!(\"{}\", t1));\n-                push_ty_ref(&r2, tnm2, &mut values.1);\n+                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::TyRef(r1, ref tnm1), &ty::TyRef(r2, ref tnm2)) if equals(&tnm1.ty, &tnm2.ty) => {\n+            (&ty::TyRef(r1, ref_ty1, mutbl1),\n+             &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, tnm1, &mut values.0);\n-                push_ty_ref(&r2, tnm2, &mut values.1);\n+                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n+                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n "}, {"sha": "614ae17fa46923b7afb9c5ebfdf605e69c670bcc", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::TyRef(r, _) = expr_ty.sty {\n+                if let ty::TyRef(r, _, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -859,7 +859,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match bm {\n                     ty::BindByReference(m) => {\n-                        if let ty::TyRef(r, _) = pat_ty.sty {\n+                        if let ty::TyRef(r, _, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                         }"}, {"sha": "3875770a5ff5c50298de2c1154e0d2be4d243241", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -1012,7 +1012,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n-            ty::TyRef(region, mt) => (region, mt.mutbl),\n+            ty::TyRef(region, _, mutbl) => (region, mutbl),\n             _ => {\n                 span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n@@ -1046,8 +1046,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let ptr = match base_cmt.ty.sty {\n             ty::TyAdt(def, ..) if def.is_box() => Unique,\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::TyRef(r, mt) => {\n-                let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n+            ty::TyRef(r, _, mutbl) => {\n+                let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)"}, {"sha": "11e25322f00726b2e2226f7ae09bfed9f81cf96b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -29,7 +29,6 @@ use mir::interpret::{Value, PrimVal, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::TypeAndMut;\n use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n@@ -1905,9 +1904,8 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n             write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n         (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)), &TyRef(_, TypeAndMut {\n-            ty: &ty::TyS { sty: TyStr, .. }, ..\n-        })) => {\n+        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n+         &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 let alloc = tcx\n                     .interpret_interner"}, {"sha": "25be4a2ff5c8b086633c4d87de95ff94e4fbdeb5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -878,9 +878,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let mut trait_type = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n-                    trait_type.sty {\n-\n+                if let ty::TypeVariants::TyRef(_, t_type, _) = trait_type.sty {\n                     trait_type = t_type;\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);"}, {"sha": "614cb912fb21215bfd138e41fc5df8e06c69ac08", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -2167,14 +2167,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::TyRef(_, _, hir::MutImmutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n-            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::TyRef(_, _, hir::MutMutable) => {\n                 Never\n             }\n \n@@ -2263,7 +2263,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n-            ty::TyRef(_, ty::TypeAndMut { ty: element_ty, ..}) => {\n+            ty::TyRef(_, element_ty, _) => {\n                 vec![element_ty]\n             },\n "}, {"sha": "908335424e71320d7e061c4e19078eeba572104c", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -36,9 +36,9 @@ pub enum CastTy<'tcx> {\n     /// Function Pointers\n     FnPtr,\n     /// Raw pointers\n-    Ptr(&'tcx ty::TypeAndMut<'tcx>),\n+    Ptr(ty::TypeAndMut<'tcx>),\n     /// References\n-    RPtr(&'tcx ty::TypeAndMut<'tcx>),\n+    RPtr(ty::TypeAndMut<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n@@ -69,8 +69,8 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyFloat(_) => Some(CastTy::Float),\n             ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n-            ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n-            ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n+            ty::TyRawPtr(mt) => Some(CastTy::Ptr(mt)),\n+            ty::TyRef(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n             ty::TyFnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }"}, {"sha": "36eb091cb6e5bcefc5d6f5b34ba14b1706e41199", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -2351,7 +2351,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRef(r, tm))\n+        self.mk_ty(TyRef(r, tm.ty, tm.mutbl))\n     }\n \n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "cfde35de93c3b1ac2963dd0186bb2b628d74f93a", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -189,20 +189,17 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n-            ty::TyRef(region, tymut) => {\n+            ty::TyRef(region, ty, mutbl) => {\n+                let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n                    tymut_string.len() > 10 ||     //name longer than saying \"reference\",\n                    region.to_string() != \"\"       //... or a complex type\n                 {\n-                    match tymut {\n-                        ty::TypeAndMut{mutbl, ..} => {\n-                            format!(\"{}reference\", match mutbl {\n-                                hir::Mutability::MutMutable => \"mutable \",\n-                                _ => \"\"\n-                            })\n-                        }\n-                    }\n+                    format!(\"{}reference\", match mutbl {\n+                        hir::Mutability::MutMutable => \"mutable \",\n+                        _ => \"\"\n+                    })\n                 } else {\n                     format!(\"&{}\", tymut_string)\n                 }"}, {"sha": "cf5e55a59f713e10cd16534bba946745570adaba", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -80,11 +80,11 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyDynamic(ref trait_info, ..) => {\n             trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n-        ty::TyRef(_, mt) => {\n+        ty::TyRef(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n             // view of possibly unifying\n-            simplify_type(tcx, mt.ty, can_simplify_params)\n+            simplify_type(tcx, ty, can_simplify_params)\n         }\n         ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => {"}, {"sha": "01de848e0f076b077010336b17cf02ec42eba7e8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -173,9 +173,9 @@ impl FlagComputation {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyRef(r, ref m) => {\n+            &ty::TyRef(r, ty, _) => {\n                 self.add_region(r);\n-                self.add_ty(m.ty);\n+                self.add_ty(ty);\n             }\n \n             &ty::TyTuple(ref ts) => {"}, {"sha": "17a3d0011eddfe5276eadb910ff9dc214583568f", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -269,8 +269,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     _ => DefIdForest::empty()\n                 }\n             }\n-            TyRef(_, ref tm) => {\n-                tm.ty.uninhabited_from(visited, tcx)\n+            TyRef(_, ty, _) => {\n+                ty.uninhabited_from(visited, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "41625afec86a02a659b6d2582ce8ae5a2d3f1ce9", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -360,8 +360,9 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) => characteristic_def_id_of_type(subty),\n \n-        ty::TyRawPtr(mt) |\n-        ty::TyRef(_, mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::TyRawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::TyRef(_, ty, _) => characteristic_def_id_of_type(ty),\n \n         ty::TyTuple(ref tys) => tys.iter()\n                                    .filter_map(|ty| characteristic_def_id_of_type(ty))"}, {"sha": "0688dcabe5585db0d83089b372f918c30b07dbb3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n@@ -1262,7 +1262,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         };\n \n         match ty.sty {\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail(pointee);\n@@ -1560,7 +1560,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < 2);\n "}, {"sha": "7076112e3715a285b6377140e3319d40332fcff3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -514,7 +514,7 @@ impl<'tcx> TyS<'tcx> {\n                 TypeVariants::TyInfer(InferTy::FloatVar(_)) |\n                 TypeVariants::TyInfer(InferTy::FreshIntTy(_)) |\n                 TypeVariants::TyInfer(InferTy::FreshFloatTy(_)) => true,\n-            TypeVariants::TyRef(_, x) => x.ty.is_primitive_ty(),\n+            TypeVariants::TyRef(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n     }"}, {"sha": "109dfebf154de67730d3e0294d5cf092af1dee30", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -454,10 +454,12 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_ptr(mt))\n         }\n \n-        (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n+        (&ty::TyRef(a_r, a_ty, a_mutbl), &ty::TyRef(b_r, b_ty, b_mutbl)) =>\n         {\n             let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n+            let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n+            let mt = relation.relate(&a_mt, &b_mt)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n "}, {"sha": "e77ede72143b1afd819f169f0d5355dbf7bc0373", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -864,8 +864,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n                 ty::TyFnDef(def_id, substs.fold_with(folder))\n             }\n             ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n-            ty::TyRef(ref r, tm) => {\n-                ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n+            ty::TyRef(ref r, ty, mutbl) => {\n+                ty::TyRef(r.fold_with(folder), ty.fold_with(folder), mutbl)\n             }\n             ty::TyGenerator(did, substs, movability) => {\n                 ty::TyGenerator(\n@@ -904,7 +904,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n-            ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n+            ty::TyRef(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n             ty::TyGenerator(_did, ref substs, _) => {\n                 substs.visit_with(visitor)\n             }"}, {"sha": "7518f008fb316515be6f8b4ce65e1f2ffe442b6d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -121,7 +121,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(Region<'tcx>, TypeAndMut<'tcx>),\n+    TyRef(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n@@ -1392,7 +1392,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+            TyRawPtr(TypeAndMut { ty, .. }) | TyRef(_, ty, _) => match ty.sty {\n                 TySlice(_) | TyStr => true,\n                 _ => false,\n             },\n@@ -1441,11 +1441,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_mutable_pointer(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(tnm) | TyRef(_, tnm) => if let hir::Mutability::MutMutable = tnm.mutbl {\n-                true\n-            } else {\n-                false\n-            },\n+            TyRawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n+            TyRef(_, _, hir::Mutability::MutMutable) => true,\n             _ => false\n         }\n     }\n@@ -1598,7 +1595,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     mutbl: hir::MutImmutable,\n                 })\n             },\n-            TyRef(_, mt) => Some(mt),\n+            TyRef(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n             TyRawPtr(mt) if explicit => Some(mt),\n             _ => None,\n         }\n@@ -1652,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// ignores late-bound regions binders.\n     pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n-            TyRef(region, _) => {\n+            TyRef(region, _, _) => {\n                 vec![region]\n             }\n             TyDynamic(ref obj, region) => {"}, {"sha": "80dc3b2b452ce4047370fcf5683b9da55872d8fa", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -201,7 +201,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n                 ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => return Ok(()),\n+                ty::TyRef(_, _, hir::MutImmutable) => return Ok(()),\n \n                 ty::TyAdt(adt, substs) => (adt, substs),\n \n@@ -664,8 +664,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                     _ => bug!(\"arrays should not have {:?} as length\", n)\n                 }\n             }\n-            TyRawPtr(m) |\n-            TyRef(_, m) => self.hash(m.mutbl),\n+            TyRawPtr(m) => self.hash(m.mutbl),\n+            TyRef(_, _, mutbl) => self.hash(mutbl),\n             TyClosure(def_id, _) |\n             TyGenerator(def_id, _, _) |\n             TyAnon(def_id, _) |\n@@ -1141,7 +1141,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+            ty::TyRef(region, ty, mutbl) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {"}, {"sha": "ebe88d60ed12f0ec9b624d4744d10603b67e2f78", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -92,9 +92,12 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TySlice(ty) => {\n             stack.push(ty);\n         }\n-        ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {\n+        ty::TyRawPtr(ref mt) => {\n             stack.push(mt.ty);\n         }\n+        ty::TyRef(_, ty, _) => {\n+            stack.push(ty);\n+        }\n         ty::TyProjection(ref data) => {\n             stack.extend(data.substs.types().rev());\n         }"}, {"sha": "62fed1ecb668aa5402809263a630db9d6733c01b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -298,17 +298,17 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.out.extend(obligations);\n                 }\n \n-                ty::TyRef(r, mt) => {\n+                ty::TyRef(r, rty, _) => {\n                     // WfReference\n-                    if !r.has_escaping_regions() && !mt.ty.has_escaping_regions() {\n+                    if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n                         self.out.push(\n                             traits::Obligation::new(\n                                 cause,\n                                 param_env,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(mt.ty, r)))));\n+                                        ty::OutlivesPredicate(rty, r)))));\n                     }\n                 }\n "}, {"sha": "4fb1017035168497b5d42b9534251e736a9e2e43", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -1011,14 +1011,14 @@ define_print! {\n                     })?;\n                     tm.ty.print(f, cx)\n                 }\n-                TyRef(r, ref tm) => {\n+                TyRef(r, ty, mutbl) => {\n                     write!(f, \"&\")?;\n                     let s = r.print_to_string(cx);\n                     write!(f, \"{}\", s)?;\n                     if !s.is_empty() {\n                         write!(f, \" \")?;\n                     }\n-                    tm.print(f, cx)\n+                    ty::TypeAndMut { ty, mutbl }.print(f, cx)\n                 }\n                 TyNever => write!(f, \"!\"),\n                 TyTuple(ref tys) => {"}, {"sha": "5102bfe766eeff2370e63610b3043b9fa2357797", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -1173,9 +1173,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n-            Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n-                if to_mt.mutbl == hir::Mutability::MutMutable &&\n-                   from_mt.mutbl == hir::Mutability::MutImmutable {\n+            Some((&ty::TyRef(_, _, from_mt), &ty::TyRef(_, _, to_mt))) => {\n+                if to_mt == hir::Mutability::MutMutable &&\n+                   from_mt == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }"}, {"sha": "32963146893bbf2e9c2ff1b5e148c05b42109e5d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -662,8 +662,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 help: Some(\"consider using a struct instead\"),\n             },\n \n-            ty::TyRawPtr(ref m) |\n-            ty::TyRef(_, ref m) => self.check_type_for_ffi(cache, m.ty),\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => self.check_type_for_ffi(cache, ty),\n \n             ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n "}, {"sha": "fde740bce3f3566129adbdf7b8322d42fe27eb15", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -773,8 +773,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     format!(\"{}\", def.non_enum_variant().fields[field.index()].name)\n                 },\n                 ty::TyTuple(_) => format!(\"{}\", field.index()),\n-                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n-                    self.describe_field_from_ty(&tnm.ty, field)\n+                ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                    self.describe_field_from_ty(&ty, field)\n                 }\n                 ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n                 ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {"}, {"sha": "1cc69351b4750578633dbfb8992f9f7e2f68f3a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -1913,8 +1913,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n-                            ty::TyRef(_, tnm) => {\n-                                match tnm.mutbl {\n+                            ty::TyRef(_, _, mutbl) => {\n+                                match mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n@@ -2348,13 +2348,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                         (\n                             ProjectionElem::Deref,\n-                            ty::TyRef(\n-                                _,\n-                                ty::TypeAndMut {\n-                                    ty: _,\n-                                    mutbl: hir::MutImmutable,\n-                                },\n-                            ),\n+                            ty::TyRef( _, _, hir::MutImmutable),\n                             _,\n                         ) => {\n                             // the borrow goes through a dereference of a shared reference."}, {"sha": "4f87a2b30ae843bae1587d3a75e91631edc5ffb0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -270,7 +270,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n-                        ty::TyRef(ref_region, ty::TypeAndMut { ty: _, mutbl }) => {\n+                        ty::TyRef(ref_region, _, mutbl) => {\n                             let span = self.mir.source_info(location).span;\n                             self.regioncx.add_outlives(\n                                 span,"}, {"sha": "dee78341265bf536ba7500b536c762b334c4edc9", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -156,10 +156,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                 ty::TyRawPtr(_) |\n                 ty::TyRef(\n                     _, /*rgn*/\n-                    ty::TypeAndMut {\n-                        ty: _,\n-                            mutbl: hir::MutImmutable,\n-                        },\n+                    _, /*ty*/\n+                    hir::MutImmutable\n                     ) => {\n                     // don't continue traversing over derefs of raw pointers or shared borrows.\n                     self.next = None;\n@@ -168,10 +166,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n                 ty::TyRef(\n                     _, /*rgn*/\n-                    ty::TypeAndMut {\n-                        ty: _,\n-                        mutbl: hir::MutMutable,\n-                    },\n+                    _, /*ty*/\n+                    hir::MutMutable,\n                     ) => {\n                     self.next = Some(&proj.base);\n                     return Some(cursor);"}, {"sha": "d6ddfea1f19fb7dfd137360f0dcbd7a700f2b58b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // array, so we can call `<[u8]>::eq` rather than having to find an\n                     // `<[u8; N]>::eq`.\n                     let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::TyRef(region, tam) => match tam.ty.sty {\n+                        ty::TyRef(region, rty, _) => match rty.sty {\n                             ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n                             _ => None,\n                         },"}, {"sha": "76605a7aa04840a05aac63af6f619f3a5a5883b8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -283,7 +283,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprAddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n-                ty::TyRef(r, _) => r,\n+                ty::TyRef(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n@@ -987,13 +987,13 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // Reconstruct the output assuming it's a reference with the\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mt) = match recv_ty.sty {\n-        ty::TyRef(region, mt) => (region, mt),\n+    let (region, mutbl) = match recv_ty.sty {\n+        ty::TyRef(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n         ty: place_ty,\n-        mutbl: mt.mutbl,\n+        mutbl,\n     });\n \n     // construct the complete expression `foo()` for the overloaded call,"}, {"sha": "1245f506955c133a4ebc2f51fc3d44b9850797bb", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -46,13 +46,13 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::TyRef(_, mt), &PatternKind::Constant { ref value }) => {\n+            (&ty::TyRef(_, rty, _), &PatternKind::Constant { ref value }) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n                     kind: box PatternKind::Deref {\n                         subpattern: Pattern {\n-                            ty: mt.ty,\n+                            ty: rty,\n                             span: pat.span,\n                             kind: box PatternKind::Constant { value: value.clone() },\n                         }\n@@ -907,7 +907,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n+        ty::TyRef(_, rty, _) => vec![rty],\n         ty::TyAdt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>."}, {"sha": "2585447fa0a04f6cdecfe14bb2777a7a04fb4d31", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -238,9 +238,9 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Deref { ref subpattern } => {\n                 match self.ty.sty {\n                     ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::TyRef(_, mt) => {\n+                    ty::TyRef(_, _, mutbl) => {\n                         write!(f, \"&\")?;\n-                        if mt.mutbl == hir::MutMutable {\n+                        if mutbl == hir::MutMutable {\n                             write!(f, \"mut \")?;\n                         }\n                     }\n@@ -424,13 +424,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n-                    ty::TyRef(_, mt) =>\n+                    ty::TyRef(_, ty, _) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n-                                ty: mt.ty,\n+                                ty,\n                                 span: pat.span,\n                                 kind: Box::new(self.slice_or_array_pattern(\n-                                    pat.span, mt.ty, prefix, slice, suffix))\n+                                    pat.span, ty, prefix, slice, suffix))\n                             },\n                         },\n \n@@ -469,7 +469,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Binding(_, id, ref name, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(r, _) => Some(r),\n+                    ty::TyRef(r, _, _) => Some(r),\n                     _ => None,\n                 };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n@@ -490,8 +490,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::TyRef(_, mt) = ty.sty {\n-                        ty = mt.ty;\n+                    if let ty::TyRef(_, rty, _) = ty.sty {\n+                        ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", name.node, ty);\n                     }"}, {"sha": "00cc91db8480c51713364add0f9ca136aeb632a1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::maps::TyCtxtAt;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::middle::const_val::FrameInfo;\n@@ -775,8 +775,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(super) fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyRawPtr(ref tam) |\n-            ty::TyRef(_, ref tam) => !self.type_is_sized(tam.ty),\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n             ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n             _ => false,\n         }\n@@ -1259,8 +1259,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             ty::TyFnPtr(_) => PrimValKind::FnPtr,\n \n-            ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) if self.type_is_sized(tam.ty) => PrimValKind::Ptr,\n+            ty::TyRef(_, ty, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => {\n+                PrimValKind::Ptr\n+            }\n \n             ty::TyAdt(def, _) if def.is_box() => PrimValKind::Ptr,\n \n@@ -1400,8 +1402,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             ty::TyFnPtr(_) => self.memory.read_ptr_sized(ptr, ptr_align)?,\n-            ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, ptr_align, tam.ty).map(Some),\n+            ty::TyRef(_, rty, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n+                return self.read_ptr(ptr, ptr_align, rty).map(Some)\n+            }\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n@@ -1501,10 +1505,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         dst_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n-            (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n-            (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n-            (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n-                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s.ty, d.ty)\n+            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n+            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s, d)\n             }\n             (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);"}, {"sha": "b5a06286e4eed18430d12f9460043b0ecd27d4aa", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -369,8 +369,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let val = self.read_place(base)?;\n \n                 let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ref tam) |\n-                    ty::TyRef(_, ref tam) => tam.ty,\n+                    ty::TyRawPtr(ref tam) => tam.ty,\n+                    ty::TyRef(_, ty, _) => ty,\n                     ty::TyAdt(def, _) if def.is_box() => base_ty.boxed_ty(),\n                     _ => bug!(\"can only deref pointer types\"),\n                 };"}, {"sha": "c61487f106b66f272f2440ea367a63cfb4e9da91", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // mutability of raw pointers.\n                 // TODO: Should not be allowed when fat pointers are involved.\n                 (&ty::TyRawPtr(_), &ty::TyRawPtr(_)) => true,\n-                (&ty::TyRef(_, _), &ty::TyRef(_, _)) => {\n+                (&ty::TyRef(_, _, _), &ty::TyRef(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n                 }\n                 // rule out everything else"}, {"sha": "e051b848c011fe21a193cfc193fbf88719413b34", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -844,9 +844,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     match (&source_ty.sty, &target_ty.sty) {\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+        (&ty::TyRef(_, a, _),\n+         &ty::TyRef(_, b, _)) |\n+        (&ty::TyRef(_, a, _),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {"}, {"sha": "176ed8c5bca745c53e4c8f0cf2c7f80f9ba86bd7", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -302,7 +302,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            ty::TyRef(_, inner_type, mutbl) => {\n                 output.push('&');\n                 if mutbl == hir::MutMutable {\n                     output.push_str(\"mut \");"}, {"sha": "584887d03738fe27d8812fc7a3c5f9bdc81fefdc", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -44,14 +44,14 @@ fn place_context<'a, 'tcx, D>(\n                     // A Deref projection may restrict the context, this depends on the type\n                     // being deref'd.\n                     let context = match ty.sty {\n-                        ty::TyRef(re, tam) => {\n+                        ty::TyRef(re, _, mutbl) => {\n                             let re = match re {\n                                 &RegionKind::ReScope(ce) => Some(ce),\n                                 &RegionKind::ReErased =>\n                                     bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n                                 _ => None\n                             };\n-                            (re, tam.mutbl)\n+                            (re, mutbl)\n                         }\n                         ty::TyRawPtr(_) =>\n                             // There is no guarantee behind even a mutable raw pointer,"}, {"sha": "33dc9b3b7ab90087caf3291f7c1ae6aabe53115d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -228,9 +228,9 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n ) -> (ValueRef, ValueRef) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+        (&ty::TyRef(_, a, _),\n+         &ty::TyRef(_, b, _)) |\n+        (&ty::TyRef(_, a, _),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {"}, {"sha": "ae23b523cbfaebcb68fa9dc4e56e44a2a5d2a297", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -555,7 +555,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             false)\n         }\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) => {\n+        ty::TyRef(_, ty, _) => {\n             match ptr_metadata(ty) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,"}, {"sha": "565a9bedef0f51d724bf78e044bcb1e7c66891b0", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -80,7 +80,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+        ty::TyRef(_, inner_type, mutbl) => {\n             if !cpp_like_names {\n                 output.push('&');\n             }"}, {"sha": "8ea0983075dc403212b49619bd703ceed78660c2", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -571,7 +571,8 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bx.cx.layout_of(mt.ty), true),\n+                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+                ty::TyRef(_, ty, _)  => (bx.cx.layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n@@ -615,8 +616,8 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 // a pointer in an alloca for debuginfo atm.\n                 let mut ops = if env_ref || true { &ops[..] } else { &ops[1..] };\n \n-                let ty = if let (true, &ty::TyRef(_, mt)) = (decl.by_ref, &ty.sty) {\n-                    mt.ty\n+                let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n+                    ty\n                 } else {\n                     ops = &ops[..ops.len() - 1];\n                     ty"}, {"sha": "f736e81202a38c92b32df094c1991599fe74b711", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -250,7 +250,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n-                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                ty::TyRef(_, ty, _) |\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n@@ -418,11 +418,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyRef(_, mt) if offset.bytes() == 0 => {\n-                let (size, align) = cx.size_and_align_of(mt.ty);\n+            ty::TyRef(_, ty, mt) if offset.bytes() == 0 => {\n+                let (size, align) = cx.size_and_align_of(ty);\n \n-                let kind = match mt.mutbl {\n-                    hir::MutImmutable => if cx.type_is_freeze(mt.ty) {\n+                let kind = match mt {\n+                    hir::MutImmutable => if cx.type_is_freeze(ty) {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared"}, {"sha": "c7585c827ce11eaf92b0f0cbf59cd5ec1b0ec7a3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -84,9 +84,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected = loop {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n                 match exp_ty.sty {\n-                    ty::TypeVariants::TyRef(_, ty::TypeAndMut{\n-                        ty: inner_ty, mutbl: inner_mutability,\n-                    }) => {\n+                    ty::TypeVariants::TyRef(_, inner_ty, inner_mutability) => {\n                         debug!(\"current discriminant is TyRef, inserting implicit deref\");\n                         // Preserve the reference type. We'll need it later during HAIR lowering.\n                         pat_adjustments.push(exp_ty);\n@@ -152,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let hir::ExprLit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::TyRef(_, mt) = expected_ty.sty {\n-                            if let ty::TySlice(_) = mt.ty.sty {\n+                        if let ty::TyRef(_, r_ty, _) = expected_ty.sty {\n+                            if let ty::TySlice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n@@ -334,8 +332,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // hack detailed in (*) below.\n                     debug!(\"check_pat_walk: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n-                            (expected, mt.ty)\n+                        ty::TyRef(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                            (expected, r_ty)\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n@@ -408,7 +406,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 tcx.sess, pat.span, E0529,\n                                 \"expected an array or slice, found `{}`\",\n                                 expected_ty);\n-                            if let ty::TyRef(_, ty::TypeAndMut { mutbl: _, ty }) = expected_ty.sty {\n+                            if let ty::TyRef(_, ty, _) = expected_ty.sty {\n                                 match ty.sty {\n                                     ty::TyArray(..) | ty::TySlice(..) => {\n                                         err.help(\"the semantics of slice patterns changed \\"}, {"sha": "e1ce6073ce43698e0947d77b9be65e7dcc8bb9d8", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -177,10 +177,10 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n-                        if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                        if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n                             Some(OverloadedDeref {\n                                 region,\n-                                mutbl: mt.mutbl,\n+                                mutbl,\n                             })\n                         } else {\n                             None"}, {"sha": "b0f9a4c8b85adee737418d841f3b118a29c6d69c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -175,8 +175,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let method = self.register_infer_ok_obligations(ok);\n                     let mut autoref = None;\n                     if borrow {\n-                        if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                            let mutbl = match mt.mutbl {\n+                        if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mutbl {\n                                 hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                 hir::MutMutable => AutoBorrowMutability::Mutable {\n                                     // For initial two-phase borrow"}, {"sha": "f0d7ca8ebf14f6c5ee29d6a15b5c1437fff3b57a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -46,7 +46,7 @@ use lint;\n use rustc::hir;\n use rustc::session::Session;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable, TypeAndMut};\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::subst::Substs;\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                          fcx.resolve_type_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n-            ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n+            ty::TyRef(_, _, mt) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n                     hir::MutImmutable => \"\",\n@@ -511,8 +511,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_ptr_cast(&self,\n                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                          m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                          m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                          m_expr: ty::TypeAndMut<'tcx>,\n+                          m_cast: ty::TypeAndMut<'tcx>)\n                           -> Result<CastKind, CastError> {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n@@ -552,7 +552,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_fptr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_cast: ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to thin ptr\n \n@@ -565,7 +565,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_addr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_expr: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_expr: ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from thin ptr\n \n@@ -578,8 +578,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_ref_cast(&self,\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                      m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                      m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                      m_expr: ty::TypeAndMut<'tcx>,\n+                      m_cast: ty::TypeAndMut<'tcx>)\n                       -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn check_addr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           m_cast: TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n         match fcx.pointer_kind(m_cast.ty, self.span)? {"}, {"sha": "c1ef916e27db3130204e7090ce92e89eacaca698", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -214,7 +214,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n-            ty::TyRef(r_b, mt_b) => {\n+            ty::TyRef(r_b, ty, mutbl) => {\n+                let mt_b = ty::TypeAndMut { ty, mutbl };\n                 return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n \n@@ -266,7 +267,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // yield.\n \n         let (r_a, mt_a) = match a.sty {\n-            ty::TyRef(r_a, mt_a) => {\n+            ty::TyRef(r_a, ty, mutbl) => {\n+                let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n@@ -427,7 +429,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n-            ty::TyRef(r_borrow, _) => r_borrow,\n+            ty::TyRef(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n@@ -471,12 +473,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let reborrow = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n-                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n+            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRef(_, _, mutbl_b)) => {\n+                coerce_mutbls(mutbl_a, mutbl_b)?;\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                let mutbl = match mt_b.mutbl {\n+                let mutbl = match mutbl_b {\n                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                     hir::MutMutable => AutoBorrowMutability::Mutable {\n                         // We don't allow two-phase borrows here, at least for initial\n@@ -487,26 +489,26 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 };\n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n-                    target: mt_a.ty\n+                    target: ty_a\n                 }, Adjustment {\n                     kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n                     target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n-                        mutbl: mt_b.mutbl,\n-                        ty: mt_a.ty\n+                        mutbl: mutbl_b,\n+                        ty: ty_a\n                     })\n                 }))\n             }\n-            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n-                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n+            (&ty::TyRef(_, ty_a, mt_a), &ty::TyRawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n+                coerce_mutbls(mt_a, mt_b)?;\n \n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n-                    target: mt_a.ty\n+                    target: ty_a\n                 }, Adjustment {\n-                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b.mutbl)),\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b)),\n                     target:  self.tcx.mk_ptr(ty::TypeAndMut {\n-                        mutbl: mt_b.mutbl,\n-                        ty: mt_a.ty\n+                        mutbl: mt_b,\n+                        ty: ty_a\n                     })\n                 }))\n             }\n@@ -719,7 +721,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n         let (is_ref, mt_a) = match a.sty {\n-            ty::TyRef(_, mt) => (true, mt),\n+            ty::TyRef(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n                 return self.unify_and(a, b, identity);\n@@ -886,12 +888,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n-                        ty::TyRef(_, mt_orig) => {\n+                        ty::TyRef(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref\n                             // which will be merged into it.\n-                            mutbl_adj == mt_orig.mutbl\n+                            mutbl_adj == mt_orig\n                         }\n                         _ => false,\n                     }"}, {"sha": "06d854c15fe5beb7ad842d42079016d1e74babf5", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  expected: Ty<'tcx>)\n                  -> Option<(&'static str, String)> {\n         match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, exp), &ty::TyRef(_, check)) => match (&exp.ty.sty, &check.ty.sty) {\n+            (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::TyStr, &ty::TyArray(arr, _)) |\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprLit(_) = expr.node {\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => None,\n             },\n-            (&ty::TyRef(_, mutability), _) => {\n+            (&ty::TyRef(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -250,7 +250,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // let x = 0u32;\n                 // bar(&x); // error, expected &mut\n                 // ```\n-                let ref_ty = match mutability.mutbl {\n+                let ref_ty = match mutability {\n                     hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n                                                        self.tcx.mk_region(ty::ReStatic),\n                                                        checked_ty),\n@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::ExprCast(_, _) | hir::ExprBinary(_, _, _) => format!(\"({})\", src),\n                             _ => src,\n                         };\n-                        return Some(match mutability.mutbl {\n+                        return Some(match mutability {\n                             hir::Mutability::MutMutable => {\n                                 (\"consider mutably borrowing here\", format!(\"&mut {}\", sugg_expr))\n                             }\n@@ -278,15 +278,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None\n             }\n-            (_, &ty::TyRef(_, checked)) => {\n+            (_, &ty::TyRef(_, checked, _)) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest adding a `*`, or removing\n                 // a `&`.\n                 //\n                 // (But, also check check the `expn_info()` to see if this is\n                 // a macro; if so, it's hard to extract the text and make a good\n                 // suggestion, so don't bother.)\n-                if self.infcx.can_sub(self.param_env, checked.ty, &expected).is_ok() &&\n+                if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() &&\n                    expr.span.ctxt().outer().expn_info().is_none() {\n                     match expr.node {\n                         // Maybe remove `&`?\n@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // Maybe add `*`? Only if `T: Copy`.\n                         _ => {\n                             if !self.infcx.type_moves_by_default(self.param_env,\n-                                                                checked.ty,\n+                                                                checked,\n                                                                 expr.span) {\n                                 let sp = self.sess().codemap().call_span_if_macro(expr.span);\n                                 if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(sp) {"}, {"sha": "46288181037f49d596968d4bfa0b29736ec15b99", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -462,10 +462,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n                         if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                            if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n                                     region,\n-                                    mutbl: mt.mutbl\n+                                    mutbl,\n                                 };\n                             }\n                         }\n@@ -521,8 +521,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n-            (r, mt.mutbl)\n+        let (region, mutbl) = if let ty::TyRef(r, _, mutbl) = method.sig.inputs()[0].sty {\n+            (r, mutbl)\n         } else {\n             span_bug!(expr.span, \"input to place op is not a ref?\");\n         };"}, {"sha": "e45565c2f52203783f1389b2a79d11f21d6f1869", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -917,9 +917,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::TyRef(_, mt) = step.self_ty.sty {\n+                if let ty::TyRef(_, _, mutbl) = step.self_ty.sty {\n                     pick.autoderefs += 1;\n-                    pick.autoref = Some(mt.mutbl);\n+                    pick.autoref = Some(mutbl);\n                 }\n \n                 pick"}, {"sha": "ef14fa9a12248eb5a49d189eda474601d617e778", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -2393,8 +2393,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n-                if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                    let mutbl = match mt.mutbl {\n+                if let ty::TyRef(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n+                    let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n                             // Indexing can be desugared to a method call,\n@@ -2407,7 +2407,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                         target: self.tcx.mk_ref(region, ty::TypeAndMut {\n-                            mutbl: mt.mutbl,\n+                            mutbl: r_mutbl,\n                             ty: adjusted_ty\n                         })\n                     });\n@@ -3615,8 +3615,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         } else if let Some(ok) = self.try_overloaded_deref(\n                                 expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                                let mutbl = match mt.mutbl {\n+                            if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                let mutbl = match mutbl {\n                                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                     hir::MutMutable => AutoBorrowMutability::Mutable {\n                                         // (It shouldn't actually matter for unary ops whether\n@@ -3660,14 +3660,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n-                    ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n+                    ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                         if self.is_place_expr(&oprnd) {\n                             // Places may legitimately have unsized types.\n                             // For example, dereferences of a fat pointer and\n                             // the last field of a struct can be unsized.\n-                            ExpectHasType(mt.ty)\n+                            ExpectHasType(ty)\n                         } else {\n-                            Expectation::rvalue_hint(self, mt.ty)\n+                            Expectation::rvalue_hint(self, ty)\n                         }\n                     }\n                     _ => NoExpectation"}, {"sha": "9e8e00594e60afc9074322c7b080ac6c09294f7f", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -197,8 +197,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                        let mutbl = match mt.mutbl {\n+                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n@@ -214,8 +214,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n-                        let mutbl = match mt.mutbl {\n+                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[1].sty {\n+                        let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n@@ -262,12 +262,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             op.node.as_str(),\n                             lhs_ty);\n \n-                        if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                        if let TypeVariants::TyRef(_, rty, _) = lhs_ty.sty {\n                             if {\n                                 !self.infcx.type_moves_by_default(self.param_env,\n-                                                                  ty_mut.ty,\n+                                                                  rty,\n                                                                   lhs_expr.span) &&\n-                                    self.lookup_op_method(ty_mut.ty,\n+                                    self.lookup_op_method(rty,\n                                                           &[rhs_ty],\n                                                           Op::Binary(op, is_assign))\n                                         .is_ok()\n@@ -341,8 +341,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&TyRef(_, ref l_ty), &TyRef(_, ref r_ty))\n-            if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr => {\n+            (&TyRef(_, l_ty, _), &TyRef(_, r_ty, _))\n+            if l_ty.sty == TyStr && r_ty.sty == TyStr => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate two `&str` strings\");\n                 match codemap.span_to_snippet(lhs_expr.span) {\n@@ -353,8 +353,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 true\n             }\n-            (&TyRef(_, ref l_ty), &TyAdt(..))\n-            if l_ty.ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n+            (&TyRef(_, l_ty, _), &TyAdt(..))\n+            if l_ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate a `&str` with a `String`\");\n                 match codemap.span_to_snippet(lhs_expr.span) {"}, {"sha": "badf5bcb6a9a0d45e7ececfb78b3381171c5593a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n                 let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::TyRef(r_ptr, _) = base_ty.sty {\n+                if let ty::TyRef(r_ptr, _, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n@@ -701,11 +701,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                from_ty,\n                to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n-            /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n+            /*From:*/ (&ty::TyRef(from_r, from_ty, _),\n+            /*To:  */  &ty::TyRef(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n-                self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n+                self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n             /*From:*/ (_,\n@@ -913,8 +913,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n-        if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n-            match mt.ty.sty {\n+        if let ty::TyRef(r_ptr, r_ty, _) = indexed_ty.sty {\n+            match r_ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n                                      self.tcx.mk_region(r_index_expr), r_ptr);\n@@ -1086,7 +1086,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(r, _) = rptr_ty.sty {\n+        if let ty::TyRef(r, _, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }"}, {"sha": "57c1d33cb5d2ae608bf7d9dce6b1d4eb73f5d3aa", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -172,7 +172,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             match tables.expr_ty_adjusted(&base).sty {\n                 // All valid indexing looks like this\n-                ty::TyRef(_, ty::TypeAndMut { ty: ref base_ty, .. }) => {\n+                ty::TyRef(_, base_ty, _) => {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n "}, {"sha": "3424a31e09df09245058b1315be2b9c54450c6c2", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -223,12 +223,18 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+            (&ty::TyRef(r_a, ty_a, mutbl_a), &ty::TyRef(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+                let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n-            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRawPtr(mt_b)) => {\n+                let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+            }\n+\n             (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }"}, {"sha": "5a9539a8badf01ab87a6fbd1756733f39361f0fc", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -149,8 +149,8 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //\n             // We also want to calculate potential predicates for the T\n-            ty::TyRef(region, mt) => {\n-                insert_outlives_predicate(tcx, mt.ty.into(), region, required_predicates);\n+            ty::TyRef(region, rty, _) => {\n+                insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n             }\n \n             // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we"}, {"sha": "ad7a3051f6402f2d59bace747e33ccdaba857e38", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -272,10 +272,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n-            ty::TyRef(region, ref mt) => {\n+            ty::TyRef(region, ty, mutbl) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, region, contra);\n-                self.add_constraints_from_mt(current, mt, variance);\n+                self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n             ty::TyArray(typ, _) |"}, {"sha": "f27a3525d55bdb2af0d01464e96db804732c8a29", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9d9c249ec95afa53a1862fcb99bf04c339b126c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c9d9c249ec95afa53a1862fcb99bf04c339b126c", "patch": "@@ -1484,7 +1484,7 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         for ty_s in trait_ref.input_types().skip(1) {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let ty::TyRef(ref reg, _) = ty_s.sty {\n+                    if let ty::TyRef(ref reg, _, _) = ty_s.sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n@@ -2235,8 +2235,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n-                        if mt.ty == self_ty {\n+                    } else if let ty::TyRef(_, ty, _) = self_arg_ty.sty {\n+                        if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef{ref mut type_, ..} => {\n                                     **type_ = Generic(String::from(\"Self\"))\n@@ -2790,10 +2790,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 Array(box ty.clean(cx), n)\n             }\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n-            ty::TyRef(r, mt) => BorrowedRef {\n+            ty::TyRef(r, ty, mutbl) => BorrowedRef {\n                 lifetime: r.clean(cx),\n-                mutability: mt.mutbl.clean(cx),\n-                type_: box mt.ty.clean(cx),\n+                mutability: mutbl.clean(cx),\n+                type_: box ty.clean(cx),\n             },\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) => {"}]}