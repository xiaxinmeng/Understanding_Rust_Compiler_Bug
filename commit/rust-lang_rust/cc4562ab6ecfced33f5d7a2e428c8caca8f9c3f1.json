{"sha": "cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNDU2MmFiNmVjZmNlZDMzZjVkN2EyZTQyOGM4Y2FjYThmOWMzZjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-13T20:00:31Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T15:02:06Z"}, "message": "Collect generic args in type paths\n\nE.g. `let x: A<X>` is handled correctly.", "tree": {"sha": "8f97c863d3fad975312892024587ac02cd483626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f97c863d3fad975312892024587ac02cd483626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "html_url": "https://github.com/rust-lang/rust/commit/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "html_url": "https://github.com/rust-lang/rust/commit/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21"}], "stats": {"total": 108, "additions": 100, "deletions": 8}, "files": [{"sha": "fcde918fb1780e94c552596cd84a4fd27b8b0e1f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 97, "deletions": 5, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "patch": "@@ -38,6 +38,7 @@ use crate::{\n     name::KnownName,\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n     generics::Generics,\n+    path::GenericArg,\n };\n \n /// The ID of a type variable.\n@@ -156,6 +157,12 @@ impl Expectation {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Substs(Arc<[Ty]>);\n \n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs(Arc::new([]))\n+    }\n+}\n+\n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n /// This should be cheap to clone.\n@@ -271,6 +278,9 @@ pub struct FnSig {\n impl Ty {\n     pub(crate) fn from_hir(\n         db: &impl HirDatabase,\n+        // TODO: the next three parameters basically describe the scope for name\n+        // resolution; this should be refactored into something like a general\n+        // resolver architecture\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         generics: &Generics,\n@@ -371,12 +381,79 @@ impl Ty {\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n-            r\n-        } else {\n-            return Ty::Unknown;\n+        let resolved = match module.resolve_path(db, path).take_types() {\n+            Some(r) => r,\n+            None => return Ty::Unknown,\n+        };\n+        let ty = db.type_for_def(resolved);\n+        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, resolved);\n+        ty.apply_substs(substs)\n+    }\n+\n+    /// Collect generic arguments from a path into a `Substs`. See also\n+    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n+    fn substs_from_path(\n+        db: &impl HirDatabase,\n+        // the scope of the segment...\n+        module: &Module,\n+        impl_block: Option<&ImplBlock>,\n+        outer_generics: &Generics,\n+        path: &Path,\n+        resolved: DefId,\n+    ) -> Substs {\n+        let mut substs = Vec::new();\n+        let def = resolved.resolve(db);\n+        let last = path\n+            .segments\n+            .last()\n+            .expect(\"path should have at least one segment\");\n+        let (def_generics, segment) = match def {\n+            Def::Struct(s) => (s.generics(db), last),\n+            Def::Enum(e) => (e.generics(db), last),\n+            Def::Function(f) => (f.generics(db), last),\n+            Def::Trait(t) => (t.generics(db), last),\n+            Def::EnumVariant(ev) => {\n+                // the generic args for an enum variant may be either specified\n+                // on the segment referring to the enum, or on the segment\n+                // referring to the variant. So `Option::<T>::None` and\n+                // `Option::None::<T>` are both allowed (though the former is\n+                // preferred). See also `def_ids_for_path_segments` in rustc.\n+                let len = path.segments.len();\n+                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n+                    // Option::<T>::None\n+                    &path.segments[len - 2]\n+                } else {\n+                    // Option::None::<T>\n+                    last\n+                };\n+                (ev.parent_enum(db).generics(db), segment)\n+            }\n+            _ => return Substs::empty(),\n         };\n-        db.type_for_def(resolved)\n+        // substs_from_path\n+        if let Some(generic_args) = &segment.args_and_bindings {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            let param_count = def_generics.params.len();\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = Ty::from_hir(db, module, impl_block, outer_generics, type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        }\n+        // add placeholders for args that were not provided\n+        // TODO: handle defaults\n+        for _ in segment\n+            .args_and_bindings\n+            .as_ref()\n+            .map(|ga| ga.args.len())\n+            .unwrap_or(0)..def_generics.params.len()\n+        {\n+            substs.push(Ty::Unknown);\n+        }\n+        Substs(substs.into())\n     }\n \n     pub fn unit() -> Self {\n@@ -432,6 +509,21 @@ impl Ty {\n         }\n     }\n \n+    /// If this is a type with type parameters (an ADT or function), replaces\n+    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n+    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n+    /// `Option<u32>` afterwards.)\n+    pub fn apply_substs(self, substs: Substs) -> Ty {\n+        match self {\n+            Ty::Adt { def_id, name, .. } => Ty::Adt {\n+                def_id,\n+                name,\n+                substs,\n+            },\n+            _ => self,\n+        }\n+    }\n+\n     /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n     /// if `self` is `&[T]`, where type parameter T has index 0, and the\n     /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)"}, {"sha": "c6be2a5f566b6bd6dea7a82bf3c89db7cb958044", "filename": "crates/ra_hir/src/ty/tests/data/struct_generics.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt?ref=cc4562ab6ecfced33f5d7a2e428c8caca8f9c3f1", "patch": "@@ -1,8 +1,8 @@\n-[36; 38) 'a1': A<[unknown]>\n+[36; 38) 'a1': A<u32>\n [48; 49) 'i': i32\n [56; 147) '{     ...3.x; }': ()\n-[62; 64) 'a1': A<[unknown]>\n-[62; 66) 'a1.x': [unknown]\n+[62; 64) 'a1': A<u32>\n+[62; 66) 'a1.x': u32\n [76; 78) 'a2': A<i32>\n [81; 91) 'A { x: i }': A<i32>\n [88; 89) 'i': i32"}]}