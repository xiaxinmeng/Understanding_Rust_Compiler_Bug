{"sha": "bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMzNkZDdhYzRkNGZkYzJkMTRjNmRhNGNjZTYyZTgyYTRmOTRmODY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-01T19:26:47Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-16T17:47:23Z"}, "message": "Provide overlapping types for coherence errors\n\nCurrently, a coherence error based on overlapping impls simply mentions\nthe trait, and points to the two conflicting impls:\n\n```\nerror: conflicting implementations for trait `Foo`\n```\n\nWith this commit, the error will include all input types to the\ntrait (including the `Self` type) after unification between the\noverlapping impls. In other words, the error message will provide\nfeedback with full type details, like:\n\n```\nerror: conflicting implementations of trait `Foo<u32>` for type `u8`:\n```\n\nWhen the `Self` type for the two impls unify to an inference variable,\nit is elided in the output, since \"for type `_`\" is just noise in that\ncase.\n\nCloses #23980", "tree": {"sha": "34efcc5e77c2680caaf8b706dee43e52297654ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34efcc5e77c2680caaf8b706dee43e52297654ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "html_url": "https://github.com/rust-lang/rust/commit/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed121aa89780d1495e6a6a215b8e0cf7894a2d24", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed121aa89780d1495e6a6a215b8e0cf7894a2d24", "html_url": "https://github.com/rust-lang/rust/commit/ed121aa89780d1495e6a6a215b8e0cf7894a2d24"}], "stats": {"total": 145, "additions": 95, "deletions": 50}, "files": [{"sha": "cb166fbff05859a00e6a9bdaaddb475c81f17401", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -27,11 +27,12 @@ use syntax::codemap::{DUMMY_SP, Span};\n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n-/// True if there exist types that satisfy both of the two given impls.\n-pub fn overlapping_impls(infcx: &InferCtxt,\n-                         impl1_def_id: DefId,\n-                         impl2_def_id: DefId)\n-                         -> bool\n+/// If there are types that satisfy both impls, returns a `TraitRef`\n+/// with those types substituted (by updating the given `infcx`)\n+pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n+                                    impl1_def_id: DefId,\n+                                    impl2_def_id: DefId)\n+                                    -> Option<ty::TraitRef<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -40,16 +41,15 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n            impl2_def_id);\n \n     let selcx = &mut SelectionContext::intercrate(infcx);\n-    infcx.probe(|_| {\n-        overlap(selcx, impl1_def_id, impl2_def_id)\n-    })\n+    overlap(selcx, impl1_def_id, impl2_def_id)\n }\n \n-/// Can both impl `a` and impl `b` be satisfied by a common type (including `where` clauses)?\n-fn overlap(selcx: &mut SelectionContext,\n-           a_def_id: DefId,\n-           b_def_id: DefId)\n-           -> bool\n+/// Can both impl `a` and impl `b` be satisfied by a common type (including\n+/// `where` clauses)? If so, returns a `TraitRef` that unifies the two impls.\n+fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n+                      a_def_id: DefId,\n+                      b_def_id: DefId)\n+                      -> Option<ty::TraitRef<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n@@ -73,7 +73,7 @@ fn overlap(selcx: &mut SelectionContext,\n                                             TypeOrigin::Misc(DUMMY_SP),\n                                             a_trait_ref,\n                                             b_trait_ref) {\n-        return false;\n+        return None;\n     }\n \n     debug!(\"overlap: unification check succeeded\");\n@@ -88,10 +88,10 @@ fn overlap(selcx: &mut SelectionContext,\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-        return false\n+        return None\n     }\n \n-    true\n+    Some(selcx.infcx().resolve_type_vars_if_possible(&a_trait_ref))\n }\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool"}, {"sha": "90a3b99b71cb3b5a214ca17311e45267e4bfb64b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -65,22 +65,19 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // borrows are safe.\n         let blanket_impls = trait_def.blanket_impls.borrow();\n         let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n-        let trait_def_id = trait_def.trait_ref.def_id;\n \n         // Conflicts can only occur between a blanket impl and another impl,\n         // or between 2 non-blanket impls of the same kind.\n \n         for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n             for &impl2_def_id in &blanket_impls[(i+1)..] {\n-                self.check_if_impls_overlap(trait_def_id,\n-                                            impl1_def_id,\n+                self.check_if_impls_overlap(impl1_def_id,\n                                             impl2_def_id);\n             }\n \n             for v in nonblanket_impls.values() {\n                 for &impl2_def_id in v {\n-                    self.check_if_impls_overlap(trait_def_id,\n-                                                impl1_def_id,\n+                    self.check_if_impls_overlap(impl1_def_id,\n                                                 impl2_def_id);\n                 }\n             }\n@@ -89,8 +86,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         for impl_group in nonblanket_impls.values() {\n             for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n                 for &impl2_def_id in &impl_group[(i+1)..] {\n-                    self.check_if_impls_overlap(trait_def_id,\n-                                                impl1_def_id,\n+                    self.check_if_impls_overlap(impl1_def_id,\n                                                 impl2_def_id);\n                 }\n             }\n@@ -121,40 +117,47 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n \n     fn check_if_impls_overlap(&self,\n-                              trait_def_id: DefId,\n                               impl1_def_id: DefId,\n                               impl2_def_id: DefId)\n     {\n         if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n             impl1_def_id, impl2_def_id)\n         {\n-            debug!(\"check_if_impls_overlap({:?}, {:?}, {:?})\",\n-                   trait_def_id,\n+            debug!(\"check_if_impls_overlap({:?}, {:?})\",\n                    impl1_def_id,\n                    impl2_def_id);\n \n             let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n-            if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n+            if let Some(trait_ref) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(impl1_def_id, impl2_def_id, trait_ref);\n             }\n         }\n     }\n \n-    fn report_overlap_error(&self, trait_def_id: DefId,\n-                            impl1: DefId, impl2: DefId) {\n+    fn report_overlap_error(&self,\n+                            impl1: DefId,\n+                            impl2: DefId,\n+                            trait_ref: ty::TraitRef)\n+    {\n+        // only print the Self type if it's concrete; otherwise, it's not adding much information.\n+        let self_type = {\n+            trait_ref.substs.self_ty().and_then(|ty| {\n+                if let ty::TyInfer(_) = ty.sty {\n+                    None\n+                } else {\n+                    Some(format!(\" for type `{}`\", ty))\n+                }\n+            }).unwrap_or(String::new())\n+        };\n \n         span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n-                  \"conflicting implementations for trait `{}`\",\n-                  self.tcx.item_path_str(trait_def_id));\n-\n-        self.report_overlap_note(impl2);\n-    }\n-\n-    fn report_overlap_note(&self, impl2: DefId) {\n+                  \"conflicting implementations of trait `{}`{}:\",\n+                  trait_ref,\n+                  self_type);\n \n         if impl2.is_local() {\n             span_note!(self.tcx.sess, self.span_of_impl(impl2),\n-                       \"note conflicting implementation here\");\n+                       \"conflicting implementation is here:\");\n         } else {\n             let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n             self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n@@ -180,9 +183,9 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n-                        self.report_overlap_error(trait_ref.def_id,\n-                                                  impl_def_id,\n-                                                  self.tcx.map.local_def_id(prev_id));\n+                        self.report_overlap_error(impl_def_id,\n+                                                  self.tcx.map.local_def_id(prev_id),\n+                                                  trait_ref);\n                     }\n                     None => { }\n                 }"}, {"sha": "8c15892b7e11919edf92f87939eee344e341be32", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -1569,8 +1569,8 @@ struct Foo {\n     value: usize\n }\n \n-impl MyTrait for Foo { // error: conflicting implementations for trait\n-                       //        `MyTrait`\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n     fn get(&self) -> usize { self.value }\n }\n ```"}, {"sha": "344ec89d25de915e58de8021481d9ce2a632df69", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -15,14 +15,14 @@ trait MyTrait {}\n struct TestType<T>(::std::marker::PhantomData<T>);\n \n unsafe impl<T: MyTrait+'static> Send for TestType<T> {}\n-//~^ ERROR conflicting implementations for trait `core::marker::Send`\n-//~^^ ERROR conflicting implementations for trait `core::marker::Send`\n+//~^ ERROR conflicting implementations of trait `core::marker::Send`\n+//~^^ ERROR conflicting implementations of trait `core::marker::Send`\n \n impl<T: MyTrait> !Send for TestType<T> {}\n-//~^ ERROR conflicting implementations for trait `core::marker::Send`\n+//~^ ERROR conflicting implementations of trait `core::marker::Send`\n \n unsafe impl<T:'static> Send for TestType<T> {}\n-//~^ ERROR error: conflicting implementations for trait `core::marker::Send`\n+//~^ ERROR error: conflicting implementations of trait `core::marker::Send`\n \n impl !Send for TestType<i32> {}\n "}, {"sha": "0705702b031ee007b2731320f50b4d4885908fbe", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -15,7 +15,7 @@ trait MyTrait {}\n impl MyTrait for .. {}\n \n impl MyTrait for .. {}\n-//~^ ERROR conflicting implementations for trait `MyTrait`\n+//~^ ERROR conflicting implementations of trait `MyTrait`\n \n trait MySafeTrait {}\n "}, {"sha": "4f1092f960e0d2d41ea5e4f55297992a5a9e57e8", "filename": "src/test/compile-fail/coherence-overlap-messages.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {}\n+\n+impl<T> Foo for T {} //~ ERROR conflicting implementations of trait `Foo`:\n+impl<U> Foo for U {}\n+\n+trait Bar {}\n+\n+impl<T> Bar for T {} //~ ERROR conflicting implementations of trait `Bar` for type `u8`:\n+impl Bar for u8 {}\n+\n+trait Baz<T> {}\n+\n+impl<T, U> Baz<U> for T {} //~ ERROR conflicting implementations of trait `Baz<_>` for type `u8`:\n+impl<T> Baz<T> for u8 {}\n+\n+trait Quux<T> {}\n+\n+impl<T, U> Quux<U> for T {} //~ ERROR conflicting implementations of trait `Quux<_>`:\n+impl<T> Quux<T> for T {}\n+\n+trait Qaar<T> {}\n+\n+impl<T, U> Qaar<U> for T {} //~ ERROR conflicting implementations of trait `Qaar<u8>`:\n+impl<T> Qaar<u8> for T {}\n+\n+trait Qaax<T> {}\n+\n+impl<T, U> Qaax<U> for T {}\n+//~^ ERROR conflicting implementations of trait `Qaax<u8>` for type `u32`:\n+impl Qaax<u8> for u32 {}\n+\n+fn main() {}"}, {"sha": "1dfff144cef98770b8661d782e4c2b231f8213c0", "filename": "src/test/compile-fail/issue-28568.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs?ref=bc33dd7ac4d4fdc2d14c6da4cce62e82a4f94f86", "patch": "@@ -11,12 +11,12 @@\n struct MyStruct;\n \n impl Drop for MyStruct {\n-//~^ ERROR conflicting implementations for trait\n+//~^ ERROR conflicting implementations of trait\n     fn drop(&mut self) { }\n }\n \n impl Drop for MyStruct {\n-//~^ NOTE conflicting implementation here\n+//~^ NOTE conflicting implementation is here\n     fn drop(&mut self) { }\n }\n "}]}