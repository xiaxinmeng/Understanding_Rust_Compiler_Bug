{"sha": "e71440575c930dcecac288b7c3536410d688b351", "node_id": "C_kwDOAAsO6NoAKGU3MTQ0MDU3NWM5MzBkY2VjYWMyODhiN2MzNTM2NDEwZDY4OGIzNTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T18:45:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T18:45:29Z"}, "message": "Auto merge of #97575 - nnethercote:lazify-SourceFile-lines, r=Mark-Simulacrum\n\nLazify `SourceFile::lines`.\n\n`SourceFile::lines` is a big part of metadata. It's stored in a compressed form\n(a difference list) to save disk space. Decoding it is a big fraction of\ncompile time for very small crates/programs.\n\nThis commit introduces a new type `SourceFileLines` which has a `Lines`\nform and a `Diffs` form. The latter is used when the metadata is first\nread, and it is only decoded into the `Lines` form when line data is\nactually needed. This avoids the decoding cost for many files,\nespecially in `std`. It's a performance win of up to 15% for tiny\ncrates/programs where metadata decoding is a high part of compilation\ncosts.\n\nA `RefCell` is needed because the methods that access lines data (which can\ntrigger decoding) take `&self` rather than `&mut self`. To allow for this,\n`SourceFile::lines` now takes a `FnMut` that operates on the lines slice rather\nthan returning the lines slice.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "009840d3cb89bbf75355bfb5a04b74356c5d5db4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/009840d3cb89bbf75355bfb5a04b74356c5d5db4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e71440575c930dcecac288b7c3536410d688b351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e71440575c930dcecac288b7c3536410d688b351", "html_url": "https://github.com/rust-lang/rust/commit/e71440575c930dcecac288b7c3536410d688b351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e71440575c930dcecac288b7c3536410d688b351/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44e9516c8535c6f41f2d1c444657cd672b4ab81b", "url": "https://api.github.com/repos/rust-lang/rust/commits/44e9516c8535c6f41f2d1c444657cd672b4ab81b", "html_url": "https://github.com/rust-lang/rust/commit/44e9516c8535c6f41f2d1c444657cd672b4ab81b"}, {"sha": "72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "html_url": "https://github.com/rust-lang/rust/commit/72de7c41028cf0fc3d373652dc9bd9292f13a1b0"}], "stats": {"total": 362, "additions": 239, "deletions": 123}, "files": [{"sha": "5a915933dc5b98b80986161eee5166a4c3f21c9d", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -713,7 +713,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n         let len = BytePos::decode(decoder);\n \n         let file_lo = decoder.file_index_to_file(file_lo_index);\n-        let lo = file_lo.lines[line_lo - 1] + col_lo;\n+        let lo = file_lo.lines(|lines| lines[line_lo - 1] + col_lo);\n         let hi = lo + len;\n \n         Span::new(lo, hi, ctxt, parent)"}, {"sha": "1fa085926767d3402186f0042dea533c6cc0e680", "filename": "compiler/rustc_query_system/src/ich/impls_syntax.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -69,7 +69,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             external_src: _,\n             start_pos,\n             end_pos: _,\n-            ref lines,\n+            lines: _,\n             ref multibyte_chars,\n             ref non_narrow_chars,\n             ref normalized_pos,\n@@ -79,11 +79,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n \n         src_hash.hash_stable(hcx, hasher);\n \n-        // We only hash the relative position within this source_file\n-        lines.len().hash_stable(hcx, hasher);\n-        for &line in lines.iter() {\n-            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-        }\n+        // We are always in `Lines` form by the time we reach here.\n+        assert!(self.lines.borrow().is_lines());\n+        self.lines(|lines| {\n+            // We only hash the relative position within this source_file\n+            lines.len().hash_stable(hcx, hasher);\n+            for &line in lines.iter() {\n+                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+            }\n+        });\n \n         // We only hash the relative position within this source_file\n         multibyte_chars.len().hash_stable(hcx, hasher);"}, {"sha": "6805d212f0b27dddbc058767541d1acd3fd89503", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 193, "deletions": 94, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -1222,6 +1222,52 @@ impl DebuggerVisualizerFile {\n     }\n }\n \n+#[derive(Clone)]\n+pub enum SourceFileLines {\n+    /// The source file lines, in decoded (random-access) form.\n+    Lines(Vec<BytePos>),\n+\n+    /// The source file lines, in undecoded difference list form.\n+    Diffs(SourceFileDiffs),\n+}\n+\n+impl SourceFileLines {\n+    pub fn is_lines(&self) -> bool {\n+        matches!(self, SourceFileLines::Lines(_))\n+    }\n+}\n+\n+/// The source file lines in difference list form. This matches the form\n+/// used within metadata, which saves space by exploiting the fact that the\n+/// lines list is sorted and individual lines are usually not that long.\n+///\n+/// We read it directly from metadata and only decode it into `Lines` form\n+/// when necessary. This is a significant performance win, especially for\n+/// small crates where very little of `std`'s metadata is used.\n+#[derive(Clone)]\n+pub struct SourceFileDiffs {\n+    /// Position of the first line. Note that this is always encoded as a\n+    /// `BytePos` because it is often much larger than any of the\n+    /// differences.\n+    line_start: BytePos,\n+\n+    /// Always 1, 2, or 4. Always as small as possible, while being big\n+    /// enough to hold the length of the longest line in the source file.\n+    /// The 1 case is by far the most common.\n+    bytes_per_diff: usize,\n+\n+    /// The number of diffs encoded in `raw_diffs`. Always one less than\n+    /// the number of lines in the source file.\n+    num_diffs: usize,\n+\n+    /// The diffs in \"raw\" form. Each segment of `bytes_per_diff` length\n+    /// encodes one little-endian diff. Note that they aren't LEB128\n+    /// encoded. This makes for much faster decoding. Besides, the\n+    /// bytes_per_diff==1 case is by far the most common, and LEB128\n+    /// encoding has no effect on that case.\n+    raw_diffs: Vec<u8>,\n+}\n+\n /// A single source in the [`SourceMap`].\n #[derive(Clone)]\n pub struct SourceFile {\n@@ -1241,7 +1287,7 @@ pub struct SourceFile {\n     /// The end position of this source in the `SourceMap`.\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code.\n-    pub lines: Vec<BytePos>,\n+    pub lines: Lock<SourceFileLines>,\n     /// Locations of multi-byte characters in the source code.\n     pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code.\n@@ -1262,64 +1308,66 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n             s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", false, |s| {\n-                let lines = &self.lines[..];\n-                // Store the length.\n-                s.emit_u32(lines.len() as u32)?;\n-\n-                if !lines.is_empty() {\n-                    // In order to preserve some space, we exploit the fact that\n-                    // the lines list is sorted and individual lines are\n-                    // probably not that long. Because of that we can store lines\n-                    // as a difference list, using as little space as possible\n-                    // for the differences. But note that the first line is\n-                    // always encoded as a `BytePos` because its position is\n-                    // often much larger than any of the differences.\n-                    let max_line_length = if lines.len() == 1 {\n-                        0\n-                    } else {\n-                        lines\n-                            .array_windows()\n-                            .map(|&[fst, snd]| snd - fst)\n-                            .map(|bp| bp.to_usize())\n-                            .max()\n-                            .unwrap()\n-                    };\n-\n-                    let bytes_per_diff: u8 = match max_line_length {\n-                        0..=0xFF => 1,\n-                        0x100..=0xFFFF => 2,\n-                        _ => 4,\n-                    };\n-\n-                    // Encode the number of bytes used per diff.\n-                    bytes_per_diff.encode(s)?;\n-\n-                    // Encode the first element.\n-                    lines[0].encode(s)?;\n-\n-                    let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n-\n-                    match bytes_per_diff {\n-                        1 => {\n-                            for diff in diff_iter {\n-                                (diff.0 as u8).encode(s)?\n+                // We are always in `Lines` form by the time we reach here.\n+                assert!(self.lines.borrow().is_lines());\n+                self.lines(|lines| {\n+                    // Store the length.\n+                    s.emit_u32(lines.len() as u32)?;\n+\n+                    // Compute and store the difference list.\n+                    if lines.len() != 0 {\n+                        let max_line_length = if lines.len() == 1 {\n+                            0\n+                        } else {\n+                            lines\n+                                .array_windows()\n+                                .map(|&[fst, snd]| snd - fst)\n+                                .map(|bp| bp.to_usize())\n+                                .max()\n+                                .unwrap()\n+                        };\n+\n+                        let bytes_per_diff: usize = match max_line_length {\n+                            0..=0xFF => 1,\n+                            0x100..=0xFFFF => 2,\n+                            _ => 4,\n+                        };\n+\n+                        // Encode the number of bytes used per diff.\n+                        s.emit_u8(bytes_per_diff as u8)?;\n+\n+                        // Encode the first element.\n+                        lines[0].encode(s)?;\n+\n+                        // Encode the difference list.\n+                        let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);\n+                        let num_diffs = lines.len() - 1;\n+                        let mut raw_diffs;\n+                        match bytes_per_diff {\n+                            1 => {\n+                                raw_diffs = Vec::with_capacity(num_diffs);\n+                                for diff in diff_iter {\n+                                    raw_diffs.push(diff.0 as u8);\n+                                }\n                             }\n-                        }\n-                        2 => {\n-                            for diff in diff_iter {\n-                                (diff.0 as u16).encode(s)?\n+                            2 => {\n+                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                                for diff in diff_iter {\n+                                    raw_diffs.extend_from_slice(&(diff.0 as u16).to_le_bytes());\n+                                }\n                             }\n-                        }\n-                        4 => {\n-                            for diff in diff_iter {\n-                                diff.0.encode(s)?\n+                            4 => {\n+                                raw_diffs = Vec::with_capacity(bytes_per_diff * num_diffs);\n+                                for diff in diff_iter {\n+                                    raw_diffs.extend_from_slice(&(diff.0 as u32).to_le_bytes());\n+                                }\n                             }\n+                            _ => unreachable!(),\n                         }\n-                        _ => unreachable!(),\n+                        s.emit_raw_bytes(&raw_diffs)?;\n                     }\n-                }\n-\n-                Ok(())\n+                    Ok(())\n+                })\n             })?;\n             s.emit_struct_field(\"multibyte_chars\", false, |s| self.multibyte_chars.encode(s))?;\n             s.emit_struct_field(\"non_narrow_chars\", false, |s| self.non_narrow_chars.encode(s))?;\n@@ -1336,36 +1384,27 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n         let src_hash: SourceFileHash = Decodable::decode(d);\n         let start_pos: BytePos = Decodable::decode(d);\n         let end_pos: BytePos = Decodable::decode(d);\n-        let lines: Vec<BytePos> = {\n+        let lines = {\n             let num_lines: u32 = Decodable::decode(d);\n-            let mut lines = Vec::with_capacity(num_lines as usize);\n-\n             if num_lines > 0 {\n                 // Read the number of bytes used per diff.\n-                let bytes_per_diff: u8 = Decodable::decode(d);\n+                let bytes_per_diff = d.read_u8() as usize;\n \n                 // Read the first element.\n-                let mut line_start: BytePos = Decodable::decode(d);\n-                lines.push(line_start);\n-\n-                match bytes_per_diff {\n-                    1 => lines.extend((1..num_lines).map(|_| {\n-                        line_start = line_start + BytePos(d.read_u8() as u32);\n-                        line_start\n-                    })),\n-                    2 => lines.extend((1..num_lines).map(|_| {\n-                        line_start = line_start + BytePos(d.read_u16() as u32);\n-                        line_start\n-                    })),\n-                    4 => lines.extend((1..num_lines).map(|_| {\n-                        line_start = line_start + BytePos(d.read_u32());\n-                        line_start\n-                    })),\n-                    _ => unreachable!(),\n-                }\n+                let line_start: BytePos = Decodable::decode(d);\n+\n+                // Read the difference list.\n+                let num_diffs = num_lines as usize - 1;\n+                let raw_diffs = d.read_raw_bytes(bytes_per_diff * num_diffs).to_vec();\n+                SourceFileLines::Diffs(SourceFileDiffs {\n+                    line_start,\n+                    bytes_per_diff,\n+                    num_diffs,\n+                    raw_diffs,\n+                })\n+            } else {\n+                SourceFileLines::Lines(vec![])\n             }\n-\n-            lines\n         };\n         let multibyte_chars: Vec<MultiByteChar> = Decodable::decode(d);\n         let non_narrow_chars: Vec<NonNarrowChar> = Decodable::decode(d);\n@@ -1381,7 +1420,7 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n             // Unused - the metadata decoder will construct\n             // a new SourceFile, filling in `external_src` properly\n             external_src: Lock::new(ExternalSource::Unneeded),\n-            lines,\n+            lines: Lock::new(lines),\n             multibyte_chars,\n             non_narrow_chars,\n             normalized_pos,\n@@ -1426,7 +1465,7 @@ impl SourceFile {\n             external_src: Lock::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),\n-            lines,\n+            lines: Lock::new(SourceFileLines::Lines(lines)),\n             multibyte_chars,\n             non_narrow_chars,\n             normalized_pos,\n@@ -1435,10 +1474,68 @@ impl SourceFile {\n         }\n     }\n \n+    pub fn lines<F, R>(&self, f: F) -> R\n+    where\n+        F: FnOnce(&[BytePos]) -> R,\n+    {\n+        let mut guard = self.lines.borrow_mut();\n+        match &*guard {\n+            SourceFileLines::Lines(lines) => f(lines),\n+            SourceFileLines::Diffs(SourceFileDiffs {\n+                mut line_start,\n+                bytes_per_diff,\n+                num_diffs,\n+                raw_diffs,\n+            }) => {\n+                // Convert from \"diffs\" form to \"lines\" form.\n+                let num_lines = num_diffs + 1;\n+                let mut lines = Vec::with_capacity(num_lines);\n+                lines.push(line_start);\n+\n+                assert_eq!(*num_diffs, raw_diffs.len() / bytes_per_diff);\n+                match bytes_per_diff {\n+                    1 => {\n+                        lines.extend(raw_diffs.into_iter().map(|&diff| {\n+                            line_start = line_start + BytePos(diff as u32);\n+                            line_start\n+                        }));\n+                    }\n+                    2 => {\n+                        lines.extend((0..*num_diffs).map(|i| {\n+                            let pos = bytes_per_diff * i;\n+                            let bytes = [raw_diffs[pos], raw_diffs[pos + 1]];\n+                            let diff = u16::from_le_bytes(bytes);\n+                            line_start = line_start + BytePos(diff as u32);\n+                            line_start\n+                        }));\n+                    }\n+                    4 => {\n+                        lines.extend((0..*num_diffs).map(|i| {\n+                            let pos = bytes_per_diff * i;\n+                            let bytes = [\n+                                raw_diffs[pos],\n+                                raw_diffs[pos + 1],\n+                                raw_diffs[pos + 2],\n+                                raw_diffs[pos + 3],\n+                            ];\n+                            let diff = u32::from_le_bytes(bytes);\n+                            line_start = line_start + BytePos(diff);\n+                            line_start\n+                        }));\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                let res = f(&lines);\n+                *guard = SourceFileLines::Lines(lines);\n+                res\n+            }\n+        }\n+    }\n+\n     /// Returns the `BytePos` of the beginning of the current line.\n     pub fn line_begin_pos(&self, pos: BytePos) -> BytePos {\n         let line_index = self.lookup_line(pos).unwrap();\n-        self.lines[line_index]\n+        self.lines(|lines| lines[line_index])\n     }\n \n     /// Add externally loaded source.\n@@ -1495,8 +1592,8 @@ impl SourceFile {\n         }\n \n         let begin = {\n-            let line = self.lines.get(line_number)?;\n-            let begin: BytePos = *line - self.start_pos;\n+            let line = self.lines(|lines| lines.get(line_number).copied())?;\n+            let begin: BytePos = line - self.start_pos;\n             begin.to_usize()\n         };\n \n@@ -1518,32 +1615,34 @@ impl SourceFile {\n     }\n \n     pub fn count_lines(&self) -> usize {\n-        self.lines.len()\n+        self.lines(|lines| lines.len())\n     }\n \n     /// Finds the line containing the given position. The return value is the\n     /// index into the `lines` array of this `SourceFile`, not the 1-based line\n     /// number. If the source_file is empty or the position is located before the\n     /// first line, `None` is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n-        match self.lines.binary_search(&pos) {\n+        self.lines(|lines| match lines.binary_search(&pos) {\n             Ok(idx) => Some(idx),\n             Err(0) => None,\n             Err(idx) => Some(idx - 1),\n-        }\n+        })\n     }\n \n     pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {\n         if self.is_empty() {\n             return self.start_pos..self.end_pos;\n         }\n \n-        assert!(line_index < self.lines.len());\n-        if line_index == (self.lines.len() - 1) {\n-            self.lines[line_index]..self.end_pos\n-        } else {\n-            self.lines[line_index]..self.lines[line_index + 1]\n-        }\n+        self.lines(|lines| {\n+            assert!(line_index < lines.len());\n+            if line_index == (lines.len() - 1) {\n+                lines[line_index]..self.end_pos\n+            } else {\n+                lines[line_index]..lines[line_index + 1]\n+            }\n+        })\n     }\n \n     /// Returns whether or not the file contains the given `SourceMap` byte\n@@ -1605,7 +1704,7 @@ impl SourceFile {\n         match self.lookup_line(pos) {\n             Some(a) => {\n                 let line = a + 1; // Line numbers start at 1\n-                let linebpos = self.lines[a];\n+                let linebpos = self.lines(|lines| lines[a]);\n                 let linechpos = self.bytepos_to_file_charpos(linebpos);\n                 let col = chpos - linechpos;\n                 debug!(\"byte pos {:?} is on the line at byte pos {:?}\", pos, linebpos);\n@@ -1624,7 +1723,7 @@ impl SourceFile {\n         let (line, col_or_chpos) = self.lookup_file_pos(pos);\n         if line > 0 {\n             let col = col_or_chpos;\n-            let linebpos = self.lines[line - 1];\n+            let linebpos = self.lines(|lines| lines[line - 1]);\n             let col_display = {\n                 let start_width_idx = self\n                     .non_narrow_chars"}, {"sha": "95ea7029617014715e25efe520be80e6ae7aa9fc", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -331,7 +331,7 @@ impl SourceMap {\n         name_hash: u128,\n         source_len: usize,\n         cnum: CrateNum,\n-        mut file_local_lines: Vec<BytePos>,\n+        file_local_lines: Lock<SourceFileLines>,\n         mut file_local_multibyte_chars: Vec<MultiByteChar>,\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n@@ -355,8 +355,15 @@ impl SourceMap {\n         // form rather than pre-computing the offset into a local variable. The\n         // compiler backend can optimize away the repeated computations in a\n         // way that won't trigger overflow checks.\n-        for pos in &mut file_local_lines {\n-            *pos = (*pos - original_start_pos) + start_pos;\n+        match &mut *file_local_lines.borrow_mut() {\n+            SourceFileLines::Lines(lines) => {\n+                for pos in lines {\n+                    *pos = (*pos - original_start_pos) + start_pos;\n+                }\n+            }\n+            SourceFileLines::Diffs(SourceFileDiffs { line_start, .. }) => {\n+                *line_start = (*line_start - original_start_pos) + start_pos;\n+            }\n         }\n         for mbc in &mut file_local_multibyte_chars {\n             mbc.pos = (mbc.pos - original_start_pos) + start_pos;"}, {"sha": "5b3915c33387bb18689b48f31f59ff4d8353d117", "filename": "compiler/rustc_span/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/compiler%2Frustc_span%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Ftests.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -5,7 +5,7 @@ fn test_lookup_line() {\n     let source = \"abcdefghijklm\\nabcdefghij\\n...\".to_owned();\n     let sf =\n         SourceFile::new(FileName::Anon(0), source, BytePos(3), SourceFileHashAlgorithm::Sha256);\n-    assert_eq!(sf.lines.as_slice(), &[BytePos(3), BytePos(17), BytePos(28)]);\n+    sf.lines(|lines| assert_eq!(lines, &[BytePos(3), BytePos(17), BytePos(28)]));\n \n     assert_eq!(sf.lookup_line(BytePos(0)), None);\n     assert_eq!(sf.lookup_line(BytePos(3)), Some(0));"}, {"sha": "025dd57e83aa59ccfe8e7da39f19ef6521597c4b", "filename": "src/tools/clippy/clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -187,11 +187,13 @@ fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n                 && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n                 && let Some(src) = unsafe_line.sf.src.as_deref()\n             {\n-                comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n-                    src,\n-                    &unsafe_line.sf.lines[comment_start_line.line + 1..=unsafe_line.line],\n-                    unsafe_line.sf.start_pos.to_usize(),\n-                )\n+                unsafe_line.sf.lines(|lines| {\n+                    comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n+                        src,\n+                        &lines[comment_start_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    )\n+                })\n             } else {\n                 // Problem getting source text. Pretend a comment was found.\n                 true\n@@ -249,11 +251,13 @@ fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span\n             && Lrc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n         {\n-            macro_line.line < unsafe_line.line && text_has_safety_comment(\n-                src,\n-                &unsafe_line.sf.lines[macro_line.line + 1..=unsafe_line.line],\n-                unsafe_line.sf.start_pos.to_usize(),\n-            )\n+            unsafe_line.sf.lines(|lines| {\n+                macro_line.line < unsafe_line.line && text_has_safety_comment(\n+                    src,\n+                    &lines[macro_line.line + 1..=unsafe_line.line],\n+                    unsafe_line.sf.start_pos.to_usize(),\n+                )\n+            })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n             true\n@@ -276,11 +280,13 @@ fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n             // Get the text from the start of function body to the unsafe block.\n             //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n             //              ^-------------^\n-            body_line.line < unsafe_line.line && text_has_safety_comment(\n-                src,\n-                &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n-                unsafe_line.sf.start_pos.to_usize(),\n-            )\n+            unsafe_line.sf.lines(|lines| {\n+                body_line.line < unsafe_line.line && text_has_safety_comment(\n+                    src,\n+                    &lines[body_line.line + 1..=unsafe_line.line],\n+                    unsafe_line.sf.start_pos.to_usize(),\n+                )\n+            })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n             true"}, {"sha": "39595f589c70be77c832047d11c4e655a8d893a0", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -283,10 +283,10 @@ pub fn span_lint_and_sugg_for_edges(\n             {\n                 let split_idx = MAX_SUGGESTION_HIGHLIGHT_LINES / 2;\n                 let span_upper = sm.span_until_char(\n-                    sp.with_hi(line_upper.sf.lines[line_upper.line + split_idx]),\n+                    sp.with_hi(line_upper.sf.lines(|lines| lines[line_upper.line + split_idx])),\n                     '\\n',\n                 );\n-                let span_bottom = sp.with_lo(line_bottom.sf.lines[line_bottom.line - split_idx]);\n+                let span_bottom = sp.with_lo(line_bottom.sf.lines(|lines| lines[line_bottom.line - split_idx]));\n \n                 let sugg_lines_vec = sugg.lines().collect::<Vec<&str>>();\n                 let sugg_upper = sugg_lines_vec[..split_idx].join(\"\\n\");"}, {"sha": "833f8cde63abaa94d35849a0121ea85bd2f2460b", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71440575c930dcecac288b7c3536410d688b351/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=e71440575c930dcecac288b7c3536410d688b351", "patch": "@@ -1149,7 +1149,7 @@ fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n     let span = original_sp(span, DUMMY_SP);\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n     let line_no = source_map_and_line.line;\n-    let line_start = source_map_and_line.sf.lines[line_no];\n+    let line_start = source_map_and_line.sf.lines(|lines| lines[line_no]);\n     span.with_lo(line_start)\n }\n "}]}