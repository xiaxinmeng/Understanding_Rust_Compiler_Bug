{"sha": "615848339b0b4fd3bf6e41b4d1661cd17211fe54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNTg0ODMzOWIwYjRmZDNiZjZlNDFiNGQxNjYxY2QxNzIxMWZlNTQ=", "commit": {"author": {"name": "Erik Johnston", "email": "erikj@jki.re", "date": "2016-04-07T18:53:19Z"}, "committer": {"name": "Erik Johnston", "email": "erikj@jki.re", "date": "2016-04-07T18:53:19Z"}, "message": "Merge branch 'master' of github.com:nrc/rustfmt into fn_arg_one_line", "tree": {"sha": "cb7e227a9c9054f5867dc790ff521a1fe4a6cfcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7e227a9c9054f5867dc790ff521a1fe4a6cfcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/615848339b0b4fd3bf6e41b4d1661cd17211fe54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/615848339b0b4fd3bf6e41b4d1661cd17211fe54", "html_url": "https://github.com/rust-lang/rust/commit/615848339b0b4fd3bf6e41b4d1661cd17211fe54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/615848339b0b4fd3bf6e41b4d1661cd17211fe54/comments", "author": {"login": "erikjohnston", "id": 8428120, "node_id": "MDQ6VXNlcjg0MjgxMjA=", "avatar_url": "https://avatars.githubusercontent.com/u/8428120?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikjohnston", "html_url": "https://github.com/erikjohnston", "followers_url": "https://api.github.com/users/erikjohnston/followers", "following_url": "https://api.github.com/users/erikjohnston/following{/other_user}", "gists_url": "https://api.github.com/users/erikjohnston/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikjohnston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikjohnston/subscriptions", "organizations_url": "https://api.github.com/users/erikjohnston/orgs", "repos_url": "https://api.github.com/users/erikjohnston/repos", "events_url": "https://api.github.com/users/erikjohnston/events{/privacy}", "received_events_url": "https://api.github.com/users/erikjohnston/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikjohnston", "id": 8428120, "node_id": "MDQ6VXNlcjg0MjgxMjA=", "avatar_url": "https://avatars.githubusercontent.com/u/8428120?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikjohnston", "html_url": "https://github.com/erikjohnston", "followers_url": "https://api.github.com/users/erikjohnston/followers", "following_url": "https://api.github.com/users/erikjohnston/following{/other_user}", "gists_url": "https://api.github.com/users/erikjohnston/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikjohnston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikjohnston/subscriptions", "organizations_url": "https://api.github.com/users/erikjohnston/orgs", "repos_url": "https://api.github.com/users/erikjohnston/repos", "events_url": "https://api.github.com/users/erikjohnston/events{/privacy}", "received_events_url": "https://api.github.com/users/erikjohnston/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57847e451af3d0057f36f61c357f5c451b4ac7ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/57847e451af3d0057f36f61c357f5c451b4ac7ed", "html_url": "https://github.com/rust-lang/rust/commit/57847e451af3d0057f36f61c357f5c451b4ac7ed"}, {"sha": "c59d96a747e4d6d6391ece2d50ee3d88e878282d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c59d96a747e4d6d6391ece2d50ee3d88e878282d", "html_url": "https://github.com/rust-lang/rust/commit/c59d96a747e4d6d6391ece2d50ee3d88e878282d"}], "stats": {"total": 285, "additions": 179, "deletions": 106}, "files": [{"sha": "b65cbaa7f59c866309f240c41ac9309ecc7f644b", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -10,14 +10,14 @@\n \n #![cfg(not(test))]\n \n-#[macro_use]\n+\n extern crate log;\n extern crate rustfmt;\n extern crate toml;\n extern crate env_logger;\n extern crate getopts;\n \n-use rustfmt::{run, run_from_stdin};\n+use rustfmt::{run, Input};\n use rustfmt::config::{Config, WriteMode};\n \n use std::env;\n@@ -28,14 +28,6 @@ use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n-macro_rules! msg {\n-    ($($arg:tt)*) => (\n-        match writeln!(&mut ::std::io::stderr(), $($arg)* ) {\n-            Ok(_) => {},\n-            Err(x) => panic!(\"Unable to write to stderr: {}\", x),\n-        }\n-    )\n-}\n \n /// Rustfmt operations.\n enum Operation {\n@@ -197,7 +189,7 @@ fn execute() -> i32 {\n             // write_mode is always Plain for Stdin.\n             config.write_mode = WriteMode::Plain;\n \n-            run_from_stdin(input, &config);\n+            run(Input::Text(input), &config);\n             0\n         }\n         Operation::Format { files, config_path } => {\n@@ -212,7 +204,7 @@ fn execute() -> i32 {\n                 path = path_tmp;\n             };\n             if let Some(path) = path.as_ref() {\n-                msg!(\"Using rustfmt config file {}\", path.display());\n+                println!(\"Using rustfmt config file {}\", path.display());\n             }\n             for file in files {\n                 // Check the file directory if the config-path could not be read or not provided\n@@ -222,9 +214,9 @@ fn execute() -> i32 {\n                                                                        for {}\",\n                                                                       file.display()));\n                     if let Some(path) = path_tmp.as_ref() {\n-                        msg!(\"Using rustfmt config file {} for {}\",\n-                             path.display(),\n-                             file.display());\n+                        println!(\"Using rustfmt config file {} for {}\",\n+                                 path.display(),\n+                                 file.display());\n                     }\n                     config = config_tmp;\n                 }\n@@ -233,7 +225,7 @@ fn execute() -> i32 {\n                     print_usage(&opts, &e);\n                     return 1;\n                 }\n-                run(&file, &config);\n+                run(Input::File(file), &config);\n             }\n             0\n         }"}, {"sha": "3c426b8803308ce765d192f3501e9471f367ba32", "filename": "src/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -11,6 +11,7 @@\n extern crate toml;\n \n use lists::{SeparatorTactic, ListTactic};\n+use std::io::Write;\n \n macro_rules! configuration_option_enum{\n     ($e:ident: $( $x:ident ),+ $(,)*) => {\n@@ -45,7 +46,7 @@ configuration_option_enum! { ReturnIndent:\n     WithWhereClause,\n }\n \n-// How to stle a struct literal.\n+// How to style a struct literal.\n configuration_option_enum! { StructLitStyle:\n     // First line on the same line as the opening brace, all lines aligned with\n     // the first line.\n@@ -222,9 +223,9 @@ macro_rules! create_config {\n                 let parsed_config:ParsedConfig = match toml::decode(parsed) {\n                     Some(decoded) => decoded,\n                     None => {\n-                        println!(\"Decoding config file failed. Config:\\n{}\", toml);\n+                        msg!(\"Decoding config file failed. Config:\\n{}\", toml);\n                         let parsed: toml::Value = toml.parse().expect(\"Could not parse TOML\");\n-                        println!(\"\\n\\nParsed:\\n{:?}\", parsed);\n+                        msg!(\"\\n\\nParsed:\\n{:?}\", parsed);\n                         panic!();\n                     }\n                 };"}, {"sha": "c6af9a7018486b15e0563773cab147a2946566ef", "filename": "src/filemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -31,14 +31,14 @@ pub fn append_newlines(file_map: &mut FileMap) {\n     }\n }\n \n-pub fn write_all_files<T>(file_map: &FileMap, mut out: T, config: &Config) -> Result<(), io::Error>\n+pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> Result<(), io::Error>\n     where T: Write\n {\n-    output_header(&mut out, config.write_mode).ok();\n+    output_header(out, config.write_mode).ok();\n     for filename in file_map.keys() {\n-        try!(write_file(&file_map[filename], filename, &mut out, config));\n+        try!(write_file(&file_map[filename], filename, out, config));\n     }\n-    output_footer(&mut out, config.write_mode).ok();\n+    output_footer(out, config.write_mode).ok();\n \n     Ok(())\n }\n@@ -80,11 +80,11 @@ pub fn write_system_newlines<T>(writer: T,\n     }\n }\n \n-pub fn write_file<T>(text: &StringBuffer,\n-                     filename: &str,\n-                     out: &mut T,\n-                     config: &Config)\n-                     -> Result<Option<String>, io::Error>\n+fn write_file<T>(text: &StringBuffer,\n+                 filename: &str,\n+                 out: &mut T,\n+                 config: &Config)\n+                 -> Result<Option<String>, io::Error>\n     where T: Write\n {\n "}, {"sha": "b7af96ac5aa4fb5328d30237aefcb1897e870fd2", "filename": "src/lib.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -31,17 +31,17 @@ use syntax::errors::Handler;\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::parse::{self, ParseSess};\n \n-use std::io::stdout;\n+use std::io::{stdout, Write};\n use std::ops::{Add, Sub};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::collections::HashMap;\n use std::fmt;\n \n use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n use visitor::FmtVisitor;\n-use config::Config;\n+use config::{Config, WriteMode};\n \n #[macro_use]\n mod utils;\n@@ -287,7 +287,7 @@ fn fmt_ast(krate: &ast::Crate,\n // Formatting done on a char by char or line by line basis.\n // TODO(#209) warn on bad license\n // TODO(#20) other stuff for parity with make tidy\n-pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n+fn format_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };\n \n@@ -367,7 +367,7 @@ pub fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     report\n }\n \n-pub fn format_string(input: String, config: &Config) -> FileMap {\n+fn format_string(input: String, config: &Config) -> FileMap {\n     let path = \"stdin\";\n     let codemap = Rc::new(CodeMap::new());\n \n@@ -403,7 +403,7 @@ pub fn format_string(input: String, config: &Config) -> FileMap {\n     file_map\n }\n \n-pub fn format(file: &Path, config: &Config) -> FileMap {\n+fn format_file(file: &Path, config: &Config) -> FileMap {\n     let codemap = Rc::new(CodeMap::new());\n \n     let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n@@ -428,27 +428,35 @@ pub fn format(file: &Path, config: &Config) -> FileMap {\n     file_map\n }\n \n-pub fn run(file: &Path, config: &Config) {\n-    let mut result = format(file, config);\n+pub fn format_input(input: Input, config: &Config) -> (FileMap, FormatReport) {\n+    let mut file_map = match input {\n+        Input::File(ref file) => format_file(file, config),\n+        Input::Text(text) => format_string(text, config),\n+    };\n \n-    print!(\"{}\", fmt_lines(&mut result, config));\n-    let out = stdout();\n-    let write_result = filemap::write_all_files(&result, out, config);\n+    let report = format_lines(&mut file_map, config);\n+    (file_map, report)\n+}\n \n-    if let Err(msg) = write_result {\n-        println!(\"Error writing files: {}\", msg);\n-    }\n+pub enum Input {\n+    File(PathBuf),\n+    Text(String),\n }\n \n-// Similar to run, but takes an input String instead of a file to format\n-pub fn run_from_stdin(input: String, config: &Config) {\n-    let mut result = format_string(input, config);\n-    fmt_lines(&mut result, config);\n+pub fn run(input: Input, config: &Config) {\n+    let (file_map, report) = format_input(input, config);\n+\n+    let ignore_errors = config.write_mode == WriteMode::Plain;\n+    if !ignore_errors {\n+        print!(\"{}\", report);\n+    }\n \n     let mut out = stdout();\n-    let write_result = filemap::write_file(&result[\"stdin\"], \"stdin\", &mut out, config);\n+    let write_result = filemap::write_all_files(&file_map, &mut out, config);\n \n     if let Err(msg) = write_result {\n-        panic!(\"Error writing to stdout: {}\", msg);\n+        if !ignore_errors {\n+            msg!(\"Error writing files: {}\", msg);\n+        }\n     }\n }"}, {"sha": "66b9880777f94cb16a4c69942f46f1025f0b48dc", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -232,6 +232,16 @@ macro_rules! try_opt {\n     })\n }\n \n+macro_rules! msg {\n+    ($($arg:tt)*) => (\n+        match writeln!(&mut ::std::io::stderr(), $($arg)* ) {\n+            Ok(_) => {},\n+            Err(x) => panic!(\"Unable to write to stderr: {}\", x),\n+        }\n+    )\n+}\n+\n+\n // Wraps string-like values in an Option. Returns Some when the string adheres\n // to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Indent) -> Option<S> {"}, {"sha": "e79557af713e511b792d078dea66aa975bf7f6b2", "filename": "tests/coverage/source/comments.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fcoverage%2Fsource%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fcoverage%2Fsource%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcoverage%2Fsource%2Fcomments.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -1,3 +1,4 @@\n+// rustfmt-write_mode: coverage\n /// Here's a doc comment!\n fn main() {\n     // foo is bar", "previous_filename": "tests/coverage-source/comments.rs"}, {"sha": "8f9c223aef29c678aa42f4c1b8bde9a54cc050a5", "filename": "tests/coverage/target/comments.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fcoverage%2Ftarget%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fcoverage%2Ftarget%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcoverage%2Ftarget%2Fcomments.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -1,3 +1,4 @@\n+XX XXXXXXXXXXXXXXXXXXX XXXXXXXX\n /// Here's a doc comment!\n fn main() {\n     XX XXX XX XXX", "previous_filename": "tests/coverage-target/comments.rs"}, {"sha": "ef3486b0bdcef4f94ad0f19de79a073e57881028", "filename": "tests/system.rs", "status": "modified", "additions": 36, "deletions": 56, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -16,11 +16,11 @@ extern crate term;\n use std::collections::HashMap;\n use std::fs;\n use std::io::{self, Read, BufRead, BufReader};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use rustfmt::*;\n use rustfmt::filemap::{write_system_newlines, FileMap};\n-use rustfmt::config::{Config, ReportTactic, WriteMode};\n+use rustfmt::config::{Config, ReportTactic};\n use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n@@ -44,7 +44,7 @@ fn system_tests() {\n     // Turn a DirEntry into a String that represents the relative path to the\n     // file.\n     let files = files.map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, None);\n+    let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n     println!(\"Ran {} system tests.\", count);\n@@ -55,31 +55,27 @@ fn system_tests() {\n // the only difference is the coverage mode\n #[test]\n fn coverage_tests() {\n-    let files = fs::read_dir(\"tests/coverage-source\").expect(\"Couldn't read source dir\");\n+    let files = fs::read_dir(\"tests/coverage/source\").expect(\"Couldn't read source dir\");\n     let files = files.map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, Some(WriteMode::Coverage));\n+    let (_reports, count, fails) = check_files(files);\n \n     println!(\"Ran {} tests in coverage mode.\", count);\n     assert!(fails == 0, \"{} tests failed\", fails);\n }\n \n #[test]\n fn checkstyle_test() {\n-    let filename = \"tests/source/fn-single-line.rs\";\n-    let expected_filename = \"tests/writemode/checkstyle.xml\";\n-    assert_output(filename, expected_filename, Some(WriteMode::Checkstyle));\n+    let filename = \"tests/writemode/source/fn-single-line.rs\";\n+    let expected_filename = \"tests/writemode/target/checkstyle.xml\";\n+    assert_output(filename, expected_filename);\n }\n \n \n // Helper function for comparing the results of rustfmt\n // to a known output file generated by one of the write modes.\n-fn assert_output(source: &str, expected_filename: &str, write_mode: Option<WriteMode>) {\n-    let file_map = run_rustfmt(source.to_string(), write_mode);\n-\n-    let mut config = read_config(&source);\n-    if let Some(write_mode) = write_mode {\n-        config.write_mode = write_mode;\n-    }\n+fn assert_output(source: &str, expected_filename: &str) {\n+    let config = read_config(&source);\n+    let (file_map, _report) = format_file(source, &config);\n \n     // Populate output by writing to a vec.\n     let mut out = vec![];\n@@ -108,7 +104,7 @@ fn idempotence_tests() {\n     let files = fs::read_dir(\"tests/target\")\n                     .expect(\"Couldn't read target dir\")\n                     .map(get_path_string);\n-    let (_reports, count, fails) = check_files(files, None);\n+    let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n     println!(\"Ran {} idempotent tests.\", count);\n@@ -126,7 +122,7 @@ fn self_tests() {\n     // Hack because there's no `IntoIterator` impl for `[T; N]`.\n     let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n-    let (reports, count, fails) = check_files(files, None);\n+    let (reports, count, fails) = check_files(files);\n     let mut warnings = 0;\n \n     // Display results.\n@@ -145,7 +141,7 @@ fn self_tests() {\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I, write_mode: Option<WriteMode>) -> (Vec<FormatReport>, u32, u32)\n+fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n     where I: Iterator<Item = String>\n {\n     let mut count = 0;\n@@ -155,7 +151,7 @@ fn check_files<I>(files: I, write_mode: Option<WriteMode>) -> (Vec<FormatReport>\n     for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n \n-        match idempotent_check(file_name, write_mode) {\n+        match idempotent_check(file_name) {\n             Ok(report) => reports.push(report),\n             Err(msg) => {\n                 print_mismatches(msg);\n@@ -192,25 +188,19 @@ fn read_config(filename: &str) -> Config {\n \n     // Don't generate warnings for to-do items.\n     config.report_todo = ReportTactic::Never;\n+\n     config\n }\n \n-// Simulate run()\n-fn run_rustfmt(filename: String, write_mode: Option<WriteMode>) -> FileMap {\n-    let mut config = read_config(&filename);\n-    if let Some(write_mode) = write_mode {\n-        config.write_mode = write_mode;\n-    }\n-    format(Path::new(&filename), &config)\n+fn format_file<P: Into<PathBuf>>(filename: P, config: &Config) -> (FileMap, FormatReport) {\n+    let input = Input::File(filename.into());\n+    format_input(input, &config)\n }\n \n-pub fn idempotent_check(filename: String,\n-                        write_mode: Option<WriteMode>)\n-                        -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n+pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n     let sig_comments = read_significant_comments(&filename);\n     let config = read_config(&filename);\n-    let mut file_map = run_rustfmt(filename, write_mode);\n-    let format_report = fmt_lines(&mut file_map, &config);\n+    let (file_map, format_report) = format_file(filename, &config);\n \n     let mut write_result = HashMap::new();\n     for (filename, text) in file_map.iter() {\n@@ -224,7 +214,7 @@ pub fn idempotent_check(filename: String,\n \n     let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n \n-    handle_result(write_result, target, write_mode).map(|_| format_report)\n+    handle_result(write_result, target).map(|_| format_report)\n }\n \n // Reads test config file from comments and reads its contents.\n@@ -272,14 +262,13 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n // Compare output to input.\n // TODO: needs a better name, more explanation.\n fn handle_result(result: HashMap<String, String>,\n-                 target: Option<&str>,\n-                 write_mode: Option<WriteMode>)\n+                 target: Option<&str>)\n                  -> Result<(), HashMap<String, Vec<Mismatch>>> {\n     let mut failures = HashMap::new();\n \n     for (file_name, fmt_text) in result {\n         // If file is in tests/source, compare to file with same name in tests/target.\n-        let target = get_target(&file_name, target, write_mode);\n+        let target = get_target(&file_name, target);\n         let mut f = fs::File::open(&target).expect(\"Couldn't open target\");\n \n         let mut text = String::new();\n@@ -301,29 +290,20 @@ fn handle_result(result: HashMap<String, String>,\n }\n \n // Map source file paths to their target paths.\n-fn get_target(file_name: &str, target: Option<&str>, write_mode: Option<WriteMode>) -> String {\n-    let file_path = Path::new(file_name);\n-    let (source_path_prefix, target_path_prefix) = match write_mode {\n-        Some(WriteMode::Coverage) => {\n-            (Path::new(\"tests/coverage-source/\"), \"tests/coverage-target/\")\n+fn get_target(file_name: &str, target: Option<&str>) -> String {\n+    if file_name.contains(\"source\") {\n+        let target_file_name = file_name.replace(\"source\", \"target\");\n+        if let Some(replace_name) = target {\n+            Path::new(&target_file_name)\n+                .with_file_name(replace_name)\n+                .into_os_string()\n+                .into_string()\n+                .unwrap()\n+        } else {\n+            target_file_name\n         }\n-        _ => (Path::new(\"tests/source/\"), \"tests/target/\"),\n-    };\n-\n-    if file_path.starts_with(source_path_prefix) {\n-        let mut components = file_path.components();\n-        // Can't skip(2) as the resulting iterator can't as_path()\n-        components.next();\n-        components.next();\n-\n-        let new_target = match components.as_path().to_str() {\n-            Some(string) => string,\n-            None => file_name,\n-        };\n-        let base = target.unwrap_or(new_target);\n-\n-        format!(\"{}{}\", target_path_prefix, base)\n     } else {\n+        // This is either and idempotence check or a self check\n         file_name.to_owned()\n     }\n }"}, {"sha": "f655cfb3b6b50c9c5b3bd2409c48b0b16d900091", "filename": "tests/writemode/checkstyle.xml", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57847e451af3d0057f36f61c357f5c451b4ac7ed/tests%2Fwritemode%2Fcheckstyle.xml", "raw_url": "https://github.com/rust-lang/rust/raw/57847e451af3d0057f36f61c357f5c451b4ac7ed/tests%2Fwritemode%2Fcheckstyle.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fwritemode%2Fcheckstyle.xml?ref=57847e451af3d0057f36f61c357f5c451b4ac7ed", "patch": "@@ -1,2 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<checkstyle version=\"4.3\"><file name=\"tests/source/fn-single-line.rs\"><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_expr() { 1 }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_stmt() { foo(); }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_decl_local() { let z = 5; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_decl_item(x: &amp;mut i32) { x = 3; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn empty() {}`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_return() -&gt; String { &quot;yay&quot; }`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `fn foo_where() -&gt; T`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `    where T: Sync`\" /><error line=\"1\" severity=\"warning\" message=\"Should be `{`\" /><error line=\"50\" severity=\"warning\" message=\"Should be `fn lots_of_space() { 1 }`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `trait CoolerTypes {`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be `fn Foo&lt;T&gt;() where T: Bar {}`\" /><error line=\"57\" severity=\"warning\" message=\"Should be ``\" /></file></checkstyle>"}, {"sha": "289dd9aa093affd4c63ae3a0a690f678f5d07530", "filename": "tests/writemode/source/fn-single-line.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fwritemode%2Fsource%2Ffn-single-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fwritemode%2Fsource%2Ffn-single-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fwritemode%2Fsource%2Ffn-single-line.rs?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -0,0 +1,80 @@\n+// rustfmt-fn_single_line: true\n+// rustfmt-write_mode: checkstyle\n+// Test single-line functions.\n+\n+fn foo_expr() {\n+    1\n+}\n+\n+fn foo_stmt() {\n+    foo();\n+}\n+\n+fn foo_decl_local()  {\n+    let z = 5;\n+   }\n+\n+fn    foo_decl_item(x: &mut i32) {\n+    x = 3;\n+}\n+\n+   fn empty()     {\n+\n+}\n+\n+fn foo_return() -> String {\n+    \"yay\"\n+}\n+\n+fn foo_where() -> T where T: Sync {\n+    let x = 2;\n+}\n+\n+fn fooblock() {\n+    {\n+        \"inner-block\"\n+    }\n+}\n+\n+fn fooblock2(x: i32) {\n+    let z = match x {\n+        _ => 2,\n+    };\n+}\n+\n+fn comment() {\n+    // this is a test comment\n+    1\n+}\n+\n+fn comment2() {\n+    // multi-line comment\n+    let z = 2;\n+    1\n+}\n+\n+fn only_comment() {\n+    // Keep this here\n+}\n+\n+fn aaaaaaaaaaaaaaaaa_looooooooooooooooooooooong_name() {\n+    let z = \"aaaaaaawwwwwwwwwwwwwwwwwwwwwwwwwwww\";\n+}\n+\n+fn lots_of_space                      ()                                                           {\n+                           1                 \n+}\n+\n+fn mac() -> Vec<i32> { vec![] }\n+\n+trait CoolTypes {\n+    fn dummy(&self) {\n+    }\n+}\n+\n+trait CoolerTypes { fn dummy(&self) { \n+}\n+}\n+\n+fn Foo<T>() where T: Bar {\n+}"}, {"sha": "b59d81b29c8fb2f052b14a7feb3d8cc87a1e99f8", "filename": "tests/writemode/target/checkstyle.xml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fwritemode%2Ftarget%2Fcheckstyle.xml", "raw_url": "https://github.com/rust-lang/rust/raw/615848339b0b4fd3bf6e41b4d1661cd17211fe54/tests%2Fwritemode%2Ftarget%2Fcheckstyle.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fwritemode%2Ftarget%2Fcheckstyle.xml?ref=615848339b0b4fd3bf6e41b4d1661cd17211fe54", "patch": "@@ -0,0 +1,2 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<checkstyle version=\"4.3\"><file name=\"tests/writemode/source/fn-single-line.rs\"><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_expr() { 1 }`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_stmt() { foo(); }`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_decl_local() { let z = 5; }`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_decl_item(x: &amp;mut i32) { x = 3; }`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn empty() {}`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_return() -&gt; String { &quot;yay&quot; }`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `fn foo_where() -&gt; T`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `    where T: Sync`\" /><error line=\"2\" severity=\"warning\" message=\"Should be `{`\" /><error line=\"51\" severity=\"warning\" message=\"Should be `fn lots_of_space() { 1 }`\" /><error line=\"58\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"58\" severity=\"warning\" message=\"Should be `trait CoolerTypes {`\" /><error line=\"58\" severity=\"warning\" message=\"Should be `    fn dummy(&amp;self) {}`\" /><error line=\"58\" severity=\"warning\" message=\"Should be `fn Foo&lt;T&gt;() where T: Bar {}`\" /></file></checkstyle>"}]}