{"sha": "790d9f349b061c8b7d113a3752b7e05c3304bccb", "node_id": "C_kwDOAAsO6NoAKDc5MGQ5ZjM0OWIwNjFjOGI3ZDExM2EzNzUyYjdlMDVjMzMwNGJjY2I", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-11T11:55:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-11T11:55:41Z"}, "message": "Rollup merge of #106276 - Sp00ph:unify_slice_ranges, r=the8472\n\nFix `vec_deque::Drain` FIXME\n\nIn my original `VecDeque` rewrite, I didn't use `VecDeque::slice_ranges` in `Drain::as_slices`, even though that's basically the exact use case for `slice_ranges`. The reason for this was that a `VecDeque` wrapped in a `Drain` actually has its length set to `drain_start`, so that there's no potential use after free if you `mem::forget` the `Drain`. I modified `slice_ranges` to accept an explicit `len` parameter instead, which it now uses to bounds check the given range. This way, `Drain::as_slices` can use `slice_ranges` internally instead of having to basically just copy paste the `slice_ranges` code. Since `slice_ranges` is just an internal helper function, this shouldn't change the user facing behavior in any way.", "tree": {"sha": "e21a043993e7023b6a9144d2c91051176547cdfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e21a043993e7023b6a9144d2c91051176547cdfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/790d9f349b061c8b7d113a3752b7e05c3304bccb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDGw9CRBK7hj4Ov3rIwAAEvoIACa3V1QXX0j5bjgzFR4KQoDL\nOipDHn0G8+Nnt6d2kAq4f9XqMnjVNLa/l/68QI1lu7wHeTHYTNOEOlQufh5Gzgpt\nHT69CXtXnHo9P4m/1+UMRch701hZN75NDtbfN3XIjtXy6MDoddnhUp2UsqtMfAKB\nXSy5RB6Rv0QbJ+L8KCYCbBXnP2Y66HbKabXeZXolf7VA94ZwC/6pFLpQgLdCSHoo\nSPp3PV+cDd5yGBBlft/fuzqP9kTIuLuxG0PR9AjQFyFGmS4eGazdaZRvHnFVBiP1\nspm1s7Y31SLQxj3klbcWYlVw/pGOR9ABYvicH5z1WOhe+XIFWm2E/CZfDgiAAHk=\n=7D4M\n-----END PGP SIGNATURE-----\n", "payload": "tree e21a043993e7023b6a9144d2c91051176547cdfc\nparent e350fe4e608b653da47e8012d13ef701613e717b\nparent acc876e42fce0dc3d6596f754dcfbc0ce07cabd6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678535741 +0100\ncommitter GitHub <noreply@github.com> 1678535741 +0100\n\nRollup merge of #106276 - Sp00ph:unify_slice_ranges, r=the8472\n\nFix `vec_deque::Drain` FIXME\n\nIn my original `VecDeque` rewrite, I didn't use `VecDeque::slice_ranges` in `Drain::as_slices`, even though that's basically the exact use case for `slice_ranges`. The reason for this was that a `VecDeque` wrapped in a `Drain` actually has its length set to `drain_start`, so that there's no potential use after free if you `mem::forget` the `Drain`. I modified `slice_ranges` to accept an explicit `len` parameter instead, which it now uses to bounds check the given range. This way, `Drain::as_slices` can use `slice_ranges` internally instead of having to basically just copy paste the `slice_ranges` code. Since `slice_ranges` is just an internal helper function, this shouldn't change the user facing behavior in any way.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/790d9f349b061c8b7d113a3752b7e05c3304bccb", "html_url": "https://github.com/rust-lang/rust/commit/790d9f349b061c8b7d113a3752b7e05c3304bccb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/790d9f349b061c8b7d113a3752b7e05c3304bccb/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e350fe4e608b653da47e8012d13ef701613e717b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e350fe4e608b653da47e8012d13ef701613e717b", "html_url": "https://github.com/rust-lang/rust/commit/e350fe4e608b653da47e8012d13ef701613e717b"}, {"sha": "acc876e42fce0dc3d6596f754dcfbc0ce07cabd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/acc876e42fce0dc3d6596f754dcfbc0ce07cabd6", "html_url": "https://github.com/rust-lang/rust/commit/acc876e42fce0dc3d6596f754dcfbc0ce07cabd6"}], "stats": {"total": 67, "additions": 31, "deletions": 36}, "files": [{"sha": "0be274a3822d3ac58608f3badfe556f7ee54d0a1", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/790d9f349b061c8b7d113a3752b7e05c3304bccb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9f349b061c8b7d113a3752b7e05c3304bccb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=790d9f349b061c8b7d113a3752b7e05c3304bccb", "patch": "@@ -52,36 +52,22 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n         }\n     }\n \n-    // Only returns pointers to the slices, as that's\n-    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    // Only returns pointers to the slices, as that's all we need\n+    // to drop them. May only be called if `self.remaining != 0`.\n     unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n         unsafe {\n             let deque = self.deque.as_ref();\n-            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n-            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n-            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n-            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n-            // implementation, this seemed like the less hacky solution, though it might be good to\n-            // find a better one in the future.\n-\n-            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n-            // logical index.\n-            let wrapped_start = deque.to_physical_idx(self.idx);\n-\n-            let head_len = deque.capacity() - wrapped_start;\n-\n-            let (a_range, b_range) = if head_len >= self.remaining {\n-                (wrapped_start..wrapped_start + self.remaining, 0..0)\n-            } else {\n-                let tail_len = self.remaining - head_len;\n-                (wrapped_start..deque.capacity(), 0..tail_len)\n-            };\n-\n-            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n-            // the range `0..deque.original_len`. because of this, and because of the fact\n-            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n-            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n-            // the deques buffer.\n+\n+            // We know that `self.idx + self.remaining <= deque.len <= usize::MAX`, so this won't overflow.\n+            let logical_remaining_range = self.idx..self.idx + self.remaining;\n+\n+            // SAFETY: `logical_remaining_range` represents the\n+            // range into the logical buffer of elements that\n+            // haven't been drained yet, so they're all initialized,\n+            // and `slice::range(start..end, end) == start..end`,\n+            // so the preconditions for `slice_ranges` are met.\n+            let (a_range, b_range) =\n+                deque.slice_ranges(logical_remaining_range.clone(), logical_remaining_range.end);\n             (deque.buffer_range(a_range), deque.buffer_range(b_range))\n         }\n     }"}, {"sha": "48e907e402ccf2462ddaa917d8c0a63bf9239503", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/790d9f349b061c8b7d113a3752b7e05c3304bccb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/790d9f349b061c8b7d113a3752b7e05c3304bccb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=790d9f349b061c8b7d113a3752b7e05c3304bccb", "patch": "@@ -1156,7 +1156,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n@@ -1190,7 +1190,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n@@ -1232,19 +1232,28 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Given a range into the logical buffer of the deque, this function\n     /// return two ranges into the physical buffer that correspond to\n-    /// the given range.\n-    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n+    /// the given range. The `len` parameter should usually just be `self.len`;\n+    /// the reason it's passed explicitly is that if the deque is wrapped in\n+    /// a `Drain`, then `self.len` is not actually the length of the deque.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is always safe to call. For the resulting ranges to be valid\n+    /// ranges into the physical buffer, the caller must ensure that the result of\n+    /// calling `slice::range(range, ..len)` represents a valid range into the\n+    /// logical buffer, and that all elements in that range are initialized.\n+    fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len);\n+        let Range { start, end } = slice::range(range, ..len);\n         let len = end - start;\n \n         if len == 0 {\n             (0..0, 0..0)\n         } else {\n-            // `slice::range` guarantees that `start <= end <= self.len`.\n-            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // `slice::range` guarantees that `start <= end <= len`.\n+            // because `len != 0`, we know that `start < end`, so `start < len`\n             // and the indexing is valid.\n             let wrapped_start = self.to_physical_idx(start);\n \n@@ -1290,7 +1299,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and\n@@ -1330,7 +1339,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and"}]}