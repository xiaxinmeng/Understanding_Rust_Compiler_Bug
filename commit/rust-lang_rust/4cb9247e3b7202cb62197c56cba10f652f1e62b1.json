{"sha": "4cb9247e3b7202cb62197c56cba10f652f1e62b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYjkyNDdlM2I3MjAyY2I2MjE5N2M1NmNiYTEwZjY1MmYxZTYyYjE=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2012-12-30T21:09:34Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2012-12-30T21:09:34Z"}, "message": "doc: make small corrections to tutorial", "tree": {"sha": "302937f972bf712e690729a0fbaa1e530d5cdfd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/302937f972bf712e690729a0fbaa1e530d5cdfd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cb9247e3b7202cb62197c56cba10f652f1e62b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb9247e3b7202cb62197c56cba10f652f1e62b1", "html_url": "https://github.com/rust-lang/rust/commit/4cb9247e3b7202cb62197c56cba10f652f1e62b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cb9247e3b7202cb62197c56cba10f652f1e62b1/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be7310be0a2f35a5a73825b0718aa643c740c8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be7310be0a2f35a5a73825b0718aa643c740c8b", "html_url": "https://github.com/rust-lang/rust/commit/4be7310be0a2f35a5a73825b0718aa643c740c8b"}], "stats": {"total": 164, "additions": 83, "deletions": 81}, "files": [{"sha": "23aabbc32ec70f3a2bfdd5b5ea98efdc09beeb15", "filename": "doc/tutorial.md", "status": "modified", "additions": 83, "deletions": 81, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/4cb9247e3b7202cb62197c56cba10f652f1e62b1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4cb9247e3b7202cb62197c56cba10f652f1e62b1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=4cb9247e3b7202cb62197c56cba10f652f1e62b1", "patch": "@@ -80,7 +80,7 @@ supported build environments that are most likely to work.\n > \"[getting started][wiki-start]\" notes on the wiki. Even when using\n > the binary installer, the Windows build requires a MinGW installation,\n > the precise details of which are not discussed here. Finally, `rustc` may\n-> need to be [referred to as `rustc.exe`][bug-3319]. It's a bummer, I\n+> need to be [referred to as `rustc.exe`][bug-3319]. It's a bummer, we\n > know.\n \n [bug-3319]: https://github.com/mozilla/rust/issues/3319\n@@ -114,7 +114,7 @@ for more information on them.\n \n When complete, `make install` will place several programs into\n `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool, `cargo`, the Rust package manager,\n+API-documentation tool; `cargo`, the Rust package manager;\n and `rusti`, the Rust REPL.\n \n [wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n@@ -181,10 +181,10 @@ in blocks delineated by curly braces; there are control structures\n for branching and looping, like the familiar `if` and `while`; function\n calls are written `myfunc(arg1, arg2)`; operators are written the same\n and mostly have the same precedence as in C; comments are again like C;\n-module names are separated with double-colon, `::`, as with C++.\n+module names are separated with double-colon (`::`) as with C++.\n \n The main surface difference to be aware of is that the condition at\n-the head of control structures like `if` and `while` do not require\n+the head of control structures like `if` and `while` does not require\n parentheses, while their bodies *must* be wrapped in\n braces. Single-statement, unbraced bodies are not allowed.\n \n@@ -226,12 +226,12 @@ let monster_size: int = 50;\n ~~~~\n \n Local variables may shadow earlier declarations, as in the previous example:\n-`monster_size` was first declared as a `float`, and then then a second\n-`monster_size` was declared as an int. If you were to actually compile this\n-example, though, the compiler will determine that the second `monster_size` is\n+`monster_size` was first declared as a `float`, and then a second\n+`monster_size` was declared as an `int`. If you were to actually compile this\n+example, though, the compiler would determine that the second `monster_size` is\n unused and issue a warning (because this situation is likely to indicate a\n programmer error). For occasions where unused variables are intentional, their\n-name may be prefixed with an underscore to silence the warning, like `let\n+names may be prefixed with an underscore to silence the warning, like `let\n _monster_size = 50;`.\n \n Rust identifiers start with an alphabetic\n@@ -292,7 +292,7 @@ branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n In short, everything that's not a declaration (declarations are `let` for\n-variables, `fn` for functions, and any top-level named items such as\n+variables; `fn` for functions; and any top-level named items such as\n [traits](#traits), [enum types](#enums), and [constants](#constants)) is an\n expression, including function bodies.\n \n@@ -306,8 +306,8 @@ fn is_four(x: int) -> bool {\n \n ## Primitive types and literals\n \n-There are general signed and unsigned integer types, `int`, and `uint`,\n-as well as 8-, 16-, 32-, and 64-bit variations, `i8`, `u16`, etc.\n+There are general signed and unsigned integer types, `int` and `uint`,\n+as well as 8-, 16-, 32-, and 64-bit variants, `i8`, `u16`, etc.\n Integers can be written in decimal (`144`), hexadecimal (`0x90`), or\n binary (`0b10010000`) base. Each integral type has a corresponding literal\n suffix that can be used to indicate the type of a literal: `i` for `int`,\n@@ -326,14 +326,14 @@ let c = 100u;    // c is a uint\n let d = 1000i32; // d is an i32\n ~~~~\n \n-There are three floating point types, `float`, `f32`, and `f64`.\n-Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`.\n-Like integers, floating point literals are inferred to the correct type.\n-Suffixes `f`, `f32` and `f64` can be used to create literals of a specific type.\n+There are three floating-point types: `float`, `f32`, and `f64`.\n+Floating-point numbers are written `0.0`, `1e6`, or `2.1e-4`.\n+Like integers, floating-point literals are inferred to the correct type.\n+Suffixes `f`, `f32`, and `f64` can be used to create literals of a specific type.\n \n The keywords `true` and `false` produce literals of type `bool`.\n \n-Characters, the `char` type, are 4-byte unicode codepoints,\n+Characters, the `char` type, are four-byte Unicode codepoints,\n whose literals are written between single quotes, as in `'x'`.\n Just like C, Rust understands a number of character escapes, using the backslash\n character, such as `\\n`, `\\r`, and `\\t`. String literals,\n@@ -345,8 +345,8 @@ The nil type, written `()`, has a single value, also written `()`.\n ## Operators\n \n Rust's set of operators contains very few surprises. Arithmetic is done with\n-`*`, `/`, `%`, `+`, and `-` (multiply, divide, take remainder, add, subtract). `-` is\n-also a unary prefix operator that negates numbers. As in C, the bit operators\n+`*`, `/`, `%`, `+`, and `-` (multiply, divide, take remainder, add, and subtract). `-` is\n+also a unary prefix operator that negates numbers. As in C, the bitwise operators\n `>>`, `<<`, `&`, `|`, and `^` are also supported.\n \n Note that, if applied to an integer value, `!` flips all the bits (like `~` in\n@@ -444,7 +444,7 @@ match my_number {\n }\n ~~~~\n \n-Unlike in C, there is no 'falling through' between arms: only one arm\n+Unlike in C, there is no \"falling through\" between arms: only one arm\n executes, and it doesn't have to explicitly `break` out of the\n construct when it is finished.\n \n@@ -494,7 +494,7 @@ fn angle(vector: (float, float)) -> float {\n A variable name in a pattern matches any value, *and* binds that name\n to the value of the matched value inside of the arm's action. Thus, `(0f,\n y)` matches any tuple whose first element is zero, and binds `y` to\n-the second element. `(x, y)` matches any tuple, and binds both\n+the second element. `(x, y)` matches any two-element tuple, and binds both\n elements to variables.\n \n Any `match` arm can have a guard clause (written `if EXPR`), called a\n@@ -575,7 +575,7 @@ With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n omitted from the type, such an assignment would result in a type error.\n \n `match` patterns destructure structs. The basic syntax is\n-`Name {fieldname: pattern, ...}`:\n+`Name { fieldname: pattern, ... }`:\n \n ~~~~\n # struct Point { x: float, y: float }\n@@ -589,7 +589,7 @@ match mypoint {\n In general, the field names of a struct do not have to appear in the same\n order they appear in the type. When you are not interested in all\n the fields of a struct, a struct pattern may end with `, _` (as in\n-`Name {field1, _}`) to indicate that you're ignoring all other fields.\n+`Name { field1, _ }`) to indicate that you're ignoring all other fields.\n Additionally, struct fields have a shorthand matching form that simply\n reuses the field name as the binding name.\n \n@@ -618,15 +618,15 @@ A value of this type is either a `Circle`, in which case it contains a\n `Point` struct and a float, or a `Rectangle`, in which case it contains\n two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n-'tagged union' pattern in C, but with better static guarantees.\n+\"tagged union\" pattern in C, but with better static guarantees.\n \n The above declaration will define a type `Shape` that can refer to\n such shapes, and two functions, `Circle` and `Rectangle`, which can be\n used to construct values of the type (taking arguments of the\n-specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n+specified types). So `Circle(Point { x: 0f, y: 0f }, 10f)` is the way to\n create a new circle.\n \n-Enum variants need not have type parameters. This `enum` declaration,\n+Enum variants need not have parameters. This `enum` declaration,\n for example, is equivalent to a C enum:\n \n ~~~~\n@@ -659,7 +659,7 @@ variant does not have a discriminator, it defaults to 0. For example,\n the value of `North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n \n When an enum is C-like, you can apply the `as` cast operator to\n-convert it to its discriminator value as an int.\n+convert it to its discriminator value as an `int`.\n \n <a name=\"single_variant_enum\"></a>\n \n@@ -710,7 +710,7 @@ patterns, as in this definition of `area`:\n fn area(sh: Shape) -> float {\n     match sh {\n         Circle(_, size) => float::consts::pi * size * size,\n-        Rectangle(Point {x, y}, Point {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n+        Rectangle(Point { x, y }, Point { x: x2, y: y2 }) => (x2 - x) * (y2 - y)\n     }\n }\n ~~~~\n@@ -721,14 +721,14 @@ introduction form, nullary enum patterns are written without\n parentheses.\n \n ~~~~\n-# struct Point {x: float, y: float}\n+# struct Point { x: float, y: float }\n # enum Direction { North, East, South, West }\n fn point_from_direction(dir: Direction) -> Point {\n     match dir {\n-        North => Point {x:  0f, y:  1f},\n-        East  => Point {x:  1f, y:  0f},\n-        South => Point {x:  0f, y: -1f},\n-        West  => Point {x: -1f, y:  0f}\n+        North => Point { x:  0f, y:  1f },\n+        East  => Point { x:  1f, y:  0f },\n+        South => Point { x:  0f, y: -1f },\n+        West  => Point { x: -1f, y:  0f }\n     }\n }\n ~~~~\n@@ -737,21 +737,22 @@ Enum variants may also be structs. For example:\n \n ~~~~\n # use core::float;\n-# struct Point {x: float, y: float}\n+# struct Point { x: float, y: float }\n # fn square(x: float) -> float { x * x }\n enum Shape {\n     Circle { center: Point, radius: float },\n     Rectangle { top_left: Point, bottom_right: Point }\n }\n fn area(sh: Shape) -> float {\n-   match sh {\n-      Circle { radius: radius, _ } => float::consts::pi * square(radius),\n-      Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n-        (bottom_right.x - top_left.x) * (bottom_right.y - top_left.y)\n-      }\n-   }\n+    match sh {\n+        Circle { radius: radius, _ } => float::consts::pi * square(radius),\n+        Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n+            (bottom_right.x - top_left.x) * (bottom_right.y - top_left.y)\n+        }\n+    }\n }\n ~~~~\n+\n ## Tuples\n \n Tuples in Rust behave exactly like structs, except that their fields\n@@ -800,7 +801,7 @@ fn line(a: int, b: int, x: int) -> int {\n \n The `return` keyword immediately returns from the body of a function. It\n is optionally followed by an expression to return. A function can\n-also return a value by having its top level block produce an\n+also return a value by having its top-level block produce an\n expression.\n \n ~~~~\n@@ -834,7 +835,7 @@ assert () == oops(5, 3, 1);\n \n As with `match` expressions and `let` bindings, function arguments support\n pattern destructuring. Like `let`, argument patterns must be irrefutable,\n-as in this example that unpacks a tuple and returns it.\n+as in this example that unpacks the first value from a tuple and returns it.\n \n ~~~\n fn first((value, _): (int, float)) -> int { value }\n@@ -917,7 +918,7 @@ aggregate types like structs and enums, so as to represent these types\n as pointers to heap memory by default. In contrast, Rust, like C and\n C++, represents such types directly. Another way to say this is that\n aggregate data in Rust are *unboxed*. This means that if you `let x =\n-Point {x: 1f, y: 1f};`, you are creating a struct on the stack. If you\n+Point { x: 1f, y: 1f };`, you are creating a struct on the stack. If you\n then copy it into a data structure, you copy the entire struct, not\n just a pointer.\n \n@@ -927,7 +928,7 @@ those with mutable fields, it can be useful to have a single copy on\n the stack or on the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The safe pointer types are\n-`@T` for managed boxes allocated on the local heap, `~T`, for\n+`@T`, for managed boxes allocated on the local heap, `~T`, for\n uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n borrowed pointers, which may point to any memory, and whose lifetimes\n are governed by the call stack.\n@@ -941,8 +942,8 @@ All pointer types can be dereferenced with the `*` unary operator.\n \n ## Managed boxes\n \n-Managed boxes are pointers to heap-allocated, garbage collected\n-memory.  Applying the unary `@` operator to an expression creates a\n+Managed boxes are pointers to heap-allocated, garbage-collected\n+memory. Applying the unary `@` operator to an expression creates a\n managed box. The resulting box contains the result of the\n expression. Copying a managed box, as happens during assignment, only\n copies a pointer, never the contents of the box.\n@@ -1037,7 +1038,8 @@ As an example, consider a simple struct type, `Point`:\n \n ~~~\n struct Point {\n-    x: float, y: float\n+    x: float,\n+    y: float\n }\n ~~~~\n \n@@ -1047,9 +1049,9 @@ contains a point, but allocated in a different location:\n \n ~~~\n # struct Point { x: float, y: float }\n-let on_the_stack : Point  =  Point {x: 3.0, y: 4.0};\n-let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n-let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n+let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n+let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n+let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance\n@@ -1078,9 +1080,9 @@ Now we can call `compute_distance()` in various ways:\n \n ~~~\n # struct Point{ x: float, y: float };\n-# let on_the_stack : Point  =  Point {x: 3.0, y: 4.0};\n-# let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\n-# let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\n+# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n+# let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n+# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n # fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n compute_distance(&on_the_stack, managed_box);\n compute_distance(managed_box, owned_box);\n@@ -1090,14 +1092,14 @@ Here the `&` operator is used to take the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we are created an alias: that is, another\n+`on_the_stack`, because we are creating an alias: that is, another\n route to the same data.\n \n In the case of the boxes `managed_box` and `owned_box`, however, no\n explicit action is necessary. The compiler will automatically convert\n a box like `@point` or `~point` to a borrowed pointer like\n `&point`. This is another form of borrowing; in this case, the\n-contents of the managed/owned box is being lent out.\n+contents of the managed/owned box are being lent out.\n \n Whenever a value is borrowed, there are some limitations on what you\n can do with the original. For example, if the contents of a variable\n@@ -1157,7 +1159,7 @@ let area = (*rect).area();\n ~~~\n \n To combat this ugliness the dot operator applies _automatic pointer\n-dereferencing_ to the receiver (the value on the left hand side of the\n+dereferencing_ to the receiver (the value on the left-hand side of the\n dot), so in most cases, explicitly dereferencing the receiver is not necessary.\n \n ~~~\n@@ -1199,7 +1201,7 @@ pointers to vectors are also called 'slices'.\n // A fixed-size stack vector\n let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n \n-// A borrowed pointer to stack allocated vector\n+// A borrowed pointer to stack-allocated vector\n let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];\n \n // A local heap (managed) vector of crayons\n@@ -1526,7 +1528,7 @@ do spawn() || {\n }\n ~~~~\n \n-Look at all those bars and parentheses - that's two empty argument\n+Look at all those bars and parentheses -- that's two empty argument\n lists back to back. Since that is so unsightly, empty argument lists\n may be omitted from `do` expressions.\n \n@@ -1605,7 +1607,7 @@ fn contains(v: &[int], elt: int) -> bool {\n ~~~~\n \n Notice that, because `each` passes each value by borrowed pointer,\n-the iteratee needs to dereference it before using.\n+the iteratee needs to dereference it before using it.\n In these situations it can be convenient to lean on Rust's\n argument patterns to bind `x` to the actual value, not the pointer.\n \n@@ -1727,7 +1729,7 @@ s.draw_borrowed();\n // ... and dereferenced\n (& &s).draw_borrowed();\n \n-// ... and dereferenced, and borrowed, and\n+// ... and dereferenced and borrowed\n (&@~s).draw_borrowed();\n ~~~\n \n@@ -1790,9 +1792,9 @@ Inside a generic function, the names of the type parameters\n (capitalized by convention) stand for opaque types. All you can do\n with instances of these types is pass them around: you can't apply any\n operations to them or pattern-match on them. Note that instances of\n-generic types are often passed by pointer.  For example, the parameter\n+generic types are often passed by pointer. For example, the parameter\n `function()` is supplied with a pointer to a value of type `T` and not\n-a value of type `T` itself.  This ensures that the function works with\n+a value of type `T` itself. This ensures that the function works with\n the broadest set of types possible, since some types are expensive or\n illegal to copy and pass by value.\n \n@@ -1813,7 +1815,7 @@ enum Option<T> {\n ~~~~\n \n These declarations can be instantiated to valid types like `Set<int>`,\n-`Stack<int>` and `Option<int>`.\n+`Stack<int>`, and `Option<int>`.\n \n The last type in that example, `Option`, appears frequently in Rust code.\n Because Rust does not have null pointers (except in unsafe code), we need\n@@ -1822,13 +1824,13 @@ combination of arguments of the appropriate types. The usual way is to write\n a function that returns `Option<T>` instead of `T`.\n \n ~~~~\n-# struct Point {x: float, y: float}\n+# struct Point { x: float, y: float }\n # enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n fn radius(shape: Shape) -> Option<float> {\n-   match shape {\n-       Circle(_, radius) => Some(radius),\n-       Rectangle(*)      => None\n-   }      \n+    match shape {\n+        Circle(_, radius) => Some(radius),\n+        Rectangle(*)      => None\n+    }\n }\n ~~~~\n \n@@ -1892,12 +1894,12 @@ While most traits can be defined and implemented by user code, three\n traits are automatically derived and implemented for all applicable\n types by the compiler, and may not be overridden:\n \n-* `Copy` - Types that can be copied: either implicitly, or explicitly with the\n+* `Copy` - Types that can be copied, either implicitly, or explicitly with the\n   `copy` operator. All types are copyable unless they have destructors or\n   contain types with destructors.\n \n * `Owned` - Owned types. Types are owned unless they contain managed\n-  boxes, managed closures, or borrowed pointers.  Owned types may or\n+  boxes, managed closures, or borrowed pointers. Owned types may or\n   may not be copyable.\n \n * `Const` - Constant (immutable) types. These are types that do not contain\n@@ -1914,7 +1916,7 @@ garbage collector reclaimed it.\n \n ~~~\n struct TimeBomb {\n-    explosivity: uint,\n+    explosivity: uint\n }\n \n impl TimeBomb : Drop {\n@@ -2004,12 +2006,12 @@ following trait describes types that support an equality operation:\n // In a trait, `self` refers both to the self argument\n // and to the type implementing the trait\n trait Eq {\n-  fn equals(&self, other: &self) -> bool;\n+    fn equals(&self, other: &self) -> bool;\n }\n \n // In an impl, `self` refers just to the value of the receiver\n impl int: Eq {\n-  fn equals(&self, other: &int) -> bool { *other == *self }\n+    fn equals(&self, other: &int) -> bool { *other == *self }\n }\n ~~~~\n \n@@ -2033,7 +2035,7 @@ impl Circle: Shape {\n     static fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\n }\n impl Square: Shape {\n-     static fn new(area: float) -> Square { Square { length: sqrt(area) } }\n+    static fn new(area: float) -> Square { Square { length: sqrt(area) } }\n }\n \n let area = 42.5;\n@@ -2103,9 +2105,9 @@ fn draw_all<T: Drawable>(shapes: ~[T]) {\n # draw_all(~[c]);\n ~~~~\n \n-You can call that on an array of circles, or an array of squares\n+You can call that on an array of circles, or an array of rectangles\n (assuming those have suitable `Drawable` traits defined), but not on\n-an array containing both circles and squares. When such behavior is\n+an array containing both circles and rectangles. When such behavior is\n needed, a trait name can alternately be used as a type, called\n an _object_.\n \n@@ -2189,10 +2191,10 @@ Now, we can implement `Circle` on a type only if we also implement `Shape`.\n # fn square(x: float) -> float { x * x }\n struct CircleStruct { center: Point, radius: float }\n impl CircleStruct: Circle {\n-     fn radius(&self) -> float { sqrt(self.area() / pi) }\n+    fn radius(&self) -> float { sqrt(self.area() / pi) }\n }\n impl CircleStruct: Shape {\n-     fn area(&self) -> float { pi * square(self.radius) }\n+    fn area(&self) -> float { pi * square(self.radius) }\n }   \n ~~~~\n \n@@ -2266,7 +2268,7 @@ fn chicken_farmer() {\n ~~~\n \n These farm animal functions have a new keyword, `pub`, attached to\n-them.  The `pub` keyword modifies an item's visibility, making it\n+them. The `pub` keyword modifies an item's visibility, making it\n visible outside its containing module. An expression with `::`, like\n `farm::chicken`, can name an item outside of its containing\n module. Items, such as those declared with `fn`, `struct`, `enum`,\n@@ -2276,7 +2278,7 @@ Visibility restrictions in Rust exist only at module boundaries. This\n is quite different from most object-oriented languages that also\n enforce restrictions on objects themselves. That's not to say that\n Rust doesn't support encapsulation: both struct fields and methods can\n-be private.  But this encapsulation is at the module level, not the\n+be private. But this encapsulation is at the module level, not the\n struct level. Note that fields and methods are _public_ by default.\n \n ~~~\n@@ -2320,7 +2322,7 @@ fn main() {\n \n The unit of independent compilation in Rust is the crate: rustc\n compiles a single crate at a time, from which it produces either a\n-library or executable.\n+library or an executable.\n \n When compiling a single `.rs` source file, the file acts as the whole crate.\n You can compile it with the `--lib` compiler switch to create a shared\n@@ -2368,7 +2370,7 @@ Compiling this file will cause `rustc` to look for files named\n `cow.rs`, `chicken.rs`, and `horse.rs` in the same directory as the\n `.rc` file, compile them all together, and, based on the presence of\n the `crate_type = \"lib\"` attribute, output a shared library or an\n-executable.  (If the line `#[crate_type = \"lib\"];` was omitted,\n+executable. (If the line `#[crate_type = \"lib\"];` was omitted,\n `rustc` would create an executable.)\n \n The `#[link(...)]` attribute provides meta information about the"}]}