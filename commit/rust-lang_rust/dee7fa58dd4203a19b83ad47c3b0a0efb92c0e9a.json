{"sha": "dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTdmYTU4ZGQ0MjAzYTE5YjgzYWQ0N2MzYjBhMGVmYjkyYzBlOWE=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-11-13T10:21:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-25T06:30:00Z"}, "message": "Use `mmap` to map in task stacks and guard page\n\nAlso implement caching of stacks.", "tree": {"sha": "adb1ec1b8219633b3a7d65611cd2a1648d658f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adb1ec1b8219633b3a7d65611cd2a1648d658f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "html_url": "https://github.com/rust-lang/rust/commit/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "462f09e9494481456b22630cb42a3c0544a08625", "url": "https://api.github.com/repos/rust-lang/rust/commits/462f09e9494481456b22630cb42a3c0544a08625", "html_url": "https://github.com/rust-lang/rust/commit/462f09e9494481456b22630cb42a3c0544a08625"}], "stats": {"total": 202, "additions": 144, "deletions": 58}, "files": [{"sha": "3f2f74bbb8d699d08265ceb6031a35fac0e68648", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -12,10 +12,9 @@ use std::libc::c_void;\n use std::uint;\n use std::cast::{transmute, transmute_mut_unsafe,\n                 transmute_region, transmute_mut_region};\n+use stack::Stack;\n use std::unstable::stack;\n \n-use stack::StackSegment;\n-\n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n@@ -41,7 +40,7 @@ impl Context {\n     }\n \n     /// Create a new context that will resume execution by running proc()\n-    pub fn new(start: proc(), stack: &mut StackSegment) -> Context {\n+    pub fn new(start: proc(), stack: &mut Stack) -> Context {\n         // The C-ABI function that is the task entry point\n         //\n         // Note that this function is a little sketchy. We're taking a\n@@ -79,6 +78,7 @@ impl Context {\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n         let start = ~start;\n+\n         initialize_call_frame(&mut *regs,\n                               task_start_wrapper as *c_void,\n                               unsafe { transmute(&*start) },"}, {"sha": "3d7dc58a1b2447da453a9360d97ce4af4177ff00", "filename": "src/libgreen/coroutine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fcoroutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fcoroutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcoroutine.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -14,7 +14,7 @@\n use std::rt::env;\n \n use context::Context;\n-use stack::{StackPool, StackSegment};\n+use stack::{StackPool, Stack};\n \n /// A coroutine is nothing more than a (register context, stack) pair.\n pub struct Coroutine {\n@@ -24,7 +24,7 @@ pub struct Coroutine {\n     ///\n     /// Servo needs this to be public in order to tell SpiderMonkey\n     /// about the stack bounds.\n-    current_stack_segment: StackSegment,\n+    current_stack_segment: Stack,\n \n     /// Always valid if the task is alive and not running.\n     saved_context: Context\n@@ -39,7 +39,7 @@ impl Coroutine {\n             Some(size) => size,\n             None => env::min_stack()\n         };\n-        let mut stack = stack_pool.take_segment(stack_size);\n+        let mut stack = stack_pool.take_stack(stack_size);\n         let initial_context = Context::new(start, &mut stack);\n         Coroutine {\n             current_stack_segment: stack,\n@@ -49,14 +49,14 @@ impl Coroutine {\n \n     pub fn empty() -> Coroutine {\n         Coroutine {\n-            current_stack_segment: StackSegment::new(0),\n+            current_stack_segment: Stack::new(0),\n             saved_context: Context::empty()\n         }\n     }\n \n     /// Destroy coroutine and try to reuse std::stack segment.\n     pub fn recycle(self, stack_pool: &mut StackPool) {\n         let Coroutine { current_stack_segment, .. } = self;\n-        stack_pool.give_segment(current_stack_segment);\n+        stack_pool.give_stack(current_stack_segment);\n     }\n }"}, {"sha": "a5d5174b91b97c2a5a1584a1d2a2e525e04c6bc0", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -8,46 +8,101 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-use std::libc::{c_uint, uintptr_t};\n+use std::rt::env::max_cached_stacks;\n+use std::os::{errno, page_size, MemoryMap, MapReadable, MapWritable, MapNonStandardFlags};\n+#[cfg(not(windows))]\n+use std::libc::{MAP_STACK, MAP_PRIVATE, MAP_ANON};\n+use std::libc::{c_uint, c_int, c_void, uintptr_t};\n \n-pub struct StackSegment {\n-    priv buf: ~[u8],\n-    priv valgrind_id: c_uint\n+/// A task's stack. The name \"Stack\" is a vestige of segmented stacks.\n+pub struct Stack {\n+    priv buf: MemoryMap,\n+    priv min_size: uint,\n+    priv valgrind_id: c_uint,\n }\n \n-impl StackSegment {\n-    pub fn new(size: uint) -> StackSegment {\n-        unsafe {\n-            // Crate a block of uninitialized values\n-            let mut stack = vec::with_capacity(size);\n-            stack.set_len(size);\n+// Try to use MAP_STACK on platforms that support it (it's what we're doing\n+// anyway), but some platforms don't support it at all. For example, it appears\n+// that there's a bug in freebsd that MAP_STACK implies MAP_FIXED (so it always\n+// fails): http://lists.freebsd.org/pipermail/freebsd-bugs/2011-July/044840.html\n+#[cfg(not(windows), not(target_os = \"freebsd\"))]\n+static STACK_FLAGS: c_int = MAP_STACK | MAP_PRIVATE | MAP_ANON;\n+#[cfg(target_os = \"freebsd\")]\n+static STACK_FLAGS: c_int = MAP_PRIVATE | MAP_ANON;\n+#[cfg(windows)]\n+static STACK_FLAGS: c_int = 0;\n \n-            let mut stk = StackSegment {\n-                buf: stack,\n-                valgrind_id: 0\n-            };\n+impl Stack {\n+    pub fn new(size: uint) -> Stack {\n+        // Map in a stack. Eventually we might be able to handle stack allocation failure, which\n+        // would fail to spawn the task. But there's not many sensible things to do on OOM.\n+        // Failure seems fine (and is what the old stack allocation did).\n+        let stack = match MemoryMap::new(size, [MapReadable, MapWritable,\n+                                         MapNonStandardFlags(STACK_FLAGS)]) {\n+            Ok(map) => map,\n+            Err(e) => fail!(\"Creating memory map for stack of size {} failed: {}\", size, e)\n+        };\n \n-            // XXX: Using the FFI to call a C macro. Slow\n-            stk.valgrind_id = rust_valgrind_stack_register(stk.start(), stk.end());\n-            return stk;\n+        // Change the last page to be inaccessible. This is to provide safety; when an FFI\n+        // function overflows it will (hopefully) hit this guard page. It isn't guaranteed, but\n+        // that's why FFI is unsafe. buf.data is guaranteed to be aligned properly.\n+        if !protect_last_page(&stack) {\n+            fail!(\"Could not memory-protect guard page. stack={:?}, errno={}\",\n+                  stack, errno());\n         }\n+\n+        let mut stk = Stack {\n+            buf: stack,\n+            min_size: size,\n+            valgrind_id: 0\n+        };\n+\n+        // XXX: Using the FFI to call a C macro. Slow\n+        stk.valgrind_id = unsafe { rust_valgrind_stack_register(stk.start(), stk.end()) };\n+        return stk;\n     }\n \n     /// Point to the low end of the allocated stack\n     pub fn start(&self) -> *uint {\n-        self.buf.as_ptr() as *uint\n+        self.buf.data as *uint\n     }\n \n     /// Point one word beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n         unsafe {\n-            self.buf.as_ptr().offset(self.buf.len() as int) as *uint\n+            self.buf.data.offset(self.buf.len as int) as *uint\n         }\n     }\n }\n \n-impl Drop for StackSegment {\n+// These use ToPrimitive so that we never need to worry about the sizes of whatever types these\n+// (which we would with scalar casts). It's either a wrapper for a scalar cast or failure: fast, or\n+// will fail during compilation.\n+#[cfg(unix)]\n+fn protect_last_page(stack: &MemoryMap) -> bool {\n+    use std::libc::{mprotect, PROT_NONE, size_t};\n+    unsafe {\n+        // This may seem backwards: the start of the segment is the last page? Yes! The stack grows\n+        // from higher addresses (the end of the allocated block) to lower addresses (the start of\n+        // the allocated block).\n+        let last_page = stack.data as *c_void;\n+        mprotect(last_page, page_size() as size_t, PROT_NONE) != -1\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn protect_last_page(stack: &MemoryMap) -> bool {\n+    use std::libc::{VirtualProtect, PAGE_NOACCESS, SIZE_T, LPDWORD, DWORD};\n+    unsafe {\n+        // see above\n+        let last_page = stack.data as *mut c_void;\n+        let mut old_prot: DWORD = 0;\n+        VirtualProtect(last_page, page_size() as SIZE_T, PAGE_NOACCESS,\n+                       &mut old_prot as LPDWORD) != 0\n+    }\n+}\n+\n+impl Drop for Stack {\n     fn drop(&mut self) {\n         unsafe {\n             // XXX: Using the FFI to call a C macro. Slow\n@@ -56,16 +111,30 @@ impl Drop for StackSegment {\n     }\n }\n \n-pub struct StackPool(());\n+pub struct StackPool {\n+    // Ideally this would be some datastructure that preserved ordering on Stack.min_size.\n+    priv stacks: ~[Stack],\n+}\n \n impl StackPool {\n-    pub fn new() -> StackPool { StackPool(()) }\n+    pub fn new() -> StackPool {\n+        StackPool {\n+            stacks: ~[],\n+        }\n+    }\n \n-    pub fn take_segment(&self, min_size: uint) -> StackSegment {\n-        StackSegment::new(min_size)\n+    pub fn take_stack(&mut self, min_size: uint) -> Stack {\n+        // Ideally this would be a binary search\n+        match self.stacks.iter().position(|s| s.min_size < min_size) {\n+            Some(idx) => self.stacks.swap_remove(idx),\n+            None      => Stack::new(min_size)\n+        }\n     }\n \n-    pub fn give_segment(&self, _stack: StackSegment) {\n+    pub fn give_stack(&mut self, stack: Stack) {\n+        if self.stacks.len() <= max_cached_stacks() {\n+            self.stacks.push(stack)\n+        }\n     }\n }\n "}, {"sha": "d5f185880fad6e193b30c3df9b30fb16a357e38c", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -2863,6 +2863,7 @@ pub mod consts {\n             pub static MAP_PRIVATE : c_int = 0x0002;\n             pub static MAP_FIXED : c_int = 0x0010;\n             pub static MAP_ANON : c_int = 0x1000;\n+            pub static MAP_STACK : c_int = 0;\n \n             pub static MAP_FAILED : *c_void = -1 as *c_void;\n "}, {"sha": "b594b91d2dca6a8a7b28cbef7ea20123e1d26ed5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -39,7 +39,7 @@ use os;\n use prelude::*;\n use ptr;\n use str;\n-use to_str;\n+use fmt;\n use unstable::finally::Finally;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n \n@@ -871,7 +871,7 @@ pub enum MapOption {\n     MapOffset(uint),\n     /// On POSIX, this can be used to specify the default flags passed to `mmap`. By default it uses\n     /// `MAP_PRIVATE` and, if not using `MapFd`, `MAP_ANON`. This will override both of those. This\n-    /// is platform-specific (the exact values used) and unused on Windows.\n+    /// is platform-specific (the exact values used) and ignored on Windows.\n     MapNonStandardFlags(c_int),\n }\n \n@@ -911,23 +911,29 @@ pub enum MapError {\n     ErrMapViewOfFile(uint)\n }\n \n-impl to_str::ToStr for MapError {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ErrFdNotAvail => ~\"fd not available for reading or writing\",\n-            ErrInvalidFd => ~\"Invalid fd\",\n-            ErrUnaligned => ~\"Unaligned address, invalid flags, \\\n-                              negative length or unaligned offset\",\n-            ErrNoMapSupport=> ~\"File doesn't support mapping\",\n-            ErrNoMem => ~\"Invalid address, or not enough available memory\",\n-            ErrUnknown(code) => format!(\"Unknown error={}\", code),\n-            ErrUnsupProt => ~\"Protection mode unsupported\",\n-            ErrUnsupOffset => ~\"Offset in virtual memory mode is unsupported\",\n-            ErrAlreadyExists => ~\"File mapping for specified file already exists\",\n-            ErrVirtualAlloc(code) => format!(\"VirtualAlloc failure={}\", code),\n-            ErrCreateFileMappingW(code) => format!(\"CreateFileMappingW failure={}\", code),\n-            ErrMapViewOfFile(code) => format!(\"MapViewOfFile failure={}\", code)\n-        }\n+impl fmt::Default for MapError {\n+    fn fmt(val: &MapError, out: &mut fmt::Formatter) {\n+        let str = match *val {\n+            ErrFdNotAvail => \"fd not available for reading or writing\",\n+            ErrInvalidFd => \"Invalid fd\",\n+            ErrUnaligned => \"Unaligned address, invalid flags, negative length or unaligned offset\",\n+            ErrNoMapSupport=> \"File doesn't support mapping\",\n+            ErrNoMem => \"Invalid address, or not enough available memory\",\n+            ErrUnsupProt => \"Protection mode unsupported\",\n+            ErrUnsupOffset => \"Offset in virtual memory mode is unsupported\",\n+            ErrAlreadyExists => \"File mapping for specified file already exists\",\n+            ErrUnknown(code) => { write!(out.buf, \"Unknown error = {}\", code); return },\n+            ErrVirtualAlloc(code) => { write!(out.buf, \"VirtualAlloc failure = {}\", code); return },\n+            ErrCreateFileMappingW(code) => {\n+                format!(\"CreateFileMappingW failure = {}\", code);\n+                return\n+            },\n+            ErrMapViewOfFile(code) => {\n+                write!(out.buf, \"MapViewOfFile failure = {}\", code);\n+                return\n+            }\n+        };\n+        write!(out.buf, \"{}\", str);\n     }\n }\n \n@@ -1130,8 +1136,7 @@ impl Drop for MemoryMap {\n         unsafe {\n             match self.kind {\n                 MapVirtual => {\n-                    if libc::VirtualFree(self.data as *mut c_void,\n-                                         self.len as size_t,\n+                    if libc::VirtualFree(self.data as *mut c_void, 0,\n                                          libc::MEM_RELEASE) == FALSE {\n                         error!(\"VirtualFree failed: {}\", errno());\n                     }\n@@ -1487,7 +1492,7 @@ mod tests {\n             MapOffset(size / 2)\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(msg.to_str())\n+            Err(msg) => fail!(\"{}\", msg)\n         };\n         assert!(chunk.len > 0);\n "}, {"sha": "729e377e1af31797ad4fbae8418f6e7dc18fe5f4", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=dee7fa58dd4203a19b83ad47c3b0a0efb92c0e9a", "patch": "@@ -10,26 +10,33 @@\n \n //! Runtime environment settings\n \n-use from_str::FromStr;\n+use from_str::from_str;\n use option::{Some, None};\n use os;\n \n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n \n static mut MIN_STACK: uint = 2 * 1024 * 1024;\n+/// This default corresponds to 20M of cache per scheduler (at the default size).\n+static mut MAX_CACHED_STACKS: uint = 10;\n static mut DEBUG_BORROW: bool = false;\n static mut POISON_ON_FREE: bool = false;\n \n pub fn init() {\n     unsafe {\n         match os::getenv(\"RUST_MIN_STACK\") {\n-            Some(s) => match FromStr::from_str(s) {\n+            Some(s) => match from_str(s) {\n                 Some(i) => MIN_STACK = i,\n                 None => ()\n             },\n             None => ()\n         }\n+        match os::getenv(\"RUST_MAX_CACHED_STACKS\") {\n+            Some(max) => MAX_CACHED_STACKS = from_str(max).expect(\"expected positive integer in \\\n+                                                                   RUST_MAX_CACHED_STACKS\"),\n+            None => ()\n+        }\n         match os::getenv(\"RUST_DEBUG_BORROW\") {\n             Some(_) => DEBUG_BORROW = true,\n             None => ()\n@@ -45,6 +52,10 @@ pub fn min_stack() -> uint {\n     unsafe { MIN_STACK }\n }\n \n+pub fn max_cached_stacks() -> uint {\n+    unsafe { MAX_CACHED_STACKS }\n+}\n+\n pub fn debug_borrow() -> bool {\n     unsafe { DEBUG_BORROW }\n }"}]}