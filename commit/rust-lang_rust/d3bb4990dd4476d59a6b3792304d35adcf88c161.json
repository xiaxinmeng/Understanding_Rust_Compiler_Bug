{"sha": "d3bb4990dd4476d59a6b3792304d35adcf88c161", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYmI0OTkwZGQ0NDc2ZDU5YTZiMzc5MjMwNGQzNWFkY2Y4OGMxNjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T04:39:58Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T04:39:58Z"}, "message": "rustc: Make metadata::encoder::encode_path take an &path\n\nEliminates some bad copies.", "tree": {"sha": "22020b79693edc6126b56dda9316115675248069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22020b79693edc6126b56dda9316115675248069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3bb4990dd4476d59a6b3792304d35adcf88c161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3bb4990dd4476d59a6b3792304d35adcf88c161", "html_url": "https://github.com/rust-lang/rust/commit/d3bb4990dd4476d59a6b3792304d35adcf88c161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3bb4990dd4476d59a6b3792304d35adcf88c161/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "012364bc5f36b3871f952e1cb52b492fa2368c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/012364bc5f36b3871f952e1cb52b492fa2368c43", "html_url": "https://github.com/rust-lang/rust/commit/012364bc5f36b3871f952e1cb52b492fa2368c43"}], "stats": {"total": 47, "additions": 20, "deletions": 27}, "files": [{"sha": "b7934f7eae0445ade421d33be6c8d79f35c7b0c2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d3bb4990dd4476d59a6b3792304d35adcf88c161/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3bb4990dd4476d59a6b3792304d35adcf88c161/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d3bb4990dd4476d59a6b3792304d35adcf88c161", "patch": "@@ -298,7 +298,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             disr_val = vi[i].disr_val;\n         }\n         encode_type_param_bounds(ebml_w, ecx, /*bad*/copy ty_params);\n-        encode_path(ecx, ebml_w, /*bad*/copy path,\n+        encode_path(ecx, ebml_w, &path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n         disr_val += 1;\n@@ -307,7 +307,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n }\n \n fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-               path: ast_map::path, name: ast_map::path_elt) {\n+               path: &ast_map::path, name: ast_map::path_elt) {\n     fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n@@ -319,8 +319,8 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     }\n \n     do ebml_w.wr_tag(tag_path) {\n-        ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        for vec::each(path) |pe| {\n+        ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n+        for path.each |pe| {\n             encode_path_elt(ecx, ebml_w, *pe);\n         }\n         encode_path_elt(ecx, ebml_w, name);\n@@ -353,11 +353,11 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n                 ebml_w.end_tag();\n             }\n-            _ => {} // XXX: Encode these too.\n+            _ => {} // FIXME #4573: Encode these too.\n         }\n     }\n \n-    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n+    encode_path(ecx, ebml_w, &path, ast_map::path_mod(name));\n \n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n@@ -455,8 +455,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        tcx.sess.str_of(nm), id);\n                 encode_visibility(ebml_w, vis);\n                 encode_name(ecx, ebml_w, nm);\n-                encode_path(ecx, ebml_w, /*bad*/copy path,\n-                            ast_map::path_name(nm));\n+                encode_path(ecx, ebml_w, &path, ast_map::path_name(nm));\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n                 encode_mutability(ebml_w, mt);\n                 encode_def_id(ebml_w, local_def(id));\n@@ -482,8 +481,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n-        // XXX: Bad copy.\n-        encode_path(ecx, ebml_w, copy path, ast_map::path_name(ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(ident));\n         match item {\n            Some(ref it) => {\n              (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n@@ -516,8 +514,7 @@ fn encode_info_for_method(ecx: @encode_ctxt,\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n-    // XXX: Bad copy.\n-    encode_path(ecx, ebml_w, copy impl_path, ast_map::path_name(m.ident));\n+    encode_path(ecx, ebml_w, &impl_path, ast_map::path_name(m.ident));\n     encode_self_type(ebml_w, m.self_ty.node);\n     if len > 0u || should_inline {\n         (ecx.encode_inlined_item)(\n@@ -585,7 +582,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_fn(_, purity, tps, _) => {\n@@ -596,8 +593,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         let tps_len = tps.len();\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        // XXX: Bad copy.\n-        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, /*bad*/copy item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n@@ -616,7 +612,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_ty(_, tps) => {\n@@ -627,7 +623,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n@@ -644,8 +640,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             }\n             (ecx.encode_inlined_item)(ecx, ebml_w, /*bad*/copy path,\n                                       ii_item(item));\n-            encode_path(ecx, ebml_w, /*bad*/copy path,\n-                        ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx,\n@@ -686,7 +681,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         /* Encode the dtor */\n         /* Encode id for dtor */\n@@ -744,8 +739,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         do opt_trait.iter() |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait);\n         }\n-        // XXX: Bad copy.\n-        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n         let impl_path = vec::append_one(path,\n@@ -801,8 +795,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             }\n             i += 1u;\n         }\n-        // XXX: Bad copy.\n-        encode_path(ecx, ebml_w, copy path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait)\n         }\n@@ -830,7 +823,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             encode_type(ecx, ebml_w, polyty.ty);\n             let m_path = vec::append_one(/*bad*/copy path,\n                                          ast_map::path_name(item.ident));\n-            encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n+            encode_path(ecx, ebml_w, &m_path, ast_map::path_name(ty_m.ident));\n             ebml_w.end_tag();\n         }\n \n@@ -868,14 +861,14 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(nitem.ident));\n       }\n       foreign_item_const(*) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, &path, ast_map::path_name(nitem.ident));\n       }\n     }\n     ebml_w.end_tag();"}]}