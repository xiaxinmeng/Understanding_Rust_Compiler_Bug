{"sha": "447a24588a865142aeaf9153952485d1cd6b9c67", "node_id": "C_kwDOAAsO6NoAKDQ0N2EyNDU4OGE4NjUxNDJhZWFmOTE1Mzk1MjQ4NWQxY2Q2YjljNjc", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-15T19:51:57Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-18T20:02:25Z"}, "message": "Allow various type erasure patterns in `transmute_undefined_repr`", "tree": {"sha": "a8581cf8f0d22eab951c067b29f77a136a37af2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8581cf8f0d22eab951c067b29f77a136a37af2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/447a24588a865142aeaf9153952485d1cd6b9c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/447a24588a865142aeaf9153952485d1cd6b9c67", "html_url": "https://github.com/rust-lang/rust/commit/447a24588a865142aeaf9153952485d1cd6b9c67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/447a24588a865142aeaf9153952485d1cd6b9c67/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01732b60192ed7f99571090b5b87f61ab8c98e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/01732b60192ed7f99571090b5b87f61ab8c98e75", "html_url": "https://github.com/rust-lang/rust/commit/01732b60192ed7f99571090b5b87f61ab8c98e75"}], "stats": {"total": 170, "additions": 96, "deletions": 74}, "files": [{"sha": "a4ef1344ab9511beb75790081393d1e456c98040", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_hir_ty_cfg_dependant;\n+use clippy_utils::ty::is_c_void;\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, GenericArg};\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::sym;\n \n use super::CAST_PTR_ALIGNMENT;\n \n@@ -62,19 +62,3 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_f\n         }\n     }\n }\n-\n-/// Check if the given type is either `core::ffi::c_void` or\n-/// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "74bdace408c2ad814343026013d5ecf5b3c1843f", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -1,5 +1,6 @@\n use super::TRANSMUTE_UNDEFINED_REPR;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::is_c_void;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, Subst};\n@@ -100,7 +101,8 @@ pub(super) fn check<'tcx>(\n                 from_ty: from_sub_ty,\n                 to_ty: to_sub_ty,\n             } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::IntArray | ReducedTy::TypeErasure, _)\n+                | (_, ReducedTy::IntArray | ReducedTy::TypeErasure) => return false,\n                 (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n                     span_lint_and_then(\n                         cx,\n@@ -228,8 +230,10 @@ fn reduce_refs<'tcx>(\n }\n \n enum ReducedTy<'tcx> {\n-    /// The type is a struct containing either zero sized fields, or multiple sized fields with a\n-    /// defined order.\n+    /// The type can be used for type erasure.\n+    TypeErasure,\n+    /// The type is a struct containing either zero non-zero sized fields, or multiple non-zero\n+    /// sized fields with a defined order.\n     OrderedFields(Ty<'tcx>),\n     /// The type is a struct containing multiple non-zero sized fields with no defined order.\n     UnorderedFields(Ty<'tcx>),\n@@ -252,6 +256,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 ty = sub_ty;\n                 continue;\n             },\n+            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n             ty::Tuple(args) => {\n                 let mut iter = args.iter().map(GenericArg::expect_ty);\n                 let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n@@ -270,7 +275,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n                 let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::OrderedFields(ty);\n+                    return ReducedTy::TypeErasure;\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n@@ -282,6 +287,10 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     ReducedTy::UnorderedFields(ty)\n                 }\n             },\n+            ty::Adt(def, _) if def.is_enum() && (def.variants.is_empty() || is_c_void(cx, ty)) => {\n+                ReducedTy::TypeErasure\n+            },\n+            ty::Foreign(_) => ReducedTy::TypeErasure,\n             ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n             ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n             _ => ReducedTy::Other(ty),"}, {"sha": "5b37a1de8ed865eeba3e93810a5578ec5ac5f41b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -1,6 +1,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]"}, {"sha": "6c9ba64525a74fec4a7f1eba1a654cd5e956ba93", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -572,3 +572,17 @@ pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: &'_ AdtDef, i: VariantIdx) -\n         },\n     }\n }\n+\n+/// Check if the given type is either `core::ffi::c_void`, `std::os::raw::c_void`, or one of the\n+/// platform specific `libc::<platform>::c_void` types in libc.\n+pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind()\n+        && let &[krate, .., name] = &*cx.get_def_path(adt.did)\n+        && let sym::libc | sym::core | sym::std = krate\n+        && name.as_str() == \"c_void\"\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "c1ee0d98a921290e803a5c297b1dd9c168e780c7", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -1,6 +1,9 @@\n #![warn(clippy::transmute_undefined_repr)]\n #![allow(clippy::unit_arg)]\n \n+use core::ffi::c_void;\n+use core::mem::transmute;\n+\n fn value<T>() -> T {\n     unimplemented!()\n }\n@@ -14,49 +17,60 @@ struct Ty2C<T, U>(T, U);\n \n fn main() {\n     unsafe {\n-        let _: () = core::mem::transmute(value::<Empty>());\n-        let _: Empty = core::mem::transmute(value::<()>());\n+        let _: () = transmute(value::<Empty>());\n+        let _: Empty = transmute(value::<()>());\n \n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: Ty<u32> = transmute(value::<u32>());\n+        let _: Ty<u32> = transmute(value::<u32>());\n \n-        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n \n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n \n-        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n \n-        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n-        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+        let _: Ty<&()> = transmute(value::<&()>());\n+        let _: &() = transmute(value::<Ty<&()>>());\n \n-        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n \n-        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n-        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+        let _: Ty<usize> = transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n \n-        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+        let _: Ty<[u8; 8]> = transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n \n         // issue #8417\n-        let _: Ty2C<Ty2<u32, i32>, ()> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<Ty2<u32, i32>, ()>>()); // Ok, Ty2 types are the same\n+        let _: Ty2C<Ty2<u32, i32>, ()> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<Ty2<u32, i32>, ()>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+        let _: *mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<*mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n \n-        // Ty2 types are the same\n-        let _: &'static mut Ty2<u32, u32> = core::mem::transmute(value::<Box<Ty2<u32, u32>>>()); // Ok\n-        // Ty2 types are the same\n-        let _: Box<Ty2<u32, u32>> = core::mem::transmute(value::<&'static mut Ty2<u32, u32>>()); // Ok\n-        let _: *mut Ty2<u32, u32> = core::mem::transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n-        let _: Box<Ty2<u32, u32>> = core::mem::transmute(value::<*mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+        let _: *const () = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const ()>()); // Ok, reverse type erasure\n \n-        // Different Ty2 instances\n-        let _: &'static mut Ty2<u32, f32> = core::mem::transmute(value::<Box<Ty2<u32, u32>>>()); // Lint\n-        // Different Ty2 instances\n-        let _: Box<Ty2<u32, u32>> = core::mem::transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint\n+        let _: *const c_void = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const c_void>()); // Ok, reverse type erasure\n \n+        enum Erase {}\n+        let _: *const Erase = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase>()); // Ok, reverse type erasure\n \n+        struct Erase2(\n+            [u8; 0],\n+            core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n+        );\n+        let _: *const Erase2 = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase2>()); // Ok, reverse type erasure\n     }\n }"}, {"sha": "42d544fc954c5b31034bb0dc2f0ace0f16ee1444", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/447a24588a865142aeaf9153952485d1cd6b9c67/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/447a24588a865142aeaf9153952485d1cd6b9c67/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=447a24588a865142aeaf9153952485d1cd6b9c67", "patch": "@@ -1,62 +1,62 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:23:33\n+  --> $DIR/transmute_undefined_repr.rs:26:33\n    |\n-LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:24:32\n+  --> $DIR/transmute_undefined_repr.rs:27:32\n    |\n-LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:29:32\n+  --> $DIR/transmute_undefined_repr.rs:32:32\n    |\n-LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:30:36\n+  --> $DIR/transmute_undefined_repr.rs:33:36\n    |\n-LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:35:33\n+  --> $DIR/transmute_undefined_repr.rs:38:33\n    |\n-LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:36:37\n+  --> $DIR/transmute_undefined_repr.rs:39:37\n    |\n-LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n   --> $DIR/transmute_undefined_repr.rs:56:45\n    |\n-LL |         let _: &'static mut Ty2<u32, f32> = core::mem::transmute(value::<Box<Ty2<u32, u32>>>()); // Lint\n-   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:58:37\n+  --> $DIR/transmute_undefined_repr.rs:57:37\n    |\n-LL |         let _: Box<Ty2<u32, u32>> = core::mem::transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n "}]}