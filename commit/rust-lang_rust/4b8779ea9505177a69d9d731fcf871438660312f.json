{"sha": "4b8779ea9505177a69d9d731fcf871438660312f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiODc3OWVhOTUwNTE3N2E2OWQ5ZDczMWZjZjg3MTQzODY2MDMxMmY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-15T00:46:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-15T00:50:37Z"}, "message": "Pass tydescs to parametric fns, along with (dummy, presently) retptr when needed. Can call simple parametric fn now.", "tree": {"sha": "d05fe49ad683b714811c7342946cdb21befdb887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d05fe49ad683b714811c7342946cdb21befdb887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b8779ea9505177a69d9d731fcf871438660312f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8779ea9505177a69d9d731fcf871438660312f", "html_url": "https://github.com/rust-lang/rust/commit/4b8779ea9505177a69d9d731fcf871438660312f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b8779ea9505177a69d9d731fcf871438660312f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d55bee44179f7dcfebd8eaf1b99730c8473dadea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d55bee44179f7dcfebd8eaf1b99730c8473dadea", "html_url": "https://github.com/rust-lang/rust/commit/d55bee44179f7dcfebd8eaf1b99730c8473dadea"}], "stats": {"total": 148, "additions": 82, "deletions": 66}, "files": [{"sha": "b91cc6541a4a909bb782c99d8e790644c3deb543", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 82, "deletions": 66, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4b8779ea9505177a69d9d731fcf871438660312f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8779ea9505177a69d9d731fcf871438660312f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4b8779ea9505177a69d9d731fcf871438660312f", "patch": "@@ -288,6 +288,10 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n+fn T_typaram_ptr() -> TypeRef {\n+    ret T_ptr(T_i8());\n+}\n+\n fn T_closure_ptr(TypeRef lltarget_ty,\n                  TypeRef llbindings_ty) -> TypeRef {\n     ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n@@ -311,7 +315,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     ret llty;\n }\n \n-// NB: this function must match the ABI assumptions of trans_args.\n+// NB: this must match trans_args and create_llargs_for_fn_args.\n fn type_of_fn_full(@crate_ctxt cx,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n@@ -326,6 +330,10 @@ fn type_of_fn_full(@crate_ctxt cx,\n         i += 1u;\n     }\n \n+    if (ty.type_has_dynamic_size(output)) {\n+        atys += T_typaram_ptr();\n+    }\n+\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n             check (t as int != 0);\n@@ -336,19 +344,20 @@ fn type_of_fn_full(@crate_ctxt cx,\n         }\n     }\n \n-    if (ty.type_has_dynamic_size(output)) {\n-        atys += T_ptr(type_of(cx, output));\n-    }\n-\n     for (ty.arg arg in inputs) {\n-        let TypeRef t = type_of(cx, arg.ty);\n-        alt (arg.mode) {\n-            case (ast.alias) {\n-                t = T_ptr(t);\n+        if (ty.type_has_dynamic_size(arg.ty)) {\n+            check (arg.mode == ast.alias);\n+            atys += T_typaram_ptr();\n+        } else {\n+            let TypeRef t = type_of(cx, arg.ty);\n+            alt (arg.mode) {\n+                case (ast.alias) {\n+                    t = T_ptr(t);\n+                }\n+                case (_) { /* fall through */  }\n             }\n-            case (_) { /* fall through */  }\n+            atys += t;\n         }\n-        atys += t;\n     }\n \n     auto ret_ty;\n@@ -441,7 +450,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             fail;\n         }\n         case (ty.ty_param(_)) {\n-            ret T_ptr(T_i8());\n+            ret T_typaram_ptr();\n         }\n     }\n     fail;\n@@ -797,7 +806,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n \n-                auto body_val = load_non_structural(cx, body, body_ty);\n+                auto body_val = load_scalar_or_boxed(cx, body, body_ty);\n                 auto res = drop_ty(cx, body_val, body_ty);\n                 // FIXME: switch gc/non-gc on layer of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n@@ -1001,7 +1010,7 @@ fn iter_structural_ty(@block_ctxt cx,\n             for (@ty.t arg in args) {\n                 auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n-                      load_non_structural(r.bcx, elt, arg),\n+                      load_scalar_or_boxed(r.bcx, elt, arg),\n                       arg);\n                 i += 1;\n             }\n@@ -1011,7 +1020,7 @@ fn iter_structural_ty(@block_ctxt cx,\n             for (ty.field fld in fields) {\n                 auto llfld = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n-                      load_non_structural(r.bcx, llfld, fld.ty),\n+                      load_scalar_or_boxed(r.bcx, llfld, fld.ty),\n                       fld.ty);\n                 i += 1;\n             }\n@@ -1073,7 +1082,7 @@ fn iter_structural_ty(@block_ctxt cx,\n                                     auto llfldp = variant_cx.build.GEP(llvarp,\n                                         vec(C_int(0), C_int(j as int)));\n                                     auto llfld =\n-                                        load_non_structural(variant_cx,\n+                                        load_scalar_or_boxed(variant_cx,\n                                                             llfldp, a.ty);\n \n                                     auto res = f(variant_cx, llfld, a.ty);\n@@ -1161,7 +1170,7 @@ fn iter_sequence(@block_ctxt cx,\n \n         auto elt = body_cx.build.GEP(p0, vec(C_int(0), ix));\n         auto body_res = f(body_cx,\n-                          load_non_structural(body_cx, elt, elt_ty),\n+                          load_scalar_or_boxed(body_cx, elt, elt_ty),\n                           elt_ty);\n         auto next_ix = body_res.bcx.build.Add(ix, C_int(1));\n         auto next_scaled_ix = body_res.bcx.build.Add(scaled_ix, unit_sz);\n@@ -1206,7 +1215,7 @@ fn incr_all_refcnts(@block_ctxt cx,\n fn drop_slot(@block_ctxt cx,\n              ValueRef slot,\n              @ty.t t) -> result {\n-    auto llptr = load_non_structural(cx, slot, t);\n+    auto llptr = load_scalar_or_boxed(cx, slot, t);\n     auto re = drop_ty(cx, llptr, t);\n \n     auto llty = val_ty(slot);\n@@ -1668,7 +1677,7 @@ impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                     auto llsubvalptr = matched_cx.build.GEP(llunionptr,\n                                                             vec(C_int(0),\n                                                                 C_int(i)));\n-                    auto llsubval = load_non_structural(matched_cx,\n+                    auto llsubval = load_scalar_or_boxed(matched_cx,\n                                                         llsubvalptr,\n                                                         pat_ty(subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n@@ -1709,7 +1718,7 @@ impure fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n             for (@ast.pat subpat in subpats) {\n                 auto llsubvalptr = this_cx.build.GEP(llunionptr,\n                                                      vec(C_int(0), C_int(i)));\n-                auto llsubval = load_non_structural(this_cx, llsubvalptr,\n+                auto llsubval = load_scalar_or_boxed(this_cx, llsubvalptr,\n                                                     pat_ty(subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,\n                                                     llsubval);\n@@ -1757,7 +1766,7 @@ impure fn trans_alt(@block_ctxt cx, @ast.expr expr, vec[ast.arm] arms)\n     ret res(last_cx, C_nil());\n }\n \n-type generic_info = rec(@ty.t monotype,\n+type generic_info = rec(@ty.t item_type,\n                         vec[ValueRef] tydescs);\n \n type lval_result = rec(result res,\n@@ -1815,7 +1824,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                             append[ValueRef](tydescs,\n                                              get_tydesc(cx, t));\n                         }\n-                        auto gen = rec( monotype = monoty,\n+                        auto gen = rec( item_type = ty.item_ty(fn_item)._1,\n                                         tydescs = tydescs );\n                         lv = rec(generic = some[generic_info](gen)\n                                  with lv);\n@@ -1969,7 +1978,7 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n \n-// NB: this function must match the ABI assumptions of type_of_fn_full.\n+// NB: this must match type_of_fn_full and create_llargs_for_fn_args.\n impure fn trans_args(@block_ctxt cx,\n                      ValueRef llclosure,\n                      option.t[ValueRef] llobj,\n@@ -1980,17 +1989,19 @@ impure fn trans_args(@block_ctxt cx,\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n \n-    let vec[ty.arg] args = vec();   // FIXME: typestate bug\n-    alt (fn_ty.struct) {\n-        case (ty.ty_fn(?a, _)) { args = a; }\n-        case (_) { fail; }\n-    }\n+    let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n \n     alt (gen) {\n         case (some[generic_info](?g)) {\n             for (ValueRef t in g.tydescs) {\n                 vs += t;\n             }\n+            args = ty.ty_fn_args(g.item_type);\n+            if (ty.type_has_dynamic_size(ty.ty_fn_ret(g.item_type))) {\n+                // FIXME: allocate real outptr in caller,\n+                // pass in to here.\n+                vs += C_null(T_typaram_ptr());\n+            }\n         }\n         case (_) { }\n     }\n@@ -2019,29 +2030,33 @@ impure fn trans_args(@block_ctxt cx,\n                 // we are now passing it as an arg, so need to load it.\n                 re.val = re.bcx.build.Load(re.val);\n             }\n-        } else {\n-            if (mode == ast.alias) {\n-                let lval_result lv;\n-                if (ty.is_lval(e)) {\n-                    lv = trans_lval(bcx, e);\n-                } else {\n-                    auto r = trans_expr(bcx, e);\n-                    lv = lval_val(r.bcx, r.val);\n-                }\n+        } else if (mode == ast.alias) {\n+            let lval_result lv;\n+            if (ty.is_lval(e)) {\n+                lv = trans_lval(bcx, e);\n+            } else {\n+                auto r = trans_expr(bcx, e);\n+                lv = lval_val(r.bcx, r.val);\n+            }\n \n-                if (!lv.is_mem) {\n-                    // Non-mem but we're trying to alias; synthesize an\n-                    // alloca, spill to it and pass its address.\n-                    auto llty = val_ty(lv.res.val);\n-                    auto llptr = lv.res.bcx.build.Alloca(llty);\n-                    lv.res.bcx.build.Store(lv.res.val, llptr);\n-                    re = res(lv.res.bcx, llptr);\n-                } else {\n-                    re = lv.res;\n-                }\n+            if (!lv.is_mem) {\n+                // Non-mem but we're trying to alias; synthesize an\n+                // alloca, spill to it and pass its address.\n+                auto llty = val_ty(lv.res.val);\n+                auto llptr = lv.res.bcx.build.Alloca(llty);\n+                lv.res.bcx.build.Store(lv.res.val, llptr);\n+                re = res(lv.res.bcx, llptr);\n             } else {\n-                re = trans_expr(bcx, e);\n+                re = lv.res;\n             }\n+\n+        } else {\n+            re = trans_expr(bcx, e);\n+        }\n+\n+        if (ty.type_has_dynamic_size(args.(i).ty)) {\n+            re.val = re.bcx.build.PointerCast(re.val,\n+                                              T_typaram_ptr());\n         }\n \n         vs += re.val;\n@@ -2444,7 +2459,7 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res.is_mem);\n-            auto lhs_val = load_non_structural(lhs_res.res.bcx,\n+            auto lhs_val = load_scalar_or_boxed(lhs_res.res.bcx,\n                                                lhs_res.res.val, t);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto v = trans_eager_binop(rhs_res.bcx, op, lhs_val, rhs_res.val);\n@@ -2483,24 +2498,24 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto t = ty.expr_ty(e);\n             auto sub = trans_lval(cx, e);\n             ret res(sub.res.bcx,\n-                    load_non_structural(sub.res.bcx, sub.res.val, t));\n+                    load_scalar_or_boxed(sub.res.bcx, sub.res.val, t));\n         }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n }\n \n // We pass structural values around the compiler \"by pointer\" and\n-// non-structural values \"by value\". This function selects whether\n-// to load a pointer or pass it.\n+// non-structural values (scalars and boxes) \"by value\". This function selects\n+// whether to load a pointer or pass it.\n \n-fn load_non_structural(@block_ctxt cx,\n-                       ValueRef v,\n-                       @ty.t t) -> ValueRef {\n-    if (ty.type_is_structural(t)) {\n-        ret v;\n-    } else {\n+fn load_scalar_or_boxed(@block_ctxt cx,\n+                        ValueRef v,\n+                        @ty.t t) -> ValueRef {\n+    if (ty.type_is_scalar(t) || ty.type_is_boxed(t)) {\n         ret cx.build.Load(v);\n+    } else {\n+        ret v;\n     }\n }\n \n@@ -2591,7 +2606,8 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n             alt (cx.fcx.llretptr) {\n                 case (some[ValueRef](?llptr)) {\n-                    r.bcx.build.Store(r.val, llptr);\n+                    // FIXME: Generic return: Needs to use tydesc.\n+                    // r.bcx.build.Store(r.val, llptr);\n                     r.bcx.build.RetVoid();\n                 }\n                 case (none[ValueRef]) {\n@@ -2801,7 +2817,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              ccx=cx);\n }\n \n-\n+// NB: this must match trans_args and type_of_fn_full.\n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              option.t[TypeRef] ty_self,\n                              @ty.t ret_ty,\n@@ -2816,6 +2832,11 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         arg_n += 1u;\n     }\n \n+    if (ty.type_has_dynamic_size(ret_ty)) {\n+        cx.llretptr = some[ValueRef](llvm.LLVMGetParam(cx.llfn, arg_n));\n+        arg_n += 1u;\n+    }\n+\n     alt (ty_self) {\n         case (some[TypeRef](_)) {\n             auto llself = llvm.LLVMGetParam(cx.llfn, arg_n);\n@@ -2829,11 +2850,6 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         }\n     }\n \n-    if (ty.type_has_dynamic_size(ret_ty)) {\n-        cx.llretptr = some[ValueRef](llvm.LLVMGetParam(cx.llfn, arg_n));\n-        arg_n += 1u;\n-    }\n-\n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n         check (llarg as int != 0);\n@@ -3106,7 +3122,7 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         let int i = 0;\n         for (ast.obj_field f in ob.fields) {\n             auto arg = r.bcx.fcx.llargs.get(f.id);\n-            arg = load_non_structural(r.bcx, arg, arg_tys.(i).ty);\n+            arg = load_scalar_or_boxed(r.bcx, arg, arg_tys.(i).ty);\n             auto field = r.bcx.build.GEP(body_fields,\n                                          vec(C_int(0),C_int(i)));\n             r = copy_ty(r.bcx, true, field, arg, arg_tys.(i).ty);"}]}