{"sha": "0ca0676abde64f6c863659f78cc1798dd5959738", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYTA2NzZhYmRlNjRmNmM4NjM2NTlmNzhjYzE3OThkZDU5NTk3Mzg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-03-14T16:57:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-14T16:57:02Z"}, "message": "Merge pull request #146 from oli-obk/peephole1\n\n[Peephole Optimization 1/n] Don't allocate for structs with a single primval field", "tree": {"sha": "9c14e906d7ba7746529845068b5a13e12a1d1f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c14e906d7ba7746529845068b5a13e12a1d1f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ca0676abde64f6c863659f78cc1798dd5959738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca0676abde64f6c863659f78cc1798dd5959738", "html_url": "https://github.com/rust-lang/rust/commit/0ca0676abde64f6c863659f78cc1798dd5959738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ca0676abde64f6c863659f78cc1798dd5959738/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee8595375dadeaff743c848f298e8408f0bb5e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee8595375dadeaff743c848f298e8408f0bb5e9", "html_url": "https://github.com/rust-lang/rust/commit/6ee8595375dadeaff743c848f298e8408f0bb5e9"}, {"sha": "e2c5a6e64edf48a30fd7d593e90b1a97fe6a5aa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c5a6e64edf48a30fd7d593e90b1a97fe6a5aa7", "html_url": "https://github.com/rust-lang/rust/commit/e2c5a6e64edf48a30fd7d593e90b1a97fe6a5aa7"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "011a25774aca6118379a482f7d47c80282088023", "filename": "src/eval_context.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=0ca0676abde64f6c863659f78cc1798dd5959738", "patch": "@@ -317,14 +317,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match global_value.value {\n                     Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                        self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_inner_allocation(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n@@ -374,7 +374,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         discr_val: u128,\n         variant_idx: usize,\n         discr_size: u64,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        where J::IntoIter: ExactSizeIterator,\n+    {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n@@ -397,7 +399,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n         operands: J,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        where J::IntoIter: ExactSizeIterator,\n+    {\n+        if self.type_size(dest_ty)? == Some(0) {\n+            // zst assigning is a nop\n+            return Ok(());\n+        }\n+        if self.ty_to_primval_kind(dest_ty).is_ok() {\n+            let mut iter = operands.into_iter();\n+            assert_eq!(iter.len(), 1);\n+            let (value, value_ty) = iter.next().unwrap().into_val_ty_pair(self)?;\n+            return self.write_value(value, dest, value_ty);\n+        }\n         for (field_index, operand) in operands.into_iter().enumerate() {\n             let (value, value_ty) = operand.into_val_ty_pair(self)?;\n             let field_dest = self.lvalue_field(dest, field_index, dest_ty, value_ty)?;\n@@ -795,7 +809,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n+    pub fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n         let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n@@ -1052,8 +1066,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         a: PrimVal,\n         b: PrimVal,\n         ptr: Pointer,\n-        ty: Ty<'tcx>\n+        mut ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n+        while self.get_field_count(ty)? == 1 {\n+            ty = self.get_field_ty(ty, 0)?;\n+        }\n         assert_eq!(self.get_field_count(ty)?, 2);\n         let field_0 = self.get_field_offset(ty, 0)?.bytes();\n         let field_1 = self.get_field_offset(ty, 1)?.bytes();\n@@ -1109,7 +1126,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(ref def, _) if def.is_box() => PrimValKind::Ptr,\n \n-            ty::TyAdt(..) => {\n+            ty::TyAdt(ref def, substs) => {\n                 use rustc::ty::layout::Layout::*;\n                 match *self.type_layout(ty)? {\n                     CEnum { discr, signed, .. } => {\n@@ -1132,6 +1149,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n+                    // represent single field structs as their single field\n+                    Univariant { .. } => {\n+                        // enums with just one variant are no different, but `.struct_variant()` doesn't work for enums\n+                        let variant = &def.variants[0];\n+                        // FIXME: also allow structs with only a single non zst field\n+                        if variant.fields.len() == 1 {\n+                            return self.ty_to_primval_kind(variant.fields[0].ty(self.tcx, substs));\n+                        } else {\n+                            return Err(EvalError::TypeNotPrimitive(ty));\n+                        }\n+                    }\n+\n                     _ => return Err(EvalError::TypeNotPrimitive(ty)),\n                 }\n             }\n@@ -1320,8 +1349,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     return self.unsize_into_ptr(src, src_ty, dest, dest_ty, src_ty.boxed_ty(), dest_ty.boxed_ty());\n                 }\n-                // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr();\n+                if self.ty_to_primval_kind(src_ty).is_ok() {\n+                    let sty = self.get_field_ty(src_ty, 0)?;\n+                    let dty = self.get_field_ty(dest_ty, 0)?;\n+                    return self.unsize_into(src, sty, dest, dty);\n+                }\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n@@ -1338,6 +1370,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(\"expected pointer, got {:?}\", src),\n                 };\n \n+                // FIXME(solson)\n+                let dest = self.force_allocation(dest)?.to_ptr();\n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);"}, {"sha": "35fe958f7567ffe5cf5172a0896673e780afd7c5", "filename": "src/lvalue.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=0ca0676abde64f6c863659f78cc1798dd5959738", "patch": "@@ -219,14 +219,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (ptr, LvalueExtra::None)\n                 },\n                 Value::ByVal(PrimVal::Undef) => {\n-                    // FIXME: add some logic for when to not allocate\n-                    (self.force_allocation(base)?.to_ptr(), LvalueExtra::None)\n+                    // FIXME: allocate in fewer cases\n+                    if self.ty_to_primval_kind(base_ty).is_ok() {\n+                        return Ok(base);\n+                    } else {\n+                        (self.force_allocation(base)?.to_ptr(), LvalueExtra::None)\n+                    }\n                 },\n                 Value::ByVal(_) => {\n-                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n+                    assert_eq!(field_index, 0, \"ByVal can only have 1 non zst field with offset 0\");\n                     return Ok(base);\n                 },\n                 Value::ByValPair(_, _) => {\n+                    let field_count = self.get_field_count(base_ty)?;\n+                    if field_count == 1 {\n+                        assert_eq!(field_index, 0, \"{:?} has only one field\", base_ty);\n+                        return Ok(base);\n+                    }\n+                    assert_eq!(field_count, 2);\n                     assert!(field_index < 2);\n                     return Ok(Lvalue::Local {\n                         frame,"}, {"sha": "d6563c4c703cdf6fae382dec2d64aa69f35d70d5", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=0ca0676abde64f6c863659f78cc1798dd5959738", "patch": "@@ -658,13 +658,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n+        trace!(\"mark_static: {:?}\", alloc_id);\n         if alloc_id != NEVER_ALLOC_ID && alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n             bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n         }\n     }\n \n+    /// mark an allocation pointed to by a static as static and initialized\n+    pub fn mark_inner_allocation(&mut self, alloc: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+        // relocations into other statics are not \"inner allocations\"\n+        if !self.static_alloc.contains(&alloc) {\n+            self.mark_static_initalized(alloc, mutable)?;\n+        }\n+        Ok(())\n+    }\n+\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+        trace!(\"mark_static_initialized {:?}, mutable: {:?}\", alloc_id, mutable);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n@@ -684,10 +695,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            // relocations into other statics are not \"inner allocations\"\n-            if !self.static_alloc.contains(&alloc) {\n-                self.mark_static_initalized(alloc, mutable)?;\n-            }\n+            self.mark_inner_allocation(alloc, mutable)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "659f8e3152044c4771581500abd59522e18a0aa5", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca0676abde64f6c863659f78cc1798dd5959738/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=0ca0676abde64f6c863659f78cc1798dd5959738", "patch": "@@ -551,7 +551,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 args.push((undef, field_ty));\n                             }\n                         },\n-                        _ => bug!(\"rust-call ABI tuple argument was {:?}\", last),\n+                        _ => bug!(\"rust-call ABI tuple argument was {:?}, but {:?} were expected\", last, fields),\n                     }\n                 }\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),"}]}