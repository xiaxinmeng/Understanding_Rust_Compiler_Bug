{"sha": "facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "node_id": "C_kwDOAAsO6NoAKGZhY2VjZjZlMWI5NmYzZGMxYzJhM2YxYmNmYjU2Y2FhMDE4ZTc4Y2Y", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-12T18:49:54Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-14T20:26:03Z"}, "message": "Fetch less HIR in signature check.", "tree": {"sha": "6ba8053c2997fd877f0d9d3928d1362c7f52f5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ba8053c2997fd877f0d9d3928d1362c7f52f5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "html_url": "https://github.com/rust-lang/rust/commit/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e12266ced4c43f07c53017f5ed094e93157a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e12266ced4c43f07c53017f5ed094e93157a18", "html_url": "https://github.com/rust-lang/rust/commit/e9e12266ced4c43f07c53017f5ed094e93157a18"}], "stats": {"total": 604, "additions": 97, "deletions": 507}, "files": [{"sha": "d5def628850437d8a8e9ea9022fed48ed5e36fe7", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 37, "deletions": 62, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -530,46 +530,33 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl { of_trait } => {\n-            if of_trait {\n-                let it = tcx.hir().item(id);\n-                let hir::ItemKind::Impl(impl_) = it.kind else { return };\n-                debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n-                if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n-                    check_impl_items_against_trait(\n-                        tcx,\n-                        it.span,\n-                        it.owner_id.def_id,\n-                        impl_trait_ref.subst_identity(),\n-                        &impl_.items,\n-                    );\n-                    check_on_unimplemented(tcx, it);\n-                }\n+            if of_trait && let Some(impl_trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n+                check_impl_items_against_trait(\n+                    tcx,\n+                    id.owner_id.def_id,\n+                    impl_trait_ref.subst_identity(),\n+                );\n+                check_on_unimplemented(tcx, id);\n             }\n         }\n         DefKind::Trait => {\n-            let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n-                return;\n-            };\n-            check_on_unimplemented(tcx, it);\n-\n-            for item in items.iter() {\n-                let item = tcx.hir().trait_item(item.id);\n-                match &item.kind {\n-                    hir::TraitItemKind::Fn(sig, _) => {\n-                        let abi = sig.header.abi;\n-                        fn_maybe_err(tcx, item.ident.span, abi);\n+            let assoc_items = tcx.associated_items(id.owner_id);\n+            check_on_unimplemented(tcx, id);\n+\n+            for assoc_item in assoc_items.in_definition_order() {\n+                match assoc_item.kind {\n+                    ty::AssocKind::Fn => {\n+                        let abi = tcx.fn_sig(assoc_item.def_id).skip_binder().abi();\n+                        fn_maybe_err(tcx, assoc_item.ident(tcx).span, abi);\n                     }\n-                    hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.owner_id);\n+                    ty::AssocKind::Type if assoc_item.defaultness(tcx).has_value() => {\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, id.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n-                            default.span,\n-                            tcx.mk_trait_ref(it.owner_id.to_def_id(), trait_substs),\n+                            tcx.mk_trait_ref(id.owner_id.to_def_id(), trait_substs),\n                         );\n                     }\n                     _ => {}\n@@ -681,7 +668,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     }\n }\n \n-pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n+pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: hir::ItemId) {\n     // an error would be reported if this fails.\n     let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n@@ -691,7 +678,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItemRef,\n+    impl_item: DefId,\n ) {\n     let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) else { return };\n     let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n@@ -737,10 +724,8 @@ pub(super) fn check_specialization_validity<'tcx>(\n \n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    full_impl_span: Span,\n     impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef],\n ) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -749,12 +734,14 @@ fn check_impl_items_against_trait<'tcx>(\n         return;\n     }\n \n+    let impl_item_refs = tcx.associated_item_def_ids(impl_id);\n+\n     // Negative impls are not expected to have any items\n     match tcx.impl_polarity(impl_id) {\n         ty::ImplPolarity::Reservation | ty::ImplPolarity::Positive => {}\n         ty::ImplPolarity::Negative => {\n             if let [first_item_ref, ..] = impl_item_refs {\n-                let first_item_span = tcx.hir().impl_item(first_item_ref.id).span;\n+                let first_item_span = tcx.def_span(first_item_ref);\n                 struct_span_err!(\n                     tcx.sess,\n                     first_item_span,\n@@ -769,43 +756,27 @@ fn check_impl_items_against_trait<'tcx>(\n \n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n-    for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n+    for &impl_item in impl_item_refs {\n+        let ty_impl_item = tcx.associated_item(impl_item);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n             // Checked in `associated_item`.\n-            tcx.sess.delay_span_bug(impl_item.span, \"missing associated item in trait\");\n+            tcx.sess.delay_span_bug(tcx.def_span(impl_item), \"missing associated item in trait\");\n             continue;\n         };\n-        let impl_item_full = tcx.hir().impl_item(impl_item.id);\n-        match impl_item_full.kind {\n-            hir::ImplItemKind::Const(..) => {\n+        match ty_impl_item.kind {\n+            ty::AssocKind::Const => {\n                 let _ = tcx.compare_impl_const((\n-                    impl_item.id.owner_id.def_id,\n+                    impl_item.expect_local(),\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }\n-            hir::ImplItemKind::Fn(..) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_method(\n-                    tcx,\n-                    &ty_impl_item,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Fn => {\n+                compare_impl_method(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n-            hir::ImplItemKind::Type(impl_ty) => {\n-                let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                compare_impl_ty(\n-                    tcx,\n-                    &ty_impl_item,\n-                    impl_ty.span,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                    opt_trait_span,\n-                );\n+            ty::AssocKind::Type => {\n+                compare_impl_ty(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n             }\n         }\n \n@@ -840,6 +811,8 @@ fn check_impl_items_against_trait<'tcx>(\n                 .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n+                let full_impl_span =\n+                    tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n                 match tcx.eval_default_body_stability(trait_item_id, full_impl_span) {\n                     EvalResult::Deny { feature, reason, issue, .. } => default_body_is_unstable(\n                         tcx,\n@@ -866,6 +839,8 @@ fn check_impl_items_against_trait<'tcx>(\n         }\n \n         if !missing_items.is_empty() {\n+            let full_impl_span =\n+                tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n             missing_items_err(tcx, tcx.def_span(impl_id), &missing_items, full_impl_span);\n         }\n "}, {"sha": "50f9bbc022e7cf91317d0920ab7bf5485ab17f30", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -33,31 +33,26 @@ use std::iter;\n /// # Parameters\n ///\n /// - `impl_m`: type of the method we are checking\n-/// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.def_span(impl_m.def_id);\n-\n     let _: Result<_, ErrorGuaranteed> = try {\n-        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n-        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_self_type(tcx, impl_m, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, false)?;\n         compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_number_of_method_arguments(tcx, impl_m, trait_m)?;\n         compare_synthetic_generics(tcx, impl_m, trait_m)?;\n-        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_asyncness(tcx, impl_m, trait_m)?;\n         compare_method_predicate_entailment(\n             tcx,\n             impl_m,\n-            impl_m_span,\n             trait_m,\n             impl_trait_ref,\n             CheckImpliedWfMode::Check,\n@@ -131,11 +126,10 @@ pub(super) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n-#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n+#[instrument(level = \"debug\", skip(tcx, impl_trait_ref))]\n fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     check_implied_wf: CheckImpliedWfMode,\n@@ -148,6 +142,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_def_id = impl_m.def_id.expect_local();\n+    let impl_m_span = tcx.def_span(impl_m_def_id);\n     let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_def_id,\n@@ -315,7 +310,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -353,7 +347,6 @@ fn compare_method_predicate_entailment<'tcx>(\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n-                    impl_m_span,\n                     trait_m,\n                     impl_trait_ref,\n                     CheckImpliedWfMode::Skip,\n@@ -535,9 +528,7 @@ enum CheckImpliedWfMode {\n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -549,9 +540,9 @@ fn compare_asyncness<'tcx>(\n             }\n             _ => {\n                 return Err(tcx.sess.emit_err(crate::errors::AsyncTraitImplShouldBeAsync {\n-                    span: impl_m_span,\n+                    span: tcx.def_span(impl_m.def_id),\n                     method_name: trait_m.name,\n-                    trait_item_span,\n+                    trait_item_span: tcx.hir().span_if_local(trait_m.def_id),\n                 }));\n             }\n         };\n@@ -606,7 +597,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     // First, check a few of the same things as `compare_impl_method`,\n     // just so we don't ICE during substitution later.\n-    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_number_of_generics(tcx, impl_m, trait_m, true)?;\n     compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n     check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n \n@@ -1094,7 +1085,6 @@ fn extract_spans_for_error_reporting<'tcx>(\n fn compare_self_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1130,6 +1120,7 @@ fn compare_self_type<'tcx>(\n \n         (false, true) => {\n             let self_descr = self_string(impl_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1149,6 +1140,7 @@ fn compare_self_type<'tcx>(\n \n         (true, false) => {\n             let self_descr = self_string(trait_m);\n+            let impl_m_span = tcx.def_span(impl_m.def_id);\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 impl_m_span,\n@@ -1196,7 +1188,6 @@ fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n     trait_: &ty::AssocItem,\n-    trait_span: Option<Span>,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n@@ -1256,6 +1247,7 @@ fn compare_number_of_generics<'tcx>(\n                     .collect();\n                 (Some(arg_spans), impl_trait_spans)\n             } else {\n+                let trait_span = tcx.hir().span_if_local(trait_.def_id);\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n \n@@ -1338,9 +1330,7 @@ fn compare_number_of_generics<'tcx>(\n fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n-    trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1362,7 +1352,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     }\n                 })\n             })\n-            .or(trait_item_span);\n+            .or_else(|| tcx.hir().span_if_local(trait_m.def_id));\n \n         let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n@@ -1377,7 +1367,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                 }\n             })\n-            .unwrap_or(impl_m_span);\n+            .unwrap_or_else(|| tcx.def_span(impl_m.def_id));\n \n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -1747,22 +1737,16 @@ pub(super) fn compare_impl_const_raw(\n pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_span: Option<Span>,\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = try {\n-        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n-\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, false)?;\n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n-\n-        let sp = tcx.def_span(impl_ty.def_id);\n-        compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n-\n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+        compare_type_predicate_entailment(tcx, impl_ty, trait_ty, impl_trait_ref)?;\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_trait_ref)?;\n     };\n }\n \n@@ -1771,7 +1755,6 @@ pub(super) fn compare_impl_ty<'tcx>(\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     trait_ty: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -1808,6 +1791,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n+    let impl_ty_span = tcx.def_span(impl_ty_def_id);\n     let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n@@ -1873,7 +1857,6 @@ pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n-    impl_ty_span: Span,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Given\n@@ -2009,8 +1992,15 @@ pub(super) fn check_type_bounds<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(&infcx);\n \n-    let assumed_wf_types =\n-        ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n+    let impl_ty_span = match tcx.hir().get_by_def_id(impl_ty_def_id) {\n+        hir::Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Type(_, Some(ty)),\n+            ..\n+        }) => ty.span,\n+        hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Type(ty), .. }) => ty.span,\n+        _ => bug!(),\n+    };\n+    let assumed_wf_types = ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty_def_id);\n \n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,"}, {"sha": "7b013cabc3ab58bd7e4f3eeeb0206088458e03e4", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -75,7 +75,6 @@ pub use check::check_abi;\n use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_index::bit_set::BitSet;\n@@ -169,27 +168,24 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n     }\n }\n \n-fn report_forbidden_specialization(\n-    tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItemRef,\n-    parent_impl: DefId,\n-) {\n+fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_impl: DefId) {\n+    let span = tcx.def_span(impl_item);\n+    let ident = tcx.item_name(impl_item);\n     let mut err = struct_span_err!(\n         tcx.sess,\n-        impl_item.span,\n+        span,\n         E0520,\n-        \"`{}` specializes an item from a parent `impl`, but \\\n-         that item is not marked `default`\",\n-        impl_item.ident\n+        \"`{}` specializes an item from a parent `impl`, but that item is not marked `default`\",\n+        ident,\n     );\n-    err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\", impl_item.ident));\n+    err.span_label(span, format!(\"cannot specialize default item `{}`\", ident));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n             err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\n                 \"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                impl_item.ident\n+                ident\n             ));\n         }\n         Err(cname) => {"}, {"sha": "9f36e5315ecc2dad431ebc5d898e5c457b0c3262", "filename": "tests/rustdoc-ui/issue-105742.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Frustdoc-ui%2Fissue-105742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Frustdoc-ui%2Fissue-105742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.rs?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -3,38 +3,17 @@\n use std::ops::Index;\n \n pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n     let _ = s;\n }\n \n pub trait SVec: Index<\n     <Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Index<<Self as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n     Output = <Self as SVec>::Item> as SVec>::Item,\n-//~^ ERROR\n-//~^^ ERROR\n-//~^^^ ERROR\n-//~^^^^ ERROR\n-//~^^^^^ ERROR\n-//~^^^^^^ ERROR\n-//~^^^^^^^ ERROR\n-//~^^^^^^^^ ERROR\n > {\n     type Item<'a, T>;\n \n     fn len(&self) -> <Self as SVec>::Item;\n     //~^ ERROR\n     //~^^ ERROR\n-    //~^^^ ERROR\n-    //~^^^^ ERROR\n }"}, {"sha": "4d2ee9726891797487dc818b7102baf9d919dcba", "filename": "tests/rustdoc-ui/issue-105742.stderr", "status": "modified", "additions": 6, "deletions": 356, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Frustdoc-ui%2Fissue-105742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Frustdoc-ui%2Fissue-105742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-105742.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -1,360 +1,11 @@\n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<'_> = T, Output = T>) {\n-   |                                            ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:5:40\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                                        ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item<T> = T, Output = T>) {\n-   |                                            +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     <Self as SVec>::Item<'a>,\n-   |                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:13:21\n-   |\n-LL |     <Self as SVec>::Item,\n-   |                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     <Self as SVec>::Item<T>,\n-   |                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<'a>,\n-   |                                         ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:18:37\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item,\n-   |                                     ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Index<<Self as SVec>::Item<T>,\n-   |                                         +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item<'a>> as SVec>::Item,\n-   |                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:30\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item<T>> as SVec>::Item,\n-   |                                  +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<'a>,\n-   |                                                  ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:23:46\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item,\n-   |                                              ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     Output = <Self as SVec>::Item> as SVec>::Item<T>,\n-   |                                                  +++\n-\n-error[E0038]: the trait `SVec` cannot be made into an object\n-  --> $DIR/issue-105742.rs:5:31\n-   |\n-LL | pub fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SVec` cannot be made into an object\n-   |\n-note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/issue-105742.rs:12:17\n-   |\n-LL |    pub trait SVec: Index<\n-   |  ____________----__^\n-   | |            |\n-   | |            this trait cannot be made into an object...\n-LL | |      <Self as SVec>::Item,\n-LL | |\n-LL | |\n-...  |\n-LL | |/     Output = <Index<<Self as SVec>::Item,\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||\n-LL | ||     Output = <Self as SVec>::Item> as SVec>::Item,\n-   | ||_________________________________________________^ ...because it uses `Self` as a type parameter\n-...  |\n-LL | |\n-LL | |  > {\n-   | |__^ ...because it uses `Self` as a type parameter\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 lifetime argument\n-   |\n-note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^ --\n-help: add missing lifetime argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n-   |                                          ++++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item;\n-   |                                      ^^^^ expected 1 generic argument\n-   |\n-note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n-   |\n-LL |     type Item<'a, T>;\n-   |          ^^^^     -\n-help: add missing generic argument\n-   |\n-LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n-   |                                          +++\n-\n-error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 lifetime argument\n    |\n note: associated type defined here, with 1 lifetime parameter: `'a`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^ --\n@@ -364,13 +15,13 @@ LL |     fn len(&self) -> <Self as SVec>::Item<'_>;\n    |                                          ++++\n \n error[E0107]: missing generics for associated type `SVec::Item`\n-  --> $DIR/issue-105742.rs:35:38\n+  --> $DIR/issue-105742.rs:16:38\n    |\n LL |     fn len(&self) -> <Self as SVec>::Item;\n    |                                      ^^^^ expected 1 generic argument\n    |\n note: associated type defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-105742.rs:33:10\n+  --> $DIR/issue-105742.rs:14:10\n    |\n LL |     type Item<'a, T>;\n    |          ^^^^     -\n@@ -379,7 +30,6 @@ help: add missing generic argument\n LL |     fn len(&self) -> <Self as SVec>::Item<T>;\n    |                                          +++\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0038, E0107.\n-For more information about an error, try `rustc --explain E0038`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "06658a49b83aaf7684e3c4eec57bb9cddedbce1e", "filename": "tests/ui/error-codes/E0520.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Ferror-codes%2FE0520.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Ferror-codes%2FE0520.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0520.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -15,7 +15,7 @@ LL | impl<T: Clone> SpaceLlama for T {\n    | ------------------------------- parent `impl` is here\n ...\n LL |     default fn fly(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `fly`\n    |\n    = note: to specialize, `fly` in the parent `impl` must be marked `default`\n "}, {"sha": "f9e62a99baee8e5b0db9e0ad3b32173bf088a772", "filename": "tests/ui/specialization/defaultimpl/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "3fc29fff230a33289f0c8c120489f8e2a914806a", "filename": "tests/ui/specialization/issue-50452-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fissue-50452-fail.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -12,7 +12,7 @@ error[E0520]: `foo` specializes an item from a parent `impl`, but that item is n\n   --> $DIR/issue-50452-fail.rs:10:5\n    |\n LL |     fn foo() {}\n-   |     ^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^ cannot specialize default item `foo`\n ...\n LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here"}, {"sha": "9d62a353da728a497f1ce96b5d2f5b452ab83bee", "filename": "tests/ui/specialization/non-defaulted-item-fail.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fnon-defaulted-item-fail.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Foo for Box<T> {\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     type Ty = Vec<()>;\n-   |     ^^^^^^^^^^^^^^^^^^ cannot specialize default item `Ty`\n+   |     ^^^^^^^ cannot specialize default item `Ty`\n    |\n    = note: to specialize, `Ty` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     const CONST: u8 = 42;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n+   |     ^^^^^^^^^^^^^^^ cannot specialize default item `CONST`\n    |\n    = note: to specialize, `CONST` in the parent `impl` must be marked `default`\n \n@@ -70,7 +70,7 @@ LL | impl<T> Foo for Vec<T> {}\n    | ---------------------- parent `impl` is here\n ...\n LL |     fn foo(&self) -> bool { true }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n "}, {"sha": "695a3f6cc45d10c25a5d0a541140c3449889380c", "filename": "tests/ui/specialization/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-no-default.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -15,7 +15,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn foo(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `foo`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `foo`\n    |\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n@@ -26,7 +26,7 @@ LL | impl<T> Foo for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     fn bar(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `bar`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `bar`\n    |\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n@@ -37,7 +37,7 @@ LL | impl<T> Bar for T {\n    | ----------------- parent `impl` is here\n ...\n LL |     type T = ();\n-   |     ^^^^^^^^^^^^ cannot specialize default item `T`\n+   |     ^^^^^^ cannot specialize default item `T`\n    |\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n@@ -48,7 +48,7 @@ LL | impl<T: Clone> Baz for T {\n    | ------------------------ parent `impl` is here\n ...\n LL |     fn baz(&self) {}\n-   |     ^^^^^^^^^^^^^^^^ cannot specialize default item `baz`\n+   |     ^^^^^^^^^^^^^ cannot specialize default item `baz`\n    |\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n@@ -59,7 +59,7 @@ LL | impl<T: Clone> Redundant for T {\n    | ------------------------------ parent `impl` is here\n ...\n LL |     default fn redundant(&self) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot specialize default item `redundant`\n    |\n    = note: to specialize, `redundant` in the parent `impl` must be marked `default`\n "}, {"sha": "040d9d14503f0f4dd332138db61d79e9bc21c326", "filename": "tests/ui/traits/negative-impls/no-items.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fno-items.stderr?ref=facecf6e1b96f3dc1c2a3f1bcfb56caa018e78cf", "patch": "@@ -2,7 +2,7 @@ error[E0749]: negative impls cannot have any items\n   --> $DIR/no-items.rs:8:5\n    |\n LL |     type Foo = i32;\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}]}