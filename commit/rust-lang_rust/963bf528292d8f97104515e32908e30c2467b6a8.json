{"sha": "963bf528292d8f97104515e32908e30c2467b6a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2JmNTI4MjkyZDhmOTcxMDQ1MTVlMzI5MDhlMzBjMjQ2N2I2YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T03:48:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T03:48:47Z"}, "message": "Auto merge of #70705 - lcnr:generic_discriminant, r=nikomatsakis\n\nUse `T`'s discriminant type in `mem::Discriminant<T>` instead of `u64`.\n\nfixes #70509\n\nAdds the lang-item `discriminant_kind`.\nUpdates the function signature of `intrinsics::discriminant_value`.\nAdds the *probably permanently unstable* trait `DiscriminantKind`.\n`mem::Discriminant` should now be smaller in some cases.\n\nr? @ghost", "tree": {"sha": "e6f2a5cf24832f59d7a8f86857b23dc95598016c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f2a5cf24832f59d7a8f86857b23dc95598016c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963bf528292d8f97104515e32908e30c2467b6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963bf528292d8f97104515e32908e30c2467b6a8", "html_url": "https://github.com/rust-lang/rust/commit/963bf528292d8f97104515e32908e30c2467b6a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963bf528292d8f97104515e32908e30c2467b6a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82911b3bba76e73afe2881b732fe6b0edb35d5d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/82911b3bba76e73afe2881b732fe6b0edb35d5d3", "html_url": "https://github.com/rust-lang/rust/commit/82911b3bba76e73afe2881b732fe6b0edb35d5d3"}, {"sha": "08b9b97c5374f4a7523cbb189bbe0ab1ed80ed64", "url": "https://api.github.com/repos/rust-lang/rust/commits/08b9b97c5374f4a7523cbb189bbe0ab1ed80ed64", "html_url": "https://github.com/rust-lang/rust/commit/08b9b97c5374f4a7523cbb189bbe0ab1ed80ed64"}], "stats": {"total": 589, "additions": 450, "deletions": 139}, "files": [{"sha": "20c7d7dcec8d6a512f668a03ac55b65b391ee047", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -287,6 +287,7 @@ the source code.\n   - `unsize`: `libcore/marker.rs`\n   - `sync`: `libcore/marker.rs`\n   - `phantom_data`: `libcore/marker.rs`\n+  - `discriminant_kind`: `libcore/marker.rs`\n   - `freeze`: `libcore/marker.rs`\n   - `debug_trait`: `libcore/fmt/mod.rs`\n   - `non_zero`: `libcore/nonzero.rs`"}, {"sha": "9006e4cfaf7bbc0e70bb5a2dd6cf1ea901a51075", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -54,6 +54,8 @@\n )]\n #![allow(missing_docs)]\n \n+#[cfg(not(bootstrap))]\n+use crate::marker::DiscriminantKind;\n use crate::mem;\n \n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n@@ -1912,6 +1914,10 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::discriminant`](../../std/mem/fn.discriminant.html)\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n+    #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n+    #[cfg(bootstrap)]\n     pub fn discriminant_value<T>(v: &T) -> u64;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`"}, {"sha": "c0c0f66aff90867f68b72cf073b120bb4bc8cb5d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -8,6 +8,7 @@\n \n use crate::cell::UnsafeCell;\n use crate::cmp;\n+use crate::fmt::Debug;\n use crate::hash::Hash;\n use crate::hash::Hasher;\n \n@@ -679,6 +680,37 @@ mod impls {\n     unsafe impl<T: Send + ?Sized> Send for &mut T {}\n }\n \n+/// Compiler-internal trait used to indicate the type of enum discriminants.\n+///\n+/// This trait is automatically implemented for every type and does not add any\n+/// guarantees to [`mem::Discriminant`]. It is **undefined behavior** to transmute\n+/// between `DiscriminantKind::Discriminant` and `mem::Discriminant`.\n+///\n+/// [`mem::Discriminant`]: https://doc.rust-lang.org/stable/core/mem/struct.Discriminant.html\n+#[unstable(\n+    feature = \"discriminant_kind\",\n+    issue = \"none\",\n+    reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n+)]\n+#[cfg_attr(not(bootstrap), lang = \"discriminant_kind\")]\n+pub trait DiscriminantKind {\n+    /// The type of the dicriminant, which must satisfy the trait\n+    /// bounds required by `mem::Discriminant`.\n+    type Discriminant: Clone + Copy + Debug + Eq + PartialEq + Hash + Send + Sync + Unpin;\n+}\n+\n+// Manually implement `DiscriminantKind` for all types during bootstrap\n+// to reduce the required amount of conditional compilation.\n+#[unstable(\n+    feature = \"discriminant_kind\",\n+    issue = \"none\",\n+    reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n+)]\n+#[cfg(bootstrap)]\n+impl<T: ?Sized> DiscriminantKind for T {\n+    type Discriminant = u64;\n+}\n+\n /// Compiler-internal trait used to determine whether a type contains\n /// any `UnsafeCell` internally, but not through an indirection.\n /// This affects, for example, whether a `static` of that type is"}, {"sha": "010f2958e36b9ecd940b9ab4493762e5f589852e", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -10,7 +10,7 @@ use crate::cmp;\n use crate::fmt;\n use crate::hash;\n use crate::intrinsics;\n-use crate::marker::{Copy, PhantomData, Sized};\n+use crate::marker::{Copy, DiscriminantKind, Sized};\n use crate::ptr;\n \n mod manually_drop;\n@@ -930,7 +930,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n ///\n /// [`discriminant`]: fn.discriminant.html\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n+pub struct Discriminant<T>(<T as DiscriminantKind>::Discriminant);\n \n // N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n \n@@ -995,5 +995,5 @@ impl<T> fmt::Debug for Discriminant<T> {\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n-    Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    Discriminant(intrinsics::discriminant_value(v))\n }"}, {"sha": "a9567f20d6925ea0dd1f6a4a2fa2ed9887942304", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 70, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -187,7 +187,6 @@ use rustc_ast::ptr::P;\n use rustc_attr as attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_session::parse::ParseSess;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -437,14 +436,7 @@ impl<'a> TraitDef<'a> {\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it\n                         // is fine.\n-                        self.expand_enum_def(\n-                            cx,\n-                            enum_def,\n-                            &item.attrs,\n-                            item.ident,\n-                            generics,\n-                            from_scratch,\n-                        )\n+                        self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n@@ -769,7 +761,6 @@ impl<'a> TraitDef<'a> {\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         enum_def: &'a EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n@@ -801,7 +792,6 @@ impl<'a> TraitDef<'a> {\n                         cx,\n                         self,\n                         enum_def,\n-                        type_attrs,\n                         type_ident,\n                         self_args,\n                         &nonself_args[..],\n@@ -816,38 +806,6 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(sess: &ParseSess, type_attrs: &[ast::Attribute]) -> &'static str {\n-    let mut repr_type_name = \"isize\";\n-    for a in type_attrs {\n-        for r in &attr::find_repr_attrs(sess, a) {\n-            repr_type_name = match *r {\n-                attr::ReprPacked(_)\n-                | attr::ReprSimd\n-                | attr::ReprAlign(_)\n-                | attr::ReprTransparent\n-                | attr::ReprNoNiche => continue,\n-\n-                attr::ReprC => \"i32\",\n-\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::Isize)) => \"isize\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n-                attr::ReprInt(attr::SignedInt(ast::IntTy::I128)) => \"i128\",\n-\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::Usize)) => \"usize\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n-                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U128)) => \"u128\",\n-            }\n-        }\n-    }\n-    repr_type_name\n-}\n-\n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(\n         &self,\n@@ -1148,20 +1106,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n-        self.build_enum_match_tuple(\n-            cx,\n-            trait_,\n-            enum_def,\n-            type_attrs,\n-            type_ident,\n-            self_args,\n-            nonself_args,\n-        )\n+        self.build_enum_match_tuple(cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n \n     /// Creates a match for a tuple of all `self_args`, where either all\n@@ -1181,11 +1130,11 @@ impl<'a> MethodDef<'a> {\n \n     /// ```{.text}\n     /// let __self0_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&self) } as i32;\n+    ///     std::intrinsics::discriminant_value(&self) };\n     /// let __self1_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg1) } as i32;\n+    ///     std::intrinsics::discriminant_value(&arg1) };\n     /// let __self2_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg2) } as i32;\n+    ///     std::intrinsics::discriminant_value(&arg2) };\n     ///\n     /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n     ///     match (...) {\n@@ -1204,7 +1153,6 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n-        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n@@ -1392,39 +1340,31 @@ impl<'a> MethodDef<'a> {\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n             // Build a series of let statements mapping each self_arg\n-            // to its discriminant value. If this is a C-style enum\n-            // with a specific repr type, then casts the values to\n-            // that type.  Otherwise casts to `i32` (the default repr\n-            // type).\n+            // to its discriminant value.\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //\n             // ```\n             // let __self0_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&self) } as i32;\n+            //     std::intrinsics::discriminant_value(&self) };\n             // let __self1_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg1) } as i32;\n+            //     std::intrinsics::discriminant_value(&arg1) };\n             // let __self2_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg2) } as i32;\n+            //     std::intrinsics::discriminant_value(&arg2) };\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n             // We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n-            let target_type_name = find_repr_type_name(&cx.parse_sess, type_attrs);\n-\n             let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n-\n-                let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name, sp));\n-                let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n                 match first_ident {"}, {"sha": "1e6d2e3dbb74ef1c8758a920f32f479776f9ba6f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -188,11 +188,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"needs_drop\" | \"type_id\"\n             | \"type_name\" => {\n-                let ty_name = self\n+                let value = self\n                     .tcx\n                     .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n                     .unwrap();\n-                OperandRef::from_const(self, ty_name, ret_ty).immediate_or_packed_pair(self)\n+                OperandRef::from_const(self, value, ret_ty).immediate_or_packed_pair(self)\n             }\n             // Effectively no-op\n             \"forget\" => {\n@@ -549,7 +549,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n-            \"discriminant_value\" => args[0].deref(self.cx()).codegen_get_discr(self, ret_ty),\n+            \"discriminant_value\" => {\n+                if ret_ty.is_integral() {\n+                    args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n+                } else {\n+                    span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n+                }\n+            }\n \n             name if name.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {"}, {"sha": "04fe3b60b6a875cdaa439f3bbfa68107bbf63509", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -163,6 +163,7 @@ language_item_table! {\n     CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n     CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n     SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n+    DiscriminantKindTraitLangItem,\"discriminant_kind\", discriminant_kind_trait, Target::Trait;\n     FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n \n     DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;"}, {"sha": "7c433574d1843cc3ebcf2b2b9c124da92844fc99", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -32,6 +32,7 @@\n #![feature(const_panic)]\n #![feature(const_transmute)]\n #![feature(core_intrinsics)]\n+#![feature(discriminant_kind)]\n #![feature(drain_filter)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]"}, {"sha": "9afab5a4d2fe9d49705f3e245c1ff09929c35411", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -411,6 +411,9 @@ pub enum Vtable<'tcx, N> {\n     /// Same as above, but for a function pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n \n+    /// Vtable for a builtin `DeterminantKind` trait implementation.\n+    VtableDiscriminantKind(VtableDiscriminantKindData),\n+\n     /// Vtable automatically generated for a generator.\n     VtableGenerator(VtableGeneratorData<'tcx, N>),\n \n@@ -429,6 +432,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableGenerator(c) => c.nested,\n             VtableObject(d) => d.nested,\n             VtableFnPointer(d) => d.nested,\n+            VtableDiscriminantKind(VtableDiscriminantKindData) => Vec::new(),\n             VtableTraitAlias(d) => d.nested,\n         }\n     }\n@@ -443,6 +447,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableGenerator(c) => &c.nested[..],\n             VtableObject(d) => &d.nested[..],\n             VtableFnPointer(d) => &d.nested[..],\n+            VtableDiscriminantKind(VtableDiscriminantKindData) => &[],\n             VtableTraitAlias(d) => &d.nested[..],\n         }\n     }\n@@ -484,6 +489,9 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n+            VtableDiscriminantKind(VtableDiscriminantKindData) => {\n+                VtableDiscriminantKind(VtableDiscriminantKindData)\n+            }\n             VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -560,6 +568,10 @@ pub struct VtableFnPointerData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n+// FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableDiscriminantKindData;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct VtableTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,"}, {"sha": "a12f5910b14b969005aa341de5c7fdee9bdf8fca", "filename": "src/librustc_middle/traits/select.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fselect.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> SelectionCache<'tcx> {\n /// clauses, and so forth that might resolve an obligation. Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not\n /// apply to the obligation: perhaps it is defined for `usize` but the\n-/// obligation is for `int`. In that case, we drop the impl out of the\n+/// obligation is for `i32`. In that case, we drop the impl out of the\n /// list. But the other cases are considered *candidates*.\n ///\n /// For selection to succeed, there must be exactly one matching\n@@ -54,12 +54,14 @@ impl<'tcx> SelectionCache<'tcx> {\n /// will always be satisfied) picking the blanket impl will be wrong\n /// for at least *some* substitutions. To make this concrete, if we have\n ///\n-///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n-///    impl<T: fmt::Debug> AsDebug for T {\n-///        type Out = T;\n-///        fn debug(self) -> fmt::Debug { self }\n-///    }\n-///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+/// ```rust, ignore\n+/// trait AsDebug { type Out: fmt::Debug; fn debug(self) -> Self::Out; }\n+/// impl<T: fmt::Debug> AsDebug for T {\n+///     type Out = T;\n+///     fn debug(self) -> fmt::Debug { self }\n+/// }\n+/// fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+/// ```\n ///\n /// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n /// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n@@ -79,14 +81,16 @@ impl<'tcx> SelectionCache<'tcx> {\n /// inference variables. The can lead to inference making \"leaps of logic\",\n /// for example in this situation:\n ///\n-///    pub trait Foo<T> { fn foo(&self) -> T; }\n-///    impl<T> Foo<()> for T { fn foo(&self) { } }\n-///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n+/// ```rust, ignore\n+/// pub trait Foo<T> { fn foo(&self) -> T; }\n+/// impl<T> Foo<()> for T { fn foo(&self) { } }\n+/// impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n ///\n-///    pub fn foo<T>(t: T) where T: Foo<bool> {\n-///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n-///    }\n-///    fn main() { foo(false); }\n+/// pub fn foo<T>(t: T) where T: Foo<bool> {\n+///     println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n+/// }\n+/// fn main() { foo(false); }\n+/// ```\n ///\n /// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n /// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n@@ -128,6 +132,9 @@ pub enum SelectionCandidate<'tcx> {\n     /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n     FnPointerCandidate,\n \n+    /// Builtin implementation of `DiscriminantKind`.\n+    DiscriminantKindCandidate,\n+\n     TraitAliasCandidate(DefId),\n \n     ObjectCandidate,"}, {"sha": "74f744152949909adc6216ad159ce002a3d19ec3", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -19,6 +19,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n \n             super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n \n+            super::VtableDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+\n             super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n \n             super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n@@ -274,6 +276,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                     traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n                 })\n             }\n+            traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData) => {\n+                Some(traits::VtableDiscriminantKind(traits::VtableDiscriminantKindData))\n+            }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {"}, {"sha": "1cd4af45f29569cb9ef7ec98ec1448d4065bf6b8", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -15,8 +15,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n+use std::convert::{TryFrom, TryInto};\n use std::hash::Hash;\n use std::intrinsics;\n+use std::marker::DiscriminantKind;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -60,6 +62,7 @@ where\n     E: TyEncoder,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n     T: EncodableWithShorthand,\n+    <T::Variant as DiscriminantKind>::Discriminant: Ord + TryFrom<usize>,\n {\n     let existing_shorthand = cache(encoder).get(value).cloned();\n     if let Some(shorthand) = existing_shorthand {\n@@ -75,7 +78,8 @@ where\n     // The shorthand encoding uses the same usize as the\n     // discriminant, with an offset so they can't conflict.\n     let discriminant = intrinsics::discriminant_value(variant);\n-    assert!(discriminant < SHORTHAND_OFFSET as u64);\n+    assert!(discriminant < SHORTHAND_OFFSET.try_into().ok().unwrap());\n+\n     let shorthand = start + SHORTHAND_OFFSET;\n \n     // Get the number of bits that leb128 could fit"}, {"sha": "42b969c99917ffa92f5cafae0999239e1c2f489e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -2,8 +2,6 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n-use std::convert::TryFrom;\n-\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n@@ -220,7 +218,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::discriminant_value => {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n-                self.write_scalar(Scalar::from_u64(u64::try_from(discr_val).unwrap()), dest)?;\n+                let scalar = match dest.layout.ty.kind {\n+                    ty::Int(_) => Scalar::from_int(discr_val as i128, dest.layout.size),\n+                    ty::Uint(_) => Scalar::from_uint(discr_val, dest.layout.size),\n+                    _ => bug!(\"invalid `discriminant_value` return layout: {:?}\", dest.layout),\n+                };\n+                self.write_scalar(scalar, dest)?;\n             }\n             sym::unchecked_shl\n             | sym::unchecked_shr"}, {"sha": "f102f34c744de56d2c11fc08aef0392e27506bc9", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 81, "deletions": 4, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -12,7 +12,10 @@ use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n-use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableImplData};\n+use super::{\n+    VtableClosureData, VtableDiscriminantKindData, VtableFnPointerData, VtableGeneratorData,\n+    VtableImplData,\n+};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n@@ -23,6 +26,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{FnOnceTraitLangItem, GeneratorTraitLangItem};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n@@ -1043,6 +1047,46 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     }\n                 }\n             }\n+            super::VtableDiscriminantKind(..) => {\n+                // While `DiscriminantKind` is automatically implemented for every type,\n+                // the concrete discriminant may not be known yet.\n+                //\n+                // Any type with multiple potential discriminant types is therefore not eligible.\n+                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+\n+                match self_ty.kind {\n+                    ty::Bool\n+                    | ty::Char\n+                    | ty::Int(_)\n+                    | ty::Uint(_)\n+                    | ty::Float(_)\n+                    | ty::Adt(..)\n+                    | ty::Foreign(_)\n+                    | ty::Str\n+                    | ty::Array(..)\n+                    | ty::Slice(_)\n+                    | ty::RawPtr(..)\n+                    | ty::Ref(..)\n+                    | ty::FnDef(..)\n+                    | ty::FnPtr(..)\n+                    | ty::Dynamic(..)\n+                    | ty::Closure(..)\n+                    | ty::Generator(..)\n+                    | ty::GeneratorWitness(..)\n+                    | ty::Never\n+                    | ty::Tuple(..)\n+                    // Integers and floats always have `u8` as their discriminant.\n+                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                    ty::Projection(..)\n+                    | ty::Opaque(..)\n+                    | ty::Param(..)\n+                    | ty::Bound(..)\n+                    | ty::Placeholder(..)\n+                    | ty::Infer(..)\n+                    | ty::Error => false,\n+                }\n+            }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:\n@@ -1124,13 +1168,15 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::VtableGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n         super::VtableClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n         super::VtableFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::VtableDiscriminantKind(data) => {\n+            confirm_discriminant_kind_candidate(selcx, obligation, data)\n+        }\n         super::VtableObject(_) => confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n         super::VtableAutoImpl(..)\n         | super::VtableParam(..)\n         | super::VtableBuiltin(..)\n-        | super::VtableTraitAlias(..) =>\n-        // we don't create Select candidates with this kind of resolution\n-        {\n+        | super::VtableTraitAlias(..) => {\n+            // we don't create Select candidates with this kind of resolution\n             span_bug!(\n                 obligation.cause.span,\n                 \"Cannot project an associated type from `{:?}`\",\n@@ -1259,6 +1305,37 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         .with_addl_obligations(obligations)\n }\n \n+fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    _: VtableDiscriminantKindData,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+    let substs = tcx.mk_substs([self_ty.into()].iter());\n+\n+    let assoc_items = tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n+    // FIXME: emit an error if the trait definition is wrong\n+    let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n+\n+    let discriminant_ty = match self_ty.kind {\n+        // Use the discriminant type for enums.\n+        ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n+        // Default to `i32` for generators.\n+        ty::Generator(..) => tcx.types.i32,\n+        // Use `u8` for all other types.\n+        _ => tcx.types.u8,\n+    };\n+\n+    let predicate = ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy { substs, item_def_id: discriminant_def_id },\n+        ty: discriminant_ty,\n+    };\n+\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate))\n+}\n+\n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "d903779e5075fa925d0f26eba1c32f30b10311bf", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -24,12 +24,13 @@ use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n use super::{\n-    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableFnPointer, VtableGenerator, VtableImpl,\n-    VtableObject, VtableParam, VtableTraitAlias,\n+    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n+    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n };\n use super::{\n-    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableFnPointerData,\n-    VtableGeneratorData, VtableImplData, VtableObjectData, VtableTraitAliasData,\n+    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n+    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n+    VtableTraitAliasData,\n };\n \n use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n@@ -1382,6 +1383,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // For other types, we'll use the builtin rules.\n             let copy_conditions = self.copy_clone_conditions(obligation);\n             self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n+            // `DiscriminantKind` is automatically implemented for every type.\n+            candidates.vec.push(DiscriminantKindCandidate);\n         } else if lang_items.sized_trait() == Some(def_id) {\n             // Sized is never implementable by end-users, it is\n             // always automatically computed.\n@@ -1995,22 +1999,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_global =\n             |cand: &ty::PolyTraitRef<'_>| cand.is_global() && !cand.has_late_bound_regions();\n \n+        // (*) Prefer `BuiltinCandidate { has_nested: false }` and `DiscriminantKindCandidate`\n+        // to anything else.\n+        //\n+        // This is a fix for #53123 and prevents winnowing from accidentally extending the\n+        // lifetime of a variable.\n         match other.candidate {\n-            // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n-            // This is a fix for #53123 and prevents winnowing from accidentally extending the\n-            // lifetime of a variable.\n-            BuiltinCandidate { has_nested: false } => true,\n+            // (*)\n+            BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => true,\n             ParamCandidate(ref cand) => match victim.candidate {\n                 AutoImplCandidate(..) => {\n                     bug!(\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\"\n                     );\n                 }\n-                // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n-                // This is a fix for #53123 and prevents winnowing from accidentally extending the\n-                // lifetime of a variable.\n-                BuiltinCandidate { has_nested: false } => false,\n+                // (*)\n+                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n@@ -2038,10 +2043,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          when there are other valid candidates\"\n                     );\n                 }\n-                // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n-                // This is a fix for #53123 and prevents winnowing from accidentally extending the\n-                // lifetime of a variable.\n-                BuiltinCandidate { has_nested: false } => false,\n+                // (*)\n+                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n@@ -2486,6 +2489,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableFnPointer(data))\n             }\n \n+            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n+\n             TraitAliasCandidate(alias_def_id) => {\n                 let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n                 Ok(VtableTraitAlias(data))"}, {"sha": "a793031d4025be48ba09fca9a4837d7dbaa47c50", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -236,7 +236,10 @@ fn resolve_associated_item<'tcx>(\n                 None\n             }\n         }\n-        traits::VtableAutoImpl(..) | traits::VtableParam(..) | traits::VtableTraitAlias(..) => None,\n+        traits::VtableAutoImpl(..)\n+        | traits::VtableParam(..)\n+        | traits::VtableTraitAlias(..)\n+        | traits::VtableDiscriminantKind(..) => None,\n     })\n }\n "}, {"sha": "bded2c695c9db50f8df0275e2d1f383d92296df1", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -283,14 +283,20 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n             \"unlikely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n \n-            \"discriminant_value\" => (\n-                1,\n-                vec![tcx.mk_imm_ref(\n-                    tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0))),\n-                    param(0),\n-                )],\n-                tcx.types.u64,\n-            ),\n+            \"discriminant_value\" => {\n+                let assoc_items =\n+                    tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n+                let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n+\n+                (\n+                    1,\n+                    vec![tcx.mk_imm_ref(\n+                        tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0))),\n+                        param(0),\n+                    )],\n+                    tcx.mk_projection(discriminant_def_id, tcx.mk_substs([param(0).into()].iter())),\n+                )\n+            }\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);"}, {"sha": "a45a44a6801e8b04fd8fc4f783b8e77ce83db700", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -48,7 +48,20 @@ fn enforce_trait_manually_implementable(\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n \n-    // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n+    // Disallow *all* explicit impls of `DiscriminantKind`, `Sized` and `Unsize` for now.\n+    if did == li.discriminant_kind_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0322,\n+            \"explicit impls for the `DiscriminantKind` trait are not permitted\"\n+        )\n+        .span_label(span, \"impl of 'DiscriminantKind' not allowed\")\n+        .emit();\n+        return;\n+    }\n+\n     if did == li.sized_trait() {\n         let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!("}, {"sha": "6a566ab3a3d88af022334229748a8b18ca414ea3", "filename": "src/test/ui/enum-discriminant/actually_not_an_enum-discriminant.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Factually_not_an_enum-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Factually_not_an_enum-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Factually_not_an_enum-discriminant.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,49 @@\n+// run-pass\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics::discriminant_value;\n+\n+struct Zst;\n+\n+struct Struct {\n+    _a: u32,\n+}\n+\n+union Union {\n+    _a: u32,\n+}\n+\n+fn check(v: u8) {\n+    assert_eq!(v, 0);\n+}\n+\n+pub fn generic<T>()\n+where\n+    for<'a> T: Fn(&'a isize),\n+{\n+    let v: Vec<T> =  Vec::new();\n+    let _: u8 = discriminant_value(&v);\n+}\n+\n+fn main() {\n+    // check that we use `u8` as the discriminant value\n+    // for everything that is not an enum.\n+    check(discriminant_value(&true));\n+    check(discriminant_value(&'a'));\n+    check(discriminant_value(&7));\n+    check(discriminant_value(&7.0));\n+    check(discriminant_value(&Zst));\n+    check(discriminant_value(&Struct { _a: 7 }));\n+    check(discriminant_value(&Union { _a: 7 }));\n+    check(discriminant_value(&[7, 77]));\n+    check(discriminant_value(&(7 as *const ())));\n+    check(discriminant_value(&(7 as *mut ())));\n+    check(discriminant_value(&&7));\n+    check(discriminant_value(&&mut 7));\n+    check(discriminant_value(&check));\n+    let fn_ptr: fn(u8) = check;\n+    check(discriminant_value(&fn_ptr));\n+    let hrtb: for<'a> fn(&'a str) -> &'a str = |x| x;\n+    check(discriminant_value(&hrtb));\n+    check(discriminant_value(&(7, 77, 777)));\n+}"}, {"sha": "4cede8c2a2ded800a8dcd5702e69f253aeaf6748", "filename": "src/test/ui/enum-discriminant/discriminant_size.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_size.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,53 @@\n+// run-pass\n+#![feature(core_intrinsics, repr128)]\n+\n+use std::intrinsics::discriminant_value;\n+\n+enum E1 {\n+    A,\n+    B,\n+}\n+\n+#[repr(i8)]\n+enum E2 {\n+    A = 7,\n+    B = -2,\n+}\n+\n+#[repr(C)]\n+enum E3 {\n+    A = 42,\n+    B = 100,\n+}\n+\n+#[repr(i128)]\n+enum E4 {\n+    A = 0x1223_3445_5667_7889,\n+    B = -0x1223_3445_5667_7889,\n+}\n+\n+fn main() {\n+    let mut target: [isize; 3] = [0, 0, 0];\n+    target[1] = discriminant_value(&E1::A);\n+    assert_eq!(target, [0, 0, 0]);\n+    target[1] = discriminant_value(&E1::B);\n+    assert_eq!(target, [0, 1, 0]);\n+\n+    let mut target: [i8; 3] = [0, 0, 0];\n+    target[1] = discriminant_value(&E2::A);\n+    assert_eq!(target, [0, 7, 0]);\n+    target[1] = discriminant_value(&E2::B);\n+    assert_eq!(target, [0, -2, 0]);\n+\n+    let mut target: [isize; 3] = [0, 0, 0];\n+    target[1] = discriminant_value(&E3::A);\n+    assert_eq!(target, [0, 42, 0]);\n+    target[1] = discriminant_value(&E3::B);\n+    assert_eq!(target, [0, 100, 0]);\n+\n+    let mut target: [i128; 3] = [0, 0, 0];\n+    target[1] = discriminant_value(&E4::A);\n+    assert_eq!(target, [0, 0x1223_3445_5667_7889, 0]);\n+    target[1] = discriminant_value(&E4::B);\n+    assert_eq!(target, [0, -0x1223_3445_5667_7889, 0]);\n+}"}, {"sha": "eb60aaf4b2d04156abc899b205a47ce2c8c18959", "filename": "src/test/ui/enum-discriminant/discriminant_value.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fdiscriminant_value.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -51,31 +51,31 @@ enum Mixed {\n }\n \n pub fn main() {\n-    assert_eq!(discriminant_value(&CLike1::A), 0);\n+    assert_eq!(discriminant_value(&CLike1::A), 0isize);\n     assert_eq!(discriminant_value(&CLike1::B), 1);\n     assert_eq!(discriminant_value(&CLike1::C), 2);\n     assert_eq!(discriminant_value(&CLike1::D), 3);\n \n-    assert_eq!(discriminant_value(&CLike2::A), 5);\n+    assert_eq!(discriminant_value(&CLike2::A), 5isize);\n     assert_eq!(discriminant_value(&CLike2::B), 2);\n     assert_eq!(discriminant_value(&CLike2::C), 19);\n     assert_eq!(discriminant_value(&CLike2::D), 20);\n \n-    assert_eq!(discriminant_value(&CLike3::A), 5);\n+    assert_eq!(discriminant_value(&CLike3::A), 5i8);\n     assert_eq!(discriminant_value(&CLike3::B), 6);\n-    assert_eq!(discriminant_value(&CLike3::C), -1_i8 as u64);\n+    assert_eq!(discriminant_value(&CLike3::C), -1);\n     assert_eq!(discriminant_value(&CLike3::D), 0);\n \n-    assert_eq!(discriminant_value(&ADT::First(0,0)), 0);\n+    assert_eq!(discriminant_value(&ADT::First(0,0)), 0isize);\n     assert_eq!(discriminant_value(&ADT::Second(5)), 1);\n \n-    assert_eq!(discriminant_value(&NullablePointer::Nothing), 1);\n+    assert_eq!(discriminant_value(&NullablePointer::Nothing), 1isize);\n     assert_eq!(discriminant_value(&NullablePointer::Something(&CONST)), 0);\n \n-    assert_eq!(discriminant_value(&10), 0);\n-    assert_eq!(discriminant_value(&\"test\"), 0);\n+    assert_eq!(discriminant_value(&10), 0u8);\n+    assert_eq!(discriminant_value(&\"test\"), 0u8);\n \n-    assert_eq!(3, discriminant_value(&Mixed::Unit));\n-    assert_eq!(2, discriminant_value(&Mixed::Tuple(5)));\n-    assert_eq!(1, discriminant_value(&Mixed::Struct{a: 7, b: 11}));\n+    assert_eq!(discriminant_value(&Mixed::Unit), 3isize);\n+    assert_eq!(discriminant_value(&Mixed::Tuple(5)), 2);\n+    assert_eq!(discriminant_value(&Mixed::Struct{a: 7, b: 11}), 1);\n }"}, {"sha": "4760ca5482a0791086a167834ca914c1b23305bf", "filename": "src/test/ui/enum-discriminant/forbidden-discriminant-kind-impl.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,14 @@\n+#![feature(discriminant_kind)]\n+\n+use std::marker::DiscriminantKind;\n+\n+enum Uninhabited {}\n+\n+struct NewType;\n+\n+impl DiscriminantKind for NewType {\n+    //~^ ERROR explicit impls for the `DiscriminantKind` trait are not permitted\n+    type Discriminant = Uninhabited;\n+}\n+\n+fn main() {}"}, {"sha": "54360c4f47b3e453bef19dd8480f1b11fed4e670", "filename": "src/test/ui/enum-discriminant/forbidden-discriminant-kind-impl.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fforbidden-discriminant-kind-impl.stderr?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,9 @@\n+error[E0322]: explicit impls for the `DiscriminantKind` trait are not permitted\n+  --> $DIR/forbidden-discriminant-kind-impl.rs:9:1\n+   |\n+LL | impl DiscriminantKind for NewType {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl of 'DiscriminantKind' not allowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0322`."}, {"sha": "5a528379b0414c5f4fee8bb166477c147d48b18c", "filename": "src/test/ui/enum-discriminant/issue-70453-polymorphic-ctfe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70453-polymorphic-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70453-polymorphic-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70453-polymorphic-ctfe.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -13,5 +13,5 @@ enum MyWeirdOption<T> {\n \n fn main() {\n     assert_eq!(discriminant_value(&MyWeirdOption::<()>::None), 0);\n-    assert_eq!(discriminant_value(&MyWeirdOption::Some(())), core::mem::size_of::<usize>() as u64);\n+    assert_eq!(discriminant_value(&MyWeirdOption::Some(())), core::mem::size_of::<usize>());\n }"}, {"sha": "e9c6104e3875aefbc9b328972b09738035fd7d49", "filename": "src/test/ui/enum-discriminant/issue-70509-partial_eq.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Fissue-70509-partial_eq.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+#![feature(repr128, arbitrary_enum_discriminant)]\n+\n+#[derive(PartialEq, Debug)]\n+#[repr(i128)]\n+enum Test {\n+    A(Box<u64>) = 0,\n+    B(usize) = u64::max_value() as i128 + 1,\n+}\n+\n+fn main() {\n+    assert_ne!(Test::A(Box::new(2)), Test::B(0));\n+    // This previously caused a segfault.\n+    //\n+    // See https://github.com/rust-lang/rust/issues/70509#issuecomment-620654186\n+    // for a detailed explanation.\n+}"}, {"sha": "420b6007c6d85e85707a4260e9509900dd730a81", "filename": "src/test/ui/enum-discriminant/repr128.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-discriminant%2Frepr128.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+#![feature(repr128, core_intrinsics, discriminant_kind)]\n+\n+use std::intrinsics::discriminant_value;\n+use std::marker::DiscriminantKind;\n+\n+#[repr(i128)]\n+enum Signed {\n+    Zero = 0,\n+    Staircase = 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f,\n+    U64Limit = u64::max_value() as i128 + 1,\n+    SmallNegative = -1,\n+    BigNegative = i128::min_value(),\n+    Next,\n+}\n+\n+#[repr(u128)]\n+enum Unsigned {\n+    Zero = 0,\n+    Staircase = 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f,\n+    U64Limit = u64::max_value() as u128 + 1,\n+    Next,\n+}\n+\n+fn discr<T, U>(v: T, value: U)\n+where\n+    <T as DiscriminantKind>::Discriminant: PartialEq<U>,\n+{\n+    assert!(discriminant_value(&v) == value);\n+}\n+\n+fn main() {\n+    discr(Signed::Zero, 0);\n+    discr(Signed::Staircase, 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f);\n+    discr(Signed::U64Limit, u64::max_value() as i128 + 1);\n+    discr(Signed::SmallNegative, -1);\n+    discr(Signed::BigNegative, i128::min_value());\n+    discr(Signed::Next, i128::min_value() + 1);\n+\n+    discr(Unsigned::Zero, 0);\n+    discr(Unsigned::Staircase, 0x01_02_03_04_05_06_07_08_09_0a_0b_0c_0d_0e_0f);\n+    discr(Unsigned::U64Limit, u64::max_value() as u128 + 1);\n+    discr(Unsigned::Next, u64::max_value() as u128 + 2);\n+}"}, {"sha": "3d0930da422432793e19ee60134b905bf1f858ae", "filename": "src/test/ui/generator/discriminant.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fgenerator%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963bf528292d8f97104515e32908e30c2467b6a8/src%2Ftest%2Fui%2Fgenerator%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdiscriminant.rs?ref=963bf528292d8f97104515e32908e30c2467b6a8", "patch": "@@ -3,10 +3,10 @@\n \n // run-pass\n \n-#![feature(generators, generator_trait, core_intrinsics)]\n+#![feature(generators, generator_trait, core_intrinsics, discriminant_kind)]\n \n use std::intrinsics::discriminant_value;\n-use std::marker::Unpin;\n+use std::marker::{Unpin, DiscriminantKind};\n use std::mem::size_of_val;\n use std::{cmp, ops::*};\n \n@@ -65,7 +65,10 @@ macro_rules! yield250 {\n     };\n }\n \n-fn cycle(gen: impl Generator<()> + Unpin, expected_max_discr: u64) {\n+fn cycle(\n+    gen: impl Generator<()> + Unpin + DiscriminantKind<Discriminant = i32>,\n+    expected_max_discr: i32\n+) {\n     let mut gen = Box::pin(gen);\n     let mut max_discr = 0;\n     loop {"}]}