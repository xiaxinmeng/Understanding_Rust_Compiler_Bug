{"sha": "0700bd12d0279db22da40748d86c42b92804888a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MDBiZDEyZDAyNzlkYjIyZGE0MDc0OGQ4NmM0MmI5MjgwNDg4OGE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2018-02-18T19:18:56Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2018-02-24T13:56:36Z"}, "message": "Clarify \"It is an error to...\" wording for zero-duration behaviors.\n\nDocumentation fix side of https://github.com/rust-lang/rust/issues/48311.", "tree": {"sha": "a381213bbe81c5488e480e937da7d8496faa3db8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a381213bbe81c5488e480e937da7d8496faa3db8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0700bd12d0279db22da40748d86c42b92804888a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0700bd12d0279db22da40748d86c42b92804888a", "html_url": "https://github.com/rust-lang/rust/commit/0700bd12d0279db22da40748d86c42b92804888a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0700bd12d0279db22da40748d86c42b92804888a/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6070d3e47e5e9f15575a3bd33583358b52bc6eda", "url": "https://api.github.com/repos/rust-lang/rust/commits/6070d3e47e5e9f15575a3bd33583358b52bc6eda", "html_url": "https://github.com/rust-lang/rust/commit/6070d3e47e5e9f15575a3bd33583358b52bc6eda"}], "stats": {"total": 148, "additions": 134, "deletions": 14}, "files": [{"sha": "53f9eaafb0645d692fdfb35ff7fdd4e8c4acfbdb", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=0700bd12d0279db22da40748d86c42b92804888a", "patch": "@@ -259,8 +259,8 @@ impl TcpStream {\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -269,9 +269,11 @@ impl TcpStream {\n     /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n     /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n+    /// [`Duration`]: ../../std/time/struct.Duration.html\n     ///\n     /// # Examples\n     ///\n@@ -282,6 +284,20 @@ impl TcpStream {\n     ///                        .expect(\"Couldn't connect to the server...\");\n     /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n+    /// let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n@@ -290,8 +306,8 @@ impl TcpStream {\n     /// Sets the write timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -300,6 +316,7 @@ impl TcpStream {\n     /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -314,6 +331,20 @@ impl TcpStream {\n     ///                        .expect(\"Couldn't connect to the server...\");\n     /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n+    /// let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)"}, {"sha": "0a50cee67560c0a52fcfe44ebae185092e2a3aef", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=0700bd12d0279db22da40748d86c42b92804888a", "patch": "@@ -228,8 +228,8 @@ impl UdpSocket {\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -238,6 +238,7 @@ impl UdpSocket {\n     /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -251,6 +252,20 @@ impl UdpSocket {\n     /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n     /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_read_timeout(dur)\n@@ -259,8 +274,8 @@ impl UdpSocket {\n     /// Sets the write timeout to the timeout specified.\n     ///\n     /// If the value specified is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// # Platform-specific behavior\n     ///\n@@ -269,6 +284,7 @@ impl UdpSocket {\n     /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../std/time/struct.Duration.html\n     /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n@@ -282,6 +298,20 @@ impl UdpSocket {\n     /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n     /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.0.set_write_timeout(dur)"}, {"sha": "3430512ebe8bd5ded6a0b5ff61b06840f67bc532", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0700bd12d0279db22da40748d86c42b92804888a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=0700bd12d0279db22da40748d86c42b92804888a", "patch": "@@ -387,10 +387,11 @@ impl UnixStream {\n     /// Sets the read timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n     /// method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n@@ -403,6 +404,20 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n@@ -411,10 +426,11 @@ impl UnixStream {\n     /// Sets the write timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n@@ -427,6 +443,20 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n@@ -1250,10 +1280,11 @@ impl UnixDatagram {\n     /// Sets the read timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n-    /// method.\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n+    /// is passed to this method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n     /// [`recv`]: #method.recv\n     /// [`recv_from`]: #method.recv_from\n     /// [`Duration`]: ../../../../std/time/struct.Duration.html\n@@ -1267,6 +1298,20 @@ impl UnixDatagram {\n     /// let sock = UnixDatagram::unbound().unwrap();\n     /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n@@ -1275,7 +1320,7 @@ impl UnixDatagram {\n     /// Sets the write timeout for the socket.\n     ///\n     /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n     /// method.\n     ///\n     /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n@@ -1293,6 +1338,20 @@ impl UnixDatagram {\n     /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n     ///     .expect(\"set_write_timeout function failed\");\n     /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)"}]}