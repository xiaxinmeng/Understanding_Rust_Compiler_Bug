{"sha": "e7c5146c5d801c020f13c81b8b550f465c33d03a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YzUxNDZjNWQ4MDFjMDIwZjEzYzgxYjhiNTUwZjQ2NWMzM2QwM2E=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-19T22:50:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-19T23:18:16Z"}, "message": "Remove `TokenStream::JointTree`.\n\nThis is done by adding a new `IsJoint` field to `TokenStream::Tree`,\nwhich simplifies a lot of `match` statements. And likewise for\n`CursorKind`.\n\nThe commit also adds a new method `TokenTree:stream()` which can replace\na choice between `.into()` and `.joint()`.", "tree": {"sha": "b0898b1ea0a02fc40221390b123f94ab4cfe1fd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0898b1ea0a02fc40221390b123f94ab4cfe1fd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c5146c5d801c020f13c81b8b550f465c33d03a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c5146c5d801c020f13c81b8b550f465c33d03a", "html_url": "https://github.com/rust-lang/rust/commit/e7c5146c5d801c020f13c81b8b550f465c33d03a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c5146c5d801c020f13c81b8b550f465c33d03a/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fb01d62916afa0c489670b665a39d1fe903a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fb01d62916afa0c489670b665a39d1fe903a4a", "html_url": "https://github.com/rust-lang/rust/commit/c6fb01d62916afa0c489670b665a39d1fe903a4a"}], "stats": {"total": 106, "additions": 46, "deletions": 60}, "files": [{"sha": "72abcb03410ec49a101ac956f4381804daba3ab4", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=e7c5146c5d801c020f13c81b8b550f465c33d03a", "patch": "@@ -11,7 +11,7 @@\n use print::pprust::token_to_string;\n use parse::lexer::StringReader;\n use parse::{token, PResult};\n-use tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree};\n \n impl<'a> StringReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n@@ -178,8 +178,7 @@ impl<'a> StringReader<'a> {\n                 let raw = self.span_src_raw;\n                 self.real_token();\n                 let is_joint = raw.hi() == self.span_src_raw.lo() && token::is_op(&self.token);\n-\n-                Ok(if is_joint { tt.joint() } else { tt.into() })\n+                Ok(TokenStream::Tree(tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }"}, {"sha": "620035413a5537a861133580e9366c60d2563efc", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=e7c5146c5d801c020f13c81b8b550f465c33d03a", "patch": "@@ -123,7 +123,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::JointTree(self)\n+        TokenStream::Tree(self, Joint)\n     }\n \n     /// Returns the opening delimiter as a token tree.\n@@ -156,15 +156,22 @@ impl TokenTree {\n #[derive(Clone, Debug)]\n pub enum TokenStream {\n     Empty,\n-    Tree(TokenTree),\n-    JointTree(TokenTree),\n+    Tree(TokenTree, IsJoint),\n     Stream(Lrc<Vec<TokenStream>>),\n }\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum IsJoint {\n+    Joint,\n+    NonJoint\n+}\n+\n+use self::IsJoint::*;\n+\n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n     /// separating the two arguments with a comma for diagnostic suggestions.\n@@ -176,16 +183,16 @@ impl TokenStream {\n             while let Some((pos, ts)) = iter.next() {\n                 if let Some((_, next)) = iter.peek() {\n                     let sp = match (&ts, &next) {\n-                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma)), _) |\n-                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma))) => {\n-                            continue;\n-                        }\n-                        (TokenStream::Tree(TokenTree::Token(sp, _)), _) => *sp,\n-                        (TokenStream::Tree(TokenTree::Delimited(sp, ..)), _) => sp.entire(),\n+                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint), _) |\n+                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint))\n+                          => continue,\n+                        (TokenStream::Tree(TokenTree::Token(sp, _), NonJoint), _) => *sp,\n+                        (TokenStream::Tree(TokenTree::Delimited(sp, ..), NonJoint), _) =>\n+                            sp.entire(),\n                         _ => continue,\n                     };\n                     let sp = sp.shrink_to_hi();\n-                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma));\n+                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma), NonJoint);\n                     suggestion = Some((pos, comma, sp));\n                 }\n             }\n@@ -204,7 +211,7 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tt: TokenTree) -> TokenStream {\n-        TokenStream::Tree(tt)\n+        TokenStream::Tree(tt, NonJoint)\n     }\n }\n \n@@ -232,7 +239,7 @@ impl Extend<TokenStream> for TokenStream {\n                 vec.reserve(iter.size_hint().0);\n                 vec\n             }\n-            TokenStream::Tree(_) | TokenStream::JointTree(_) => {\n+            TokenStream::Tree(..) => {\n                 let mut vec = Vec::new();\n                 vec.reserve(1 + iter.size_hint().0);\n                 vec.push(this);\n@@ -367,8 +374,7 @@ impl TokenStream {\n     /// Returns true if the token tree is a joint operation w.r.t. `proc_macro::TokenNode`.\n     pub fn as_tree(self) -> (TokenTree, bool /* joint? */) {\n         match self {\n-            TokenStream::Tree(tree) => (tree, false),\n-            TokenStream::JointTree(tree) => (tree, true),\n+            TokenStream::Tree(tree, is_joint) => (tree, is_joint == Joint),\n             _ => unreachable!(),\n         }\n     }\n@@ -379,8 +385,7 @@ impl TokenStream {\n         let mut i = 0;\n         while let Some(stream) = trees.next_as_stream() {\n             result.push(match stream {\n-                TokenStream::Tree(tree) => f(i, tree).into(),\n-                TokenStream::JointTree(tree) => f(i, tree).joint(),\n+                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(i, tree), is_joint),\n                 _ => unreachable!()\n             });\n             i += 1;\n@@ -393,27 +398,25 @@ impl TokenStream {\n         let mut result = Vec::new();\n         while let Some(stream) = trees.next_as_stream() {\n             result.push(match stream {\n-                TokenStream::Tree(tree) => f(tree).into(),\n-                TokenStream::JointTree(tree) => f(tree).joint(),\n+                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n                 _ => unreachable!()\n             });\n         }\n         TokenStream::new(result)\n     }\n \n-    fn first_tree_and_joint(&self) -> Option<(TokenTree, bool)> {\n+    fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n         match self {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree) => Some((tree.clone(), false)),\n-            TokenStream::JointTree(ref tree) => Some((tree.clone(), true)),\n+            TokenStream::Tree(ref tree, is_joint) => Some((tree.clone(), *is_joint)),\n             TokenStream::Stream(ref stream) => stream.first().unwrap().first_tree_and_joint(),\n         }\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n         match self {\n-            TokenStream::Empty | TokenStream::Tree(..) => None,\n-            TokenStream::JointTree(ref tree) => Some(tree.clone()),\n+            TokenStream::Empty | TokenStream::Tree(_, NonJoint) => None,\n+            TokenStream::Tree(ref tree, Joint) => Some(tree.clone()),\n             TokenStream::Stream(ref stream) => stream.last().unwrap().last_tree_if_joint(),\n         }\n     }\n@@ -437,11 +440,7 @@ impl TokenStreamBuilder {\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_span = last_span.to(span);\n                     let glued_tt = TokenTree::Token(glued_span, glued_tok);\n-                    let glued_tokenstream = if is_joint {\n-                        glued_tt.joint()\n-                    } else {\n-                        glued_tt.into()\n-                    };\n+                    let glued_tokenstream = TokenStream::Tree(glued_tt, is_joint);\n                     self.0.push(glued_tokenstream);\n                     self.push_all_but_first_tree(&stream);\n                     return\n@@ -491,8 +490,7 @@ pub struct Cursor(CursorKind);\n #[derive(Clone)]\n enum CursorKind {\n     Empty,\n-    Tree(TokenTree, bool /* consumed? */),\n-    JointTree(TokenTree, bool /* consumed? */),\n+    Tree(TokenTree, IsJoint, bool /* consumed? */),\n     Stream(StreamCursor),\n }\n \n@@ -514,9 +512,9 @@ impl StreamCursor {\n                 self.index += 1;\n                 let next = self.stream[self.index - 1].clone();\n                 match next {\n-                    TokenStream::Tree(..) | TokenStream::JointTree(..) => return Some(next),\n-                    TokenStream::Stream(stream) => self.insert(stream),\n                     TokenStream::Empty => {}\n+                    TokenStream::Tree(..) => return Some(next),\n+                    TokenStream::Stream(stream) => self.insert(stream),\n                 }\n             } else if let Some((stream, index)) = self.stack.pop() {\n                 self.stream = stream;\n@@ -538,7 +536,7 @@ impl Iterator for Cursor {\n \n     fn next(&mut self) -> Option<TokenTree> {\n         self.next_as_stream().map(|stream| match stream {\n-            TokenStream::Tree(tree) | TokenStream::JointTree(tree) => tree,\n+            TokenStream::Tree(tree, _) => tree,\n             _ => unreachable!()\n         })\n     }\n@@ -548,18 +546,15 @@ impl Cursor {\n     fn new(stream: TokenStream) -> Self {\n         Cursor(match stream {\n             TokenStream::Empty => CursorKind::Empty,\n-            TokenStream::Tree(tree) => CursorKind::Tree(tree, false),\n-            TokenStream::JointTree(tree) => CursorKind::JointTree(tree, false),\n+            TokenStream::Tree(tree, is_joint) => CursorKind::Tree(tree, is_joint, false),\n             TokenStream::Stream(stream) => CursorKind::Stream(StreamCursor::new(stream)),\n         })\n     }\n \n     pub fn next_as_stream(&mut self) -> Option<TokenStream> {\n         let (stream, consumed) = match self.0 {\n-            CursorKind::Tree(ref tree, ref mut consumed @ false) =>\n-                (tree.clone().into(), consumed),\n-            CursorKind::JointTree(ref tree, ref mut consumed @ false) =>\n-                (tree.clone().joint(), consumed),\n+            CursorKind::Tree(ref tree, ref is_joint, ref mut consumed @ false) =>\n+                (TokenStream::Tree(tree.clone(), *is_joint), consumed),\n             CursorKind::Stream(ref mut cursor) => return cursor.next_as_stream(),\n             _ => return None,\n         };\n@@ -572,7 +567,7 @@ impl Cursor {\n         match self.0 {\n             _ if stream.is_empty() => return,\n             CursorKind::Empty => *self = stream.trees(),\n-            CursorKind::Tree(_, consumed) | CursorKind::JointTree(_, consumed) => {\n+            CursorKind::Tree(_, _, consumed) => {\n                 *self = TokenStream::new(vec![self.original_stream(), stream]).trees();\n                 if consumed {\n                     self.next();\n@@ -587,8 +582,8 @@ impl Cursor {\n     pub fn original_stream(&self) -> TokenStream {\n         match self.0 {\n             CursorKind::Empty => TokenStream::empty(),\n-            CursorKind::Tree(ref tree, _) => tree.clone().into(),\n-            CursorKind::JointTree(ref tree, _) => tree.clone().joint(),\n+            CursorKind::Tree(ref tree, ref is_joint, _) =>\n+                TokenStream::Tree(tree.clone(), *is_joint),\n             CursorKind::Stream(ref cursor) => TokenStream::Stream(\n                 cursor.stack.get(0).cloned().map(|(stream, _)| stream)\n                     .unwrap_or_else(|| cursor.stream.clone())\n@@ -600,9 +595,8 @@ impl Cursor {\n         fn look_ahead(streams: &[TokenStream], mut n: usize) -> Result<TokenTree, usize> {\n             for stream in streams {\n                 n = match stream {\n-                    TokenStream::Tree(ref tree) | TokenStream::JointTree(ref tree)\n-                        if n == 0 => return Ok(tree.clone()),\n-                    TokenStream::Tree(..) | TokenStream::JointTree(..) => n - 1,\n+                    TokenStream::Tree(ref tree, _) if n == 0 => return Ok(tree.clone()),\n+                    TokenStream::Tree(..) => n - 1,\n                     TokenStream::Stream(ref stream) => match look_ahead(stream, n) {\n                         Ok(tree) => return Ok(tree),\n                         Err(n) => n,\n@@ -615,10 +609,8 @@ impl Cursor {\n \n         match self.0 {\n             CursorKind::Empty |\n-            CursorKind::Tree(_, true) |\n-            CursorKind::JointTree(_, true) => Err(n),\n-            CursorKind::Tree(ref tree, false) |\n-            CursorKind::JointTree(ref tree, false) => look_ahead(&[tree.clone().into()], n),\n+            CursorKind::Tree(_, _, true) => Err(n),\n+            CursorKind::Tree(ref tree, _, false) => look_ahead(&[tree.clone().into()], n),\n             CursorKind::Stream(ref cursor) => {\n                 look_ahead(&cursor.stream[cursor.index ..], n).or_else(|mut n| {\n                     for &(ref stream, index) in cursor.stack.iter().rev() {\n@@ -651,8 +643,7 @@ impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n         ThinTokenStream(match stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(tree) => Some(Lrc::new(vec![tree.into()])),\n-            TokenStream::JointTree(tree) => Some(Lrc::new(vec![tree.joint()])),\n+            TokenStream::Tree(..) => Some(Lrc::new(vec![stream])),\n             TokenStream::Stream(stream) => Some(stream),\n         })\n     }"}, {"sha": "fa41022b7b675fca99a57561d557831bab7f0dc9", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c5146c5d801c020f13c81b8b550f465c33d03a/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=e7c5146c5d801c020f13c81b8b550f465c33d03a", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax::ext::base::ExtCtxt;\n use syntax::parse::lexer::comments;\n use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, TokenStream};\n+use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{keywords, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n@@ -297,11 +297,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::Token(span, token);\n-        if joint {\n-            tree.joint()\n-        } else {\n-            tree.into()\n-        }\n+        TokenStream::Tree(tree, if joint { Joint } else { NonJoint })\n     }\n }\n "}]}