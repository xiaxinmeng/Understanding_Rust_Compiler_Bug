{"sha": "edf0182213a9e30982eb34f3925ddc4cf5ed3471", "node_id": "C_kwDOAAsO6NoAKGVkZjAxODIyMTNhOWUzMDk4MmViMzRmMzkyNWRkYzRjZjVlZDM0NzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-02T17:35:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-02T17:35:23Z"}, "message": "Auto merge of #103888 - Dylan-DPC:rollup-p7gubqj, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103275 (Update tinystr)\n - #103703 (Gate some parser recovery behind the check)\n - #103774 (Format `dyn Trait` better in `type_name` intrinsic)\n - #103807 (Add tracking issue for `string_extend_from_within`)\n - #103855 (rustdoc: simplify mobile item-table CSS)\n - #103862 (Use `ObligationCtxt` in `fully_normalize`)\n - #103864 (Reorder `walk_` functions in intravisit.rs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "23f9e77b96d560318694f3136c02844774a5f900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f9e77b96d560318694f3136c02844774a5f900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edf0182213a9e30982eb34f3925ddc4cf5ed3471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edf0182213a9e30982eb34f3925ddc4cf5ed3471", "html_url": "https://github.com/rust-lang/rust/commit/edf0182213a9e30982eb34f3925ddc4cf5ed3471", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edf0182213a9e30982eb34f3925ddc4cf5ed3471/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a76127283bc963b085f54a1b275a8e281e81e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a76127283bc963b085f54a1b275a8e281e81e6", "html_url": "https://github.com/rust-lang/rust/commit/c0a76127283bc963b085f54a1b275a8e281e81e6"}, {"sha": "5a288dc1121621fbf82244c3119becee25efed4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a288dc1121621fbf82244c3119becee25efed4d", "html_url": "https://github.com/rust-lang/rust/commit/5a288dc1121621fbf82244c3119becee25efed4d"}], "stats": {"total": 930, "additions": 506, "deletions": 424}, "files": [{"sha": "05993830a0fb4ab5d30336f75be3e5001e1fc770", "filename": "COPYRIGHT", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -339,3 +339,53 @@ their own copyright notices and license terms:\n     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n+\n+* Portions of internationalization code use code or data from Unicode, which\n+  carry the following license:\n+\n+      UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+    See Terms of Use <https://www.unicode.org/copyright.html>\n+    for definitions of Unicode Inc.\u2019s Data Files and Software.\n+\n+    NOTICE TO USER: Carefully read the following legal agreement.\n+    BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S\n+    DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"),\n+    YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE\n+    TERMS AND CONDITIONS OF THIS AGREEMENT.\n+    IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE\n+    THE DATA FILES OR SOFTWARE.\n+\n+    COPYRIGHT AND PERMISSION NOTICE\n+\n+    Copyright \u00a9 1991-2022 Unicode, Inc. All rights reserved.\n+    Distributed under the Terms of Use in https://www.unicode.org/copyright.html.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining\n+    a copy of the Unicode data files and any associated documentation\n+    (the \"Data Files\") or Unicode software and any associated documentation\n+    (the \"Software\") to deal in the Data Files or Software\n+    without restriction, including without limitation the rights to use,\n+    copy, modify, merge, publish, distribute, and/or sell copies of\n+    the Data Files or Software, and to permit persons to whom the Data Files\n+    or Software are furnished to do so, provided that either\n+    (a) this copyright and permission notice appear with all copies\n+    of the Data Files or Software, or\n+    (b) this copyright and permission notice appear in associated\n+    Documentation.\n+\n+    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n+    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+    NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n+    IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS\n+    NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL\n+    DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n+    DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n+    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n+    PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+    Except as contained in this notice, the name of a copyright holder\n+    shall not be used in advertising or otherwise to promote the sale,\n+    use or other dealings in these Data Files or Software without prior\n+    written authorization of the copyright holder."}, {"sha": "33b1299976f3ee8fd2a2cc8c8649707128513018", "filename": "Cargo.lock", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -1154,6 +1154,17 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"displaydoc\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"dlmalloc\"\n version = \"0.2.3\"\n@@ -1834,11 +1845,10 @@ dependencies = [\n \n [[package]]\n name = \"intl_pluralrules\"\n-version = \"7.0.1\"\n+version = \"7.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b18f988384267d7066cc2be425e6faf352900652c046b6971d2e228d3b1c5ecf\"\n+checksum = \"078ea7b7c29a2b4df841a7f6ac8775ff6074020c6776d48491ce2268e068f972\"\n dependencies = [\n- \"tinystr\",\n  \"unic-langid\",\n ]\n \n@@ -4949,9 +4959,12 @@ dependencies = [\n \n [[package]]\n name = \"tinystr\"\n-version = \"0.3.4\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n+checksum = \"f8aeafdfd935e4a7fe16a91ab711fa52d54df84f9c8f7ca5837a9d1d902ef4c2\"\n+dependencies = [\n+ \"displaydoc\",\n+]\n \n [[package]]\n name = \"tinyvec\"\n@@ -5187,28 +5200,28 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"73328fcd730a030bdb19ddf23e192187a6b01cd98be6d3140622a89129459ce5\"\n+checksum = \"398f9ad7239db44fd0f80fe068d12ff22d78354080332a5077dc6f52f14dcf2f\"\n dependencies = [\n  \"unic-langid-impl\",\n  \"unic-langid-macros\",\n ]\n \n [[package]]\n name = \"unic-langid-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a4a8eeaf0494862c1404c95ec2f4c33a2acff5076f64314b465e3ddae1b934d\"\n+checksum = \"e35bfd2f2b8796545b55d7d3fd3e89a0613f68a0d1c8bc28cb7ff96b411a35ff\"\n dependencies = [\n  \"tinystr\",\n ]\n \n [[package]]\n name = \"unic-langid-macros\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18f980d6d87e8805f2836d64b4138cc95aa7986fa63b1f51f67d5fbff64dd6e5\"\n+checksum = \"055e618bf694161ffff0466d95cef3e1a5edc59f6ba1888e97801f2b4ebdc4fe\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"tinystr\",\n@@ -5218,9 +5231,9 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid-macros-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29396ffd97e27574c3e01368b1a64267d3064969e4848e2e130ff668be9daa9f\"\n+checksum = \"1f5cdec05b907f4e2f6843f4354f4ce6a5bebe1a56df320a49134944477ce4d8\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"quote\","}, {"sha": "08a6d69b8e40c28422fc6a8710606cdca7b65d37", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -73,18 +73,10 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn print_dyn_existential(\n-        mut self,\n+        self,\n         predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut first = true;\n-        for p in predicates {\n-            if !first {\n-                write!(self, \"+\")?;\n-            }\n-            first = false;\n-            self = p.print(self)?;\n-        }\n-        Ok(self)\n+        self.pretty_print_dyn_existential(predicates)\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {"}, {"sha": "d852893ad5dc607782c8471fea9bf935f5fe84e9", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 363, "deletions": 363, "changes": 726, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -443,72 +443,6 @@ pub trait Visitor<'v>: Sized {\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n-    visitor.visit_id(mod_hir_id);\n-    for &item_id in module.item_ids {\n-        visitor.visit_nested_item(item_id);\n-    }\n-}\n-\n-pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n-    walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n-}\n-\n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n-    // Intentionally visiting the expr first - the initialization expr\n-    // dominates the local's definition.\n-    walk_list!(visitor, visit_expr, &local.init);\n-    visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n-    if let Some(els) = local.els {\n-        visitor.visit_block(els);\n-    }\n-    walk_list!(visitor, visit_ty, &local.ty);\n-}\n-\n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.name);\n-}\n-\n-pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n-    visitor.visit_ident(label.ident);\n-}\n-\n-pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n-    match generic_arg {\n-        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n-        GenericArg::Type(ty) => visitor.visit_ty(ty),\n-        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n-        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n-    }\n-}\n-\n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n-    visitor.visit_id(lifetime.hir_id);\n-    match lifetime.name {\n-        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n-            visitor.visit_ident(ident);\n-        }\n-        LifetimeName::Param(_, ParamName::Fresh)\n-        | LifetimeName::Param(_, ParamName::Error)\n-        | LifetimeName::Static\n-        | LifetimeName::Error\n-        | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Infer => {}\n-    }\n-}\n-\n-pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n-    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n-    visitor.visit_trait_ref(&trait_ref.trait_ref);\n-}\n-\n-pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n-    visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n-}\n-\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n@@ -605,142 +539,80 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n-pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n-    for (op, op_sp) in asm.operands {\n-        match op {\n-            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                visitor.visit_expr(expr)\n-            }\n-            InlineAsmOperand::Out { expr, .. } => {\n-                if let Some(expr) = expr {\n-                    visitor.visit_expr(expr);\n-                }\n-            }\n-            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                visitor.visit_expr(in_expr);\n-                if let Some(out_expr) = out_expr {\n-                    visitor.visit_expr(out_expr);\n-                }\n-            }\n-            InlineAsmOperand::Const { anon_const, .. }\n-            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n-            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n-        }\n-    }\n-}\n-\n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n-    visitor.visit_id(hir_id);\n-    visitor.visit_path(path, hir_id);\n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n+    walk_list!(visitor, visit_param, body.params);\n+    visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    enum_definition: &'v EnumDef<'v>,\n-    item_id: HirId,\n-) {\n-    visitor.visit_id(item_id);\n-    walk_list!(visitor, visit_variant, enum_definition.variants);\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.name);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n-    visitor.visit_ident(variant.ident);\n-    visitor.visit_id(variant.id);\n-    visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n+    visitor.visit_id(mod_hir_id);\n+    for &item_id in module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n-    visitor.visit_id(typ.hir_id);\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n+    visitor.visit_id(foreign_item.hir_id());\n+    visitor.visit_ident(foreign_item.ident);\n \n-    match typ.kind {\n-        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n-        }\n-        TyKind::Never => {}\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n-        }\n-        TyKind::BareFn(ref function_declaration) => {\n-            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n-        }\n-        TyKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n-        }\n-        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n-            visitor.visit_nested_item(item_id);\n-            walk_list!(visitor, visit_generic_arg, lifetimes);\n-        }\n-        TyKind::Array(ref ty, ref length) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_array_length(length)\n-        }\n-        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n-            for bound in bounds {\n-                visitor.visit_poly_trait_ref(bound);\n+    match foreign_item.kind {\n+        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_fn_decl(function_declaration);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n-            visitor.visit_lifetime(lifetime);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Type => (),\n     }\n }\n \n-pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n-    visitor.visit_id(inf.hir_id);\n-}\n-\n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n-    match *qpath {\n-        QPath::Resolved(ref maybe_qself, ref path) => {\n-            walk_list!(visitor, visit_ty, maybe_qself);\n-            visitor.visit_path(path, id)\n-        }\n-        QPath::TypeRelative(ref qself, ref segment) => {\n-            visitor.visit_ty(qself);\n-            visitor.visit_path_segment(segment);\n-        }\n-        QPath::LangItem(..) => {}\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+    visitor.visit_id(local.hir_id);\n+    visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n     }\n+    walk_list!(visitor, visit_ty, &local.ty);\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n-    for segment in path.segments {\n-        visitor.visit_path_segment(segment);\n-    }\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n+    visitor.visit_id(block.hir_id);\n+    walk_list!(visitor, visit_stmt, block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n-    visitor.visit_ident(segment.ident);\n-    visitor.visit_id(segment.hir_id);\n-    if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(args);\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n+    visitor.visit_id(statement.hir_id);\n+    match statement.kind {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_nested_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n+            visitor.visit_expr(expression)\n+        }\n     }\n }\n \n-pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n-    walk_list!(visitor, visit_generic_arg, generic_args.args);\n-    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n-}\n-\n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    type_binding: &'v TypeBinding<'v>,\n-) {\n-    visitor.visit_id(type_binding.hir_id);\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_generic_args(type_binding.gen_args);\n-    match type_binding.kind {\n-        TypeBindingKind::Equality { ref term } => match term {\n-            Term::Ty(ref ty) => visitor.visit_ty(ty),\n-            Term::Const(ref c) => visitor.visit_anon_const(c),\n-        },\n-        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n+    visitor.visit_id(arm.hir_id);\n+    visitor.visit_pat(&arm.pat);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+            Guard::IfLet(ref l) => {\n+                visitor.visit_let_expr(l);\n+            }\n+        }\n     }\n+    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -788,33 +660,181 @@ pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'\n     visitor.visit_pat(&field.pat)\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id());\n-    visitor.visit_ident(foreign_item.ident);\n-\n-    match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n-            visitor.visit_generics(generics);\n-            visitor.visit_fn_decl(function_declaration);\n-            for &param_name in param_names {\n-                visitor.visit_ident(param_name);\n-            }\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Type => (),\n+pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n+    match len {\n+        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n+        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n     }\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, _modifier) => {\n-            visitor.visit_poly_trait_ref(typ);\n+pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n+    visitor.visit_id(constant.hir_id);\n+    visitor.visit_nested_body(constant.body);\n+}\n+\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n+    visitor.visit_id(expression.hir_id);\n+    match expression.kind {\n+        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n-            visitor.visit_id(hir_id);\n-            visitor.visit_generic_args(args);\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(ref element, ref count) => {\n+            visitor.visit_expr(element);\n+            visitor.visit_array_length(count)\n         }\n-        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+            walk_list!(visitor, visit_expr_field, fields);\n+            walk_list!(visitor, visit_expr, optional_base);\n+        }\n+        ExprKind::Tup(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Call(ref callee_expression, arguments) => {\n+            visitor.visit_expr(callee_expression);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+            visitor.visit_path_segment(segment);\n+            visitor.visit_expr(receiver);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n+        }\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n+        }\n+        ExprKind::DropTemps(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n+        ExprKind::If(ref cond, ref then, ref else_opt) => {\n+            visitor.visit_expr(cond);\n+            visitor.visit_expr(then);\n+            walk_list!(visitor, visit_expr, else_opt);\n+        }\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Match(ref subexpression, arms, _) => {\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n+        }\n+        ExprKind::Closure(&Closure {\n+            binder: _,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            capture_clause: _,\n+            fn_decl_span: _,\n+            movability: _,\n+        }) => {\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+        }\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(rhs);\n+            visitor.visit_expr(lhs)\n+        }\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression);\n+        }\n+        ExprKind::Field(ref subexpression, ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident);\n+        }\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n+        }\n+        ExprKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+        }\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref destination) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+        }\n+        ExprKind::Ret(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::InlineAsm(ref asm) => {\n+            visitor.visit_inline_asm(asm, expression.hir_id);\n+        }\n+        ExprKind::Yield(ref subexpression, _) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n+    }\n+}\n+\n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n+pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_expr(&field.expr)\n+}\n+\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n+    visitor.visit_id(typ.hir_id);\n+\n+    match typ.kind {\n+        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n+        }\n+        TyKind::Never => {}\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n+        }\n+        TyKind::BareFn(ref function_declaration) => {\n+            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n+            visitor.visit_fn_decl(&function_declaration.decl);\n+        }\n+        TyKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n+        }\n+        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n+            visitor.visit_nested_item(item_id);\n+            walk_list!(visitor, visit_generic_arg, lifetimes);\n+        }\n+        TyKind::Array(ref ty, ref length) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_array_length(length)\n+        }\n+        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound);\n+            }\n+            visitor.visit_lifetime(lifetime);\n+        }\n+        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Infer | TyKind::Err => {}\n     }\n }\n \n@@ -879,25 +899,16 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n-    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(output_ty)\n-    }\n-}\n-\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n     for ty in function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, ..) => {\n-            visitor.visit_generics(generics);\n-        }\n-        FnKind::Closure | FnKind::Method(..) => {}\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n+    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n@@ -914,6 +925,20 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor.visit_nested_body(body_id)\n }\n \n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n+    match function_kind {\n+        FnKind::ItemFn(_, generics, ..) => {\n+            visitor.visit_generics(generics);\n+        }\n+        FnKind::Closure | FnKind::Method(..) => {}\n+    }\n+}\n+\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n+    visitor.visit_id(hir_id);\n+    visitor.visit_path(path, hir_id);\n+}\n+\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n@@ -1008,6 +1033,29 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_associated_item_kind(kind);\n }\n \n+pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n+    visitor.visit_id(trait_ref.hir_ref_id);\n+    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+}\n+\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n+    match *bound {\n+        GenericBound::Trait(ref typ, _modifier) => {\n+            visitor.visit_poly_trait_ref(typ);\n+        }\n+        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(args);\n+        }\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+    }\n+}\n+\n+pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n+    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     struct_definition: &'v VariantData<'v>,\n@@ -1022,173 +1070,101 @@ pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'\n     visitor.visit_ty(&field.ty);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n-    visitor.visit_id(block.hir_id);\n-    walk_list!(visitor, visit_stmt, block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n+pub fn walk_enum_def<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    enum_definition: &'v EnumDef<'v>,\n+    item_id: HirId,\n+) {\n+    visitor.visit_id(item_id);\n+    walk_list!(visitor, visit_variant, enum_definition.variants);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n-    visitor.visit_id(statement.hir_id);\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(item) => visitor.visit_nested_item(item),\n-        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n-            visitor.visit_expr(expression)\n-        }\n-    }\n+pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n }\n \n-pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n-    match len {\n-        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n-        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n-    }\n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_ident(label.ident);\n }\n \n-pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n-    visitor.visit_id(constant.hir_id);\n-    visitor.visit_nested_body(constant.body);\n+pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n+    visitor.visit_id(inf.hir_id);\n }\n \n-pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n-    // match the visit order in walk_local\n-    visitor.visit_expr(let_expr.init);\n-    visitor.visit_id(let_expr.hir_id);\n-    visitor.visit_pat(let_expr.pat);\n-    walk_list!(visitor, visit_ty, let_expr.ty);\n+pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n+    match generic_arg {\n+        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n+        GenericArg::Type(ty) => visitor.visit_ty(ty),\n+        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n+        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n+    }\n }\n \n-pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n-    visitor.visit_id(field.hir_id);\n-    visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_id(lifetime.hir_id);\n+    match lifetime.name {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n+            visitor.visit_ident(ident);\n+        }\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n+        | LifetimeName::Static\n+        | LifetimeName::Error\n+        | LifetimeName::ImplicitObjectLifetimeDefault\n+        | LifetimeName::Infer => {}\n+    }\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n-    visitor.visit_id(expression.hir_id);\n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n-            visitor.visit_expr(element);\n-            visitor.visit_array_length(count)\n-        }\n-        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-            walk_list!(visitor, visit_expr_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n-        }\n-        ExprKind::Tup(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::Call(ref callee_expression, arguments) => {\n-            visitor.visit_expr(callee_expression);\n-            walk_list!(visitor, visit_expr, arguments);\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            walk_list!(visitor, visit_ty, maybe_qself);\n+            visitor.visit_path(path, id)\n         }\n-        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n             visitor.visit_path_segment(segment);\n-            visitor.visit_expr(receiver);\n-            walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(left_expression);\n-            visitor.visit_expr(right_expression)\n-        }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n-            visitor.visit_expr(subexpression)\n-        }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ty(typ)\n-        }\n-        ExprKind::DropTemps(ref subexpression) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n-        ExprKind::If(ref cond, ref then, ref else_opt) => {\n-            visitor.visit_expr(cond);\n-            visitor.visit_expr(then);\n-            walk_list!(visitor, visit_expr, else_opt);\n-        }\n-        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Match(ref subexpression, arms, _) => {\n-            visitor.visit_expr(subexpression);\n-            walk_list!(visitor, visit_arm, arms);\n-        }\n-        ExprKind::Closure(&Closure {\n-            binder: _,\n-            bound_generic_params,\n-            fn_decl,\n-            body,\n-            capture_clause: _,\n-            fn_decl_span: _,\n-            movability: _,\n-        }) => {\n-            walk_list!(visitor, visit_generic_param, bound_generic_params);\n-            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n-        }\n-        ExprKind::Block(ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            visitor.visit_expr(rhs);\n-            visitor.visit_expr(lhs)\n-        }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression);\n-        }\n-        ExprKind::Field(ref subexpression, ident) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n-        }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(main_expression);\n-            visitor.visit_expr(index_expression)\n-        }\n-        ExprKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-        }\n-        ExprKind::Break(ref destination, ref opt_expr) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprKind::Continue(ref destination) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-        }\n-        ExprKind::Ret(ref optional_expression) => {\n-            walk_list!(visitor, visit_expr, optional_expression);\n-        }\n-        ExprKind::InlineAsm(ref asm) => {\n-            visitor.visit_inline_asm(asm, expression.hir_id);\n-        }\n-        ExprKind::Yield(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        QPath::LangItem(..) => {}\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n-    visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            Guard::If(ref e) => visitor.visit_expr(e),\n-            Guard::IfLet(ref l) => {\n-                visitor.visit_let_expr(l);\n-            }\n-        }\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+    for segment in path.segments {\n+        visitor.visit_path_segment(segment);\n+    }\n+}\n+\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n+    visitor.visit_ident(segment.ident);\n+    visitor.visit_id(segment.hir_id);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(args);\n+    }\n+}\n+\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n+    walk_list!(visitor, visit_generic_arg, generic_args.args);\n+    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n+}\n+\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n+    visitor.visit_id(type_binding.hir_id);\n+    visitor.visit_ident(type_binding.ident);\n+    visitor.visit_generic_args(type_binding.gen_args);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref term } => match term {\n+            Term::Ty(ref ty) => visitor.visit_ty(ty),\n+            Term::Const(ref c) => visitor.visit_anon_const(c),\n+        },\n+        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n     }\n-    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssocItemKind) {\n@@ -1202,3 +1178,27 @@ pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n     // the right thing to do, should content be added in the future,\n     // would be to walk it.\n }\n+\n+pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n+    for (op, op_sp) in asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                visitor.visit_expr(expr)\n+            }\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. }\n+            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n+        }\n+    }\n+}"}, {"sha": "fab85c39d253594fb8bd1dc35044dd9a4de39137", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -1137,7 +1137,7 @@ pub trait PrettyPrinter<'tcx>:\n         //\n         // To avoid causing instabilities in compiletest\n         // output, sort the auto-traits alphabetically.\n-        auto_traits.sort_by_cached_key(|did| self.tcx().def_path_str(*did));\n+        auto_traits.sort_by_cached_key(|did| with_no_trimmed_paths!(self.tcx().def_path_str(*did)));\n \n         for def_id in auto_traits {\n             if !first {"}, {"sha": "7dc4fd0044f1ff5d3487fd8d2648e932b8e0df8c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -769,6 +769,10 @@ impl<'a> Parser<'a> {\n         segment: &PathSegment,\n         end: &[&TokenKind],\n     ) -> bool {\n+        if !self.may_recover() {\n+            return false;\n+        }\n+\n         // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n@@ -863,6 +867,10 @@ impl<'a> Parser<'a> {\n     /// Check if a method call with an intended turbofish has been written without surrounding\n     /// angle brackets.\n     pub(super) fn check_turbofish_missing_angle_brackets(&mut self, segment: &mut PathSegment) {\n+        if !self.may_recover() {\n+            return;\n+        }\n+\n         if token::ModSep == self.token.kind && segment.args.is_none() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n             self.bump();\n@@ -1396,6 +1404,10 @@ impl<'a> Parser<'a> {\n         &mut self,\n         base: P<T>,\n     ) -> PResult<'a, P<T>> {\n+        if !self.may_recover() {\n+            return Ok(base);\n+        }\n+\n         // Do not add `::` to expected tokens.\n         if self.token == token::ModSep {\n             if let Some(ty) = base.to_ty() {"}, {"sha": "0eb633f64168711bef38b86a901bfb207ec04e02", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -132,7 +132,7 @@ impl<'a> Parser<'a> {\n             Ok(expr) => Ok(expr),\n             Err(mut err) => match self.token.ident() {\n                 Some((Ident { name: kw::Underscore, .. }, false))\n-                    if self.look_ahead(1, |t| t == &token::Comma) =>\n+                    if self.may_recover() && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n@@ -456,15 +456,15 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             (Some(op), _) => (op, self.token.span),\n-            (None, Some((Ident { name: sym::and, span }, false))) => {\n+            (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n                     sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n-            (None, Some((Ident { name: sym::or, span }, false))) => {\n+            (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n@@ -615,7 +615,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n                 make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n             }\n-            token::Ident(..) if this.is_mistaken_not_ident_negation() => {\n+            token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n             _ => return this.parse_dot_or_call_expr(Some(attrs)),\n@@ -718,6 +718,10 @@ impl<'a> Parser<'a> {\n         let cast_expr = match self.parse_as_cast_ty() {\n             Ok(rhs) => mk_expr(self, lhs, rhs),\n             Err(type_err) => {\n+                if !self.may_recover() {\n+                    return Err(type_err);\n+                }\n+\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n@@ -1197,6 +1201,10 @@ impl<'a> Parser<'a> {\n         seq: &mut PResult<'a, P<Expr>>,\n         snapshot: Option<(SnapshotParser<'a>, ExprKind)>,\n     ) -> Option<P<Expr>> {\n+        if !self.may_recover() {\n+            return None;\n+        }\n+\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 snapshot.bump(); // `(`\n@@ -1360,7 +1368,7 @@ impl<'a> Parser<'a> {\n             )\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n-        } else if self.is_do_catch_block() {\n+        } else if self.may_recover() && self.is_do_catch_block() {\n             self.recover_do_catch()\n         } else if self.is_try_block() {\n             self.expect_keyword(kw::Try)?;\n@@ -1532,6 +1540,7 @@ impl<'a> Parser<'a> {\n         {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n+            && self.may_recover()\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n                 || self.token.is_op())\n         {\n@@ -1999,6 +2008,10 @@ impl<'a> Parser<'a> {\n         prev_span: Span,\n         open_delim_span: Span,\n     ) -> PResult<'a, ()> {\n+        if !self.may_recover() {\n+            return Ok(());\n+        }\n+\n         if self.token.kind == token::Comma {\n             if !self.sess.source_map().is_multiline(prev_span.until(self.token.span)) {\n                 return Ok(());\n@@ -2039,7 +2052,7 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         blk_mode: BlockCheckMode,\n     ) -> PResult<'a, P<Expr>> {\n-        if self.is_array_like_block() {\n+        if self.may_recover() && self.is_array_like_block() {\n             if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo) {\n                 return Ok(arr);\n             }"}, {"sha": "2e59c005e315ae21e5bfa0510fe11545a20cfa6f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -104,6 +104,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery\n+                    && $self.may_recover()\n                     && $self.look_ahead(1, |t| t == &token::ModSep)\n                     && let token::Interpolated(nt) = &$self.token.kind\n                     && let token::NtTy(ty) = &**nt"}, {"sha": "9ee6e0a2bf3a20337df5928b9569efd69b572c7c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -390,6 +390,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n }\n \n /// Normalize a type and process all resulting obligations, returning any errors\n+#[instrument(skip_all)]\n pub fn fully_normalize<'tcx, T>(\n     infcx: &InferCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -399,28 +400,18 @@ pub fn fully_normalize<'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n-    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n-    let selcx = &mut SelectionContext::new(infcx);\n-    let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, param_env, cause, value);\n-    debug!(\n-        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n-        normalized_value, obligations\n-    );\n-\n-    let mut fulfill_cx = FulfillmentContext::new();\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-\n-    debug!(\"fully_normalize: select_all_or_error start\");\n-    let errors = fulfill_cx.select_all_or_error(infcx);\n+    let ocx = ObligationCtxt::new(infcx);\n+    debug!(?value);\n+    let normalized_value = ocx.normalize(cause, param_env, value);\n+    debug!(?normalized_value);\n+    debug!(\"select_all_or_error start\");\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         return Err(errors);\n     }\n-    debug!(\"fully_normalize: select_all_or_error complete\");\n+    debug!(\"select_all_or_error complete\");\n     let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n-    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n+    debug!(?resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "c9ba8921f6ecc939ad182bb7db3c078e187ba5e6", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -949,7 +949,7 @@ impl String {\n     /// assert_eq!(string, \"abcdecdeabecde\");\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n-    #[unstable(feature = \"string_extend_from_within\", issue = \"none\")]\n+    #[unstable(feature = \"string_extend_from_within\", issue = \"103806\")]\n     pub fn extend_from_within<R>(&mut self, src: R)\n     where\n         R: RangeBounds<usize>,"}, {"sha": "e98dac8d12ef449d6d54a8bb1a2e714d68cbea98", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -131,6 +131,24 @@ fn distinct_type_names() {\n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n \n+#[cfg(not(bootstrap))]\n+#[test]\n+fn dyn_type_name() {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    assert_eq!(\n+        \"dyn core::ops::function::Fn(i32, i32) -> i32\",\n+        std::any::type_name::<dyn Fn(i32, i32) -> i32>()\n+    );\n+    assert_eq!(\n+        \"dyn coretests::any::dyn_type_name::Foo<Bar = i32> \\\n+        + core::marker::Send + core::marker::Sync\",\n+        std::any::type_name::<dyn Foo<Bar = i32> + Send + Sync>()\n+    );\n+}\n+\n // Test the `Provider` API.\n \n struct SomeConcreteType {"}, {"sha": "360b6b9832a5505d4ae0f74cfeb17dd2a03d1ba5", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -1870,16 +1870,9 @@ in storage.js\n \t}\n \n \t/* Display an alternating layout on tablets and phones */\n-\t.item-table {\n+\t.item-table, .item-row, .item-left, .item-right {\n \t\tdisplay: block;\n \t}\n-\t.item-row {\n-\t\tdisplay: flex;\n-\t\tflex-flow: column wrap;\n-\t}\n-\t.item-left, .item-right {\n-\t\twidth: 100%;\n-\t}\n \n \t/* Display an alternating layout on tablets and phones */\n \t.search-results > a {"}, {"sha": "3713a32eb1183c4597330cfe4882d52f3e26d634", "filename": "src/test/ui/type/issue-94187-verbose-type-name.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Ftest%2Fui%2Ftype%2Fissue-94187-verbose-type-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Ftest%2Fui%2Ftype%2Fissue-94187-verbose-type-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-94187-verbose-type-name.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -12,8 +12,5 @@ fn main() {\n     struct Wrapper<const VALUE: usize>;\n     assert_eq!(type_name::<Wrapper<0>>(), \"issue_94187_verbose_type_name::main::Wrapper<0>\");\n \n-    assert_eq!(\n-        type_name::<dyn Fn(u32) -> u32>(),\n-        \"dyn core::ops::function::Fn<(u32,)>+Output = u32\"\n-    );\n+    assert_eq!(type_name::<dyn Fn(u32) -> u32>(), \"dyn core::ops::function::Fn(u32) -> u32\");\n }"}, {"sha": "35fa968f977ab54ac5f1dec51f4557231d0d665b", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf0182213a9e30982eb34f3925ddc4cf5ed3471/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=edf0182213a9e30982eb34f3925ddc4cf5ed3471", "patch": "@@ -23,6 +23,7 @@ const LICENSES: &[&str] = &[\n     \"MIT OR Apache-2.0 OR Zlib\",                // tinyvec_macros\n     \"MIT OR Zlib OR Apache-2.0\",                // miniz_oxide\n     \"(MIT OR Apache-2.0) AND Unicode-DFS-2016\", // unicode_ident\n+    \"Unicode-DFS-2016\",                         // tinystr and icu4x\n ];\n \n /// These are exceptions to Rust's permissive licensing policy, and\n@@ -109,6 +110,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"datafrog\",\n     \"difference\",\n     \"digest\",\n+    \"displaydoc\",\n     \"dlmalloc\",\n     \"either\",\n     \"ena\","}]}