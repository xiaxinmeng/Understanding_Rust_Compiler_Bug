{"sha": "35f5ef65e2c5433adb2907e1c1badd9ecfd07c06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZjVlZjY1ZTJjNTQzM2FkYjI5MDdlMWMxYmFkZDllY2ZkMDdjMDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-10T19:35:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-12T17:56:04Z"}, "message": "execute cycle check before we consider caching", "tree": {"sha": "11f80098c80aa360b8c8cc427f95ee001a68095d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11f80098c80aa360b8c8cc427f95ee001a68095d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06", "html_url": "https://github.com/rust-lang/rust/commit/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5486a860f1d9cf5862beacf3ceace9e84e170f85", "url": "https://api.github.com/repos/rust-lang/rust/commits/5486a860f1d9cf5862beacf3ceace9e84e170f85", "html_url": "https://github.com/rust-lang/rust/commit/5486a860f1d9cf5862beacf3ceace9e84e170f85"}], "stats": {"total": 145, "additions": 83, "deletions": 62}, "files": [{"sha": "8725c6bb718115528888a9a31c4f83a91cad1f9f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 83, "deletions": 62, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f5ef65e2c5433adb2907e1c1badd9ecfd07c06/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=35f5ef65e2c5433adb2907e1c1badd9ecfd07c06", "patch": "@@ -874,6 +874,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(result);\n         }\n \n+        // Check if this is a match for something already on the\n+        // stack. If so, we don't want to insert the result into the\n+        // main cache (it is cycle dependent) nor the provisional\n+        // cache (which is meant for things that have completed but\n+        // for a \"backedge\" -- this result *is* the backedge).\n+        if let Some(cycle_result) = self.check_evaluation_cycle(&stack) {\n+            return Ok(cycle_result);\n+        }\n+\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n@@ -894,6 +903,74 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         Ok(result)\n     }\n \n+    /// If there is any previous entry on the stack that precisely\n+    /// matches this obligation, then we can assume that the\n+    /// obligation is satisfied for now (still all other conditions\n+    /// must be met of course). One obvious case this comes up is\n+    /// marker traits like `Send`. Think of a linked list:\n+    ///\n+    ///    struct List<T> { data: T, next: Option<Box<List<T>>> }\n+    ///\n+    /// `Box<List<T>>` will be `Send` if `T` is `Send` and\n+    /// `Option<Box<List<T>>>` is `Send`, and in turn\n+    /// `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n+    /// `Send`.\n+    ///\n+    /// Note that we do this comparison using the `fresh_trait_ref`\n+    /// fields. Because these have all been freshened using\n+    /// `self.freshener`, we can be sure that (a) this will not\n+    /// affect the inferencer state and (b) that if we see two\n+    /// fresh regions with the same index, they refer to the same\n+    /// unbound type variable.\n+    fn check_evaluation_cycle(\n+        &mut self,\n+        stack: &TraitObligationStack<'_, 'tcx>,\n+    ) -> Option<EvaluationResult> {\n+        if let Some(cycle_depth) = stack.iter()\n+            .skip(1) // skip top-most frame\n+            .find(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n+            .map(|stack| stack.depth)\n+        {\n+            debug!(\n+                \"evaluate_stack({:?}) --> recursive at depth {}\",\n+                stack.fresh_trait_ref,\n+                cycle_depth,\n+            );\n+\n+            // If we have a stack like `A B C D E A`, where the top of\n+            // the stack is the final `A`, then this will iterate over\n+            // `A, E, D, C, B` -- i.e., all the participants apart\n+            // from the cycle head. We mark them as participating in a\n+            // cycle. This suppresses caching for those nodes. See\n+            // `in_cycle` field for more details.\n+            stack.update_reached_depth(cycle_depth);\n+\n+            // Subtle: when checking for a coinductive cycle, we do\n+            // not compare using the \"freshened trait refs\" (which\n+            // have erased regions) but rather the fully explicit\n+            // trait refs. This is important because it's only a cycle\n+            // if the regions match exactly.\n+            let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n+            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n+            if self.coinductive_match(cycle) {\n+                debug!(\n+                    \"evaluate_stack({:?}) --> recursive, coinductive\",\n+                    stack.fresh_trait_ref\n+                );\n+                Some(EvaluatedToOk)\n+            } else {\n+                debug!(\n+                    \"evaluate_stack({:?}) --> recursive, inductive\",\n+                    stack.fresh_trait_ref\n+                );\n+                Some(EvaluatedToRecur)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn evaluate_stack<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -970,66 +1047,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(EvaluatedToUnknown);\n         }\n \n-        // If there is any previous entry on the stack that precisely\n-        // matches this obligation, then we can assume that the\n-        // obligation is satisfied for now (still all other conditions\n-        // must be met of course). One obvious case this comes up is\n-        // marker traits like `Send`. Think of a linked list:\n-        //\n-        //    struct List<T> { data: T, next: Option<Box<List<T>>> }\n-        //\n-        // `Box<List<T>>` will be `Send` if `T` is `Send` and\n-        // `Option<Box<List<T>>>` is `Send`, and in turn\n-        // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n-        // `Send`.\n-        //\n-        // Note that we do this comparison using the `fresh_trait_ref`\n-        // fields. Because these have all been freshened using\n-        // `self.freshener`, we can be sure that (a) this will not\n-        // affect the inferencer state and (b) that if we see two\n-        // fresh regions with the same index, they refer to the same\n-        // unbound type variable.\n-        if let Some(cycle_depth) = stack.iter()\n-            .skip(1) // skip top-most frame\n-            .find(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n-                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n-            .map(|stack| stack.depth)\n-        {\n-            debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n-\n-            // If we have a stack like `A B C D E A`, where the top of\n-            // the stack is the final `A`, then this will iterate over\n-            // `A, E, D, C, B` -- i.e., all the participants apart\n-            // from the cycle head. We mark them as participating in a\n-            // cycle. This suppresses caching for those nodes. See\n-            // `in_cycle` field for more details.\n-            for item in stack.iter().take_while(|s| s.depth > cycle_depth) {\n-                debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n-                item.update_reached_depth(cycle_depth);\n-            }\n-\n-            // Subtle: when checking for a coinductive cycle, we do\n-            // not compare using the \"freshened trait refs\" (which\n-            // have erased regions) but rather the fully explicit\n-            // trait refs. This is important because it's only a cycle\n-            // if the regions match exactly.\n-            let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n-            let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n-            if self.coinductive_match(cycle) {\n-                debug!(\n-                    \"evaluate_stack({:?}) --> recursive, coinductive\",\n-                    stack.fresh_trait_ref\n-                );\n-                return Ok(EvaluatedToOk);\n-            } else {\n-                debug!(\n-                    \"evaluate_stack({:?}) --> recursive, inductive\",\n-                    stack.fresh_trait_ref\n-                );\n-                return Ok(EvaluatedToRecur);\n-            }\n-        }\n-\n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Ok(None) => Ok(EvaluatedToAmbig),\n@@ -3966,8 +3983,12 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n             reached_depth,\n         );\n         debug!(\"update_reached_depth(reached_depth={})\", reached_depth);\n-        let v = self.reached_depth.get();\n-        self.reached_depth.set(v.min(reached_depth));\n+        let mut p = self;\n+        while reached_depth < p.depth {\n+            debug!(\"update_reached_depth: marking {:?} as cycle participant\", p.fresh_trait_ref);\n+            p.reached_depth.set(p.reached_depth.get().min(reached_depth));\n+            p = p.previous.head.unwrap();\n+        }\n     }\n }\n "}]}