{"sha": "1906c6f714502b1a0de46b9c217dc02570c3fd3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MDZjNmY3MTQ1MDJiMWEwZGU0NmI5YzIxN2RjMDI1NzBjM2ZkM2U=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-10-18T22:48:21Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T11:05:00Z"}, "message": "Add `MaybeUninit` methods `uninit_array`, `slice_get_ref`, `slice_get_mut`", "tree": {"sha": "ec70ffc009687c8cf968282537c88afde040f8fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec70ffc009687c8cf968282537c88afde040f8fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1906c6f714502b1a0de46b9c217dc02570c3fd3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1906c6f714502b1a0de46b9c217dc02570c3fd3e", "html_url": "https://github.com/rust-lang/rust/commit/1906c6f714502b1a0de46b9c217dc02570c3fd3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1906c6f714502b1a0de46b9c217dc02570c3fd3e/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a76fe76f756895b8cda1e10398f2268656a2e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "html_url": "https://github.com/rust-lang/rust/commit/7a76fe76f756895b8cda1e10398f2268656a2e0f"}], "stats": {"total": 57, "additions": 57, "deletions": 0}, "files": [{"sha": "46b0fd3c3cbaa764849ceacf299a36459f18b249", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1906c6f714502b1a0de46b9c217dc02570c3fd3e/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1906c6f714502b1a0de46b9c217dc02570c3fd3e/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=1906c6f714502b1a0de46b9c217dc02570c3fd3e", "patch": "@@ -258,6 +258,37 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n+    /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice_assume_init)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let input = b\"Foo\";\n+    /// let f = u8::to_ascii_uppercase;\n+    ///\n+    /// let mut buffer: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n+    /// let vec;\n+    /// let output = if let Some(buffer) = buffer.get_mut(..input.len()) {\n+    ///     buffer.iter_mut().zip(input).for_each(|(a, b)| { a.write(f(b)); });\n+    ///     unsafe { MaybeUninit::slice_get_ref(buffer) }\n+    /// } else {\n+    ///     vec = input.iter().map(f).collect::<Vec<u8>>();\n+    ///     &vec\n+    /// };\n+    ///\n+    /// assert_eq!(output, b\"FOO\");\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"0\")]\n+    #[inline(always)]\n+    pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n+        unsafe {\n+            MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init()\n+        }\n+    }\n+\n     /// A promotable constant, equivalent to `uninit()`.\n     #[unstable(feature = \"internal_uninit_const\", issue = \"0\",\n         reason = \"hack to work around promotability\")]\n@@ -690,6 +721,32 @@ impl<T> MaybeUninit<T> {\n         &mut *self.value\n     }\n \n+    /// Get a slice of assume-initialized items.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` items\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n+        &*(slice as *const [Self] as *const [T])\n+    }\n+\n+    /// Get a mutable slice of assume-initialized items.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` items\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n+    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"0\")]\n+    #[inline(always)]\n+    pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n+        &mut *(slice as *mut [Self] as *mut [T])\n+    }\n+\n     /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]"}]}