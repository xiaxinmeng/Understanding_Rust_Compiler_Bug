{"sha": "2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmODg2NTU1NmJkNmNhZTEyM2IzZGI0Y2VhYTBjNzk3N2RhY2VhOGQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-11T17:29:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-03-04T08:50:09Z"}, "message": "Encode codemap and span information in crate metadata.\n\nThis allows to create proper debuginfo line information for items inlined from other crates (e.g. instantiations of generics).\nOnly the codemap's 'metadata' is stored in a crate's metadata. That is, just filename, line-beginnings, etc. but not the actual source code itself. We are thus missing the opportunity of making Rust the first \"open-source-only\" programming language out there. Pity.", "tree": {"sha": "0b04b461ef373a9657d24fcff968ca69775bf39d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b04b461ef373a9657d24fcff968ca69775bf39d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "html_url": "https://github.com/rust-lang/rust/commit/2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fed12499e7d91f9cdfba5833e34d20e8fd19b898", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed12499e7d91f9cdfba5833e34d20e8fd19b898", "html_url": "https://github.com/rust-lang/rust/commit/fed12499e7d91f9cdfba5833e34d20e8fd19b898"}], "stats": {"total": 865, "additions": 693, "deletions": 172}, "files": [{"sha": "b3c1d6cd15fee26f47e326c7642a2f32e12f9715", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -252,3 +252,6 @@ pub const tag_macro_def: uint = 0x9e;\n pub const tag_macro_def_body: uint = 0x9f;\n \n pub const tag_paren_sugar: uint = 0xa0;\n+\n+pub const tag_codemap: uint = 0xa1;\n+pub const tag_codemap_filemap: uint = 0xa2;"}, {"sha": "bc3071d8db2cbf9c1dc0c8b43fda09be57ecd38a", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -26,7 +26,7 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span, mk_sp};\n+use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -373,15 +373,17 @@ impl<'a> CrateReader<'a> {\n         // Maintain a reference to the top most crate.\n         let root = if root.is_some() { root } else { &crate_paths };\n \n-        let cnum_map = self.resolve_crate_deps(root, lib.metadata.as_slice(), span);\n+        let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let loader::Library{ dylib, rlib, metadata } = lib;\n+        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n+        let codemap_import_info = import_codemap(self.sess.codemap(), &metadata);\n \n         let cmeta = Rc::new( cstore::crate_metadata {\n             name: name.to_string(),\n             data: metadata,\n             cnum_map: cnum_map,\n             cnum: cnum,\n+            codemap_import_info: codemap_import_info,\n             span: span,\n         });\n \n@@ -586,3 +588,131 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n }\n+\n+/// Imports the codemap from an external crate into the codemap of the crate\n+/// currently being compiled (the \"local crate\").\n+///\n+/// The import algorithm works analogous to how AST items are inlined from an\n+/// external crate's metadata:\n+/// For every FileMap in the external codemap an 'inline' copy is created in the\n+/// local codemap. The correspondence relation between external and local\n+/// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n+/// function. When an item from an external crate is later inlined into this\n+/// crate, this correspondence information is used to translate the span\n+/// information of the inlined item so that it refers the correct positions in\n+/// the local codemap (see `astencode::DecodeContext::tr_span()`).\n+///\n+/// The import algorithm in the function below will reuse FileMaps already\n+/// existing in the local codemap. For example, even if the FileMap of some\n+/// source file of libstd gets imported many times, there will only ever be\n+/// one FileMap object for the corresponding file in the local codemap.\n+///\n+/// Note that imported FileMaps do not actually contain the source code of the\n+/// file they represent, just information about length, line breaks, and\n+/// multibyte characters. This information is enough to generate valid debuginfo\n+/// for items inlined from other crates.\n+fn import_codemap(local_codemap: &codemap::CodeMap,\n+                  metadata: &MetadataBlob)\n+                  -> Vec<cstore::ImportedFileMap> {\n+    let external_codemap = decoder::get_imported_filemaps(metadata.as_slice());\n+\n+    let imported_filemaps = external_codemap.into_iter().map(|filemap_to_import| {\n+        // Try to find an existing FileMap that can be reused for the filemap to\n+        // be imported. A FileMap is reusable if it is exactly the same, just\n+        // positioned at a different offset within the codemap.\n+        let reusable_filemap = {\n+            local_codemap.files\n+                         .borrow()\n+                         .iter()\n+                         .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n+                         .map(|rc| rc.clone())\n+        };\n+\n+        match reusable_filemap {\n+            Some(fm) => {\n+                cstore::ImportedFileMap {\n+                    original_start_pos: filemap_to_import.start_pos,\n+                    original_end_pos: filemap_to_import.end_pos,\n+                    translated_filemap: fm\n+                }\n+            }\n+            None => {\n+                // We can't reuse an existing FileMap, so allocate a new one\n+                // containing the information we need.\n+                let codemap::FileMap {\n+                    name,\n+                    start_pos,\n+                    end_pos,\n+                    lines,\n+                    multibyte_chars,\n+                    ..\n+                } = filemap_to_import;\n+\n+                let source_length = (end_pos - start_pos).to_usize();\n+\n+                // Translate line-start positions and multibyte character\n+                // position into frame of reference local to file.\n+                // `CodeMap::new_imported_filemap()` will then translate those\n+                // coordinates to their new global frame of reference when the\n+                // offset of the FileMap is known.\n+                let lines = lines.into_inner().map_in_place(|pos| pos - start_pos);\n+                let multibyte_chars = multibyte_chars\n+                    .into_inner()\n+                    .map_in_place(|mbc|\n+                        codemap::MultiByteChar {\n+                            pos: mbc.pos + start_pos,\n+                            bytes: mbc.bytes\n+                        });\n+\n+                let local_version = local_codemap.new_imported_filemap(name,\n+                                                                       source_length,\n+                                                                       lines,\n+                                                                       multibyte_chars);\n+                cstore::ImportedFileMap {\n+                    original_start_pos: start_pos,\n+                    original_end_pos: end_pos,\n+                    translated_filemap: local_version\n+                }\n+            }\n+        }\n+    }).collect();\n+\n+    return imported_filemaps;\n+\n+    fn are_equal_modulo_startpos(fm1: &codemap::FileMap,\n+                                 fm2: &codemap::FileMap)\n+                                 -> bool {\n+        if fm1.name != fm2.name {\n+            return false;\n+        }\n+\n+        let lines1 = fm1.lines.borrow();\n+        let lines2 = fm2.lines.borrow();\n+\n+        if lines1.len() != lines2.len() {\n+            return false;\n+        }\n+\n+        for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n+            if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n+                return false;\n+            }\n+        }\n+\n+        let multibytes1 = fm1.multibyte_chars.borrow();\n+        let multibytes2 = fm2.multibyte_chars.borrow();\n+\n+        if multibytes1.len() != multibytes2.len() {\n+            return false;\n+        }\n+\n+        for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n+            if (mb1.bytes != mb2.bytes) ||\n+               ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+}"}, {"sha": "620987330235c02dbb2c94a2ac9e0d04f3ece840", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -27,7 +27,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use flate::Bytes;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap;\n use syntax::parse::token::IdentInterner;\n \n // A map from external crate numbers (as decoded from some crate file) to\n@@ -41,12 +41,24 @@ pub enum MetadataBlob {\n     MetadataArchive(loader::ArchiveMetadata),\n }\n \n+/// Holds information about a codemap::FileMap imported from another crate.\n+/// See creader::import_codemap() for more information.\n+pub struct ImportedFileMap {\n+    /// This FileMap's byte-offset within the codemap of its original crate\n+    pub original_start_pos: codemap::BytePos,\n+    /// The end of this FileMap within the codemap of its original crate\n+    pub original_end_pos: codemap::BytePos,\n+    /// The imported FileMap's representation within the local codemap\n+    pub translated_filemap: Rc<codemap::FileMap>\n+}\n+\n pub struct crate_metadata {\n     pub name: String,\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n-    pub span: Span,\n+    pub codemap_import_info: Vec<ImportedFileMap>,\n+    pub span: codemap::Span,\n }\n \n #[derive(Copy, Debug, PartialEq, Clone)]"}, {"sha": "994cb3f0f25e20d2e67cd9e331ab246821d2b1f1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -1561,11 +1561,26 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n-\n pub fn is_default_trait<'tcx>(cdata: Cmd, id: ast::NodeId) -> bool {\n     let item_doc = lookup_item(id, cdata.data());\n     match item_family(item_doc) {\n         Family::DefaultImpl => true,\n         _ => false\n     }\n }\n+\n+pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n+    let crate_doc = rbml::Doc::new(metadata);\n+    let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n+\n+    let mut filemaps = vec![];\n+\n+    reader::tagged_docs(cm_doc, tag_codemap_filemap, |filemap_doc| {\n+        let mut decoder = reader::Decoder::new(filemap_doc);\n+        let filemap: codemap::FileMap = Decodable::decode(&mut decoder).unwrap();\n+        filemaps.push(filemap);\n+        true\n+    });\n+\n+    return filemaps;\n+}"}, {"sha": "b9e0e452c8374c34a59e0fb05d4e29a479e1361b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -1751,6 +1751,28 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     }\n }\n \n+fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_codemap);\n+    let codemap = ecx.tcx.sess.codemap();\n+\n+    for filemap in &codemap.files.borrow()[..] {\n+\n+        if filemap.lines.borrow().len() == 0 || filemap.is_imported() {\n+            // No need to export empty filemaps, as they can't contain spans\n+            // that need translation.\n+            // Also no need to re-export imported filemaps, as any downstream\n+            // crate will import them from their original source.\n+            continue;\n+        }\n+\n+        rbml_w.start_tag(tag_codemap_filemap);\n+        filemap.encode(rbml_w);\n+        rbml_w.end_tag();\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n /// Serialize the text of the exported macros\n fn encode_macro_defs(rbml_w: &mut Encoder,\n                      krate: &ast::Crate) {\n@@ -1968,6 +1990,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         lang_item_bytes: u64,\n         native_lib_bytes: u64,\n         plugin_registrar_fn_bytes: u64,\n+        codemap_bytes: u64,\n         macro_defs_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n@@ -1982,6 +2005,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         lang_item_bytes: 0,\n         native_lib_bytes: 0,\n         plugin_registrar_fn_bytes: 0,\n+        codemap_bytes: 0,\n         macro_defs_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n@@ -2047,6 +2071,11 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     encode_plugin_registrar_fn(&ecx, &mut rbml_w);\n     stats.plugin_registrar_fn_bytes = rbml_w.writer.tell().unwrap() - i;\n \n+    // Encode codemap\n+    i = rbml_w.writer.tell().unwrap();\n+    encode_codemap(&ecx, &mut rbml_w);\n+    stats.codemap_bytes = rbml_w.writer.tell().unwrap() - i;\n+\n     // Encode macro definitions\n     i = rbml_w.writer.tell().unwrap();\n     encode_macro_defs(&mut rbml_w, krate);\n@@ -2091,6 +2120,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         println!(\"       lang item bytes: {}\", stats.lang_item_bytes);\n         println!(\"          native bytes: {}\", stats.native_lib_bytes);\n         println!(\"plugin registrar bytes: {}\", stats.plugin_registrar_fn_bytes);\n+        println!(\"         codemap bytes: {}\", stats.codemap_bytes);\n         println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n         println!(\"            impl bytes: {}\", stats.impl_bytes);\n         println!(\"            misc bytes: {}\", stats.misc_bytes);"}, {"sha": "9d712c7c0fcc800d2e60e61363eb7f9f08c39ae3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -42,6 +42,7 @@ use syntax;\n use std::old_io::Seek;\n use std::num::FromPrimitive;\n use std::rc::Rc;\n+use std::cell::Cell;\n \n use rbml::reader;\n use rbml::writer::Encoder;\n@@ -58,7 +59,9 @@ struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     cdata: &'b cstore::crate_metadata,\n     from_id_range: ast_util::IdRange,\n-    to_id_range: ast_util::IdRange\n+    to_id_range: ast_util::IdRange,\n+    // Cache the last used filemap for translating spans as an optimization.\n+    last_filemap_index: Cell<usize>,\n }\n \n trait tr {\n@@ -120,6 +123,8 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n     }\n }\n \n+/// Decodes an item from its AST in the cdata's metadata and adds it to the\n+/// ast-map.\n pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n@@ -143,7 +148,8 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             cdata: cdata,\n             tcx: tcx,\n             from_id_range: from_id_range,\n-            to_id_range: to_id_range\n+            to_id_range: to_id_range,\n+            last_filemap_index: Cell::new(0)\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n@@ -234,8 +240,47 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n         ast::DefId { krate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n-    pub fn tr_span(&self, _span: Span) -> Span {\n-        codemap::DUMMY_SP // FIXME (#1972): handle span properly\n+\n+    /// Translates a `Span` from an extern crate to the corresponding `Span`\n+    /// within the local crate's codemap. `creader::import_codemap()` will\n+    /// already have allocated any additionally needed FileMaps in the local\n+    /// codemap as a side-effect of creating the crate_metadata's\n+    /// `codemap_import_info`.\n+    pub fn tr_span(&self, span: Span) -> Span {\n+        let imported_filemaps = &self.cdata.codemap_import_info[..];\n+\n+        let filemap_index = {\n+            // Optimize for the case that most spans within a translated item\n+            // originate from the same filemap.\n+            let last_filemap_index = self.last_filemap_index.get();\n+\n+            if span.lo >= imported_filemaps[last_filemap_index].original_start_pos &&\n+               span.hi <= imported_filemaps[last_filemap_index].original_end_pos {\n+                last_filemap_index\n+            } else {\n+                let mut a = 0;\n+                let mut b = imported_filemaps.len();\n+\n+                while b - a > 1 {\n+                    let m = (a + b) / 2;\n+                    if imported_filemaps[m].original_start_pos > span.lo {\n+                        b = m;\n+                    } else {\n+                        a = m;\n+                    }\n+                }\n+\n+                self.last_filemap_index.set(a);\n+                a\n+            }\n+        };\n+\n+        let lo = (span.lo - imported_filemaps[filemap_index].original_start_pos) +\n+                  imported_filemaps[filemap_index].translated_filemap.start_pos;\n+        let hi = (span.hi - imported_filemaps[filemap_index].original_start_pos) +\n+                  imported_filemaps[filemap_index].translated_filemap.start_pos;\n+\n+        codemap::mk_sp(lo, hi)\n     }\n }\n "}, {"sha": "f433e67d878919607248bfc2c200481a96b549a9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -542,7 +542,11 @@ pub fn pretty_print_input(sess: Session,\n \n     let src_name = driver::source_name(input);\n     let src = sess.codemap().get_filemap(&src_name[..])\n-                            .src.as_bytes().to_vec();\n+                            .src\n+                            .as_ref()\n+                            .unwrap()\n+                            .as_bytes()\n+                            .to_vec();\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {"}, {"sha": "162da2ac54c12ee111e380302ce5b430a60332a9", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 278, "deletions": 39, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -29,6 +29,11 @@ use std::rc::Rc;\n use libc::c_uint;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+\n+// _____________________________________________________________________________\n+// Pos, BytePos, CharPos\n+//\n+\n pub trait Pos {\n     fn from_usize(n: usize) -> Self;\n     fn to_usize(&self) -> usize;\n@@ -69,6 +74,18 @@ impl Sub for BytePos {\n     }\n }\n \n+impl Encodable for BytePos {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl Decodable for BytePos {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n+        Ok(BytePos(try!{ d.read_u32() }))\n+    }\n+}\n+\n impl Pos for CharPos {\n     fn from_usize(n: usize) -> CharPos { CharPos(n) }\n     fn to_usize(&self) -> usize { let CharPos(n) = *self; n }\n@@ -90,6 +107,10 @@ impl Sub for CharPos {\n     }\n }\n \n+// _____________________________________________________________________________\n+// Span, Spanned\n+//\n+\n /// Spans represent a region of code, used for error reporting. Positions in spans\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n@@ -126,15 +147,20 @@ impl PartialEq for Span {\n impl Eq for Span {}\n \n impl Encodable for Span {\n-    /* Note #1972 -- spans are encoded but not decoded */\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_nil()\n+        // Encode spans as a single u64 in order to cut down on tagging overhead\n+        // added by the RBML metadata encoding. The should be solved differently\n+        // altogether some time (FIXME #21482)\n+        s.emit_u64( (self.lo.0 as u64) | ((self.hi.0 as u64) << 32) )\n     }\n }\n \n impl Decodable for Span {\n-    fn decode<D: Decoder>(_d: &mut D) -> Result<Span, D::Error> {\n-        Ok(DUMMY_SP)\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n+        let lo_hi: u64 = try! { d.read_u64() };\n+        let lo = BytePos(lo_hi as u32);\n+        let hi = BytePos((lo_hi >> 32) as u32);\n+        Ok(mk_sp(lo, hi))\n     }\n }\n \n@@ -168,6 +194,10 @@ pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n+// _____________________________________________________________________________\n+// Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n+//\n+\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n@@ -192,6 +222,11 @@ pub struct LocWithOpt {\n pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n \n+\n+// _____________________________________________________________________________\n+// MacroFormat, NameAndSpan, ExpnInfo, ExpnId\n+//\n+\n /// The syntax with which a macro was invoked.\n #[derive(Clone, Copy, Hash, Debug)]\n pub enum MacroFormat {\n@@ -254,6 +289,10 @@ impl ExpnId {\n     }\n }\n \n+// _____________________________________________________________________________\n+// FileMap, MultiByteChar, FileName, FileLines\n+//\n+\n pub type FileName = String;\n \n pub struct FileLines {\n@@ -262,7 +301,7 @@ pub struct FileLines {\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n-#[derive(Copy)]\n+#[derive(Copy, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the CodeMap\n     pub pos: BytePos,\n@@ -277,13 +316,134 @@ pub struct FileMap {\n     /// e.g. `<anon>`\n     pub name: FileName,\n     /// The complete source code\n-    pub src: String,\n+    pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n     pub start_pos: BytePos,\n+    /// The end position of this source in the CodeMap\n+    pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    pub lines: RefCell<Vec<BytePos> >,\n+    pub lines: RefCell<Vec<BytePos>>,\n     /// Locations of multi-byte characters in the source code\n-    pub multibyte_chars: RefCell<Vec<MultiByteChar> >,\n+    pub multibyte_chars: RefCell<Vec<MultiByteChar>>,\n+}\n+\n+impl Encodable for FileMap {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_struct(\"FileMap\", 5, |s| {\n+            try! { s.emit_struct_field(\"name\", 0, |s| self.name.encode(s)) };\n+            try! { s.emit_struct_field(\"start_pos\", 1, |s| self.start_pos.encode(s)) };\n+            try! { s.emit_struct_field(\"end_pos\", 2, |s| self.end_pos.encode(s)) };\n+            try! { s.emit_struct_field(\"lines\", 3, |s| {\n+                    let lines = self.lines.borrow();\n+                    // store the length\n+                    try! { s.emit_u32(lines.len() as u32) };\n+\n+                    if lines.len() > 0 {\n+                        // In order to preserve some space, we exploit the fact that\n+                        // the lines list is sorted and individual lines are\n+                        // probably not that long. Because of that we can store lines\n+                        // as a difference list, using as little space as possible\n+                        // for the differences.\n+                        let max_line_length = if lines.len() == 1 {\n+                            0\n+                        } else {\n+                            lines.as_slice()\n+                                 .windows(2)\n+                                 .map(|w| w[1] - w[0])\n+                                 .map(|bp| bp.to_usize())\n+                                 .max()\n+                                 .unwrap()\n+                        };\n+\n+                        let bytes_per_diff: u8 = match max_line_length {\n+                            0 ... 0xFF => 1,\n+                            0x100 ... 0xFFFF => 2,\n+                            _ => 4\n+                        };\n+\n+                        // Encode the number of bytes used per diff.\n+                        try! { bytes_per_diff.encode(s) };\n+\n+                        // Encode the first element.\n+                        try! { lines[0].encode(s) };\n+\n+                        let diff_iter = (&lines[..]).windows(2)\n+                                                    .map(|w| (w[1] - w[0]));\n+\n+                        match bytes_per_diff {\n+                            1 => for diff in diff_iter { try! { (diff.0 as u8).encode(s) } },\n+                            2 => for diff in diff_iter { try! { (diff.0 as u16).encode(s) } },\n+                            4 => for diff in diff_iter { try! { (diff.0 as u32).encode(s) } },\n+                            _ => unreachable!()\n+                        }\n+                    }\n+\n+                    Ok(())\n+                })\n+            };\n+            s.emit_struct_field(\"multibyte_chars\", 4, |s| {\n+                (*self.multibyte_chars.borrow()).encode(s)\n+            })\n+        })\n+    }\n+}\n+\n+impl Decodable for FileMap {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n+\n+        d.read_struct(\"FileMap\", 5, |d| {\n+            let name: String = try! {\n+                d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))\n+            };\n+            let start_pos: BytePos = try! {\n+                d.read_struct_field(\"start_pos\", 1, |d| Decodable::decode(d))\n+            };\n+            let end_pos: BytePos = try! {\n+                d.read_struct_field(\"end_pos\", 2, |d| Decodable::decode(d))\n+            };\n+            let lines: Vec<BytePos> = try! {\n+                d.read_struct_field(\"lines\", 3, |d| {\n+                    let num_lines: u32 = try! { Decodable::decode(d) };\n+                    let mut lines = Vec::with_capacity(num_lines as usize);\n+\n+                    if num_lines > 0 {\n+                        // Read the number of bytes used per diff.\n+                        let bytes_per_diff: u8 = try! { Decodable::decode(d) };\n+\n+                        // Read the first element.\n+                        let mut line_start: BytePos = try! { Decodable::decode(d) };\n+                        lines.push(line_start);\n+\n+                        for _ in 1..num_lines {\n+                            let diff = match bytes_per_diff {\n+                                1 => try! { d.read_u8() } as u32,\n+                                2 => try! { d.read_u16() } as u32,\n+                                4 => try! { d.read_u32() },\n+                                _ => unreachable!()\n+                            };\n+\n+                            line_start = line_start + BytePos(diff);\n+\n+                            lines.push(line_start);\n+                        }\n+                    }\n+\n+                    Ok(lines)\n+                })\n+            };\n+            let multibyte_chars: Vec<MultiByteChar> = try! {\n+                d.read_struct_field(\"multibyte_chars\", 4, |d| Decodable::decode(d))\n+            };\n+            Ok(FileMap {\n+                name: name,\n+                start_pos: start_pos,\n+                end_pos: end_pos,\n+                src: None,\n+                lines: RefCell::new(lines),\n+                multibyte_chars: RefCell::new(multibyte_chars)\n+            })\n+        })\n+    }\n }\n \n impl FileMap {\n@@ -307,16 +467,21 @@ impl FileMap {\n     /// get a line from the list of pre-computed line-beginnings\n     ///\n     pub fn get_line(&self, line_number: usize) -> Option<String> {\n-        let lines = self.lines.borrow();\n-        lines.get(line_number).map(|&line| {\n-            let begin: BytePos = line - self.start_pos;\n-            let begin = begin.to_usize();\n-            let slice = &self.src[begin..];\n-            match slice.find('\\n') {\n-                Some(e) => &slice[..e],\n-                None => slice\n-            }.to_string()\n-        })\n+        match self.src {\n+            Some(ref src) => {\n+                let lines = self.lines.borrow();\n+                lines.get(line_number).map(|&line| {\n+                    let begin: BytePos = line - self.start_pos;\n+                    let begin = begin.to_usize();\n+                    let slice = &src[begin..];\n+                    match slice.find('\\n') {\n+                        Some(e) => &slice[..e],\n+                        None => slice\n+                    }.to_string()\n+                })\n+            }\n+            None => None\n+        }\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n@@ -332,8 +497,17 @@ impl FileMap {\n         !(self.name.starts_with(\"<\") &&\n           self.name.ends_with(\">\"))\n     }\n+\n+    pub fn is_imported(&self) -> bool {\n+        self.src.is_none()\n+    }\n }\n \n+\n+// _____________________________________________________________________________\n+// CodeMap\n+//\n+\n pub struct CodeMap {\n     pub files: RefCell<Vec<Rc<FileMap>>>,\n     expansions: RefCell<Vec<ExpnInfo>>\n@@ -351,7 +525,7 @@ impl CodeMap {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n             None => 0,\n-            Some(last) => last.start_pos.to_usize() + last.src.len(),\n+            Some(last) => last.end_pos.to_usize(),\n         };\n \n         // Remove utf-8 BOM if any.\n@@ -372,10 +546,13 @@ impl CodeMap {\n             src.push('\\n');\n         }\n \n+        let end_pos = start_pos + src.len();\n+\n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            src: src.to_string(),\n+            src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n+            end_pos: Pos::from_usize(end_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n         });\n@@ -385,6 +562,45 @@ impl CodeMap {\n         filemap\n     }\n \n+    /// Allocates a new FileMap representing a source file from an external\n+    /// crate. The source code of such an \"imported filemap\" is not available,\n+    /// but we still know enough to generate accurate debuginfo location\n+    /// information for things inlined from other crates.\n+    pub fn new_imported_filemap(&self,\n+                                filename: FileName,\n+                                source_len: usize,\n+                                file_local_lines: Vec<BytePos>,\n+                                file_local_multibyte_chars: Vec<MultiByteChar>)\n+                                -> Rc<FileMap> {\n+        let mut files = self.files.borrow_mut();\n+        let start_pos = match files.last() {\n+            None => 0,\n+            Some(last) => last.end_pos.to_usize(),\n+        };\n+\n+        let end_pos = Pos::from_usize(start_pos + source_len);\n+        let start_pos = Pos::from_usize(start_pos);\n+\n+        let lines = file_local_lines.map_in_place(|pos| pos + start_pos);\n+        let multibyte_chars = file_local_multibyte_chars.map_in_place(|mbc| MultiByteChar {\n+            pos: mbc.pos + start_pos,\n+            bytes: mbc.bytes\n+        });\n+\n+        let filemap = Rc::new(FileMap {\n+            name: filename,\n+            src: None,\n+            start_pos: start_pos,\n+            end_pos: end_pos,\n+            lines: RefCell::new(lines),\n+            multibyte_chars: RefCell::new(multibyte_chars),\n+        });\n+\n+        files.push(filemap.clone());\n+\n+        filemap\n+    }\n+\n     pub fn mk_substr_filename(&self, sp: Span) -> String {\n         let pos = self.lookup_char_pos(sp.lo);\n         (format!(\"<{}:{}:{}>\",\n@@ -442,30 +658,42 @@ impl CodeMap {\n             return Err(SpanSnippetError::IllFormedSpan(sp));\n         }\n \n-        let begin = self.lookup_byte_offset(sp.lo);\n-        let end = self.lookup_byte_offset(sp.hi);\n+        let local_begin = self.lookup_byte_offset(sp.lo);\n+        let local_end = self.lookup_byte_offset(sp.hi);\n \n-        if begin.fm.start_pos != end.fm.start_pos {\n+        if local_begin.fm.start_pos != local_end.fm.start_pos {\n             return Err(SpanSnippetError::DistinctSources(DistinctSources {\n-                begin: (begin.fm.name.clone(),\n-                        begin.fm.start_pos),\n-                end: (end.fm.name.clone(),\n-                      end.fm.start_pos)\n+                begin: (local_begin.fm.name.clone(),\n+                        local_begin.fm.start_pos),\n+                end: (local_end.fm.name.clone(),\n+                      local_end.fm.start_pos)\n             }));\n         } else {\n-            let start = begin.pos.to_usize();\n-            let limit = end.pos.to_usize();\n-            if start > limit || limit > begin.fm.src.len() {\n-                return Err(SpanSnippetError::MalformedForCodemap(\n-                    MalformedCodemapPositions {\n-                        name: begin.fm.name.clone(),\n-                        source_len: begin.fm.src.len(),\n-                        begin_pos: begin.pos,\n-                        end_pos: end.pos,\n-                    }));\n-            }\n+            match local_begin.fm.src {\n+                Some(ref src) => {\n+                    let start_index = local_begin.pos.to_usize();\n+                    let end_index = local_end.pos.to_usize();\n+                    let source_len = (local_begin.fm.end_pos -\n+                                      local_begin.fm.start_pos).to_usize();\n+\n+                    if start_index > end_index || end_index > source_len {\n+                        return Err(SpanSnippetError::MalformedForCodemap(\n+                            MalformedCodemapPositions {\n+                                name: local_begin.fm.name.clone(),\n+                                source_len: source_len,\n+                                begin_pos: local_begin.pos,\n+                                end_pos: local_end.pos,\n+                            }));\n+                    }\n \n-            return Ok((&begin.fm.src[start..limit]).to_string())\n+                    return Ok((&src[start_index..end_index]).to_string())\n+                }\n+                None => {\n+                    return Err(SpanSnippetError::SourceNotAvailable {\n+                        filename: local_begin.fm.name.clone()\n+                    });\n+                }\n+            }\n         }\n     }\n \n@@ -478,6 +706,7 @@ impl CodeMap {\n         panic!(\"asking for {} which we don't know about\", filename);\n     }\n \n+    /// For a global BytePos compute the local offset within the containing FileMap\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = (*self.files.borrow())[idx].clone();\n@@ -639,11 +868,16 @@ impl CodeMap {\n     }\n }\n \n+// _____________________________________________________________________________\n+// SpanSnippetError, DistinctSources, MalformedCodemapPositions\n+//\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n     DistinctSources(DistinctSources),\n     MalformedForCodemap(MalformedCodemapPositions),\n+    SourceNotAvailable { filename: String }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -660,6 +894,11 @@ pub struct MalformedCodemapPositions {\n     end_pos: BytePos\n }\n \n+\n+// _____________________________________________________________________________\n+// Tests\n+//\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "8d3e93d35ddd1b87ea13ec8f577d392ae1981471", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -76,6 +76,10 @@ pub struct StringReader<'a> {\n     // are revised to go directly to token-trees.\n     /// Is \\x00<name>,<ctxt>\\x00 is interpreted as encoded ast::Ident?\n     read_embedded_ident: bool,\n+\n+    // cache a direct reference to the source text, so that we don't have to\n+    // retrieve it via `self.filemap.src.as_ref().unwrap()` all the time.\n+    source_text: Rc<String>\n }\n \n impl<'a> Reader for StringReader<'a> {\n@@ -141,7 +145,14 @@ pub fn make_reader_with_embedded_idents<'b>(span_diagnostic: &'b SpanHandler,\n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n     pub fn new_raw<'b>(span_diagnostic: &'b SpanHandler,\n-                   filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n+                       filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n+        if filemap.src.is_none() {\n+            span_diagnostic.handler.bug(&format!(\"Cannot lex filemap without source: {}\",\n+                                                 filemap.name)[..]);\n+        }\n+\n+        let source_text = (*filemap.src.as_ref().unwrap()).clone();\n+\n         let mut sr = StringReader {\n             span_diagnostic: span_diagnostic,\n             pos: filemap.start_pos,\n@@ -153,6 +164,7 @@ impl<'a> StringReader<'a> {\n             peek_tok: token::Eof,\n             peek_span: codemap::DUMMY_SP,\n             read_embedded_ident: false,\n+            source_text: source_text\n         };\n         sr.bump();\n         sr\n@@ -213,7 +225,7 @@ impl<'a> StringReader<'a> {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_usize();\n         let to = self.byte_offset(to_pos).to_usize();\n-        m.push_str(&self.filemap.src[from..to]);\n+        m.push_str(&self.source_text[from..to]);\n         self.fatal_span_(from_pos, to_pos, &m[..]);\n     }\n \n@@ -270,9 +282,8 @@ impl<'a> StringReader<'a> {\n     fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T where\n         F: FnOnce(&str) -> T,\n     {\n-        f(&self.filemap.src[\n-                self.byte_offset(start).to_usize()..\n-                self.byte_offset(end).to_usize()])\n+        f(&self.source_text[self.byte_offset(start).to_usize()..\n+                            self.byte_offset(end).to_usize()])\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -321,12 +332,10 @@ impl<'a> StringReader<'a> {\n     pub fn bump(&mut self) {\n         self.last_pos = self.pos;\n         let current_byte_offset = self.byte_offset(self.pos).to_usize();\n-        if current_byte_offset < self.filemap.src.len() {\n+        if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let next = self.filemap\n-                          .src\n-                          .char_range_at(current_byte_offset);\n+            let next = self.source_text.char_range_at(current_byte_offset);\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(next.ch);\n@@ -346,8 +355,8 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n-        if offset < self.filemap.src.len() {\n-            Some(self.filemap.src.char_at(offset))\n+        if offset < self.source_text.len() {\n+            Some(self.source_text.char_at(offset))\n         } else {\n             None\n         }\n@@ -359,7 +368,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn nextnextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n-        let s = &*self.filemap.src;\n+        let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n         let str::CharRange { next, .. } = s.char_range_at(offset);\n         if next < s.len() {"}, {"sha": "66589d5e3d1cf1f8d226225c5057bbfa1a30d932", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 44, "deletions": 110, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -751,6 +751,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use std::rc::Rc;\n     use serialize::json;\n     use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n     use owned_slice::OwnedSlice;\n@@ -855,117 +856,50 @@ mod test {\n     }\n \n     #[test]\n-    fn string_to_tts_1 () {\n+    fn string_to_tts_1() {\n         let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n-        assert_eq!(json::encode(&tts).unwrap(),\n-        \"[\\\n-    {\\\n-        \\\"variant\\\":\\\"TtToken\\\",\\\n-        \\\"fields\\\":[\\\n-            null,\\\n-            {\\\n-                \\\"variant\\\":\\\"Ident\\\",\\\n-                \\\"fields\\\":[\\\n-                    \\\"fn\\\",\\\n-                    \\\"Plain\\\"\\\n-                ]\\\n-            }\\\n-        ]\\\n-    },\\\n-    {\\\n-        \\\"variant\\\":\\\"TtToken\\\",\\\n-        \\\"fields\\\":[\\\n-            null,\\\n-            {\\\n-                \\\"variant\\\":\\\"Ident\\\",\\\n-                \\\"fields\\\":[\\\n-                    \\\"a\\\",\\\n-                    \\\"Plain\\\"\\\n-                ]\\\n-            }\\\n-        ]\\\n-    },\\\n-    {\\\n-        \\\"variant\\\":\\\"TtDelimited\\\",\\\n-        \\\"fields\\\":[\\\n-            null,\\\n-            {\\\n-                \\\"delim\\\":\\\"Paren\\\",\\\n-                \\\"open_span\\\":null,\\\n-                \\\"tts\\\":[\\\n-                    {\\\n-                        \\\"variant\\\":\\\"TtToken\\\",\\\n-                        \\\"fields\\\":[\\\n-                            null,\\\n-                            {\\\n-                                \\\"variant\\\":\\\"Ident\\\",\\\n-                                \\\"fields\\\":[\\\n-                                    \\\"b\\\",\\\n-                                    \\\"Plain\\\"\\\n-                                ]\\\n-                            }\\\n-                        ]\\\n-                    },\\\n-                    {\\\n-                        \\\"variant\\\":\\\"TtToken\\\",\\\n-                        \\\"fields\\\":[\\\n-                            null,\\\n-                            \\\"Colon\\\"\\\n-                        ]\\\n-                    },\\\n-                    {\\\n-                        \\\"variant\\\":\\\"TtToken\\\",\\\n-                        \\\"fields\\\":[\\\n-                            null,\\\n-                            {\\\n-                                \\\"variant\\\":\\\"Ident\\\",\\\n-                                \\\"fields\\\":[\\\n-                                    \\\"i32\\\",\\\n-                                    \\\"Plain\\\"\\\n-                                ]\\\n-                            }\\\n-                        ]\\\n-                    }\\\n-                ],\\\n-                \\\"close_span\\\":null\\\n-            }\\\n-        ]\\\n-    },\\\n-    {\\\n-        \\\"variant\\\":\\\"TtDelimited\\\",\\\n-        \\\"fields\\\":[\\\n-            null,\\\n-            {\\\n-                \\\"delim\\\":\\\"Brace\\\",\\\n-                \\\"open_span\\\":null,\\\n-                \\\"tts\\\":[\\\n-                    {\\\n-                        \\\"variant\\\":\\\"TtToken\\\",\\\n-                        \\\"fields\\\":[\\\n-                            null,\\\n-                            {\\\n-                                \\\"variant\\\":\\\"Ident\\\",\\\n-                                \\\"fields\\\":[\\\n-                                    \\\"b\\\",\\\n-                                    \\\"Plain\\\"\\\n-                                ]\\\n-                            }\\\n-                        ]\\\n-                    },\\\n-                    {\\\n-                        \\\"variant\\\":\\\"TtToken\\\",\\\n-                        \\\"fields\\\":[\\\n-                            null,\\\n-                            \\\"Semi\\\"\\\n-                        ]\\\n-                    }\\\n-                ],\\\n-                \\\"close_span\\\":null\\\n-            }\\\n-        ]\\\n-    }\\\n-]\"\n-        );\n+\n+        let expected = vec![\n+            ast::TtToken(sp(0, 2),\n+                         token::Ident(str_to_ident(\"fn\"),\n+                         token::IdentStyle::Plain)),\n+            ast::TtToken(sp(3, 4),\n+                         token::Ident(str_to_ident(\"a\"),\n+                         token::IdentStyle::Plain)),\n+            ast::TtDelimited(\n+                sp(5, 14),\n+                Rc::new(ast::Delimited {\n+                    delim: token::DelimToken::Paren,\n+                    open_span: sp(5, 6),\n+                    tts: vec![\n+                        ast::TtToken(sp(6, 7),\n+                                     token::Ident(str_to_ident(\"b\"),\n+                                     token::IdentStyle::Plain)),\n+                        ast::TtToken(sp(8, 9),\n+                                     token::Colon),\n+                        ast::TtToken(sp(10, 13),\n+                                     token::Ident(str_to_ident(\"i32\"),\n+                                     token::IdentStyle::Plain)),\n+                    ],\n+                    close_span: sp(13, 14),\n+                })),\n+            ast::TtDelimited(\n+                sp(15, 21),\n+                Rc::new(ast::Delimited {\n+                    delim: token::DelimToken::Brace,\n+                    open_span: sp(15, 16),\n+                    tts: vec![\n+                        ast::TtToken(sp(17, 18),\n+                                     token::Ident(str_to_ident(\"b\"),\n+                                     token::IdentStyle::Plain)),\n+                        ast::TtToken(sp(18, 19),\n+                                     token::Semi)\n+                    ],\n+                    close_span: sp(20, 21),\n+                }))\n+        ];\n+\n+        assert_eq!(tts, expected);\n     }\n \n     #[test] fn ret_expr() {"}, {"sha": "22c206836ee0f38bc861122b70cc2c9ef8b82050", "filename": "src/test/auxiliary/cross_crate_spans.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![omit_gdb_pretty_printer_section]\n+\n+// no-prefer-dynamic\n+// compile-flags:-g\n+\n+pub fn generic_function<T: Clone>(val: T) -> (T, T) {\n+    let result = (val.clone(), val.clone());\n+    let a_variable: u32 = 123456789;\n+    let another_variable: f64 = 123456789.5;\n+    zzz();\n+    result\n+}\n+\n+#[inline(never)]\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "3aef9438a338e4cc28c2aa2807ed3f3d63d13a1e", "filename": "src/test/debuginfo/cross-crate-spans.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8865556bd6cae123b3db4ceaa0c7977dacea8d/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-spans.rs?ref=2f8865556bd6cae123b3db4ceaa0c7977dacea8d", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![omit_gdb_pretty_printer_section]\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// aux-build:cross_crate_spans.rs\n+extern crate cross_crate_spans;\n+\n+// compile-flags:-g\n+\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:break cross_crate_spans.rs:21\n+// gdb-command:run\n+\n+// gdb-command:print result\n+// gdb-check:$1 = {17, 17}\n+// gdb-command:print a_variable\n+// gdb-check:$2 = 123456789\n+// gdb-command:print another_variable\n+// gdb-check:$3 = 123456789.5\n+// gdb-command:continue\n+\n+// gdb-command:print result\n+// gdb-check:$4 = {1212, 1212}\n+// gdb-command:print a_variable\n+// gdb-check:$5 = 123456789\n+// gdb-command:print another_variable\n+// gdb-check:$6 = 123456789.5\n+// gdb-command:continue\n+\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:b cross_crate_spans.rs:21\n+// lldb-command:run\n+\n+// lldb-command:print result\n+// lldb-check:[...]$0 = (17, 17)\n+// lldb-command:print a_variable\n+// lldb-check:[...]$1 = 123456789\n+// lldb-command:print another_variable\n+// lldb-check:[...]$2 = 123456789.5\n+// lldb-command:continue\n+\n+// lldb-command:print result\n+// lldb-check:[...]$3 = (1212, 1212)\n+// lldb-command:print a_variable\n+// lldb-check:[...]$4 = 123456789\n+// lldb-command:print another_variable\n+// lldb-check:[...]$5 = 123456789.5\n+// lldb-command:continue\n+\n+\n+// This test makes sure that we can break in functions inlined from other crates.\n+\n+fn main() {\n+\n+    let _ = cross_crate_spans::generic_function(17u32);\n+    let _ = cross_crate_spans::generic_function(1212i16);\n+\n+}"}]}