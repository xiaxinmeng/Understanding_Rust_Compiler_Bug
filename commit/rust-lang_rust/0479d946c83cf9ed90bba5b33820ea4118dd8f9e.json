{"sha": "0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzlkOTQ2YzgzY2Y5ZWQ5MGJiYTViMzM4MjBlYTQxMThkZDhmOWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-15T01:41:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-19T11:13:15Z"}, "message": "Add externfn macro and correctly label fixed_stack_segments", "tree": {"sha": "0e31638f9dee1f085c9463e2a6b3f8b9209c6fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e31638f9dee1f085c9463e2a6b3f8b9209c6fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "html_url": "https://github.com/rust-lang/rust/commit/0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303f650ecfb5580f3d89aa662fbd164b849c8eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/303f650ecfb5580f3d89aa662fbd164b849c8eff", "html_url": "https://github.com/rust-lang/rust/commit/303f650ecfb5580f3d89aa662fbd164b849c8eff"}], "stats": {"total": 976, "additions": 890, "deletions": 86}, "files": [{"sha": "278273b16719321c17b5be3445f140ec12e1a5c5", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,6 +19,7 @@ extern {\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n \n+#[fixed_stack_segment]\n fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n     println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n@@ -35,6 +36,11 @@ interfaces that aren't thread-safe, and almost any function that takes a pointer\n valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n+Finally, the `#[fixed_stack_segment]` annotation that appears on\n+`main()` instructs the Rust compiler that when `main()` executes, it\n+should request a \"very large\" stack segment.  More details on\n+stack management can be found in the following sections.\n+\n When declaring the argument types to a foreign function, the Rust compiler will not check if the\n declaration is correct, so specifying it correctly is part of keeping the binding correct at\n runtime.\n@@ -75,6 +81,8 @@ length is number of elements currently contained, and the capacity is the total\n the allocated memory. The length is less than or equal to the capacity.\n \n ~~~~ {.xfail-test}\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n         snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n@@ -86,6 +94,36 @@ The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, b\n guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n signature.\n \n+The `validate_compressed_buffer` wrapper is also annotated with two\n+attributes `#[fixed_stack_segment]` and `#[inline(never)]`. The\n+purpose of these attributes is to guarantee that there will be\n+sufficient stack for the C function to execute. This is necessary\n+because Rust, unlike C, does not assume that the stack is allocated in\n+one continuous chunk. Instead, we rely on a *segmented stack* scheme,\n+in which the stack grows and shrinks as necessary.  C code, however,\n+expects one large stack, and so callers of C functions must request a\n+large stack segment to ensure that the C routine will not run off the\n+end of the stack.\n+\n+The compiler includes a lint mode that will report an error if you\n+call a C function without a `#[fixed_stack_segment]` attribute. More\n+details on the lint mode are given in a later section.\n+\n+You may be wondering why we include a `#[inline(never)]` directive.\n+This directive informs the compiler never to inline this function.\n+While not strictly necessary, it is usually a good idea to use an\n+`#[inline(never)]` directive in concert with `#[fixed_stack_segment]`.\n+The reason is that if a fn annotated with `fixed_stack_segment` is\n+inlined, then its caller also inherits the `fixed_stack_segment`\n+annotation. This means that rather than requesting a large stack\n+segment only for the duration of the call into C, the large stack\n+segment would be used for the entire duration of the caller. This is\n+not necessarily *bad* -- it can for example be more efficient,\n+particularly if `validate_compressed_buffer()` is called multiple\n+times in a row -- but it does work against the purpose of the\n+segmented stack scheme, which is to keep stacks small and thus\n+conserve address space.\n+\n The `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be\n allocated to hold the output too.\n \n@@ -96,6 +134,8 @@ the true length after compression for setting the length.\n \n ~~~~ {.xfail-test}\n pub fn compress(src: &[u8]) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    \n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -116,6 +156,8 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n \n ~~~~ {.xfail-test}\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    \n     unsafe {\n         let srclen = src.len() as size_t;\n         let psrc = vec::raw::to_ptr(src);\n@@ -139,6 +181,99 @@ pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n \n+# Automatic wrappers\n+\n+Sometimes writing Rust wrappers can be quite tedious.  For example, if\n+function does not take any pointer arguments, often there is no need\n+for translating types. In such cases, it is usually still a good idea\n+to have a Rust wrapper so as to manage the segmented stacks, but you\n+can take advantage of the (standard) `externfn!` macro to remove some\n+of the tedium.\n+\n+In the initial section, we showed an extern block that added a call\n+to a specific snappy API:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+#[link_args = \"-lsnappy\"]\n+extern {\n+    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+To avoid the need to create a wrapper fn for `snappy_max_compressed_length()`,\n+and also to avoid the need to think about `#[fixed_stack_segment]`, we\n+could simply use the `externfn!` macro instead, as shown here:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+externfn!(#[link_args = \"-lsnappy\"]\n+          fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n+\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+As you can see from the example, `externfn!` replaces the extern block\n+entirely. After macro expansion, it will create something like this:\n+\n+~~~~ {.xfail-test}\n+use std::libc::size_t;\n+\n+// Automatically generated by\n+//   externfn!(#[link_args = \"-lsnappy\"]\n+//             fn snappy_max_compressed_length(source_length: size_t) -> size_t)\n+unsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return snappy_max_compressed_length(source_length);\n+    \n+    #[link_args = \"-lsnappy\"]\n+    extern {\n+        fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n+    }\n+}\n+\n+fn main() {\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n+}\n+~~~~\n+\n+# Segmented stacks and the linter\n+\n+By default, whenever you invoke a non-Rust fn, the `cstack` lint will\n+check that one of the following conditions holds:\n+\n+1. The call occurs inside of a fn that has been annotated with\n+   `#[fixed_stack_segment]`;\n+2. The call occurs inside of an `extern fn`;\n+3. The call occurs within a stack closure created by some other\n+   safe fn.\n+   \n+All of these conditions ensure that you are running on a large stack\n+segmented. However, they are sometimes too strict. If your application\n+will be making many calls into C, it is often beneficial to promote\n+the `#[fixed_stack_segment]` attribute higher up the call chain.  For\n+example, the Rust compiler actually labels main itself as requiring a\n+`#[fixed_stack_segment]`. In such cases, the linter is just an\n+annoyance, because all C calls that occur from within the Rust\n+compiler are made on a large stack. Another situation where this\n+frequently occurs is on a 64-bit architecture, where large stacks are\n+the default. In cases, you can disable the linter by including a\n+`#[allow(cstack)]` directive somewhere, which permits violations of\n+the \"cstack\" rules given above (you can also use `#[warn(cstack)]` to\n+convert the errors into warnings, if you prefer).\n+\n # Destructors\n \n Foreign libraries often hand off ownership of resources to the calling code,\n@@ -161,6 +296,9 @@ pub struct Unique<T> {\n \n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+        \n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n@@ -184,6 +322,9 @@ impl<T: Send> Unique<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&self) {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+        \n         unsafe {\n             let x = intrinsics::init(); // dummy value to swap in\n             // moving the object out is needed to call the destructor"}, {"sha": "9e1504aad2a5625ebda57cb59fd429ff3153f92f", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -155,12 +155,20 @@ mod tests {\n     use std::libc;\n \n     fn malloc(n: size_t) -> CVec<u8> {\n+        #[fixed_stack_segment];\n+        #[inline(never)];\n+\n         unsafe {\n             let mem = libc::malloc(n);\n \n             assert!(mem as int != 0);\n \n-            c_vec_with_dtor(mem as *mut u8, n as uint, || free(mem))\n+            return c_vec_with_dtor(mem as *mut u8, n as uint, || f(mem));\n+        }\n+\n+        fn f(mem: *c_void) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { libc::free(mem) }\n         }\n     }\n "}, {"sha": "530885001292c51d77d5b0df33ba1cb21c42d452", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -47,6 +47,8 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n@@ -73,6 +75,8 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;"}, {"sha": "db87cf94641bb59290ffb1b3fb598db6426caee7", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,15 +19,25 @@ use std::str;\n pub mod rustrt {\n     use std::libc::{c_char, c_int};\n \n-    extern {\n-        pub fn linenoise(prompt: *c_char) -> *c_char;\n-        pub fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-        pub fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-        pub fn linenoiseHistorySave(file: *c_char) -> c_int;\n-        pub fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-        pub fn linenoiseSetCompletionCallback(callback: *u8);\n-        pub fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+    #[cfg(stage0)]\n+    mod macro_hack {\n+    #[macro_escape];\n+    macro_rules! externfn(\n+        (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            extern {\n+                fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+            }\n+        )\n+    )\n     }\n+\n+    externfn!(fn linenoise(prompt: *c_char) -> *c_char)\n+    externfn!(fn linenoiseHistoryAdd(line: *c_char) -> c_int)\n+    externfn!(fn linenoiseHistorySetMaxLen(len: c_int) -> c_int)\n+    externfn!(fn linenoiseHistorySave(file: *c_char) -> c_int)\n+    externfn!(fn linenoiseHistoryLoad(file: *c_char) -> c_int)\n+    externfn!(fn linenoiseSetCompletionCallback(callback: *u8))\n+    externfn!(fn linenoiseAddCompletion(completions: *(), line: *c_char))\n }\n \n /// Add a line to history\n@@ -84,7 +94,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n                         rustrt::linenoiseAddCompletion(completions, buf);\n                     }\n                 }\n-}\n+            }\n         }\n     }\n "}, {"sha": "75d00f9ea5999cdf2793c32d89f386bee73fa27f", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -188,6 +188,8 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n }\n \n fn usage(binary: &str, helpstr: &str) -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let message = fmt!(\"Usage: %s [OPTIONS] [FILTER]\", binary);\n     println(groups::usage(message, optgroups()));\n     println(\"\");"}, {"sha": "ab35bf2386ca4d89ed9345c7004ff4a2f5ce182f", "filename": "src/libextra/time.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -64,6 +64,8 @@ impl Ord for Timespec {\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n pub fn get_time() -> Timespec {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let mut sec = 0i64;\n         let mut nsec = 0i32;\n@@ -78,6 +80,8 @@ pub fn get_time() -> Timespec {\n  * in nanoseconds since an unspecified epoch.\n  */\n pub fn precise_time_ns() -> u64 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let mut ns = 0u64;\n         rustrt::precise_time_ns(&mut ns);\n@@ -95,6 +99,8 @@ pub fn precise_time_s() -> float {\n }\n \n pub fn tzset() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         rustrt::rust_tzset();\n     }\n@@ -135,6 +141,8 @@ pub fn empty_tm() -> Tm {\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -150,6 +158,8 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n@@ -176,6 +186,8 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n     pub fn to_timespec(&self) -> Timespec {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let sec = match self.tm_gmtoff {\n                 0_i32 => rustrt::rust_timegm(self),"}, {"sha": "d010f7d52d8a82dc05dd2c996f5b7b7c53f82922", "filename": "src/librust/rust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -229,6 +229,8 @@ fn usage() {\n }\n \n pub fn main() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let os_args = os::args();\n \n     if (os_args.len() > 1 && (os_args[1] == ~\"-v\" || os_args[1] == ~\"--version\")) {"}, {"sha": "cdafb7400e1a294e4e6fd9c3061f56bc64ed2fe7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -645,9 +645,13 @@ pub fn build_session_options(binary: @str,\n         }\n         debugging_opts |= this_bit;\n     }\n+\n     if debugging_opts & session::debug_llvm != 0 {\n-        unsafe {\n-            llvm::LLVMSetDebug(1);\n+        set_llvm_debug();\n+\n+        fn set_llvm_debug() {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { llvm::LLVMSetDebug(1); }\n         }\n     }\n "}, {"sha": "9175c13c8aeebbd2940d143aef154ac4980ff163", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// LLVM wrappers are intended to be called from trans,\n+// which already runs in a #[fixed_stack_segment]\n+#[allow(cstack)];\n+\n use std::c_str::ToCStr;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ushort};"}, {"sha": "8837a9461edf4792bf0988af8c28ccc9fa38123e", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,6 +19,7 @@ large stacks.\n use middle::lint;\n use middle::ty;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::span;\n use visit = syntax::oldvisit;\n@@ -47,19 +48,33 @@ pub fn stack_check_crate(tcx: ty::ctxt,\n \n fn stack_check_item(item: @ast::item,\n                     (in_cx, v): (Context, visit::vt<Context>)) {\n-    let safe_stack = match item.node {\n+    match item.node {\n+        ast::item_fn(_, ast::extern_fn, _, _, _) => {\n+            // an extern fn is already being called from C code...\n+            let new_cx = Context {safe_stack: true, ..in_cx};\n+            visit::visit_item(item, (new_cx, v));\n+        }\n         ast::item_fn(*) => {\n-            attr::contains_name(item.attrs, \"fixed_stack_segment\")\n+            let safe_stack = fixed_stack_segment(item.attrs);\n+            let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+            visit::visit_item(item, (new_cx, v));\n+        }\n+        ast::item_impl(_, _, _, ref methods) => {\n+            // visit_method() would make this nicer\n+            for &method in methods.iter() {\n+                let safe_stack = fixed_stack_segment(method.attrs);\n+                let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n+                visit::visit_method_helper(method, (new_cx, v));\n+            }\n         }\n         _ => {\n-            false\n+            visit::visit_item(item, (in_cx, v));\n         }\n-    };\n-    let new_cx = Context {\n-        tcx: in_cx.tcx,\n-        safe_stack: safe_stack\n-    };\n-    visit::visit_item(item, (new_cx, v));\n+    }\n+\n+    fn fixed_stack_segment(attrs: &[ast::Attribute]) -> bool {\n+        attr::contains_name(attrs, \"fixed_stack_segment\")\n+    }\n }\n \n fn stack_check_fn<'a>(fk: &visit::fn_kind,\n@@ -69,13 +84,23 @@ fn stack_check_fn<'a>(fk: &visit::fn_kind,\n                       id: ast::NodeId,\n                       (in_cx, v): (Context, visit::vt<Context>)) {\n     let safe_stack = match *fk {\n-        visit::fk_item_fn(*) => in_cx.safe_stack, // see stack_check_item above\n-        visit::fk_anon(*) | visit::fk_fn_block | visit::fk_method(*) => false,\n-    };\n-    let new_cx = Context {\n-        tcx: in_cx.tcx,\n-        safe_stack: safe_stack\n+        visit::fk_method(*) | visit::fk_item_fn(*) => {\n+            in_cx.safe_stack // see stack_check_item above\n+        }\n+        visit::fk_anon(*) | visit::fk_fn_block => {\n+            match ty::get(ty::node_id_to_type(in_cx.tcx, id)).sty {\n+                ty::ty_bare_fn(*) |\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) |\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+                    false\n+                }\n+                _ => {\n+                    in_cx.safe_stack\n+                }\n+            }\n+        }\n     };\n+    let new_cx = Context {safe_stack: safe_stack, ..in_cx};\n     debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n     visit::visit_fn(fk, decl, body, sp, id, (new_cx, v));\n }\n@@ -92,12 +117,7 @@ fn stack_check_expr<'a>(expr: @ast::expr,\n                 match ty::get(callee_ty).sty {\n                     ty::ty_bare_fn(ref fty) => {\n                         if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n-                            cx.tcx.sess.add_lint(\n-                                lint::cstack,\n-                                callee.id,\n-                                callee.span,\n-                                fmt!(\"invoking non-Rust fn in fn without \\\n-                                      #[fixed_stack_segment]\"));\n+                            call_to_extern_fn(cx, callee);\n                         }\n                     }\n                     _ => {}\n@@ -108,3 +128,32 @@ fn stack_check_expr<'a>(expr: @ast::expr,\n     }\n     visit::visit_expr(expr, (cx, v));\n }\n+\n+fn call_to_extern_fn(cx: Context, callee: @ast::expr) {\n+    // Permit direct calls to extern fns that are annotated with\n+    // #[rust_stack]. This is naturally a horrible pain to achieve.\n+    match callee.node {\n+        ast::expr_path(*) => {\n+            match cx.tcx.def_map.find(&callee.id) {\n+                Some(&ast::def_fn(id, _)) if id.crate == ast::LOCAL_CRATE => {\n+                    match cx.tcx.items.find(&id.node) {\n+                        Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n+                            if attr::contains_name(item.attrs, \"rust_stack\") {\n+                                return;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    cx.tcx.sess.add_lint(lint::cstack,\n+                         callee.id,\n+                         callee.span,\n+                         fmt!(\"invoking non-Rust fn in fn without \\\n+                              #[fixed_stack_segment]\"));\n+}"}, {"sha": "88fc02ca83c66f34abced2d083e0c9bb0b901a8b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -2509,14 +2509,14 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                     register_method(ccx, id, pth, m)\n                 }\n \n-                ast_map::node_foreign_item(ni, _, _, pth) => {\n+                ast_map::node_foreign_item(ni, abis, _, pth) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n                     exprt = true;\n \n                     match ni.node {\n                         ast::foreign_item_fn(*) => {\n                             let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n-                            foreign::register_foreign_item_fn(ccx, abis, &path, ni);\n+                            foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);"}, {"sha": "f9cbab58211e6475296a4db16e6207c6fa6a49b6", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -17,6 +17,11 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n+// Rustc tasks always run on a fixed_stack_segment, so code in this\n+// module can call C functions (in particular, LLVM functions) with\n+// impunity.\n+#[allow(cstack)];\n+\n extern mod extra;\n extern mod syntax;\n "}, {"sha": "d4bee13aae7f97eb3a180a150eebfd59c5f52239", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -498,6 +498,8 @@ pub fn run_line(repl: &mut Repl, input: @io::Reader, out: @io::Writer, line: ~st\n }\n \n pub fn main() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let args = os::args();\n     let input = io::stdin();\n     let out = io::stdout();"}, {"sha": "41c1c7e31aeff82eb7503c354e1ee3af0dc647c1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -382,6 +382,8 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n \n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     /* FIXME (#1768): Investigate how to do this on win32\n        Node wraps symlinks by having a .bat,\n        but that won't work with minGW. */\n@@ -394,6 +396,8 @@ pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     use std::c_str::ToCStr;\n     use std::libc;\n "}, {"sha": "98710c158e0d7f8d82e0719952ab13716a075e51", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -96,6 +96,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+        #[fixed_stack_segment]; #[inline(never)];\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             let len = libc::strlen(self.buf) as uint;\n@@ -114,6 +115,7 @@ impl CString {\n \n impl Drop for CString {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         if self.owns_buffer_ {\n             unsafe {\n                 libc::free(self.buf as *libc::c_void)\n@@ -172,6 +174,7 @@ impl<'self> ToCStr for &'self str {\n \n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n+        #[fixed_stack_segment]; #[inline(never)];\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n         do cs.with_mut_ref |buf| {\n             for i in range(0, self.len()) {\n@@ -190,6 +193,7 @@ impl<'self> ToCStr for &'self [u8] {\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n@@ -260,12 +264,16 @@ mod tests {\n \n     #[test]\n     fn test_unwrap() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let c_str = \"hello\".to_c_str();\n         unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n     }\n \n     #[test]\n     fn test_with_ref() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n         assert!(!c_str.is_null());"}, {"sha": "8f5a3728e95b4845f2ce6de11e0fbf39ced394b8", "filename": "src/libstd/io.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -928,6 +928,8 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n \n impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do bytes.as_mut_buf |buf_p, buf_len| {\n                 assert!(buf_len >= len);\n@@ -950,23 +952,31 @@ impl Reader for *libc::FILE {\n         }\n     }\n     fn read_byte(&self) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fgetc(*self) as int\n         }\n     }\n     fn eof(&self) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             return libc::feof(*self) != 0 as c_int;\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             return libc::ftell(*self) as uint;\n         }\n@@ -1005,6 +1015,8 @@ impl FILERes {\n \n impl Drop for FILERes {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fclose(self.f);\n         }\n@@ -1035,12 +1047,16 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n * ~~~\n */\n pub fn stdin() -> @Reader {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         @rustrt::rust_get_stdin() as @Reader\n     }\n }\n \n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let f = do path.with_c_str |pathbuf| {\n         do \"rb\".with_c_str |modebuf| {\n             unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n@@ -1162,6 +1178,8 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n \n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do v.as_imm_buf |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n@@ -1177,23 +1195,31 @@ impl Writer for *libc::FILE {\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             assert!(libc::fseek(*self,\n                                      offset as c_long,\n                                      convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::ftell(*self) as uint\n         }\n     }\n     fn flush(&self) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::fflush(*self) as int\n         }\n     }\n     fn get_type(&self) -> WriterType {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let fd = libc::fileno(*self);\n             if libc::isatty(fd) == 0 { File   }\n@@ -1212,6 +1238,8 @@ pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n \n impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let mut count = 0u;\n             do v.as_imm_buf |vbuf, len| {\n@@ -1238,6 +1266,8 @@ impl Writer for fd_t {\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             if libc::isatty(*self) == 0 { File } else { Screen }\n         }\n@@ -1256,6 +1286,8 @@ impl FdRes {\n \n impl Drop for FdRes {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             libc::close(self.fd);\n         }\n@@ -1273,6 +1305,8 @@ pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n \n pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n@@ -1573,6 +1607,8 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n \n // FIXME: fileflags // #2004\n pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let f = do path.with_c_str |pathbuf| {\n             do \"w\".with_c_str |modebuf| {\n@@ -1803,23 +1839,30 @@ pub mod fsync {\n                          blk: &fn(v: Res<*libc::FILE>)) {\n         blk(Res::new(Arg {\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: |file, l| {\n-                unsafe {\n-                    os::fsync_fd(libc::fileno(*file), l) as int\n-                }\n-            }\n+            fsync_fn: |file, l| fsync_fd(fileno(*file), l)\n         }));\n+\n+        fn fileno(stream: *libc::FILE) -> libc::c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe { libc::fileno(stream) }\n+        }\n     }\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n                        blk: &fn(v: Res<fd_t>)) {\n         blk(Res::new(Arg {\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: |fd, l| os::fsync_fd(*fd, l) as int\n+            fsync_fn: |fd, l| fsync_fd(*fd, l)\n         }));\n     }\n \n+    fn fsync_fd(fd: libc::c_int, level: Level) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        os::fsync_fd(fd, level) as int\n+    }\n+\n     // Type of objects that may want to fsync\n     pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n "}, {"sha": "d3e0c88e5dff7e78bad2ed3543178ca89767ebd3", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -2762,9 +2762,11 @@ pub mod funcs {\n             // doesn't link it correctly on i686, so we're going\n             // through a C function that mysteriously does work.\n             pub unsafe fn opendir(dirname: *c_char) -> *DIR {\n+                #[fixed_stack_segment]; #[inline(never)];\n                 rust_opendir(dirname)\n             }\n             pub unsafe fn readdir(dirp: *DIR) -> *dirent_t {\n+                #[fixed_stack_segment]; #[inline(never)];\n                 rust_readdir(dirp)\n             }\n "}, {"sha": "17175de9b929dafd3025c0ca6b57102b5046f7fc", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline]\n+                #[inline] #[fixed_stack_segment] #[inline(never)]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "91361a61c215137042e4607715c08415094f96b8", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -43,7 +43,7 @@ macro_rules! delegate(\n             use unstable::intrinsics;\n \n             $(\n-                #[inline]\n+                #[inline] #[fixed_stack_segment] #[inline(never)]\n                 pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n                     unsafe {\n                         $bound_name($( $arg ),*)"}, {"sha": "4e5a0e9b9138a632beda8eeaa6e4689cd585cfe2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -51,6 +51,7 @@ pub use os::consts::*;\n \n /// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::close(fd)\n     }\n@@ -70,6 +71,7 @@ pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n \n pub fn getcwd() -> Path {\n+    #[fixed_stack_segment]; #[inline(never)];\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n@@ -109,6 +111,8 @@ pub mod win32 {\n \n     pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n             let mut res = None;\n@@ -145,6 +149,18 @@ pub mod win32 {\n     }\n }\n \n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident ()) => (\n+        extern {\n+            fn $name();\n+        }\n+    )\n+)\n+}\n+\n /*\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n@@ -161,12 +177,8 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n         };\n     }\n \n-    extern {\n-        #[fast_ffi]\n-        fn rust_take_env_lock();\n-        #[fast_ffi]\n-        fn rust_drop_env_lock();\n-    }\n+    externfn!(fn rust_take_env_lock());\n+    externfn!(fn rust_drop_env_lock());\n }\n \n /// Returns a vector of (variable, value) pairs for all the environment\n@@ -175,6 +187,8 @@ pub fn env() -> ~[(~str,~str)] {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsA,\n                 FreeEnvironmentStringsA\n@@ -198,6 +212,8 @@ pub fn env() -> ~[(~str,~str)] {\n         }\n         #[cfg(unix)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             extern {\n                 fn rust_env_pairs() -> **libc::c_char;\n             }\n@@ -237,6 +253,7 @@ pub fn env() -> ~[(~str,~str)] {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             let s = do n.with_c_str |buf| {\n@@ -255,6 +272,8 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         do with_env_lock {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n@@ -272,6 +291,7 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do with_env_lock {\n             do n.with_c_str |nbuf| {\n@@ -288,6 +308,8 @@ pub fn setenv(n: &str, v: &str) {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         do with_env_lock {\n             use os::win32::as_utf16_p;\n@@ -304,6 +326,7 @@ pub fn setenv(n: &str, v: &str) {\n pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 do n.with_c_str |nbuf| {\n@@ -314,6 +337,7 @@ pub fn unsetenv(n: &str) {\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do with_env_lock {\n                 use os::win32::as_utf16_p;\n@@ -328,6 +352,7 @@ pub fn unsetenv(n: &str) {\n }\n \n pub fn fdopen(fd: c_int) -> *FILE {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do \"r\".with_c_str |modebuf| {\n         unsafe {\n             libc::fdopen(fd, modebuf)\n@@ -340,6 +365,7 @@ pub fn fdopen(fd: c_int) -> *FILE {\n \n #[cfg(windows)]\n pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         use libc::funcs::extra::msvcrt::*;\n         return commit(fd);\n@@ -349,6 +375,7 @@ pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         use libc::funcs::posix01::unistd::*;\n         match level {\n@@ -361,6 +388,8 @@ pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n \n #[cfg(target_os = \"macos\")]\n pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         use libc::consts::os::extra::*;\n         use libc::funcs::posix88::fcntl::*;\n@@ -381,6 +410,8 @@ pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n \n #[cfg(target_os = \"freebsd\")]\n pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         use libc::funcs::posix01::unistd::*;\n         return fsync(fd);\n@@ -394,6 +425,7 @@ pub struct Pipe {\n \n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         let mut fds = Pipe {input: 0 as c_int,\n                             out: 0 as c_int };\n@@ -406,6 +438,7 @@ pub fn pipe() -> Pipe {\n \n #[cfg(windows)]\n pub fn pipe() -> Pipe {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         // Windows pipes work subtly differently than unix pipes, and their\n         // inheritance has to be handled in a different way that I do not\n@@ -424,6 +457,7 @@ pub fn pipe() -> Pipe {\n }\n \n fn dup2(src: c_int, dst: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::dup2(src, dst)\n     }\n@@ -440,6 +474,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n@@ -458,6 +493,7 @@ pub fn self_exe_path() -> Option<Path> {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::posix01::unistd::readlink;\n \n@@ -479,6 +515,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do fill_charp_buf() |buf, sz| {\n                 let mut sz = sz as u32;\n@@ -490,6 +527,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn load_self() -> Option<~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             do fill_utf16_buf_and_decode() |buf, sz| {\n@@ -592,6 +630,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n \n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do p.with_c_str |buf| {\n             rustrt::rust_path_is_dir(buf) != 0 as c_int\n@@ -601,6 +640,7 @@ pub fn path_is_dir(p: &Path) -> bool {\n \n /// Indicates whether a path exists\n pub fn path_exists(p: &Path) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         do p.with_c_str |buf| {\n             rustrt::rust_path_exists(buf) != 0 as c_int\n@@ -633,6 +673,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(windows)]\n     fn mkdir(p: &Path, _mode: c_int) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             // FIXME: turn mode into something useful? #2623\n@@ -645,6 +686,7 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n \n     #[cfg(unix)]\n     fn mkdir(p: &Path, mode: c_int) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n@@ -689,6 +731,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n         #[cfg(target_os = \"freebsd\")]\n         #[cfg(target_os = \"macos\")]\n         unsafe fn get_list(p: &Path) -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n             use libc::{dirent_t};\n             use libc::{opendir, readdir, closedir};\n             extern {\n@@ -721,6 +764,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n         }\n         #[cfg(windows)]\n         unsafe fn get_list(p: &Path) -> ~[~str] {\n+            #[fixed_stack_segment]; #[inline(never)];\n             use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n             use libc::{wcslen, free};\n             use libc::funcs::extra::kernel32::{\n@@ -809,6 +853,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn rmdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -819,6 +864,7 @@ pub fn remove_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn rmdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::rmdir(buf) == (0 as c_int)\n@@ -834,6 +880,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -844,6 +891,7 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do p.with_c_str |buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n@@ -858,6 +906,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(from.to_str()) |fromp| {\n@@ -871,6 +920,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             let istream = do from.with_c_str |fromp| {\n                 do \"rb\".with_c_str |modebuf| {\n@@ -933,6 +983,7 @@ pub fn remove_file(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn unlink(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use os::win32::as_utf16_p;\n             return do as_utf16_p(p.to_str()) |buf| {\n@@ -943,6 +994,7 @@ pub fn remove_file(p: &Path) -> bool {\n \n     #[cfg(unix)]\n     fn unlink(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do p.with_c_str |buf| {\n                 libc::unlink(buf) == (0 as c_int)\n@@ -957,6 +1009,7 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn errno_location() -> *c_int {\n+        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __error() -> *c_int;\n@@ -969,6 +1022,7 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn errno_location() -> *c_int {\n+        #[fixed_stack_segment]; #[inline(never)];\n         #[nolink]\n         extern {\n             fn __errno_location() -> *c_int;\n@@ -986,6 +1040,7 @@ pub fn errno() -> int {\n #[cfg(windows)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n     use libc::types::os::arch::extra::DWORD;\n \n     #[link_name = \"kernel32\"]\n@@ -1008,6 +1063,8 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"freebsd\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n                       -> c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             #[nolink]\n             extern {\n                 fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n@@ -1023,6 +1080,7 @@ pub fn last_os_error() -> ~str {\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n+            #[fixed_stack_segment]; #[inline(never)];\n             #[nolink]\n             extern {\n                 fn __xpg_strerror_r(errnum: c_int,\n@@ -1050,6 +1108,8 @@ pub fn last_os_error() -> ~str {\n \n     #[cfg(windows)]\n     fn strerror() -> ~str {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -1129,6 +1189,8 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n  */\n #[cfg(target_os = \"macos\")]\n pub fn real_args() -> ~[~str] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as c_int,\n                             *_NSGetArgv() as **c_char);\n@@ -1150,6 +1212,8 @@ pub fn real_args() -> ~[~str] {\n \n #[cfg(windows)]\n pub fn real_args() -> ~[~str] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n     let lpCmdLine = unsafe { GetCommandLineW() };\n@@ -1232,6 +1296,8 @@ pub fn set_args(new_args: ~[~str]) {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n pub fn glob(pattern: &str) -> ~[Path] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn default_glob_t () -> libc::glob_t {\n@@ -1326,13 +1392,17 @@ fn round_up(from: uint, to: uint) -> uint {\n \n #[cfg(unix)]\n pub fn page_size() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         libc::sysconf(libc::_SC_PAGESIZE) as uint\n     }\n }\n \n #[cfg(windows)]\n pub fn page_size() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n   unsafe {\n     let mut info = libc::SYSTEM_INFO::new();\n     libc::GetSystemInfo(&mut info);\n@@ -1404,6 +1474,8 @@ impl to_str::ToStr for MapError {\n #[cfg(unix)]\n impl MemoryMap {\n     pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::off_t;\n \n         let mut addr: *c_void = ptr::null();\n@@ -1460,6 +1532,8 @@ impl MemoryMap {\n #[cfg(unix)]\n impl Drop for MemoryMap {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             match libc::munmap(self.data as *c_void, self.len) {\n                 0 => (),\n@@ -1476,6 +1550,8 @@ impl Drop for MemoryMap {\n #[cfg(windows)]\n impl MemoryMap {\n     pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n         let mut lpAddress: LPVOID = ptr::mut_null();\n@@ -1569,6 +1645,8 @@ impl MemoryMap {\n #[cfg(windows)]\n impl Drop for MemoryMap {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n \n         unsafe {\n@@ -1921,6 +1999,8 @@ mod tests {\n \n     #[test]\n     fn copy_file_ok() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let tempdir = getcwd(); // would like to use $TMPDIR,\n                                     // doesn't seem to work on Linux\n@@ -1991,17 +2071,23 @@ mod tests {\n \n     #[test]\n     fn memory_map_file() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n \n         #[cfg(unix)]\n+        #[fixed_stack_segment]\n+        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n             unsafe {\n                 assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n             }\n         }\n         #[cfg(windows)]\n+        #[fixed_stack_segment]\n+        #[inline(never)]\n         fn lseek_(fd: c_int, size: uint) {\n            unsafe {\n                assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);"}, {"sha": "858098409e90d7c8dd9f4ff76e185a38fb107f64", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -381,6 +381,7 @@ mod stat {\n #[cfg(target_os = \"win32\")]\n impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf, &mut st) } {\n@@ -415,6 +416,7 @@ impl WindowsPath {\n #[cfg(not(target_os = \"win32\"))]\n impl PosixPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::stat(buf as *libc::c_char, &mut st) } {\n@@ -493,6 +495,7 @@ impl PosixPath {\n #[cfg(unix)]\n impl PosixPath {\n     pub fn lstat(&self) -> Option<libc::stat> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do self.with_c_str |buf| {\n             let mut st = stat::arch::default_stat();\n             match unsafe { libc::lstat(buf, &mut st) } {\n@@ -1101,6 +1104,8 @@ pub mod windows {\n     }\n \n     pub fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&"}, {"sha": "7b10866207a4222a6f6426b044384673fa09a940", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -877,6 +877,8 @@ impl Rng for XorShiftRng {\n impl XorShiftRng {\n     /// Create an xor shift random number generator with a random seed.\n     pub fn new() -> XorShiftRng {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // generate seeds the same way as seed(), except we have a spceific size\n         let mut s = [0u8, ..16];\n         loop {\n@@ -910,6 +912,8 @@ impl XorShiftRng {\n \n /// Create a new random seed.\n pub fn seed() -> ~[u8] {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n         let mut s = vec::from_elem(n, 0_u8);\n@@ -1142,6 +1146,8 @@ mod test {\n \n     #[test]\n     fn compare_isaac_implementation() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // This is to verify that the implementation of the ISAAC rng is\n         // correct (i.e. matches the output of the upstream implementation,\n         // which is in the runtime)"}, {"sha": "71eae56c894b81842baf946b38ac56ad610c688c", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -118,12 +118,22 @@ mod imp {\n         args\n     }\n \n-    extern {\n-        fn rust_take_global_args_lock();\n-        fn rust_drop_global_args_lock();\n-        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n+    #[cfg(stage0)]\n+    mod macro_hack {\n+    #[macro_escape];\n+    macro_rules! externfn(\n+        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            extern {\n+                fn $name() $(-> $ret_ty),*;\n+            }\n+        )\n+    )\n     }\n \n+    externfn!(fn rust_take_global_args_lock())\n+    externfn!(fn rust_drop_global_args_lock())\n+    externfn!(fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>)\n+\n     #[cfg(test)]\n     mod tests {\n         use option::{Some, None};"}, {"sha": "6400c1b660d17f7421bac367c7d5eac0e5d34584", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -136,6 +136,7 @@ impl DebugPrints for io::fd_t {\n     }\n \n     unsafe fn write_cstr(&self, p: *c_char) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         use libc::strlen;\n         use vec;\n "}, {"sha": "7d3f5f917748732982753722828c78349eaee010", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -35,8 +35,9 @@ fn align_to(size: uint, align: uint) -> uint {\n }\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n-#[inline]\n pub unsafe fn malloc_raw(size: uint) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let p = malloc(size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -46,8 +47,9 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n }\n \n /// A wrapper around libc::realloc, aborting on out-of-memory\n-#[inline]\n pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let p = realloc(ptr, size as size_t);\n     if p.is_null() {\n         // we need a non-allocating way to print an error here\n@@ -97,8 +99,9 @@ pub unsafe fn exchange_free_(ptr: *c_char) {\n     exchange_free(ptr)\n }\n \n-#[inline]\n pub unsafe fn exchange_free(ptr: *c_char) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(ptr as *c_void);\n }\n "}, {"sha": "bca1b4a70f4c933ba604d15f117255bb593251e3", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -37,6 +37,7 @@ pub struct LocalHeap {\n }\n \n impl LocalHeap {\n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn new() -> LocalHeap {\n         unsafe {\n             // Don't need synchronization for the single-threaded local heap\n@@ -55,18 +56,21 @@ impl LocalHeap {\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn alloc(&mut self, td: *TypeDesc, size: uint) -> *OpaqueBox {\n         unsafe {\n             return rust_boxed_region_malloc(self.boxed_region, td, size as size_t);\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn realloc(&mut self, ptr: *OpaqueBox, size: uint) -> *OpaqueBox {\n         unsafe {\n             return rust_boxed_region_realloc(self.boxed_region, ptr, size as size_t);\n         }\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn free(&mut self, box: *OpaqueBox) {\n         unsafe {\n             return rust_boxed_region_free(self.boxed_region, box);\n@@ -75,6 +79,7 @@ impl LocalHeap {\n }\n \n impl Drop for LocalHeap {\n+    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&self) {\n         unsafe {\n             rust_delete_boxed_region(self.boxed_region);"}, {"sha": "77303cb8c06cf5b04759624bd6ffa03d1ee29f5a", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -24,6 +24,8 @@ use unstable::finally::Finally;\n use tls = rt::thread_local_storage;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub fn init_tls_key() {\n     unsafe {\n         rust_initialize_rt_tls_key();\n@@ -124,6 +126,8 @@ fn tls_key() -> tls::Key {\n     }\n }\n \n+#[fixed_stack_segment]\n+#[inline(never)]\n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_rt_tls_key();\n@@ -149,8 +153,6 @@ fn maybe_tls_key() -> Option<tls::Key> {\n     }\n \n     extern {\n-        #[fast_ffi]\n         fn rust_get_rt_tls_key() -> *mut c_void;\n     }\n-\n }"}, {"sha": "f35304865bb3d7297442f78b899698f707d05122", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -57,6 +57,7 @@ impl Logger for StdErrLogger {\n \n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n+#[fixed_stack_segment] #[inline(never)]\n pub fn init(crate_map: *u8) {\n     use c_str::ToCStr;\n     use os;\n@@ -78,8 +79,13 @@ pub fn init(crate_map: *u8) {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn console_on() { unsafe { rust_log_console_on() } }\n+\n+#[fixed_stack_segment] #[inline(never)]\n pub fn console_off() { unsafe { rust_log_console_off() } }\n+\n+#[fixed_stack_segment] #[inline(never)]\n fn should_log_console() -> bool { unsafe { rust_should_log_console() != 0 } }\n \n extern {"}, {"sha": "db1bfdf1bf56cb0cba485736f00bd5f6d74d9f03", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -200,6 +200,18 @@ pub fn start_on_main_thread(argc: int, argv: **u8, crate_map: *u8, main: ~fn())\n     return exit_code;\n }\n \n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+        }\n+    )\n+)\n+}\n+\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing\n@@ -215,9 +227,7 @@ pub fn init(argc: int, argv: **u8, crate_map: *u8) {\n         rust_update_gc_metadata(crate_map);\n     }\n \n-    extern {\n-        fn rust_update_gc_metadata(crate_map: *u8);\n-    }\n+    externfn!(fn rust_update_gc_metadata(crate_map: *u8));\n }\n \n /// One-time runtime cleanup."}, {"sha": "4b2a9b7a6cce40b418df65d081be82ac787a5ab9", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -21,6 +21,8 @@ pub struct StackSegment {\n \n impl StackSegment {\n     pub fn new(size: uint) -> StackSegment {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             // Crate a block of uninitialized values\n             let mut stack = vec::with_capacity(size);\n@@ -50,6 +52,8 @@ impl StackSegment {\n \n impl Drop for StackSegment {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             // XXX: Using the FFI to call a C macro. Slow\n             rust_valgrind_stack_deregister(self.valgrind_id);"}, {"sha": "22d2600507836159db13e1d5d8f7a1d11cd4b954", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -441,6 +441,8 @@ impl Unwinder {\n     }\n \n     pub fn begin_unwind(&mut self) -> ! {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         self.unwinding = true;\n         unsafe {\n             rust_begin_unwind(UNWIND_TOKEN);"}, {"sha": "a9331157749338123d784b36e8673ed77a012e41", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -98,6 +98,8 @@ mod darwin_fd_limit {\n     static RLIMIT_NOFILE: libc::c_int = 8;\n \n     pub unsafe fn raise_fd_limit() {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n         // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n         use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n@@ -305,6 +307,7 @@ pub fn cleanup_task(mut task: ~Task) {\n }\n \n /// Get a port number, starting at 9600, for use in tests\n+#[fixed_stack_segment] #[inline(never)]\n pub fn next_test_port() -> u16 {\n     unsafe {\n         return rust_dbg_next_port(base_port() as libc::uintptr_t) as u16;"}, {"sha": "61db08f4813ef5da516cd1d8ecc335cb43fc9a3d", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -23,6 +23,8 @@ pub struct Thread {\n impl Thread {\n     pub fn start(main: ~fn()) -> Thread {\n         fn substart(main: &~fn()) -> *raw_thread {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             unsafe { rust_raw_thread_start(main) }\n         }\n         let raw = substart(&main);\n@@ -34,6 +36,8 @@ impl Thread {\n     }\n \n     pub fn join(self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         assert!(!self.joined);\n         let mut this = self;\n         unsafe { rust_raw_thread_join(this.raw_thread); }\n@@ -43,6 +47,8 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         assert!(self.joined);\n         unsafe { rust_raw_thread_delete(self.raw_thread) }\n     }"}, {"sha": "a9cd29c18c9652d58a2fbe10704d236bf6650ccb", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -20,16 +20,22 @@ use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     assert_eq!(0, pthread_key_create(key, null()));\n }\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert_eq!(0, pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     pthread_getspecific(key)\n }\n@@ -58,18 +64,24 @@ extern {\n pub type Key = DWORD;\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn create(key: &mut Key) {\n     static TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n     *key = TlsAlloc();\n     assert!(*key != TLS_OUT_OF_INDEXES);\n }\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert!(0 != TlsSetValue(key, value))\n }\n \n #[cfg(windows)]\n+#[fixed_stack_segment]\n+#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     TlsGetValue(key)\n }"}, {"sha": "b8c7c8761e85d72cd2ffaae9a5320b5946e74fce", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -17,6 +17,8 @@ use str::StrSlice;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         return rust_get_num_cpus();\n     }\n@@ -94,11 +96,16 @@ memory and partly incapable of presentation to others.\",\n     rterrln!(\"%s\", \"\");\n     rterrln!(\"fatal runtime error: %s\", msg);\n \n-    unsafe { libc::abort(); }\n+    abort();\n+\n+    fn abort() -> ! {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe { libc::abort() }\n+    }\n }\n \n pub fn set_exit_status(code: int) {\n-\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         return rust_set_exit_status_newrt(code as libc::uintptr_t);\n     }\n@@ -109,7 +116,7 @@ pub fn set_exit_status(code: int) {\n }\n \n pub fn get_exit_status() -> int {\n-\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         return rust_get_exit_status_newrt() as int;\n     }"}, {"sha": "9312efbf03e9ac4f0d9e3e66e7fc07bea31eca8d", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -310,6 +310,8 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n \n /// Transmute an owned vector to a Buf\n pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     unsafe {\n         let data = malloc(v.len() as size_t) as *u8;\n         assert!(data.is_not_null());\n@@ -323,6 +325,8 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n \n /// Transmute a Buf that was once a ~[u8] back to ~[u8]\n pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     if !(buf.len == 0 && buf.base.is_null()) {\n         let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n         unsafe { free(buf.base as *c_void) };"}, {"sha": "d4794da9b0f2884f47d00a1a48f7c66826b66a71", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -45,6 +45,7 @@ enum SocketNameKind {\n \n fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n                                                  handle: U) -> Result<SocketAddr, IoError> {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     let getsockname = match sk {\n         TcpPeer => uvll::rust_uv_tcp_getpeername,\n@@ -406,6 +407,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 1 as c_int)\n         };\n@@ -417,6 +420,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 0 as c_int)\n         };\n@@ -524,6 +529,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_nodelay(self.native_handle(), 0 as c_int)\n         };\n@@ -535,6 +542,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_nodelay(self.native_handle(), 1 as c_int)\n         };\n@@ -546,6 +555,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_keepalive(self.native_handle(), 1 as c_int,\n                                         delay_in_seconds as c_uint)\n@@ -558,6 +569,8 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let r = unsafe {\n             uvll::rust_uv_tcp_keepalive(self.native_handle(), 0 as c_int, 0 as c_uint)\n         };"}, {"sha": "65c0cffe5a073a57d607f0a1d93791b4233c0dd6", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -124,6 +124,8 @@ pub enum uv_membership {\n }\n \n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = rust_uv_handle_size(handle as uint);\n     let p = malloc(size);\n@@ -132,10 +134,14 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n }\n \n pub unsafe fn free_handle(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(v)\n }\n \n pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n     let size = rust_uv_req_size(req as uint);\n     let p = malloc(size);\n@@ -144,309 +150,454 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n }\n \n pub unsafe fn free_req(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     free(v)\n }\n \n #[test]\n fn handle_sanity_check() {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n     }\n }\n \n #[test]\n+#[fixed_stack_segment]\n+#[inline(never)]\n fn request_sanity_check() {\n     unsafe {\n         assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n     }\n }\n \n pub unsafe fn loop_new() -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_loop_new();\n }\n \n pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_loop_delete(loop_handle);\n }\n \n pub unsafe fn run(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_run(loop_handle);\n }\n \n pub unsafe fn close<T>(handle: *T, cb: *u8) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_close(handle as *c_void, cb);\n }\n \n pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_walk(loop_handle, cb, arg);\n }\n \n pub unsafe fn idle_new() -> *uv_idle_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_new()\n }\n \n pub unsafe fn idle_delete(handle: *uv_idle_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_delete(handle)\n }\n \n pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_init(loop_handle, handle)\n }\n \n pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_start(handle, cb)\n }\n \n pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_idle_stop(handle)\n }\n \n pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_init(loop_handle, handle);\n }\n \n pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_bind(server, addr, flags);\n }\n \n pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_bind6(server, addr, flags);\n }\n \n pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n                           addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n }\n \n pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n                           addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n }\n \n pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n                              on_recv: uv_udp_recv_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n }\n \n pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_recv_stop(server);\n }\n \n pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_getsockname(handle, name);\n }\n \n pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n                                  interface_addr: *c_char, membership: uv_membership) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n }\n \n pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_multicast_loop(handle, on);\n }\n \n pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_multicast_ttl(handle, ttl);\n }\n \n pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_ttl(handle, ttl);\n }\n \n pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_udp_set_broadcast(handle, on);\n }\n \n pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_init(loop_handle, handle);\n }\n \n pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n                           addr_ptr: *sockaddr_in, after_connect_cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n \n pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n                            addr_ptr: *sockaddr_in6, after_connect_cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n }\n \n pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n }\n \n pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n }\n \n pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n }\n \n pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_getsockname(handle, name);\n }\n \n pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_nodelay(handle, enable);\n }\n \n pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_keepalive(handle, enable, delay);\n }\n \n pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_tcp_simultaneous_accepts(handle, enable);\n }\n \n pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_listen(stream as *c_void, backlog, cb);\n }\n \n pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_accept(server as *c_void, client as *c_void);\n }\n \n pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: uv_alloc_cb, on_read: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n }\n \n pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_read_stop(stream as *c_void);\n }\n \n pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_last_error(loop_handle);\n }\n \n pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_strerror(err);\n }\n pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_err_name(err);\n }\n \n pub unsafe fn async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_async_init(loop_handle, async_handle, cb);\n }\n \n pub unsafe fn async_send(async_handle: *uv_async_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_async_send(async_handle);\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n     let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n     rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n \n pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n                           repeat: u64) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_timer_stop(timer_ptr);\n }\n \n pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n }\n \n pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n }\n \n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do ip.with_c_str |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n+    #[fixed_stack_segment]; #[inline(never)];\n     do ip.with_c_str |ip_buf| {\n         rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n     }\n }\n \n pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_malloc_sockaddr_storage()\n }\n \n pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_sockaddr_storage(ss);\n }\n \n pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_ip4_addr(addr);\n }\n \n pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_free_ip6_addr(addr);\n }\n \n pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip4_name(addr, dst, size);\n }\n \n pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip6_name(addr, dst, size);\n }\n \n pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n    return rust_uv_ip4_port(addr);\n }\n \n pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_ip6_port(addr);\n }\n \n // data access helpers\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_stream_handle_from_connect_req(connect);\n }\n pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_stream_handle_from_write_req(write_req);\n }\n pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_data_for_uv_handle(handle as *c_void);\n }\n pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n }\n pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_data_for_req(req as *c_void);\n }\n pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n }\n pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_base_from_buf(buf);\n }\n pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_get_len_from_buf(buf);\n }\n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {"}, {"sha": "a43d448dae51f30a0bda7b6c7312c4df4ddd8d9a", "filename": "src/libstd/run.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -147,8 +147,11 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions)\n+    pub fn new(prog: &str, args: &[~str],\n+               options: ProcessOptions)\n                -> Process {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         let (in_pipe, in_fd) = match options.in_fd {\n             None => {\n                 let pipe = os::pipe();\n@@ -287,6 +290,7 @@ impl Process {\n      * method does nothing.\n      */\n     pub fn close_input(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         match self.input {\n             Some(-1) | None => (),\n             Some(fd) => {\n@@ -299,10 +303,12 @@ impl Process {\n     }\n \n     fn close_outputs(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         fclose_and_null(&mut self.output);\n         fclose_and_null(&mut self.error);\n \n         fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n+            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n             match *f_opt {\n                 Some(f) if !f.is_null() => {\n                     unsafe {\n@@ -387,6 +393,7 @@ impl Process {\n \n         #[cfg(windows)]\n         fn killpid(pid: pid_t, _force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n             unsafe {\n                 libc::funcs::extra::kernel32::TerminateProcess(\n                     cast::transmute(pid), 1);\n@@ -395,6 +402,8 @@ impl Process {\n \n         #[cfg(unix)]\n         fn killpid(pid: pid_t, force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n             let signal = if force {\n                 libc::consts::os::posix88::SIGKILL\n             } else {\n@@ -447,6 +456,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n@@ -630,6 +640,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n \n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n@@ -782,6 +793,7 @@ fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n \n #[cfg(windows)]\n fn free_handle(handle: *()) {\n+    #[fixed_stack_segment]; #[inline(never)];\n     unsafe {\n         libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n@@ -848,6 +860,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n \n         use libc::types::os::arch::extra::DWORD;\n         use libc::consts::os::extra::{\n@@ -892,6 +905,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n \n         use libc::funcs::posix01::wait::*;\n \n@@ -1069,6 +1083,8 @@ mod tests {\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             let file = os::fdopen(fd);\n             let reader = io::FILE_reader(file, false);\n@@ -1351,6 +1367,7 @@ mod tests {\n     }\n \n     fn running_on_valgrind() -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe { rust_running_on_valgrind() != 0 }\n     }\n "}, {"sha": "7f22f44a6f87286ec101244bcf5953aff531cac2", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -220,3 +220,4 @@ mod std {\n     pub use fmt;\n     pub use to_bytes;\n }\n+"}, {"sha": "2a8a79fcb32923f8e058ea8db25f2c43482da409", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -2908,6 +2908,7 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n+        #[fixed_stack_segment]; #[inline(never)];\n         assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n         assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n     }"}, {"sha": "8132bfe53778ba246c273019f2f674a94b6f51df", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -147,7 +147,7 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n                 // above.\n                 let data = match util::replace(entry, None) {\n                     Some((_, data, _)) => data,\n-                    None => libc::abort(),\n+                    None => abort(),\n                 };\n \n                 // Move `data` into transmute to get out the memory that it\n@@ -252,7 +252,7 @@ unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n                         }\n                     }\n                 }\n-                _ => libc::abort()\n+                _ => abort()\n             }\n \n             // n.b. 'data' and 'loans' are both invalid pointers at the point\n@@ -262,14 +262,20 @@ unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n             if return_loan {\n                 match map[i] {\n                     Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n-                    None => { libc::abort(); }\n+                    None => { abort(); }\n                 }\n             }\n             return ret;\n         }\n     }\n }\n \n+fn abort() -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    unsafe { libc::abort() }\n+}\n+\n pub unsafe fn local_set<T: 'static>(handle: Handle,\n                                     key: local_data::Key<T>,\n                                     data: T) {"}, {"sha": "0d2e62a77003e003e016033b5cb4bd2bae37d33c", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -1045,15 +1045,12 @@ fn test_spawn_sched_childs_on_default_sched() {\n mod testrt {\n     use libc;\n \n-    #[nolink]\n-    extern {\n-        pub fn rust_dbg_lock_create() -> *libc::c_void;\n-        pub fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_lock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_wait(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_signal(lock: *libc::c_void);\n-    }\n+    externfn!(fn rust_dbg_lock_create() -> *libc::c_void)\n+    externfn!(fn rust_dbg_lock_destroy(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_lock(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_unlock(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_wait(lock: *libc::c_void))\n+    externfn!(fn rust_dbg_lock_signal(lock: *libc::c_void))\n }\n \n #[test]"}, {"sha": "6dbe68200b3b7fe23d28c62b72dc39083e7ec993", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -145,16 +145,21 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do filename.with_c_str |raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         unsafe {\n             do atomically {\n                 let _old_error = dlerror();\n@@ -172,9 +177,13 @@ mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlsym(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n         dlclose(handle); ()\n     }\n \n@@ -204,18 +213,21 @@ mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         do os::win32::as_utf16_p(filename.to_str()) |raw_name| {\n             LoadLibraryW(raw_name)\n         }\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         let handle = ptr::null();\n         GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n         handle\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             do atomically {\n                 SetLastError(0);\n@@ -232,9 +244,11 @@ mod dl {\n         }\n     }\n     pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n+        #[fixed_stack_segment]; #[inline(never)];\n         GetProcAddress(handle, symbol)\n     }\n     pub unsafe fn close(handle: *libc::c_void) {\n+        #[fixed_stack_segment]; #[inline(never)];\n         FreeLibrary(handle); ()\n     }\n "}, {"sha": "6ad15bfc7c03939884be3590eaad06ffa789d946", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -83,6 +83,8 @@ fn test_run_in_bare_thread_exchange() {\n /// can lead to deadlock. Calling change_dir_locked recursively will\n /// also deadlock.\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     use os;\n     use os::change_dir;\n     use unstable::sync::atomically;"}, {"sha": "29be094121c3b6350bc64c61e7b4e585747730f1", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -322,7 +322,6 @@ impl LittleLock {\n         }\n     }\n \n-    #[inline]\n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n             rust_lock_little_lock(self.l);\n@@ -410,13 +409,28 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-extern {\n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n+#[cfg(stage0)]\n+mod macro_hack {\n+#[macro_escape];\n+macro_rules! externfn(\n+    (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name() $(-> $ret_ty),*;\n+        }\n+    );\n+    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+        extern {\n+            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+        }\n+    )\n+)\n }\n \n+externfn!(fn rust_create_little_lock() -> rust_little_lock)\n+externfn!(fn rust_destroy_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_lock_little_lock(lock: rust_little_lock))\n+externfn!(fn rust_unlock_little_lock(lock: rust_little_lock))\n+\n #[cfg(test)]\n mod tests {\n     use cell::Cell;"}, {"sha": "4bea1dc23e737a0d4ae660130ec9358030ddcb9b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -968,6 +968,85 @@ pub fn std_macros() -> @str {\n             pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n         )\n     )\n+\n+    // externfn! declares a wrapper for an external function.\n+    // It is intended to be used like:\n+    //\n+    // externfn!(#[nolink]\n+    //           #[abi = \\\"cdecl\\\"]\n+    //           fn memcmp(cx: *u8, ct: *u8, n: u32) -> u32)\n+    //\n+    // Due to limitations in the macro parser, this pattern must be\n+    // implemented with 4 distinct patterns (with attrs / without\n+    // attrs CROSS with args / without ARGS).\n+    //\n+    // Also, this macro grammar allows for any number of return types\n+    // because I couldn't figure out the syntax to specify at most one.\n+    macro_rules! externfn(\n+        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name() $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name();\n+\n+                extern {\n+                    fn $name() $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name($($arg_name),*);\n+\n+                extern {\n+                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        ($($attrs:attr)* fn $name:ident () $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name() $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name();\n+\n+                $($attrs)*\n+                extern {\n+                    fn $name() $(-> $ret_ty),*;\n+                }\n+            }\n+        );\n+        ($($attrs:attr)* fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n+            pub unsafe fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),* {\n+                // Note: to avoid obscure bug in macros, keep these\n+                // attributes *internal* to the fn\n+                #[fixed_stack_segment];\n+                #[inline(never)];\n+                #[allow(missing_doc)];\n+\n+                return $name($($arg_name),*);\n+\n+                $($attrs)*\n+                extern {\n+                    fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n+                }\n+            }\n+        )\n+    )\n+\n }\";\n }\n "}, {"sha": "03cb96a3729af21dc9295d761534fde3f81f583c", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -24,6 +24,7 @@ pub mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "6f0c2f1de1ab45b1bb7f4cf7992a2e1e329d2cb3", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -10,6 +10,7 @@\n \n // Exercise the unused_unsafe attribute in some positive and negative cases\n \n+#[allow(cstack)];\n #[deny(unused_unsafe)];\n \n mod foo {\n@@ -55,6 +56,7 @@ fn good2() {\n         }\n     }\n }\n+\n unsafe fn good3() { foo::bar() }\n fn good4() { unsafe { foo::bar() } }\n "}, {"sha": "1a2c22889fd82d680fc6a993f9077c7ee0f16f7c", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -14,6 +14,7 @@ extern mod anonexternmod;\n \n use anonexternmod::*;\n \n+#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         rust_get_test_int();"}, {"sha": "ed9caa1f65e2f52223ea868d95d5d7ac54a7ba3c", "filename": "src/test/run-pass/anon-extern-mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -16,6 +16,7 @@ extern {\n     fn rust_get_test_int() -> libc::intptr_t;\n }\n \n+#[fixed_stack_segment]\n pub fn main() {\n     unsafe {\n         let _ = rust_get_test_int();"}, {"sha": "f140c4621aa27319cec5be3f064514d951d4b2b1", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,10 +19,12 @@ mod libc {\n     }\n }\n \n+#[fixed_stack_segment]\n fn atol(s: ~str) -> int {\n     s.with_c_str(|x| unsafe { libc::atol(x) as int })\n }\n \n+#[fixed_stack_segment]\n fn atoll(s: ~str) -> i64 {\n     s.with_c_str(|x| unsafe { libc::atoll(x) as i64 })\n }"}, {"sha": "27ad2fc46e07dab407a2c9e2b3b055917b7f696b", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -27,6 +27,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "6c90443636d3913cabe7008e469bdbf99697426f", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -28,6 +28,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "5abd3c7b9d918ce55865b555aaa1c6ebe4cfa5de", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -32,6 +32,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "939487df174db1f1cf9059b746ab13179994b4d2", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -27,6 +27,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "7db7b898c0e6d7e29e1f059eeddc84c882e239c7", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -13,6 +13,7 @@\n \n extern mod externcallback(vers = \"0.1\");\n \n+#[fixed_stack_segment] #[inline(never)]\n fn fact(n: uint) -> uint {\n     unsafe {\n         info!(\"n = %?\", n);"}, {"sha": "147db0c0b2b0d9eb1c33ccf6b16b67c2ce3d6245", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -20,6 +20,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU32s(v: TwoU32s) -> TwoU32s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU32s {one: 22, two: 23};"}, {"sha": "1937c366831ffc795de87530dcb49eefd1790b34", "filename": "src/test/run-pass/extern-pass-TwoU64s-ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,6 +19,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(u: TwoU64s) -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "b543099b3b8f8f4990ecc508ef8d1ff20f9680d2", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -24,6 +24,7 @@ extern {\n     pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let x = TwoU64s {one: 22, two: 23};"}, {"sha": "f255746b75a8f683ca6ae60449866660904a0fcd", "filename": "src/test/run-pass/extern-pass-char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u8(v: u8) -> u8;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u8, rust_dbg_extern_identity_u8(22_u8));"}, {"sha": "c80a0cd502fd351905a863140af3f5b765a2b702", "filename": "src/test/run-pass/extern-pass-double.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -12,6 +12,7 @@ extern {\n     pub fn rust_dbg_extern_identity_double(v: f64) -> f64;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22.0_f64, rust_dbg_extern_identity_double(22.0_f64));"}, {"sha": "c6fdabeab3dea0bbf4ee0f39903531bd6426966f", "filename": "src/test/run-pass/extern-pass-u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u32(v: u32) -> u32;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u32, rust_dbg_extern_identity_u32(22_u32));"}, {"sha": "09babc1109f8c3166bbd9058201c5b909fb8ec10", "filename": "src/test/run-pass/extern-pass-u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -14,6 +14,7 @@ extern {\n     pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         assert_eq!(22_u64, rust_dbg_extern_identity_u64(22_u64));"}, {"sha": "2b9f99ca0105cb06a620c519252e4d0139275b33", "filename": "src/test/run-pass/extern-return-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU16s() -> TwoU16s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU16s();"}, {"sha": "f93a15bd80806c601aab3e1612346e939aff138c", "filename": "src/test/run-pass/extern-return-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU32s() -> TwoU32s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU32s();"}, {"sha": "4dc31d715260b2707ffbd34521f941c198e31433", "filename": "src/test/run-pass/extern-return-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU64s() -> TwoU64s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU64s();"}, {"sha": "aae8b8a8587d0d7d91addae7f5b4fd24135d47f1", "filename": "src/test/run-pass/extern-return-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -16,6 +16,7 @@ extern {\n     pub fn rust_dbg_extern_return_TwoU8s() -> TwoU8s;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let y = rust_dbg_extern_return_TwoU8s();"}, {"sha": "4eda3f34b6c15198a9f78d15d7b7efc22542a9b7", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -32,6 +32,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         rustrt::rust_dbg_call(cb, n)"}, {"sha": "ce51aafa9d80960160f663f1544535643ca5cb7f", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -28,6 +28,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn count(n: uint) -> uint {\n     unsafe {\n         task::deschedule();"}, {"sha": "c8acdbf44781c64bebe81228a742f753337d36ee", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -2,9 +2,7 @@ use std::cast;\n use std::libc;\n use std::unstable::run_in_bare_thread;\n \n-extern {\n-    pub fn rust_dbg_call(cb: *u8, data: libc::uintptr_t) -> libc::uintptr_t;\n-}\n+externfn!(fn rust_dbg_call(cb: *u8, data: libc::uintptr_t) -> libc::uintptr_t)\n \n pub fn main() {\n     unsafe {"}, {"sha": "3ff1ebb57322cfa10e67d32a56ce2cecbcda5e9a", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -31,6 +31,7 @@ mod rustrt2 {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt1::rust_get_test_int();"}, {"sha": "57b59e4445e7718800ffe80de19a24fdda7b90a0", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -21,6 +21,7 @@ mod libc {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn strlen(str: ~str) -> uint {\n     // C string is terminated with a zero\n     do str.with_c_str |buf| {"}, {"sha": "f9c2698eda499f882b5d6781718578db047c3f78", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -18,6 +18,7 @@ mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         rustrt::rust_get_test_int();"}, {"sha": "1736428affb36cc0844152bba85fa5ff4d47b008", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -17,6 +17,7 @@\n \n extern mod foreign_lib;\n \n+#[fixed_stack_segment] #[inline(never)]\n pub fn main() {\n     unsafe {\n         let _foo = foreign_lib::rustrt::rust_get_test_int();"}, {"sha": "1bb8a0008760b2ede0f90d6cdd9381ee03ce5259", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -19,6 +19,7 @@ fn to_c_int(v: &mut int) -> &mut c_int {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn lgamma(n: c_double, value: &mut int) -> c_double {\n     unsafe {\n         return m::lgamma(n, to_c_int(value));"}, {"sha": "b58c8738295da925923dba8c2c9c40ce5cacae97", "filename": "src/test/run-pass/newtype-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -4,6 +4,7 @@ use std::libc;\n pub struct Fd(c_int);\n \n impl Drop for Fd {\n+    #[fixed_stack_segment] #[inline(never)]\n     fn drop(&self) {\n         unsafe {\n             libc::close(**self);"}, {"sha": "360ac75b3e75357381cc2aebc7fa15828f58b2af", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -6,6 +6,7 @@ mod a {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn main() {\n     unsafe {\n         a::free(transmute(0));"}, {"sha": "201584d48a58571231daf8ee855752e2a033359e", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -27,6 +27,7 @@ struct Ccx {\n     x: int\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         cast::transmute(libc::malloc(sys::size_of::<Bcx<'blk>>()\n@@ -38,6 +39,7 @@ fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);"}, {"sha": "429b49375e0daa0576e3f8c1405dff560eed200b", "filename": "src/test/run-pass/static-mut-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -26,6 +26,7 @@ fn static_bound_set(a: &'static mut libc::c_int) {\n     *a = 3;\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n unsafe fn run() {\n     assert!(debug_static_mut == 3);\n     debug_static_mut = 4;"}, {"sha": "1c39504ba717bc5cf5f7c9773983f049c753bcec", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -21,6 +21,7 @@ mod rustrt {\n     }\n }\n \n+#[fixed_stack_segment] #[inline(never)]\n fn test1() {\n     unsafe {\n         let q = Quad { a: 0xaaaa_aaaa_aaaa_aaaa_u64,\n@@ -40,6 +41,8 @@ fn test1() {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n+#[fixed_stack_segment]\n+#[inline(never)]\n fn test2() {\n     unsafe {\n         let f = Floats { a: 1.234567890e-15_f64,"}, {"sha": "3722dccf94b94001c38914056d6220fe9f082c47", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479d946c83cf9ed90bba5b33820ea4118dd8f9e/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=0479d946c83cf9ed90bba5b33820ea4118dd8f9e", "patch": "@@ -29,6 +29,7 @@ mod kernel32 {\n \n \n #[cfg(target_os = \"win32\")]\n+#[fixed_stack_segment]\n pub fn main() {\n     let heap = unsafe { kernel32::GetProcessHeap() };\n     let mem = unsafe { kernel32::HeapAlloc(heap, 0u32, 100u32) };"}]}