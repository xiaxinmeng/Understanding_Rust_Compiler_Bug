{"sha": "2643b16468fda787470340890212591d8bc832b7", "node_id": "C_kwDOAAsO6NoAKDI2NDNiMTY0NjhmZGE3ODc0NzAzNDA4OTAyMTI1OTFkOGJjODMyYjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T18:22:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T18:22:33Z"}, "message": "Auto merge of #99816 - GuillaumeGomez:rollup-tyobksa, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94247 (Fix slice::ChunksMut aliasing)\n - #99358 (Allow `ValTree::try_to_raw_bytes` on `u8` array)\n - #99651 (Deeply deny fn and raw ptrs in const generics)\n - #99710 (lint: add bad opt access internal lint)\n - #99717 (Add some comments to the docs issue template to clarify)\n - #99728 (Clean up HIR-based lifetime resolution)\n - #99812 (Fix headings colors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dfb7655d89e2758e346ed903c3cf258e79b4fcec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb7655d89e2758e346ed903c3cf258e79b4fcec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2643b16468fda787470340890212591d8bc832b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2643b16468fda787470340890212591d8bc832b7", "html_url": "https://github.com/rust-lang/rust/commit/2643b16468fda787470340890212591d8bc832b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2643b16468fda787470340890212591d8bc832b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da5b546d2e563747b16a16dae83bacf49aa0bf3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5b546d2e563747b16a16dae83bacf49aa0bf3b", "html_url": "https://github.com/rust-lang/rust/commit/da5b546d2e563747b16a16dae83bacf49aa0bf3b"}, {"sha": "2d52aa05d1786b32f7d6e944a733352d31675acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d52aa05d1786b32f7d6e944a733352d31675acc", "html_url": "https://github.com/rust-lang/rust/commit/2d52aa05d1786b32f7d6e944a733352d31675acc"}], "stats": {"total": 2920, "additions": 1570, "deletions": 1350}, "files": [{"sha": "9ccda17a6ef47e41bc8cb41b906769b49c0d4cdf", "filename": ".github/ISSUE_TEMPLATE/documentation.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdocumentation.md?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -4,13 +4,28 @@ about: Create a report for a documentation problem.\n labels: A-docs\n ---\n <!--\n+\n Thank you for finding a documentation problem! \ud83d\udcda\n \n Documentation problems might be grammatical issues, typos, or unclear wording, please provide details regarding the documentation including where it is present.\n \n+Note: If your issue is for one of these, please use their dedicated issue tracker instead:\n+\n+- The Rust Book: https://github.com/rust-lang/book/issues\n+- Rust by Example: https://github.com/rust-lang/rust-by-example/issues\n+- The Edition Guide: https://github.com/rust-lang/edition-guide/issues\n+- The Cargo Book: https://github.com/rust-lang/cargo/issues\n+- The Clippy Book: https://github.com/rust-lang/rust-clippy/issues\n+- The Reference: https://github.com/rust-lang/reference/issues\n+- The Rustonomicon: https://github.com/rust-lang/nomicon/issues\n+- The Embedded Book: https://github.com/rust-embedded/book/issues\n+\n+All other documentation issues should be filed here.\n+\n+Or, if you find an issue related to rustdoc (e.g. doctest, rustdoc UI), please use the bug report or blank issue template instead.\n+\n -->\n \n ### Location\n \n ### Summary\n-"}, {"sha": "a1bf0f94964bb70e8d342dd18b868482cb0bbb89", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1883,29 +1883,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n-            LifetimeRes::Anonymous { binder, elided } => {\n-                let mut l_name = None;\n-                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                        let p_id = self.next_node_id();\n-                        let p_def_id = self.create_def(\n-                            captured_lifetimes.parent_def_id,\n-                            p_id,\n-                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                        );\n-                        captured_lifetimes\n-                            .captures\n-                            .insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n-                        l_name = Some(hir::LifetimeName::Param(p_def_id, ParamName::Fresh));\n-                    }\n-                    self.captured_lifetimes = Some(captured_lifetimes);\n-                };\n-                l_name.unwrap_or(if elided {\n-                    hir::LifetimeName::Implicit\n-                } else {\n-                    hir::LifetimeName::Underscore\n-                })\n-            }\n+            LifetimeRes::Infer => hir::LifetimeName::Infer,\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),"}, {"sha": "0662d4d882f6a8cdda2215ee29dec8dbdac5995b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -589,8 +589,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n             hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n             | hir::LifetimeName::ImplicitObjectLifetimeDefault\n-            | hir::LifetimeName::Implicit\n-            | hir::LifetimeName::Underscore => {\n+            | hir::LifetimeName::Infer => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "e099445117225e4a268718c01617e1612bcbeb63", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -226,7 +226,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty, true).is_some()\n+        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty).is_some()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "53ae913f94f124f9dd1166c5eb723e177d21253b", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -123,8 +123,7 @@ impl Callbacks for TimePassesCallbacks {\n     fn config(&mut self, config: &mut interface::Config) {\n         // If a --prints=... option has been given, we don't print the \"total\"\n         // time because it will mess up the --prints output. See #64339.\n-        self.time_passes = config.opts.prints.is_empty()\n-            && (config.opts.unstable_opts.time_passes || config.opts.unstable_opts.time);\n+        self.time_passes = config.opts.prints.is_empty() && config.opts.time_passes();\n         config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n     }\n }\n@@ -249,7 +248,7 @@ fn run_compiler(\n                     if sopts.describe_lints {\n                         let mut lint_store = rustc_lint::new_lint_store(\n                             sopts.unstable_opts.no_interleave_lints,\n-                            compiler.session().unstable_options(),\n+                            compiler.session().enable_internal_lints(),\n                         );\n                         let registered_lints =\n                             if let Some(register_lints) = compiler.register_lints() {"}, {"sha": "b17eb9c2d260e9a4a14b9eb07220b229ed5a6c7f", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -256,3 +256,9 @@ passes-unused-duplicate = unused attribute\n passes-unused-multiple = multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n+\n+passes-rustc-lint-opt-ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+    .label = not a struct\n+\n+passes-rustc-lint-opt-deny-field-access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+    .label = not a field"}, {"sha": "0e73d8fd7f600f284e2af7be4c7f08cf89c3d344", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -619,6 +619,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Used by the `rustc::untranslatable_diagnostic` and `rustc::diagnostic_outside_of_impl` lints\n     // to assist in changes to diagnostic APIs.\n     rustc_attr!(rustc_lint_diagnostics, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint to identify `DebuggingOptions` and `CodegenOptions`\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_ty, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint on fields\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_deny_field_access, Normal, template!(List: \"message\"), WarnFollowing, INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:"}, {"sha": "be5b7eccbafb2ef34cc1bd53fd2924fe265ac2fe", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -738,13 +738,8 @@ pub enum LifetimeRes {\n         binder: NodeId,\n     },\n     /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n-    Anonymous {\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-        /// Whether this lifetime was spelled or elided.\n-        elided: bool,\n-    },\n+    /// late resolution.  Those lifetimes will be inferred by typechecking.\n+    Infer,\n     /// Explicit `'static` lifetime.\n     Static,\n     /// Resolution failure."}, {"sha": "f71400898e60b44fa561f49917a481dd650c9ce5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -90,9 +90,6 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(LocalDefId, ParamName),\n \n-    /// User wrote nothing (e.g., the lifetime in `&u32`).\n-    Implicit,\n-\n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n     /// lifetime that they default to must appear elsewhere within the\n@@ -110,8 +107,9 @@ pub enum LifetimeName {\n     /// that was already reported.\n     Error,\n \n-    /// User wrote specifies `'_`.\n-    Underscore,\n+    /// User wrote an anonymous lifetime, either `'_` or nothing.\n+    /// The semantics of this lifetime should be inferred by typechecking code.\n+    Infer,\n \n     /// User wrote `'static`.\n     Static,\n@@ -120,10 +118,8 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Error => Ident::empty(),\n-            LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n+            LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Error => Ident::empty(),\n+            LifetimeName::Infer => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(_, param_name) => param_name.ident(),\n         }\n@@ -132,8 +128,7 @@ impl LifetimeName {\n     pub fn is_anonymous(&self) -> bool {\n         match *self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Underscore\n+            | LifetimeName::Infer\n             | LifetimeName::Param(_, ParamName::Fresh)\n             | LifetimeName::Error => true,\n             LifetimeName::Static | LifetimeName::Param(..) => false,\n@@ -142,9 +137,7 @@ impl LifetimeName {\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit\n-            | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Infer => true,\n \n             // It might seem surprising that `Fresh` counts as\n             // *not* elided -- but this is because, as far as the code"}, {"sha": "640974115b926e2075a9b26f42d13c3c7b4c0352", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -496,9 +496,8 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         | LifetimeName::Param(_, ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n-        | LifetimeName::Implicit\n         | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Underscore => {}\n+        | LifetimeName::Infer => {}\n     }\n }\n "}, {"sha": "c1b201da69121c92e5a1b2e63a068a90836a376a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -100,23 +100,6 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                 // the lifetime of the TyRptr\n                 let hir_id = lifetime.hir_id;\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n-                    // Find the index of the anonymous region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (\n-                        Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n-                        ty::BrAnon(br_index),\n-                    ) => {\n-                        debug!(\n-                            \"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n-                            debruijn_index, anon_index, br_index\n-                        );\n-                        if debruijn_index == self.current_index && anon_index == br_index {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n@@ -151,8 +134,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n                             | rl::Region::EarlyBound(_, _)\n-                            | rl::Region::LateBound(_, _, _)\n-                            | rl::Region::LateBoundAnon(_, _, _),\n+                            | rl::Region::LateBound(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -206,16 +188,6 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (\n-                Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n-                ty::BrAnon(br_index),\n-            ) => {\n-                if debruijn_index == self.current_index && anon_index == br_index {\n-                    self.found_it = true;\n-                    return;\n-                }\n-            }\n-\n             (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n@@ -239,7 +211,6 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n                     rl::Region::Static\n                     | rl::Region::EarlyBound(_, _)\n                     | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::LateBoundAnon(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )\n                 | None,"}, {"sha": "94f81b6607798f7027a227e67d1719858e2046eb", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -329,6 +329,8 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n     })\n }\n \n+// JUSTIFICATION: before session exists, only config\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n     tracing::trace!(\"run_compiler\");\n     util::run_in_thread_pool_with_globals("}, {"sha": "8f0835917861acb41b5d2ce2cfc7f9039e6b0848", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -210,7 +210,7 @@ pub fn register_plugins<'a>(\n \n     let mut lint_store = rustc_lint::new_lint_store(\n         sess.opts.unstable_opts.no_interleave_lints,\n-        sess.unstable_options(),\n+        sess.enable_internal_lints(),\n     );\n     register_lints(sess, &mut lint_store);\n "}, {"sha": "21d9eaccf67e7ccffa4397cf9ac79cc8edf5701e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,3 +1,4 @@\n+#![cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n use crate::interface::parse_cfgspecs;\n \n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "4c64e679b95711260a60efe5067daa0db50226d3", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -559,6 +559,8 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     // Only check command line flags if present. If no types are specified by\n     // command line, then reuse the empty `base` Vec to hold the types that\n     // will be found in crate attributes.\n+    // JUSTIFICATION: before wrapper fn is available\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     let mut base = session.opts.crate_types.clone();\n     if base.is_empty() {\n         base.extend(attr_types);"}, {"sha": "c26d7824758ef06f11b40692b10ff2a2d367ea49", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -51,20 +51,6 @@ fn typeck_results_of_method_fn<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &Expr<'_>,\n ) -> Option<(Span, DefId, ty::subst::SubstsRef<'tcx>)> {\n-    // FIXME(rustdoc): Lints which use this function use typecheck results which can cause\n-    // `rustdoc` to error if there are resolution failures.\n-    //\n-    // As internal lints are currently always run if there are `unstable_options`, they are added\n-    // to the lint store of rustdoc. Internal lints are also not used via the `lint_mod` query.\n-    // Crate lints run outside of a query so rustdoc currently doesn't disable them.\n-    //\n-    // Instead of relying on this, either change crate lints to a query disabled by rustdoc, only\n-    // run internal lints if the user is explicitly opting in or figure out a different way to\n-    // avoid running lints for rustdoc.\n-    if cx.tcx.sess.opts.actually_rustdoc {\n-        return None;\n-    }\n-\n     match expr.kind {\n         ExprKind::MethodCall(segment, _, _)\n             if let Some(def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) =>\n@@ -446,3 +432,38 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n     }\n }\n+\n+declare_tool_lint! {\n+    pub rustc::BAD_OPT_ACCESS,\n+    Deny,\n+    \"prevent using options by field access when there is a wrapper function\",\n+    report_in_external_macro: true\n+}\n+\n+declare_lint_pass!(BadOptAccess => [ BAD_OPT_ACCESS ]);\n+\n+impl LateLintPass<'_> for BadOptAccess {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        let ExprKind::Field(base, target) = expr.kind else { return };\n+        let Some(adt_def) = cx.typeck_results().expr_ty(base).ty_adt_def() else { return };\n+        // Skip types without `#[rustc_lint_opt_ty]` - only so that the rest of the lint can be\n+        // avoided.\n+        if !cx.tcx.has_attr(adt_def.did(), sym::rustc_lint_opt_ty) {\n+            return;\n+        }\n+\n+        for field in adt_def.all_fields() {\n+            if field.name == target.name &&\n+                let Some(attr) = cx.tcx.get_attr(field.did, sym::rustc_lint_opt_deny_field_access) &&\n+                let Some(items) = attr.meta_item_list()  &&\n+                let Some(item) = items.first()  &&\n+                let Some(literal) = item.literal()  &&\n+                let ast::LitKind::Str(val, _) = literal.kind\n+            {\n+                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, |lint| {\n+                    lint.build(val.as_str()).emit(); }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "7b0702dad75dee9ae6d65420e01ea63f8ebc4fc0", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -509,8 +509,14 @@ fn register_internals(store: &mut LintStore) {\n     store.register_late_pass(|| Box::new(TyTyKind));\n     store.register_lints(&Diagnostics::get_lints());\n     store.register_late_pass(|| Box::new(Diagnostics));\n+    store.register_lints(&BadOptAccess::get_lints());\n+    store.register_late_pass(|| Box::new(BadOptAccess));\n     store.register_lints(&PassByValue::get_lints());\n     store.register_late_pass(|| Box::new(PassByValue));\n+    // FIXME(davidtwco): deliberately do not include `UNTRANSLATABLE_DIAGNOSTIC` and\n+    // `DIAGNOSTIC_OUTSIDE_OF_IMPL` here because `-Wrustc::internal` is provided to every crate and\n+    // these lints will trigger all of the time - change this once migration to diagnostic structs\n+    // and translation is completed\n     store.register_group(\n         false,\n         \"rustc::internal\",\n@@ -523,6 +529,7 @@ fn register_internals(store: &mut LintStore) {\n             LintId::of(LINT_PASS_IMPL_WITHOUT_MACRO),\n             LintId::of(USAGE_OF_QUALIFIED_TY),\n             LintId::of(EXISTING_DOC_KEYWORD),\n+            LintId::of(BAD_OPT_ACCESS),\n         ],\n     );\n }"}, {"sha": "9b2f44567053225e81a7b2f6c19d71a0819b0d26", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -12,7 +12,6 @@ pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n-    LateBoundAnon(ty::DebruijnIndex, /* late-bound index */ u32, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n "}, {"sha": "f8792edc017b2d8d3a5da6affae1e10302511dce", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -203,7 +203,7 @@ impl<'tcx> Const<'tcx> {\n     pub fn to_valtree(self) -> ty::ValTree<'tcx> {\n         match self.kind() {\n             ty::ConstKind::Value(valtree) => valtree,\n-            _ => bug!(\"expected ConstKind::Value\"),\n+            _ => bug!(\"expected ConstKind::Value, got {:?}\", self.kind()),\n         }\n     }\n "}, {"sha": "93707bb18ceec4c4f6a0341edea391c07d2f2f68", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -80,31 +80,25 @@ impl<'tcx> ValTree<'tcx> {\n     }\n \n     /// Get the values inside the ValTree as a slice of bytes. This only works for\n-    /// constants with types &str and &[u8].\n+    /// constants with types &str, &[u8], or [u8; _].\n     pub fn try_to_raw_bytes(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<&'tcx [u8]> {\n         match ty.kind() {\n             ty::Ref(_, inner_ty, _) => match inner_ty.kind() {\n-                ty::Str => {\n-                    let leafs = self\n-                        .unwrap_branch()\n-                        .into_iter()\n-                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap());\n-\n-                    return Some(tcx.arena.alloc_from_iter(leafs));\n-                }\n-                ty::Slice(slice_ty) if *slice_ty == tcx.types.u8 => {\n-                    let leafs = self\n-                        .unwrap_branch()\n-                        .into_iter()\n-                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap());\n-\n-                    return Some(tcx.arena.alloc_from_iter(leafs));\n-                }\n-                _ => {}\n+                // `&str` can be interpreted as raw bytes\n+                ty::Str => {}\n+                // `&[u8]` can be interpreted as raw bytes\n+                ty::Slice(slice_ty) if *slice_ty == tcx.types.u8 => {}\n+                // other `&_` can't be interpreted as raw bytes\n+                _ => return None,\n             },\n-            _ => {}\n+            // `[u8; N]` can be interpreted as raw bytes\n+            ty::Array(array_ty, _) if *array_ty == tcx.types.u8 => {}\n+            // Otherwise, type cannot be interpreted as raw bytes\n+            _ => return None,\n         }\n \n-        None\n+        Some(tcx.arena.alloc_from_iter(\n+            self.unwrap_branch().into_iter().map(|v| v.unwrap_leaf().try_to_u8().unwrap()),\n+        ))\n     }\n }"}, {"sha": "7f2e81a71a93d16cd773eeb221339fa8eeca15df", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1452,7 +1452,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n             },\n             (ty::ValTree::Branch(_), ty::Array(t, _)) if *t == u8_type => {\n-                let bytes = valtree.try_to_raw_bytes(self.tcx(), *t).unwrap_or_else(|| {\n+                let bytes = valtree.try_to_raw_bytes(self.tcx(), ty).unwrap_or_else(|| {\n                     bug!(\"expected to convert valtree to raw bytes for type {:?}\", t)\n                 });\n                 p!(\"*\");"}, {"sha": "d6dd0f017941a74aa2a8f84ee5b9eff18412cdcb", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -120,37 +120,35 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty, true).map(\n-            |non_sm_ty| {\n-                with_no_trimmed_paths!(match non_sm_ty.kind {\n-                    traits::NonStructuralMatchTyKind::Adt(adt) => self.adt_derive_msg(adt),\n-                    traits::NonStructuralMatchTyKind::Dynamic => {\n-                        \"trait objects cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Opaque => {\n-                        \"opaque types cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Closure => {\n-                        \"closures cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Generator => {\n-                        \"generators cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Float => {\n-                        \"floating-point numbers cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTyKind::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n-                    }\n-                })\n-            },\n-        )\n+        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n+            with_no_trimmed_paths!(match non_sm_ty.kind() {\n+                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n+                ty::Dynamic(..) => {\n+                    \"trait objects cannot be used in patterns\".to_string()\n+                }\n+                ty::Opaque(..) => {\n+                    \"opaque types cannot be used in patterns\".to_string()\n+                }\n+                ty::Closure(..) => {\n+                    \"closures cannot be used in patterns\".to_string()\n+                }\n+                ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                    \"generators cannot be used in patterns\".to_string()\n+                }\n+                ty::Float(..) => {\n+                    \"floating-point numbers cannot be used in patterns\".to_string()\n+                }\n+                ty::FnPtr(..) => {\n+                    \"function pointers cannot be used in patterns\".to_string()\n+                }\n+                ty::RawPtr(..) => {\n+                    \"raw pointers cannot be used in patterns\".to_string()\n+                }\n+                _ => {\n+                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n+                }\n+            })\n+        })\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "2f02d00ec9fb04854217d352b000d6c4957841d7", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -11,7 +11,7 @@ pub struct LowerSliceLenCalls;\n \n impl<'tcx> MirPass<'tcx> for LowerSliceLenCalls {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.opts.mir_opt_level() > 0\n+        sess.mir_opt_level() > 0\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "4919ad40098cb0f2ae58a211969cca08304d77c5", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -9,7 +9,7 @@ pub struct RevealAll;\n \n impl<'tcx> MirPass<'tcx> for RevealAll {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.opts.mir_opt_level() >= 3 || super::inline::Inline.is_enabled(sess)\n+        sess.mir_opt_level() >= 3 || super::inline::Inline.is_enabled(sess)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "fde12b9eee6b92d0ed4eee7f53f7f758ada4a020", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -121,6 +121,10 @@ impl CheckAttrVisitor<'_> {\n                 sym::rustc_lint_diagnostics => {\n                     self.check_rustc_lint_diagnostics(&attr, span, target)\n                 }\n+                sym::rustc_lint_opt_ty => self.check_rustc_lint_opt_ty(&attr, span, target),\n+                sym::rustc_lint_opt_deny_field_access => {\n+                    self.check_rustc_lint_opt_deny_field_access(&attr, span, target)\n+                }\n                 sym::rustc_clean\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n@@ -1382,6 +1386,35 @@ impl CheckAttrVisitor<'_> {\n         self.check_applied_to_fn_or_method(attr, span, target)\n     }\n \n+    /// Checks that the `#[rustc_lint_opt_ty]` attribute is only applied to a struct.\n+    fn check_rustc_lint_opt_ty(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::Struct => true,\n+            _ => {\n+                self.tcx.sess.emit_err(errors::RustcLintOptTy { attr_span: attr.span, span });\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks that the `#[rustc_lint_opt_deny_field_access]` attribute is only applied to a field.\n+    fn check_rustc_lint_opt_deny_field_access(\n+        &self,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Field => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .emit_err(errors::RustcLintOptDenyFieldAccess { attr_span: attr.span, span });\n+                false\n+            }\n+        }\n+    }\n+\n     /// Checks that the dep-graph debugging attributes are only present when the query-dep-graph\n     /// option is passed to the compiler.\n     fn check_rustc_dirty_clean(&self, attr: &Attribute) -> bool {"}, {"sha": "5feb0e2956b74fa55b24e1b0ee8fb7871a35cb78", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -625,3 +625,21 @@ pub struct UnusedMultiple {\n     pub other: Span,\n     pub name: Symbol,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_lint_opt_ty)]\n+pub struct RustcLintOptTy {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_lint_opt_deny_field_access)]\n+pub struct RustcLintOptDenyFieldAccess {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}"}, {"sha": "ed65100ae77511584e0c70b190c899be0e15d18a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 104, "deletions": 135, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -262,9 +262,6 @@ enum LifetimeRibKind {\n     /// error on default object bounds (e.g., `Box<dyn Foo>`).\n     AnonymousReportError,\n \n-    /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    AnonymousPassThrough(NodeId),\n-\n     /// Replace all anonymous lifetimes by provided lifetime.\n     Elided(LifetimeRes),\n \n@@ -698,14 +695,25 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     },\n                     |this| {\n                         this.visit_generic_params(&bare_fn.generic_params, false);\n-                        this.resolve_fn_signature(\n-                            ty.id,\n-                            None,\n-                            false,\n-                            // We don't need to deal with patterns in parameters, because\n-                            // they are not possible for foreign or bodiless functions.\n-                            bare_fn.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n-                            &bare_fn.decl.output,\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: ty.id,\n+                                report_in_path: false,\n+                            },\n+                            |this| {\n+                                this.resolve_fn_signature(\n+                                    ty.id,\n+                                    false,\n+                                    // We don't need to deal with patterns in parameters, because\n+                                    // they are not possible for foreign or bodiless functions.\n+                                    bare_fn\n+                                        .decl\n+                                        .inputs\n+                                        .iter()\n+                                        .map(|Param { ty, .. }| (None, &**ty)),\n+                                    &bare_fn.decl.output,\n+                                )\n+                            },\n                         );\n                     },\n                 )\n@@ -785,12 +793,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n                 self.visit_fn_header(&sig.header);\n                 self.visit_generics(generics);\n-                self.resolve_fn_signature(\n-                    fn_id,\n-                    None,\n-                    sig.decl.has_self(),\n-                    sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n-                    &sig.decl.output,\n+                self.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousCreateParameter {\n+                        binder: fn_id,\n+                        report_in_path: false,\n+                    },\n+                    |this| {\n+                        this.resolve_fn_signature(\n+                            fn_id,\n+                            sig.decl.has_self(),\n+                            sig.decl.inputs.iter().map(|Param { ty, .. }| (None, &**ty)),\n+                            &sig.decl.output,\n+                        )\n+                    },\n                 );\n                 return;\n             }\n@@ -815,15 +830,22 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let declaration = &sig.decl;\n                         let async_node_id = sig.header.asyncness.opt_return_id();\n \n-                        this.resolve_fn_signature(\n-                            fn_id,\n-                            async_node_id,\n-                            declaration.has_self(),\n-                            declaration\n-                                .inputs\n-                                .iter()\n-                                .map(|Param { pat, ty, .. }| (Some(&**pat), &**ty)),\n-                            &declaration.output,\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: fn_id,\n+                                report_in_path: async_node_id.is_some(),\n+                            },\n+                            |this| {\n+                                this.resolve_fn_signature(\n+                                    fn_id,\n+                                    declaration.has_self(),\n+                                    declaration\n+                                        .inputs\n+                                        .iter()\n+                                        .map(|Param { pat, ty, .. }| (Some(&**pat), &**ty)),\n+                                    &declaration.output,\n+                                )\n+                            },\n                         );\n \n                         // Construct the list of in-scope lifetime parameters for async lowering.\n@@ -868,7 +890,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             let previous_state = replace(&mut this.in_func_body, true);\n                             // Resolve the function body, potentially inside the body of an async closure\n                             this.with_lifetime_rib(\n-                                LifetimeRibKind::AnonymousPassThrough(fn_id),\n+                                LifetimeRibKind::Elided(LifetimeRes::Infer),\n                                 |this| this.visit_block(body),\n                             );\n \n@@ -896,7 +918,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         this.with_lifetime_rib(\n                             match binder {\n                                 ClosureBinder::NotPresent => {\n-                                    LifetimeRibKind::AnonymousPassThrough(fn_id)\n+                                    LifetimeRibKind::Elided(LifetimeRes::Infer)\n                                 }\n                                 ClosureBinder::For { .. } => LifetimeRibKind::AnonymousReportError,\n                             },\n@@ -908,7 +930,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         let previous_state = replace(&mut this.in_func_body, true);\n                         // Resolve the function body, potentially inside the body of an async closure\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(fn_id),\n+                            LifetimeRibKind::Elided(LifetimeRes::Infer),\n                             |this| this.visit_expr(body),\n                         );\n \n@@ -1038,12 +1060,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 kind: LifetimeBinderKind::PolyTrait,\n                                 ..\n                             } => {\n-                                self.resolve_fn_signature(\n-                                    binder,\n-                                    None,\n-                                    false,\n-                                    p_args.inputs.iter().map(|ty| (None, &**ty)),\n-                                    &p_args.output,\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder,\n+                                        report_in_path: false,\n+                                    },\n+                                    |this| {\n+                                        this.resolve_fn_signature(\n+                                            binder,\n+                                            false,\n+                                            p_args.inputs.iter().map(|ty| (None, &**ty)),\n+                                            &p_args.output,\n+                                        )\n+                                    },\n                                 );\n                                 break;\n                             }\n@@ -1053,8 +1082,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 visit::walk_generic_args(self, path_span, args);\n                                 break;\n                             }\n-                            LifetimeRibKind::AnonymousPassThrough(..)\n-                            | LifetimeRibKind::AnonymousCreateParameter { .. }\n+                            LifetimeRibKind::AnonymousCreateParameter { .. }\n                             | LifetimeRibKind::AnonymousReportError\n                             | LifetimeRibKind::Elided(_)\n                             | LifetimeRibKind::ElisionFailure\n@@ -1415,8 +1443,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     | LifetimeRibKind::AnonymousReportError\n                                     | LifetimeRibKind::ElisionFailure => Some(LifetimeUseSet::Many),\n                                     // An anonymous lifetime is legal here, go ahead.\n-                                    LifetimeRibKind::AnonymousPassThrough(_)\n-                                    | LifetimeRibKind::AnonymousCreateParameter { .. } => {\n+                                    LifetimeRibKind::AnonymousCreateParameter { .. } => {\n                                         Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n                                     }\n                                     // Only report if eliding the lifetime would have the same\n@@ -1527,14 +1554,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }\n-                LifetimeRibKind::AnonymousPassThrough(node_id) => {\n-                    self.record_lifetime_res(\n-                        lifetime.id,\n-                        LifetimeRes::Anonymous { binder: node_id, elided },\n-                        elision_candidate,\n-                    );\n-                    return;\n-                }\n                 LifetimeRibKind::Elided(res) => {\n                     self.record_lifetime_res(lifetime.id, res, elision_candidate);\n                     return;\n@@ -1632,6 +1651,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | PathSource::Struct\n                 | PathSource::TupleStruct(..) => false,\n             };\n+            if !missing && !segment.has_generic_args {\n+                continue;\n+            }\n \n             let elided_lifetime_span = if segment.has_generic_args {\n                 // If there are brackets, but not generic arguments, then use the opening bracket\n@@ -1653,37 +1675,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             if !missing {\n                 // Do not create a parameter for patterns and expressions.\n-                for rib in self.lifetime_ribs.iter().rev() {\n-                    match rib.kind {\n-                        LifetimeRibKind::AnonymousPassThrough(binder) => {\n-                            let res = LifetimeRes::Anonymous { binder, elided: true };\n-                            for id in node_ids {\n-                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n-                            }\n-                            break;\n-                        }\n-                        // `LifetimeRes::Error`, which would usually be used in the case of\n-                        // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n-                        // we simply resolve to an implicit lifetime, which will be checked later, at\n-                        // which point a suitable error will be emitted.\n-                        LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n-                            // FIXME(cjgillot) This resolution is wrong, but this does not matter\n-                            // since these cases are erroneous anyway.  Lifetime resolution should\n-                            // emit a \"missing lifetime specifier\" diagnostic.\n-                            let res =\n-                                LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n-                            for id in node_ids {\n-                                self.record_lifetime_res(id, res, LifetimeElisionCandidate::Named);\n-                            }\n-                            break;\n-                        }\n-                        LifetimeRibKind::AnonymousCreateParameter { .. }\n-                        | LifetimeRibKind::Elided(_)\n-                        | LifetimeRibKind::ElisionFailure\n-                        | LifetimeRibKind::Generics { .. }\n-                        | LifetimeRibKind::ConstGeneric\n-                        | LifetimeRibKind::AnonConst => {}\n-                    }\n+                for id in node_ids {\n+                    self.record_lifetime_res(\n+                        id,\n+                        LifetimeRes::Infer,\n+                        LifetimeElisionCandidate::Named,\n+                    );\n                 }\n                 continue;\n             }\n@@ -1750,19 +1747,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         }\n                         break;\n                     }\n-                    // `PassThrough` is the normal case.\n-                    LifetimeRibKind::AnonymousPassThrough(binder) => {\n-                        let res = LifetimeRes::Anonymous { binder, elided: true };\n-                        let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n-                        for id in node_ids {\n-                            self.record_lifetime_res(\n-                                id,\n-                                res,\n-                                replace(&mut candidate, LifetimeElisionCandidate::Ignore),\n-                            );\n-                        }\n-                        break;\n-                    }\n                     LifetimeRibKind::Elided(res) => {\n                         let mut candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n                         for id in node_ids {\n@@ -1837,15 +1821,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )\n         }\n         match res {\n-            LifetimeRes::Param { .. }\n-            | LifetimeRes::Fresh { .. }\n-            | LifetimeRes::Anonymous { .. }\n-            | LifetimeRes::Static => {\n+            LifetimeRes::Param { .. } | LifetimeRes::Fresh { .. } | LifetimeRes::Static => {\n                 if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n                     candidates.insert(res, candidate);\n                 }\n             }\n-            LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n+            LifetimeRes::Infer | LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n         }\n     }\n \n@@ -1864,18 +1845,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_fn_signature(\n         &mut self,\n         fn_id: NodeId,\n-        async_node_id: Option<NodeId>,\n         has_self: bool,\n         inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)> + Clone,\n         output_ty: &'ast FnRetTy,\n     ) {\n         // Add each argument to the rib.\n-        let parameter_rib = LifetimeRibKind::AnonymousCreateParameter {\n-            binder: fn_id,\n-            report_in_path: async_node_id.is_some(),\n-        };\n-        let elision_lifetime =\n-            self.with_lifetime_rib(parameter_rib, |this| this.resolve_fn_params(has_self, inputs));\n+        let elision_lifetime = self.resolve_fn_params(has_self, inputs);\n         debug!(?elision_lifetime);\n \n         let outer_failures = take(&mut self.diagnostic_metadata.current_elision_failures);\n@@ -2268,26 +2243,23 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Static), |this| {\n                         this.visit_ty(ty);\n                     });\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(item.id),\n-                        |this| {\n-                            if let Some(expr) = expr {\n-                                let constant_item_kind = match item.kind {\n-                                    ItemKind::Const(..) => ConstantItemKind::Const,\n-                                    ItemKind::Static(..) => ConstantItemKind::Static,\n-                                    _ => unreachable!(),\n-                                };\n-                                // We already forbid generic params because of the above item rib,\n-                                // so it doesn't matter whether this is a trivial constant.\n-                                this.with_constant_rib(\n-                                    IsRepeatExpr::No,\n-                                    HasGenericParams::Yes,\n-                                    Some((item.ident, constant_item_kind)),\n-                                    |this| this.visit_expr(expr),\n-                                );\n-                            }\n-                        },\n-                    );\n+                    this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                        if let Some(expr) = expr {\n+                            let constant_item_kind = match item.kind {\n+                                ItemKind::Const(..) => ConstantItemKind::Const,\n+                                ItemKind::Static(..) => ConstantItemKind::Static,\n+                                _ => unreachable!(),\n+                            };\n+                            // We already forbid generic params because of the above item rib,\n+                            // so it doesn't matter whether this is a trivial constant.\n+                            this.with_constant_rib(\n+                                IsRepeatExpr::No,\n+                                HasGenericParams::Yes,\n+                                Some((item.ident, constant_item_kind)),\n+                                |this| this.visit_expr(expr),\n+                            );\n+                        }\n+                    });\n                 });\n             }\n \n@@ -2544,7 +2516,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         // Type parameters can already be used and as associated consts are\n                         // not used as part of the type system, this is far less surprising.\n                         self.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(item.id),\n+                            LifetimeRibKind::Elided(LifetimeRes::Infer),\n                             |this| {\n                                 this.with_constant_rib(\n                                     IsRepeatExpr::No,\n@@ -2717,17 +2689,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     // Type parameters can already be used and as associated consts are\n                     // not used as part of the type system, this is far less surprising.\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(item.id),\n-                        |this| {\n-                            this.with_constant_rib(\n-                                IsRepeatExpr::No,\n-                                HasGenericParams::Yes,\n-                                None,\n-                                |this| this.visit_expr(expr),\n-                            )\n-                        },\n-                    );\n+                    self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                        this.with_constant_rib(\n+                            IsRepeatExpr::No,\n+                            HasGenericParams::Yes,\n+                            None,\n+                            |this| this.visit_expr(expr),\n+                        )\n+                    });\n                 }\n             }\n             AssocItemKind::Fn(box Fn { generics, .. }) => {"}, {"sha": "94460e33d8b01a62b8be14afca238e9da2680555", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 56, "deletions": 512, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! Resolution of early vs late bound lifetimes.\n //!\n //! Name resolution for lifetimes is performed on the AST and embedded into HIR.  From this\n@@ -21,10 +20,9 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::borrow::Cow;\n-use std::cell::Cell;\n use std::fmt;\n use std::mem::take;\n \n@@ -33,8 +31,6 @@ trait RegionExt {\n \n     fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n-    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n-\n     fn id(&self) -> Option<DefId>;\n \n     fn shifted(self, amount: u32) -> Region;\n@@ -65,16 +61,9 @@ impl RegionExt for Region {\n         (def_id, Region::LateBound(depth, idx, def_id.to_def_id()))\n     }\n \n-    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n-        let i = index.get();\n-        index.set(i + 1);\n-        let depth = ty::INNERMOST;\n-        Region::LateBoundAnon(depth, named_late_bound_vars + i, i)\n-    }\n-\n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static | Region::LateBoundAnon(..) => None,\n+            Region::Static => None,\n \n             Region::EarlyBound(_, id) | Region::LateBound(_, _, id) | Region::Free(_, id) => {\n                 Some(id)\n@@ -87,9 +76,6 @@ impl RegionExt for Region {\n             Region::LateBound(debruijn, idx, id) => {\n                 Region::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n-            Region::LateBoundAnon(debruijn, index, anon_index) => {\n-                Region::LateBoundAnon(debruijn.shifted_in(amount), index, anon_index)\n-            }\n             _ => self,\n         }\n     }\n@@ -99,9 +85,6 @@ impl RegionExt for Region {\n             Region::LateBound(debruijn, index, id) => {\n                 Region::LateBound(debruijn.shifted_out_to_binder(binder), index, id)\n             }\n-            Region::LateBoundAnon(debruijn, index, anon_index) => {\n-                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index, anon_index)\n-            }\n             _ => self,\n         }\n     }\n@@ -193,10 +176,6 @@ enum Scope<'a> {\n \n         s: ScopeRef<'a>,\n \n-        /// In some cases not allowing late bounds allows us to avoid ICEs.\n-        /// This is almost ways set to true.\n-        allow_late_bound: bool,\n-\n         /// If this binder comes from a where clause, specify how it was created.\n         /// This is used to diagnose inaccessible lifetimes in APIT:\n         /// ```ignore (illustrative)\n@@ -215,9 +194,8 @@ enum Scope<'a> {\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n-    /// on them (e.g., due to ambiguity). For more details, see `Elide`.\n+    /// on them (e.g., due to ambiguity).\n     Elision {\n-        elide: Elide,\n         s: ScopeRef<'a>,\n     },\n \n@@ -273,7 +251,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 opaque_type_parent,\n                 scope_type,\n                 hir_id,\n-                allow_late_bound,\n                 where_bound_origin,\n                 s: _,\n             } => f\n@@ -283,16 +260,13 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n-                .field(\"allow_late_bound\", allow_late_bound)\n                 .field(\"where_bound_origin\", where_bound_origin)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Body { id, s: _ } => {\n                 f.debug_struct(\"Body\").field(\"id\", id).field(\"s\", &\"..\").finish()\n             }\n-            Scope::Elision { elide, s: _ } => {\n-                f.debug_struct(\"Elision\").field(\"elide\", elide).field(\"s\", &\"..\").finish()\n-            }\n+            Scope::Elision { s: _ } => f.debug_struct(\"Elision\").field(\"s\", &\"..\").finish(),\n             Scope::ObjectLifetimeDefault { lifetime, s: _ } => f\n                 .debug_struct(\"ObjectLifetimeDefault\")\n                 .field(\"lifetime\", lifetime)\n@@ -309,21 +283,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-enum Elide {\n-    /// Use a fresh anonymous late-bound lifetime each time, by\n-    /// incrementing the counter to generate sequential indices. All\n-    /// anonymous lifetimes must start *after* named bound vars.\n-    FreshLateAnon(u32, Cell<u32>),\n-    /// Always use this one lifetime.\n-    Exact(Region),\n-    /// Less or more than one lifetime were found, error on unspecified.\n-    Error,\n-    /// Forbid lifetime elision inside of a larger scope where it would be\n-    /// permitted. For example, in let position impl trait.\n-    Forbid,\n-}\n-\n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n@@ -486,9 +445,6 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n             ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n         }\n-        Region::LateBoundAnon(_, _, anon_idx) => {\n-            ty::BoundVariableKind::Region(ty::BrAnon(*anon_idx))\n-        }\n         _ => bug!(\"{:?} is not a late region\", region),\n     }\n }\n@@ -623,7 +579,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 next_early_index,\n                 opaque_type_parent: false,\n                 scope_type: BinderScopeType::Normal,\n-                allow_late_bound: true,\n                 where_bound_origin: None,\n             };\n \n@@ -664,8 +619,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n-                let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n-                self.with(scope, |this| intravisit::walk_item(this, item));\n+                self.with(Scope::Elision { s: self.scope }, |this| {\n+                    intravisit::walk_item(this, item)\n+                });\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 // Opaque types are visited when we visit the\n@@ -741,7 +697,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n-                    allow_late_bound: false,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -794,7 +749,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -819,13 +773,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // `Box<dyn Debug + 'static>`.\n                         self.resolve_object_lifetime_default(lifetime)\n                     }\n-                    LifetimeName::Implicit | LifetimeName::Underscore => {\n+                    LifetimeName::Infer => {\n                         // If the user writes `'_`, we use the *ordinary* elision\n                         // rules. So the `'_` in e.g., `Box<dyn Debug + '_>` will be\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n-                        self.resolve_elided_lifetimes(&[lifetime])\n                     }\n                     LifetimeName::Param(..) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n@@ -860,7 +813,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // position impl Trait\n                         let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |this| {\n-                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            let scope = Scope::Elision { s: this.scope };\n                             this.with(scope, |this| {\n                                 intravisit::walk_item(this, opaque_ty);\n                             })\n@@ -936,7 +889,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index_for_opaque_type();\n                 debug!(?index);\n \n-                let mut elision = None;\n                 let mut lifetimes = FxIndexMap::default();\n                 let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n@@ -945,15 +897,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             lifetimes.insert(def_id, reg);\n-                            if let hir::ParamName::Plain(Ident {\n-                                name: kw::UnderscoreLifetime,\n-                                ..\n-                            }) = param.name\n-                            {\n-                                // Pick the elided lifetime \"definition\" if one exists\n-                                // and use it to make an elision scope.\n-                                elision = Some(reg);\n-                            }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -963,51 +906,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n-                if let Some(elision_region) = elision {\n-                    let scope =\n-                        Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::Binder {\n-                            hir_id: ty.hir_id,\n-                            lifetimes,\n-                            next_early_index,\n-                            s: this.scope,\n-                            opaque_type_parent: false,\n-                            scope_type: BinderScopeType::Normal,\n-                            allow_late_bound: false,\n-                            where_bound_origin: None,\n-                        };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            let scope = Scope::TraitRefBoundary { s: this.scope };\n-                            this.with(scope, |this| {\n-                                for bound in bounds {\n-                                    this.visit_param_bound(bound);\n-                                }\n-                            })\n-                        });\n-                    });\n-                } else {\n-                    let scope = Scope::Binder {\n-                        hir_id: ty.hir_id,\n-                        lifetimes,\n-                        next_early_index,\n-                        s: self.scope,\n-                        opaque_type_parent: false,\n-                        scope_type: BinderScopeType::Normal,\n-                        allow_late_bound: false,\n-                        where_bound_origin: None,\n-                    };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::TraitRefBoundary { s: this.scope };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            for bound in bounds {\n-                                this.visit_param_bound(bound);\n-                            }\n-                        })\n-                    });\n-                }\n+                let scope = Scope::Binder {\n+                    hir_id: ty.hir_id,\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    opaque_type_parent: false,\n+                    scope_type: BinderScopeType::Normal,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| {\n+                        this.visit_generics(generics);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                    })\n+                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1051,7 +967,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: false,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1113,7 +1028,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1135,15 +1049,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.name {\n-            hir::LifetimeName::ImplicitObjectLifetimeDefault\n-            | hir::LifetimeName::Implicit\n-            | hir::LifetimeName::Underscore => self.resolve_elided_lifetimes(&[lifetime_ref]),\n             hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n             hir::LifetimeName::Param(param_def_id, _) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n             // If we've already reported an error, just ignore `lifetime_ref`.\n             hir::LifetimeName::Error => {}\n+            // Those will be resolved by typechecking.\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Infer => {}\n         }\n     }\n \n@@ -1156,12 +1069,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'tcx>,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        _: Span,\n+        _: hir::HirId,\n+    ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n             hir::FnRetTy::Return(ref ty) => Some(&**ty),\n         };\n-        self.visit_fn_like_elision(&fd.inputs, output);\n+        self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n+        intravisit::walk_fn_kind(self, fk);\n+        self.visit_nested_body(body_id)\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n@@ -1219,7 +1141,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n-                            allow_late_bound: true,\n                             where_bound_origin: Some(origin),\n                         };\n                         this.with(scope, |this| {\n@@ -1292,7 +1213,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: self.next_early_index(),\n                     opaque_type_parent: false,\n                     scope_type,\n-                    allow_late_bound: true,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -1343,7 +1263,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             next_early_index,\n             opaque_type_parent: false,\n             scope_type,\n-            allow_late_bound: true,\n             where_bound_origin: None,\n         };\n         self.with(scope, |this| {\n@@ -1597,7 +1516,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n-            allow_late_bound: true,\n             where_bound_origin: None,\n         };\n         self.with(scope, walk);\n@@ -1773,30 +1691,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n \n         if generic_args.parenthesized {\n-            self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n+            self.visit_fn_like_elision(\n+                generic_args.inputs(),\n+                Some(generic_args.bindings[0].ty()),\n+                false,\n+            );\n             return;\n         }\n \n-        let mut elide_lifetimes = true;\n-        let lifetimes: Vec<_> = generic_args\n-            .args\n-            .iter()\n-            .filter_map(|arg| match arg {\n-                hir::GenericArg::Lifetime(lt) => {\n-                    if !lt.is_elided() {\n-                        elide_lifetimes = false;\n-                    }\n-                    Some(lt)\n-                }\n-                _ => None,\n-            })\n-            .collect();\n-        // We short-circuit here if all are elided in order to pluralize\n-        // possible errors\n-        if elide_lifetimes {\n-            self.resolve_elided_lifetimes(&lifetimes);\n-        } else {\n-            lifetimes.iter().for_each(|lt| self.visit_lifetime(lt));\n+        for arg in generic_args.args {\n+            if let hir::GenericArg::Lifetime(lt) = arg {\n+                self.visit_lifetime(lt);\n+            }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -2052,380 +1958,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n+        in_closure: bool,\n     ) {\n-        debug!(\"visit_fn_like_elision: enter\");\n-        let mut scope = &*self.scope;\n-        let hir_id = loop {\n-            match scope {\n-                Scope::Binder { hir_id, allow_late_bound: true, .. } => {\n-                    break *hir_id;\n-                }\n-                Scope::ObjectLifetimeDefault { ref s, .. }\n-                | Scope::Elision { ref s, .. }\n-                | Scope::Supertrait { ref s, .. }\n-                | Scope::TraitRefBoundary { ref s, .. } => {\n-                    scope = *s;\n-                }\n-                Scope::Root\n-                | Scope::Body { .. }\n-                | Scope::Binder { allow_late_bound: false, .. } => {\n-                    // See issues #83907 and #83693. Just bail out from looking inside.\n-                    // See the issue #95023 for not allowing late bound\n-                    self.tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n-                        \"In fn_like_elision without appropriate scope above\",\n-                    );\n-                    return;\n-                }\n-            }\n-        };\n-        // While not strictly necessary, we gather anon lifetimes *before* actually\n-        // visiting the argument types.\n-        let mut gather = GatherAnonLifetimes { anon_count: 0 };\n-        for input in inputs {\n-            gather.visit_ty(input);\n-        }\n-        trace!(?gather.anon_count);\n-        let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n-        let named_late_bound_vars = late_bound_vars.len() as u32;\n-        late_bound_vars.extend(\n-            (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n-        );\n-        let arg_scope = Scope::Elision {\n-            elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n-            s: self.scope,\n-        };\n-        self.with(arg_scope, |this| {\n+        self.with(Scope::Elision { s: self.scope }, |this| {\n             for input in inputs {\n                 this.visit_ty(input);\n             }\n-        });\n-\n-        let Some(output) = output else { return };\n-\n-        debug!(\"determine output\");\n-\n-        // Figure out if there's a body we can get argument names from,\n-        // and whether there's a `self` argument (treated specially).\n-        let mut assoc_item_kind = None;\n-        let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node(output.hir_id);\n-        match self.tcx.hir().get(parent) {\n-            // `fn` definitions and methods.\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. }) => {}\n-\n-            Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. }) => {\n-                if let hir::ItemKind::Trait(.., ref trait_items) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    assoc_item_kind =\n-                        trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n-                }\n-            }\n-\n-            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, _), .. }) => {\n-                if let hir::ItemKind::Impl(hir::Impl { ref self_ty, ref items, .. }) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    impl_self = Some(self_ty);\n-                    assoc_item_kind =\n-                        items.iter().find(|ii| ii.id.hir_id() == parent).map(|ii| ii.kind);\n-                }\n-            }\n-\n-            // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => {},\n-\n-            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => {},\n-\n-            // Everything else (only closures?) doesn't\n-            // actually enjoy elision in return types.\n-            _ => {\n-                self.visit_ty(output);\n-                return;\n-            }\n-        };\n-\n-        let has_self = match assoc_item_kind {\n-            Some(hir::AssocItemKind::Fn { has_self }) => has_self,\n-            _ => false,\n-        };\n-\n-        // In accordance with the rules for lifetime elision, we can determine\n-        // what region to use for elision in the output type in two ways.\n-        // First (determined here), if `self` is by-reference, then the\n-        // implied output region is the region of the self parameter.\n-        if has_self {\n-            struct SelfVisitor<'a> {\n-                map: &'a NamedRegionMap,\n-                impl_self: Option<&'a hir::TyKind<'a>>,\n-                lifetime: Set1<Region>,\n-            }\n-\n-            impl SelfVisitor<'_> {\n-                // Look for `self: &'a Self` - also desugared from `&'a self`,\n-                // and if that matches, use it for elision and return early.\n-                fn is_self_ty(&self, res: Res) -> bool {\n-                    if let Res::SelfTy { .. } = res {\n-                        return true;\n-                    }\n-\n-                    // Can't always rely on literal (or implied) `Self` due\n-                    // to the way elision rules were originally specified.\n-                    if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) =\n-                        self.impl_self\n-                    {\n-                        match path.res {\n-                            // Permit the types that unambiguously always\n-                            // result in the same type constructor being used\n-                            // (it can't differ between `Self` and `self`).\n-                            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum, _)\n-                            | Res::PrimTy(_) => return res == path.res,\n-                            _ => {}\n-                        }\n-                    }\n-\n-                    false\n-                }\n-            }\n-\n-            impl<'a> Visitor<'a> for SelfVisitor<'a> {\n-                fn visit_ty(&mut self, ty: &'a hir::Ty<'a>) {\n-                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n-                        {\n-                            if self.is_self_ty(path.res) {\n-                                if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                                    self.lifetime.insert(*lifetime);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    intravisit::walk_ty(self, ty)\n-                }\n-            }\n-\n-            let mut visitor = SelfVisitor {\n-                map: self.map,\n-                impl_self: impl_self.map(|ty| &ty.kind),\n-                lifetime: Set1::Empty,\n-            };\n-            visitor.visit_ty(&inputs[0]);\n-            if let Set1::One(lifetime) = visitor.lifetime {\n-                let scope = Scope::Elision { elide: Elide::Exact(lifetime), s: self.scope };\n-                self.with(scope, |this| this.visit_ty(output));\n-                return;\n+            if !in_closure && let Some(output) = output {\n+                this.visit_ty(output);\n             }\n-        }\n-\n-        // Second, if there was exactly one lifetime (either a substitution or a\n-        // reference) in the arguments, then any anonymous regions in the output\n-        // have that lifetime.\n-        let mut possible_implied_output_region = None;\n-        let mut lifetime_count = 0;\n-        for input in inputs.iter().skip(has_self as usize) {\n-            let mut gather = GatherLifetimes {\n-                map: self.map,\n-                outer_index: ty::INNERMOST,\n-                have_bound_regions: false,\n-                lifetimes: Default::default(),\n-            };\n-            gather.visit_ty(input);\n-\n-            lifetime_count += gather.lifetimes.len();\n-\n-            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-            }\n-        }\n-\n-        let elide = if lifetime_count == 1 {\n-            Elide::Exact(possible_implied_output_region.unwrap())\n-        } else {\n-            Elide::Error\n-        };\n-\n-        debug!(?elide);\n-\n-        let scope = Scope::Elision { elide, s: self.scope };\n-        self.with(scope, |this| this.visit_ty(output));\n-\n-        struct GatherLifetimes<'a> {\n-            map: &'a NamedRegionMap,\n-            outer_index: ty::DebruijnIndex,\n-            have_bound_regions: bool,\n-            lifetimes: FxHashSet<Region>,\n-        }\n-\n-        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_in(1);\n-                }\n-                match ty.kind {\n-                    hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                        for bound in bounds {\n-                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                        }\n-\n-                        // Stay on the safe side and don't include the object\n-                        // lifetime default (which may not end up being used).\n-                        if !lifetime.is_elided() {\n-                            self.visit_lifetime(lifetime);\n-                        }\n-                    }\n-                    _ => {\n-                        intravisit::walk_ty(self, ty);\n-                    }\n-                }\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_out(1);\n-                }\n-            }\n-\n-            fn visit_generic_param(&mut self, param: &hir::GenericParam<'_>) {\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // FIXME(eddyb) Do we want this? It only makes a difference\n-                    // if this `for<'a>` lifetime parameter is never used.\n-                    self.have_bound_regions = true;\n-                }\n-\n-                intravisit::walk_generic_param(self, param);\n-            }\n-\n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &hir::PolyTraitRef<'_>,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                self.outer_index.shift_in(1);\n-                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.outer_index.shift_out(1);\n-            }\n-\n-            fn visit_param_bound(&mut self, bound: &hir::GenericBound<'_>) {\n-                if let hir::GenericBound::LangItemTrait { .. } = bound {\n-                    self.outer_index.shift_in(1);\n-                    intravisit::walk_param_bound(self, bound);\n-                    self.outer_index.shift_out(1);\n-                } else {\n-                    intravisit::walk_param_bound(self, bound);\n-                }\n-            }\n-\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                    match lifetime {\n-                        Region::LateBound(debruijn, _, _)\n-                        | Region::LateBoundAnon(debruijn, _, _)\n-                            if debruijn < self.outer_index =>\n-                        {\n-                            self.have_bound_regions = true;\n-                        }\n-                        _ => {\n-                            // FIXME(jackh726): nested trait refs?\n-                            self.lifetimes.insert(lifetime.shifted_out_to_binder(self.outer_index));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        struct GatherAnonLifetimes {\n-            anon_count: u32,\n-        }\n-        impl<'v> Visitor<'v> for GatherAnonLifetimes {\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                // If we enter a `BareFn`, then we enter a *new* binding scope\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    return;\n-                }\n-                intravisit::walk_ty(self, ty);\n-            }\n-\n-            fn visit_generic_args(\n-                &mut self,\n-                path_span: Span,\n-                generic_args: &'v hir::GenericArgs<'v>,\n-            ) {\n-                // parenthesized args enter a new elision scope\n-                if generic_args.parenthesized {\n-                    return;\n-                }\n-                intravisit::walk_generic_args(self, path_span, generic_args)\n-            }\n-\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if lifetime_ref.is_elided() {\n-                    self.anon_count += 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[&'tcx hir::Lifetime]) {\n-        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n-\n-        if lifetime_refs.is_empty() {\n-            return;\n-        }\n-\n-        let mut late_depth = 0;\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                // Do not assign any resolution, it will be inferred.\n-                Scope::Body { .. } => return,\n-\n-                Scope::Root => break,\n-\n-                Scope::Binder { s, scope_type, .. } => {\n-                    match scope_type {\n-                        BinderScopeType::Normal => late_depth += 1,\n-                        BinderScopeType::Concatenating => {}\n-                    }\n-                    scope = s;\n-                }\n-\n-                Scope::Elision {\n-                    elide: Elide::FreshLateAnon(named_late_bound_vars, ref counter),\n-                    ..\n-                } => {\n-                    for lifetime_ref in lifetime_refs {\n-                        let lifetime =\n-                            Region::late_anon(named_late_bound_vars, counter).shifted(late_depth);\n-\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Exact(l), .. } => {\n-                    let lifetime = l.shifted(late_depth);\n-                    for lifetime_ref in lifetime_refs {\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Error, .. }\n-                | Scope::Elision { elide: Elide::Forbid, .. } => break,\n-\n-                Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n-                    scope = s;\n-                }\n-            }\n-        }\n-\n-        for lt in lifetime_refs {\n-            self.tcx.sess.delay_span_bug(lt.span, \"Missing lifetime specifier\");\n+        });\n+        if in_closure && let Some(output) = output {\n+            self.visit_ty(output);\n         }\n     }\n "}, {"sha": "fe9ef6045415e332632fa39f7384018255cfc1b9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -948,6 +948,8 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     if sess.opts.debug_assertions {\n         ret.insert((sym::debug_assertions, None));\n     }\n+    // JUSTIFICATION: before wrapper fn is available\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     if sess.opts.crate_types.contains(&CrateType::ProcMacro) {\n         ret.insert((sym::proc_macro, None));\n     }\n@@ -2196,6 +2198,8 @@ fn parse_remap_path_prefix(\n     mapping\n }\n \n+// JUSTIFICATION: before wrapper fn is available\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let color = parse_color(matches);\n "}, {"sha": "501997679f4bf40858bfe05473b0fe81023747cb", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -102,28 +102,6 @@ macro_rules! top_level_options {\n     );\n }\n \n-impl Options {\n-    pub fn mir_opt_level(&self) -> usize {\n-        self.unstable_opts\n-            .mir_opt_level\n-            .unwrap_or_else(|| if self.optimize != OptLevel::No { 2 } else { 1 })\n-    }\n-\n-    pub fn instrument_coverage(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off) != InstrumentCoverage::Off\n-    }\n-\n-    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n-            == InstrumentCoverage::ExceptUnusedGenerics\n-    }\n-\n-    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n-        self.cg.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n-            == InstrumentCoverage::ExceptUnusedFunctions\n-    }\n-}\n-\n top_level_options!(\n     /// The top-level command-line options struct.\n     ///\n@@ -149,9 +127,11 @@ top_level_options!(\n     /// `CodegenOptions`, think about how it influences incremental compilation. If in\n     /// doubt, specify `[TRACKED]`, which is always \"correct\" but might lead to\n     /// unnecessary re-compilation.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_ty)]\n     pub struct Options {\n         /// The crate config requested for the session, which may be combined\n         /// with additional crate configurations during the compile process.\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::crate_types` instead of this field\"))]\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n         /// Include the `debug_assertions` flag in dependency tracking, since it\n@@ -198,7 +178,9 @@ top_level_options!(\n         /// what rustc was invoked with, but massaged a bit to agree with\n         /// commands like `--emit llvm-ir` which they're often incompatible with\n         /// if we otherwise use the defaults of rustc.\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::codegen_units` instead of this field\"))]\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n+        #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n         /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n@@ -249,11 +231,12 @@ macro_rules! options {\n      ),* ,) =>\n (\n     #[derive(Clone)]\n-    pub struct $struct_name { $(pub $opt: $t),* }\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_ty)]\n+    pub struct $struct_name { $( $( #[$attr] )* pub $opt: $t),* }\n \n     impl Default for $struct_name {\n         fn default() -> $struct_name {\n-            $struct_name { $( $( #[$attr] )* $opt: $init),* }\n+            $struct_name { $($opt: $init),* }\n         }\n     }\n \n@@ -297,6 +280,22 @@ macro_rules! options {\n \n ) }\n \n+impl Options {\n+    // JUSTIFICATION: defn of the suggested wrapper fn\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+    pub fn time_passes(&self) -> bool {\n+        self.unstable_opts.time_passes || self.unstable_opts.time\n+    }\n+}\n+\n+impl CodegenOptions {\n+    // JUSTIFICATION: defn of the suggested wrapper fn\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+    pub fn instrument_coverage(&self) -> InstrumentCoverage {\n+        self.instrument_coverage.unwrap_or(InstrumentCoverage::Off)\n+    }\n+}\n+\n // Sometimes different options need to build a common structure.\n // That structure can be kept in one of the options' fields, the others become dummy.\n macro_rules! redirect_field {\n@@ -1076,6 +1075,7 @@ options! {\n \n     ar: String = (String::new(), parse_string, [UNTRACKED],\n         \"this option is deprecated and does nothing\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::code_model` instead of this field\"))]\n     code_model: Option<CodeModel> = (None, parse_code_model, [TRACKED],\n         \"choose the code model to use (`rustc --print code-models` for details)\"),\n     codegen_units: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n@@ -1095,12 +1095,14 @@ options! {\n         \"extra data to put in each output filename\"),\n     force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"force use of the frame pointers\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::must_emit_unwind_tables` instead of this field\"))]\n     force_unwind_tables: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"force use of unwind tables\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"enable incremental compilation\"),\n     inline_threshold: Option<u32> = (None, parse_opt_number, [TRACKED],\n         \"set the threshold for inlining a function\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_coverage` instead of this field\"))]\n     instrument_coverage: Option<InstrumentCoverage> = (None, parse_instrument_coverage, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`); \\\n@@ -1113,6 +1115,7 @@ options! {\n         \"a single extra argument to append to the linker invocation (can be used several times)\"),\n     link_args: Vec<String> = (Vec::new(), parse_list, [UNTRACKED],\n         \"extra arguments to append to the linker invocation (space separated)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::link_dead_code` instead of this field\"))]\n     link_dead_code: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"keep dead code at link time (useful for code coverage) (default: no)\"),\n     link_self_contained: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n@@ -1127,6 +1130,7 @@ options! {\n         \"generate build artifacts that are compatible with linker-based LTO\"),\n     llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n         \"a list of arguments to pass to LLVM (space separated)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n     lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n     metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n@@ -1143,8 +1147,10 @@ options! {\n         \"disable LLVM's SLP vectorization pass\"),\n     opt_level: String = (\"0\".to_string(), parse_string, [TRACKED],\n         \"optimization level (0-3, s, or z; default: 0)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::overflow_checks` instead of this field\"))]\n     overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use overflow checks for integer arithmetic\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::panic_strategy` instead of this field\"))]\n     panic: Option<PanicStrategy> = (None, parse_opt_panic_strategy, [TRACKED],\n         \"panic strategy to compile crate with\"),\n     passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n@@ -1156,6 +1162,7 @@ options! {\n         \"compile the program with profiling instrumentation\"),\n     profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n         \"use the given `.profdata` file for profile-guided optimization\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::relocation_model` instead of this field\"))]\n     relocation_model: Option<RelocModel> = (None, parse_relocation_model, [TRACKED],\n         \"control generation of position-independent code (PIC) \\\n         (`rustc --print relocation-models` for details)\"),\n@@ -1167,6 +1174,7 @@ options! {\n         \"save all temporary output files during compilation (default: no)\"),\n     soft_float: bool = (false, parse_bool, [TRACKED],\n         \"use soft float ABI (*eabihf targets only) (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::split_debuginfo` instead of this field\"))]\n     split_debuginfo: Option<SplitDebuginfo> = (None, parse_split_debuginfo, [TRACKED],\n         \"how to handle split-debuginfo, a platform-specific option\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n@@ -1202,11 +1210,13 @@ options! {\n         \"encode MIR of all functions into the crate metadata (default: no)\"),\n     assume_incomplete_release: bool = (false, parse_bool, [TRACKED],\n         \"make cfg(version) treat the current version as incomplete (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::asm_comments` instead of this field\"))]\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior) (default: no)\"),\n     assert_incr_state: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"assert that the incremental cache is in given state: \\\n          either `loaded` or `not-loaded`.\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::binary_dep_depinfo` instead of this field\"))]\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n         (default: no)\"),\n@@ -1284,6 +1294,7 @@ options! {\n         \"emit the bc module with thin LTO info (default: yes)\"),\n     export_executable_symbols: bool = (false, parse_bool, [TRACKED],\n         \"export symbols from executables, as if they were dynamic libraries\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::fewer_names` instead of this field\"))]\n     fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) \\\n         (default: no)\"),\n@@ -1326,6 +1337,7 @@ options! {\n         \"control whether `#[inline]` functions are in all CGUs\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_coverage` instead of this field\"))]\n     instrument_coverage: Option<InstrumentCoverage> = (None, parse_instrument_coverage, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`); \\\n@@ -1334,6 +1346,7 @@ options! {\n         `=except-unused-generics`\n         `=except-unused-functions`\n         `=off` (default)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::instrument_mcount` instead of this field\"))]\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n@@ -1356,6 +1369,7 @@ options! {\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking \\\n         the same values as the target option of the same name\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::meta_stats` instead of this field\"))]\n     meta_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather metadata statistics (default: no)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n@@ -1365,6 +1379,7 @@ options! {\n         \"use like `-Zmir-enable-passes=+DestProp,-InstCombine`. Forces the specified passes to be \\\n         enabled, overriding all other checks. Passes that are not specified are enabled or \\\n         disabled by other flags as usual.\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::mir_opt_level` instead of this field\"))]\n     mir_opt_level: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"MIR optimization level (0-4; default: 1 in non optimized builds and 2 in optimized builds)\"),\n     move_size_limit: Option<usize> = (None, parse_opt_number, [TRACKED],\n@@ -1431,6 +1446,7 @@ options! {\n         See #77382 and #74551.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make rustc print the total optimization fuel used by a crate\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::print_llvm_passes` instead of this field\"))]\n     print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"print the LLVM optimization passes being run (default: no)\"),\n     print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1505,6 +1521,7 @@ options! {\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::stack_protector` instead of this field\"))]\n     stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n     strict_init_checks: bool = (false, parse_bool, [TRACKED],\n@@ -1525,6 +1542,7 @@ options! {\n     symbol_mangling_version: Option<SymbolManglingVersion> = (None,\n         parse_symbol_mangling_version, [TRACKED],\n         \"which mangling version to use for symbol names ('legacy' (default) or 'v0')\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::teach` instead of this field\"))]\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help (default: no)\"),\n     temps_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -1540,6 +1558,7 @@ options! {\n         \"emit directionality isolation markers in translated diagnostics\"),\n     tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::lto` instead of this field\"))]\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     thir_unsafeck: bool = (false, parse_bool, [TRACKED],\n@@ -1548,14 +1567,19 @@ options! {\n     /// a sequential compiler for now. This'll likely be adjusted\n     /// in the future. Note that -Zthreads=0 is the way to get\n     /// the num_cpus behavior.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::threads` instead of this field\"))]\n     threads: usize = (1, parse_threads, [UNTRACKED],\n         \"use a thread pool with N threads\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_passes` instead of this field\"))]\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_llvm_passes` instead of this field\"))]\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each LLVM pass (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::time_passes` instead of this field\"))]\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::tls_model` instead of this field\"))]\n     tls_model: Option<TlsModel> = (None, parse_tls_model, [TRACKED],\n         \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n@@ -1590,14 +1614,17 @@ options! {\n         \"enable unsound and buggy MIR optimizations (default: no)\"),\n     /// This name is kind of confusing: Most unstable options enable something themselves, while\n     /// this just allows \"normal\" options to be feature-gated.\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::unstable_options` instead of this field\"))]\n     unstable_options: bool = (false, parse_bool, [UNTRACKED],\n         \"adds unstable command line options to rustc interface (default: no)\"),\n     use_ctors_section: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"use legacy .ctors section for initializers rather than .init_array\"),\n     validate_mir: bool = (false, parse_bool, [UNTRACKED],\n         \"validate MIR after each transformation\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::verbose` instead of this field\"))]\n     verbose: bool = (false, parse_bool, [UNTRACKED],\n         \"in general, enable more debug printouts (default: no)\"),\n+    #[cfg_attr(not(bootstrap), rustc_lint_opt_deny_field_access(\"use `Session::verify_llvm_ir` instead of this field\"))]\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n         \"verify LLVM IR (default: no)\"),\n     virtual_function_elimination: bool = (false, parse_bool, [TRACKED],"}, {"sha": "9669287b3f37075f26563c344d84b005d3973d25", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 350, "deletions": 315, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,7 +1,7 @@\n use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n-use crate::config::{self, CrateType, OutputType, SwitchWithOptPath};\n+use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -583,50 +583,356 @@ impl Session {\n     pub fn source_map(&self) -> &SourceMap {\n         self.parse_sess.source_map()\n     }\n+\n+    pub fn time_passes(&self) -> bool {\n+        self.opts.time_passes()\n+    }\n+\n+    /// Returns `true` if internal lints should be added to the lint store - i.e. if\n+    /// `-Zunstable-options` is provided and this isn't rustdoc (internal lints can trigger errors\n+    /// to be emitted under rustdoc).\n+    pub fn enable_internal_lints(&self) -> bool {\n+        self.unstable_options() && !self.opts.actually_rustdoc\n+    }\n+\n+    pub fn instrument_coverage(&self) -> bool {\n+        self.opts.cg.instrument_coverage() != InstrumentCoverage::Off\n+    }\n+\n+    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n+        self.opts.cg.instrument_coverage() == InstrumentCoverage::ExceptUnusedGenerics\n+    }\n+\n+    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n+        self.opts.cg.instrument_coverage() == InstrumentCoverage::ExceptUnusedFunctions\n+    }\n+\n+    /// Gets the features enabled for the current compilation session.\n+    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n+    /// dependency tracking. Use tcx.features() instead.\n+    #[inline]\n+    pub fn features_untracked(&self) -> &rustc_feature::Features {\n+        self.features.get().unwrap()\n+    }\n+\n+    pub fn init_features(&self, features: rustc_feature::Features) {\n+        match self.features.set(features) {\n+            Ok(()) => {}\n+            Err(_) => panic!(\"`features` was initialized twice\"),\n+        }\n+    }\n+\n+    pub fn is_sanitizer_cfi_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n+    }\n+\n+    /// Check whether this compile session and crate type use static crt.\n+    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n+        if !self.target.crt_static_respected {\n+            // If the target does not opt in to crt-static support, use its default.\n+            return self.target.crt_static_default;\n+        }\n+\n+        let requested_features = self.opts.cg.target_feature.split(',');\n+        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n+        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n+\n+        // JUSTIFICATION: necessary use of crate_types directly (see FIXME below)\n+        #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+        if found_positive || found_negative {\n+            found_positive\n+        } else if crate_type == Some(CrateType::ProcMacro)\n+            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n+        {\n+            // FIXME: When crate_type is not available,\n+            // we use compiler options to determine the crate_type.\n+            // We can't check `#![crate_type = \"proc-macro\"]` here.\n+            false\n+        } else {\n+            self.target.crt_static_default\n+        }\n+    }\n+\n+    pub fn is_wasi_reactor(&self) -> bool {\n+        self.target.options.os == \"wasi\"\n+            && matches!(\n+                self.opts.unstable_opts.wasi_exec_model,\n+                Some(config::WasiExecModel::Reactor)\n+            )\n+    }\n+\n+    pub fn target_can_use_split_dwarf(&self) -> bool {\n+        !self.target.is_like_windows && !self.target.is_like_osx\n+    }\n+\n+    pub fn generate_proc_macro_decls_symbol(&self, stable_crate_id: StableCrateId) -> String {\n+        format!(\"__rustc_proc_macro_decls_{:08x}__\", stable_crate_id.to_u64())\n+    }\n+\n+    pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n+        filesearch::FileSearch::new(\n+            &self.sysroot,\n+            self.opts.target_triple.triple(),\n+            &self.opts.search_paths,\n+            &self.target_tlib_path,\n+            kind,\n+        )\n+    }\n+    pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n+        filesearch::FileSearch::new(\n+            &self.sysroot,\n+            config::host_triple(),\n+            &self.opts.search_paths,\n+            &self.host_tlib_path,\n+            kind,\n+        )\n+    }\n+\n+    /// Returns a list of directories where target-specific tool binaries are located.\n+    pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n+        let rustlib_path = rustc_target::target_rustlib_path(&self.sysroot, &config::host_triple());\n+        let p = PathBuf::from_iter([\n+            Path::new(&self.sysroot),\n+            Path::new(&rustlib_path),\n+            Path::new(\"bin\"),\n+        ]);\n+        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n+    }\n+\n+    pub fn init_incr_comp_session(\n+        &self,\n+        session_dir: PathBuf,\n+        lock_file: flock::Lock,\n+        load_dep_graph: bool,\n+    ) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        if let IncrCompSession::NotInitialized = *incr_comp_session {\n+        } else {\n+            panic!(\"Trying to initialize IncrCompSession `{:?}`\", *incr_comp_session)\n+        }\n+\n+        *incr_comp_session =\n+            IncrCompSession::Active { session_directory: session_dir, lock_file, load_dep_graph };\n+    }\n+\n+    pub fn finalize_incr_comp_session(&self, new_directory_path: PathBuf) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        if let IncrCompSession::Active { .. } = *incr_comp_session {\n+        } else {\n+            panic!(\"trying to finalize `IncrCompSession` `{:?}`\", *incr_comp_session);\n+        }\n+\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::Finalized { session_directory: new_directory_path };\n+    }\n+\n+    pub fn mark_incr_comp_session_as_invalid(&self) {\n+        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n+\n+        let session_directory = match *incr_comp_session {\n+            IncrCompSession::Active { ref session_directory, .. } => session_directory.clone(),\n+            IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n+            _ => panic!(\"trying to invalidate `IncrCompSession` `{:?}`\", *incr_comp_session),\n+        };\n+\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n+    }\n+\n+    pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n+        let incr_comp_session = self.incr_comp_session.borrow();\n+        cell::Ref::map(incr_comp_session, |incr_comp_session| match *incr_comp_session {\n+            IncrCompSession::NotInitialized => panic!(\n+                \"trying to get session directory from `IncrCompSession`: {:?}\",\n+                *incr_comp_session,\n+            ),\n+            IncrCompSession::Active { ref session_directory, .. }\n+            | IncrCompSession::Finalized { ref session_directory }\n+            | IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n+                session_directory\n+            }\n+        })\n+    }\n+\n+    pub fn incr_comp_session_dir_opt(&self) -> Option<cell::Ref<'_, PathBuf>> {\n+        self.opts.incremental.as_ref().map(|_| self.incr_comp_session_dir())\n+    }\n+\n+    pub fn print_perf_stats(&self) {\n+        eprintln!(\n+            \"Total time spent computing symbol hashes:      {}\",\n+            duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n+        );\n+        eprintln!(\n+            \"Total queries canonicalized:                   {}\",\n+            self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n+        );\n+        eprintln!(\n+            \"normalize_generic_arg_after_erasing_regions:   {}\",\n+            self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n+        );\n+        eprintln!(\n+            \"normalize_projection_ty:                       {}\",\n+            self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed)\n+        );\n+    }\n+\n+    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n+    /// This expends fuel if applicable, and records fuel if applicable.\n+    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+        let mut ret = true;\n+        if let Some((ref c, _)) = self.opts.unstable_opts.fuel {\n+            if c == crate_name {\n+                assert_eq!(self.threads(), 1);\n+                let mut fuel = self.optimization_fuel.lock();\n+                ret = fuel.remaining != 0;\n+                if fuel.remaining == 0 && !fuel.out_of_fuel {\n+                    if self.diagnostic().can_emit_warnings() {\n+                        // We only call `msg` in case we can actually emit warnings.\n+                        // Otherwise, this could cause a `delay_good_path_bug` to\n+                        // trigger (issue #79546).\n+                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n+                    }\n+                    fuel.out_of_fuel = true;\n+                } else if fuel.remaining > 0 {\n+                    fuel.remaining -= 1;\n+                }\n+            }\n+        }\n+        if let Some(ref c) = self.opts.unstable_opts.print_fuel {\n+            if c == crate_name {\n+                assert_eq!(self.threads(), 1);\n+                self.print_fuel.fetch_add(1, SeqCst);\n+            }\n+        }\n+        ret\n+    }\n+\n+    pub fn rust_2015(&self) -> bool {\n+        self.edition() == Edition::Edition2015\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2018 edition?\n+    pub fn rust_2018(&self) -> bool {\n+        self.edition() >= Edition::Edition2018\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2021 edition?\n+    pub fn rust_2021(&self) -> bool {\n+        self.edition() >= Edition::Edition2021\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2024 edition?\n+    pub fn rust_2024(&self) -> bool {\n+        self.edition() >= Edition::Edition2024\n+    }\n+\n+    /// Returns `true` if we cannot skip the PLT for shared library calls.\n+    pub fn needs_plt(&self) -> bool {\n+        // Check if the current target usually needs PLT to be enabled.\n+        // The user can use the command line flag to override it.\n+        let needs_plt = self.target.needs_plt;\n+\n+        let dbg_opts = &self.opts.unstable_opts;\n+\n+        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.relro_level);\n+\n+        // Only enable this optimization by default if full relro is also enabled.\n+        // In this case, lazy binding was already unavailable, so nothing is lost.\n+        // This also ensures `-Wl,-z,now` is supported by the linker.\n+        let full_relro = RelroLevel::Full == relro_level;\n+\n+        // If user didn't explicitly forced us to use / skip the PLT,\n+        // then try to skip it where possible.\n+        dbg_opts.plt.unwrap_or(needs_plt || !full_relro)\n+    }\n+\n+    /// Checks if LLVM lifetime markers should be emitted.\n+    pub fn emit_lifetime_markers(&self) -> bool {\n+        self.opts.optimize != config::OptLevel::No\n+        // AddressSanitizer uses lifetimes to detect use after scope bugs.\n+        // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n+        // HWAddressSanitizer will use lifetimes to detect use after scope bugs in the future.\n+        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n+    }\n+\n+    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| attr.has_name(*kind))\n+    }\n+\n+    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n+        attrs.iter().any(|item| item.has_name(name))\n+    }\n+\n+    pub fn find_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> Option<&'a Attribute> {\n+        attrs.iter().find(|attr| attr.has_name(name))\n+    }\n+\n+    pub fn filter_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> impl Iterator<Item = &'a Attribute> {\n+        attrs.iter().filter(move |attr| attr.has_name(name))\n+    }\n+\n+    pub fn first_attr_value_str_by_name(\n+        &self,\n+        attrs: &[Attribute],\n+        name: Symbol,\n+    ) -> Option<Symbol> {\n+        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n+    }\n+}\n+\n+// JUSTIFICATION: defn of the suggested wrapper fns\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n+impl Session {\n     pub fn verbose(&self) -> bool {\n         self.opts.unstable_opts.verbose\n     }\n-    pub fn time_passes(&self) -> bool {\n-        self.opts.unstable_opts.time_passes || self.opts.unstable_opts.time\n-    }\n+\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.unstable_opts.instrument_mcount\n     }\n+\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.unstable_opts.time_llvm_passes\n     }\n+\n     pub fn meta_stats(&self) -> bool {\n         self.opts.unstable_opts.meta_stats\n     }\n+\n     pub fn asm_comments(&self) -> bool {\n         self.opts.unstable_opts.asm_comments\n     }\n+\n     pub fn verify_llvm_ir(&self) -> bool {\n         self.opts.unstable_opts.verify_llvm_ir || option_env!(\"RUSTC_VERIFY_LLVM_IR\").is_some()\n     }\n+\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.unstable_opts.print_llvm_passes\n     }\n+\n     pub fn binary_dep_depinfo(&self) -> bool {\n         self.opts.unstable_opts.binary_dep_depinfo\n     }\n-    pub fn mir_opt_level(&self) -> usize {\n-        self.opts.mir_opt_level()\n-    }\n-\n-    /// Gets the features enabled for the current compilation session.\n-    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n-    /// dependency tracking. Use tcx.features() instead.\n-    #[inline]\n-    pub fn features_untracked(&self) -> &rustc_feature::Features {\n-        self.features.get().unwrap()\n-    }\n \n-    pub fn init_features(&self, features: rustc_feature::Features) {\n-        match self.features.set(features) {\n-            Ok(()) => {}\n-            Err(_) => panic!(\"`features` was initialized twice\"),\n-        }\n+    pub fn mir_opt_level(&self) -> usize {\n+        self.opts\n+            .unstable_opts\n+            .mir_opt_level\n+            .unwrap_or_else(|| if self.opts.optimize != OptLevel::No { 2 } else { 1 })\n     }\n \n     /// Calculates the flavor of LTO to use for this compilation.\n@@ -702,6 +1008,7 @@ impl Session {\n     pub fn panic_strategy(&self) -> PanicStrategy {\n         self.opts.cg.panic.unwrap_or(self.target.panic_strategy)\n     }\n+\n     pub fn fewer_names(&self) -> bool {\n         if let Some(fewer_names) = self.opts.unstable_opts.fewer_names {\n             fewer_names\n@@ -713,43 +1020,17 @@ impl Session {\n             !more_names\n         }\n     }\n-\n-    pub fn unstable_options(&self) -> bool {\n-        self.opts.unstable_opts.unstable_options\n-    }\n-    pub fn is_nightly_build(&self) -> bool {\n-        self.opts.unstable_features.is_nightly_build()\n-    }\n-    pub fn is_sanitizer_cfi_enabled(&self) -> bool {\n-        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n-    }\n-    pub fn overflow_checks(&self) -> bool {\n-        self.opts.cg.overflow_checks.unwrap_or(self.opts.debug_assertions)\n-    }\n-\n-    /// Check whether this compile session and crate type use static crt.\n-    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n-        if !self.target.crt_static_respected {\n-            // If the target does not opt in to crt-static support, use its default.\n-            return self.target.crt_static_default;\n-        }\n-\n-        let requested_features = self.opts.cg.target_feature.split(',');\n-        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n-        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n-\n-        if found_positive || found_negative {\n-            found_positive\n-        } else if crate_type == Some(CrateType::ProcMacro)\n-            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n-        {\n-            // FIXME: When crate_type is not available,\n-            // we use compiler options to determine the crate_type.\n-            // We can't check `#![crate_type = \"proc-macro\"]` here.\n-            false\n-        } else {\n-            self.target.crt_static_default\n-        }\n+\n+    pub fn unstable_options(&self) -> bool {\n+        self.opts.unstable_opts.unstable_options\n+    }\n+\n+    pub fn is_nightly_build(&self) -> bool {\n+        self.opts.unstable_features.is_nightly_build()\n+    }\n+\n+    pub fn overflow_checks(&self) -> bool {\n+        self.opts.cg.overflow_checks.unwrap_or(self.opts.debug_assertions)\n     }\n \n     pub fn relocation_model(&self) -> RelocModel {\n@@ -764,14 +1045,6 @@ impl Session {\n         self.opts.unstable_opts.tls_model.unwrap_or(self.target.tls_model)\n     }\n \n-    pub fn is_wasi_reactor(&self) -> bool {\n-        self.target.options.os == \"wasi\"\n-            && matches!(\n-                self.opts.unstable_opts.wasi_exec_model,\n-                Some(config::WasiExecModel::Reactor)\n-            )\n-    }\n-\n     pub fn split_debuginfo(&self) -> SplitDebuginfo {\n         self.opts.cg.split_debuginfo.unwrap_or(self.target.split_debuginfo)\n     }\n@@ -784,10 +1057,6 @@ impl Session {\n         }\n     }\n \n-    pub fn target_can_use_split_dwarf(&self) -> bool {\n-        !self.target.is_like_windows && !self.target.is_like_osx\n-    }\n-\n     pub fn must_emit_unwind_tables(&self) -> bool {\n         // This is used to control the emission of the `uwtable` attribute on\n         // LLVM functions.\n@@ -815,151 +1084,6 @@ impl Session {\n             )\n     }\n \n-    pub fn generate_proc_macro_decls_symbol(&self, stable_crate_id: StableCrateId) -> String {\n-        format!(\"__rustc_proc_macro_decls_{:08x}__\", stable_crate_id.to_u64())\n-    }\n-\n-    pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n-        filesearch::FileSearch::new(\n-            &self.sysroot,\n-            self.opts.target_triple.triple(),\n-            &self.opts.search_paths,\n-            &self.target_tlib_path,\n-            kind,\n-        )\n-    }\n-    pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n-        filesearch::FileSearch::new(\n-            &self.sysroot,\n-            config::host_triple(),\n-            &self.opts.search_paths,\n-            &self.host_tlib_path,\n-            kind,\n-        )\n-    }\n-\n-    /// Returns a list of directories where target-specific tool binaries are located.\n-    pub fn get_tools_search_paths(&self, self_contained: bool) -> Vec<PathBuf> {\n-        let rustlib_path = rustc_target::target_rustlib_path(&self.sysroot, &config::host_triple());\n-        let p = PathBuf::from_iter([\n-            Path::new(&self.sysroot),\n-            Path::new(&rustlib_path),\n-            Path::new(\"bin\"),\n-        ]);\n-        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n-    }\n-\n-    pub fn init_incr_comp_session(\n-        &self,\n-        session_dir: PathBuf,\n-        lock_file: flock::Lock,\n-        load_dep_graph: bool,\n-    ) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        if let IncrCompSession::NotInitialized = *incr_comp_session {\n-        } else {\n-            panic!(\"Trying to initialize IncrCompSession `{:?}`\", *incr_comp_session)\n-        }\n-\n-        *incr_comp_session =\n-            IncrCompSession::Active { session_directory: session_dir, lock_file, load_dep_graph };\n-    }\n-\n-    pub fn finalize_incr_comp_session(&self, new_directory_path: PathBuf) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        if let IncrCompSession::Active { .. } = *incr_comp_session {\n-        } else {\n-            panic!(\"trying to finalize `IncrCompSession` `{:?}`\", *incr_comp_session);\n-        }\n-\n-        // Note: this will also drop the lock file, thus unlocking the directory.\n-        *incr_comp_session = IncrCompSession::Finalized { session_directory: new_directory_path };\n-    }\n-\n-    pub fn mark_incr_comp_session_as_invalid(&self) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        let session_directory = match *incr_comp_session {\n-            IncrCompSession::Active { ref session_directory, .. } => session_directory.clone(),\n-            IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n-            _ => panic!(\"trying to invalidate `IncrCompSession` `{:?}`\", *incr_comp_session),\n-        };\n-\n-        // Note: this will also drop the lock file, thus unlocking the directory.\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n-    }\n-\n-    pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n-        let incr_comp_session = self.incr_comp_session.borrow();\n-        cell::Ref::map(incr_comp_session, |incr_comp_session| match *incr_comp_session {\n-            IncrCompSession::NotInitialized => panic!(\n-                \"trying to get session directory from `IncrCompSession`: {:?}\",\n-                *incr_comp_session,\n-            ),\n-            IncrCompSession::Active { ref session_directory, .. }\n-            | IncrCompSession::Finalized { ref session_directory }\n-            | IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n-                session_directory\n-            }\n-        })\n-    }\n-\n-    pub fn incr_comp_session_dir_opt(&self) -> Option<cell::Ref<'_, PathBuf>> {\n-        self.opts.incremental.as_ref().map(|_| self.incr_comp_session_dir())\n-    }\n-\n-    pub fn print_perf_stats(&self) {\n-        eprintln!(\n-            \"Total time spent computing symbol hashes:      {}\",\n-            duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n-        );\n-        eprintln!(\n-            \"Total queries canonicalized:                   {}\",\n-            self.perf_stats.queries_canonicalized.load(Ordering::Relaxed)\n-        );\n-        eprintln!(\n-            \"normalize_generic_arg_after_erasing_regions:   {}\",\n-            self.perf_stats.normalize_generic_arg_after_erasing_regions.load(Ordering::Relaxed)\n-        );\n-        eprintln!(\n-            \"normalize_projection_ty:                       {}\",\n-            self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed)\n-        );\n-    }\n-\n-    /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n-    /// This expends fuel if applicable, and records fuel if applicable.\n-    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n-        let mut ret = true;\n-        if let Some((ref c, _)) = self.opts.unstable_opts.fuel {\n-            if c == crate_name {\n-                assert_eq!(self.threads(), 1);\n-                let mut fuel = self.optimization_fuel.lock();\n-                ret = fuel.remaining != 0;\n-                if fuel.remaining == 0 && !fuel.out_of_fuel {\n-                    if self.diagnostic().can_emit_warnings() {\n-                        // We only call `msg` in case we can actually emit warnings.\n-                        // Otherwise, this could cause a `delay_good_path_bug` to\n-                        // trigger (issue #79546).\n-                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n-                    }\n-                    fuel.out_of_fuel = true;\n-                } else if fuel.remaining > 0 {\n-                    fuel.remaining -= 1;\n-                }\n-            }\n-        }\n-        if let Some(ref c) = self.opts.unstable_opts.print_fuel {\n-            if c == crate_name {\n-                assert_eq!(self.threads(), 1);\n-                self.print_fuel.fetch_add(1, SeqCst);\n-            }\n-        }\n-        ret\n-    }\n-\n     /// Returns the number of query threads that should be used for this\n     /// compilation\n     pub fn threads(&self) -> usize {\n@@ -1040,109 +1164,17 @@ impl Session {\n         self.opts.unstable_opts.teach && self.diagnostic().must_teach(code)\n     }\n \n-    pub fn rust_2015(&self) -> bool {\n-        self.opts.edition == Edition::Edition2015\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2018 edition?\n-    pub fn rust_2018(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2018\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2021 edition?\n-    pub fn rust_2021(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2021\n-    }\n-\n-    /// Are we allowed to use features from the Rust 2024 edition?\n-    pub fn rust_2024(&self) -> bool {\n-        self.opts.edition >= Edition::Edition2024\n-    }\n-\n     pub fn edition(&self) -> Edition {\n         self.opts.edition\n     }\n \n-    /// Returns `true` if we cannot skip the PLT for shared library calls.\n-    pub fn needs_plt(&self) -> bool {\n-        // Check if the current target usually needs PLT to be enabled.\n-        // The user can use the command line flag to override it.\n-        let needs_plt = self.target.needs_plt;\n-\n-        let dbg_opts = &self.opts.unstable_opts;\n-\n-        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.relro_level);\n-\n-        // Only enable this optimization by default if full relro is also enabled.\n-        // In this case, lazy binding was already unavailable, so nothing is lost.\n-        // This also ensures `-Wl,-z,now` is supported by the linker.\n-        let full_relro = RelroLevel::Full == relro_level;\n-\n-        // If user didn't explicitly forced us to use / skip the PLT,\n-        // then try to skip it where possible.\n-        dbg_opts.plt.unwrap_or(needs_plt || !full_relro)\n-    }\n-\n-    /// Checks if LLVM lifetime markers should be emitted.\n-    pub fn emit_lifetime_markers(&self) -> bool {\n-        self.opts.optimize != config::OptLevel::No\n-        // AddressSanitizer uses lifetimes to detect use after scope bugs.\n-        // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n-        // HWAddressSanitizer will use lifetimes to detect use after scope bugs in the future.\n-        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n-    }\n-\n     pub fn link_dead_code(&self) -> bool {\n         self.opts.cg.link_dead_code.unwrap_or(false)\n     }\n-\n-    pub fn instrument_coverage(&self) -> bool {\n-        self.opts.instrument_coverage()\n-    }\n-\n-    pub fn instrument_coverage_except_unused_generics(&self) -> bool {\n-        self.opts.instrument_coverage_except_unused_generics()\n-    }\n-\n-    pub fn instrument_coverage_except_unused_functions(&self) -> bool {\n-        self.opts.instrument_coverage_except_unused_functions()\n-    }\n-\n-    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n-        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-            .iter()\n-            .any(|kind| attr.has_name(*kind))\n-    }\n-\n-    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| item.has_name(name))\n-    }\n-\n-    pub fn find_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| attr.has_name(name))\n-    }\n-\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| attr.has_name(name))\n-    }\n-\n-    pub fn first_attr_value_str_by_name(\n-        &self,\n-        attrs: &[Attribute],\n-        name: Symbol,\n-    ) -> Option<Symbol> {\n-        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n-    }\n }\n \n+// JUSTIFICATION: part of session construction\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n fn default_emitter(\n     sopts: &config::Options,\n     registry: rustc_errors::registry::Registry,\n@@ -1227,6 +1259,8 @@ pub enum DiagnosticOutput {\n     Raw(Box<dyn Write + Send>),\n }\n \n+// JUSTIFICATION: literally session construction\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n pub fn build_session(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n@@ -1348,11 +1382,8 @@ pub fn build_session(\n         CguReuseTracker::new_disabled()\n     };\n \n-    let prof = SelfProfilerRef::new(\n-        self_profiler,\n-        sopts.unstable_opts.time_passes || sopts.unstable_opts.time,\n-        sopts.unstable_opts.time_passes,\n-    );\n+    let prof =\n+        SelfProfilerRef::new(self_profiler, sopts.time_passes(), sopts.unstable_opts.time_passes);\n \n     let ctfe_backtrace = Lock::new(match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n         Ok(ref val) if val == \"immediate\" => CtfeBacktrace::Immediate,\n@@ -1401,8 +1432,12 @@ pub fn build_session(\n     sess\n }\n \n-// If it is useful to have a Session available already for validating a\n-// commandline argument, you can do so here.\n+/// Validate command line arguments with a `Session`.\n+///\n+/// If it is useful to have a Session available already for validating a commandline argument, you\n+/// can do so here.\n+// JUSTIFICATION: needs to access args to validate them\n+#[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n fn validate_commandline_args_with_session_available(sess: &Session) {\n     // Since we don't know if code in an rlib will be linked to statically or\n     // dynamically downstream, rustc generates `__imp_` symbols that help linkers"}, {"sha": "060e7a7b90aeeea7ebefc27679e0912efb05bdcc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1238,6 +1238,8 @@ symbols! {\n         rustc_layout_scalar_valid_range_start,\n         rustc_legacy_const_generics,\n         rustc_lint_diagnostics,\n+        rustc_lint_opt_deny_field_access,\n+        rustc_lint_opt_ty,\n         rustc_lint_query_instability,\n         rustc_macro_transparency,\n         rustc_main,"}, {"sha": "d0a17f712d3dfc24e46c9d8b9c902f6a0dc97813", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -60,8 +60,9 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::{NonStructuralMatchTy, NonStructuralMatchTyKind};\n+pub use self::structural_match::{\n+    search_for_adt_const_param_violation, search_for_structural_match_violation,\n+};\n pub use self::util::{\n     elaborate_obligations, elaborate_predicates, elaborate_predicates_with_span,\n     elaborate_trait_ref, elaborate_trait_refs,"}, {"sha": "c278752e3d9f46459a6027ebcd67307f0020624c", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -6,29 +6,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::Span;\n use std::ops::ControlFlow;\n \n-#[derive(Debug)]\n-pub struct NonStructuralMatchTy<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: NonStructuralMatchTyKind<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub enum NonStructuralMatchTyKind<'tcx> {\n-    Adt(AdtDef<'tcx>),\n-    Param,\n-    Dynamic,\n-    Foreign,\n-    Opaque,\n-    Closure,\n-    Generator,\n-    Projection,\n-    Float,\n-}\n-\n /// This method traverses the structure of `ty`, trying to find an\n /// instance of an ADT (i.e. struct or enum) that doesn't implement\n /// the structural-match traits, or a generic type parameter\n@@ -54,15 +35,28 @@ pub enum NonStructuralMatchTyKind<'tcx> {\n /// For more background on why Rust has this requirement, and issues\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-///\n-/// The floats_allowed flag is used to deny constants in floating point\n pub fn search_for_structural_match_violation<'tcx>(\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    floats_allowed: bool,\n-) -> Option<NonStructuralMatchTy<'tcx>> {\n-    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), floats_allowed })\n+) -> Option<Ty<'tcx>> {\n+    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), adt_const_param: false })\n+        .break_value()\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find any\n+/// types that are not allowed to be used in a const generic.\n+///\n+/// This is either because the type does not implement `StructuralEq`\n+/// and `StructuralPartialEq`, or because the type is intentionally\n+/// not supported in const generics (such as floats and raw pointers,\n+/// which are allowed in match blocks).\n+pub fn search_for_adt_const_param_violation<'tcx>(\n+    span: Span,\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<Ty<'tcx>> {\n+    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), adt_const_param: true })\n         .break_value()\n }\n \n@@ -125,7 +119,10 @@ struct Search<'tcx> {\n     /// we will not recur on them again.\n     seen: FxHashSet<hir::def_id::DefId>,\n \n-    floats_allowed: bool,\n+    // Additionally deny things that have been allowed in patterns,\n+    // but are not allowed in adt const params, such as floats and\n+    // fn ptrs.\n+    adt_const_param: bool,\n }\n \n impl<'tcx> Search<'tcx> {\n@@ -135,59 +132,35 @@ impl<'tcx> Search<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-    type BreakTy = NonStructuralMatchTy<'tcx>;\n+    type BreakTy = Ty<'tcx>;\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n         let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n-                let kind = NonStructuralMatchTyKind::Param;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Dynamic(..) => {\n-                let kind = NonStructuralMatchTyKind::Dynamic;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Foreign(_) => {\n-                let kind = NonStructuralMatchTyKind::Foreign;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Opaque(..) => {\n-                let kind = NonStructuralMatchTyKind::Opaque;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Projection(..) => {\n-                let kind = NonStructuralMatchTyKind::Projection;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Closure(..) => {\n-                let kind = NonStructuralMatchTyKind::Closure;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                let kind = NonStructuralMatchTyKind::Generator;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n-            }\n-            ty::RawPtr(..) => {\n-                // structural-match ignores substructure of\n-                // `*const _`/`*mut _`, so skip `super_visit_with`.\n-                //\n-                // For example, if you have:\n-                // ```\n-                // struct NonStructural;\n-                // #[derive(PartialEq, Eq)]\n-                // struct T(*const NonStructural);\n-                // const C: T = T(std::ptr::null());\n-                // ```\n-                //\n-                // Even though `NonStructural` does not implement `PartialEq`,\n-                // structural equality on `T` does not recur into the raw\n-                // pointer. Therefore, one can still use `C` in a pattern.\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Break(ty);\n             }\n-            ty::FnDef(..) | ty::FnPtr(..) => {\n+            ty::FnDef(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n                 return ControlFlow::CONTINUE;\n@@ -206,14 +179,41 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                 return ControlFlow::CONTINUE;\n             }\n \n+            ty::FnPtr(..) => {\n+                if !self.adt_const_param {\n+                    return ControlFlow::CONTINUE;\n+                } else {\n+                    return ControlFlow::Break(ty);\n+                }\n+            }\n+\n+            ty::RawPtr(..) => {\n+                if !self.adt_const_param {\n+                    // structural-match ignores substructure of\n+                    // `*const _`/`*mut _`, so skip `super_visit_with`.\n+                    //\n+                    // For example, if you have:\n+                    // ```\n+                    // struct NonStructural;\n+                    // #[derive(PartialEq, Eq)]\n+                    // struct T(*const NonStructural);\n+                    // const C: T = T(std::ptr::null());\n+                    // ```\n+                    //\n+                    // Even though `NonStructural` does not implement `PartialEq`,\n+                    // structural equality on `T` does not recur into the raw\n+                    // pointer. Therefore, one can still use `C` in a pattern.\n+                    return ControlFlow::CONTINUE;\n+                } else {\n+                    return ControlFlow::Break(ty);\n+                }\n+            }\n+\n             ty::Float(_) => {\n-                if self.floats_allowed {\n+                if !self.adt_const_param {\n                     return ControlFlow::CONTINUE;\n                 } else {\n-                    return ControlFlow::Break(NonStructuralMatchTy {\n-                        ty,\n-                        kind: NonStructuralMatchTyKind::Float,\n-                    });\n+                    return ControlFlow::Break(ty);\n                 }\n             }\n \n@@ -239,8 +239,7 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n-            let kind = NonStructuralMatchTyKind::Adt(adt_def);\n-            return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+            return ControlFlow::Break(ty);\n         }\n \n         // structural-match does not care about the"}, {"sha": "08e8e6f7d0f402d18d9273702e983ffab5324733", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -221,14 +221,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::LateBoundAnon(debruijn, index, anon_index)) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_u32(index),\n-                    kind: ty::BrAnon(anon_index),\n-                };\n-                tcx.mk_region(ty::ReLateBound(debruijn, br))\n-            }\n-\n             Some(rl::Region::EarlyBound(index, id)) => {\n                 let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))"}, {"sha": "bae986de9a23d64a48835a68b8c5b9c24fc7295b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -848,29 +848,13 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n             let ty = tcx.type_of(tcx.hir().local_def_id(param.hir_id));\n \n             if tcx.features().adt_const_params {\n-                let err = match ty.peel_refs().kind() {\n-                    ty::FnPtr(_) => Some(\"function pointers\"),\n-                    ty::RawPtr(_) => Some(\"raw pointers\"),\n-                    _ => None,\n-                };\n-\n-                if let Some(unsupported_type) = err {\n-                    tcx.sess.span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"using {} as const generic parameters is forbidden\",\n-                            unsupported_type\n-                        ),\n-                    );\n-                }\n-\n                 if let Some(non_structural_match_ty) =\n-                    traits::search_for_structural_match_violation(param.span, tcx, ty, false)\n+                    traits::search_for_adt_const_param_violation(param.span, tcx, ty)\n                 {\n                     // We use the same error code in both branches, because this is really the same\n                     // issue: we just special-case the message for type parameters to make it\n                     // clearer.\n-                    match ty.peel_refs().kind() {\n+                    match non_structural_match_ty.kind() {\n                         ty::Param(_) => {\n                             // Const parameters may not have type parameters as their types,\n                             // because we cannot be sure that the type parameter derives `PartialEq`\n@@ -902,17 +886,35 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                             .note(\"floats do not derive `Eq` or `Ord`, which are required for const parameters\")\n                             .emit();\n                         }\n+                        ty::FnPtr(_) => {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"using function pointers as const generic parameters is forbidden\",\n+                            )\n+                            .emit();\n+                        }\n+                        ty::RawPtr(_) => {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"using raw pointers as const generic parameters is forbidden\",\n+                            )\n+                            .emit();\n+                        }\n                         _ => {\n                             let mut diag = struct_span_err!(\n                                 tcx.sess,\n                                 hir_ty.span,\n                                 E0741,\n                                 \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n                                 the type of a const parameter\",\n-                                non_structural_match_ty.ty,\n+                                non_structural_match_ty,\n                             );\n \n-                            if ty == non_structural_match_ty.ty {\n+                            if ty == non_structural_match_ty {\n                                 diag.span_label(\n                                     hir_ty.span,\n                                     format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),"}, {"sha": "60c0694ca0e453e986c73bf36d737e3b2f77fc40", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1346,16 +1346,8 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n             match self.tcx.named_region(lt.hir_id) {\n                 Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(\n-                    rl::Region::LateBound(debruijn, _, _)\n-                    | rl::Region::LateBoundAnon(debruijn, _, _),\n-                ) if debruijn < self.outer_index => {}\n-                Some(\n-                    rl::Region::LateBound(..)\n-                    | rl::Region::LateBoundAnon(..)\n-                    | rl::Region::Free(..),\n-                )\n-                | None => {\n+                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n+                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n                     self.has_late_bound_regions = Some(lt.span);\n                 }\n             }"}, {"sha": "76b4a534e5db5b7989904ac479c42624e60e4a30", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 122, "deletions": 72, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1628,14 +1628,21 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> ChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -1649,10 +1656,11 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(sz);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -1684,11 +1692,13 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(end);\n-            let (_, nth) = head.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth) = unsafe { head.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -1698,13 +1708,14 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n-            Some(&mut self.v[start..])\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })\n         }\n     }\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         //\n         // Also note that the caller also guarantees that we're never called\n         // with the same index again, and that no other methods that will\n@@ -1726,12 +1737,12 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -1747,10 +1758,13 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n                 Some(res) => cmp::min(self.v.len(), res),\n                 None => self.v.len(),\n             };\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (temp, _tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -1956,9 +1970,16 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for ChunksExact<'a, T> {\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n-    rem: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n+    rem: &'a mut [T], // The iterator never yields from here, so this can be unique\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n@@ -1968,7 +1989,7 @@ impl<'a, T> ChunksExactMut<'a, T> {\n         let fst_len = slice.len() - rem;\n         // SAFETY: 0 <= fst_len <= slice.len() by construction above\n         let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n-        Self { v: fst, rem: snd, chunk_size }\n+        Self { v: fst, rem: snd, chunk_size, _marker: PhantomData }\n     }\n \n     /// Returns the remainder of the original slice that is not going to be\n@@ -1990,10 +2011,11 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2015,8 +2037,8 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (_, snd) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, snd) = unsafe { self.v.split_at_mut(start) };\n             self.v = snd;\n             self.next()\n         }\n@@ -2029,7 +2051,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `ChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2041,11 +2063,11 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            // SAFETY: This subtraction is inbounds because of the check above\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2058,10 +2080,13 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         } else {\n             let start = (len - 1 - n) * self.chunk_size;\n             let end = start + self.chunk_size;\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2645,14 +2670,21 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunks<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> RChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -2666,16 +2698,16 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: split_at_mut_unchecked just requires the argument be less\n             // than the length. This could only happen if the expression\n-            // `tmp_len - sz` overflows. This could only happen if `sz >\n-            // tmp_len`, which is impossible as we initialize it as the `min` of\n-            // `self.v.len()` (e.g. `tmp_len`) and `self.chunk_size`.\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            // `len - sz` overflows. This could only happen if `sz >\n+            // len`, which is impossible as we initialize it as the `min` of\n+            // `self.v.len()` (e.g. `len`) and `self.chunk_size`.\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2709,11 +2741,15 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n                 Some(sum) => sum,\n                 None => 0,\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(start);\n-            let (nth, _) = tail.split_at_mut(end - start);\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n+            let (head, tail) = unsafe { self.v.split_at_mut(start) };\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n+            let (nth, _) = unsafe { tail.split_at_mut(end - start) };\n             self.v = head;\n-            Some(nth)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -2724,7 +2760,8 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n         } else {\n             let rem = self.v.len() % self.chunk_size;\n             let end = if rem == 0 { self.chunk_size } else { rem };\n-            Some(&mut self.v[0..end])\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })\n         }\n     }\n \n@@ -2735,7 +2772,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             Some(start) => start,\n         };\n         // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and\n-        // `ChunksMut::__iterator_get_unchecked`\n+        // `ChunksMut::__iterator_get_unchecked`, `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n }\n@@ -2749,11 +2786,11 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2768,10 +2805,13 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let offset_from_end = (len - 1 - n) * self.chunk_size;\n             let end = self.v.len() - offset_from_end;\n             let start = end.saturating_sub(self.chunk_size);\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2897,8 +2937,7 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY:\n-        // SAFETY: mostmy identical to `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n         unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2981,7 +3020,13 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunksExact<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize,\n }\n@@ -3014,11 +3059,12 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            let len = self.v.len();\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -3040,9 +3086,9 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n+            let len = self.v.len();\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n             self.v = fst;\n             self.next()\n         }\n@@ -3056,7 +3102,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -3068,10 +3114,11 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -3087,10 +3134,13 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             let offset = (len - n) * self.chunk_size;\n             let start = self.v.len() - offset;\n             let end = start + self.chunk_size;\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }"}, {"sha": "6d1516958f39bd49b38217d196bcb1d11fb16c8c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -409,6 +409,50 @@ fn test_chunks_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 14]);\n }\n \n+#[test]\n+fn test_chunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_chunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n #[test]\n fn test_chunks_exact_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}, {"sha": "aecc9aa879a69fe1e392723de2c89d9aa8f2d487", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -167,7 +167,7 @@ h2, h3, h4 {\n h2,\n .top-doc .docblock > h3,\n .top-doc .docblock > h4 {\n-\tborder-bottom: 1px solid;\n+\tborder-bottom: 1px solid var(--headings-border-bottom-color);\n }\n h3.code-header {\n \tfont-size: 1.125rem; /* 18px */\n@@ -652,7 +652,7 @@ h2.location a {\n }\n \n .top-doc .docblock h2 { font-size: 1.375rem; }\n-.top-doc .docblock h3 { font-size: 1.25; }\n+.top-doc .docblock h3 { font-size: 1.25rem; }\n .top-doc .docblock h4,\n .top-doc .docblock h5 {\n \tfont-size: 1.125rem;"}, {"sha": "a550eb1c130afd655c7247454f438b9b5adf5dfd", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -42,10 +42,6 @@ input:focus + .slider {\n \tbackground-color: #0a042f !important;\n }\n \n-.docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5, .docblock h6 {\n-\tborder-bottom-color: #DDD;\n-}\n-\n .docblock table td, .docblock table th {\n \tborder-color: #ddd;\n }"}, {"sha": "3a96884d45d9f9ec2516dd24e99691ec285ac278", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -788,7 +788,7 @@ fn main_options(options: config::Options) -> MainResult {\n         if sess.opts.describe_lints {\n             let mut lint_store = rustc_lint::new_lint_store(\n                 sess.opts.unstable_opts.no_interleave_lints,\n-                sess.unstable_options(),\n+                sess.enable_internal_lints(),\n             );\n             let registered_lints = if let Some(register_lints) = compiler.register_lints() {\n                 register_lints(sess, &mut lint_store);"}, {"sha": "b79946ea8b56c96d8d1c4305643a5685fcfbd19d", "filename": "src/test/mir-opt/issue-99325.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fmir-opt%2Fissue-99325.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fmir-opt%2Fissue-99325.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-99325.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,12 @@\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n+\n+pub fn function_with_bytes<const BYTES: &'static [u8; 4]>() -> &'static [u8] {\n+    BYTES\n+}\n+\n+// EMIT_MIR issue_99325.main.mir_map.0.mir\n+pub fn main() {\n+    assert_eq!(function_with_bytes::<b\"AAAA\">(), &[0x41, 0x41, 0x41, 0x41]);\n+    assert_eq!(function_with_bytes::<{ &[0x41, 0x41, 0x41, 0x41] }>(), b\"AAAA\");\n+}"}, {"sha": "175f244aa5dc9344f5588867fb017042cf3eb7a8", "filename": "src/test/mir-opt/issue_99325.main.mir_map.0.mir", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fmir-opt%2Fissue_99325.main.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fmir-opt%2Fissue_99325.main.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_99325.main.mir_map.0.mir?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,295 @@\n+// MIR for `main` 0 mir_map\n+\n+| User Type Annotations\n+| 0: user_ty: Canonical { max_universe: U0, variables: [], value: TypeOf(DefId(0:3 ~ issue_99325[8f58]::function_with_bytes), UserSubsts { substs: [Const { ty: &'static [u8; 4], kind: Value(Branch([Leaf(0x41), Leaf(0x41), Leaf(0x41), Leaf(0x41)])) }], user_self_ty: None }) }, span: $DIR/issue-99325.rs:10:16: 10:46, inferred_ty: fn() -> &'static [u8] {function_with_bytes::<&*b\"AAAA\">}\n+| 1: user_ty: Canonical { max_universe: U0, variables: [], value: TypeOf(DefId(0:3 ~ issue_99325[8f58]::function_with_bytes), UserSubsts { substs: [Const { ty: &'static [u8; 4], kind: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:8 ~ issue_99325[8f58]::main::{constant#1}), const_param_did: Some(DefId(0:4 ~ issue_99325[8f58]::function_with_bytes::BYTES)) }, substs: [], promoted: None }) }], user_self_ty: None }) }, span: $DIR/issue-99325.rs:11:16: 11:68, inferred_ty: fn() -> &'static [u8] {function_with_bytes::<&*b\"AAAA\">}\n+|\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/issue-99325.rs:9:15: 9:15\n+    let _1: ();                          // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _2: (&&[u8], &&[u8; 4]);     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _3: &&[u8];                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _4: &[u8];                       // in scope 0 at $DIR/issue-99325.rs:10:16: 10:48\n+    let mut _5: &&[u8; 4];               // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _6: &[u8; 4];                    // in scope 0 at $DIR/issue-99325.rs:10:50: 10:75\n+    let _7: [u8; 4];                     // in scope 0 at $DIR/issue-99325.rs:10:51: 10:75\n+    let _8: &&[u8];                      // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _9: &&[u8; 4];                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _10: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _11: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _12: &&[u8];                 // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _13: &&[u8; 4];              // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _14: !;                      // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _16: !;                          // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _17: core::panicking::AssertKind; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _18: &&[u8];                 // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _19: &&[u8];                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _20: &&[u8; 4];              // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _21: &&[u8; 4];                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _22: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _23: ();                         // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _24: (&&[u8], &&[u8; 4]);    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _25: &&[u8];                 // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _26: &[u8];                      // in scope 0 at $DIR/issue-99325.rs:11:16: 11:70\n+    let mut _27: &&[u8; 4];              // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _28: &[u8; 4];                   // in scope 0 at $DIR/issue-99325.rs:11:72: 11:79\n+    let _29: &&[u8];                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _30: &&[u8; 4];                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _31: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _32: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _33: &&[u8];                 // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _34: &&[u8; 4];              // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _35: !;                      // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _37: !;                          // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _38: core::panicking::AssertKind; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _39: &&[u8];                 // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _40: &&[u8];                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _41: &&[u8; 4];              // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let _42: &&[u8; 4];                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _43: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    scope 1 {\n+        debug left_val => _8;            // in scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        debug right_val => _9;           // in scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        let _15: core::panicking::AssertKind; // in scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        scope 2 {\n+            debug kind => _15;           // in scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        }\n+    }\n+    scope 3 {\n+        debug left_val => _29;           // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        debug right_val => _30;          // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        let _36: core::panicking::AssertKind; // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        scope 4 {\n+            debug kind => _36;           // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_3);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 0 at $DIR/issue-99325.rs:10:16: 10:48\n+        _4 = function_with_bytes::<&*b\"AAAA\">() -> [return: bb1, unwind: bb19]; // scope 0 at $DIR/issue-99325.rs:10:16: 10:48\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue-99325.rs:10:16: 10:46\n+                                         // + user_ty: UserType(0)\n+                                         // + literal: Const { ty: fn() -> &'static [u8] {function_with_bytes::<&*b\"AAAA\">}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        _3 = &_4;                        // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_5);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 0 at $DIR/issue-99325.rs:10:50: 10:75\n+        StorageLive(_7);                 // scope 0 at $DIR/issue-99325.rs:10:51: 10:75\n+        _7 = [const 65_u8, const 65_u8, const 65_u8, const 65_u8]; // scope 0 at $DIR/issue-99325.rs:10:51: 10:75\n+        _6 = &_7;                        // scope 0 at $DIR/issue-99325.rs:10:50: 10:75\n+        _5 = &_6;                        // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _2 = (move _3, move _5);         // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        FakeRead(ForMatchedPlace(None), _2); // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_8);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _8 = (_2.0: &&[u8]);             // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_9);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _9 = (_2.1: &&[u8; 4]);          // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_10);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_11);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_12);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _12 = &(*_8);                    // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_13);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _13 = &(*_9);                    // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _11 = <&[u8] as PartialEq<&[u8; 4]>>::eq(move _12, move _13) -> [return: bb2, unwind: bb19]; // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // + literal: Const { ty: for<'r, 's> fn(&'r &[u8], &'s &[u8; 4]) -> bool {<&[u8] as PartialEq<&[u8; 4]>>::eq}, val: Value(<ZST>) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_13);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_12);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _10 = Not(move _11);             // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_11);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        switchInt(move _10) -> [false: bb4, otherwise: bb3]; // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        StorageLive(_15);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _15 = core::panicking::AssertKind::Eq; // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        FakeRead(ForLet(None), _15);     // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_16);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_17);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _17 = move _15;                  // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_18);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_19);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _19 = &(*_8);                    // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _18 = &(*_19);                   // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_20);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_21);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _21 = &(*_9);                    // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _20 = &(*_21);                   // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_22);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _22 = Option::<Arguments>::None; // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _16 = core::panicking::assert_failed::<&[u8], &[u8; 4]>(move _17, move _18, move _20, move _22) -> bb19; // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // + literal: Const { ty: for<'r, 's, 't0> fn(core::panicking::AssertKind, &'r &[u8], &'s &[u8; 4], Option<Arguments<'t0>>) -> ! {core::panicking::assert_failed::<&[u8], &[u8; 4]>}, val: Value(<ZST>) }\n+    }\n+\n+    bb4: {\n+        goto -> bb7;                     // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb5: {\n+        StorageDead(_22);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_20);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_18);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_17);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_21);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_19);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_16);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_15);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        unreachable;                     // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb6: {\n+        goto -> bb8;                     // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb7: {\n+        _1 = const ();                   // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        goto -> bb8;                     // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb8: {\n+        StorageDead(_10);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_9);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        goto -> bb9;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb9: {\n+        StorageDead(_7);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_6);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_4);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_1);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_23);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_24);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_25);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_26);                // scope 0 at $DIR/issue-99325.rs:11:16: 11:70\n+        _26 = function_with_bytes::<&*b\"AAAA\">() -> [return: bb10, unwind: bb19]; // scope 0 at $DIR/issue-99325.rs:11:16: 11:70\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue-99325.rs:11:16: 11:68\n+                                         // + user_ty: UserType(1)\n+                                         // + literal: Const { ty: fn() -> &'static [u8] {function_with_bytes::<&*b\"AAAA\">}, val: Value(<ZST>) }\n+    }\n+\n+    bb10: {\n+        _25 = &_26;                      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_27);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_28);                // scope 0 at $DIR/issue-99325.rs:11:72: 11:79\n+        _28 = const b\"AAAA\";             // scope 0 at $DIR/issue-99325.rs:11:72: 11:79\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue-99325.rs:11:72: 11:79\n+                                         // + literal: Const { ty: &[u8; 4], val: Value(Scalar(alloc4)) }\n+        _27 = &_28;                      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _24 = (move _25, move _27);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_27);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_25);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        FakeRead(ForMatchedPlace(None), _24); // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_29);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _29 = (_24.0: &&[u8]);           // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_30);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _30 = (_24.1: &&[u8; 4]);        // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_31);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_32);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_33);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _33 = &(*_29);                   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_34);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _34 = &(*_30);                   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _32 = <&[u8] as PartialEq<&[u8; 4]>>::eq(move _33, move _34) -> [return: bb11, unwind: bb19]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // + literal: Const { ty: for<'r, 's> fn(&'r &[u8], &'s &[u8; 4]) -> bool {<&[u8] as PartialEq<&[u8; 4]>>::eq}, val: Value(<ZST>) }\n+    }\n+\n+    bb11: {\n+        StorageDead(_34);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_33);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _31 = Not(move _32);             // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_32);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        switchInt(move _31) -> [false: bb13, otherwise: bb12]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb12: {\n+        StorageLive(_36);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _36 = core::panicking::AssertKind::Eq; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        FakeRead(ForLet(None), _36);     // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_37);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_38);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _38 = move _36;                  // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_39);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_40);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _40 = &(*_29);                   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _39 = &(*_40);                   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_41);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_42);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _42 = &(*_30);                   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _41 = &(*_42);                   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageLive(_43);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _43 = Option::<Arguments>::None; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _37 = core::panicking::assert_failed::<&[u8], &[u8; 4]>(move _38, move _39, move _41, move _43) -> bb19; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                         // + literal: Const { ty: for<'r, 's, 't0> fn(core::panicking::AssertKind, &'r &[u8], &'s &[u8; 4], Option<Arguments<'t0>>) -> ! {core::panicking::assert_failed::<&[u8], &[u8; 4]>}, val: Value(<ZST>) }\n+    }\n+\n+    bb13: {\n+        goto -> bb16;                    // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb14: {\n+        StorageDead(_43);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_41);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_39);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_38);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_42);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_40);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_37);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_36);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        unreachable;                     // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb15: {\n+        goto -> bb17;                    // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb16: {\n+        _23 = const ();                  // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        goto -> bb17;                    // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb17: {\n+        StorageDead(_31);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_30);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_29);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        goto -> bb18;                    // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    }\n+\n+    bb18: {\n+        StorageDead(_28);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_26);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_24);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        StorageDead(_23);                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _0 = const ();                   // scope 0 at $DIR/issue-99325.rs:9:15: 12:2\n+        return;                          // scope 0 at $DIR/issue-99325.rs:12:2: 12:2\n+    }\n+\n+    bb19 (cleanup): {\n+        resume;                          // scope 0 at $DIR/issue-99325.rs:9:1: 12:2\n+    }\n+}\n+\n+alloc4 (size: 4, align: 1) {\n+    41 41 41 41                                     \u2502 AAAA\n+}"}, {"sha": "f6287ade2f295b2f6b3c266555590e0d5ed1337d", "filename": "src/test/rustdoc-gui/docblock-details.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-details.goml?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -9,12 +9,12 @@ reload:\n assert-text: (\".top-doc .docblock > h3\", \"Hello\")\n assert-css: (\n     \".top-doc .docblock > h3\",\n-    {\"border-bottom\": \"1px solid rgb(221, 221, 221)\"},\n+    {\"border-bottom\": \"1px solid rgb(210, 210, 210)\"},\n )\n // We now check that the `<summary>` doesn't have a bottom border and has the correct display.\n assert-css: (\n     \".top-doc .docblock summary h4\",\n-    {\"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+    {\"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n )\n // This allows to ensure that summary is on one line only!\n assert-property: (\".top-doc .docblock summary h4\", {\"offsetHeight\": \"33\"})"}, {"sha": "8c2c3df1588f507370b1c20f0a1fbafa35abbeb2", "filename": "src/test/rustdoc-gui/headings.goml", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -150,15 +150,109 @@ assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"font-size\": \"20px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"border-bottom-width\": \"1px\"})\n \n-goto: file://|DOC_PATH|/staged_api/struct.Foo.html\n+// Checking colors now.\n show-text: true\n local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n+goto: file://|DOC_PATH|/test_docs/struct.HeavilyDocumentedStruct.html\n+assert-css: (\n+    \".top-doc .docblock h2\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"1px solid rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h3\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"1px solid rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h4\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"1px solid rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h5\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h4\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h5\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h6\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"border-bottom\": \"0px none rgb(221, 221, 221)\"},\n+)\n+\n+local-storage: {\"rustdoc-theme\": \"dark\"}\n+reload:\n+assert-css: (\n+    \".top-doc .docblock h2\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"1px solid rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h3\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"1px solid rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h4\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"1px solid rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h5\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h4\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h5\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h6\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"border-bottom\": \"0px none rgb(210, 210, 210)\"},\n+)\n+\n+local-storage: {\"rustdoc-theme\": \"ayu\"}\n+reload:\n+assert-css: (\n+    \".top-doc .docblock h2\",\n+    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom\": \"1px solid rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h2\",\n+    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom\": \"1px solid rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h4\",\n+    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom\": \"1px solid rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \".top-doc .docblock h5\",\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h4\",\n+    {\"color\": \"rgb(255, 255, 255)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h5\",\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+)\n+assert-css: (\n+    \"#implementations-list .docblock h6\",\n+    {\"color\": \"rgb(197, 197, 197)\", \"border-bottom\": \"0px none rgb(92, 103, 115)\"},\n+)\n+\n+local-storage: {\"rustdoc-theme\": \"light\"}\n+goto: file://|DOC_PATH|/staged_api/struct.Foo.html\n assert-css: (\".since\", {\"color\": \"rgb(128, 128, 128)\"})\n \n-local-storage: {\"rustdoc-theme\": \"dark\", \"rustdoc-use-system-theme\": \"false\"}\n+local-storage: {\"rustdoc-theme\": \"dark\"}\n reload:\n assert-css: (\".since\", {\"color\": \"rgb(128, 128, 128)\"})\n \n-local-storage: {\"rustdoc-theme\": \"ayu\", \"rustdoc-use-system-theme\": \"false\"}\n+local-storage: {\"rustdoc-theme\": \"ayu\"}\n reload:\n assert-css: (\".since\", {\"color\": \"rgb(128, 128, 128)\"})"}, {"sha": "1b26aaecb5ef3d224a1db4202858a3abd4becb3a", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -146,6 +146,10 @@ pub use crate::repro as repro2;\n /// ### Top-doc Prose sub-sub-heading\n ///\n /// Text below sub-sub-heading\n+///\n+/// #### You know the drill.\n+///\n+/// More text.\n pub struct HeavilyDocumentedStruct {\n     /// # Title for field\n     /// ## Sub-heading for field"}, {"sha": "d6bd6945e150ad09704dc0c0a1ff583365dcecf7", "filename": "src/test/ui-fulldeps/internal-lints/bad_opt_access.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Z unstable-options\n+\n+// Test that accessing command line options by field access triggers a lint for those fields\n+// that have wrapper functions which should be used.\n+\n+#![crate_type = \"lib\"]\n+#![feature(rustc_private)]\n+#![deny(rustc::bad_opt_access)]\n+\n+extern crate rustc_session;\n+use rustc_session::Session;\n+\n+pub fn access_bad_option(sess: Session) {\n+    let _ = sess.opts.cg.split_debuginfo;\n+    //~^ ERROR use `Session::split_debuginfo` instead of this field\n+\n+    let _ = sess.opts.crate_types;\n+    //~^ ERROR use `Session::crate_types` instead of this field\n+\n+    let _ = sess.opts.crate_name;\n+    // okay!\n+}"}, {"sha": "e4145bff8bee97ffc71043e6dfb612ace156dd15", "filename": "src/test/ui-fulldeps/internal-lints/bad_opt_access.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fbad_opt_access.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,20 @@\n+error: use `Session::split_debuginfo` instead of this field\n+  --> $DIR/bad_opt_access.rs:14:13\n+   |\n+LL |     let _ = sess.opts.cg.split_debuginfo;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/bad_opt_access.rs:8:9\n+   |\n+LL | #![deny(rustc::bad_opt_access)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: use `Session::crate_types` instead of this field\n+  --> $DIR/bad_opt_access.rs:17:13\n+   |\n+LL |     let _ = sess.opts.crate_types;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b55c2449858c9fe0b9966d4428b795298b2c2afe", "filename": "src/test/ui/const-generics/fn-const-param-call.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,14 +1,15 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-call.rs:11:25\n    |\n LL | struct Wrapper<const F: fn() -> u32>;\n    |                         ^^^^^^^^^^^\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-call.rs:13:15\n    |\n LL | impl<const F: fn() -> u32> Wrapper<F> {\n    |               ^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "2d66a19233269cb7fc93d31465a74a2b44f61efe", "filename": "src/test/ui/const-generics/fn-const-param-infer.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-infer.rs:6:25\n    |\n LL | struct Checked<const F: fn(usize) -> bool>;\n    |                         ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "e17cf96aa3e3d0bdfea2d317753a8bdaf5094c3a", "filename": "src/test/ui/const-generics/issues/issue-71381.full.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71381.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -10,18 +10,19 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL |         const FN: unsafe extern \"C\" fn(Args),\n    |                                        ^^^^ the type must not depend on the parameter `Args`\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71381.rs:14:61\n    |\n LL |     pub fn call_me<Args: Sized, const IDX: usize, const FN: unsafe extern \"C\" fn(Args)>(&self) {\n    |                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71381.rs:23:19\n    |\n LL |         const FN: unsafe extern \"C\" fn(Args),\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0770`.\n+Some errors have detailed explanations: E0741, E0770.\n+For more information about an error, try `rustc --explain E0741`."}, {"sha": "ab2a4e64a838978bade17de81988f5540df5062b", "filename": "src/test/ui/const-generics/issues/issue-71382.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71382.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71382.rs:16:23\n    |\n LL |     fn test<const FN: fn()>(&self) {\n    |                       ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "656aa29e19b2595579442e16cea4575ffb83638f", "filename": "src/test/ui/const-generics/issues/issue-71611.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71611.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -4,12 +4,13 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL | fn func<A, const F: fn(inner: A)>(outer: A) {\n    |                               ^ the type must not depend on the parameter `A`\n \n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-71611.rs:5:21\n    |\n LL | fn func<A, const F: fn(inner: A)>(outer: A) {\n    |                     ^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0770`.\n+Some errors have detailed explanations: E0741, E0770.\n+For more information about an error, try `rustc --explain E0741`."}, {"sha": "92580b33685d190c45541ebb5b930dea8ee4b412", "filename": "src/test/ui/const-generics/issues/issue-72352.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72352.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,8 +1,9 @@\n-error: using function pointers as const generic parameters is forbidden\n+error[E0741]: using function pointers as const generic parameters is forbidden\n   --> $DIR/issue-72352.rs:7:42\n    |\n LL | unsafe fn unsafely_do_the_thing<const F: fn(&CStr) -> usize>(ptr: *const i8) -> usize {\n    |                                          ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "fae6d3fc41fb86ae77d179e7058bf79e26fecd7c", "filename": "src/test/ui/const-generics/issues/issue-99641.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,18 @@\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n+\n+fn main() {\n+    pub struct Color<const WHITE: (fn(),)>;\n+    //~^ ERROR using function pointers\n+\n+    impl<const WHITE: (fn(),)> Color<WHITE> {\n+        //~^ ERROR using function pointers\n+        pub fn new() -> Self {\n+            Color::<WHITE>\n+        }\n+    }\n+\n+    pub const D65: (fn(),) = (|| {},);\n+\n+    Color::<D65>::new();\n+}"}, {"sha": "349ebba08d53f5ba385b3ab9d667514457480560", "filename": "src/test/ui/const-generics/issues/issue-99641.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-99641.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,15 @@\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/issue-99641.rs:5:35\n+   |\n+LL |     pub struct Color<const WHITE: (fn(),)>;\n+   |                                   ^^^^^^^\n+\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/issue-99641.rs:8:23\n+   |\n+LL |     impl<const WHITE: (fn(),)> Color<WHITE> {\n+   |                       ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "657eee2be24431697ed97a7a1e42a14a2ecc9cd4", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.full.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,14 +1,15 @@\n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param-deref.rs:9:23\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n \n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param-deref.rs:11:15\n    |\n LL | impl<const P: *const u32> Const<P> {\n    |               ^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "69f1aae5681a4371897857de6529bce118bec9a3", "filename": "src/test/ui/const-generics/raw-ptr-const-param.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.full.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,8 +1,9 @@\n-error: using raw pointers as const generic parameters is forbidden\n+error[E0741]: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param.rs:6:23\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "1496b28bd3ee6f4c2b3f466e9d19f8fbb2d5ed98", "filename": "src/test/ui/consts/refs_check_const_eq-issue-88384.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,5 +1,3 @@\n-// check-pass\n-\n #![feature(fn_traits)]\n #![feature(adt_const_params)]\n //~^ WARNING the feature `adt_const_params` is incomplete\n@@ -10,8 +8,10 @@ struct CompileTimeSettings{\n }\n \n struct Foo<const T: CompileTimeSettings>;\n+//~^ ERROR using function pointers as const generic parameters is forbidden\n \n impl<const T: CompileTimeSettings> Foo<T> {\n+    //~^ ERROR using function pointers as const generic parameters is forbidden\n     fn call_hooks(){\n     }\n }"}, {"sha": "4f2f5e244b67e51e005e3cbe20c435da60571f7f", "filename": "src/test/ui/consts/refs_check_const_eq-issue-88384.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frefs_check_const_eq-issue-88384.stderr?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -1,11 +1,24 @@\n warning: the feature `adt_const_params` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/refs_check_const_eq-issue-88384.rs:4:12\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:2:12\n    |\n LL | #![feature(adt_const_params)]\n    |            ^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #95174 <https://github.com/rust-lang/rust/issues/95174> for more information\n \n-warning: 1 warning emitted\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:10:21\n+   |\n+LL | struct Foo<const T: CompileTimeSettings>;\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error[E0741]: using function pointers as const generic parameters is forbidden\n+  --> $DIR/refs_check_const_eq-issue-88384.rs:13:15\n+   |\n+LL | impl<const T: CompileTimeSettings> Foo<T> {\n+   |               ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "929b82bfc432e993dce2423e88022fd67284e5c2", "filename": "src/test/ui/impl-header-lifetime-elision/constant-used-as-arraylen.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fconstant-used-as-arraylen.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// Verify that we do not ICE when anonymous lifetimes appear inside an AnonConst.\n+\n+pub struct EntriesBuffer(Box<[[u8; HashesEntry::LEN]; 5]>);\n+\n+impl EntriesBuffer {\n+    pub fn iter_child_buffers(&mut self) -> impl Iterator<Item = &mut [u8; HashesEntry::LEN]> {\n+        self.0.iter_mut()\n+    }\n+\n+    pub fn iter_child_buffers_explicit(\n+        &mut self,\n+    ) -> impl Iterator<Item = &mut [u8; HashesEntry::<'_>::LEN]> {\n+        self.0.iter_mut()\n+    }\n+}\n+\n+pub struct HashesEntry<'a>(&'a [u8]);\n+\n+impl HashesEntry<'_> {\n+    pub const LEN: usize = 1;\n+}\n+\n+fn main() {}"}, {"sha": "3f69cc2038839c815a6e4c94221dffe7c7e1807a", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -615,7 +615,7 @@ struct BodyLifetimeChecker {\n impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.ident().name != kw::Empty && lifetime.name.ident().name != kw::StaticLifetime {\n+        if lifetime.name.ident().name != kw::UnderscoreLifetime && lifetime.name.ident().name != kw::StaticLifetime {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}, {"sha": "a0ca7e6ff1e22b78f2cd4c08a8ca29c6cea71e8c", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -166,7 +166,7 @@ fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName])\n     // - There's only one output lifetime bound using `+ '_`\n     // - All input lifetimes are explicitly bound to the output\n     input_lifetimes.is_empty()\n-        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Underscore))\n+        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Infer))\n         || input_lifetimes\n             .iter()\n             .all(|in_lt| output_lifetimes.iter().any(|out_lt| in_lt == out_lt))"}, {"sha": "3c5ea2d94144faf0718772b5342befcc510c7b8e", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -351,7 +351,7 @@ impl fmt::Display for RefPrefix {\n                 name.fmt(f)?;\n                 f.write_char(' ')?;\n             },\n-            LifetimeName::Underscore => f.write_str(\"'_ \")?,\n+            LifetimeName::Infer => f.write_str(\"'_ \")?,\n             LifetimeName::Static => f.write_str(\"'static \")?,\n             _ => (),\n         }"}, {"sha": "c1ec2bd5bd665c659475866d3ba817ff37189aef", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2643b16468fda787470340890212591d8bc832b7/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=2643b16468fda787470340890212591d8bc832b7", "patch": "@@ -94,6 +94,8 @@ struct ClippyCallbacks {\n }\n \n impl rustc_driver::Callbacks for ClippyCallbacks {\n+    // JUSTIFICATION: necessary in clippy driver to set `mir_opt_level`\n+    #[cfg_attr(not(bootstrap), allow(rustc::bad_opt_access))]\n     fn config(&mut self, config: &mut interface::Config) {\n         let previous = config.register_lints.take();\n         let clippy_args_var = self.clippy_args_var.take();"}]}