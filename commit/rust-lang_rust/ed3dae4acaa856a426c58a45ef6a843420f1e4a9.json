{"sha": "ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkM2RhZTRhY2FhODU2YTQyNmM1OGE0NWVmNmE4NDM0MjBmMWU0YTk=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-08T01:21:19Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:57Z"}, "message": "Rename *shallow_resolve to *shallow_resolve_type\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "1820f6e6a355e4c716dd7bd0bb9e8d390e282e9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1820f6e6a355e4c716dd7bd0bb9e8d390e282e9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "html_url": "https://github.com/rust-lang/rust/commit/ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f675ab038cfd82550fe54b7d659f26753987d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f675ab038cfd82550fe54b7d659f26753987d34", "html_url": "https://github.com/rust-lang/rust/commit/3f675ab038cfd82550fe54b7d659f26753987d34"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "59a9fd11e1d577bab77c8c3b11a6d615eacb2583", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -255,8 +255,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         // doing more work yet\n         if !pending_obligation.stalled_on.is_empty() {\n             if pending_obligation.stalled_on.iter().all(|&ty| {\n-                // Use the force-inlined variant of shallow_resolve() because this code is hot.\n-                let resolved_ty = self.selcx.infcx().inlined_shallow_resolve(&ty);\n+                // Use the force-inlined variant of shallow_resolve_type() because this code is hot.\n+                let resolved_ty = self.selcx.infcx().inlined_shallow_resolve_type(&ty);\n                 resolved_ty == ty // nothing changed here\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\","}, {"sha": "763fa40d8f3bbfecb0df86dc2fae1cbb4805b537", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -1229,7 +1229,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let object_ty = selcx.infcx().shallow_resolve_type(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n@@ -1346,7 +1346,7 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n+    let fn_type = selcx.infcx().shallow_resolve_type(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized {\n         value: sig,\n@@ -1371,7 +1371,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n-    let closure_sig = infcx.shallow_resolve(&closure_sig_ty).fn_sig(tcx);\n+    let closure_sig = infcx.shallow_resolve_type(&closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n         value: closure_sig,\n         obligations"}, {"sha": "18ac30b7f1eb25ca35d3b2d6ffc981ab30bd16fa", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -2403,7 +2403,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx\n-            .shallow_resolve(obligation.predicate.skip_binder().self_ty());\n+            .shallow_resolve_type(obligation.predicate.skip_binder().self_ty());\n \n         match self_ty.sty {\n             ty::Infer(ty::IntVar(_))\n@@ -2467,7 +2467,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> BuiltinImplConditions<'tcx> {\n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx\n-            .shallow_resolve(obligation.predicate.skip_binder().self_ty());\n+            .shallow_resolve_type(obligation.predicate.skip_binder().self_ty());\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n@@ -2866,7 +2866,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         );\n \n         let types = obligation.predicate.map_bound(|inner| {\n-            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n+            let self_ty = self.infcx.shallow_resolve_type(inner.self_ty());\n             self.constituent_types_for_ty(self_ty)\n         });\n         self.vtable_auto_impl(obligation, trait_def_id, types)\n@@ -2990,7 +2990,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // from the object. Have to try to make a broken test case that\n         // results.\n         let self_ty = self.infcx\n-            .shallow_resolve(*obligation.self_ty().skip_binder());\n+            .shallow_resolve_type(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::Dynamic(ref data, ..) =>\n                 data.principal().unwrap_or_else(|| {\n@@ -3045,7 +3045,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // OK to skip binder; it is reintroduced below\n         let self_ty = self.infcx\n-            .shallow_resolve(*obligation.self_ty().skip_binder());\n+            .shallow_resolve_type(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n         let trait_ref = self.tcx()\n             .closure_trait_ref_and_return_type(\n@@ -3125,7 +3125,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx\n-            .shallow_resolve(obligation.self_ty().skip_binder());\n+            .shallow_resolve_type(obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -3183,7 +3183,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx\n-            .shallow_resolve(obligation.self_ty().skip_binder());\n+            .shallow_resolve_type(obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -3278,14 +3278,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx\n-            .shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n+            .shallow_resolve_type(obligation.self_ty().no_bound_vars().unwrap());\n         let target = obligation\n             .predicate\n             .skip_binder()\n             .trait_ref\n             .substs\n             .type_at(1);\n-        let target = self.infcx.shallow_resolve(target);\n+        let target = self.infcx.shallow_resolve_type(target);\n \n         debug!(\n             \"confirm_builtin_unsize_candidate(source={:?}, target={:?})\","}, {"sha": "c8ee3fd482b3f618f1c6c97f77fd8ccbb380161d", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -406,7 +406,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 //    moving. (Goal is that an \"inductive hypothesis\"\n                 //    is satisfied to ensure termination.)\n                 ty::Infer(_) => {\n-                    let ty = self.infcx.shallow_resolve(ty);\n+                    let ty = self.infcx.shallow_resolve_type(ty);\n                     if let ty::Infer(_) = ty.sty { // not yet resolved...\n                         if ty == ty0 { // ...this is the type we started from! no progress.\n                             return false;"}, {"sha": "f03a3bde84e4ce46a0d64d9b5558f4b14c426bfe", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve(expected);\n+                let expected = self.shallow_resolve_type(expected);\n                 if self.check_dereferencable(pat.span, expected, &inner) {\n                     // `demand::subtype` would be good enough, but using\n                     // `eqtype` turns out to be equally general. See (*)\n@@ -519,7 +519,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n+            if let Some(mt) = self.shallow_resolve_type(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error."}, {"sha": "1c6601536eea1943b405ac694a5e249096261a43", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -154,7 +154,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     }\n \n     fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        let a = self.shallow_resolve(a);\n+        let a = self.shallow_resolve_type(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n@@ -170,8 +170,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            let b = self.shallow_resolve(b);\n-            return if self.shallow_resolve(b).is_ty_var() {\n+            let b = self.shallow_resolve_type(b);\n+            return if self.shallow_resolve_type(b).is_ty_var() {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n@@ -659,7 +659,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! into a closure or a `proc`.\n         //!\n \n-        let b = self.shallow_resolve(b);\n+        let b = self.shallow_resolve_type(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n         self.coerce_from_safe_fn(a, fn_ty_a, b,\n@@ -673,7 +673,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n         //! into a closure or a `proc`.\n \n-        let b = self.shallow_resolve(b);\n+        let b = self.shallow_resolve_type(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n@@ -719,7 +719,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         //! into a function pointer.\n         //!\n \n-        let b = self.shallow_resolve(b);\n+        let b = self.shallow_resolve_type(b);\n \n         let hir_id_a = self.tcx.hir().as_local_hir_id(def_id_a).unwrap();\n         match b.sty {\n@@ -1128,7 +1128,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         // compatibility (hopefully that is true) by helping us\n         // uncover never types better.\n         if expression_ty.is_ty_var() {\n-            expression_ty = fcx.infcx.shallow_resolve(expression_ty);\n+            expression_ty = fcx.infcx.shallow_resolve_type(expression_ty);\n         }\n \n         // If we see any error types, just propagate that error"}, {"sha": "4b772abc5f09e85432ddc936d198fedb62d1b15c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3dae4acaa856a426c58a45ef6a843420f1e4a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ed3dae4acaa856a426c58a45ef6a843420f1e4a9", "patch": "@@ -281,7 +281,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n-                let ety = fcx.shallow_resolve(ety);\n+                let ety = fcx.shallow_resolve_type(ety);\n                 if !ety.is_ty_var() {\n                     ExpectHasType(ety)\n                 } else {\n@@ -2792,7 +2792,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         expected_vid: ty::TyVid,\n     ) -> bool {\n-        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n+        let self_ty = self.shallow_resolve_type(trait_ref.self_ty());\n         debug!(\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n             trait_ref, self_ty, expected_vid"}]}