{"sha": "47cd3a4ae7d82775b74f8199139a020323375c06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Y2QzYTRhZTdkODI3NzViNzRmODE5OTEzOWEwMjAzMjMzNzVjMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-10T19:54:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-10T19:54:15Z"}, "message": "Auto merge of #30182 - alexcrichton:remove-deprecated, r=aturon\n\nThis is a standard \"clean out libstd\" commit which removes all 1.5-and-before\ndeprecated functionality as it's now all been deprecated for at least one entire\ncycle.", "tree": {"sha": "0a0217447fafa8f786001a2021906efeacf3c360", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0217447fafa8f786001a2021906efeacf3c360"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47cd3a4ae7d82775b74f8199139a020323375c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47cd3a4ae7d82775b74f8199139a020323375c06", "html_url": "https://github.com/rust-lang/rust/commit/47cd3a4ae7d82775b74f8199139a020323375c06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47cd3a4ae7d82775b74f8199139a020323375c06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce132752c68aebbaf78125df4266e96e00261d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce132752c68aebbaf78125df4266e96e00261d36", "html_url": "https://github.com/rust-lang/rust/commit/ce132752c68aebbaf78125df4266e96e00261d36"}, {"sha": "da50f7c288b8e6856b42fd923f3479af1c94b3bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/da50f7c288b8e6856b42fd923f3479af1c94b3bf", "html_url": "https://github.com/rust-lang/rust/commit/da50f7c288b8e6856b42fd923f3479af1c94b3bf"}], "stats": {"total": 1549, "additions": 112, "deletions": 1437}, "files": [{"sha": "9479d47943eab37345e86619d19e4b29cbf8de80", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -385,13 +385,6 @@ impl<T: ?Sized> Deref for Arc<T> {\n }\n \n impl<T: Clone> Arc<T> {\n-    #[unstable(feature = \"arc_make_unique\", reason = \"renamed to Arc::make_mut\",\n-               issue = \"27718\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to Arc::make_mut\")]\n-    pub fn make_unique(this: &mut Self) -> &mut T {\n-        Arc::make_mut(this)\n-    }\n-\n     /// Make a mutable reference into the given `Arc<T>` by cloning the inner\n     /// data if the `Arc<T>` doesn't have one strong reference and no weak\n     /// references."}, {"sha": "8f00605d33b37c0da1f8d391ec5795ce31528486", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -360,14 +360,6 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    #[inline]\n-    #[unstable(feature = \"rc_make_unique\", reason = \"renamed to Rc::make_mut\",\n-               issue = \"27718\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to Rc::make_mut\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n-        Rc::make_mut(self)\n-    }\n-\n     /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n     /// data if the `Rc<T>` doesn't have one strong reference and no weak\n     /// references."}, {"sha": "04cffeddc5f6aa5577d568b80a680694a3396ccd", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -230,26 +230,6 @@ impl<T: Ord> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Creates a `BinaryHeap` from a vector. This is sometimes called\n-    /// `heapifying` the vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(binary_heap_extras)]\n-    /// # #![allow(deprecated)]\n-    ///\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![9, 1, 2, 7, 3, 2]);\n-    /// ```\n-    #[unstable(feature = \"binary_heap_extras\",\n-               reason = \"needs to be audited\",\n-               issue = \"28147\")]\n-    #[rustc_deprecated(since = \"1.5.0\", reason = \"use BinaryHeap::from instead\")]\n-    pub fn from_vec(vec: Vec<T>) -> BinaryHeap<T> {\n-        BinaryHeap::from(vec)\n-    }\n-\n     /// Returns an iterator visiting all values in the underlying vector, in\n     /// arbitrary order.\n     ///"}, {"sha": "de9c8a2feafb84ab69f7eceb98f6c03031f0f569", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -151,25 +151,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn new() -> BTreeMap<K, V> {\n-        // FIXME(Gankro): Tune this as a function of size_of<K/V>?\n-        BTreeMap::with_b(6)\n-    }\n-\n-    /// Makes a new empty BTreeMap with the given B.\n-    ///\n-    /// B cannot be less than 2.\n-    #[unstable(feature = \"btree_b\",\n-               reason = \"probably want this to be on the type, eventually\",\n-               issue = \"27795\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API\")]\n-    pub fn with_b(b: usize) -> BTreeMap<K, V> {\n-        assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {\n             length: 0,\n             depth: 1,\n-            root: Node::make_leaf_root(b),\n-            b: b,\n+            root: Node::make_leaf_root(6),\n+            // FIXME(Gankro): Tune this as a function of size_of<K/V>?\n+            b: 6,\n         }\n+\n     }\n \n     /// Clears the map, removing all values.\n@@ -185,11 +174,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n     pub fn clear(&mut self) {\n-        let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)) {}\n+        for _ in mem::replace(self, BTreeMap::new()) {}\n     }\n \n     // Searching in a B-Tree is pretty straightforward."}, {"sha": "a2c09c36795e4e2f3ed19ae6ac331fb70690be39", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -98,18 +98,6 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n-\n-    /// Makes a new BTreeSet with the given B.\n-    ///\n-    /// B cannot be less than 2.\n-    #[unstable(feature = \"btree_b\",\n-               reason = \"probably want this to be on the type, eventually\",\n-               issue = \"27795\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API\")]\n-    #[allow(deprecated)]\n-    pub fn with_b(b: usize) -> BTreeSet<T> {\n-        BTreeSet { map: BTreeMap::with_b(b) }\n-    }\n }\n \n impl<T> BTreeSet<T> {"}, {"sha": "9bb5ec808194c4d5765fe77cc68802df2581b1d6", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -110,9 +110,6 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{SplitMut, ChunksMut, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n-#[unstable(feature = \"ref_slice\", issue = \"27774\")]\n-#[allow(deprecated)]\n-pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n "}, {"sha": "4757ada474f117caf8564bdb120cfba761645e3c", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1074,17 +1074,6 @@ impl String {\n         let slice = self.vec.into_boxed_slice();\n         unsafe { mem::transmute::<Box<[u8]>, Box<str>>(slice) }\n     }\n-\n-    /// Converts the string into `Box<str>`.\n-    ///\n-    /// Note that this will drop any excess capacity.\n-    #[unstable(feature = \"box_str2\",\n-               reason = \"recently added, matches RFC\",\n-               issue = \"27785\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to `into_boxed_str`\")]\n-    pub fn into_boxed_slice(self) -> Box<str> {\n-        self.into_boxed_str()\n-    }\n }\n \n impl FromUtf8Error {"}, {"sha": "0ca4ce2dddf42250721c30b4d322ccdec1bdc66e", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1115,15 +1115,6 @@ impl<T> VecDeque<T> {\n         self.pop_back()\n     }\n \n-    /// deprecated\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"the naming of this function may be altered\",\n-               issue = \"27788\")]\n-    #[rustc_deprecated(since = \"1.5.0\", reason = \"renamed to swap_remove_back\")]\n-    pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n-        self.swap_remove_back(index)\n-    }\n-\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n@@ -1158,15 +1149,6 @@ impl<T> VecDeque<T> {\n         self.pop_front()\n     }\n \n-    /// deprecated\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"the naming of this function may be altered\",\n-               issue = \"27788\")]\n-    #[rustc_deprecated(since = \"1.5.0\", reason = \"renamed to swap_remove_front\")]\n-    pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n-        self.swap_remove_front(index)\n-    }\n-\n     /// Inserts an element at `index` within the `VecDeque`. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n@@ -2178,15 +2160,15 @@ mod tests {\n                             tester.push_front(i);\n                         }\n                         for i in 0..len {\n-                            assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n+                            assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n                         }\n                     } else {\n                         for i in 0..len * 2 {\n                             tester.push_back(i);\n                         }\n                         for i in 0..len {\n                             let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n+                            assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n                         }\n                     }\n                     assert!(tester.tail < tester.cap());"}, {"sha": "cc4366e8ae4638785fb3f3a4300df1d818163773", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -14,7 +14,7 @@ use std::collections::BinaryHeap;\n fn test_iterator() {\n     let data = vec![5, 9, 3];\n     let iterout = [9, 5, 3];\n-    let heap = BinaryHeap::from_vec(data);\n+    let heap = BinaryHeap::from(data);\n     let mut i = 0;\n     for el in &heap {\n         assert_eq!(*el, iterout[i]);\n@@ -26,7 +26,7 @@ fn test_iterator() {\n fn test_iterator_reverse() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n-    let pq = BinaryHeap::from_vec(data);\n+    let pq = BinaryHeap::from(data);\n \n     let v: Vec<_> = pq.iter().rev().cloned().collect();\n     assert_eq!(v, iterout);\n@@ -36,7 +36,7 @@ fn test_iterator_reverse() {\n fn test_move_iter() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![9, 5, 3];\n-    let pq = BinaryHeap::from_vec(data);\n+    let pq = BinaryHeap::from(data);\n \n     let v: Vec<_> = pq.into_iter().collect();\n     assert_eq!(v, iterout);\n@@ -45,7 +45,7 @@ fn test_move_iter() {\n #[test]\n fn test_move_iter_size_hint() {\n     let data = vec![5, 9];\n-    let pq = BinaryHeap::from_vec(data);\n+    let pq = BinaryHeap::from(data);\n \n     let mut it = pq.into_iter();\n \n@@ -63,7 +63,7 @@ fn test_move_iter_size_hint() {\n fn test_move_iter_reverse() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n-    let pq = BinaryHeap::from_vec(data);\n+    let pq = BinaryHeap::from(data);\n \n     let v: Vec<_> = pq.into_iter().rev().collect();\n     assert_eq!(v, iterout);\n@@ -74,7 +74,7 @@ fn test_peek_and_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n     let mut sorted = data.clone();\n     sorted.sort();\n-    let mut heap = BinaryHeap::from_vec(data);\n+    let mut heap = BinaryHeap::from(data);\n     while !heap.is_empty() {\n         assert_eq!(heap.peek().unwrap(), sorted.last().unwrap());\n         assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n@@ -83,7 +83,7 @@ fn test_peek_and_pop() {\n \n #[test]\n fn test_push() {\n-    let mut heap = BinaryHeap::from_vec(vec![2, 4, 9]);\n+    let mut heap = BinaryHeap::from(vec![2, 4, 9]);\n     assert_eq!(heap.len(), 3);\n     assert!(*heap.peek().unwrap() == 9);\n     heap.push(11);\n@@ -105,7 +105,7 @@ fn test_push() {\n \n #[test]\n fn test_push_unique() {\n-    let mut heap = BinaryHeap::<Box<_>>::from_vec(vec![box 2, box 4, box 9]);\n+    let mut heap = BinaryHeap::<Box<_>>::from(vec![box 2, box 4, box 9]);\n     assert_eq!(heap.len(), 3);\n     assert!(*heap.peek().unwrap() == box 9);\n     heap.push(box 11);\n@@ -127,7 +127,7 @@ fn test_push_unique() {\n \n #[test]\n fn test_push_pop() {\n-    let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n+    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n     assert_eq!(heap.len(), 5);\n     assert_eq!(heap.push_pop(6), 6);\n     assert_eq!(heap.len(), 5);\n@@ -141,7 +141,7 @@ fn test_push_pop() {\n \n #[test]\n fn test_replace() {\n-    let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n+    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n     assert_eq!(heap.len(), 5);\n     assert_eq!(heap.replace(6).unwrap(), 5);\n     assert_eq!(heap.len(), 5);\n@@ -154,7 +154,7 @@ fn test_replace() {\n }\n \n fn check_to_vec(mut data: Vec<i32>) {\n-    let heap = BinaryHeap::from_vec(data.clone());\n+    let heap = BinaryHeap::from(data.clone());\n     let mut v = heap.clone().into_vec();\n     v.sort();\n     data.sort();"}, {"sha": "dfb72d78d461143849fcf58672ae4b0c5093c50d", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -11,7 +11,6 @@\n use std::collections::BTreeMap;\n use std::collections::Bound::{Excluded, Included, Unbounded, self};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n-use std::iter::range_inclusive;\n use std::rc::Rc;\n \n #[test]\n@@ -188,7 +187,7 @@ fn test_range() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n-            let mut pairs = range_inclusive(i, j).map(|i| (i, i));\n+            let mut pairs = (i..j+1).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);"}, {"sha": "f86c016921ecc5c0cf1bf15aedce94fc16c89745", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -866,17 +866,6 @@ fn test_vec_default() {\n     t!(Vec<i32>);\n }\n \n-#[test]\n-fn test_bytes_set_memory() {\n-    use std::slice::bytes::MutableByteVector;\n-\n-    let mut values = [1,2,3,4,5];\n-    values[0..5].set_memory(0xAB);\n-    assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-    values[2..4].set_memory(0xFF);\n-    assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n-}\n-\n #[test]\n #[should_panic]\n fn test_overflow_does_not_cause_segfault() {"}, {"sha": "f063c6b06767b6edf9b794cfd5ed812fc0ce5659", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -4750,87 +4750,3 @@ impl<T> ExactSizeIterator for Once<T> {\n pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }\n }\n-\n-/// Functions for lexicographical ordering of sequences.\n-///\n-/// Lexicographical ordering through `<`, `<=`, `>=`, `>` requires\n-/// that the elements implement both `PartialEq` and `PartialOrd`.\n-///\n-/// If two sequences are equal up until the point where one ends,\n-/// the shorter sequence compares less.\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"use the equivalent methods on `Iterator` instead\")]\n-#[unstable(feature = \"iter_order_deprecated\", reason = \"needs review and revision\",\n-           issue = \"27737\")]\n-pub mod order {\n-    use cmp;\n-    use cmp::{Eq, Ord, PartialOrd, PartialEq};\n-    use option::Option;\n-    use super::Iterator;\n-\n-    /// Compare `a` and `b` for equality using `Eq`\n-    pub fn equals<A, L, R>(a: L, b: R) -> bool where\n-        A: Eq,\n-        L: Iterator<Item=A>,\n-        R: Iterator<Item=A>,\n-    {\n-        a.eq(b)\n-    }\n-\n-    /// Order `a` and `b` lexicographically using `Ord`\n-    pub fn cmp<A, L, R>(a: L, b: R) -> cmp::Ordering where\n-        A: Ord,\n-        L: Iterator<Item=A>,\n-        R: Iterator<Item=A>,\n-    {\n-        a.cmp(b)\n-    }\n-\n-    /// Order `a` and `b` lexicographically using `PartialOrd`\n-    pub fn partial_cmp<L: Iterator, R: Iterator>(a: L, b: R) -> Option<cmp::Ordering> where\n-        L::Item: PartialOrd<R::Item>\n-    {\n-        a.partial_cmp(b)\n-    }\n-\n-    /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n-    pub fn eq<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialEq<R::Item>,\n-    {\n-        a.eq(b)\n-    }\n-\n-    /// Compares `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n-    pub fn ne<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialEq<R::Item>,\n-    {\n-        a.ne(b)\n-    }\n-\n-    /// Returns `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn lt<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialOrd<R::Item>,\n-    {\n-        a.lt(b)\n-    }\n-\n-    /// Returns `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn le<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialOrd<R::Item>,\n-    {\n-        a.le(b)\n-    }\n-\n-    /// Returns `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn gt<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialOrd<R::Item>,\n-    {\n-        a.gt(b)\n-    }\n-\n-    /// Returns `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn ge<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n-        L::Item: PartialOrd<R::Item>,\n-    {\n-        a.ge(b)\n-    }\n-}"}, {"sha": "454e2b02b1ca01a8c5d40ea203150916363f1751", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -153,12 +153,6 @@ pub mod option;\n pub mod raw;\n pub mod result;\n \n-#[cfg(stage0)]\n-#[path = \"simd_old.rs\"]\n-pub mod simd;\n-#[cfg(not(stage0))]\n-pub mod simd;\n-\n pub mod slice;\n pub mod str;\n pub mod hash;"}, {"sha": "8af1022acdf24bdb7150653dffb213fe59501500", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -15,11 +15,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use prelude::v1::*;\n-\n use intrinsics;\n use mem;\n-use num::{Float, ParseFloatError};\n+use num::Float;\n use num::FpCategory as Fp;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -163,8 +161,6 @@ impl Float for f32 {\n     #[inline]\n     fn one() -> f32 { 1.0 }\n \n-    from_str_radix_float_impl! { f32 }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }"}, {"sha": "9486e4337bf58f56dcbd38b6527c68c73174ec5f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -15,12 +15,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use prelude::v1::*;\n-\n use intrinsics;\n use mem;\n use num::FpCategory as Fp;\n-use num::{Float, ParseFloatError};\n+use num::Float;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_docs)]\n@@ -163,8 +161,6 @@ impl Float for f64 {\n     #[inline]\n     fn one() -> f64 { 1.0 }\n \n-    from_str_radix_float_impl! { f64 }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }"}, {"sha": "b3adef53dabeebc8a7a03ed478fb691dd7ed28d6", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -18,144 +18,3 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n-\n-macro_rules! from_str_radix_float_impl {\n-    ($T:ty) => {\n-        fn from_str_radix(src: &str, radix: u32)\n-                          -> Result<$T, ParseFloatError> {\n-            use num::dec2flt::{pfe_empty, pfe_invalid};\n-\n-            // Special values\n-            match src {\n-                \"inf\"   => return Ok(Float::infinity()),\n-                \"-inf\"  => return Ok(Float::neg_infinity()),\n-                \"NaN\"   => return Ok(Float::nan()),\n-                _       => {},\n-            }\n-\n-            let (is_positive, src) =  match src.slice_shift_char() {\n-                None             => return Err(pfe_empty()),\n-                Some(('-', \"\"))  => return Err(pfe_empty()),\n-                Some(('-', src)) => (false, src),\n-                Some((_, _))     => (true,  src),\n-            };\n-\n-            // The significand to accumulate\n-            let mut sig = if is_positive { 0.0 } else { -0.0 };\n-            // Necessary to detect overflow\n-            let mut prev_sig = sig;\n-            let mut cs = src.chars().enumerate();\n-            // Exponent prefix and exponent index offset\n-            let mut exp_info = None::<(char, usize)>;\n-\n-            // Parse the integer part of the significand\n-            for (i, c) in cs.by_ref() {\n-                match c.to_digit(radix) {\n-                    Some(digit) => {\n-                        // shift significand one digit left\n-                        sig = sig * (radix as $T);\n-\n-                        // add/subtract current digit depending on sign\n-                        if is_positive {\n-                            sig = sig + ((digit as isize) as $T);\n-                        } else {\n-                            sig = sig - ((digit as isize) as $T);\n-                        }\n-\n-                        // Detect overflow by comparing to last value, except\n-                        // if we've not seen any non-zero digits.\n-                        if prev_sig != 0.0 {\n-                            if is_positive && sig <= prev_sig\n-                                { return Ok(Float::infinity()); }\n-                            if !is_positive && sig >= prev_sig\n-                                { return Ok(Float::neg_infinity()); }\n-\n-                            // Detect overflow by reversing the shift-and-add process\n-                            if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                { return Ok(Float::infinity()); }\n-                            if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                { return Ok(Float::neg_infinity()); }\n-                        }\n-                        prev_sig = sig;\n-                    },\n-                    None => match c {\n-                        'e' | 'E' | 'p' | 'P' => {\n-                            exp_info = Some((c, i + 1));\n-                            break;  // start of exponent\n-                        },\n-                        '.' => {\n-                            break;  // start of fractional part\n-                        },\n-                        _ => {\n-                            return Err(pfe_invalid())\n-                        },\n-                    },\n-                }\n-            }\n-\n-            // If we are not yet at the exponent parse the fractional\n-            // part of the significand\n-            if exp_info.is_none() {\n-                let mut power = 1.0;\n-                for (i, c) in cs.by_ref() {\n-                    match c.to_digit(radix) {\n-                        Some(digit) => {\n-                            // Decrease power one order of magnitude\n-                            power = power / (radix as $T);\n-                            // add/subtract current digit depending on sign\n-                            sig = if is_positive {\n-                                sig + (digit as $T) * power\n-                            } else {\n-                                sig - (digit as $T) * power\n-                            };\n-                            // Detect overflow by comparing to last value\n-                            if is_positive && sig < prev_sig\n-                                { return Ok(Float::infinity()); }\n-                            if !is_positive && sig > prev_sig\n-                                { return Ok(Float::neg_infinity()); }\n-                            prev_sig = sig;\n-                        },\n-                        None => match c {\n-                            'e' | 'E' | 'p' | 'P' => {\n-                                exp_info = Some((c, i + 1));\n-                                break; // start of exponent\n-                            },\n-                            _ => {\n-                                return Err(pfe_invalid())\n-                            },\n-                        },\n-                    }\n-                }\n-            }\n-\n-            // Parse and calculate the exponent\n-            let exp = match exp_info {\n-                Some((c, offset)) => {\n-                    let base = match c {\n-                        'E' | 'e' if radix == 10 => 10.0,\n-                        'P' | 'p' if radix == 16 => 2.0,\n-                        _ => return Err(pfe_invalid()),\n-                    };\n-\n-                    // Parse the exponent as decimal integer\n-                    let src = &src[offset..];\n-                    let (is_positive, exp) = match src.slice_shift_char() {\n-                        Some(('-', src)) => (false, src.parse::<usize>()),\n-                        Some(('+', src)) => (true,  src.parse::<usize>()),\n-                        Some((_, _))     => (true,  src.parse::<usize>()),\n-                        None             => return Err(pfe_invalid()),\n-                    };\n-\n-                    match (is_positive, exp) {\n-                        (true,  Ok(exp)) => base.powi(exp as i32),\n-                        (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                        (_, Err(_))      => return Err(pfe_invalid()),\n-                    }\n-                },\n-                None => 1.0, // no exponent\n-            };\n-\n-            Ok(sig * exp)\n-        }\n-    }\n-}"}, {"sha": "4f3c12567095ee2e385f4799687818c8a4b1051f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1771,12 +1771,6 @@ pub trait Float: Sized {\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n     fn one() -> Self;\n-    /// Parses the string `s` with the radix `r` as a float.\n-    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\",\n-               issue = \"27736\")]\n-    #[rustc_deprecated(since = \"1.4.0\",\n-                 reason = \"unclear how useful or correct this is\")]\n-    fn from_str_radix(s: &str, r: u32) -> Result<Self, ParseFloatError>;\n \n     /// Returns true if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]"}, {"sha": "aca36d856266b773176b331073c570f3d11e93fb", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -154,7 +154,6 @@ use mem;\n use ops::FnOnce;\n use result::Result::{Ok, Err};\n use result::Result;\n-use slice;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -269,42 +268,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `&mut [T]` (without copying)\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(as_slice)]\n-    /// # #![allow(deprecated)]\n-    ///\n-    /// let mut x = Some(\"Diamonds\");\n-    /// {\n-    ///     let v = x.as_mut_slice();\n-    ///     assert!(v == [\"Diamonds\"]);\n-    ///     v[0] = \"Dirt\";\n-    ///     assert!(v == [\"Dirt\"]);\n-    /// }\n-    /// assert_eq!(x, Some(\"Dirt\"));\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_slice\",\n-               reason = \"waiting for mut conventions\",\n-               issue = \"27776\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API, unclear of usefulness\")]\n-    #[allow(deprecated)]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        match *self {\n-            Some(ref mut x) => {\n-                let result: &mut [T] = slice::mut_ref_slice(x);\n-                result\n-            }\n-            None => {\n-                let result: &mut [T] = &mut [];\n-                result\n-            }\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////\n@@ -690,22 +653,6 @@ impl<T> Option<T> {\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n-\n-    /// Converts from `Option<T>` to `&[T]` (without copying)\n-    #[inline]\n-    #[unstable(feature = \"as_slice\", reason = \"unsure of the utility here\",\n-               issue = \"27776\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API, unclear of usefulness\")]\n-    #[allow(deprecated)]\n-    pub fn as_slice(&self) -> &[T] {\n-        match *self {\n-            Some(ref x) => slice::ref_slice(x),\n-            None => {\n-                let result: &[_] = &[];\n-                result\n-            }\n-        }\n-    }\n }\n \n impl<'a, T: Clone> Option<&'a T> {"}, {"sha": "015887e3772ad83a5d36fab7e35e498001cc0e01", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -240,7 +240,6 @@ use fmt;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSizeIterator, IntoIterator};\n use ops::FnOnce;\n use option::Option::{self, None, Some};\n-use slice;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n@@ -406,58 +405,6 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `&[T]` (without copying)\n-    #[inline]\n-    #[unstable(feature = \"as_slice\", reason = \"unsure of the utility here\",\n-               issue = \"27776\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API, unclear of usefulness\")]\n-    #[allow(deprecated)]\n-    pub fn as_slice(&self) -> &[T] {\n-        match *self {\n-            Ok(ref x) => slice::ref_slice(x),\n-            Err(_) => {\n-                // work around lack of implicit coercion from fixed-size array to slice\n-                let emp: &[_] = &[];\n-                emp\n-            }\n-        }\n-    }\n-\n-    /// Converts from `Result<T, E>` to `&mut [T]` (without copying)\n-    ///\n-    /// ```\n-    /// #![feature(as_slice)]\n-    /// # #![allow(deprecated)]\n-    ///\n-    /// let mut x: Result<&str, u32> = Ok(\"Gold\");\n-    /// {\n-    ///     let v = x.as_mut_slice();\n-    ///     assert!(v == [\"Gold\"]);\n-    ///     v[0] = \"Silver\";\n-    ///     assert!(v == [\"Silver\"]);\n-    /// }\n-    /// assert_eq!(x, Ok(\"Silver\"));\n-    ///\n-    /// let mut x: Result<&str, u32> = Err(45);\n-    /// assert!(x.as_mut_slice().is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_slice\",\n-               reason = \"waiting for mut conventions\",\n-               issue = \"27776\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"niche API, unclear of usefulness\")]\n-    #[allow(deprecated)]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        match *self {\n-            Ok(ref mut x) => slice::mut_ref_slice(x),\n-            Err(_) => {\n-                // work around lack of implicit coercion from fixed-size array to slice\n-                let emp: &mut [_] = &mut [];\n-                emp\n-            }\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "697f96ddefbf8a05fb0bda55fcdd1174bd501d8a", "filename": "src/libcore/simd.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ce132752c68aebbaf78125df4266e96e00261d36/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce132752c68aebbaf78125df4266e96e00261d36/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=ce132752c68aebbaf78125df4266e96e00261d36", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! SIMD vectors.\n-//!\n-//! These types can be used for accessing basic SIMD operations. Currently\n-//! comparison operators are not implemented. To use SSE3+, you must enable\n-//! the features, like `-C target-feature=sse3,sse4.1,sse4.2`, or a more\n-//! specific `target-cpu`. No other SIMD intrinsics or high-level wrappers are\n-//! provided beyond this module.\n-//!\n-//! # Stability Note\n-//!\n-//! These are all experimental. The interface may change entirely, without\n-//! warning.\n-\n-#![unstable(feature = \"core_simd\",\n-            reason = \"needs an RFC to flesh out the design\",\n-            issue = \"27731\")]\n-#![rustc_deprecated(since = \"1.3.0\",\n-              reason = \"use the external `simd` crate instead\")]\n-\n-#![allow(non_camel_case_types)]\n-#![allow(missing_docs)]\n-#![allow(deprecated)]\n-\n-use ops::{Add, Sub, Mul, Div, Shl, Shr, BitAnd, BitOr, BitXor};\n-\n-// FIXME(stage0): the contents of macro can be inlined.\n-// ABIs are verified as valid as soon as they are parsed, i.e. before\n-// `cfg` stripping. The `platform-intrinsic` ABI is new, so stage0\n-// doesn't know about it, but it still errors out when it hits it\n-// (despite this being in a `cfg(not(stage0))` module).\n-macro_rules! argh {\n-    () => {\n-        extern \"platform-intrinsic\" {\n-            fn simd_add<T>(x: T, y: T) -> T;\n-            fn simd_sub<T>(x: T, y: T) -> T;\n-            fn simd_mul<T>(x: T, y: T) -> T;\n-            fn simd_div<T>(x: T, y: T) -> T;\n-            fn simd_shl<T>(x: T, y: T) -> T;\n-            fn simd_shr<T>(x: T, y: T) -> T;\n-            fn simd_and<T>(x: T, y: T) -> T;\n-            fn simd_or<T>(x: T, y: T) -> T;\n-            fn simd_xor<T>(x: T, y: T) -> T;\n-        }\n-    }\n-}\n-argh!();\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n-                 pub i16, pub i16, pub i16, pub i16);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i64x2(pub i64, pub i64);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n-                 pub u16, pub u16, pub u16, pub u16);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u64x2(pub u64, pub u64);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct f64x2(pub f64, pub f64);\n-\n-macro_rules! impl_traits {\n-    ($($trayt: ident, $method: ident, $func: ident: $($ty: ty),*;)*) => {\n-        $($(\n-            impl $trayt<$ty> for $ty {\n-                type Output = Self;\n-                fn $method(self, other: Self) -> Self {\n-                    unsafe {\n-                        $func(self, other)\n-                    }\n-                }\n-            }\n-            )*)*\n-    }\n-}\n-\n-impl_traits! {\n-    Add, add, simd_add: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n-    Sub, sub, simd_sub: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n-    Mul, mul, simd_mul: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2, f32x4, f64x2;\n-\n-    Div, div, simd_div: f32x4, f64x2;\n-\n-    Shl, shl, simd_shl: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n-    Shr, shr, simd_shr: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n-    BitAnd, bitand, simd_and: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n-    BitOr, bitor, simd_or: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n-    BitXor, bitxor, simd_xor: u8x16, u16x8, u32x4, u64x2, i8x16, i16x8, i32x4, i64x2;\n-}"}, {"sha": "7ecd08bea3574fc192b3d9d2811b39e2922d264a", "filename": "src/libcore/simd_old.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ce132752c68aebbaf78125df4266e96e00261d36/src%2Flibcore%2Fsimd_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce132752c68aebbaf78125df4266e96e00261d36/src%2Flibcore%2Fsimd_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd_old.rs?ref=ce132752c68aebbaf78125df4266e96e00261d36", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! SIMD vectors.\n-//!\n-//! These types can be used for accessing basic SIMD operations. Each of them\n-//! implements the standard arithmetic operator traits (Add, Sub, Mul, Div,\n-//! Rem, Shl, Shr) through compiler magic, rather than explicitly. Currently\n-//! comparison operators are not implemented. To use SSE3+, you must enable\n-//! the features, like `-C target-feature=sse3,sse4.1,sse4.2`, or a more\n-//! specific `target-cpu`. No other SIMD intrinsics or high-level wrappers are\n-//! provided beyond this module.\n-//!\n-//! ```rust\n-//! # #![feature(core_simd)]\n-//! fn main() {\n-//!     use std::simd::f32x4;\n-//!     let a = f32x4(40.0, 41.0, 42.0, 43.0);\n-//!     let b = f32x4(1.0, 1.1, 3.4, 9.8);\n-//!     println!(\"{:?}\", a + b);\n-//! }\n-//! ```\n-//!\n-//! # Stability Note\n-//!\n-//! These are all experimental. The interface may change entirely, without\n-//! warning.\n-\n-#![unstable(feature = \"core_simd\",\n-            reason = \"needs an RFC to flesh out the design\")]\n-\n-#![allow(non_camel_case_types)]\n-#![allow(missing_docs)]\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8,\n-                 pub i8, pub i8, pub i8, pub i8);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n-                 pub i16, pub i16, pub i16, pub i16);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct i64x2(pub i64, pub i64);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8,\n-                 pub u8, pub u8, pub u8, pub u8);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n-                 pub u16, pub u16, pub u16, pub u16);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct u64x2(pub u64, pub u64);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n-\n-#[simd]\n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub struct f64x2(pub f64, pub f64);"}, {"sha": "b17fac4d77162156b6bca8af2c0afce1dc3ab425", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1380,24 +1380,6 @@ impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n // Free functions\n //\n \n-/// Converts a reference to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"ref_slice\", issue = \"27774\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"unclear whether belongs in libstd\")]\n-pub fn ref_slice<A>(s: &A) -> &[A] {\n-    unsafe {\n-        from_raw_parts(s, 1)\n-    }\n-}\n-\n-/// Converts a reference to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"ref_slice\", issue = \"27774\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"unclear whether belongs in libstd\")]\n-pub fn mut_ref_slice<A>(s: &mut A) -> &mut [A] {\n-    unsafe {\n-        from_raw_parts_mut(s, 1)\n-    }\n-}\n-\n /// Forms a slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes."}, {"sha": "ba308314e9e8feb6b097afa988c0d41089cdf2de", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -829,18 +829,6 @@ fn test_range() {\n                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n \n-#[test]\n-fn test_range_inclusive() {\n-    assert!(range_inclusive(0, 5).collect::<Vec<isize>>() ==\n-            vec![0, 1, 2, 3, 4, 5]);\n-    assert!(range_inclusive(0, 5).rev().collect::<Vec<isize>>() ==\n-            vec![5, 4, 3, 2, 1, 0]);\n-    assert_eq!(range_inclusive(200, -5).count(), 0);\n-    assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-    assert_eq!(range_inclusive(200, 200).collect::<Vec<isize>>(), [200]);\n-    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<isize>>(), [200]);\n-}\n-\n #[test]\n fn test_range_step() {\n     assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);"}, {"sha": "88f1835d2cce4b42499b1f868fbf3d6697895346", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -43,6 +43,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(clone_from_slice)]\n \n extern crate core;\n extern crate test;"}, {"sha": "65b233ee92f41c99dd0a47a884e188138a9c41f3", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -10,7 +10,6 @@\n \n use std::prelude::v1::*;\n use std::{str, mem, i16, f32, f64, fmt};\n-use std::slice::bytes;\n use std::__rand as rand;\n use rand::{Rand, XorShiftRng};\n use rand::distributions::{IndependentSample, Range};\n@@ -101,7 +100,7 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n \n     // check significant digits\n     for i in 1..cut.unwrap_or(expected.len() - 1) {\n-        bytes::copy_memory(&expected[..i], &mut expected_);\n+        expected_.clone_from_slice(&expected[..i]);\n         let mut expectedk_ = expectedk;\n         if expected[i] >= b'5' {\n             // check if this is a rounding-to-even case.\n@@ -148,7 +147,7 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n     // check infinite zero digits\n     if let Some(cut) = cut {\n         for i in cut..expected.len()-1 {\n-            bytes::copy_memory(&expected[..cut], &mut expected_);\n+            expected_.clone_from_slice(&expected[..cut]);\n             for c in &mut expected_[cut..i] { *c = b'0'; }\n \n             try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk;"}, {"sha": "09f2e3265034bdb28fd955d765a11b14a1e053a6", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -54,35 +54,6 @@ mod tests {\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n \n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n-        assert_eq!(u, None);\n-        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n-        assert_eq!(s, None);\n-        let s = \"10000000000000000000000000000000000000000\";\n-        let f : Option<f32> = f32::from_str_radix(s, 10).ok();\n-        assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = f32::from_str_radix(\"1e40\", 10).ok();\n-        assert_eq!(fe, Some(Float::infinity()));\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = f64::from_str_radix(\"-123.456\", 10).ok();\n-        assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = f32::from_str_radix(\"123.456\", 10).ok();\n-        assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = f32::from_str_radix(\"-0.0\", 10).ok();\n-        assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = f32::from_str_radix(\"0.0\", 10).ok();\n-        assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = f32::from_str_radix(\"1.0\", 10).ok();\n-        assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = f32::from_str_radix(\"-1.0\", 10).ok();\n-        assert_eq!(x5, Some(-1.0));\n-    }\n-\n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127;"}, {"sha": "cd099c69005f3a1ece79fad054ef70c48b7bdfd4", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -208,7 +208,6 @@ impl Rand for ChaChaRng {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use core::iter::order;\n     use {Rng, SeedableRng};\n     use super::ChaChaRng;\n \n@@ -217,17 +216,17 @@ mod tests {\n         let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n         let mut ra: ChaChaRng = SeedableRng::from_seed(&*s);\n         let mut rb: ChaChaRng = SeedableRng::from_seed(&*s);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_rng_seeded() {\n         let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]"}, {"sha": "dd99bc93ef379bf532beb12d14482e7bb33e486c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -544,7 +544,6 @@ impl Rand for Isaac64Rng {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use core::iter::order;\n     use {Rng, SeedableRng};\n     use super::{IsaacRng, Isaac64Rng};\n \n@@ -553,33 +552,33 @@ mod tests {\n         let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n         let mut ra: IsaacRng = SeedableRng::from_seed(&s[..]);\n         let mut rb: IsaacRng = SeedableRng::from_seed(&s[..]);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n     fn test_rng_32_seeded() {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]"}, {"sha": "db5e0213726d90951538ed28540ad5deed47a9fe", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -122,7 +122,6 @@ impl Default for ReseedWithDefault {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use core::iter::order;\n     use super::{ReseedingRng, ReseedWithDefault};\n     use {SeedableRng, Rng};\n \n@@ -167,8 +166,8 @@ mod tests {\n     fn test_rng_seeded() {\n         let mut ra: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n         let mut rb: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n-        assert!(order::equals(ra.gen_ascii_chars().take(100),\n-                              rb.gen_ascii_chars().take(100)));\n+        assert!(ra.gen_ascii_chars().take(100)\n+                  .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]"}, {"sha": "8bde24d2b0c4220abf7e197d70ea0ec67d53cc12", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -48,8 +48,8 @@ pub mod char;\n #[allow(deprecated)]\n pub mod str {\n     pub use u_str::{UnicodeStr, SplitWhitespace};\n-    pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n-    pub use u_str::{utf16_items, Utf16Encoder};\n+    pub use u_str::{utf8_char_width, is_utf16};\n+    pub use u_str::{Utf16Encoder};\n }\n \n // For use in libcollections, not re-exported in libstd."}, {"sha": "f65c05672f68bd526ee3d4254fb76376becde7e4", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 94, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -13,10 +13,8 @@\n //! This module provides functionality to `str` that requires the Unicode\n //! methods provided by the unicode parts of the CharExt trait.\n \n-use char::{DecodeUtf16, decode_utf16};\n use core::char;\n-use core::iter::{Cloned, Filter};\n-use core::slice;\n+use core::iter::Filter;\n use core::str::Split;\n \n /// An iterator over the non-whitespace substrings of a string,\n@@ -127,97 +125,6 @@ pub fn is_utf16(v: &[u16]) -> bool {\n     }\n }\n \n-/// An iterator that decodes UTF-16 encoded codepoints from a vector\n-/// of `u16`s.\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to `char::DecodeUtf16`\")]\n-#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n-#[allow(deprecated)]\n-#[derive(Clone)]\n-pub struct Utf16Items<'a> {\n-    decoder: DecodeUtf16<Cloned<slice::Iter<'a, u16>>>,\n-}\n-\n-/// The possibilities for values decoded from a `u16` stream.\n-#[rustc_deprecated(since = \"1.4.0\",\n-                   reason = \"`char::DecodeUtf16` uses `Result<char, u16>` instead\")]\n-#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n-#[allow(deprecated)]\n-#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n-pub enum Utf16Item {\n-    /// A valid codepoint.\n-    ScalarValue(char),\n-    /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16),\n-}\n-\n-#[allow(deprecated)]\n-impl Utf16Item {\n-    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n-    /// replacement character (U+FFFD).\n-    #[inline]\n-    pub fn to_char_lossy(&self) -> char {\n-        match *self {\n-            Utf16Item::ScalarValue(c) => c,\n-            Utf16Item::LoneSurrogate(_) => '\\u{FFFD}',\n-        }\n-    }\n-}\n-\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"use `char::DecodeUtf16` instead\")]\n-#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n-#[allow(deprecated)]\n-impl<'a> Iterator for Utf16Items<'a> {\n-    type Item = Utf16Item;\n-\n-    fn next(&mut self) -> Option<Utf16Item> {\n-        self.decoder.next().map(|result| {\n-            match result {\n-                Ok(c) => Utf16Item::ScalarValue(c),\n-                Err(s) => Utf16Item::LoneSurrogate(s),\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.decoder.size_hint()\n-    }\n-}\n-\n-/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n-/// returning invalid surrogates as `LoneSurrogate`s.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(unicode, decode_utf16)]\n-/// # #![allow(deprecated)]\n-///\n-/// extern crate rustc_unicode;\n-///\n-/// use rustc_unicode::str::Utf16Item::{ScalarValue, LoneSurrogate};\n-///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n-///\n-///     assert_eq!(rustc_unicode::str::utf16_items(&v).collect::<Vec<_>>(),\n-///                vec![ScalarValue('\ud834\udd1e'),\n-///                     ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///                     LoneSurrogate(0xDD1E),\n-///                     ScalarValue('i'), ScalarValue('c'),\n-///                     LoneSurrogate(0xD834)]);\n-/// }\n-/// ```\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to `char::decode_utf16`\")]\n-#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n-#[allow(deprecated)]\n-pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n-    Utf16Items { decoder: decode_utf16(v.iter().cloned()) }\n-}\n-\n /// Iterator adaptor for encoding `char`s to UTF-16.\n #[derive(Clone)]\n pub struct Utf16Encoder<I> {"}, {"sha": "9fae9af2d54d4c3a7be8a6c2533a48fb087ffb6f", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -14,7 +14,6 @@ extern crate test;\n use prelude::v1::*;\n \n use self::test::Bencher;\n-use iter::range_inclusive;\n \n #[bench]\n fn new_drop(b : &mut Bencher) {\n@@ -43,7 +42,7 @@ fn grow_by_insertion(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1, 1000) {\n+    for i in 1..1001 {\n         m.insert(i, i);\n     }\n \n@@ -61,12 +60,12 @@ fn find_existing(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1, 1000) {\n+    for i in 1..1001 {\n         m.insert(i, i);\n     }\n \n     b.iter(|| {\n-        for i in range_inclusive(1, 1000) {\n+        for i in 1..1001 {\n             m.contains_key(&i);\n         }\n     });\n@@ -78,12 +77,12 @@ fn find_nonexisting(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1, 1000) {\n+    for i in 1..1001 {\n         m.insert(i, i);\n     }\n \n     b.iter(|| {\n-        for i in range_inclusive(1001, 2000) {\n+        for i in 1001..2001 {\n             m.contains_key(&i);\n         }\n     });\n@@ -95,7 +94,7 @@ fn hashmap_as_queue(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1, 1000) {\n+    for i in 1..1001 {\n         m.insert(i, i);\n     }\n \n@@ -114,7 +113,7 @@ fn get_remove_insert(b: &mut Bencher) {\n \n     let mut m = HashMap::new();\n \n-    for i in range_inclusive(1, 1000) {\n+    for i in 1..1001 {\n         m.insert(i, i);\n     }\n "}, {"sha": "38c080febf196ac973be2adf2c3cd379cc39e97d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1681,7 +1681,6 @@ mod test_map {\n \n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n-    use iter::range_inclusive;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n \n@@ -1877,54 +1876,54 @@ mod test_map {\n         for _ in 0..10 {\n             assert!(m.is_empty());\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in 1..1001 {\n                 assert!(m.insert(i, i).is_none());\n \n-                for j in range_inclusive(1, i) {\n+                for j in 1..i+1 {\n                     let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n \n-                for j in range_inclusive(i+1, 1000) {\n+                for j in i+1..1001 {\n                     let r = m.get(&j);\n                     assert_eq!(r, None);\n                 }\n             }\n \n-            for i in range_inclusive(1001, 2000) {\n+            for i in 1001..2001 {\n                 assert!(!m.contains_key(&i));\n             }\n \n             // remove forwards\n-            for i in range_inclusive(1, 1000) {\n+            for i in 1..1001 {\n                 assert!(m.remove(&i).is_some());\n \n-                for j in range_inclusive(1, i) {\n+                for j in 1..i+1 {\n                     assert!(!m.contains_key(&j));\n                 }\n \n-                for j in range_inclusive(i+1, 1000) {\n+                for j in i+1..1001 {\n                     assert!(m.contains_key(&j));\n                 }\n             }\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in 1..1001 {\n                 assert!(!m.contains_key(&i));\n             }\n \n-            for i in range_inclusive(1, 1000) {\n+            for i in 1..1001 {\n                 assert!(m.insert(i, i).is_none());\n             }\n \n             // remove backwards\n             for i in (1..1001).rev() {\n                 assert!(m.remove(&i).is_some());\n \n-                for j in range_inclusive(i, 1000) {\n+                for j in i..1001 {\n                     assert!(!m.contains_key(&j));\n                 }\n \n-                for j in range_inclusive(1, i-1) {\n+                for j in 1..i {\n                     assert!(m.contains_key(&j));\n                 }\n             }"}, {"sha": "318ff410cbad4de25436c030a85b328549181807", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -206,18 +206,6 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a CString that was transferred to C.\n-    ///\n-    /// The only appropriate argument is a pointer obtained by calling\n-    /// `into_raw`. The length of the string will be recalculated\n-    /// using the pointer.\n-    #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n-               issue = \"27769\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to from_raw\")]\n-    pub unsafe fn from_ptr(ptr: *const c_char) -> CString {\n-        CString::from_raw(ptr as *mut _)\n-    }\n-\n     /// Retakes ownership of a CString that was transferred to C.\n     ///\n     /// The only appropriate argument is a pointer obtained by calling\n@@ -230,21 +218,6 @@ impl CString {\n         CString { inner: mem::transmute(slice) }\n     }\n \n-    /// Transfers ownership of the string to a C caller.\n-    ///\n-    /// The pointer must be returned to Rust and reconstituted using\n-    /// `from_raw` to be properly deallocated. Specifically, one\n-    /// should *not* use the standard C `free` function to deallocate\n-    /// this string.\n-    ///\n-    /// Failure to call `from_raw` will lead to a memory leak.\n-    #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n-               issue = \"27769\")]\n-    #[rustc_deprecated(since = \"1.4.0\", reason = \"renamed to into_raw\")]\n-    pub fn into_ptr(self) -> *const c_char {\n-        self.into_raw() as *const _\n-    }\n-\n     /// Transfers ownership of the string to a C caller.\n     ///\n     /// The pointer must be returned to Rust and reconstituted using"}, {"sha": "25a05efd0266640bd47249708b65ce2f0887d13a", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -1178,85 +1178,6 @@ impl Iterator for WalkDir {\n     }\n }\n \n-/// Utility methods for paths.\n-#[unstable(feature = \"path_ext_deprecated\",\n-           reason = \"The precise set of methods exposed on this trait may \\\n-                     change and some methods may be removed.  For stable code, \\\n-                     see the std::fs::metadata function.\",\n-           issue = \"27725\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with inherent methods\")]\n-pub trait PathExt {\n-    /// Gets information on the file, directory, etc at this path.\n-    ///\n-    /// Consult the `fs::metadata` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with\n-    /// `fs::metadata`.\n-    fn metadata(&self) -> io::Result<Metadata>;\n-\n-    /// Gets information on the file, directory, etc at this path.\n-    ///\n-    /// Consult the `fs::symlink_metadata` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with\n-    /// `fs::symlink_metadata`.\n-    fn symlink_metadata(&self) -> io::Result<Metadata>;\n-\n-    /// Returns the canonical form of a path, normalizing all components and\n-    /// eliminate all symlinks.\n-    ///\n-    /// This call preserves identical runtime/error semantics with\n-    /// `fs::canonicalize`.\n-    fn canonicalize(&self) -> io::Result<PathBuf>;\n-\n-    /// Reads the symlink at this path.\n-    ///\n-    /// For more information see `fs::read_link`.\n-    fn read_link(&self) -> io::Result<PathBuf>;\n-\n-    /// Reads the directory at this path.\n-    ///\n-    /// For more information see `fs::read_dir`.\n-    fn read_dir(&self) -> io::Result<ReadDir>;\n-\n-    /// Boolean value indicator whether the underlying file exists on the local\n-    /// filesystem. Returns false in exactly the cases where `fs::metadata`\n-    /// fails.\n-    fn exists(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) points at a \"regular file\" on the FS. Will return false for paths\n-    /// to non-existent locations or directories or other non-regular files\n-    /// (named pipes, etc). Follows links when making this determination.\n-    fn is_file(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) is pointing at a directory in the underlying FS. Will return\n-    /// false for paths to non-existent locations or if the item is not a\n-    /// directory (eg files, named pipes, etc). Follows links when making this\n-    /// determination.\n-    fn is_dir(&self) -> bool;\n-}\n-\n-#[allow(deprecated)]\n-#[unstable(feature = \"path_ext_deprecated\", issue = \"27725\")]\n-impl PathExt for Path {\n-    fn metadata(&self) -> io::Result<Metadata> { metadata(self) }\n-    fn symlink_metadata(&self) -> io::Result<Metadata> { symlink_metadata(self) }\n-    fn canonicalize(&self) -> io::Result<PathBuf> { canonicalize(self) }\n-    fn read_link(&self) -> io::Result<PathBuf> { read_link(self) }\n-    fn read_dir(&self) -> io::Result<ReadDir> { read_dir(self) }\n-    fn exists(&self) -> bool { metadata(self).is_ok() }\n-\n-    fn is_file(&self) -> bool {\n-        metadata(self).map(|s| s.is_file()).unwrap_or(false)\n-    }\n-\n-    fn is_dir(&self) -> bool {\n-        metadata(self).map(|s| s.is_dir()).unwrap_or(false)\n-    }\n-}\n-\n /// Changes the permissions found on a file or a directory.\n ///\n /// # Examples"}, {"sha": "8772d0f5b099bef112772371d9cb0dd0f3f28353", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -22,6 +22,3 @@\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use super::{Read, Write, BufRead, Seek};\n-#[allow(deprecated)]\n-#[unstable(feature = \"path_ext_deprecated\", issue = \"27725\")]\n-pub use fs::PathExt;"}, {"sha": "c8b8caee84ee68926577901fb15bae906dbc1065", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -233,7 +233,6 @@\n #![feature(const_fn)]\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n-#![feature(core_simd)]\n #![feature(decode_utf16)]\n #![feature(drop_in_place)]\n #![feature(dropck_parametricity)]\n@@ -255,6 +254,7 @@\n #![feature(rand)]\n #![feature(range_inclusive)]\n #![feature(raw)]\n+#![feature(repr_simd)]\n #![feature(reflect_marker)]\n #![feature(shared)]\n #![feature(slice_bytes)]\n@@ -334,9 +334,6 @@ pub use core::ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::raw;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use core::simd;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::option;"}, {"sha": "30bee80fbf658859f5585f2d8d96be8a14598481", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -18,7 +18,7 @@\n use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{FpCategory, ParseFloatError};\n+use num::FpCategory;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n@@ -126,16 +126,6 @@ mod cmath {\n #[cfg(not(test))]\n #[lang = \"f32\"]\n impl f32 {\n-    /// Parses a float as with a given radix\n-    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\",\n-               issue = \"27736\")]\n-    #[rustc_deprecated(since = \"1.4.0\",\n-                 reason = \"unclear how useful or correct this is\")]\n-    #[allow(deprecated)]\n-    pub fn from_str_radix(s: &str, radix: u32) -> Result<f32, ParseFloatError> {\n-        num::Float::from_str_radix(s, radix)\n-    }\n-\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -1712,11 +1702,9 @@ mod tests {\n \n     #[test]\n     fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = f32::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        let f1 = 2.0f32.powi(-123);\n+        let f2 = 2.0f32.powi(-111);\n+        let f3 = 1.75 * 2.0f32.powi(-12);\n         assert_eq!(f32::ldexp(1f32, -123), f1);\n         assert_eq!(f32::ldexp(1f32, -111), f2);\n         assert_eq!(f32::ldexp(1.75f32, -12), f3);\n@@ -1734,11 +1722,9 @@ mod tests {\n \n     #[test]\n     fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = f32::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1 = 2.0f32.powi(-123);\n+        let f2 = 2.0f32.powi(-111);\n+        let f3 = 1.75 * 2.0f32.powi(-123);\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();"}, {"sha": "d444b2594453cef35bca319adc7a86fcc210cfc0", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -18,7 +18,7 @@\n use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{FpCategory, ParseFloatError};\n+use num::FpCategory;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n@@ -83,16 +83,6 @@ mod cmath {\n #[cfg(not(test))]\n #[lang = \"f64\"]\n impl f64 {\n-    /// Parses a float as with a given radix\n-    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\",\n-               issue = \"27736\")]\n-    #[rustc_deprecated(since = \"1.4.0\",\n-                 reason = \"unclear how useful or correct this is\")]\n-    #[allow(deprecated)]\n-    pub fn from_str_radix(s: &str, radix: u32) -> Result<f64, ParseFloatError> {\n-        num::Float::from_str_radix(s, radix)\n-    }\n-\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -1569,11 +1559,9 @@ mod tests {\n \n     #[test]\n     fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = f64::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        let f1 = 2.0f64.powi(-123);\n+        let f2 = 2.0f64.powi(-111);\n+        let f3 = 1.75 * 2.0f64.powi(-12);\n         assert_eq!(f64::ldexp(1f64, -123), f1);\n         assert_eq!(f64::ldexp(1f64, -111), f2);\n         assert_eq!(f64::ldexp(1.75f64, -12), f3);\n@@ -1591,11 +1579,9 @@ mod tests {\n \n     #[test]\n     fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = f64::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1 = 2.0f64.powi(-123);\n+        let f2 = 2.0f64.powi(-111);\n+        let f3 = 1.75 * 2.0f64.powi(-123);\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();"}, {"sha": "5e0368f35cc74e4fc867798bef10ad7196472ec7", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -16,7 +16,10 @@ use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort};\n use os::raw::{c_char, c_short, c_ulonglong};\n use libc::{wchar_t, size_t, c_void};\n use ptr;\n-use simd;\n+\n+#[cfg_attr(not(stage0), repr(simd))]\n+#[repr(C)]\n+struct u64x2(u64, u64);\n \n pub use self::GET_FILEEX_INFO_LEVELS::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n@@ -783,7 +786,7 @@ pub struct FLOATING_SAVE_AREA {\n #[cfg(target_arch = \"x86_64\")]\n #[repr(C)]\n pub struct CONTEXT {\n-    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    _align_hack: [u64x2; 0], // FIXME align on 16-byte\n     pub P1Home: DWORDLONG,\n     pub P2Home: DWORDLONG,\n     pub P3Home: DWORDLONG,\n@@ -843,15 +846,15 @@ pub struct CONTEXT {\n #[cfg(target_arch = \"x86_64\")]\n #[repr(C)]\n pub struct M128A {\n-    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    _align_hack: [u64x2; 0], // FIXME align on 16-byte\n     pub Low:  c_ulonglong,\n     pub High: c_longlong\n }\n \n #[cfg(target_arch = \"x86_64\")]\n #[repr(C)]\n pub struct FLOATING_SAVE_AREA {\n-    _align_hack: [simd::u64x2; 0], // FIXME align on 16-byte\n+    _align_hack: [u64x2; 0], // FIXME align on 16-byte\n     _Dummy: [u8; 512] // FIXME: Fill this out\n }\n "}, {"sha": "21ac23253c86a7d16ac5a0e2ee21408638bfd2c9", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ce132752c68aebbaf78125df4266e96e00261d36", "patch": "@@ -1,209 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-#![feature(core_simd, core)]\n-\n-// ignore-pretty very bad with line comments\n-\n-use std::env;\n-use std::io::prelude::*;\n-use std::io;\n-use std::simd::f64x2;\n-use std::sync::Arc;\n-use std::thread;\n-\n-const ITER: usize = 50;\n-const LIMIT: f64 = 2.0;\n-const WORKERS: usize = 16;\n-\n-fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n-    assert_eq!(WORKERS % 2, 0);\n-\n-    // Ensure w and h are multiples of 8.\n-    let w = (w + 7) / 8 * 8;\n-    let h = w;\n-\n-    let chunk_size = h / WORKERS;\n-\n-    // Account for remainders in workload division, e.g. 1000 / 16 = 62.5\n-    let last_chunk_size = if h % WORKERS != 0 {\n-        chunk_size + h % WORKERS\n-    } else {\n-        chunk_size\n-    };\n-\n-    // precalc values\n-    let inverse_w_doubled = 2.0 / w as f64;\n-    let inverse_h_doubled = 2.0 / h as f64;\n-    let v_inverses = f64x2(inverse_w_doubled, inverse_h_doubled);\n-    let v_consts = f64x2(1.5, 1.0);\n-\n-    // A lot of this code assumes this (so do other lang benchmarks)\n-    assert_eq!(w, h);\n-    let mut precalc_r = Vec::with_capacity(w);\n-    let mut precalc_i = Vec::with_capacity(h);\n-\n-    let precalc_futures = (0..WORKERS).map(|i| {\n-        thread::spawn(move|| {\n-            let mut rs = Vec::with_capacity(w / WORKERS);\n-            let mut is = Vec::with_capacity(w / WORKERS);\n-\n-            let start = i * chunk_size;\n-            let end = if i == (WORKERS - 1) {\n-                start + last_chunk_size\n-            } else {\n-                (i + 1) * chunk_size\n-            };\n-\n-            // This assumes w == h\n-            for x in start..end {\n-                let xf = x as f64;\n-                let xy = f64x2(xf, xf);\n-\n-                let f64x2(r, i) = xy * v_inverses - v_consts;\n-                rs.push(r);\n-                is.push(i);\n-            }\n-\n-            (rs, is)\n-        })\n-    }).collect::<Vec<_>>();\n-\n-    for res in precalc_futures {\n-        let (rs, is) = res.join().unwrap();\n-        precalc_r.extend(rs);\n-        precalc_i.extend(is);\n-    }\n-\n-    assert_eq!(precalc_r.len(), w);\n-    assert_eq!(precalc_i.len(), h);\n-\n-    let arc_init_r = Arc::new(precalc_r);\n-    let arc_init_i = Arc::new(precalc_i);\n-\n-    let data = (0..WORKERS).map(|i| {\n-        let vec_init_r = arc_init_r.clone();\n-        let vec_init_i = arc_init_i.clone();\n-\n-        thread::spawn(move|| {\n-            let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n-            let init_r_slice = vec_init_r;\n-\n-            let start = i * chunk_size;\n-            let end = if i == (WORKERS - 1) {\n-                start + last_chunk_size\n-            } else {\n-                (i + 1) * chunk_size\n-            };\n-\n-            for &init_i in &vec_init_i[start..end] {\n-                write_line(init_i, &init_r_slice, &mut res);\n-            }\n-\n-            res\n-        })\n-    }).collect::<Vec<_>>();\n-\n-    try!(writeln!(&mut out, \"P4\\n{} {}\", w, h));\n-    for res in data {\n-        try!(out.write_all(&res.join().unwrap()));\n-    }\n-    out.flush()\n-}\n-\n-fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n-    let v_init_i : f64x2 = f64x2(init_i, init_i);\n-    let v_2 : f64x2 = f64x2(2.0, 2.0);\n-    const LIMIT_SQUARED: f64 = LIMIT * LIMIT;\n-\n-    for chunk_init_r in vec_init_r.chunks(8) {\n-        let mut cur_byte = 0xff;\n-        let mut i = 0;\n-\n-        while i < 8 {\n-            let v_init_r = f64x2(chunk_init_r[i], chunk_init_r[i + 1]);\n-            let mut cur_r = v_init_r;\n-            let mut cur_i = v_init_i;\n-            let mut r_sq = v_init_r * v_init_r;\n-            let mut i_sq = v_init_i * v_init_i;\n-\n-            let mut b = 0;\n-            for _ in 0..ITER {\n-                let r = cur_r;\n-                let i = cur_i;\n-\n-                cur_i = v_2 * r * i + v_init_i;\n-                cur_r = r_sq - i_sq + v_init_r;\n-\n-                let f64x2(bit1, bit2) = r_sq + i_sq;\n-\n-                if bit1 > LIMIT_SQUARED {\n-                    b |= 2;\n-                    if b == 3 { break; }\n-                }\n-\n-                if bit2 > LIMIT_SQUARED {\n-                    b |= 1;\n-                    if b == 3 { break; }\n-                }\n-\n-                r_sq = cur_r * cur_r;\n-                i_sq = cur_i * cur_i;\n-            }\n-\n-            cur_byte = (cur_byte << 2) + b;\n-            i += 2;\n-        }\n-\n-        res.push(cur_byte^!0);\n-    }\n-}\n-\n-fn main() {\n-    let mut args = env::args();\n-    let res = if args.len() < 2 {\n-        println!(\"Test mode: do not dump the image because it's not utf8, \\\n-                  which interferes with the test runner.\");\n-        mandelbrot(1000, io::sink())\n-    } else {\n-        mandelbrot(args.nth(1).unwrap().parse().unwrap(), io::stdout())\n-    };\n-    res.unwrap();\n-}"}, {"sha": "a6c77eaf7c63091839277a74df50700125029bbe", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=ce132752c68aebbaf78125df4266e96e00261d36", "patch": "@@ -1,123 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2012-2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-// no-pretty-expanded FIXME #15189\n-\n-#![allow(non_snake_case)]\n-#![feature(unboxed_closures, iter_arith, core_simd, scoped)]\n-\n-use std::thread;\n-use std::env;\n-use std::simd::f64x2;\n-\n-fn main() {\n-    let mut args = env::args();\n-    let answer = spectralnorm(if env::var_os(\"RUST_BENCH\").is_some() {\n-        5500\n-    } else if args.len() < 2 {\n-        2000\n-    } else {\n-        args.nth(1).unwrap().parse().unwrap()\n-    });\n-    println!(\"{:.9}\", answer);\n-}\n-\n-fn spectralnorm(n: usize) -> f64 {\n-    assert!(n % 2 == 0, \"only even lengths are accepted\");\n-    let mut u = vec![1.0; n];\n-    let mut v = u.clone();\n-    let mut tmp = v.clone();\n-    for _ in 0..10 {\n-        mult_AtAv(&u, &mut v, &mut tmp);\n-        mult_AtAv(&v, &mut u, &mut tmp);\n-    }\n-    (dot(&u, &v) / dot(&v, &v)).sqrt()\n-}\n-\n-fn mult_AtAv(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {\n-    mult_Av(v, tmp);\n-    mult_Atv(tmp, out);\n-}\n-\n-fn mult_Av(v: &[f64], out: &mut [f64]) {\n-    parallel(out, |start, out| mult(v, out, start, |i, j| A(i, j)));\n-}\n-\n-fn mult_Atv(v: &[f64], out: &mut [f64]) {\n-    parallel(out, |start, out| mult(v, out, start, |i, j| A(j, i)));\n-}\n-\n-fn mult<F>(v: &[f64], out: &mut [f64], start: usize, a: F)\n-           where F: Fn(usize, usize) -> f64 {\n-    for (i, slot) in out.iter_mut().enumerate().map(|(i, s)| (i + start, s)) {\n-        let mut sum = f64x2(0.0, 0.0);\n-        for (j, chunk) in v.chunks(2).enumerate().map(|(j, s)| (2 * j, s)) {\n-            let top = f64x2(chunk[0], chunk[1]);\n-            let bot = f64x2(a(i, j), a(i, j + 1));\n-            sum = sum + top / bot;\n-        }\n-        let f64x2(a, b) = sum;\n-        *slot = a + b;\n-    }\n-}\n-\n-fn A(i: usize, j: usize) -> f64 {\n-    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n-}\n-\n-fn dot(v: &[f64], u: &[f64]) -> f64 {\n-    v.iter().zip(u).map(|(a, b)| *a * *b).sum()\n-}\n-\n-\n-// Executes a closure in parallel over the given mutable slice. The closure `f`\n-// is run in parallel and yielded the starting index within `v` as well as a\n-// sub-slice of `v`.\n-fn parallel<'a,T, F>(v: &mut [T], ref f: F)\n-                  where T: Send + Sync + 'a,\n-                        F: Fn(usize, &mut [T]) + Sync + 'a {\n-    // FIXME: pick a more appropriate parallel factor\n-    // FIXME: replace with thread::scoped when it exists again\n-    let parallelism = 4;\n-    let size = v.len() / parallelism + 1;\n-    v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n-        f(i * size, chunk)\n-    }).collect::<Vec<_>>();\n-}"}, {"sha": "31c055f229c3e7a66bdc216563393f6420548ef1", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, core_simd)]\n-#![allow(dead_code, deprecated)]\n+#![feature(repr_simd)]\n+#![allow(dead_code)]\n \n-use std::simd::f32x4;\n-\n-#[repr(simd)] #[derive(Copy, Clone)] #[repr(C)] struct LocalSimd(u8, u8);\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+struct LocalSimd(u8, u8);\n \n extern {\n-    fn foo() -> f32x4; //~ ERROR use of SIMD type\n-    fn bar(x: f32x4); //~ ERROR use of SIMD type\n-\n     fn baz() -> LocalSimd; //~ ERROR use of SIMD type\n     fn qux(x: LocalSimd); //~ ERROR use of SIMD type\n }"}, {"sha": "620e1a73b4d64c7e10dd6370333df957add4ff14", "filename": "src/test/debuginfo/simd.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Fdebuginfo%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimd.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -43,9 +43,28 @@\n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n-#![feature(core_simd)]\n+#![feature(repr_simd)]\n \n-use std::simd::{i8x16, i16x8,i32x4,i64x2,u8x16,u16x8,u32x4,u64x2,f32x4,f64x2};\n+#[repr(simd)]\n+struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+#[repr(simd)]\n+struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+#[repr(simd)]\n+struct i32x4(i32, i32, i32, i32);\n+#[repr(simd)]\n+struct i64x2(i64, i64);\n+#[repr(simd)]\n+struct u8x16(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8);\n+#[repr(simd)]\n+struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);\n+#[repr(simd)]\n+struct u32x4(u32, u32, u32, u32);\n+#[repr(simd)]\n+struct u64x2(u64, u64);\n+#[repr(simd)]\n+struct f32x4(f32, f32, f32, f32);\n+#[repr(simd)]\n+struct f64x2(f64, f64);\n \n fn main() {\n "}, {"sha": "562cfbe7a148a2006b487caa48d990b236c29a59", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -12,8 +12,7 @@\n // type is `&mut [u8]`, passes in a pointer to the lvalue and not a\n // temporary. Issue #19147.\n \n-\n-#![feature(slice_bytes)]\n+#![feature(clone_from_slice)]\n \n use std::slice;\n \n@@ -23,7 +22,7 @@ trait MyWriter {\n \n impl<'a> MyWriter for &'a mut [u8] {\n     fn my_write(&mut self, buf: &[u8]) -> Result<(), ()> {\n-        slice::bytes::copy_memory(buf, *self);\n+        self.clone_from_slice(buf);\n \n         let write_len = buf.len();\n         unsafe {"}, {"sha": "c3eef0f9c3217a0e01fee6f2d7b921560a69eca4", "filename": "src/test/run-pass/simd-issue-10604.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce132752c68aebbaf78125df4266e96e00261d36/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-issue-10604.rs?ref=ce132752c68aebbaf78125df4266e96e00261d36", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(core_simd)]\n-\n-pub fn main() {\n-    let _o = None::<std::simd::i32x4>;\n-}"}, {"sha": "931789948159d79cead4c66e0c8c859d6e563dff", "filename": "src/test/run-pass/sync-send-iterators-in-libcore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -14,11 +14,10 @@\n #![feature(iter_empty)]\n #![feature(iter_once)]\n #![feature(iter_unfold)]\n-#![feature(range_inclusive)]\n #![feature(step_by)]\n #![feature(str_escape)]\n \n-use std::iter::{empty, once, range_inclusive, repeat};\n+use std::iter::{empty, once, repeat};\n \n fn is_sync<T>(_: T) where T: Sync {}\n fn is_send<T>(_: T) where T: Send {}\n@@ -98,7 +97,6 @@ fn main() {\n                    inspect(|_| ()));\n \n     is_sync_send!((1..).step_by(2));\n-    is_sync_send!(range_inclusive(1, 1));\n     is_sync_send!((1..2).step_by(2));\n     is_sync_send!((1..2));\n     is_sync_send!((1..));"}, {"sha": "9ffba2c7999f1770966643689706329ec802a9eb", "filename": "src/test/run-pass/while-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cd3a4ae7d82775b74f8199139a020323375c06/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=47cd3a4ae7d82775b74f8199139a020323375c06", "patch": "@@ -14,7 +14,7 @@\n use std::collections::BinaryHeap;\n \n fn make_pq() -> BinaryHeap<isize> {\n-    BinaryHeap::from_vec(vec![1,2,3])\n+    BinaryHeap::from(vec![1,2,3])\n }\n \n pub fn main() {"}]}