{"sha": "7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOTlhMDJkZGIzZmYzMDM4OGFlMWRkNWRiMDZlMzMyYzIxNWZlYTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-07T23:37:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-08T14:54:20Z"}, "message": "syntax: Remove uses of DVec", "tree": {"sha": "cfea745b79f58bad9266ddcb80490be166a45f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfea745b79f58bad9266ddcb80490be166a45f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "html_url": "https://github.com/rust-lang/rust/commit/7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a72099063b21abc84145960a14224458b6dc37c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a72099063b21abc84145960a14224458b6dc37c", "html_url": "https://github.com/rust-lang/rust/commit/2a72099063b21abc84145960a14224458b6dc37c"}], "stats": {"total": 68, "additions": 29, "deletions": 39}, "files": [{"sha": "3397ca91c9624f6d6e05fc310d771015141a063c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -24,7 +24,6 @@ source code snippets, etc.\n use core::prelude::*;\n \n use core::cmp;\n-use core::dvec::DVec;\n use core::str;\n use core::to_bytes;\n use core::uint;\n@@ -242,7 +241,7 @@ pub struct FileMap {\n     /// Locations of lines beginnings in the source code\n     lines: @mut ~[BytePos],\n     /// Locations of multi-byte characters in the source code\n-    multibyte_chars: DVec<MultiByteChar>\n+    multibyte_chars: @mut ~[MultiByteChar],\n }\n \n pub impl FileMap {\n@@ -282,13 +281,13 @@ pub impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: DVec<@FileMap>\n+    files: @mut ~[@FileMap]\n }\n \n pub impl CodeMap {\n     static pub fn new() -> CodeMap {\n         CodeMap {\n-            files: DVec()\n+            files: @mut ~[],\n         }\n     }\n \n@@ -315,7 +314,7 @@ pub impl CodeMap {\n             name: filename, substr: substr, src: src,\n             start_pos: BytePos(start_pos),\n             lines: @mut ~[],\n-            multibyte_chars: DVec()\n+            multibyte_chars: @mut ~[],\n         };\n \n         self.files.push(filemap);"}, {"sha": "33e734fbd64ccea14eabffd06c17a02f99850521", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -18,7 +18,6 @@ use core::io;\n use core::option;\n use core::str;\n use core::vec;\n-use core::dvec::DVec;\n \n use std::term;\n \n@@ -203,7 +202,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-pub fn collect(messages: @DVec<~str>)\n+pub fn collect(messages: @mut ~[~str])\n             -> @fn(Option<(@codemap::CodeMap, span)>, &str, level) {\n     let f: @fn(Option<(@codemap::CodeMap, span)>, &str, level) =\n         |_o, msg: &str, _l| { messages.push(msg.to_str()); };"}, {"sha": "a1514bc3eabdb9c0e27da817e3626ab56cf838a9", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -29,7 +29,6 @@ use parse::token::special_idents::clownshoes_extensions;\n use ast_util;\n use opt_vec;\n \n-use core::dvec;\n use core::uint;\n \n enum Junction {\n@@ -99,7 +98,7 @@ fn expand_deriving(cx: ext_ctxt,\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n                    expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n                 -> ~[@item] {\n-    let result = dvec::DVec();\n+    let mut result = ~[];\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n@@ -120,7 +119,7 @@ fn expand_deriving(cx: ext_ctxt,\n             _ => ()\n         }\n     }\n-    dvec::unwrap(result)\n+    result\n }\n \n fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n@@ -202,14 +201,13 @@ fn create_self_type_with_params(cx: ext_ctxt,\n                                 generics: &Generics)\n                              -> @Ty {\n     // Create the type parameters on the `self` path.\n-    let self_ty_params = dvec::DVec();\n+    let mut self_ty_params = ~[];\n     for generics.ty_params.each |ty_param| {\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n         self_ty_params.push(self_ty_param);\n     }\n-    let self_ty_params = dvec::unwrap(self_ty_params);\n \n     // Create the type of `self`.\n     let self_type = build::mk_raw_path_(span,\n@@ -433,7 +431,7 @@ fn create_subpatterns(cx: ext_ctxt,\n                       prefix: ~str,\n                       n: uint)\n                    -> ~[@pat] {\n-    let subpats = dvec::DVec();\n+    let mut subpats = ~[];\n     for uint::range(0, n) |_i| {\n         // Create the subidentifier.\n         let index = subpats.len().to_str();\n@@ -445,7 +443,7 @@ fn create_subpatterns(cx: ext_ctxt,\n         let subpat = build::mk_pat(cx, span, subpat);\n         subpats.push(subpat);\n     }\n-    return dvec::unwrap(subpats);\n+    return subpats;\n }\n \n fn is_struct_tuple(struct_def: &struct_def) -> bool {\n@@ -809,7 +807,7 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     let self_ident = cx.ident_of(~\"self\");\n \n     // Create the body of the method.\n-    let statements = dvec::DVec();\n+    let mut statements = ~[];\n     for struct_def.fields.each |struct_field| {\n         match struct_field.node.kind {\n             named_field(ident, _, _) => {\n@@ -833,7 +831,6 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let statements = dvec::unwrap(statements);\n     return create_iter_bytes_method(cx, span, statements);\n }\n \n@@ -942,9 +939,9 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n     }\n \n     // Create the arms of the self match in the method body.\n-    let self_arms = dvec::DVec();\n+    let mut self_arms = ~[];\n     for enum_definition.variants.each |self_variant| {\n-        let other_arms = dvec::DVec();\n+        let mut other_arms = ~[];\n \n         // Create the matching pattern.\n         let matching_pat = create_enum_variant_pattern(cx,\n@@ -1026,7 +1023,6 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // Create the self pattern body.\n         let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n         let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_arms = dvec::unwrap(other_arms);\n         let other_match_expr = expr_match(other_expr, other_arms);\n         let other_match_expr = build::mk_expr(cx,\n                                               span,\n@@ -1047,7 +1043,6 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n     // Create the method body.\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_arms = dvec::unwrap(self_arms);\n     let self_match_expr = expr_match(self_expr, self_arms);\n     let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n@@ -1148,7 +1143,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Feed the discriminant to the byte iteration function.\n-        let stmts = dvec::DVec();\n+        let mut stmts = ~[];\n         let discrim_stmt = call_substructure_iter_bytes_method(cx,\n                                                                span,\n                                                                discriminant);\n@@ -1167,7 +1162,6 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Create the pattern body.\n-        let stmts = dvec::unwrap(stmts);\n         let match_body_block = build::mk_block_(cx, span, stmts);\n \n         // Create the arm."}, {"sha": "88797a152066a9045e322d4f341242294b49de9a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -19,8 +19,6 @@ use parse::parser::Parser;\n use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::token;\n \n-use core::dvec::DVec;\n-use core::dvec;\n use core::option::{Option, Some, None};\n use core::str;\n use core::uint;\n@@ -115,7 +113,7 @@ pub struct MatcherPos {\n     sep: Option<Token>,\n     idx: uint,\n     up: matcher_pos_up, // mutable for swapping only\n-    matches: ~[DVec<@named_match>],\n+    matches: ~[~[@named_match]],\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n@@ -151,7 +149,7 @@ pub fn initial_matcher_pos(+ms: ~[matcher], +sep: Option<Token>, lo: BytePos)\n           }\n         }\n     }\n-    let matches = vec::from_fn(count_names(ms), |_i| dvec::DVec());\n+    let matches = vec::from_fn(count_names(ms), |_i| ~[]);\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n@@ -283,7 +281,7 @@ pub fn parse(\n \n                         // Only touch the binders we have actually bound\n                         for uint::range(ei.match_lo, ei.match_hi) |idx| {\n-                            let sub = ei.matches[idx].get();\n+                            let sub = ei.matches[idx];\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n                                                    mk_sp(ei.sp_lo,\n@@ -331,7 +329,7 @@ pub fn parse(\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n-                                           |_m| DVec::<@named_match>());\n+                                           |_m| ~[]);\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: copy *matchers,\n@@ -358,9 +356,11 @@ pub fn parse(\n         /* error messages here could be improved with links to orig. rules */\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n-                return success(\n-                    nameize(sess, ms,\n-                            eof_eis[0u].matches.map(|dv| dv.pop())));\n+                let mut v = ~[];\n+                for vec::each_mut(eof_eis[0u].matches) |dv| {\n+                    v.push(dv.pop());\n+                }\n+                return success(nameize(sess, ms, v));\n             } else if eof_eis.len() > 1u {\n                 return error(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {"}, {"sha": "c68341c20fa4c273b38f058be092e4ee2213f1b1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -28,7 +28,6 @@ use print::pp;\n use print::pprust;\n \n use core::char;\n-use core::dvec::DVec;\n use core::io;\n use core::str;\n use core::u64;\n@@ -63,7 +62,7 @@ pub struct ps {\n     comments: Option<~[comments::cmnt]>,\n     literals: Option<~[comments::lit]>,\n     cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n-    boxes: DVec<pp::breaks>,\n+    boxes: @mut ~[pp::breaks],\n     ann: pp_ann\n }\n \n@@ -88,7 +87,7 @@ pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> @ps {\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: DVec(),\n+        boxes: @mut ~[],\n         ann: no_ann()\n     };\n }\n@@ -123,7 +122,7 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: DVec(),\n+        boxes: @mut ~[],\n         ann: ann\n     };\n     print_crate_(s, crate);"}, {"sha": "7a5708049e9f400bc63a84672baf7ccde58e0f3a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f99a02ddb3ff30388ae1dd5db06e332c215fea2/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7f99a02ddb3ff30388ae1dd5db06e332c215fea2", "patch": "@@ -13,20 +13,19 @@\n // type, and vice versa.\n \n use core::prelude::*;\n-use core::dvec::DVec;\n use core::hashmap::linear::LinearMap;\n \n pub struct Interner<T> {\n     priv map: @mut LinearMap<T, uint>,\n-    priv vect: DVec<T>,\n+    priv vect: @mut ~[T],\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     static fn new() -> Interner<T> {\n         Interner {\n             map: @mut LinearMap::new(),\n-            vect: DVec(),\n+            vect: @mut ~[],\n         }\n     }\n \n@@ -58,7 +57,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(&self, idx: uint) -> T { self.vect.get_elt(idx) }\n+    pure fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     fn len(&self) -> uint { self.vect.len() }\n }"}]}