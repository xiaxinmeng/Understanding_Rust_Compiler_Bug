{"sha": "8a69a00941ddb06254abe8633a4f721fd0576266", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjlhMDA5NDFkZGIwNjI1NGFiZTg2MzNhNGY3MjFmZDA1NzYyNjY=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2015-11-04T06:02:22Z"}, "committer": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2015-11-05T02:38:03Z"}, "message": "Unwrap the RefCell around DefMap", "tree": {"sha": "6cea65b2f46d3ca5550e206cbbbe2189e3c8becd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cea65b2f46d3ca5550e206cbbbe2189e3c8becd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a69a00941ddb06254abe8633a4f721fd0576266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a69a00941ddb06254abe8633a4f721fd0576266", "html_url": "https://github.com/rust-lang/rust/commit/8a69a00941ddb06254abe8633a4f721fd0576266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a69a00941ddb06254abe8633a4f721fd0576266/comments", "author": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "effcd29652bbf16981d9cd0d8a578681b2ed55bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/effcd29652bbf16981d9cd0d8a578681b2ed55bb", "html_url": "https://github.com/rust-lang/rust/commit/effcd29652bbf16981d9cd0d8a578681b2ed55bb"}], "stats": {"total": 64, "additions": 33, "deletions": 31}, "files": [{"sha": "cfd7d3548e06539be52cb0e5c49e911997d01d6c", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -27,7 +27,7 @@ use std::cell::RefCell;\n \n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a DefMap,\n+    def_map: &'a RefCell<DefMap>,\n     ast_map: &'a ast_map::Map<'ast>,\n     // `discriminant_map` is a cache that associates the `NodeId`s of local\n     // variant definitions with the discriminant expression that applies to\n@@ -92,7 +92,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n \n pub fn check_crate<'ast>(sess: &Session,\n                          krate: &'ast hir::Crate,\n-                         def_map: &DefMap,\n+                         def_map: &RefCell<DefMap>,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n@@ -108,7 +108,7 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n-    def_map: &'a DefMap,\n+    def_map: &'a RefCell<DefMap>,\n     discriminant_map: &'a RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n     idstack: Vec<ast::NodeId>,\n }"}, {"sha": "b1d24187957535040a75be1a5a394061954b16cb", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -17,8 +17,6 @@ use util::nodemap::NodeMap;\n use syntax::ast;\n use rustc_front::hir;\n \n-use std::cell::RefCell;\n-\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     DefFn(DefId, bool /* is_ctor */),\n@@ -103,7 +101,7 @@ impl PathResolution {\n }\n \n // Definition mapping\n-pub type DefMap = RefCell<NodeMap<PathResolution>>;\n+pub type DefMap = NodeMap<PathResolution>;\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;"}, {"sha": "77ffd0b606ebe989bd9521bbeb5ac82e8dffde94", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -18,19 +18,21 @@ use rustc_front::hir;\n use rustc_front::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n+use std::cell::RefCell;\n+\n pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &DefMap, pat: &hir::Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n }\n \n-pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_refutable(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatLit(_) | hir::PatRange(_, _) | hir::PatQPath(..) => true,\n         hir::PatEnum(_, _) |\n@@ -46,7 +48,7 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatEnum(_, _) |\n         hir::PatIdent(_, _, None) |\n@@ -60,7 +62,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n@@ -74,7 +76,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n // Same as above, except that partially-resolved defs cause `false` to be\n // returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_resolved_const(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n             match dm.borrow().get(&pat.id)\n@@ -88,7 +90,7 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -98,7 +100,7 @@ pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(..) => pat_is_binding(dm, pat),\n         hir::PatWild => true,\n@@ -108,7 +110,7 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n+pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n {\n     walk_pat(pat, |p| {\n@@ -122,7 +124,7 @@ pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n     });\n }\n \n-pub fn pat_bindings_hygienic<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n+pub fn pat_bindings_hygienic<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Ident>),\n {\n     walk_pat(pat, |p| {\n@@ -138,7 +140,7 @@ pub fn pat_bindings_hygienic<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n@@ -153,7 +155,7 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n /// and if yes wether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(dm: &DefMap, pat: &hir::Pat) -> Option<hir::Mutability> {\n+pub fn pat_contains_ref_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Option<hir::Mutability> {\n     let mut result = None;\n     pat_bindings(dm, pat, |mode, _, _, _| {\n         match mode {\n@@ -172,7 +174,7 @@ pub fn pat_contains_ref_binding(dm: &DefMap, pat: &hir::Pat) -> Option<hir::Muta\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n /// bindings, and if yes wether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(dm: &DefMap, arm: &hir::Arm) -> Option<hir::Mutability> {\n+pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<hir::Mutability> {\n     arm.pats.iter()\n             .filter_map(|pat| pat_contains_ref_binding(dm, pat))\n             .max_by(|m| match *m {\n@@ -183,7 +185,7 @@ pub fn arm_contains_ref_binding(dm: &DefMap, arm: &hir::Arm) -> Option<hir::Muta\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings_or_wild(dm: &RefCell<DefMap>, pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding_or_wild(dm, p) {\n@@ -219,7 +221,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n }\n \n /// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n+pub fn necessary_variants(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {"}, {"sha": "5035ac12a85f75d3e2b497ff0c479d9080ed72bd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -23,6 +23,7 @@ use middle::def::{self, DefMap};\n use middle::region;\n use middle::subst;\n use middle::ty;\n+use std::cell::RefCell;\n use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n@@ -54,7 +55,7 @@ struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n-    def_map: &'a DefMap,\n+    def_map: &'a RefCell<DefMap>,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -93,7 +94,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n \n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n-pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n+pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &RefCell<DefMap>) -> NamedRegionMap {\n     let mut named_region_map = NodeMap();\n     visit::walk_crate(&mut LifetimeContext {\n         sess: sess,"}, {"sha": "d91cac4cc75b94347cd09d581b7433880ace777f", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -228,7 +228,7 @@ pub struct ctxt<'tcx> {\n     pub types: CommonTypes<'tcx>,\n \n     pub sess: &'tcx Session,\n-    pub def_map: DefMap,\n+    pub def_map: RefCell<DefMap>,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -453,7 +453,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                  arenas: &'tcx CtxtArenas<'tcx>,\n-                                 def_map: DefMap,\n+                                 def_map: RefCell<DefMap>,\n                                  named_region_map: resolve_lifetime::NamedRegionMap,\n                                  map: ast_map::Map<'tcx>,\n                                  freevars: FreevarMap,"}, {"sha": "e9a0efe76cb42a87a55bbbdeeb9a00b965987309", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -1150,7 +1150,7 @@ pub struct Resolver<'a, 'tcx:'a> {\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    def_map: DefMap,\n+    def_map: RefCell<DefMap>,\n     freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n     export_map: ExportMap,\n@@ -4026,7 +4026,7 @@ fn module_to_string(module: &Module) -> String {\n \n \n pub struct CrateMap {\n-    pub def_map: DefMap,\n+    pub def_map: RefCell<DefMap>,\n     pub freevars: FreevarMap,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,"}, {"sha": "6678d1c34a0c4be407d7ac00dff4a48a976bf6b0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a69a00941ddb06254abe8633a4f721fd0576266/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=8a69a00941ddb06254abe8633a4f721fd0576266", "patch": "@@ -222,6 +222,7 @@ use util::nodemap::FnvHashMap;\n use util::ppaux;\n \n use std;\n+use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -495,7 +496,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                          dm: &DefMap,\n+                                          dm: &RefCell<DefMap>,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                           col: usize,\n                                           val: MatchInput,\n@@ -541,7 +542,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     dm: &DefMap,\n+                                     dm: &RefCell<DefMap>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      col: usize,\n                                      val: MatchInput)\n@@ -596,7 +597,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n-             dm: &DefMap,\n+             dm: &RefCell<DefMap>,\n              m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n              col: usize,\n@@ -842,8 +843,8 @@ impl FailureHandler {\n     }\n }\n \n-fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<usize> {\n-    fn pat_score(def_map: &DefMap, pat: &hir::Pat) -> usize {\n+fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n+    fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n             hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n             _ if pat_is_refutable(def_map, pat) => 1,"}]}