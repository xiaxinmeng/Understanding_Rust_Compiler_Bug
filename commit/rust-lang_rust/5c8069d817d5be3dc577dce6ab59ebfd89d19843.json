{"sha": "5c8069d817d5be3dc577dce6ab59ebfd89d19843", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjODA2OWQ4MTdkNWJlM2RjNTc3ZGNlNmFiNTllYmZkODlkMTk4NDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T13:38:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T13:57:13Z"}, "message": "break out type checking of alts/patterns (again)", "tree": {"sha": "fae88191844563b9d238e48bfbc6ee4a42a01b92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fae88191844563b9d238e48bfbc6ee4a42a01b92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c8069d817d5be3dc577dce6ab59ebfd89d19843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c8069d817d5be3dc577dce6ab59ebfd89d19843", "html_url": "https://github.com/rust-lang/rust/commit/5c8069d817d5be3dc577dce6ab59ebfd89d19843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c8069d817d5be3dc577dce6ab59ebfd89d19843/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da98e14c946d8ac124b845d65c1a52065791febe", "url": "https://api.github.com/repos/rust-lang/rust/commits/da98e14c946d8ac124b845d65c1a52065791febe", "html_url": "https://github.com/rust-lang/rust/commit/da98e14c946d8ac124b845d65c1a52065791febe"}], "stats": {"total": 533, "additions": 272, "deletions": 261}, "files": [{"sha": "2d41a86f9ddb64eb29613aa3ceb3d879bd716865", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 260, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5c8069d817d5be3dc577dce6ab59ebfd89d19843", "patch": "@@ -559,15 +559,6 @@ fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n     const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n-type pat_ctxt = {\n-    fcx: @fn_ctxt,\n-    map: pat_id_map,\n-    alt_region: ty::region,\n-    block_region: ty::region,\n-    /* Equal to either alt_region or block_region. */\n-    pat_region: ty::region\n-};\n-\n // Helper for the other universally_quantify_*() routines.  Extracts the bound\n // regions from bound_tys and then replaces those same regions with fresh\n // variables in `sty`, returning the resulting type.\n@@ -673,223 +664,6 @@ fn replace_bound_regions(\n     }\n }\n \n-fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n-                     subpats: option<[@ast::pat]>, expected: ty::t) {\n-\n-    // Typecheck the path.\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n-\n-    // Lookup the enum and variant def ids:\n-    let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n-    let v_def_ids = ast_util::variant_def_ids(v_def);\n-\n-    // Assign the pattern the type of the *enum*, not the variant.\n-    let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n-    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n-\n-    // Take the enum type params out of `expected`.\n-    alt structure_of(pcx.fcx, pat.span, expected) {\n-      ty::ty_enum(_, expected_substs) {\n-        // check that the type of the value being matched is a subtype\n-        // of the type of the pattern:\n-        let pat_ty = fcx.node_ty(pat.id);\n-        demand::suptype(fcx, pat.span, pat_ty, expected);\n-\n-        // Get the expected types of the arguments.\n-        let arg_types = {\n-            let vinfo =\n-                ty::enum_variant_with_id(\n-                    tcx, v_def_ids.enm, v_def_ids.var);\n-            vinfo.args.map { |t| ty::subst(tcx, expected_substs, t) }\n-        };\n-        let arg_len = arg_types.len(), subpats_len = alt subpats {\n-            none { arg_len }\n-            some(ps) { ps.len() }};\n-        if arg_len > 0u {\n-            // N-ary variant.\n-            if arg_len != subpats_len {\n-                let s = #fmt[\"this pattern has %u field%s, but the \\\n-                              corresponding variant has %u field%s\",\n-                             subpats_len,\n-                             if subpats_len == 1u { \"\" } else { \"s\" },\n-                             arg_len,\n-                             if arg_len == 1u { \"\" } else { \"s\" }];\n-                tcx.sess.span_fatal(pat.span, s);\n-            }\n-\n-            option::iter(subpats) {|pats|\n-                vec::iter2(pats, arg_types) {|subpat, arg_ty|\n-                  check_pat(pcx, subpat, arg_ty);\n-                }\n-            };\n-        } else if subpats_len > 0u {\n-            tcx.sess.span_fatal\n-                (pat.span, #fmt[\"this pattern has %u field%s, \\\n-                                 but the corresponding variant has no fields\",\n-                                subpats_len,\n-                                if subpats_len == 1u { \"\" }\n-                                else { \"s\" }]);\n-        }\n-      }\n-      _ {\n-        tcx.sess.span_fatal\n-            (pat.span,\n-             #fmt[\"mismatched types: expected enum but found `%s`\",\n-                  fcx.ty_to_str(expected)]);\n-      }\n-    }\n-}\n-\n-// Pattern checking is top-down rather than bottom-up so that bindings get\n-// their types immediately.\n-fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n-    alt pat.node {\n-      ast::pat_wild {\n-        fcx.write_ty(pat.id, expected);\n-      }\n-      ast::pat_lit(lt) {\n-        check_expr_with(pcx.fcx, lt, expected);\n-        fcx.write_ty(pat.id, fcx.expr_ty(lt));\n-      }\n-      ast::pat_range(begin, end) {\n-        check_expr_with(pcx.fcx, begin, expected);\n-        check_expr_with(pcx.fcx, end, expected);\n-        let b_ty = resolve_type_vars_if_possible(pcx.fcx,\n-                                                 fcx.expr_ty(begin));\n-        if !require_same_types(\n-            tcx, pat.span, b_ty,\n-            resolve_type_vars_if_possible(\n-                pcx.fcx, fcx.expr_ty(end)),\n-            {|| \"mismatched types in range\" }) {\n-            // no-op\n-        } else if !ty::type_is_numeric(b_ty) {\n-            tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n-        } else if !valid_range_bounds(pcx.fcx.ccx, begin, end) {\n-            tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n-                                           than upper\");\n-        }\n-        fcx.write_ty(pat.id, b_ty);\n-      }\n-      ast::pat_ident(name, sub) if !pat_is_variant(tcx.def_map, pat) {\n-        let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n-        let mut typ = ty::mk_var(tcx, vid);\n-        demand::suptype(pcx.fcx, pat.span, expected, typ);\n-        let canon_id = pcx.map.get(pat_util::path_to_ident(name));\n-        if canon_id != pat.id {\n-            let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n-            let ct = ty::mk_var(tcx, tv_id);\n-            demand::suptype(pcx.fcx, pat.span, ct, typ);\n-        }\n-        fcx.write_ty(pat.id, typ);\n-        alt sub {\n-          some(p) { check_pat(pcx, p, expected); }\n-          _ {}\n-        }\n-      }\n-      ast::pat_ident(path, c) {\n-        check_pat_variant(pcx, pat, path, some([]), expected);\n-      }\n-      ast::pat_enum(path, subpats) {\n-        check_pat_variant(pcx, pat, path, subpats, expected);\n-      }\n-      ast::pat_rec(fields, etc) {\n-        let ex_fields = alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_rec(fields) { fields }\n-          _ {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                #fmt[\"mismatched types: expected `%s` but found record\",\n-                     fcx.ty_to_str(expected)]);\n-          }\n-        };\n-        let f_count = vec::len(fields);\n-        let ex_f_count = vec::len(ex_fields);\n-        if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            tcx.sess.span_fatal\n-                (pat.span, #fmt[\"mismatched types: expected a record \\\n-                      with %u fields, found one with %u \\\n-                      fields\",\n-                                ex_f_count, f_count]);\n-        }\n-        fn matches(name: str, f: ty::field) -> bool {\n-            ret str::eq(name, f.ident);\n-        }\n-        for fields.each {|f|\n-            alt vec::find(ex_fields, bind matches(f.ident, _)) {\n-              some(field) {\n-                check_pat(pcx, f.pat, field.mt.ty);\n-              }\n-              none {\n-                tcx.sess.span_fatal(pat.span,\n-                                    #fmt[\"mismatched types: did not \\\n-                                          expect a record with a field `%s`\",\n-                                         f.ident]);\n-              }\n-            }\n-        }\n-        fcx.write_ty(pat.id, expected);\n-      }\n-      ast::pat_tup(elts) {\n-        let ex_elts = alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_tup(elts) { elts }\n-          _ {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                 #fmt[\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.ty_to_str(expected)]);\n-          }\n-        };\n-        let e_count = vec::len(elts);\n-        if e_count != vec::len(ex_elts) {\n-            tcx.sess.span_fatal\n-                (pat.span, #fmt[\"mismatched types: expected a tuple \\\n-                      with %u fields, found one with %u \\\n-                      fields\", vec::len(ex_elts), e_count]);\n-        }\n-        let mut i = 0u;\n-        for elts.each {|elt|\n-            check_pat(pcx, elt, ex_elts[i]);\n-            i += 1u;\n-        }\n-\n-        fcx.write_ty(pat.id, expected);\n-      }\n-      ast::pat_box(inner) {\n-        alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_box(e_inner) {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                \"mismatched types: expected `\" +\n-                pcx.fcx.ty_to_str(expected) +\n-                \"` found box\");\n-          }\n-        }\n-      }\n-      ast::pat_uniq(inner) {\n-        alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_uniq(e_inner) {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                \"mismatched types: expected `\" +\n-                pcx.fcx.ty_to_str(expected) +\n-                \"` found uniq\");\n-          }\n-        }\n-      }\n-    }\n-}\n-\n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     check_expr(fcx, expr, some(expected))\n }\n@@ -1870,38 +1644,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           bot = !may_break(body);\n       }\n       ast::expr_alt(discrim, arms, _) {\n-        let pattern_ty = fcx.next_ty_var();\n-        bot = check_expr_with(fcx, discrim, pattern_ty);\n-\n-        // Typecheck the patterns first, so that we get types for all the\n-        // bindings.\n-        //let pattern_ty = fcx.expr_ty(discrim);\n-        for arms.each {|arm|\n-            let pcx = {\n-                fcx: fcx,\n-                map: pat_id_map(tcx.def_map, arm.pats[0]),\n-                alt_region: ty::re_scope(expr.id),\n-                block_region: ty::re_scope(arm.body.node.id),\n-                pat_region: ty::re_scope(expr.id)\n-            };\n-\n-            for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n-        }\n-        // Now typecheck the blocks.\n-        let mut result_ty = fcx.next_ty_var();\n-        let mut arm_non_bot = false;\n-        for arms.each {|arm|\n-            alt arm.guard {\n-              some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n-              none { }\n-            }\n-            if !check_block(fcx, arm.body) { arm_non_bot = true; }\n-            let bty = fcx.node_ty(arm.body.node.id);\n-            demand::suptype(fcx, arm.body.span, result_ty, bty);\n-        }\n-        bot |= !arm_non_bot;\n-        if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n-        fcx.write_ty(id, result_ty);\n+        bot = alt::check_alt(fcx, expr, discrim, arms);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) {\n         check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n@@ -2344,8 +2087,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n         block_region: region,\n         pat_region: region\n     };\n-\n-    check_pat(pcx, local.node.pat, t);\n+    alt::check_pat(pcx, local.node.pat, t);\n     ret bot;\n }\n "}, {"sha": "ef9c574ccd20e0a773f422a580a1f199fa1e9a1f", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=5c8069d817d5be3dc577dce6ab59ebfd89d19843", "patch": "@@ -0,0 +1,267 @@\n+fn check_alt(fcx: @fn_ctxt,\n+             expr: @ast::expr,\n+             discrim: @ast::expr,\n+             arms: [ast::arm]) -> bool {\n+    let tcx = fcx.ccx.tcx;\n+    let mut bot = false;\n+\n+    let pattern_ty = fcx.next_ty_var();\n+    bot = check_expr_with(fcx, discrim, pattern_ty);\n+\n+    // Typecheck the patterns first, so that we get types for all the\n+    // bindings.\n+    for arms.each {|arm|\n+        let pcx = {\n+            fcx: fcx,\n+            map: pat_id_map(tcx.def_map, arm.pats[0]),\n+            alt_region: ty::re_scope(expr.id),\n+            block_region: ty::re_scope(arm.body.node.id),\n+            pat_region: ty::re_scope(expr.id)\n+        };\n+\n+        for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n+    }\n+    // Now typecheck the blocks.\n+    let mut result_ty = fcx.next_ty_var();\n+    let mut arm_non_bot = false;\n+    for arms.each {|arm|\n+        alt arm.guard {\n+          some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n+          none { }\n+        }\n+        if !check_block(fcx, arm.body) { arm_non_bot = true; }\n+        let bty = fcx.node_ty(arm.body.node.id);\n+        demand::suptype(fcx, arm.body.span, result_ty, bty);\n+    }\n+    bot |= !arm_non_bot;\n+    if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n+    fcx.write_ty(expr.id, result_ty);\n+    ret bot;\n+}\n+\n+type pat_ctxt = {\n+    fcx: @fn_ctxt,\n+    map: pat_id_map,\n+    alt_region: ty::region,\n+    block_region: ty::region,\n+    /* Equal to either alt_region or block_region. */\n+    pat_region: ty::region\n+};\n+\n+fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n+                     subpats: option<[@ast::pat]>, expected: ty::t) {\n+\n+    // Typecheck the path.\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+\n+    // Lookup the enum and variant def ids:\n+    let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n+    let v_def_ids = ast_util::variant_def_ids(v_def);\n+\n+    // Assign the pattern the type of the *enum*, not the variant.\n+    let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n+    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n+\n+    // Take the enum type params out of `expected`.\n+    alt structure_of(pcx.fcx, pat.span, expected) {\n+      ty::ty_enum(_, expected_substs) {\n+        // check that the type of the value being matched is a subtype\n+        // of the type of the pattern:\n+        let pat_ty = fcx.node_ty(pat.id);\n+        demand::suptype(fcx, pat.span, pat_ty, expected);\n+\n+        // Get the expected types of the arguments.\n+        let arg_types = {\n+            let vinfo =\n+                ty::enum_variant_with_id(\n+                    tcx, v_def_ids.enm, v_def_ids.var);\n+            vinfo.args.map { |t| ty::subst(tcx, expected_substs, t) }\n+        };\n+        let arg_len = arg_types.len(), subpats_len = alt subpats {\n+            none { arg_len }\n+            some(ps) { ps.len() }};\n+        if arg_len > 0u {\n+            // N-ary variant.\n+            if arg_len != subpats_len {\n+                let s = #fmt[\"this pattern has %u field%s, but the \\\n+                              corresponding variant has %u field%s\",\n+                             subpats_len,\n+                             if subpats_len == 1u { \"\" } else { \"s\" },\n+                             arg_len,\n+                             if arg_len == 1u { \"\" } else { \"s\" }];\n+                tcx.sess.span_fatal(pat.span, s);\n+            }\n+\n+            option::iter(subpats) {|pats|\n+                vec::iter2(pats, arg_types) {|subpat, arg_ty|\n+                  check_pat(pcx, subpat, arg_ty);\n+                }\n+            };\n+        } else if subpats_len > 0u {\n+            tcx.sess.span_fatal\n+                (pat.span, #fmt[\"this pattern has %u field%s, \\\n+                                 but the corresponding variant has no fields\",\n+                                subpats_len,\n+                                if subpats_len == 1u { \"\" }\n+                                else { \"s\" }]);\n+        }\n+      }\n+      _ {\n+        tcx.sess.span_fatal\n+            (pat.span,\n+             #fmt[\"mismatched types: expected enum but found `%s`\",\n+                  fcx.ty_to_str(expected)]);\n+      }\n+    }\n+}\n+\n+// Pattern checking is top-down rather than bottom-up so that bindings get\n+// their types immediately.\n+fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+    let fcx = pcx.fcx;\n+    let tcx = pcx.fcx.ccx.tcx;\n+    alt pat.node {\n+      ast::pat_wild {\n+        fcx.write_ty(pat.id, expected);\n+      }\n+      ast::pat_lit(lt) {\n+        check_expr_with(pcx.fcx, lt, expected);\n+        fcx.write_ty(pat.id, fcx.expr_ty(lt));\n+      }\n+      ast::pat_range(begin, end) {\n+        check_expr_with(pcx.fcx, begin, expected);\n+        check_expr_with(pcx.fcx, end, expected);\n+        let b_ty = resolve_type_vars_if_possible(pcx.fcx,\n+                                                 fcx.expr_ty(begin));\n+        if !require_same_types(\n+            tcx, pat.span, b_ty,\n+            resolve_type_vars_if_possible(\n+                pcx.fcx, fcx.expr_ty(end)),\n+            {|| \"mismatched types in range\" }) {\n+            // no-op\n+        } else if !ty::type_is_numeric(b_ty) {\n+            tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n+        } else if !valid_range_bounds(pcx.fcx.ccx, begin, end) {\n+            tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n+                                           than upper\");\n+        }\n+        fcx.write_ty(pat.id, b_ty);\n+      }\n+      ast::pat_ident(name, sub) if !pat_is_variant(tcx.def_map, pat) {\n+        let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n+        let mut typ = ty::mk_var(tcx, vid);\n+        demand::suptype(pcx.fcx, pat.span, expected, typ);\n+        let canon_id = pcx.map.get(pat_util::path_to_ident(name));\n+        if canon_id != pat.id {\n+            let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n+            let ct = ty::mk_var(tcx, tv_id);\n+            demand::suptype(pcx.fcx, pat.span, ct, typ);\n+        }\n+        fcx.write_ty(pat.id, typ);\n+        alt sub {\n+          some(p) { check_pat(pcx, p, expected); }\n+          _ {}\n+        }\n+      }\n+      ast::pat_ident(path, c) {\n+        check_pat_variant(pcx, pat, path, some([]), expected);\n+      }\n+      ast::pat_enum(path, subpats) {\n+        check_pat_variant(pcx, pat, path, subpats, expected);\n+      }\n+      ast::pat_rec(fields, etc) {\n+        let ex_fields = alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_rec(fields) { fields }\n+          _ {\n+            tcx.sess.span_fatal\n+                (pat.span,\n+                #fmt[\"mismatched types: expected `%s` but found record\",\n+                     fcx.ty_to_str(expected)]);\n+          }\n+        };\n+        let f_count = vec::len(fields);\n+        let ex_f_count = vec::len(ex_fields);\n+        if ex_f_count < f_count || !etc && ex_f_count > f_count {\n+            tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected a record \\\n+                      with %u fields, found one with %u \\\n+                      fields\",\n+                                ex_f_count, f_count]);\n+        }\n+        fn matches(name: str, f: ty::field) -> bool {\n+            ret str::eq(name, f.ident);\n+        }\n+        for fields.each {|f|\n+            alt vec::find(ex_fields, bind matches(f.ident, _)) {\n+              some(field) {\n+                check_pat(pcx, f.pat, field.mt.ty);\n+              }\n+              none {\n+                tcx.sess.span_fatal(pat.span,\n+                                    #fmt[\"mismatched types: did not \\\n+                                          expect a record with a field `%s`\",\n+                                         f.ident]);\n+              }\n+            }\n+        }\n+        fcx.write_ty(pat.id, expected);\n+      }\n+      ast::pat_tup(elts) {\n+        let ex_elts = alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_tup(elts) { elts }\n+          _ {\n+            tcx.sess.span_fatal\n+                (pat.span,\n+                 #fmt[\"mismatched types: expected `%s`, found tuple\",\n+                      fcx.ty_to_str(expected)]);\n+          }\n+        };\n+        let e_count = vec::len(elts);\n+        if e_count != vec::len(ex_elts) {\n+            tcx.sess.span_fatal\n+                (pat.span, #fmt[\"mismatched types: expected a tuple \\\n+                      with %u fields, found one with %u \\\n+                      fields\", vec::len(ex_elts), e_count]);\n+        }\n+        let mut i = 0u;\n+        for elts.each {|elt|\n+            check_pat(pcx, elt, ex_elts[i]);\n+            i += 1u;\n+        }\n+\n+        fcx.write_ty(pat.id, expected);\n+      }\n+      ast::pat_box(inner) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_box(e_inner) {\n+            check_pat(pcx, inner, e_inner.ty);\n+            fcx.write_ty(pat.id, expected);\n+          }\n+          _ {\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                \"mismatched types: expected `\" +\n+                pcx.fcx.ty_to_str(expected) +\n+                \"` found box\");\n+          }\n+        }\n+      }\n+      ast::pat_uniq(inner) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_uniq(e_inner) {\n+            check_pat(pcx, inner, e_inner.ty);\n+            fcx.write_ty(pat.id, expected);\n+          }\n+          _ {\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                \"mismatched types: expected `\" +\n+                pcx.fcx.ty_to_str(expected) +\n+                \"` found uniq\");\n+          }\n+        }\n+      }\n+    }\n+}\n+"}, {"sha": "f54907fa63d35e10449a496e2e17b989bb276aa4", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5c8069d817d5be3dc577dce6ab59ebfd89d19843/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=5c8069d817d5be3dc577dce6ab59ebfd89d19843", "patch": "@@ -52,7 +52,9 @@ mod middle {\n     mod ast_map;\n     mod resolve;\n     mod typeck {\n-        mod check;\n+        mod check {\n+            mod alt;\n+        }\n         mod regionck;\n         mod demand;\n         mod infer;"}]}