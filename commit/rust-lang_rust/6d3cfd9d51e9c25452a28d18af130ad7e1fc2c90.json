{"sha": "6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkM2NmZDlkNTFlOWMyNTQ1MmEyOGQxOGFmMTMwYWQ3ZTFmYzJjOTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-01T00:13:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-01T00:13:37Z"}, "message": "Rollup merge of #77305 - lcnr:candidate_from_obligation, r=davidtwco\n\nmove candidate_from_obligation_no_cache\n\nIt's only called from `candidate_from_obligation` which is already in this file.", "tree": {"sha": "54deafc7a7baeb37766f3f5c19aada2040a36a05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54deafc7a7baeb37766f3f5c19aada2040a36a05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdR8xCRBK7hj4Ov3rIwAAdHIIADEit/hgW1Y+H2aFyRTZqnNo\nIJuDXSQKvE3pa5mFBZJeFkF96zCSDc7oG5wjs1yXXrOrb0hxTuUFsrPqrwxKUu56\n7LQrJnIZsMhAkmQNxbHD/ICadVvLmRSorFqHhlhJhVz7qkTgIng7N+1EABIWD9Q/\nfcVl+fuyhyKFsm5tgQr0bv+g7tUbcI1uUXL+HhTVL6umHaxwcOWozSBuI/pw2pf8\nc7XenHwH2jtiQ3PFGPynAdW9O0H3lQhLMcKDdflAnkzCvA4l1/v9NN2lqIpkTRZ7\n9NrlF3hJOWRpNSnZJTFPu0aGTUldMdqimcE6i32scVeb7OyXglcckdyUnKPGIcU=\n=viNO\n-----END PGP SIGNATURE-----\n", "payload": "tree 54deafc7a7baeb37766f3f5c19aada2040a36a05\nparent f23559451b0dc5181d73ddd89657266d4e150b6a\nparent db5b70f193dcc08476ec1bef8dc1863d508eea1e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1601511217 +0200\ncommitter GitHub <noreply@github.com> 1601511217 +0200\n\nRollup merge of #77305 - lcnr:candidate_from_obligation, r=davidtwco\n\nmove candidate_from_obligation_no_cache\n\nIt's only called from `candidate_from_obligation` which is already in this file.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "html_url": "https://github.com/rust-lang/rust/commit/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f23559451b0dc5181d73ddd89657266d4e150b6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23559451b0dc5181d73ddd89657266d4e150b6a", "html_url": "https://github.com/rust-lang/rust/commit/f23559451b0dc5181d73ddd89657266d4e150b6a"}, {"sha": "db5b70f193dcc08476ec1bef8dc1863d508eea1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5b70f193dcc08476ec1bef8dc1863d508eea1e", "html_url": "https://github.com/rust-lang/rust/commit/db5b70f193dcc08476ec1bef8dc1863d508eea1e"}], "stats": {"total": 317, "additions": 161, "deletions": 156}, "files": [{"sha": "9cb5c232646f854e73457951643373a0eec25077", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "patch": "@@ -7,14 +7,19 @@\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n use rustc_hir as hir;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_target::spec::abi::Abi;\n \n+use crate::traits::coherence::Conflict;\n use crate::traits::{util, SelectionResult};\n+use crate::traits::{Overflow, Unimplemented};\n \n use super::BuiltinImplConditions;\n+use super::IntercrateAmbiguityCause;\n+use super::OverflowError;\n use super::SelectionCandidate::{self, *};\n-use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub(super) fn candidate_from_obligation<'o>(\n@@ -62,6 +67,161 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n+    fn candidate_from_obligation_no_cache<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let Some(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+\n+                    for c in candidate_set.vec.iter() {\n+                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n+                            no_candidates_apply = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let (trait_desc, self_desc) = with_no_trimmed_paths(|| {\n+                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                            let self_desc = if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            };\n+                            (trait_desc, self_desc)\n+                        });\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                    }\n+                }\n+            }\n+            return Ok(None);\n+        }\n+\n+        let candidate_set = self.assemble_candidates(stack)?;\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let mut candidates = candidate_set.vec;\n+\n+        debug!(\"assembled {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n+        if candidates.len() == 1 {\n+            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let mut candidates = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => {\n+                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n+                }\n+                Ok(_) => Ok(None),\n+                Err(OverflowError) => Err(Overflow),\n+            })\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n+\n+        debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n+\n+        let needs_infer = stack.obligation.predicate.needs_infer();\n+\n+        // If there are STILL multiple candidates, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n+                });\n+                if is_dup {\n+                    debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(\"Retaining candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n+                    i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If there are *NO* candidates, then there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_stack` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n+        if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.references_error() {\n+                debug!(\"no results for error type, treating as ambiguous\");\n+                return Ok(None);\n+            }\n+            return Err(Unimplemented);\n+        }\n+\n+        // Just one candidate left.\n+        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n+    }\n+\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,"}, {"sha": "114dc79c44f50e58134f45cc14a8ba6ede5d5f1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6d3cfd9d51e9c25452a28d18af130ad7e1fc2c90", "patch": "@@ -1029,161 +1029,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n-    fn candidate_from_obligation_no_cache<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if let Some(conflict) = self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    let mut no_candidates_apply = true;\n-\n-                    for c in candidate_set.vec.iter() {\n-                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n-                            no_candidates_apply = false;\n-                            break;\n-                        }\n-                    }\n-\n-                    if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths(|| {\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n-                    }\n-                }\n-            }\n-            return Ok(None);\n-        }\n-\n-        let candidate_set = self.assemble_candidates(stack)?;\n-\n-        if candidate_set.ambiguous {\n-            debug!(\"candidate set contains ambig\");\n-            return Ok(None);\n-        }\n-\n-        let mut candidates = candidate_set.vec;\n-\n-        debug!(\"assembled {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n-\n-        // At this point, we know that each of the entries in the\n-        // candidate set is *individually* applicable. Now we have to\n-        // figure out if they contain mutual incompatibilities. This\n-        // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for `$0: Eq` where `$0` is some\n-        // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes `$0 ==\n-        // usize`, etc. This spells an ambiguity.\n-\n-        // If there is more than one candidate, first winnow them down\n-        // by considering extra conditions (nested obligations and so\n-        // forth). We don't winnow if there is exactly one\n-        // candidate. This is a relatively minor distinction but it\n-        // can lead to better inference and error-reporting. An\n-        // example would be if there was an impl:\n-        //\n-        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n-        //\n-        // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n-        // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report \"`Bar` does\n-        // not implement `Clone`\".\n-        if candidates.len() == 1 {\n-            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n-        }\n-\n-        // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates\n-            .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c) {\n-                Ok(eval) if eval.may_apply() => {\n-                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n-                }\n-                Ok(_) => Ok(None),\n-                Err(OverflowError) => Err(Overflow),\n-            })\n-            .flat_map(Result::transpose)\n-            .collect::<Result<Vec<_>, _>>()?;\n-\n-        debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n-\n-        let needs_infer = stack.obligation.predicate.needs_infer();\n-\n-        // If there are STILL multiple candidates, we can further\n-        // reduce the list by dropping duplicates -- including\n-        // resolving specializations.\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                        needs_infer,\n-                    )\n-                });\n-                if is_dup {\n-                    debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n-                    candidates.swap_remove(i);\n-                } else {\n-                    debug!(\"Retaining candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n-                    i += 1;\n-\n-                    // If there are *STILL* multiple candidates, give up\n-                    // and report ambiguity.\n-                    if i > 1 {\n-                        debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If there are *NO* candidates, then there are no impls --\n-        // that we know of, anyway. Note that in the case where there\n-        // are unbound type variables within the obligation, it might\n-        // be the case that you could still satisfy the obligation\n-        // from another crate by instantiating the type variables with\n-        // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_stack` (and hence users\n-        // who might care about this case, like coherence, should use\n-        // that function).\n-        if candidates.is_empty() {\n-            // If there's an error type, 'downgrade' our result from\n-            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n-            // emitting additional spurious errors, since we're guaranteed\n-            // to have emitted at least one.\n-            if stack.obligation.references_error() {\n-                debug!(\"no results for error type, treating as ambiguous\");\n-                return Ok(None);\n-            }\n-            return Err(Unimplemented);\n-        }\n-\n-        // Just one candidate left.\n-        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n-    }\n-\n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n         debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n "}]}