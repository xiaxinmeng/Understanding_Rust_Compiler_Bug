{"sha": "448c349234111d2fbe057898fb6435fd8466ffdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0OGMzNDkyMzQxMTFkMmZiZTA1Nzg5OGZiNjQzNWZkODQ2NmZmZGM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T21:49:07Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T21:49:07Z"}, "message": "Copyedit sections 7 and 8 of the borrowed pointer tutorial", "tree": {"sha": "8c5dd0d61723077e5755f7c7eb75b1d43312caf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c5dd0d61723077e5755f7c7eb75b1d43312caf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/448c349234111d2fbe057898fb6435fd8466ffdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/448c349234111d2fbe057898fb6435fd8466ffdc", "html_url": "https://github.com/rust-lang/rust/commit/448c349234111d2fbe057898fb6435fd8466ffdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/448c349234111d2fbe057898fb6435fd8466ffdc/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae861f0288c4773a004967123ad5eb4000989dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae861f0288c4773a004967123ad5eb4000989dde", "html_url": "https://github.com/rust-lang/rust/commit/ae861f0288c4773a004967123ad5eb4000989dde"}], "stats": {"total": 142, "additions": 73, "deletions": 69}, "files": [{"sha": "f5199a76a40b3f60c2e9558f0c916d4916330354", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 73, "deletions": 69, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/448c349234111d2fbe057898fb6435fd8466ffdc/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/448c349234111d2fbe057898fb6435fd8466ffdc/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=448c349234111d2fbe057898fb6435fd8466ffdc", "patch": "@@ -447,11 +447,11 @@ the block restricts the scope of `y`, making the move legal.\n \n # Borrowing and enums\n \n-The previous example showed that borrowing unique boxes found in\n-aliasable, mutable memory is not permitted, so as to prevent pointers\n-into freed memory. There is one other case where the compiler must be\n-very careful to ensure that pointers remain valid: pointers into the\n-interior of an enum.\n+The previous example showed that the type system forbids any borrowing\n+of unique boxes found in aliasable, mutable memory. This restriction\n+prevents pointers from pointing into freed memory. There is one other\n+case where the compiler must be very careful to ensure that pointers\n+remain valid: pointers into the interior of an `enum`.\n \n As an example, let\u2019s look at the following `shape` type that can\n represent both rectangles and circles:\n@@ -465,9 +465,9 @@ enum Shape {\n }\n ~~~\n \n-Now I might write a function to compute the area of a shape. This\n-function takes a borrowed pointer to a shape to avoid the need of\n-copying them.\n+Now we might write a function to compute the area of a shape. This\n+function takes a borrowed pointer to a shape, to avoid the need for\n+copying.\n \n ~~~\n # struct Point {x: float, y: float}; // as before\n@@ -485,21 +485,21 @@ fn compute_area(shape: &Shape) -> float {\n }\n ~~~\n \n-The first case matches against circles. Here the radius is extracted\n-from the shape variant and used to compute the area of the circle\n-(Like any up-to-date engineer, we use the [tau circle constant][tau]\n-and not that dreadfully outdated notion of pi).\n+The first case matches against circles. Here, the pattern extracts the\n+radius from the shape variant and the action uses it to compute the\n+area of the circle. (Like any up-to-date engineer, we use the [tau\n+circle constant][tau] and not that dreadfully outdated notion of pi).\n \n [tau]: http://www.math.utah.edu/~palais/pi.html\n \n The second match is more interesting. Here we match against a\n-rectangle and extract its size: but rather than copy the `size` struct,\n-we use a by-reference binding to create a pointer to it. In other\n-words, a pattern binding like `ref size` in fact creates a pointer of\n-type `&size` into the _interior of the enum_.\n+rectangle and extract its size: but rather than copy the `size`\n+struct, we use a by-reference binding to create a pointer to it. In\n+other words, a pattern binding like `ref size` binds the name `size`\n+to a pointer of type `&size` into the _interior of the enum_.\n \n-To make this more clear, let\u2019s look at a diagram of how things are\n-laid out in memory in the case where `shape` points at a rectangle:\n+To make this more clear, let's look at a diagram of memory layout in\n+the case where `shape` points at a rectangle:\n \n ~~~ {.notrust}\n Stack             Memory\n@@ -523,8 +523,8 @@ the shape.\n Perhaps you can see where the danger lies: if the shape were somehow\n to be reassigned, perhaps to a circle, then although the memory used\n to store that shape value would still be valid, _it would have a\n-different type_! This is shown in the following diagram, depicting what\n-the state of memory would be if shape were overwritten with a circle:\n+different type_! The following diagram shows what memory would look\n+like if code overwrote `shape` with a circle:\n \n ~~~ {.notrust}\n Stack             Memory\n@@ -538,20 +538,23 @@ Stack             Memory\n                   +---------------+\n ~~~\n \n-As you can see, the `size` pointer would not be pointing at a `float` and\n-not a struct. This is not good.\n+As you can see, the `size` pointer would be pointing at a `float`\n+instead of a struct. This is not good: dereferencing the second field\n+of a `float` as if it were a struct with two fields would be a memory\n+safety violation.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n same rules as the ones we saw for borrowing the interior of a unique\n-box: it must be able to guarantee that the enum will not be\n-overwritten for the duration of the borrow.  In fact, the example I\n-gave earlier would be considered safe. This is because the shape\n-pointer has type `&Shape`, which means \u201cborrowed pointer to immutable\n-memory containing a shape\u201d. If however the type of that pointer were\n-`&const Shape` or `&mut Shape`, then the ref binding would not be\n-permitted. Just as with unique boxes, the compiler will permit ref\n-bindings into data owned by the stack frame even if it is mutable, but\n-otherwise it requires that the data reside in immutable memory.\n+box: it must be able to guarantee that the `enum` will not be\n+overwritten for the duration of the borrow.  In fact, the compiler\n+would accept the example we gave earlier. The example is safe because\n+the shape pointer has type `&Shape`, which means \"borrowed pointer to\n+immutable memory containing a `shape`\". If, however, the type of that\n+pointer were `&const Shape` or `&mut Shape`, then the ref binding\n+would be ill-typed. Just as with unique boxes, the compiler will\n+permit `ref` bindings into data owned by the stack frame even if the\n+data are mutable, but otherwise it requires that the data reside in\n+immutable memory.\n \n > ***Note:*** Right now, pattern bindings not explicitly annotated\n > with `ref` or `copy` use a special mode of \"implicit by reference\".\n@@ -560,11 +563,11 @@ otherwise it requires that the data reside in immutable memory.\n \n # Returning borrowed pointers\n \n-So far, all of the examples we\u2019ve looked at use borrowed pointers in a\n-\u201cdownward\u201d direction. That is, the borrowed pointer is created and\n-then used during the method or code block which created it. It is also\n-possible to return borrowed pointers to the caller, but as we'll see\n-this requires some explicit annotation.\n+So far, all of the examples we've looked at use borrowed pointers in a\n+\u201cdownward\u201d direction. That is, a method or code block creates a\n+borrowed pointer, then uses it within the same scope. It is also\n+possible to return borrowed pointers as the result of a function, but\n+as we'll see, doing so requires some explicit annotation.\n \n For example, we could write a subroutine like this:\n \n@@ -573,23 +576,25 @@ struct Point {x: float, y: float}\n fn get_x(p: &r/Point) -> &r/float { &p.x }\n ~~~\n \n-Here, the function `get_x()` returns a pointer into the structure it was\n-given. The type of the parameter (`&r/Point`) and return type (`&r/float`) both\n-make use of a new syntactic form that we have not seen so far.  Here the identifier `r`\n-serves as an explicit name for the lifetime of the pointer.  So in effect\n-this function is declaring that it takes in a pointer with lifetime `r` and returns\n-a pointer with that same lifetime.\n+Here, the function `get_x()` returns a pointer into the structure it\n+was given. The type of the parameter (`&r/Point`) and return type\n+(`&r/float`) both use a new syntactic form that we have not seen so\n+far.  Here the identifier `r` names the lifetime of the pointer\n+explicitly. So in effect, this function declares that it takes a\n+pointer with lifetime `r` and returns a pointer with that same\n+lifetime.\n \n In general, it is only possible to return borrowed pointers if they\n-are derived from a borrowed pointer which was given as input to the\n-procedure.  In that case, they will always have the same lifetime as\n-one of the parameters; named lifetimes are used to indicate which\n-parameter that is.\n+are derived from a parameter to the procedure. In that case, the\n+pointer result will always have the same lifetime as one of the\n+parameters; named lifetimes indicate which parameter that\n+is.\n \n-In the examples before, function parameter types did not include a\n-lifetime name.  In this case, the compiler simply creates a new,\n-anonymous name, meaning that the parameter is assumed to have a\n-distinct lifetime from all other parameters.\n+In the previous examples, function parameter types did not include a\n+lifetime name. In those examples, the compiler simply creates a fresh\n+name for the lifetime automatically: that is, the lifetime name is\n+guaranteed to refer to a distinct lifetime from the lifetimes of all\n+other parameters.\n \n Named lifetimes that appear in function signatures are conceptually\n the same as the other lifetimes we've seen before, but they are a bit\n@@ -599,13 +604,13 @@ lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n by the caller to `get_x()`, just as the value for the parameter `p` is\n defined by that caller.\n \n-In any case, whatever the lifetime `r` is, the pointer produced by\n-`&p.x` always has the same lifetime as `p` itself, as a pointer to a\n+In any case, whatever the lifetime of `r` is, the pointer produced by\n+`&p.x` always has the same lifetime as `p` itself: a pointer to a\n field of a struct is valid as long as the struct is valid. Therefore,\n-the compiler is satisfied with the function `get_x()`.\n+the compiler accepts the function `get_x()`.\n \n-To drill in this point, let\u2019s look at a variation on the example, this\n-time one which does not compile:\n+To emphasize this point, let\u2019s look at a variation on the example, this\n+time one that does not compile:\n \n ~~~ {.xfail-test}\n struct Point {x: float, y: float}\n@@ -617,22 +622,21 @@ fn get_x_sh(p: @Point) -> &float {\n Here, the function `get_x_sh()` takes a managed box as input and\n returns a borrowed pointer. As before, the lifetime of the borrowed\n pointer that will be returned is a parameter (specified by the\n-caller). That means that effectively `get_x_sh()` is promising to\n-return a borrowed pointer that is valid for as long as the caller\n-would like: this is subtly different from the first example, which\n-promised to return a pointer that was valid for as long as the pointer\n-it was given.\n+caller). That means that `get_x_sh()` promises to return a borrowed\n+pointer that is valid for as long as the caller would like: this is\n+subtly different from the first example, which promised to return a\n+pointer that was valid for as long as its pointer argument was valid.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a managed box. This implies that the compiler\n-must guarantee that, so long as the resulting pointer is valid, the\n-managed box will not be reclaimed by the garbage collector. But recall\n-that `get_x_sh()` also promised to return a pointer that was valid for\n-as long as the caller wanted it to be. Clearly, `get_x_sh()` is not in\n-a position to make both of these guarantees; in fact, it cannot\n-guarantee that the pointer will remain valid at all once it returns,\n-as the parameter `p` may or may not be live in the caller. Therefore,\n-the compiler will report an error here.\n+address of a field of a managed box. The presence of this expression\n+implies that the compiler must guarantee that, so long as the\n+resulting pointer is valid, the managed box will not be reclaimed by\n+the garbage collector. But recall that `get_x_sh()` also promised to\n+return a pointer that was valid for as long as the caller wanted it to\n+be. Clearly, `get_x_sh()` is not in a position to make both of these\n+guarantees; in fact, it cannot guarantee that the pointer will remain\n+valid at all once it returns, as the parameter `p` may or may not be\n+live in the caller. Therefore, the compiler will report an error here.\n \n In general, if you borrow a managed (or unique) box to create a\n borrowed pointer, the pointer will only be valid within the function"}]}