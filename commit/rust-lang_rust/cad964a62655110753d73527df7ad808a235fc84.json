{"sha": "cad964a62655110753d73527df7ad808a235fc84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZDk2NGE2MjY1NTExMDc1M2Q3MzUyN2RmN2FkODA4YTIzNWZjODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T01:34:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-29T01:34:50Z"}, "message": "Auto merge of #32461 - mitaa:rdoc-anchors, r=alexcrichton\n\nrustdoc: Correct anchor for links to associated trait items\n\nfixes #28478\n\nr? @alexcrichton", "tree": {"sha": "ecef63a4996afd905da71e0356fe1f2d41986f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecef63a4996afd905da71e0356fe1f2d41986f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cad964a62655110753d73527df7ad808a235fc84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cad964a62655110753d73527df7ad808a235fc84", "html_url": "https://github.com/rust-lang/rust/commit/cad964a62655110753d73527df7ad808a235fc84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cad964a62655110753d73527df7ad808a235fc84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a77f67696e855a9841eaf7c7bf7639131cfec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/44a77f67696e855a9841eaf7c7bf7639131cfec6", "html_url": "https://github.com/rust-lang/rust/commit/44a77f67696e855a9841eaf7c7bf7639131cfec6"}, {"sha": "4e0abdb021a704842b3c2702b533643fafa166df", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0abdb021a704842b3c2702b533643fafa166df", "html_url": "https://github.com/rust-lang/rust/commit/4e0abdb021a704842b3c2702b533643fafa166df"}], "stats": {"total": 669, "additions": 473, "deletions": 196}, "files": [{"sha": "a09640c3055c2ac68bd7cdeab15074100da83a97", "filename": "src/doc/style/features/traits/generics.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -27,8 +27,7 @@ explicitly implement to be used by this generic function.\n * _Inference_. Since the type parameters to generic functions can usually be\n   inferred, generic functions can help cut down on verbosity in code where\n   explicit conversions or other method calls would usually be necessary. See the\n-  [overloading/implicits use case](#use-case-limited-overloading-andor-implicit-conversions)\n-  below.\n+  overloading/implicits use case below.\n * _Precise types_. Because generics give a _name_ to the specific type\n   implementing a trait, it is possible to be precise about places where that\n   exact type is required or produced. For example, a function\n@@ -51,7 +50,7 @@ explicitly implement to be used by this generic function.\n   a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n   vector representation is specialized to lay these out in line). Sometimes\n   heterogeneous collections are useful; see\n-  [trait objects](#use-case-trait-objects) below.\n+  trait objects below.\n * _Signature verbosity_. Heavy use of generics can bloat function signatures.\n   **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n "}, {"sha": "4dbcf7ab4e320b6ef1d68fb13ab10ba1630c2dec", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -434,7 +434,7 @@ pub trait Iterator {\n     /// `None`. Once `None` is encountered, `count()` returns the number of\n     /// times it called [`next()`].\n     ///\n-    /// [`next()`]: #method.next\n+    /// [`next()`]: #tymethod.next\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -497,7 +497,7 @@ pub trait Iterator {\n     /// This method will evaluate the iterator `n` times, discarding those elements.\n     /// After it does so, it will call [`next()`] and return its value.\n     ///\n-    /// [`next()`]: #method.next\n+    /// [`next()`]: #tymethod.next\n     ///\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on."}, {"sha": "702c6dd8211cbba6b59d3fc52605ac97301b09a1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n-use clean::{self, Attributes};\n+use clean::{self, Attributes, GetDefId};\n \n use super::{Clean, ToSource};\n \n@@ -414,15 +414,22 @@ pub fn build_impl(cx: &DocContext,\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if let Some(clean::ResolvedPath { did, .. }) = trait_ {\n-        if Some(did) == cx.deref_trait_did.get() {\n-            super::build_deref_target_impls(cx, &trait_items, ret);\n-        }\n+    if trait_.def_id() == cx.deref_trait_did.get() {\n+        super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n+\n+    let provided = trait_.def_id().map(|did| {\n+        cx.tcx().provided_trait_methods(did)\n+                .into_iter()\n+                .map(|meth| meth.name.to_string())\n+                .collect()\n+    }).unwrap_or(HashSet::new());\n+\n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal, // FIXME: this should be decoded\n             derived: clean::detect_derived(&attrs),\n+            provided_trait_methods: provided,\n             trait_: trait_,\n             for_: ty.ty.clean(cx),\n             generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),"}, {"sha": "b26e56008accb34f050d835edd39b108e09c4a12", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -44,7 +44,7 @@ use rustc::middle::stability;\n \n use rustc_front::hir;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::u32;\n@@ -559,15 +559,9 @@ impl TyParamBound {\n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc_front::hir::TraitBoundModifier as TBM;\n         if let Some(tcx) = cx.tcx_opt() {\n-            let sized_did = match tcx.lang_items.sized_trait() {\n-                Some(did) => did,\n-                None => return false\n-            };\n-            if let TyParamBound::TraitBound(PolyTrait {\n-                trait_: Type::ResolvedPath { did, .. }, ..\n-            }, TBM::None) = *self {\n-                if did == sized_did {\n-                    return true\n+            if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+                if trait_.def_id() == tcx.lang_items.sized_trait() {\n+                    return true;\n                 }\n             }\n         }\n@@ -724,15 +718,18 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             }\n         }\n \n-        TraitBound(PolyTrait {\n-            trait_: ResolvedPath {\n-                path: path,\n-                typarams: None,\n-                did: self.def_id,\n-                is_generic: false,\n+        TraitBound(\n+            PolyTrait {\n+                trait_: ResolvedPath {\n+                    path: path,\n+                    typarams: None,\n+                    did: self.def_id,\n+                    is_generic: false,\n+                },\n+                lifetimes: late_bounds,\n             },\n-            lifetimes: late_bounds\n-        }, hir::TraitBoundModifier::None)\n+            hir::TraitBoundModifier::None\n+        )\n     }\n }\n \n@@ -932,7 +929,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n                                     &'a ty::GenericPredicates<'tcx>,\n                                     subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n-        use std::collections::HashSet;\n         use self::WherePredicate as WP;\n \n         let (gens, preds, space) = *self;\n@@ -1486,6 +1482,16 @@ pub enum TypeKind {\n     TypeTypedef,\n }\n \n+pub trait GetDefId {\n+    fn def_id(&self) -> Option<DefId>;\n+}\n+\n+impl<T: GetDefId> GetDefId for Option<T> {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id())\n+    }\n+}\n+\n impl Type {\n     pub fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n@@ -1499,7 +1505,9 @@ impl Type {\n             _ => None,\n         }\n     }\n+}\n \n+impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n@@ -1884,18 +1892,11 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                         Item {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n-                            attrs: Vec::new(),\n+                            attrs: cx.tcx().get_attrs(field.did).clean(cx),\n                             visibility: Some(field.vis),\n-                            // FIXME: this is not accurate, we need an id for\n-                            //        the specific field but we're using the id\n-                            //        for the whole variant. Thus we read the\n-                            //        stability from the whole variant as well.\n-                            //        Struct variants are experimental and need\n-                            //        more infrastructure work before we can get\n-                            //        at the needed information here.\n-                            def_id: self.did,\n-                            stability: get_stability(cx, self.did),\n-                            deprecation: get_deprecation(cx, self.did),\n+                            def_id: field.did,\n+                            stability: get_stability(cx, field.did),\n+                            deprecation: get_deprecation(cx, field.did),\n                             inner: StructFieldItem(\n                                 TypedStructField(field.unsubst_ty().clean(cx))\n                             )\n@@ -1908,7 +1909,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n             name: Some(self.name.clean(cx)),\n             attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n             source: Span::empty(),\n-            visibility: Some(hir::Public),\n+            visibility: Some(hir::Inherited),\n             def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),\n             stability: get_stability(cx, self.did),\n@@ -2208,6 +2209,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n+    pub provided_trait_methods: HashSet<String>,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n@@ -2227,12 +2229,19 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if let Some(ResolvedPath { did, .. }) = trait_ {\n-            if Some(did) == cx.deref_trait_did.get() {\n-                build_deref_target_impls(cx, &items, &mut ret);\n-            }\n+        if trait_.def_id() == cx.deref_trait_did.get() {\n+            build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n+        let provided = trait_.def_id().and_then(|did| {\n+            cx.tcx_opt().map(|tcx| {\n+                tcx.provided_trait_methods(did)\n+                   .into_iter()\n+                   .map(|meth| meth.name.to_string())\n+                   .collect()\n+            })\n+        }).unwrap_or(HashSet::new());\n+\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -2244,6 +2253,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n+                provided_trait_methods: provided,\n                 trait_: trait_,\n                 for_: self.for_.clean(cx),\n                 items: items,"}, {"sha": "e7304b6951083e064380c37378c1f321cfe9fb1e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -607,15 +607,15 @@ mod tests {\n     fn issue_17736() {\n         let markdown = \"# title\";\n         format!(\"{}\", Markdown(markdown));\n-        reset_ids();\n+        reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n             let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect);\n-            reset_ids();\n+            reset_ids(true);\n         }\n \n         t(\"# Foo bar\", \"\\n<h1 id='foo-bar' class='section-header'>\\\n@@ -654,7 +654,7 @@ mod tests {\n               <a href='#panics-1'>Panics</a></h1>\");\n         };\n         test();\n-        reset_ids();\n+        reset_ids(true);\n         test();\n     }\n "}, {"sha": "0f436efd70b2ed00791d03e43b19a3267e77ac23", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 113, "deletions": 77, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc_front::hir;\n \n-use clean::{self, SelfTy, Attributes};\n+use clean::{self, SelfTy, Attributes, GetDefId};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -144,9 +144,7 @@ pub struct Impl {\n \n impl Impl {\n     fn trait_did(&self) -> Option<DefId> {\n-        self.impl_.trait_.as_ref().and_then(|tr| {\n-            if let clean::ResolvedPath { did, .. } = *tr {Some(did)} else {None}\n-        })\n+        self.impl_.trait_.def_id()\n     }\n }\n \n@@ -380,8 +378,14 @@ fn init_ids() -> HashMap<String, usize> {\n /// This method resets the local table of used ID attributes. This is typically\n /// used at the beginning of rendering an entire HTML page to reset from the\n /// previous state (if any).\n-pub fn reset_ids() {\n-    USED_ID_MAP.with(|s| *s.borrow_mut() = init_ids());\n+pub fn reset_ids(embedded: bool) {\n+    USED_ID_MAP.with(|s| {\n+        *s.borrow_mut() = if embedded {\n+            init_ids()\n+        } else {\n+            HashMap::new()\n+        };\n+    });\n }\n \n pub fn derive_id(candidate: String) -> String {\n@@ -967,7 +971,7 @@ impl DocFolder for Cache {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(clean::ResolvedPath{ did, .. }) = i.trait_ {\n+            if let Some(did) = i.trait_.def_id() {\n                 self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n                     def_id: item.def_id,\n                     stability: item.stability.clone(),\n@@ -1282,7 +1286,7 @@ impl Context {\n                 keywords: &keywords,\n             };\n \n-            reset_ids();\n+            reset_ids(true);\n \n             // We have a huge number of calls to write, so try to alleviate some\n             // of the pain by using a buffered writer instead of invoking the\n@@ -2023,10 +2027,33 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n-fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n-               ty: &clean::Type, default: Option<&String>)\n-               -> fmt::Result {\n-    write!(w, \"const {}\", it.name.as_ref().unwrap())?;\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n+    use html::item_type::ItemType::*;\n+\n+    let name = it.name.as_ref().unwrap();\n+    let ty = match shortty(it) {\n+        Typedef | AssociatedType => AssociatedType,\n+        s@_ => s,\n+    };\n+\n+    let anchor = format!(\"#{}.{}\", ty, name);\n+    match link {\n+        AssocItemLink::Anchor => anchor,\n+        AssocItemLink::GotoSource(did, _) => {\n+            href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+        }\n+    }\n+}\n+\n+fn assoc_const(w: &mut fmt::Formatter,\n+               it: &clean::Item,\n+               ty: &clean::Type,\n+               default: Option<&String>,\n+               link: AssocItemLink) -> fmt::Result {\n+    write!(w, \"const <a href='{}' class='constant'>{}</a>\",\n+           naive_assoc_href(it, link),\n+           it.name.as_ref().unwrap())?;\n+\n     write!(w, \": {}\", ty)?;\n     if let Some(default) = default {\n         write!(w, \" = {}\", default)?;\n@@ -2036,13 +2063,15 @@ fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n-              default: &Option<clean::Type>)\n-              -> fmt::Result {\n-    write!(w, \"type {}\", it.name.as_ref().unwrap())?;\n+              default: Option<&clean::Type>,\n+              link: AssocItemLink) -> fmt::Result {\n+    write!(w, \"type <a href='{}' class='type'>{}</a>\",\n+           naive_assoc_href(it, link),\n+           it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n         write!(w, \": {}\", TyParamBounds(bounds))?\n     }\n-    if let Some(ref default) = *default {\n+    if let Some(default) = default {\n         write!(w, \" = {}\", default)?;\n     }\n     Ok(())\n@@ -2066,10 +2095,11 @@ fn render_stability_since(w: &mut fmt::Formatter,\n     render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n }\n \n-fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n+fn render_assoc_item(w: &mut fmt::Formatter,\n+                     item: &clean::Item,\n                      link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n-              it: &clean::Item,\n+              meth: &clean::Item,\n               unsafety: hir::Unsafety,\n               constness: hir::Constness,\n               abi: abi::Abi,\n@@ -2080,14 +2110,23 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n               -> fmt::Result {\n         use syntax::abi::Abi;\n \n-        let name = it.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", shortty(it), name);\n+        let name = meth.name.as_ref().unwrap();\n+        let anchor = format!(\"#{}.{}\", shortty(meth), name);\n         let href = match link {\n             AssocItemLink::Anchor => anchor,\n-            AssocItemLink::GotoSource(did) => {\n-                href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            AssocItemLink::GotoSource(did, provided_methods) => {\n+                // We're creating a link from an impl-item to the corresponding\n+                // trait-item and need to map the anchored type accordingly.\n+                let ty = if provided_methods.contains(name) {\n+                    ItemType::Method\n+                } else {\n+                    ItemType::TyMethod\n+                };\n+\n+                href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n+        // FIXME(#24111): remove when `const_fn` is stabilized\n         let vis_constness = match get_unstable_features_setting() {\n             UnstableFeatures::Allow => constness,\n             _ => hir::Constness::NotConst\n@@ -2106,21 +2145,21 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n     }\n-    match meth.inner {\n+    match item.inner {\n         clean::TyMethodItem(ref m) => {\n-            method(w, meth, m.unsafety, hir::Constness::NotConst,\n+            method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n         }\n         clean::MethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.constness,\n+            method(w, item, m.unsafety, m.constness,\n                    m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n-            assoc_const(w, meth, ty, default.as_ref())\n+            assoc_const(w, item, ty, default.as_ref(), link)\n         }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n-            assoc_type(w, meth, bounds, default)\n+            assoc_type(w, item, bounds, default.as_ref(), link)\n         }\n         _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n@@ -2153,8 +2192,9 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\")?;\n             for field in fields {\n                 write!(w, \"<tr class='stab {stab}'>\n-                             <td id='structfield.{name}'>\\\n+                             <td id='{shortty}.{name}'>\\\n                                <code>{name}</code></td><td>\",\n+                       shortty = ItemType::StructField,\n                        stab = field.stability_class(),\n                        name = field.name.as_ref().unwrap())?;\n                 document(w, cx, field)?;\n@@ -2224,7 +2264,8 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\")?;\n         for variant in &e.variants {\n-            write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+            write!(w, \"<tr><td id='{shortty}.{name}'><code>{name}</code></td><td>\",\n+                   shortty = ItemType::Variant,\n                    name = variant.name.as_ref().unwrap())?;\n             document(w, cx, variant)?;\n \n@@ -2240,8 +2281,9 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                            <table>\")?;\n                 for field in fields {\n                     write!(w, \"<tr><td \\\n-                               id='variant.{v}.field.{f}'>\\\n+                               id='{shortty}.{v}.field.{f}'>\\\n                                <code>{f}</code></td><td>\",\n+                           shortty = ItemType::Variant,\n                            v = variant.name.as_ref().unwrap(),\n                            f = field.name.as_ref().unwrap())?;\n                     document(w, cx, field)?;\n@@ -2338,9 +2380,9 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n #[derive(Copy, Clone)]\n-enum AssocItemLink {\n+enum AssocItemLink<'a> {\n     Anchor,\n-    GotoSource(DefId),\n+    GotoSource(DefId, &'a HashSet<String>),\n }\n \n enum AssocItemRender<'a> {\n@@ -2383,12 +2425,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n-            match *t.impl_.trait_.as_ref().unwrap() {\n-                clean::ResolvedPath { did, .. } => {\n-                    Some(did) == c.deref_trait_did\n-                }\n-                _ => false\n-            }\n+            t.impl_.trait_.def_id() == c.deref_trait_did\n         });\n         if let Some(impl_) = deref_impl {\n             render_deref_methods(w, cx, impl_, containing_item)?;\n@@ -2400,17 +2437,17 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                        containing_item.stable_since())?;\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+            render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n             write!(w, \"<h3 id='derived_implementations'>\\\n                            Derived Implementations \\\n                        </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                            containing_item.stable_since())?;\n+                let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+                render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n             }\n         }\n     }\n@@ -2427,17 +2464,16 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n         }\n     }).next().expect(\"Expected associated type binding\");\n     let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n-    match *target {\n-        clean::ResolvedPath { did, .. } => render_assoc_items(w, cx, container_item, did, what),\n-        _ => {\n-            if let Some(prim) = target.primitive_type() {\n-                if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = DefId { krate: *c, index: prim.to_def_index() };\n-                    render_assoc_items(w, cx, container_item, did, what)?;\n-                }\n+    if let Some(did) = target.def_id() {\n+        render_assoc_items(w, cx, container_item, did, what)\n+    } else {\n+        if let Some(prim) = target.primitive_type() {\n+            if let Some(c) = cache().primitive_locations.get(&prim) {\n+                let did = DefId { krate: *c, index: prim.to_def_index() };\n+                render_assoc_items(w, cx, container_item, did, what)?;\n             }\n-            Ok(())\n         }\n+        Ok(())\n     }\n }\n \n@@ -2459,6 +2495,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n                     link: AssocItemLink, render_static: bool,\n                     outer_version: Option<&str>) -> fmt::Result {\n+        let shortty = shortty(item);\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n@@ -2471,36 +2508,36 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static || render_static {\n-                    let id = derive_id(format!(\"method.{}\", name));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item))?;\n+                    let id = derive_id(format!(\"{}.{}\", shortty, name));\n+                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty)?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link)?;\n                     write!(w, \"</code></h4>\\n\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n-                let id = derive_id(format!(\"associatedtype.{}\", name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n-                write!(w, \"type {} = {}\", name, tydef.type_)?;\n+                let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"associatedconstant.{}\", name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n-                assoc_const(w, item, ty, default.as_ref())?;\n+                let id = derive_id(format!(\"{}.{}\", shortty, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                assoc_const(w, item, ty, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n-                let id = derive_id(format!(\"associatedconstant.{}\", name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n-                assoc_const(w, item, &c.type_, Some(&c.expr))?;\n+                let id = derive_id(format!(\"{}.{}\", shortty, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                assoc_const(w, item, &c.type_, Some(&c.expr), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"associatedtype.{}\", name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n-                assoc_type(w, item, bounds, default)?;\n+                let id = derive_id(format!(\"{}.{}\", shortty, name));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                assoc_type(w, item, bounds, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n@@ -2521,30 +2558,29 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n-                            did: DefId,\n                             t: &clean::Trait,\n-                              i: &clean::Impl,\n-                              render_static: bool,\n-                              outer_version: Option<&str>) -> fmt::Result {\n+                            i: &clean::Impl,\n+                            render_static: bool,\n+                            outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n-            if i.items.iter().find(|m| { m.name == n }).is_some() {\n+            if i.items.iter().find(|m| m.name == n).is_some() {\n                 continue;\n             }\n+            let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n-            doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n+            doctraititem(w, cx, trait_item, assoc_link, render_static,\n                          outer_version)?;\n         }\n         Ok(())\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n-    // default methods which weren't overridden in the implementation block.\n-    // FIXME: this also needs to be done for associated types, whenever defaults\n-    // for them work.\n-    if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n+    // default items which weren't overridden in the implementation block.\n+    if let Some(did) = i.trait_did() {\n         if let Some(t) = cache().traits.get(&did) {\n-            render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version)?;\n+            render_default_items(w, cx, t, &i.impl_, render_header, outer_version)?;\n         }\n     }\n     write!(w, \"</div>\")?;\n@@ -2718,6 +2754,6 @@ fn test_unique_id() {\n         assert_eq!(&actual[..], expected);\n     };\n     test();\n-    reset_ids();\n+    reset_ids(true);\n     test();\n }"}, {"sha": "d21726dd40f08195ec366b989025a38c5b47b331", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -83,7 +83,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     }\n     let title = metadata[0];\n \n-    reset_ids();\n+    reset_ids(false);\n \n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))"}, {"sha": "88cb20991d66059e8edb3051aeb31c855621beb7", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -16,7 +16,7 @@ use std::string::String;\n use std::usize;\n use rustc_front::hir;\n \n-use clean::{self, Attributes};\n+use clean::{self, Attributes, GetDefId};\n use clean::Item;\n use plugins;\n use fold;\n@@ -74,7 +74,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                         return None;\n                     }\n                     // Impls of stripped traits also don't need to exist\n-                    if let Some(clean::ResolvedPath { did, .. }) = *trait_ {\n+                    if let Some(did) = trait_.def_id() {\n                         if self.stripped.contains(&did) {\n                             return None;\n                         }\n@@ -223,13 +223,10 @@ struct ImplStripper<'a>(&'a DefIdSet);\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n-            match imp.trait_ {\n-                Some(clean::ResolvedPath{ did, .. }) => {\n-                    if did.is_local() && !self.0.contains(&did) {\n-                        return None;\n-                    }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.0.contains(&did) {\n+                    return None;\n                 }\n-                Some(..) | None => {}\n             }\n         }\n         self.fold_item_recur(i)"}, {"sha": "5362f7086bd8b0413c90fcd56a8e25d609f9fe9a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -1254,7 +1254,7 @@ pub trait BufRead: Read {\n     /// longer be returned. As such, this function may do odd things if\n     /// `fill_buf` isn't called before calling it.\n     ///\n-    /// [fillbuf]: #tymethod.fill_buff\n+    /// [fillbuf]: #tymethod.fill_buf\n     ///\n     /// The `amt` must be `<=` the number of bytes in the buffer returned by\n     /// `fill_buf`."}, {"sha": "f7b1042592d855ad6655a060fc837a311c033edc", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -190,7 +190,7 @@\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/crates-and-modules.html#importing-modules-with-use\n-//! [crate root]: ../book/crates-and-modules.html#basic-terminology:-crates-and-modules\n+//! [crate root]: ../book/crates-and-modules.html#basic-terminology-crates-and-modules\n //! [crates.io]: https://crates.io\n //! [deref coercions]: ../book/deref-coercions.html\n //! [files]: fs/struct.File.html"}, {"sha": "38da74b89039b9f03e0d752ff9dc5727b9c3f6b1", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -196,7 +196,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_nodelay`][link].\n     ///\n-    /// [link]: #tymethod.set_nodelay\n+    /// [link]: #method.set_nodelay\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn nodelay(&self) -> io::Result<bool> {\n         self.0.nodelay()\n@@ -215,7 +215,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -238,7 +238,7 @@ impl TcpStream {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -374,7 +374,7 @@ impl TcpListener {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -397,7 +397,7 @@ impl TcpListener {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()"}, {"sha": "0be9f13e817614bfefb0044be40cbbcbb97a84fc", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -155,7 +155,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_broadcast`][link].\n     ///\n-    /// [link]: #tymethod.set_broadcast\n+    /// [link]: #method.set_broadcast\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn broadcast(&self) -> io::Result<bool> {\n         self.0.broadcast()\n@@ -175,7 +175,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_loop_v4`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_loop_v4\n+    /// [link]: #method.set_multicast_loop_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v4()\n@@ -198,7 +198,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_ttl_v4`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_ttl_v4\n+    /// [link]: #method.set_multicast_ttl_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n         self.0.multicast_ttl_v4()\n@@ -218,7 +218,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`set_multicast_loop_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_multicast_loop_v6\n+    /// [link]: #method.set_multicast_loop_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n         self.0.multicast_loop_v6()\n@@ -237,7 +237,7 @@ impl UdpSocket {\n     ///\n     /// For more information about this option, see [`set_ttl`][link].\n     ///\n-    /// [link]: #tymethod.set_ttl\n+    /// [link]: #method.set_ttl\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -260,7 +260,7 @@ impl UdpSocket {\n     ///\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n-    /// [link]: #tymethod.set_only_v6\n+    /// [link]: #method.set_only_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -293,7 +293,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`join_multicast_v4`][link].\n     ///\n-    /// [link]: #tymethod.join_multicast_v4\n+    /// [link]: #method.join_multicast_v4\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n         self.0.leave_multicast_v4(multiaddr, interface)\n@@ -304,7 +304,7 @@ impl UdpSocket {\n     /// For more information about this option, see\n     /// [`join_multicast_v6`][link].\n     ///\n-    /// [link]: #tymethod.join_multicast_v6\n+    /// [link]: #method.join_multicast_v6\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         self.0.leave_multicast_v6(multiaddr, interface)"}, {"sha": "0db92a491ed180d18b654c76994ae97f0b309a8a", "filename": "src/test/rustdoc/issue-28478.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(associated_consts)]\n+\n+// @has issue_28478/trait.Bar.html\n+pub trait Bar {\n+    // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = ()'\n+    // @has - '//*[@href=\"#associatedtype.Bar\"]' 'Bar'\n+    type Bar = ();\n+    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize = 7'\n+    // @has - '//*[@href=\"#associatedconstant.Baz\"]' 'Baz'\n+    const Baz: usize = 7;\n+    // @has - '//*[@id=\"tymethod.bar\"]' 'fn bar'\n+    fn bar();\n+    // @has - '//*[@id=\"method.baz\"]' 'fn baz'\n+    fn baz() { }\n+}\n+\n+// @has issue_28478/struct.Foo.html\n+pub struct Foo;\n+\n+impl Foo {\n+    // @has - '//*[@href=\"#method.foo\"]' 'foo'\n+    pub fn foo() {}\n+}\n+\n+impl Bar for Foo {\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedtype.Bar\"]' 'Bar'\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedconstant.Baz\"]' 'Baz'\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#tymethod.bar\"]' 'bar'\n+    fn bar() {}\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#method.baz\"]' 'baz'\n+}"}, {"sha": "672c8757049d9fc5420eebab44b3f644cadc4fda", "filename": "src/test/rustdoc/issue-32395.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32395.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -14,8 +14,10 @@\n \n // @has variant_struct/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub Bar'\n extern crate variant_struct;\n \n // @has issue_32395/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub Bar'\n pub use variant_struct::Foo;"}, {"sha": "12419d4f7e5f79ee4f9053e668e0ed2b1a81b473", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 231, "deletions": 47, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/cad964a62655110753d73527df7ad808a235fc84/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad964a62655110753d73527df7ad808a235fc84/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=cad964a62655110753d73527df7ad808a235fc84", "patch": "@@ -17,9 +17,9 @@\n //! actually point to a valid place.\n //!\n //! Currently this doesn't actually do any HTML parsing or anything fancy like\n-//! that, it just has a simple \"regex\" to search for `href` tags. These values\n-//! are then translated to file URLs if possible and then the destination is\n-//! asserted to exist.\n+//! that, it just has a simple \"regex\" to search for `href` and `id` tags.\n+//! These values are then translated to file URLs if possible and then the\n+//! destination is asserted to exist.\n //!\n //! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n //! but this should catch the majority of \"broken link\" cases.\n@@ -29,14 +29,18 @@ extern crate url;\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n+use std::collections::{HashMap, HashSet};\n+use std::collections::hash_map::Entry;\n \n use url::{Url, UrlParser};\n \n+use Redirect::*;\n+\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+        Err(e) => panic!(\"{} failed with {:?}\", stringify!($e), e),\n     })\n }\n \n@@ -45,74 +49,270 @@ fn main() {\n     let docs = env::current_dir().unwrap().join(docs);\n     let mut url = Url::from_file_path(&docs).unwrap();\n     let mut errors = false;\n-    walk(&docs, &docs, &mut url, &mut errors);\n+    walk(&mut HashMap::new(), &docs, &docs, &mut url, &mut errors);\n     if errors {\n         panic!(\"found some broken links\");\n     }\n }\n \n-fn walk(root: &Path, dir: &Path, url: &mut Url, errors: &mut bool) {\n+#[derive(Debug)]\n+pub enum LoadError {\n+    IOError(std::io::Error),\n+    BrokenRedirect(PathBuf, std::io::Error),\n+    IsRedirect,\n+}\n+\n+enum Redirect {\n+    SkipRedirect,\n+    FromRedirect(bool),\n+}\n+\n+struct FileEntry {\n+    source: String,\n+    ids: HashSet<String>,\n+}\n+\n+type Cache = HashMap<PathBuf, FileEntry>;\n+\n+impl FileEntry {\n+    fn parse_ids(&mut self,\n+                file: &Path,\n+                contents: &str,\n+                errors: &mut bool)\n+{\n+        if self.ids.is_empty() {\n+            with_attrs_in_source(contents, \" id\", |fragment, i| {\n+                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                if !self.ids.insert(frag) {\n+                    *errors = true;\n+                    println!(\"{}:{}: id is not unique: `{}`\",\n+                             file.display(), i, fragment);\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+fn walk(cache: &mut Cache,\n+        root: &Path,\n+        dir: &Path,\n+        url: &mut Url,\n+        errors: &mut bool)\n+{\n     for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n         let path = entry.path();\n         let kind = t!(entry.file_type());\n         url.path_mut().unwrap().push(entry.file_name().into_string().unwrap());\n         if kind.is_dir() {\n-            walk(root, &path, url, errors);\n+            walk(cache, root, &path, url, errors);\n         } else {\n-            check(root, &path, url, errors);\n+            let pretty_path = check(cache, root, &path, url, errors);\n+            if let Some(pretty_path) = pretty_path {\n+                let entry = cache.get_mut(&pretty_path).unwrap();\n+                // we don't need the source anymore,\n+                // so drop to to reduce memory-usage\n+                entry.source = String::new();\n+            }\n         }\n         url.path_mut().unwrap().pop();\n     }\n }\n \n-fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n+fn check(cache: &mut Cache,\n+         root: &Path,\n+         file: &Path,\n+         base: &Url,\n+         errors: &mut bool) -> Option<PathBuf>\n+{\n     // ignore js files as they are not prone to errors as the rest of the\n     // documentation is and they otherwise bring up false positives.\n     if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n-        return\n+        return None;\n     }\n \n-    let pretty_file = file.strip_prefix(root).unwrap_or(file);\n-\n     // Unfortunately we're not 100% full of valid links today to we need a few\n     // whitelists to get this past `make check` today.\n     // FIXME(#32129)\n     if file.ends_with(\"std/string/struct.String.html\") {\n-        return\n+        return None;\n+    }\n+    // FIXME(#32553)\n+    if file.ends_with(\"collections/string/struct.String.html\") {\n+        return None;\n     }\n     // FIXME(#32130)\n     if file.ends_with(\"btree_set/struct.BTreeSet.html\") ||\n-       file.ends_with(\"collections/struct.BTreeSet.html\") {\n-        return\n+       file.ends_with(\"collections/struct.BTreeSet.html\") ||\n+       file.ends_with(\"collections/btree_map/struct.BTreeMap.html\") ||\n+       file.ends_with(\"collections/hash_map/struct.HashMap.html\") {\n+        return None;\n     }\n \n     if file.ends_with(\"std/sys/ext/index.html\") {\n-        return\n+        return None;\n     }\n \n     if let Some(file) = file.to_str() {\n         // FIXME(#31948)\n         if file.contains(\"ParseFloatError\") {\n-            return\n+            return None;\n         }\n         // weird reexports, but this module is on its way out, so chalk it up to\n         // \"rustdoc weirdness\" and move on from there\n         if file.contains(\"scoped_tls\") {\n-            return\n+            return None;\n         }\n     }\n \n     let mut parser = UrlParser::new();\n     parser.base_url(base);\n+\n+    let res = load_file(cache, root, PathBuf::from(file), SkipRedirect);\n+    let (pretty_file, contents) = match res {\n+        Ok(res) => res,\n+        Err(_) => return None,\n+    };\n+    {\n+        cache.get_mut(&pretty_file).unwrap()\n+                                   .parse_ids(&pretty_file, &contents, errors);\n+    }\n+\n+    // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n+    with_attrs_in_source(&contents, \" href\", |url, i| {\n+        // Once we've plucked out the URL, parse it using our base url and\n+        // then try to extract a file path. If either of these fail then we\n+        // just keep going.\n+        let (parsed_url, path) = match url_to_file_path(&parser, url) {\n+            Some((url, path)) => (url, PathBuf::from(path)),\n+            None => return,\n+        };\n+\n+        // Alright, if we've found a file name then this file had better\n+        // exist! If it doesn't then we register and print an error.\n+        if path.exists() {\n+            if path.is_dir() {\n+                return;\n+            }\n+            let res = load_file(cache, root, path.clone(), FromRedirect(false));\n+            let (pretty_path, contents) = match res {\n+                Ok(res) => res,\n+                Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n+                Err(LoadError::BrokenRedirect(target, _)) => {\n+                    print!(\"{}:{}: broken redirect to {}\",\n+                           pretty_file.display(), i + 1, target.display());\n+                    return;\n+                }\n+                Err(LoadError::IsRedirect) => unreachable!(),\n+            };\n+\n+            if let Some(ref fragment) = parsed_url.fragment {\n+                // Fragments like `#1-6` are most likely line numbers to be\n+                // interpreted by javascript, so we're ignoring these\n+                if fragment.splitn(2, '-')\n+                           .all(|f| f.chars().all(|c| c.is_numeric())) {\n+                    return;\n+                }\n+\n+                let entry = &mut cache.get_mut(&pretty_path).unwrap();\n+                entry.parse_ids(&pretty_path, &contents, errors);\n+\n+                if !entry.ids.contains(fragment) {\n+                    *errors = true;\n+                    print!(\"{}:{}: broken link fragment  \",\n+                           pretty_file.display(), i + 1);\n+                    println!(\"`#{}` pointing to `{}`\",\n+                             fragment, pretty_path.display());\n+                };\n+            }\n+        } else {\n+            *errors = true;\n+            print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n+            let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n+            println!(\"{}\", pretty_path.display());\n+        }\n+    });\n+    Some(pretty_file)\n+}\n+\n+fn load_file(cache: &mut Cache,\n+             root: &Path,\n+             file: PathBuf,\n+             redirect: Redirect) -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n-    if t!(File::open(file)).read_to_string(&mut contents).is_err() {\n-        return\n+    let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n+\n+    let maybe_redirect = match cache.entry(pretty_file.clone()) {\n+        Entry::Occupied(entry) => {\n+            contents = entry.get().source.clone();\n+            None\n+        },\n+        Entry::Vacant(entry) => {\n+            let mut fp = try!(File::open(file.clone()).map_err(|err| {\n+                if let FromRedirect(true) = redirect {\n+                    LoadError::BrokenRedirect(file.clone(), err)\n+                } else {\n+                    LoadError::IOError(err)\n+                }\n+            }));\n+            try!(fp.read_to_string(&mut contents)\n+                   .map_err(|err| LoadError::IOError(err)));\n+\n+            let maybe = maybe_redirect(&contents);\n+            if maybe.is_some() {\n+                if let SkipRedirect = redirect {\n+                    return Err(LoadError::IsRedirect);\n+                }\n+            } else {\n+                entry.insert(FileEntry {\n+                    source: contents.clone(),\n+                    ids: HashSet::new(),\n+                });\n+            }\n+            maybe\n+        },\n+    };\n+    let base = Url::from_file_path(&file).unwrap();\n+    let mut parser = UrlParser::new();\n+    parser.base_url(&base);\n+\n+    match maybe_redirect.and_then(|url| url_to_file_path(&parser, &url)) {\n+        Some((_, redirect_file)) => {\n+            let path = PathBuf::from(redirect_file);\n+            load_file(cache, root, path, FromRedirect(true))\n+        }\n+        None => Ok((pretty_file, contents))\n     }\n+}\n+\n+fn maybe_redirect(source: &str) -> Option<String> {\n+    const REDIRECT: &'static str = \"<p>Redirecting to <a href=\";\n+\n+    let mut lines = source.lines();\n+    let redirect_line = match lines.nth(6) {\n+        Some(l) => l,\n+        None => return None,\n+    };\n+\n+    redirect_line.find(REDIRECT).map(|i| {\n+        let rest = &redirect_line[(i + REDIRECT.len() + 1)..];\n+        let pos_quote = rest.find('\"').unwrap();\n+        rest[..pos_quote].to_owned()\n+    })\n+}\n \n+fn url_to_file_path(parser: &UrlParser, url: &str) -> Option<(Url, PathBuf)> {\n+    parser.parse(url).ok().and_then(|parsed_url| {\n+        parsed_url.to_file_path().ok().map(|f| (parsed_url, f))\n+    })\n+}\n+\n+fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str,\n+                                               attr: &str,\n+                                               mut f: F)\n+{\n     for (i, mut line) in contents.lines().enumerate() {\n-        // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-        while let Some(j) = line.find(\" href\") {\n-            let rest = &line[j + 5..];\n+        while let Some(j) = line.find(attr) {\n+            let rest = &line[j + attr.len() ..];\n             line = rest;\n             let pos_equals = match rest.find(\"=\") {\n                 Some(i) => i,\n@@ -121,40 +321,24 @@ fn check(root: &Path, file: &Path, base: &Url, errors: &mut bool) {\n             if rest[..pos_equals].trim_left_matches(\" \") != \"\" {\n                 continue\n             }\n+\n             let rest = &rest[pos_equals + 1..];\n-            let pos_quote = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+\n+            let pos_quote = match rest.find(&['\"', '\\''][..]) {\n                 Some(i) => i,\n                 None => continue,\n             };\n+            let quote_delim = rest.as_bytes()[pos_quote] as char;\n+\n             if rest[..pos_quote].trim_left_matches(\" \") != \"\" {\n                 continue\n             }\n             let rest = &rest[pos_quote + 1..];\n-            let url = match rest.find(\"\\\"\").or_else(|| rest.find(\"'\")) {\n+            let url = match rest.find(quote_delim) {\n                 Some(i) => &rest[..i],\n                 None => continue,\n             };\n-\n-            // Once we've plucked out the URL, parse it using our base url and\n-            // then try to extract a file path. If either if these fail then we\n-            // just keep going.\n-            let parsed_url = match parser.parse(url) {\n-                Ok(url) => url,\n-                Err(..) => continue,\n-            };\n-            let path = match parsed_url.to_file_path() {\n-                Ok(path) => path,\n-                Err(..) => continue,\n-            };\n-\n-            // Alright, if we've found a file name then this file had better\n-            // exist! If it doesn't then we register and print an error.\n-            if !path.exists() {\n-                *errors = true;\n-                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n-                let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-                println!(\"{}\", pretty_path.display());\n-            }\n+            f(url, i)\n         }\n     }\n }"}]}