{"sha": "1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5OTliZmFhOWY5NjFjZTJlMGM4MmU5N2Y5YmMxNTJkNWNlNWVkNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-11T04:04:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-11T04:04:11Z"}, "message": "Auto merge of #42913 - kennytm:fix-40569-ident-without-backtrack, r=jseyfried\n\nOnly match a fragment specifier the if it starts with certain tokens.\n\nWhen trying to match a fragment specifier, we first predict whether the current token can be matched at all. If it cannot be matched, don't bother to push the Earley item to `bb_eis`. This can fix a lot of issues which otherwise requires full backtracking (#42838).\n\nIn this PR the prediction treatment is not done for `:item`, `:stmt` and `:tt`, but it could be expanded in the future.\n\nFixes #24189.\nFixes #26444.\nFixes #27832.\nFixes #34030.\nFixes #35650.\nFixes #39964.\nFixes the 4th comment in #40569.\nFixes the issue blocking #40984.", "tree": {"sha": "74733e43e94e408c8ff016c4532e1337402198b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74733e43e94e408c8ff016c4532e1337402198b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "html_url": "https://github.com/rust-lang/rust/commit/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9228d231fc05488647c6d72516b527963310ac2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9228d231fc05488647c6d72516b527963310ac2d", "html_url": "https://github.com/rust-lang/rust/commit/9228d231fc05488647c6d72516b527963310ac2d"}, {"sha": "600800480a750978a5ed6d29188056e950ae2075", "url": "https://api.github.com/repos/rust-lang/rust/commits/600800480a750978a5ed6d29188056e950ae2075", "html_url": "https://github.com/rust-lang/rust/commit/600800480a750978a5ed6d29188056e950ae2075"}], "stats": {"total": 323, "additions": 317, "deletions": 6}, "files": [{"sha": "d18961b75c84aed7bcecde5dd14697927655d5c4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "patch": "@@ -386,12 +386,11 @@ fn inner_parse_loop(sess: &ParseSess,\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n-                TokenTree::MetaVarDecl(..) => {\n+                TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    match *token {\n-                        token::CloseDelim(_) => {},\n-                        _ => bb_eis.push(ei),\n+                    if may_begin_with(&*id.name.as_str(), token) {\n+                        bb_eis.push(ei);\n                     }\n                 }\n                 seq @ TokenTree::Delimited(..) | seq @ TokenTree::Token(_, DocComment(..)) => {\n@@ -493,6 +492,73 @@ pub fn parse(sess: &ParseSess,\n     }\n }\n \n+/// Checks whether a non-terminal may begin with a particular token.\n+///\n+/// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n+/// token. Be conservative (return true) if not sure.\n+fn may_begin_with(name: &str, token: &Token) -> bool {\n+    /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n+    fn may_be_ident(nt: &token::Nonterminal) -> bool {\n+        match *nt {\n+            token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) => false,\n+            _ => true,\n+        }\n+    }\n+\n+    match name {\n+        \"expr\" => token.can_begin_expr(),\n+        \"ty\" => token.can_begin_type(),\n+        \"ident\" => token.is_ident(),\n+        \"vis\" => match *token { // The follow-set of :vis + \"priv\" keyword + interpolated\n+            Token::Comma | Token::Ident(_) | Token::Interpolated(_) => true,\n+            _ => token.can_begin_type(),\n+        },\n+        \"block\" => match *token {\n+            Token::OpenDelim(token::Brace) => true,\n+            Token::Interpolated(ref nt) => match nt.0 {\n+                token::NtItem(_) |\n+                token::NtPat(_) |\n+                token::NtTy(_) |\n+                token::NtIdent(_) |\n+                token::NtMeta(_) |\n+                token::NtPath(_) |\n+                token::NtVis(_) => false, // none of these may start with '{'.\n+                _ => true,\n+            },\n+            _ => false,\n+        },\n+        \"path\" | \"meta\" => match *token {\n+            Token::ModSep | Token::Ident(_) => true,\n+            Token::Interpolated(ref nt) => match nt.0 {\n+                token::NtPath(_) | token::NtMeta(_) => true,\n+                _ => may_be_ident(&nt.0),\n+            },\n+            _ => false,\n+        },\n+        \"pat\" => match *token {\n+            Token::Ident(_) |               // box, ref, mut, and other identifiers (can stricten)\n+            Token::OpenDelim(token::Paren) |    // tuple pattern\n+            Token::OpenDelim(token::Bracket) |  // slice pattern\n+            Token::BinOp(token::And) |          // reference\n+            Token::BinOp(token::Minus) |        // negative literal\n+            Token::AndAnd |                     // double reference\n+            Token::Literal(..) |                // literal\n+            Token::DotDot |                     // range pattern (future compat)\n+            Token::DotDotDot |                  // range pattern (future compat)\n+            Token::ModSep |                     // path\n+            Token::Lt |                         // path (UFCS constant)\n+            Token::BinOp(token::Shl) |          // path (double UFCS)\n+            Token::Underscore => true,          // placeholder\n+            Token::Interpolated(ref nt) => may_be_ident(&nt.0),\n+            _ => false,\n+        },\n+        _ => match *token {\n+            token::CloseDelim(_) => false,\n+            _ => true,\n+        },\n+    }\n+}\n+\n fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n     if name == \"tt\" {\n         return token::NtTT(p.parse_token_tree());"}, {"sha": "a20ff864705a13c7fabc11e5158a63712fa3b853", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    panic!(@); //~ ERROR expected expression, found `@`\n+    panic!(@); //~ ERROR no rules expected the token `@`\n }"}, {"sha": "c79e67a3768957c095e5bd088f75ed805bc9309d", "filename": "src/test/compile-fail/vec-macro-with-comma-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs?ref=1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    vec![,]; //~ ERROR expected expression, found `,`\n+    vec![,]; //~ ERROR no rules expected the token `,`\n }"}, {"sha": "99e5d22fb476e9d8b96c13a4bf3fbefdd749ffa2", "filename": "src/test/run-pass/macro-first-set.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Frun-pass%2Fmacro-first-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72/src%2Ftest%2Frun-pass%2Fmacro-first-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-first-set.rs?ref=1999bfaa9f961ce2e0c82e97f9bc152d5ce5ed72", "patch": "@@ -0,0 +1,245 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_vis_matcher)]\n+\n+//{{{ issue 40569 ==============================================================\n+\n+macro_rules! my_struct {\n+    ($(#[$meta:meta])* $ident:ident) => {\n+        $(#[$meta])* struct $ident;\n+    }\n+}\n+\n+my_struct!(#[derive(Debug, PartialEq)] Foo40569);\n+\n+fn test_40569() {\n+    assert_eq!(Foo40569, Foo40569);\n+}\n+\n+//}}}\n+\n+//{{{ issue 26444 ==============================================================\n+\n+macro_rules! foo_26444 {\n+    ($($beginning:ident),*; $middle:ident; $($end:ident),*) => {\n+        stringify!($($beginning,)* $middle $(,$end)*)\n+    }\n+}\n+\n+fn test_26444() {\n+    assert_eq!(\"a , b , c , d , e\", foo_26444!(a, b; c; d, e));\n+    assert_eq!(\"f\", foo_26444!(; f ;));\n+}\n+\n+macro_rules! pat_26444 {\n+    ($fname:ident $($arg:pat)* =) => {}\n+}\n+\n+pat_26444!(foo 1 2 5...7 =);\n+pat_26444!(bar Some(ref x) Ok(ref mut y) &(w, z) =);\n+\n+//}}}\n+\n+//{{{ issue 40984 ==============================================================\n+\n+macro_rules! thread_local_40984 {\n+    () => {};\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => {\n+        thread_local_40984!($($rest)*);\n+    };\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => {};\n+}\n+\n+thread_local_40984! {\n+    // no docs\n+    #[allow(unused)]\n+    static FOO: i32 = 42;\n+    /// docs\n+    pub static BAR: String = String::from(\"bar\");\n+\n+    // look at these restrictions!!\n+    pub(crate) static BAZ: usize = 0;\n+    pub(in foo) static QUUX: usize = 0;\n+}\n+\n+//}}}\n+\n+//{{{ issue 35650 ==============================================================\n+\n+macro_rules! size {\n+    ($ty:ty) => {\n+        std::mem::size_of::<$ty>()\n+    };\n+    ($size:tt) => {\n+        $size\n+    };\n+}\n+\n+fn test_35650() {\n+    assert_eq!(size!(u64), 8);\n+    assert_eq!(size!(5), 5);\n+}\n+\n+//}}}\n+\n+//{{{ issue 27832 ==============================================================\n+\n+macro_rules! m {\n+    ( $i:ident ) => ();\n+    ( $t:tt $j:tt ) => ();\n+}\n+\n+m!(c);\n+m!(t 9);\n+m!(0 9);\n+m!(struct);\n+m!(struct Foo);\n+\n+macro_rules! m2 {\n+    ( $b:expr ) => ();\n+    ( $t:tt $u:tt ) => ();\n+}\n+\n+m2!(3);\n+m2!(1 2);\n+m2!(_ 1);\n+m2!(enum Foo);\n+\n+//}}}\n+\n+//{{{ issue 39964 ==============================================================\n+\n+macro_rules! foo_39964 {\n+    ($a:ident) => {};\n+    (_) => {};\n+}\n+\n+foo_39964!(_);\n+\n+//}}}\n+\n+//{{{ issue 34030 ==============================================================\n+\n+macro_rules! foo_34030 {\n+    ($($t:ident),* /) => {};\n+}\n+\n+foo_34030!(a, b/);\n+foo_34030!(a/);\n+foo_34030!(/);\n+\n+//}}}\n+\n+//{{{ issue 24189 ==============================================================\n+\n+macro_rules! foo_24189 {\n+    (\n+        pub enum $name:ident {\n+            $( #[$attr:meta] )* $var:ident\n+        }\n+    ) => {\n+        pub enum $name {\n+            $( #[$attr] )* $var\n+        }\n+    };\n+}\n+\n+foo_24189! {\n+    pub enum Foo24189 {\n+        #[doc = \"Bar\"] Baz\n+    }\n+}\n+\n+macro_rules! serializable {\n+    (\n+        $(#[$struct_meta:meta])*\n+        pub struct $name:ident {\n+            $(\n+                $(#[$field_meta:meta])*\n+                $field:ident: $type_:ty\n+            ),* ,\n+        }\n+    ) => {\n+        $(#[$struct_meta])*\n+        pub struct $name {\n+            $(\n+                $(#[$field_meta])*\n+                $field: $type_\n+            ),* ,\n+        }\n+    }\n+}\n+\n+serializable! {\n+    #[allow(dead_code)]\n+    /// This is a test\n+    pub struct Tester {\n+        #[allow(dead_code)]\n+        name: String,\n+    }\n+}\n+\n+macro_rules! foo_24189_c {\n+    ( $( > )* $x:ident ) => { };\n+}\n+foo_24189_c!( > a );\n+\n+fn test_24189() {\n+    let _ = Foo24189::Baz;\n+    let _ = Tester { name: \"\".to_owned() };\n+}\n+\n+//}}}\n+\n+//{{{ some more tests ==========================================================\n+\n+macro_rules! test_block {\n+    (< $($b:block)* >) => {}\n+}\n+\n+test_block!(<>);\n+test_block!(<{}>);\n+test_block!(<{1}{2}>);\n+\n+macro_rules! test_ty {\n+    ($($t:ty),* $(,)*) => {}\n+}\n+\n+test_ty!();\n+test_ty!(,);\n+test_ty!(u8);\n+test_ty!(u8,);\n+\n+macro_rules! test_path {\n+    ($($t:path),* $(,)*) => {}\n+}\n+\n+test_path!();\n+test_path!(,);\n+test_path!(::std);\n+test_path!(std::u8,);\n+test_path!(any, super, super::super::self::path, X<Y>::Z<'a, T=U>);\n+\n+macro_rules! test_meta_block {\n+    ($($m:meta)* $b:block) => {};\n+}\n+\n+test_meta_block!(windows {});\n+\n+//}}}\n+\n+fn main() {\n+    test_26444();\n+    test_40569();\n+    test_35650();\n+    test_24189();\n+}\n+"}]}