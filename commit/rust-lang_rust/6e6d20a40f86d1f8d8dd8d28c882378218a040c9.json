{"sha": "6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNmQyMGE0MGY4NmQxZjhkOGRkOGQyOGM4ODIzNzgyMThhMDQwYzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-24T20:31:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-24T20:31:46Z"}, "message": "Merge remote-tracking branch 'mozilla/incoming'", "tree": {"sha": "4bd8e42e9958202e1e1a794aff96c20eedc0c715", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bd8e42e9958202e1e1a794aff96c20eedc0c715"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "html_url": "https://github.com/rust-lang/rust/commit/6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5281771a07ba6d437bcdd9d94343c04ea1ed7221", "url": "https://api.github.com/repos/rust-lang/rust/commits/5281771a07ba6d437bcdd9d94343c04ea1ed7221", "html_url": "https://github.com/rust-lang/rust/commit/5281771a07ba6d437bcdd9d94343c04ea1ed7221"}, {"sha": "f60cdf27e76f9e8c195246e90bfd944680cd7617", "url": "https://api.github.com/repos/rust-lang/rust/commits/f60cdf27e76f9e8c195246e90bfd944680cd7617", "html_url": "https://github.com/rust-lang/rust/commit/f60cdf27e76f9e8c195246e90bfd944680cd7617"}], "stats": {"total": 303, "additions": 179, "deletions": 124}, "files": [{"sha": "e8b8f9b1bf27de8401d101cf20d5236f23b3f8df", "filename": "RELEASES.txt", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,3 +1,44 @@\n+Version 0.3  (June 2012) - not yet!\n+-----------------------------------\n+\n+  * ~1500 changes, numerous bugfixes\n+\n+  * New coding conveniences\n+    * Integer-literal suffix inference\n+    * Per-module control over warnings, errors\n+    * #[cfg(windows)] and #[cfg(unix)] attributes\n+\n+  * Semantic cleanup\n+    * Resolve pass and exhaustiveness checker rewritten\n+    * Borrow-check taking over from alias-analysis\n+    * Liveness taking over from last-use, typestate\n+    * Extensive work on region pointers\n+\n+  * Experimental new language features\n+    * Slices and fixed-size, interior-allocated vectors\n+    * #!-comments for lang versioning, shell execution\n+    * More work on classes\n+    * Type reflection\n+\n+  * Removal of various obsolete features\n+    * Keywords: be, prove, syntax, note, mutable, do, bind\n+    * Constructs: do-while loops, fn binding, \n+\n+  * Compiler reorganization\n+    * Syntax-layer of compiler split into separate crate\n+    * Clang (from LLVM project) integrated into build\n+    * Typechecker split into sub-modules\n+\n+  * New library code\n+    * New time functions\n+    * Extension methods for many built-in types\n+    * Arc: atomic-refcount read-only / exclusive-use shared cells\n+    * Par: parallel map and search routines\n+    * Extensive work on libuv interface\n+    * Much vector code moved to libraries\n+    * Syntax extensions: #line, #col, #file, #mod,\n+      #stringify, #include, #include_str, #include_bin.\n+\n Version 0.2  (March 2012)\n -------------------------\n "}, {"sha": "435c4149a04e3d1e45b0c8802091db6b614476cb", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -440,7 +440,7 @@ fn test_recv_chan_wrong_task() {\n     let po = port();\n     let ch = chan(po);\n     send(ch, \"flower\");\n-    assert result::is_failure(task::try {||\n+    assert result::is_err(task::try {||\n         recv_chan(ch)\n     })\n }"}, {"sha": "8b55a04ca484b2524c1af3604019a36fed6c4092", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -11,6 +11,7 @@ import option::extensions;\n import option_iter::extensions;\n import ptr::extensions;\n import rand::extensions;\n+import result::extensions;\n \n export path, option, some, none, unreachable;\n export extensions;"}, {"sha": "677773933e91394c2b641998587436f0e371844f", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -232,5 +232,5 @@ fn test_weaken_task_fail() unsafe {\n             fail;\n         }\n     };\n-    assert result::is_failure(res);\n+    assert result::is_err(res);\n }"}, {"sha": "7981f48c8daa1d1db0730c96bc3dce9762f7d3d4", "filename": "src/libcore/result.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -43,16 +43,16 @@ pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n }\n \n #[doc = \"Returns true if the result is `ok`\"]\n-pure fn is_success<T, U>(res: result<T, U>) -> bool {\n+pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n     }\n }\n \n-#[doc = \"Returns true if the result is `error`\"]\n-pure fn is_failure<T, U>(res: result<T, U>) -> bool {\n-    !is_success(res)\n+#[doc = \"Returns true if the result is `err`\"]\n+pure fn is_err<T, U>(res: result<T, U>) -> bool {\n+    !is_ok(res)\n }\n \n #[doc = \"\n@@ -180,22 +180,10 @@ fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n     }\n }\n \n-impl extensions<T:copy, E:copy> for result<T,E> {\n-    fn get() -> T { get(self) }\n-\n-    fn get_err() -> E { get_err(self) }\n-\n-    fn is_success() -> bool { is_success(self) }\n-\n-    fn is_failure() -> bool { is_failure(self) }\n-\n-    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n-        chain(self, op)\n-    }\n+impl extensions<T, E> for result<T, E> {\n+    fn is_ok() -> bool { is_ok(self) }\n \n-    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n-        chain_err(self, op)\n-    }\n+    fn is_err() -> bool { is_err(self) }\n \n     fn iter(f: fn(T)) {\n         alt self {\n@@ -210,19 +198,37 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n           err(e) { f(e) }\n         }\n     }\n+}\n+\n+impl extensions<T:copy, E> for result<T, E> {\n+    fn get() -> T { get(self) }\n+\n+    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n+        alt self {\n+          ok(t) { ok(t) }\n+          err(e) { err(op(e)) }\n+        }\n+    }\n+}\n+\n+impl extensions<T, E:copy> for result<T, E> {\n+    fn get_err() -> E { get_err(self) }\n \n     fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n         alt self {\n           ok(t) { ok(op(t)) }\n           err(e) { err(e) }\n         }\n     }\n+}\n \n-    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n-        alt self {\n-          ok(t) { ok(t) }\n-          err(e) { err(op(e)) }\n-        }\n+impl extensions<T:copy, E:copy> for result<T,E> {\n+    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n+        chain(self, op)\n+    }\n+\n+    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n+        chain_err(self, op)\n     }\n }\n "}, {"sha": "1b2a50f9b4028908ff63958aee396eae7e4c72a5", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -385,7 +385,6 @@ fn shift<T>(&v: [T]) -> T {\n             let mut r <- *vv;\n \n             for uint::range(1u, ln) {|i|\n-                // FIXME (#2703): this isn't legal, per se...\n                 let r <- *ptr::offset(vv, i);\n                 push(v, r);\n             }\n@@ -397,6 +396,15 @@ fn shift<T>(&v: [T]) -> T {\n     }\n }\n \n+#[doc = \"Prepend an element to the vector\"]\n+fn unshift<T>(&v: [T], +x: T) {\n+    let mut vv = [x];\n+    v <-> vv;\n+    while len(vv) > 0 {\n+        push(v, shift(vv));\n+    }\n+}\n+\n #[doc = \"Remove the last element from a vector and return it\"]\n fn pop<T>(&v: [const T]) -> T unsafe {\n     let ln = len(v);\n@@ -2198,6 +2206,13 @@ mod tests {\n         assert addr == addr_imm;\n     }\n \n+    #[test]\n+    fn test_unshift() {\n+        let mut x = [1, 2, 3];\n+        unshift(x, 0);\n+        assert x == [0, 1, 2, 3];\n+    }\n+\n     #[test]\n     fn test_capacity() {\n         let mut v = [0u64];"}, {"sha": "1cb1d81e0e407d163f67ec8b22607f26c9d22cce", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -813,7 +813,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     log(debug, \"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n-    if result::is_failure(rs_result) {\n+    if result::is_err(rs_result) {\n         let err_data = result::get_err(rs_result);\n         result::err(err_data)\n     }\n@@ -1424,7 +1424,7 @@ mod test {\n \n                         let accept_result = accept(new_conn);\n                         log(debug, \"SERVER: after accept()\");\n-                        if result::is_failure(accept_result) {\n+                        if result::is_err(accept_result) {\n                             log(debug, \"SERVER: error accept connection\");\n                             let err_data = result::get_err(accept_result);\n                             comm::send(kill_ch, some(err_data));\n@@ -1465,7 +1465,7 @@ mod test {\n                 log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n             });\n             // err check on listen_result\n-            if result::is_failure(listen_result) {\n+            if result::is_err(listen_result) {\n                 let err_data = result::get_err(listen_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1486,7 +1486,7 @@ mod test {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let new_listener_result =\n                 new_listener(server_ip_addr, server_port, 128u, iotask);\n-            if result::is_failure(new_listener_result) {\n+            if result::is_err(new_listener_result) {\n                 let err_data = result::get_err(new_listener_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1498,7 +1498,7 @@ mod test {\n             // in a loop {}, but we're just going to take a single\n             // client.. get their req, write a resp and then exit\n             let new_conn_result = server_port.recv();\n-            if result::is_failure(new_conn_result) {\n+            if result::is_err(new_conn_result) {\n                 let err_data = result::get_err(new_conn_result);\n                 log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n                                 err_data.err_name, err_data.err_msg));\n@@ -1535,7 +1535,7 @@ mod test {\n \n         log(debug, \"CLIENT: starting..\");\n         let connect_result = connect(server_ip_addr, server_port, iotask);\n-        if result::is_failure(connect_result) {\n+        if result::is_err(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n             log(debug, #fmt(\"CLIENT: connect err name: %s msg: %s\",\n@@ -1547,7 +1547,7 @@ mod test {\n             let resp_bytes = str::bytes(resp);\n             tcp_write_single(sock, resp_bytes);\n             let read_result = sock.read(0u);\n-            if read_result.is_failure() {\n+            if read_result.is_err() {\n                 log(debug, \"CLIENT: failure to read\");\n                 \"\"\n             }\n@@ -1564,7 +1564,7 @@ mod test {\n     fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n-        if result::is_failure(write_result) {\n+        if result::is_err(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n             log(debug, #fmt(\"tcp_write_single err name: %s msg: %s\","}, {"sha": "fe9f59d553842cdc92b6edd991dea30cc216b0cf", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -452,10 +452,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         []\n       }\n \n-      ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n-      }\n-\n+      ast::ty_vstore(@{node: ast::ty_vec(mt),_}, ast::vstore_uniq) |\n       ast::ty_vec(mt) {\n         let ser_e =\n             cx.expr(\n@@ -472,6 +469,11 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             std::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n         }]\n       }\n+\n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n+      }\n+\n     }\n }\n \n@@ -673,14 +675,15 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ fail }\n       }\n \n-      ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n-      }\n-\n+      ast::ty_vstore(@{node: ast::ty_vec(mt),_}, ast::vstore_uniq) |\n       ast::ty_vec(mt) {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ std::serialization::read_to_vec($(d), $(l)) }\n       }\n+\n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n+      }\n     }\n }\n "}, {"sha": "28fee93fad752c51569e03ead23a2d52e8237756", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1979,7 +1979,7 @@ class parser {\n         let rp = self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         let class_path = self.ident_to_path_tys(class_name, rp, ty_params);\n-        let ifaces : [@iface_ref] = if self.eat_keyword(\"implements\")\n+        let ifaces : [@iface_ref] = if self.eat(token::COLON)\n             { self.parse_iface_ref_list() }\n         else { [] };\n         self.expect(token::LBRACE);"}, {"sha": "0a166dceb1d21f8ab5a9ca8984b7852b8a43d139", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -251,7 +251,6 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n     let keys = [\n         \"as\",\n         \"else\",\n-        \"implements\",\n         \"move\",\n         \"of\",\n         \"priv\", \"pub\","}, {"sha": "f632f3bcc210f7605187858c6eaf8a906d1ec923", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -527,9 +527,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n           word_nbsp(s, *item.ident);\n           print_region_param(s, rp);\n           print_type_params(s, tps);\n-          word_space(s, \"implements\");\n-          commasep(s, inconsistent, ifaces, {|s, p|\n-                      print_path(s, p.path, false)});\n+          if vec::len(ifaces) != 0u {\n+              word_space(s, \":\");\n+              commasep(s, inconsistent, ifaces, {|s, p|\n+                  print_path(s, p.path, false)});\n+          }\n           bopen(s);\n           hardbreak_if_not_bol(s);\n           maybe_print_comment(s, ctor.span.lo);"}, {"sha": "ad729494c457e6483f1d947f4bc211eb330d070a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -891,9 +891,7 @@ rust_unlock_cond_lock(rust_cond_lock *lock) {\n extern \"C\" void\n rust_wait_cond_lock(rust_cond_lock *lock) {\n     rust_task *task = rust_get_current_task();\n-#ifdef DEBUG_LOCKS\n-    assert(lock->lock.lock_held_by_current_thread());\n-#endif\n+    lock->lock.must_have_lock();\n     assert(NULL == lock->waiting);\n     lock->waiting = task;\n     task->block(lock, \"waiting for signal\");\n@@ -905,9 +903,7 @@ rust_wait_cond_lock(rust_cond_lock *lock) {\n \n extern \"C\" bool\n rust_signal_cond_lock(rust_cond_lock *lock) {\n-#ifdef DEBUG_LOCKS\n-    assert(lock->lock.lock_held_by_current_thread());\n-#endif\n+    lock->lock.must_have_lock();\n     if(NULL == lock->waiting) {\n         return false;\n     }"}, {"sha": "8d8009ceece55e03543778835e9cd7c02133f7d7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1797,7 +1797,6 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n             arg_exprs([src]), save_in(target));\n \n         ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n-                     // FIXME (#2704): should kind be owned?\n                      {bcx: bcx, val: target, kind: owned},\n                      dty);\n       }"}, {"sha": "ef85132ded10dad4f2938066c87103f04a3a4b7f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -684,7 +684,7 @@ fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, {ty: mk_nil(cx), mutbl: ast::m_imm})\n }\n \n-fn mk_vec(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_vec(tm)) }\n+fn mk_vec(cx: ctxt, tm: mt) -> t { mk_evec(cx, tm, vstore_uniq) }\n \n fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_evec(tm, t))\n@@ -1496,7 +1496,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) { kind_implicitly_sendable() | kind_const() }\n       // Implicit copyability of strs is configurable\n-      ty_str {\n+      ty_str | ty_estr(vstore_uniq) {\n         if cx.vecs_implicitly_copyable {\n             kind_implicitly_sendable() | kind_const()\n         } else { kind_sendable() | kind_const() }\n@@ -1526,7 +1526,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         remove_implicit(mutable_type_kind(cx, tm))\n       }\n       // Implicit copyability of vecs is configurable\n-      ty_vec(tm) {\n+      ty_vec(tm) | ty_evec(tm, vstore_uniq) {\n           if cx.vecs_implicitly_copyable {\n               mutable_type_kind(cx, tm)\n           } else { remove_implicit(mutable_type_kind(cx, tm)) }\n@@ -1544,17 +1544,13 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             kind_implicitly_copyable()\n         }\n       }\n-      ty_evec(tm, vstore_uniq) {\n-        remove_implicit(mutable_type_kind(cx, tm))\n-      }\n       ty_evec(tm, vstore_fixed(_)) {\n         mutable_type_kind(cx, tm)\n       }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n       ty_estr(vstore_slice(_)) { kind_implicitly_copyable() | kind_const() }\n-      ty_estr(vstore_uniq) { kind_sendable() | kind_const() }\n       ty_estr(vstore_fixed(_)) { kind_implicitly_sendable() | kind_const() }\n \n       // Records lower to the lowest of their members."}, {"sha": "ad1a613e7392e5ec539a500a43e976228dc3b95f", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -218,7 +218,7 @@ fn require_same_types(\n \n fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::get(a.ty).struct {\n-      ty::ty_vec(mt) {\n+      ty::ty_evec(mt, vstore_uniq) {\n         if mt.mutbl != ast::m_imm { ret false; }\n         alt ty::get(mt.ty).struct {\n           ty::ty_str { ret true; }\n@@ -271,12 +271,12 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_for_main_fn(ccx: @crate_ctxt, crate: @ast::crate) {\n+fn check_for_main_fn(ccx: @crate_ctxt) {\n     let tcx = ccx.tcx;\n     if !tcx.sess.building_library {\n         alt copy tcx.sess.main_fn {\n           some((id, sp)) { check_main_fn_ty(ccx, id, sp); }\n-          none { tcx.sess.span_err(crate.span, \"main function not found\"); }\n+          none { tcx.sess.err(\"main function not found\"); }\n         }\n     }\n }\n@@ -289,7 +289,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 tcx: tcx};\n     collect::collect_item_types(ccx, crate);\n     check::check_item_types(ccx, crate);\n-    check_for_main_fn(ccx, crate);\n+    check_for_main_fn(ccx);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "c40b86d05309ea7b677fb3256d6284723a423d28", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -170,6 +170,12 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             ret ty::mk_evec(tcx, mt, vst);\n           }\n \n+          // HACK: if we get a []/~, we assume that it was actually a\n+          // [] that got written down, and we throw away the /~...\n+          ty::ty_evec(mt, vstore_uniq) {\n+            ret ty::mk_evec(tcx, mt, vst);\n+          }\n+\n           ty::ty_str {\n             ret ty::mk_estr(tcx, vst);\n           }"}, {"sha": "e03967af79eeeedb9e3f370373435f58f07b8623", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -385,7 +385,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // Check that there's at least one field\n           let (fields,_) = split_class_items(members);\n           if fields.len() < 1u {\n-              ccx.tcx.sess.span_err(it.span, \"A class must have at least one \\\n+              ccx.tcx.sess.span_err(it.span, \"a class must have at least one \\\n                 field\");\n           }\n           // Check that the class is instantiable\n@@ -942,7 +942,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 // separate case below.\n                 tcx.sess.span_bug(\n                     expr.span,\n-                    #fmt[\"Comparison operator in expr_binop: %s\",\n+                    #fmt[\"comparison operator in expr_binop: %s\",\n                          ast_util::binop_to_str(op)]);\n               }\n               _ { lhs_t }\n@@ -1221,7 +1221,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) { /* fall through */ }\n               result::err(_) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"ret; in function returning non-nil\"); }\n+                                  \"`ret;` in function returning non-nil\"); }\n             }\n           }\n           some(e) { check_expr_with(fcx, e, ret_ty); }\n@@ -1303,16 +1303,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) {}\n               result::err(err) {\n                 tcx.sess.span_fatal(\n-                    expr.span, #fmt(\"a loop function's last argument \\\n+                    expr.span, #fmt(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n                                     fcx.infcx.ty_to_str(fty.output)));\n               }\n             }\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n           }\n           _ {\n-            tcx.sess.span_fatal(expr.span, \"a loop function's last argument \\\n-                                            should be of function type\");\n+            tcx.sess.span_fatal(expr.span, \"a `loop` function's last \\\n+                                            argument should be of function \\\n+                                            type\");\n           }\n         };\n         alt check b.node {\n@@ -1338,7 +1339,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             (ty::mk_fn(tcx, fty), fty.proto)\n           }\n           _ {\n-            tcx.sess.span_fatal(expr.span, \"a do function's last argument \\\n+            tcx.sess.span_fatal(expr.span, \"a `do` function's last argument \\\n                                             should be of function type\");\n           }\n         };\n@@ -1551,8 +1552,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n               none {\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = #fmt[\"attempted access of field %s on type %s, but \\\n-                          no public field or method with that name was found\",\n+                let msg = #fmt[\"attempted access of field `%s` on type `%s`, \\\n+                                but no public field or method with that name \\\n+                                was found\",\n                                *field, fcx.infcx.ty_to_str(t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n@@ -1785,8 +1787,8 @@ fn check_instantiable(tcx: ty::ctxt,\n     let rty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, rty) {\n         tcx.sess.span_err(sp, #fmt[\"this type cannot be instantiated \\\n-                                    without an instance of itself. \\\n-                                    Consider using option<%s>.\",\n+                                    without an instance of itself; \\\n+                                    consider using `option<%s>`\",\n                                    ty_to_str(tcx, rty)]);\n     }\n }\n@@ -1825,7 +1827,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         }\n         if vec::contains(disr_vals, disr_val) {\n             ccx.tcx.sess.span_err(v.span,\n-                                  \"discriminator value already exists.\");\n+                                  \"discriminator value already exists\");\n         }\n         disr_vals += [disr_val];\n         let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -1852,7 +1854,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n           _ { false }\n         }\n     }) {\n-        ccx.tcx.sess.span_err(sp, \"illegal recursive enum type. \\\n+        ccx.tcx.sess.span_err(sp, \"illegal recursive enum type; \\\n                                    wrap the inner value in a box to \\\n                                    make it representable\");\n     }\n@@ -2199,13 +2201,13 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     if !r_used {\n         ccx.tcx.sess.span_err(\n             span, \"lifetime `self` unused inside \\\n-                   reference-parameterized type.\");\n+                   reference-parameterized type\");\n     }\n \n     for tps_used.eachi { |i, b|\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, #fmt[\"Type parameter %s is unused.\", *tps[i].ident]);\n+                span, #fmt[\"type parameter `%s` is unused\", *tps[i].ident]);\n         }\n     }\n }\n@@ -2272,13 +2274,13 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n-                                         of type parameters. found %u, \\\n+                                         of type parameters: found %u, \\\n                                          expected %u\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n             tcx, none, it.span, i_ty.ty, fty,\n-            {|| #fmt[\"intrinsic has wrong type. \\\n-                      expected %s\",\n+            {|| #fmt[\"intrinsic has wrong type: \\\n+                      expected `%s`\",\n                      ty_to_str(ccx.tcx, fty)]});\n     }\n }"}, {"sha": "63b8426ac93c19e81fd0be7f30b7f307d746df8b", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -3,7 +3,7 @@ import to_str::to_str;\n \n mod kitty {\n \n-class cat implements to_str {\n+class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "c4e519026289b8bf253ffbe32c0e1aa661b4da4a", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -77,7 +77,6 @@ mod map_reduce {\n \n     type putter<K: send, V: send> = fn(K, V);\n \n-    // FIXME: the first K1 parameter should probably be a - (#2599)\n     type mapper<K1: send, K2: send, V: send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: send> = fn() -> option<V>;"}, {"sha": "e79c021d9f3ef79f39ac163871eda6390f652ec6", "filename": "src/test/compile-fail/class-cast-to-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,9 +1,9 @@\n-// error-pattern: attempted access of field eat on type noisy\n+// error-pattern: attempted access of field `eat` on type `noisy`\n iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "4e95b986a9ab8421cd8499bbf6c67832d2998233", "filename": "src/test/compile-fail/class-implements-bad-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,5 +1,5 @@\n // error-pattern:unresolved typename: nonexistent\n-class cat implements nonexistent {\n+class cat : nonexistent {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "1768b8c4bf04729c46a20bc3adbb7a595b09b5d4", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,4 +1,4 @@\n-class cat implements int { //! ERROR can only implement interface types\n+class cat : int { //! ERROR can only implement interface types\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "788baa73c345cc78e6ef3606d547b94493304776", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -3,7 +3,7 @@ iface animal {\n   fn eat();\n }\n \n-class cat implements animal {\n+class cat : animal {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }"}, {"sha": "e0d3680a381b5eff0b3f0122e7f26ad56749b3d7", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:expected `str` but found `[int]`\n+// error-pattern:expected `str` but found `[int]/~`\n fn main() { fail [0i]; }"}, {"sha": "17510164a5f9e92e85bab28f65c0e0e9efb82264", "filename": "src/test/compile-fail/issue-1763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,6 +1,6 @@\n // Issue #1763 - infer types correctly\n \n-type actor<T> = { //! ERROR Type parameter T is unused.\n+type actor<T> = { //! ERROR type parameter `T` is unused\n     unused: bool\n };\n "}, {"sha": "69970f8dc950e24c0148cac26be8961243c42261", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,4 +1,4 @@\n-class c { //! ERROR A class must have at least one field\n+class c { //! ERROR a class must have at least one field\n     new() { }\n }\n "}, {"sha": "f54a0ffc068d52bfc922f71f99ff93f214ec77fa", "filename": "src/test/compile-fail/private-method-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method-cross-crate.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted access of field nap on type\n+// error-pattern:attempted access of field `nap` on type\n // xfail-fast\n // aux-build:cci_class_5.rs\n use cci_class_5;"}, {"sha": "4153f413dc034bddcb5baf4ae0d02ecbf742ab3d", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: ret; in function returning non-nil\n+// error-pattern: `ret;` in function returning non-nil\n \n fn f() { ret; }\n "}, {"sha": "cc6faa07557b521e169b80f070a6fa2cd4f6cbb6", "filename": "src/test/compile-fail/unsafe-fn-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -15,7 +15,7 @@ fn f(p: *rec) -> int {\n     // are prohibited by various checks, such as that the enum is\n     // instantiable and so forth).\n \n-    ret p.f; //! ERROR attempted access of field f on type *rec\n+    ret p.f; //! ERROR attempted access of field `f` on type `*rec`\n }\n \n fn main() {"}, {"sha": "6642112d9986cc49df6d4284bad07b3b990a046e", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,8 +1,8 @@\n // xfail-test\n \n-// FIXME: + should allow immutable or mutable vectors on the right\n-// hand side in all cases. We are getting compiler errors about this\n-// now, so I'm xfailing the test for now. -eholk\n+// FIXME (Issue #2711): + should allow immutable or mutable vectors on\n+// the right hand side in all cases. We are getting compiler errors\n+// about this now, so I'm xfailing the test for now. -eholk\n \n fn add(i: [int], m: [mut int], c: [const int]) {\n "}, {"sha": "7eb7e118b39f0465ccc181d1bbdbeab9ec6c2195", "filename": "src/test/compile-fail/vec-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Fcompile-fail%2Fvec-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-field.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted access of field some_field_name on type [int]\n+// error-pattern:attempted access of field `some_field_name` on type `[int]/~`\n // issue #367\n \n fn f() {"}, {"sha": "13c0e60c427f488dbc9c8da79b91785bd679dc5e", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,7 +1,7 @@\n import to_str::*;\n import to_str::to_str;\n \n-class cat implements to_str {\n+class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "e2dc7b732a8ef027751bfca7f34b94cd9831734b", "filename": "src/test/run-pass/class-cast-to-iface-multiple-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak() -> int;\n }\n \n-class dog implements noisy {\n+class dog : noisy {\n   priv {\n     let barks : @mut uint;\n     fn bark() -> int {\n@@ -26,7 +26,7 @@ class dog implements noisy {\n   fn speak() -> int { self.bark() }\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let meows : @mut uint;\n     fn meow() -> uint {"}, {"sha": "10222acc45aa71c87cf625de59041e6f8fb7d67b", "filename": "src/test/run-pass/class-cast-to-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "4da75037421c0502ea2ee68e0ce6de0cf533a431", "filename": "src/test/run-pass/class-iface-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-iface-bounded-param.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::map::{map, hashmap, int_hash};\n \n class keys<K: copy, V: copy, M: copy map<K,V>>\n-    implements iter::base_iter<K> {\n+    : iter::base_iter<K> {\n \n     let map: M;\n "}, {"sha": "dc76b57c2d26484e835b222059d40e321e38a67a", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std::map::*;\n \n-class cat implements map<int, bool> {\n+class cat : map<int, bool> {\n   priv {\n     // Yes, you can have negative meows\n     let mut meows : int;"}, {"sha": "30c4be25c604351d2f8cb5ff0fe7c4f796940ae0", "filename": "src/test/run-pass/class-impl-very-parameterized-iface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -7,7 +7,7 @@ enum cat_type { tuxedo, tabby, tortoiseshell }\n // for any int value that's less than the meows field\n \n // ok: T should be in scope when resolving the iface ref for map\n-class cat<T: copy> implements map<int, T> {\n+class cat<T: copy> : map<int, T> {\n   priv {\n     // Yes, you can have negative meows\n     let mut meows : int;"}, {"sha": "5add42fb263c89614d7229544bce0447845a423d", "filename": "src/test/run-pass/class-implement-iface-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -3,7 +3,7 @@\n use cci_class_iface;\n import cci_class_iface::animals::*;\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "f772ef957d7eee842a4eced98beda64c08cf68b1", "filename": "src/test/run-pass/class-implement-ifaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@ iface noisy {\n   fn speak();\n }\n \n-class cat implements noisy {\n+class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {"}, {"sha": "fe3f160c1f8184f52ede87251ef9b36fa9ea66d4", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -24,7 +24,7 @@ fn vec_includes<T>(xs: [T], x: T) -> bool {\n }\n \n // vtables other than the 1st one don't seem to work\n-class cat implements noisy, scratchy, bitey {\n+class cat : noisy, scratchy, bitey {\n   priv {\n     let meows : @mut uint;\n     let scratched : dvec<furniture>;"}, {"sha": "3f5e92cdb75a20691f02f68852f4f67744e1422f", "filename": "src/test/run-pass/cleanup-copy-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -2,7 +2,7 @@\n fn adder(+x: @int, +y: @int) -> int { ret *x + *y; }\n fn failer() -> @int { fail; }\n fn main() {\n-    assert(result::is_failure(task::try {||\n+    assert(result::is_err(task::try {||\n         adder(@2, failer()); ()\n     }));\n }"}, {"sha": "458a0b12698b80597c24548e27a81e032eb1400d", "filename": "src/test/run-pass/issue-506.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -1,9 +1,3 @@\n-// xfail-test\n-// FIXME: This test is no longer testing what it was intended to. It should\n-// be testing spawning of a native function, but is actually testing\n-// spawning some other function, then executing a native function.\n-// #2602\n-\n /*\n   A reduced test case for Issue #506, provided by Rob Arnold.\n */\n@@ -13,9 +7,7 @@ import task;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn task_yield();\n+    fn rust_task_allow_kill();\n }\n \n-fn yield_wrap(&&_arg: ()) { rustrt::task_yield(); }\n-\n-fn main() { task::spawn((), yield_wrap); }\n+fn main() { task::spawn(rustrt::rust_task_allow_kill); }"}, {"sha": "d250b311cccd83858c5c3a78afffaca092a7b01b", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d20a40f86d1f8d8dd8d28c882378218a040c9/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=6e6d20a40f86d1f8d8dd8d28c882378218a040c9", "patch": "@@ -52,8 +52,6 @@ fn test_tag() {\n     send(ch, tag1);\n     send(ch, tag2(10));\n     send(ch, tag3(10, 11u8, 'A'));\n-    // FIXME: Do port semantics really guarantee these happen in order?\n-    // (#2605)\n     let mut t1: t;\n     t1 = recv(po);\n     assert (t1 == tag1);"}]}