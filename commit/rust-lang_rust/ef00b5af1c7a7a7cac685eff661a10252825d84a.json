{"sha": "ef00b5af1c7a7a7cac685eff661a10252825d84a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDBiNWFmMWM3YTdhN2NhYzY4NWVmZjY2MWExMDI1MjgyNWQ4NGE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T14:31:26Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-23T14:31:26Z"}, "message": "Merge #1312\n\n1312: Introduce TokenBuffer r=matklad a=edwin0cheng\n\nAs discussed in Zulip, this PR Introduce `TokenBuffer` , a safe version of  `syn` crate `TokenBuffer` which support cursor based traversal of `tt::TokenTree`. This is the basis of incoming refactoring of `TokenSource` iterator based API.\r\n\r\nThis PR do the following things:\r\n\r\n* Add TokenBuffer in `ra_tt` crate.\r\n* Try to use this new API to refactor the `SubtreeSource` to prove it usage.\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "b48cf769d66b2c9366c5488cfa254520730a98a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b48cf769d66b2c9366c5488cfa254520730a98a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef00b5af1c7a7a7cac685eff661a10252825d84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef00b5af1c7a7a7cac685eff661a10252825d84a", "html_url": "https://github.com/rust-lang/rust/commit/ef00b5af1c7a7a7cac685eff661a10252825d84a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef00b5af1c7a7a7cac685eff661a10252825d84a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "eef24bddc96ddcdbcad5fddb9c0cf0e2ccad7681", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef24bddc96ddcdbcad5fddb9c0cf0e2ccad7681", "html_url": "https://github.com/rust-lang/rust/commit/eef24bddc96ddcdbcad5fddb9c0cf0e2ccad7681"}, {"sha": "63b67134fdbfedfeab655ac9ff03730575fdf475", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b67134fdbfedfeab655ac9ff03730575fdf475", "html_url": "https://github.com/rust-lang/rust/commit/63b67134fdbfedfeab655ac9ff03730575fdf475"}], "stats": {"total": 460, "additions": 259, "deletions": 201}, "files": [{"sha": "709b87a38494acff19ab69cf584b2194ce5cc5d5", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=ef00b5af1c7a7a7cac685eff661a10252825d84a", "patch": "@@ -2,6 +2,7 @@ use crate::subtree_source::SubtreeTokenSource;\n \n use ra_parser::{TokenSource, TreeSink};\n use ra_syntax::{SyntaxKind};\n+use tt::buffer::TokenBuffer;\n \n struct OffsetTokenSink {\n     token_pos: usize,\n@@ -69,7 +70,8 @@ impl<'a> Parser<'a> {\n     where\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),\n     {\n-        let mut src = SubtreeTokenSource::new(&self.subtree.token_trees[*self.cur_pos..]);\n+        let buffer = TokenBuffer::new(&self.subtree.token_trees[*self.cur_pos..]);\n+        let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { token_pos: 0, error: false };\n \n         f(&src, &mut sink);\n@@ -85,7 +87,7 @@ impl<'a> Parser<'a> {\n         let res = src.bump_n(parsed_token);\n         *self.cur_pos += res.len();\n \n-        let res: Vec<_> = res.into_iter().cloned().collect();\n+        let res: Vec<_> = res.into_iter().collect();\n \n         match res.len() {\n             0 => None,"}, {"sha": "972af4a7c59b0b142880768aa51160d2de6c20aa", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 70, "deletions": 192, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=ef00b5af1c7a7a7cac685eff661a10252825d84a", "patch": "@@ -1,50 +1,10 @@\n use ra_parser::{TokenSource};\n use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*, T};\n-use std::cell::{RefCell};\n+use std::cell::{RefCell, Cell};\n+use tt::buffer::{TokenBuffer, Cursor};\n \n-// A Sequece of Token,\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub(super) enum TokenSeq<'a> {\n-    Subtree(&'a tt::Subtree),\n-    Seq(&'a [tt::TokenTree]),\n-}\n-\n-impl<'a> From<&'a tt::Subtree> for TokenSeq<'a> {\n-    fn from(s: &'a tt::Subtree) -> TokenSeq<'a> {\n-        TokenSeq::Subtree(s)\n-    }\n-}\n-\n-impl<'a> From<&'a [tt::TokenTree]> for TokenSeq<'a> {\n-    fn from(s: &'a [tt::TokenTree]) -> TokenSeq<'a> {\n-        TokenSeq::Seq(s)\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum DelimToken<'a> {\n-    Delim(&'a tt::Delimiter, bool),\n-    Token(&'a tt::TokenTree),\n-    End,\n-}\n-\n-impl<'a> TokenSeq<'a> {\n-    fn get(&self, pos: usize) -> DelimToken<'a> {\n-        match self {\n-            TokenSeq::Subtree(subtree) => {\n-                let len = subtree.token_trees.len() + 2;\n-                match pos {\n-                    p if p >= len => DelimToken::End,\n-                    p if p == len - 1 => DelimToken::Delim(&subtree.delimiter, true),\n-                    0 => DelimToken::Delim(&subtree.delimiter, false),\n-                    p => DelimToken::Token(&subtree.token_trees[p - 1]),\n-                }\n-            }\n-            TokenSeq::Seq(tokens) => {\n-                tokens.get(pos).map(DelimToken::Token).unwrap_or(DelimToken::End)\n-            }\n-        }\n-    }\n+pub(crate) trait Querier {\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -54,183 +14,101 @@ struct TtToken {\n     pub text: SmolStr,\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq)]\n-enum WalkCursor {\n-    Token(usize, TtToken),\n-    Eof,\n-}\n-\n-#[derive(Debug)]\n-struct SubTreeWalker<'a> {\n-    pos: usize,\n-    stack: Vec<(TokenSeq<'a>, usize)>,\n-    cursor: WalkCursor,\n-    ts: TokenSeq<'a>,\n-}\n-\n-impl<'a> SubTreeWalker<'a> {\n-    fn new(ts: TokenSeq<'a>) -> SubTreeWalker {\n-        let mut res = SubTreeWalker { pos: 0, stack: vec![], cursor: WalkCursor::Eof, ts };\n-\n-        res.reset();\n-        res\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.cursor == WalkCursor::Eof\n-    }\n-\n-    fn reset(&mut self) {\n-        self.pos = 0;\n-        self.stack = vec![];\n-\n-        self.cursor = match self.ts.get(0) {\n-            DelimToken::Token(token) => match token {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let ts = TokenSeq::from(subtree);\n-                    self.stack.push((ts, 0));\n-                    WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n-                }\n-                tt::TokenTree::Leaf(leaf) => WalkCursor::Token(0, convert_leaf(leaf)),\n-            },\n-            DelimToken::Delim(delim, is_end) => {\n-                assert!(!is_end);\n-                WalkCursor::Token(0, convert_delim(*delim, false))\n-            }\n-            DelimToken::End => WalkCursor::Eof,\n-        }\n-    }\n-\n-    fn current(&self) -> Option<&TtToken> {\n-        match &self.cursor {\n-            WalkCursor::Token(_, t) => Some(t),\n-            WalkCursor::Eof => None,\n-        }\n-    }\n-\n-    fn top(&self) -> &TokenSeq {\n-        self.stack.last().map(|(t, _)| t).unwrap_or(&self.ts)\n-    }\n-\n-    /// Move cursor forward by 1 step        \n-    fn forward(&mut self) {\n-        if self.is_eof() {\n-            return;\n-        }\n-        self.pos += 1;\n-\n-        if let WalkCursor::Token(u, _) = self.cursor {\n-            self.cursor = self.walk_token(u)\n-        }\n-    }\n-\n-    /// Traversal child token\n-    fn walk_token(&mut self, pos: usize) -> WalkCursor {\n-        let top = self.stack.last().map(|(t, _)| t).unwrap_or(&self.ts);\n-        let pos = pos + 1;\n-\n-        match top.get(pos) {\n-            DelimToken::Token(token) => match token {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let ts = TokenSeq::from(subtree);\n-                    self.stack.push((ts, pos));\n-                    WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n-                }\n-                tt::TokenTree::Leaf(leaf) => WalkCursor::Token(pos, convert_leaf(leaf)),\n-            },\n-            DelimToken::Delim(delim, is_end) => {\n-                WalkCursor::Token(pos, convert_delim(*delim, is_end))\n-            }\n-            DelimToken::End => {\n-                // it is the top level\n-                if let Some((_, last_idx)) = self.stack.pop() {\n-                    self.walk_token(last_idx)\n-                } else {\n-                    WalkCursor::Eof\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) trait Querier {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n-}\n-\n // A wrapper class for ref cell\n #[derive(Debug)]\n-pub(crate) struct WalkerOwner<'a> {\n-    walker: RefCell<SubTreeWalker<'a>>,\n+pub(crate) struct SubtreeWalk<'a> {\n+    start: Cursor<'a>,\n+    cursor: Cell<Cursor<'a>>,\n     cached: RefCell<Vec<Option<TtToken>>>,\n }\n \n-impl<'a> WalkerOwner<'a> {\n-    fn new<I: Into<TokenSeq<'a>>>(ts: I) -> Self {\n-        WalkerOwner {\n-            walker: RefCell::new(SubTreeWalker::new(ts.into())),\n+impl<'a> SubtreeWalk<'a> {\n+    fn new(cursor: Cursor<'a>) -> Self {\n+        SubtreeWalk {\n+            start: cursor,\n+            cursor: Cell::new(cursor),\n             cached: RefCell::new(Vec::with_capacity(10)),\n         }\n     }\n \n-    fn get<'b>(&self, pos: usize) -> Option<TtToken> {\n+    fn get(&self, pos: usize) -> Option<TtToken> {\n         let mut cached = self.cached.borrow_mut();\n         if pos < cached.len() {\n             return cached[pos].clone();\n         }\n \n         while pos >= cached.len() {\n-            self.set_pos(cached.len());\n-            let walker = self.walker.borrow();\n-            cached.push(walker.current().cloned());\n+            let cursor = self.cursor.get();\n+            if cursor.eof() {\n+                cached.push(None);\n+                continue;\n+            }\n+\n+            match cursor.token_tree() {\n+                Some(tt::TokenTree::Leaf(leaf)) => {\n+                    cached.push(Some(convert_leaf(&leaf)));\n+                    self.cursor.set(cursor.bump());\n+                }\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    self.cursor.set(cursor.subtree().unwrap());\n+                    cached.push(Some(convert_delim(subtree.delimiter, false)));\n+                }\n+                None => {\n+                    if let Some(subtree) = cursor.end() {\n+                        cached.push(Some(convert_delim(subtree.delimiter, true)));\n+                        self.cursor.set(cursor.bump());\n+                    }\n+                }\n+            }\n         }\n \n         return cached[pos].clone();\n     }\n \n-    fn set_pos(&self, pos: usize) {\n-        let mut walker = self.walker.borrow_mut();\n-        assert!(walker.pos <= pos);\n+    fn collect_token_trees(&mut self, n: usize) -> Vec<tt::TokenTree> {\n+        let mut res = vec![];\n \n-        while pos > walker.pos && !walker.is_eof() {\n-            walker.forward();\n-        }\n-    }\n+        let mut pos = 0;\n+        let mut cursor = self.start;\n+        let mut level = 0;\n \n-    fn collect_token_trees(&mut self, n: usize) -> Vec<&tt::TokenTree> {\n-        let mut res = vec![];\n-        let mut walker = self.walker.borrow_mut();\n-        walker.reset();\n+        while pos < n {\n+            if cursor.eof() {\n+                break;\n+            }\n \n-        while walker.pos < n {\n-            if let WalkCursor::Token(u, _) = &walker.cursor {\n-                // We only collect the topmost child\n-                if walker.stack.len() == 0 {\n-                    if let DelimToken::Token(token) = walker.ts.get(*u) {\n-                        res.push(token);\n+            match cursor.token_tree() {\n+                Some(tt::TokenTree::Leaf(leaf)) => {\n+                    if level == 0 {\n+                        res.push(leaf.into());\n                     }\n+                    cursor = cursor.bump();\n+                    pos += 1;\n                 }\n-                // Check whether the second level is a subtree\n-                // if so, collect its parent which is topmost child\n-                else if walker.stack.len() == 1 {\n-                    if let DelimToken::Delim(_, is_end) = walker.top().get(*u) {\n-                        if !is_end {\n-                            let (_, last_idx) = &walker.stack[0];\n-                            if let DelimToken::Token(token) = walker.ts.get(*last_idx) {\n-                                res.push(token);\n-                            }\n-                        }\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    if level == 0 {\n+                        res.push(subtree.into());\n                     }\n+                    pos += 1;\n+                    level += 1;\n+                    cursor = cursor.subtree().unwrap();\n                 }\n-            }\n \n-            walker.forward();\n+                None => {\n+                    if let Some(_) = cursor.end() {\n+                        level -= 1;\n+                        pos += 1;\n+                        cursor = cursor.bump();\n+                    }\n+                }\n+            }\n         }\n \n         res\n     }\n }\n \n-impl<'a> Querier for WalkerOwner<'a> {\n+impl<'a> Querier for SubtreeWalk<'a> {\n     fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool) {\n         self.get(uidx)\n             .map(|tkn| (tkn.kind, tkn.text, tkn.is_joint_to_next))\n@@ -239,22 +117,22 @@ impl<'a> Querier for WalkerOwner<'a> {\n }\n \n pub(crate) struct SubtreeTokenSource<'a> {\n-    walker: WalkerOwner<'a>,\n+    walker: SubtreeWalk<'a>,\n }\n \n impl<'a> SubtreeTokenSource<'a> {\n-    pub fn new<I: Into<TokenSeq<'a>>>(ts: I) -> SubtreeTokenSource<'a> {\n-        SubtreeTokenSource { walker: WalkerOwner::new(ts) }\n+    pub fn new(buffer: &'a TokenBuffer) -> SubtreeTokenSource<'a> {\n+        SubtreeTokenSource { walker: SubtreeWalk::new(buffer.begin()) }\n     }\n \n-    pub fn querier<'b>(&'a self) -> &'b WalkerOwner<'a>\n+    pub fn querier<'b>(&'a self) -> &'b SubtreeWalk<'a>\n     where\n         'a: 'b,\n     {\n         &self.walker\n     }\n \n-    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<&tt::TokenTree> {\n+    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<tt::TokenTree> {\n         let res = self.walker.collect_token_trees(parsed_tokens);\n         res\n     }"}, {"sha": "0a75305b478ec871b684ba8a0d414a4ccbfcdfc9", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=ef00b5af1c7a7a7cac685eff661a10252825d84a", "patch": "@@ -47,7 +47,8 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n \n /// Parses the token tree (result of macro expansion) to an expression\n pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_expr(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -62,7 +63,8 @@ pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, Expand\n \n /// Parses the token tree (result of macro expansion) to a Pattern\n pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_pat(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -75,7 +77,8 @@ pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandEr\n \n /// Parses the token tree (result of macro expansion) to a Type\n pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_ty(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -89,7 +92,8 @@ pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, Expan\n pub fn token_tree_to_macro_stmts(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroStmts>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_macro_stmts(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -103,7 +107,8 @@ pub fn token_tree_to_macro_stmts(\n pub fn token_tree_to_macro_items(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroItems>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_macro_items(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -115,7 +120,8 @@ pub fn token_tree_to_macro_items(\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> TreeArc<ast::SourceFile> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse(&token_source, &mut tree_sink);\n     let syntax = tree_sink.inner.finish();\n@@ -381,7 +387,8 @@ mod tests {\n             \"#,\n         );\n         let expansion = expand(&rules, \"literals!(foo)\");\n-        let tt_src = SubtreeTokenSource::new(&expansion);\n+        let buffer = tt::buffer::TokenBuffer::new(&[expansion.clone().into()]);\n+        let tt_src = SubtreeTokenSource::new(&buffer);\n \n         let query = tt_src.querier();\n "}, {"sha": "56b844b8b76910f4ad6405fe3bca39cdff3e47fa", "filename": "crates/ra_tt/src/buffer.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Fbuffer.rs?ref=ef00b5af1c7a7a7cac685eff661a10252825d84a", "patch": "@@ -0,0 +1,169 @@\n+use crate::{TokenTree, Subtree, Leaf};\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+struct EntryId(usize);\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+struct EntryPtr(EntryId, usize);\n+\n+/// Internal type which is used instead of `TokenTree` to represent a token tree\n+/// within a `TokenBuffer`.\n+#[derive(Debug)]\n+enum Entry {\n+    // Mimicking types from proc-macro.\n+    Subtree(Subtree, EntryId),\n+    Leaf(Leaf),\n+    // End entries contain a pointer to the entry from the containing\n+    // token tree, or None if this is the outermost level.\n+    End(Option<EntryPtr>),\n+}\n+\n+/// A token tree buffer\n+/// The safe version of `syn` [`TokenBuffer`](https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L41)\n+#[derive(Debug)]\n+pub struct TokenBuffer {\n+    buffers: Vec<Box<[Entry]>>,\n+}\n+\n+impl TokenBuffer {\n+    pub fn new(tokens: &[TokenTree]) -> TokenBuffer {\n+        let mut buffers = vec![];\n+\n+        let idx = TokenBuffer::new_inner(tokens, &mut buffers, None);\n+        assert_eq!(idx, 0);\n+\n+        TokenBuffer { buffers }\n+    }\n+\n+    fn new_inner(\n+        tokens: &[TokenTree],\n+        buffers: &mut Vec<Box<[Entry]>>,\n+        next: Option<EntryPtr>,\n+    ) -> usize {\n+        let mut entries = vec![];\n+        let mut children = vec![];\n+\n+        for (idx, tt) in tokens.iter().cloned().enumerate() {\n+            match tt {\n+                TokenTree::Leaf(leaf) => {\n+                    entries.push(Entry::Leaf(leaf));\n+                }\n+                TokenTree::Subtree(subtree) => {\n+                    entries.push(Entry::End(None));\n+                    children.push((idx, subtree));\n+                }\n+            }\n+        }\n+\n+        entries.push(Entry::End(next));\n+        let res = buffers.len();\n+        buffers.push(entries.into_boxed_slice());\n+\n+        for (child_idx, subtree) in children {\n+            let idx = TokenBuffer::new_inner(\n+                &subtree.token_trees,\n+                buffers,\n+                Some(EntryPtr(EntryId(res), child_idx + 1)),\n+            );\n+            buffers[res].as_mut()[child_idx] = Entry::Subtree(subtree, EntryId(idx));\n+        }\n+\n+        res\n+    }\n+\n+    /// Creates a cursor referencing the first token in the buffer and able to\n+    /// traverse until the end of the buffer.\n+    pub fn begin(&self) -> Cursor {\n+        Cursor::create(self, EntryPtr(EntryId(0), 0))\n+    }\n+\n+    fn entry(&self, ptr: &EntryPtr) -> Option<&Entry> {\n+        let id = ptr.0;\n+        self.buffers[id.0].get(ptr.1)\n+    }\n+}\n+\n+/// A safe version of `Cursor` from `syn` crate https://github.com/dtolnay/syn/blob/6533607f91686545cb034d2838beea338d9d0742/src/buffer.rs#L125\n+#[derive(Copy, Clone, Debug)]\n+pub struct Cursor<'a> {\n+    buffer: &'a TokenBuffer,\n+    ptr: EntryPtr,\n+}\n+\n+impl<'a> PartialEq for Cursor<'a> {\n+    fn eq(&self, other: &Cursor) -> bool {\n+        self.ptr == other.ptr && std::ptr::eq(self.buffer, other.buffer)\n+    }\n+}\n+\n+impl<'a> Eq for Cursor<'a> {}\n+\n+impl<'a> Cursor<'a> {\n+    /// Check whether it is eof\n+    pub fn eof(self) -> bool {\n+        match self.buffer.entry(&self.ptr) {\n+            None | Some(Entry::End(None)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// If the cursor is pointing at the end of a subtree, returns\n+    /// the parent subtree\n+    pub fn end(self) -> Option<(&'a Subtree)> {\n+        match self.entry() {\n+            Some(Entry::End(Some(ptr))) => {\n+                let idx = ptr.1;\n+                if let Some(Entry::Subtree(subtree, _)) =\n+                    self.buffer.entry(&EntryPtr(ptr.0, idx - 1))\n+                {\n+                    return Some(subtree);\n+                }\n+\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn entry(self) -> Option<(&'a Entry)> {\n+        self.buffer.entry(&self.ptr)\n+    }\n+\n+    /// If the cursor is pointing at a `Subtree`, returns\n+    /// a cursor into that subtree\n+    pub fn subtree(self) -> Option<Cursor<'a>> {\n+        match self.entry() {\n+            Some(Entry::Subtree(_, entry_id)) => {\n+                Some(Cursor::create(self.buffer, EntryPtr(*entry_id, 0)))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// If the cursor is pointing at a `TokenTree`, returns it\n+    pub fn token_tree(self) -> Option<(TokenTree)> {\n+        match self.entry() {\n+            Some(Entry::Leaf(leaf)) => Some(leaf.clone().into()),\n+            Some(Entry::Subtree(subtree, _)) => Some(subtree.clone().into()),\n+            Some(Entry::End(_)) => None,\n+            None => None,\n+        }\n+    }\n+\n+    fn create(buffer: &'a TokenBuffer, ptr: EntryPtr) -> Cursor<'a> {\n+        Cursor { buffer, ptr }\n+    }\n+\n+    /// Bump the cursor\n+    pub fn bump(self) -> Cursor<'a> {\n+        if let Some(Entry::End(exit)) = self.buffer.entry(&self.ptr) {\n+            if let Some(exit) = exit {\n+                Cursor::create(self.buffer, *exit)\n+            } else {\n+                self\n+            }\n+        } else {\n+            Cursor::create(self.buffer, EntryPtr(self.ptr.0, self.ptr.1 + 1))\n+        }\n+    }\n+}"}, {"sha": "2a48c66c48ef448a248343e4bc88a73a33d9b3fc", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef00b5af1c7a7a7cac685eff661a10252825d84a/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=ef00b5af1c7a7a7cac685eff661a10252825d84a", "patch": "@@ -165,3 +165,5 @@ impl Subtree {\n         self.token_trees.len() + children_count\n     }\n }\n+\n+pub mod buffer;"}]}