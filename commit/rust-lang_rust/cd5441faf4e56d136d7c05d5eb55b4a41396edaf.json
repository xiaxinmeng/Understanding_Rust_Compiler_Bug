{"sha": "cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNTQ0MWZhZjRlNTZkMTM2ZDdjMDVkNWViNTViNGE0MTM5NmVkYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T10:10:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T10:10:15Z"}, "message": "Auto merge of #69088 - JohnTitor:rollup-x7bk7h7, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #67695 (Added dyn and true keyword docs)\n - #68487 ([experiment] Support linking from a .rlink file)\n - #68554 (Split lang_items to crates `rustc_hir` and `rustc_passes`.)\n - #68937 (Test failure of unchecked arithmetic intrinsics in const eval)\n - #68947 (Python script PEP8 style guide space formatting and minor Python source cleanup)\n - #68999 (remove dependency on itertools)\n - #69026 (Remove common usage pattern from `AllocRef`)\n - #69027 (Add missing `_zeroed` varants to `AllocRef`)\n - #69058 (Preparation for allocator aware `Box`)\n - #69070 (Add self to .mailmap)\n - #69077 (Fix outdated doc comment.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "27e27611e789f2cf88d5efe83c1fa543dee6590f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27e27611e789f2cf88d5efe83c1fa543dee6590f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "html_url": "https://github.com/rust-lang/rust/commit/cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cba853b4f6080bf7831169fe5632ec9b6833242", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cba853b4f6080bf7831169fe5632ec9b6833242", "html_url": "https://github.com/rust-lang/rust/commit/7cba853b4f6080bf7831169fe5632ec9b6833242"}, {"sha": "486856f75fd8c681f728ed3445e285666dbe19b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/486856f75fd8c681f728ed3445e285666dbe19b9", "html_url": "https://github.com/rust-lang/rust/commit/486856f75fd8c681f728ed3445e285666dbe19b9"}], "stats": {"total": 2225, "additions": 1201, "deletions": 1024}, "files": [{"sha": "e5aad52ef4b792b1d1f52e23a100a5fea6b38f12", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -114,6 +114,7 @@ James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n Jason Fager <jfager@gmail.com>\n+Jason Liquorish <jason@liquori.sh> <Bassetts@users.noreply.github.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason.orendorff@gmail.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason@mozmac-2.local>\n Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>"}, {"sha": "b8fbfbf8ad3f5a7e29b9cfff515efbb5e3a8855c", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -3552,6 +3552,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_ast_pretty\",\n+ \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n@@ -3629,6 +3630,7 @@ version = \"0.0.0\"\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"lazy_static 1.4.0\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3748,7 +3750,6 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n@@ -3812,7 +3813,6 @@ name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n- \"itertools 0.8.0\",\n  \"log\",\n  \"rustc\",\n  \"rustc_apfloat\","}, {"sha": "50e1726240fffd29936c469d15386e60fad3a52b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -80,7 +80,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-s\"\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n-             \"--connect-timeout\", \"30\", # timeout if cannot connect within 30 seconds\n+             \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n              \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n             exception=exception)\n@@ -332,7 +332,6 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n \n-\n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n@@ -351,7 +350,7 @@ def support_xz():\n             try:\n                 with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n                     temp_path = temp_file.name\n-                with tarfile.open(temp_path, \"w:xz\") as tar:\n+                with tarfile.open(temp_path, \"w:xz\"):\n                     pass\n                 return True\n             except tarfile.CompressionError:\n@@ -825,7 +824,7 @@ def check_vendored_status(self):\n                 if not os.path.exists(vendor_dir):\n                     print('error: vendoring required, but vendor directory does not exist.')\n                     print('       Run `cargo vendor` without sudo to initialize the '\n-                        'vendor directory.')\n+                          'vendor directory.')\n                     raise Exception(\"{} not found\".format(vendor_dir))\n \n         if self.use_vendored_sources:\n@@ -839,7 +838,7 @@ def check_vendored_status(self):\n                     \"\\n\"\n                     \"[source.vendored-sources]\\n\"\n                     \"directory = '{}/vendor'\\n\"\n-                .format(self.rust_root))\n+                    .format(self.rust_root))\n         else:\n             if os.path.exists('.cargo'):\n                 shutil.rmtree('.cargo')"}, {"sha": "3d2eead6788bf2fedcb8aeb93c54daa4a428c782", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -393,11 +393,12 @@ def set(key, value):\n \n \n def is_number(value):\n-  try:\n-    float(value)\n-    return True\n-  except ValueError:\n-    return False\n+    try:\n+        float(value)\n+        return True\n+    except ValueError:\n+        return False\n+\n \n # Here we walk through the constructed configuration we have from the parsed\n # command line arguments. We then apply each piece of configuration by"}, {"sha": "78ac060368193964fb3fb8420e63894810802863", "filename": "src/ci/cpu-usage-over-time.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -148,11 +148,11 @@ def idle_since(self, prev):\n     print('unknown platform', sys.platform)\n     sys.exit(1)\n \n-cur_state = State();\n+cur_state = State()\n print(\"Time,Idle\")\n while True:\n-    time.sleep(1);\n-    next_state = State();\n+    time.sleep(1)\n+    next_state = State()\n     now = datetime.datetime.utcnow().isoformat()\n     idle = next_state.idle_since(cur_state)\n     print(\"%s,%s\" % (now, idle))"}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -212,7 +212,6 @@ def __classify_struct(self):\n         # REGULAR STRUCT\n         return TYPE_KIND_REGULAR_STRUCT\n \n-\n     def __classify_union(self):\n         assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n \n@@ -233,7 +232,6 @@ def __classify_union(self):\n         else:\n             return TYPE_KIND_REGULAR_UNION\n \n-\n     def __conforms_to_field_layout(self, expected_fields):\n         actual_fields = self.get_fields()\n         actual_field_count = len(actual_fields)\n@@ -363,6 +361,7 @@ def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (tail, head, data_ptr, capacity)\n \n+\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n@@ -376,8 +375,10 @@ def extract_length_and_ptr_from_slice(slice_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (length, data_ptr)\n \n+\n UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n     \"\"\"Extracts the type name from a fully qualified path\"\"\"\n     if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n@@ -393,6 +394,7 @@ def extract_type_name(qualified_type_name):\n     else:\n         return qualified_type_name[index + 2:]\n \n+\n try:\n     compat_str = unicode  # Python 2\n except NameError:"}, {"sha": "4979882ffeaffecebfaf2a856b7d50191d2a4483", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -14,7 +14,6 @@\n even larger, and it's already uncomfortably large (6 KiB).\n \"\"\"\n from __future__ import print_function\n-import sys\n from math import ceil, log\n from fractions import Fraction\n from collections import namedtuple\n@@ -82,6 +81,7 @@ def error(f, e, z):\n     ulp_err = abs_err / Fraction(2) ** z.exp\n     return float(ulp_err)\n \n+\n HEADER = \"\"\"\n //! Tables of approximations of powers of ten.\n //! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`"}, {"sha": "0914c22eb13f03d0b9d0c94474ac7e5b57795195", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -9,7 +9,7 @@\n if sys.version_info[0] >= 3:\n     xrange = range\n \n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n \n # The btree pretty-printers fail in a confusing way unless\n # https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n@@ -21,9 +21,10 @@\n     if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n         gdb_81 = True\n \n-#===============================================================================\n+# ===============================================================================\n # GDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class GdbType(rustpp.Type):\n \n@@ -133,39 +134,39 @@ def rust_pretty_printer_lookup_function(gdb_val):\n \n     if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n         return RustStringSlicePrinter(val)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = True,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=True,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return RustCStyleVariantPrinter(val.get_child_at_index(0))\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         variant = get_field_at_index(gdb_val, 0)\n@@ -189,9 +190,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     return None\n \n \n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n # Pretty Printer Classes\n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n class RustEmptyPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -355,6 +356,7 @@ def children_of_node(boxed_node, height, want_values):\n             else:\n                 yield keys[i]['value']['value']\n \n+\n class RustStdBTreeSetPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -429,6 +431,7 @@ def to_string(self):\n     def display_hint(self):\n         return \"string\"\n \n+\n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):\n         assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM"}, {"sha": "c42f942c63cf5fa4597ef663afde6ee1c14704b8", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -8,7 +8,8 @@\n sample usage: src/etc/generate-deriving-span-tests.py\n \"\"\"\n \n-import os, stat\n+import os\n+import stat\n \n TEST_DIR = os.path.abspath(\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n@@ -56,15 +57,17 @@\n \n ENUM_TUPLE, ENUM_STRUCT, STRUCT_FIELDS, STRUCT_TUPLE = range(4)\n \n+\n def create_test_case(type, trait, super_traits, error_count):\n     string = [ENUM_STRING, ENUM_STRUCT_VARIANT_STRING, STRUCT_STRING, STRUCT_TUPLE_STRING][type]\n     all_traits = ','.join([trait] + super_traits)\n     super_traits = ','.join(super_traits)\n     error_deriving = '#[derive(%s)]' % super_traits if super_traits else ''\n \n     errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n-    code = string.format(traits = all_traits, errors = errors)\n-    return TEMPLATE.format(error_deriving=error_deriving, code = code)\n+    code = string.format(traits=all_traits, errors=errors)\n+    return TEMPLATE.format(error_deriving=error_deriving, code=code)\n+\n \n def write_file(name, string):\n     test_file = os.path.join(TEST_DIR, 'derives-span-%s.rs' % name)\n@@ -86,10 +89,10 @@ def write_file(name, string):\n \n traits = {\n     'Default': (STRUCT, [], 1),\n-    'FromPrimitive': (0, [], 0), # only works for C-like enums\n+    'FromPrimitive': (0, [], 0),  # only works for C-like enums\n \n-    'Decodable': (0, [], 0), # FIXME: quoting gives horrible spans\n-    'Encodable': (0, [], 0), # FIXME: quoting gives horrible spans\n+    'Decodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n+    'Encodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n }\n \n for (trait, supers, errs) in [('Clone', [], 1),"}, {"sha": "77c3d2758c6dcd6bcfb188cf7ceafd36fa53d2f1", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -11,7 +11,6 @@\n \n import sys\n import os\n-import datetime\n import stat\n \n "}, {"sha": "7789b24b62c83be1ce1297ebf08893e0bc611805", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -131,6 +131,7 @@\n except NameError:\n     unichr = chr\n \n+\n class CustomHTMLParser(HTMLParser):\n     \"\"\"simplified HTML parser.\n \n@@ -169,21 +170,25 @@ def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n+\n Command = namedtuple('Command', 'negated cmd args lineno context')\n \n+\n class FailedCheck(Exception):\n     pass\n \n+\n class InvalidCheck(Exception):\n     pass\n \n+\n def concat_multi_lines(f):\n     \"\"\"returns a generator out of the file object, which\n     - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n       optional whitespace;\n     - keeps a line number (starting from 0) of the first line being\n       concatenated.\"\"\"\n-    lastline = None # set to the last line when the last line has a backslash\n+    lastline = None  # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n     for lineno, line in enumerate(f):\n@@ -208,6 +213,7 @@ def concat_multi_lines(f):\n     if lastline is not None:\n         print_err(lineno, line, 'Trailing backslash at the end of the file')\n \n+\n LINE_PATTERN = re.compile(r'''\n     (?<=(?<!\\S)@)(?P<negated>!?)\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n@@ -252,7 +258,7 @@ def flatten(node):\n \n def normalize_xpath(path):\n     if path.startswith('//'):\n-        return '.' + path # avoid warnings\n+        return '.' + path  # avoid warnings\n     elif path.startswith('.//'):\n         return path\n     else:\n@@ -316,7 +322,7 @@ def get_dir(self, path):\n \n def check_string(data, pat, regexp):\n     if not pat:\n-        return True # special case a presence testing\n+        return True  # special case a presence testing\n     elif regexp:\n         return re.search(pat, data, flags=re.UNICODE) is not None\n     else:\n@@ -353,7 +359,7 @@ def check_tree_text(tree, path, pat, regexp):\n                 ret = check_string(value, pat, regexp)\n                 if ret:\n                     break\n-    except Exception as e:\n+    except Exception:\n         print('Failed to get path \"{}\"'.format(path))\n         raise\n     return ret\n@@ -363,6 +369,7 @@ def get_tree_count(tree, path):\n     path = normalize_xpath(path)\n     return len(tree.findall(path))\n \n+\n def stderr(*args):\n     if sys.version_info.major < 3:\n         file = codecs.getwriter('utf-8')(sys.stderr)\n@@ -371,6 +378,7 @@ def stderr(*args):\n \n     print(*args, file=file)\n \n+\n def print_err(lineno, context, err, message=None):\n     global ERR_COUNT\n     ERR_COUNT += 1\n@@ -381,48 +389,50 @@ def print_err(lineno, context, err, message=None):\n     if context:\n         stderr(\"\\t{}\".format(context))\n \n+\n ERR_COUNT = 0\n \n+\n def check_command(c, cache):\n     try:\n         cerr = \"\"\n-        if c.cmd == 'has' or c.cmd == 'matches': # string test\n+        if c.cmd == 'has' or c.cmd == 'matches':  # string test\n             regexp = (c.cmd == 'matches')\n-            if len(c.args) == 1 and not regexp: # @has <path> = file existence\n+            if len(c.args) == 1 and not regexp:  # @has <path> = file existence\n                 try:\n                     cache.get_file(c.args[0])\n                     ret = True\n                 except FailedCheck as err:\n                     cerr = str(err)\n                     ret = False\n-            elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n+            elif len(c.args) == 2:  # @has/matches <path> <pat> = string test\n                 cerr = \"`PATTERN` did not match\"\n                 ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n-            elif len(c.args) == 3: # @has/matches <path> <pat> <match> = XML tree test\n+            elif len(c.args) == 3:  # @has/matches <path> <pat> <match> = XML tree test\n                 cerr = \"`XPATH PATTERN` did not match\"\n                 tree = cache.get_tree(c.args[0])\n                 pat, sep, attr = c.args[1].partition('/@')\n-                if sep: # attribute\n+                if sep:  # attribute\n                     tree = cache.get_tree(c.args[0])\n                     ret = check_tree_attr(tree, pat, attr, c.args[2], regexp)\n-                else: # normalized text\n+                else:  # normalized text\n                     pat = c.args[1]\n                     if pat.endswith('/text()'):\n                         pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n \n-        elif c.cmd == 'count': # count test\n-            if len(c.args) == 3: # @count <path> <pat> <count> = count test\n+        elif c.cmd == 'count':  # count test\n+            if len(c.args) == 3:  # @count <path> <pat> <count> = count test\n                 expected = int(c.args[2])\n                 found = get_tree_count(cache.get_tree(c.args[0]), c.args[1])\n                 cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n                 ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n-        elif c.cmd == 'has-dir': # has-dir test\n-            if len(c.args) == 1: # @has-dir <path> = has-dir test\n+        elif c.cmd == 'has-dir':  # has-dir test\n+            if len(c.args) == 1:  # @has-dir <path> = has-dir test\n                 try:\n                     cache.get_dir(c.args[0])\n                     ret = True\n@@ -448,11 +458,13 @@ def check_command(c, cache):\n     except InvalidCheck as err:\n         print_err(c.lineno, c.context, str(err))\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n         check_command(c, cache)\n \n+\n if __name__ == '__main__':\n     if len(sys.argv) != 3:\n         stderr('Usage: {} <doc dir> <template>'.format(sys.argv[0]))"}, {"sha": "d9c4bc5562f00a19bcf38981e4378ed62c619d18", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -157,6 +157,7 @@ def watchdog():\n # ~main\n ####################################################################################################\n \n+\n if len(sys.argv) != 3:\n     print(\"usage: python lldb_batchmode.py target-path script-path\")\n     sys.exit(1)"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,10 +1,10 @@\n import lldb\n-import re\n import debugger_pretty_printers_common as rustpp\n \n-#===============================================================================\n+# ===============================================================================\n # LLDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class LldbType(rustpp.Type):\n \n@@ -84,16 +84,16 @@ def print_val(lldb_val, internal_dict):\n         type_kind == rustpp.TYPE_KIND_EMPTY):\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_SLICE:\n         return print_vec_slice_val(val, internal_dict)\n@@ -110,26 +110,26 @@ def print_val(lldb_val, internal_dict):\n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = True,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=True,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return val.type.get_unqualified_type_name()\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n@@ -157,9 +157,9 @@ def print_val(lldb_val, internal_dict):\n     return lldb_val.GetValue()\n \n \n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n     \"\"\"\n@@ -212,6 +212,7 @@ def render_child(child_index):\n     return template % {\"type_name\": type_name,\n                        \"body\": body}\n \n+\n def print_pointer_val(val, internal_dict):\n     \"\"\"Prints a pointer value with Rust syntax\"\"\"\n     assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n@@ -253,18 +254,21 @@ def print_std_vec_val(val, internal_dict):\n                                               length,\n                                               internal_dict)\n \n+\n def print_str_slice_val(val, internal_dict):\n     (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n     return read_utf8_string(data_ptr, length)\n \n+\n def print_std_string_val(val, internal_dict):\n     vec = val.get_child_at_index(0)\n     (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n     return read_utf8_string(data_ptr, length)\n \n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n # Helper Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n+\n \n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n     \"\"\"Prints a contiguous memory range, interpreting it as values of the"}, {"sha": "f41404bf8cab97ff5eb94a1084393e9297e90fad", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -200,21 +200,27 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         align as *mut u8\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        let ptr = alloc(layout);\n-        if !ptr.is_null() { ptr } else { handle_alloc_error(layout) }\n+        match Global.alloc(layout) {\n+            Ok(ptr) => ptr.as_ptr(),\n+            Err(_) => handle_alloc_error(layout),\n+        }\n     }\n }\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+// This signature has to be the same as `Box`, otherwise an ICE will happen.\n+// When an additional parameter to `Box` is added (like `A: AllocRef`), this has to be added here as\n+// well.\n+// For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n+// this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let ptr = ptr.as_ptr();\n-    let size = size_of_val(&*ptr);\n-    let align = min_align_of_val(&*ptr);\n+    let size = size_of_val(ptr.as_ref());\n+    let align = min_align_of_val(ptr.as_ref());\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        dealloc(ptr as *mut u8, layout);\n+        Global.dealloc(ptr.cast().into(), layout);\n     }\n }\n "}, {"sha": "3ac4bd82a3a10fa4919d078b9dcefc53d88bd1b9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -196,12 +196,14 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        if layout.size() == 0 {\n-            return Box(NonNull::dangling().into());\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+            };\n+            Box::from_raw(ptr.as_ptr())\n         }\n-        let ptr =\n-            unsafe { Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)) };\n-        Box(ptr.cast().into())\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -264,15 +266,14 @@ impl<T> Box<[T]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = if layout.size() == 0 {\n-            NonNull::dangling()\n-        } else {\n-            unsafe {\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n                 Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n-            }\n-        };\n-        let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n-        Box(Unique::from(slice))\n+            };\n+            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n+        }\n     }\n }\n \n@@ -308,7 +309,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box(Box::into_unique(self).cast())\n+        Box::from_raw(Box::into_raw(self) as *mut T)\n     }\n }\n \n@@ -346,7 +347,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+        Box::from_raw(Box::into_raw(self) as *mut [T])\n     }\n }\n "}, {"sha": "144654946a2acb53225ac5dedb413f4a2aa95dd4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -280,7 +280,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, uniq) = match self.current_layout() {\n+            let (new_cap, ptr) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +297,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Ok(ptr) => (new_cap, ptr),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -308,13 +308,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n                     // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n+                    let layout = Layout::array::<T>(new_cap).unwrap();\n+                    match self.a.alloc(layout) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n             };\n-            self.ptr = uniq;\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n         }\n     }"}, {"sha": "71f7f971eabaf8c07145b1a7af81cc18a7adc88e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 139, "deletions": 199, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -593,9 +593,8 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n-///   reallocation method (`realloc`, `realloc_excess`, or\n-///   `realloc_array`), and\n+///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n+///   (`realloc`, `realloc_excess`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n@@ -606,11 +605,6 @@ pub unsafe trait GlobalAlloc {\n /// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n-/// * However, some higher-level allocation methods (`alloc_one`,\n-///   `alloc_array`) are well-defined on zero-sized types and can\n-///   optionally support them: it is left up to the implementor\n-///   whether to return `Err`, or to return `Ok` with some pointer.\n-///\n /// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n@@ -853,6 +847,59 @@ pub unsafe trait AllocRef {\n         result\n     }\n \n+    /// Behaves like `realloc`, but also ensures that the new contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n+        let old_size = layout.size();\n+\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let result = self.alloc_zeroed(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n@@ -904,6 +951,31 @@ pub unsafe trait AllocRef {\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Behaves like `realloc`, but also returns the whole size of\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n@@ -934,6 +1006,37 @@ pub unsafe trait AllocRef {\n         self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_excess_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -983,6 +1086,34 @@ pub unsafe trait AllocRef {\n         if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n+    /// Behaves like `grow_in_place`, but also ensures that the new\n+    /// contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `grow_in_place` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n+    /// function; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n+        self.grow_in_place(ptr, layout, new_size)?;\n+        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n+        Ok(())\n+    }\n+\n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -1035,195 +1166,4 @@ pub unsafe trait AllocRef {\n         // new_layout.size() <= layout.size()        [required by this method]\n         if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-\n-    // == COMMON USAGE PATTERNS ==\n-    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n-\n-    /// Allocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `T` does not meet allocator's size or alignment constraints.\n-    ///\n-    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n-    /// will *not* yield undefined behavior.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n-    }\n-\n-    /// Deallocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// The given block must have been produced by this allocator,\n-    /// and must be suitable for storing a `T` (in terms of alignment\n-    /// as well as minimum and maximum size); otherwise yields\n-    /// undefined behavior.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            self.dealloc(ptr.cast(), k);\n-        }\n-    }\n-\n-    /// Allocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Reallocates a block previously suitable for holding `n_old`\n-    /// instances of `T`, returning a block suitable for holding\n-    /// `n_new` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n_new]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(\n-        &mut self,\n-        ptr: NonNull<T>,\n-        n_old: usize,\n-        n_new: usize,\n-    ) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n-                debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n-            }\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Deallocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `[T; n]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either `[T; n]` or the given\n-    /// memory block does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n-            _ => Err(AllocErr),\n-        }\n-    }\n }"}, {"sha": "7d48280661a64232a6487687ab4dfc9b10c09eeb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -2,7 +2,6 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n-pub mod check_attr;\n pub mod exports;\n pub mod map;\n "}, {"sha": "1a763e43d557dea9520394b670096445794faeb1", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -251,12 +251,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "88ddd96eec8f5e66a61c1582bad4bd5b035d7ed0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,40 +1,3 @@\n-macro_rules! enum_from_u32 {\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant = $e),*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant,)*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    }\n-}\n-\n #[macro_export]\n macro_rules! bug {\n     () => ( bug!(\"impossible case reached\") );"}, {"sha": "c8e284be6fc09cf5cad7615b2d19fd125163d61e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 35, "deletions": 390, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -9,401 +9,14 @@\n \n pub use self::LangItem::*;\n \n-use crate::hir::check_attr::Target;\n-use crate::middle::cstore::ExternCrate;\n-use crate::middle::weak_lang_items;\n use crate::ty::{self, TyCtxt};\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_macros::HashStable;\n-use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use syntax::ast;\n+use rustc_target::spec::PanicStrategy;\n \n-// The actual lang items defined come at the end of this file in one handy table.\n-// So you probably just want to nip down to the end.\n-macro_rules! language_item_table {\n-    (\n-        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n-    ) => {\n-\n-enum_from_u32! {\n-    /// A representation of all the valid language items in Rust.\n-    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-    pub enum LangItem {\n-        $($variant,)*\n-    }\n-}\n-\n-impl LangItem {\n-    /// Returns the `name` in `#[lang = \"$name\"]`.\n-    /// For example, `LangItem::EqTraitLangItem`,\n-    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-    fn name(self) -> &'static str {\n-        match self {\n-            $( $variant => $name, )*\n-        }\n-    }\n-}\n-\n-#[derive(HashStable)]\n-pub struct LanguageItems {\n-    /// Mappings from lang items to their possibly found `DefId`s.\n-    /// The index corresponds to the order in `LangItem`.\n-    pub items: Vec<Option<DefId>>,\n-    /// Lang items that were not found during collection.\n-    pub missing: Vec<LangItem>,\n-}\n-\n-impl LanguageItems {\n-    /// Construct an empty collection of lang items and no missing ones.\n-    pub fn new() -> Self {\n-        fn init_none(_: LangItem) -> Option<DefId> { None }\n-\n-        Self {\n-            items: vec![$(init_none($variant)),*],\n-            missing: Vec::new(),\n-        }\n-    }\n-\n-    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-    pub fn items(&self) -> &[Option<DefId>] {\n-        &*self.items\n-    }\n-\n-    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-    /// returns an error message as a string.\n-    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n-    }\n-\n-    /// Returns the kind of closure that `id`, which is one of the `Fn*` traits, corresponds to.\n-    /// If `id` is not one of the `Fn*` traits, `None` is returned.\n-    pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n-        match Some(id) {\n-            x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n-            x if x == self.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n-            x if x == self.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n-            _ => None\n-        }\n-    }\n-\n-    $(\n-        /// Returns the corresponding `DefId` for the lang item\n-        #[doc = $name]\n-        /// if it exists.\n-        #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<DefId> {\n-            self.items[$variant as usize]\n-        }\n-    )*\n-}\n-\n-struct LanguageItemCollector<'tcx> {\n-    items: LanguageItems,\n-    tcx: TyCtxt<'tcx>,\n-    /// A mapping from the name of the lang item to its order and the form it must be of.\n-    item_refs: FxHashMap<&'static str, (usize, Target)>,\n-}\n-\n-impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let Some((value, span)) = extract(&item.attrs) {\n-            let actual_target = Target::from_item(item);\n-            match self.item_refs.get(&*value.as_str()).cloned() {\n-                // Known lang item with attribute on correct target.\n-                Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n-                },\n-                // Known lang item with attribute on incorrect target.\n-                Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value, expected_target,\n-                    ).span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    ).emit();\n-                },\n-                // Unknown lang item.\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    ).span_label(\n-                        span,\n-                        format!(\"definition of unknown language item `{}`\", value)\n-                    ).emit();\n-                },\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n-        // At present, lang items are always items, not trait items.\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n-        // At present, lang items are always items, not impl items.\n-    }\n-}\n-\n-impl LanguageItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n-        let mut item_refs = FxHashMap::default();\n-\n-        $( item_refs.insert($name, ($variant as usize, $target)); )*\n-\n-        LanguageItemCollector {\n-            tcx,\n-            items: LanguageItems::new(),\n-            item_refs,\n-        }\n-    }\n-\n-    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n-        // Check for duplicates.\n-        if let Some(original_def_id) = self.items.items[item_index] {\n-            if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => {\n-                        match self.tcx.extern_crate(item_def_id) {\n-                            Some(ExternCrate {dependency_of, ..}) => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name))\n-                            },\n-                            _ => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}`: `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                name))\n-                            }\n-                        }\n-                    },\n-                };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n-                } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate {dependency_of, ..}) => {\n-                            err.note(&format!(\n-                            \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                      self.tcx.crate_name(original_def_id.krate),\n-                                      self.tcx.crate_name(*dependency_of)));\n-                        },\n-                        _ => {\n-                            err.note(&format!(\"the lang item is first defined in crate `{}`.\",\n-                                      self.tcx.crate_name(original_def_id.krate)));\n-                        }\n-                    }\n-                }\n-                err.emit();\n-            }\n-        }\n-\n-        // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n-    }\n-}\n-\n-/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-        _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n-        _ => return None,\n-    }))\n-}\n-\n-/// Traverses and collects all the lang items in all crates.\n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n-    // Initialize the collector.\n-    let mut collector = LanguageItemCollector::new(tcx);\n-\n-    // Collect lang items in other crates.\n-    for &cnum in tcx.crates().iter() {\n-        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            collector.collect_item(item_index, def_id);\n-        }\n-    }\n-\n-    // Collect lang items in this crate.\n-    tcx.hir().krate().visit_all_item_likes(&mut collector);\n-\n-    // Extract out the found lang items.\n-    let LanguageItemCollector { mut items, .. } = collector;\n-\n-    // Find all required but not-yet-defined lang items.\n-    weak_lang_items::check_crate(tcx, &mut items);\n-\n-    items\n-}\n-\n-// End of the macro\n-    }\n-}\n-\n-language_item_table! {\n-//  Variant name,                Name,                 Method name,             Target;\n-    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n-    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n-    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n-    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n-    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n-    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n-    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n-    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n-    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n-    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n-    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n-    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n-    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n-    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n-    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n-    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n-    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n-    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n-    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n-    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n-    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n-    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n-    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n-    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n-    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n-    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n-\n-    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n-    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n-    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n-    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n-    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n-    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n-    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n-    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n-    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n-\n-    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n-\n-    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n-\n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n-\n-    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n-    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n-\n-    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n-    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n-    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n-\n-    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n-    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n-    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n-\n-    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n-    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n-    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n-    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n-    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n-\n-    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n-    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n-    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-\n-    // A number of panic-related lang items. The `panic` item corresponds to\n-    // divide-by-zero and various panic cases with `match`. The\n-    // `panic_bounds_check` item is for indexing arrays.\n-    //\n-    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n-    // a \"weak lang item\" in the sense that a crate is not required to have it\n-    // defined to use it, but a final product is required to define it\n-    // somewhere. Additionally, there are restrictions on crates that use a weak\n-    // lang item, but do not have it defined.\n-    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n-    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n-    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n-    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n-    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n-    // Libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n-\n-    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n-    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n-    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n-    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n-    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n-\n-    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n-\n-    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n-    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n-\n-    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n-\n-    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n-\n-    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n-\n-    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n-\n-    // Align offset for stride != 1; must not panic.\n-    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n-\n-    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n-\n-    Arc,                         \"arc\",                arc,                     Target::Struct;\n-    Rc,                          \"rc\",                 rc,                      Target::Struct;\n-}\n+pub use rustc_hir::weak_lang_items::link_name;\n+pub use rustc_hir::{LangItem, LanguageItems};\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n@@ -417,4 +30,36 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         })\n     }\n+\n+    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+        let items = self.lang_items();\n+        match Some(id) {\n+            x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n+            x if x == items.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n+            x if x == items.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        self.lang_items().is_weak_lang_item(item_def_id)\n+    }\n+}\n+\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n+/// present for this compilation.\n+///\n+/// Not all lang items are always required for each compilation, particularly in\n+/// the case of panic=abort. In these situations some lang items are injected by\n+/// crates and don't actually need to be defined in libstd.\n+pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n+    // If we're not compiling with unwinding, we won't actually need these\n+    // symbols. Other panic runtimes ensure that the relevant symbols are\n+    // available to link things together, but they're never exercised.\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+        return lang_item == LangItem::EhPersonalityLangItem\n+            || lang_item == LangItem::EhUnwindResumeLangItem;\n+    }\n+\n+    false\n }"}, {"sha": "b20f2cf3a85c133f53bec53c9ea3b041aa21ff43", "filename": "src/librustc/middle/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmod.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -33,4 +33,3 @@ pub mod recursion_limit;\n pub mod region;\n pub mod resolve_lifetime;\n pub mod stability;\n-pub mod weak_lang_items;"}, {"sha": "5571f8f2313d56f0d8e0dae37ed41527bfa52847", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7cba853b4f6080bf7831169fe5632ec9b6833242/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cba853b4f6080bf7831169fe5632ec9b6833242/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7cba853b4f6080bf7831169fe5632ec9b6833242", "patch": "@@ -1,167 +0,0 @@\n-//! Validity checking for weak lang items\n-\n-use crate::middle::lang_items;\n-use crate::session::config;\n-\n-use crate::hir::map::Map;\n-use crate::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n-use rustc_target::spec::PanicStrategy;\n-use syntax::ast;\n-\n-macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n-\n-struct Context<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    items: &'a mut lang_items::LanguageItems,\n-}\n-\n-/// Checks the crate for usage of weak lang items, returning a vector of all the\n-/// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n-                             items: &mut lang_items::LanguageItems) {\n-    // These are never called by user code, they're generated by the compiler.\n-    // They will never implicitly be added to the `missing` array unless we do\n-    // so here.\n-    if items.eh_personality().is_none() {\n-        items.missing.push(lang_items::EhPersonalityLangItem);\n-    }\n-    if tcx.sess.target.target.options.custom_unwind_resume &\n-       items.eh_unwind_resume().is_none() {\n-        items.missing.push(lang_items::EhUnwindResumeLangItem);\n-    }\n-\n-    {\n-        let mut cx = Context { tcx, items };\n-        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n-    }\n-    verify(tcx, items);\n-}\n-\n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n-        }\n-    })\n-}\n-\n-/// Returns `true` if the specified `lang_item` doesn't actually need to be\n-/// present for this compilation.\n-///\n-/// Not all lang items are always required for each compilation, particularly in\n-/// the case of panic=abort. In these situations some lang items are injected by\n-/// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: lang_items::LangItem) -> bool {\n-    // If we're not compiling with unwinding, we won't actually need these\n-    // symbols. Other panic runtimes ensure that the relevant symbols are\n-    // available to link things together, but they're never exercised.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == lang_items::EhPersonalityLangItem ||\n-            lang_item == lang_items::EhUnwindResumeLangItem\n-    }\n-\n-    false\n-}\n-\n-fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n-                    items: &lang_items::LanguageItems) {\n-    // We only need to check for the presence of weak lang items if we're\n-    // emitting something that's not an rlib.\n-    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n-        match *kind {\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro |\n-            config::CrateType::Cdylib |\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib => true,\n-            config::CrateType::Rlib => false,\n-        }\n-    });\n-    if !needs_check {\n-        return\n-    }\n-\n-    let mut missing = FxHashSet::default();\n-    for &cnum in tcx.crates().iter() {\n-        for &item in tcx.missing_lang_items(cnum).iter() {\n-            missing.insert(item);\n-        }\n-    }\n-\n-    $(\n-        if missing.contains(&lang_items::$item) &&\n-           !whitelisted(tcx, lang_items::$item) &&\n-           items.$name().is_none() {\n-            if lang_items::$item == lang_items::PanicImplLangItem {\n-                tcx.sess.err(&format!(\"`#[panic_handler]` function required, \\\n-                                       but not found\"));\n-            } else if lang_items::$item == lang_items::OomLangItem {\n-                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, \\\n-                                       but not found\"));\n-            } else {\n-                tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n-                                      stringify!($name)));\n-            }\n-        }\n-    )*\n-}\n-\n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n-        $(if name == sym::$name {\n-            if self.items.$name().is_none() {\n-                self.items.missing.push(lang_items::$item);\n-            }\n-        } else)* {\n-            struct_span_err!(\n-                self.tcx.sess, span, E0264,\n-                \"unknown external lang item: `{}`\",\n-                name\n-            )\n-            .emit();\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    type Map = Map<'v>;\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Map<'v>> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n-        }\n-        intravisit::walk_foreign_item(self, i)\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let lang_items = self.lang_items();\n-        let did = Some(item_def_id);\n-\n-        $(lang_items.$name() == did)||*\n-    }\n-}\n-\n-) }\n-\n-weak_lang_items! {\n-    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n-    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n-    oom,                OomLangItem,                rust_oom;\n-}"}, {"sha": "86e7bb28e00699494f2fe2a28427ccc13e00ece6", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -128,10 +128,9 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         }\n     }\n \n-    /// Sets the message passed in via `message`, then adds the span labels for you, before applying\n-    /// further modifications in `emit`. It's up to you to call emit(), stash(..), etc. within the\n-    /// `emit` method. If you don't need to do any additional processing, just use\n-    /// struct_generic.\n+    /// Sets the message passed in via `message` and adds span labels before handing control back\n+    /// to `emit` to do any final processing. It's the caller's responsibility to call emit(),\n+    /// stash(), etc. within the `emit` function to dispose of the diagnostic properly.\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,"}, {"sha": "bf82d743c2b0466a5a7ccc8d5b4c010d2b656c58", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1634,7 +1634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n+        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => {\n                 return Ok(());\n@@ -1677,7 +1677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2889,8 +2889,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let kind = self\n             .tcx()\n-            .lang_items()\n-            .fn_trait_kind(obligation.predicate.def_id())\n+            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "2adf708641798a86d08dc8307bb497f60048bf73", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -2716,10 +2716,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.get_lang_items = |tcx, id| {\n-        assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(middle::lang_items::collect(tcx))\n-    };\n     providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "b5e17661c5de1ed30c719bb23ea5765edc177e80", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -450,7 +450,7 @@ fn resolve_associated_item<'tcx>(\n             substs: generator_data.substs,\n         }),\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "274482cba64cc5d66c09ab21e40c503f0d734f1c", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -724,7 +724,7 @@ pub trait PrettyPrinter<'tcx>:\n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();"}, {"sha": "7aaa70d6ec4d3d13c4dba22e53a082a77e32cf38", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -32,7 +32,7 @@ use syntax::expand::allocator::AllocatorKind;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc::session::config::{OptLevel, OutputFilenames, PrintRequest};\n+use rustc::session::config::{self, OptLevel, OutputFilenames, PrintRequest};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n@@ -301,7 +301,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n             let rlink_data = json::encode(&codegen_results).map_err(|err| {\n                 sess.fatal(&format!(\"failed to encode rlink: {}\", err));\n             })?;\n-            let rlink_file = outputs.with_extension(\"rlink\");\n+            let rlink_file = outputs.with_extension(config::RLINK_EXT);\n             fs::write(&rlink_file, rlink_data).map_err(|err| {\n                 sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n             })?;"}, {"sha": "e9431d94863ef96a4eb87ff4ec1520cfccfa77cd", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -28,8 +28,8 @@ use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind}\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::{self, LinkagePreference};\n+use rustc::middle::lang_items;\n use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n@@ -847,11 +847,8 @@ impl CrateInfo {\n \n             // No need to look for lang items that are whitelisted and don't\n             // actually need to exist.\n-            let missing = missing\n-                .iter()\n-                .cloned()\n-                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n-                .collect();\n+            let missing =\n+                missing.iter().cloned().filter(|&l| !lang_items::whitelisted(tcx, l)).collect();\n             info.missing_lang_items.insert(cnum, missing);\n         }\n "}, {"sha": "67fbe3058cdb981170ce653c9d22c0695f8f753c", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -17,3 +17,41 @@ macro_rules! static_assert_size {\n         const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n     };\n }\n+\n+#[macro_export]\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "5b185f9a8b6b9bee7c67054866971f48afa93583", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -26,6 +26,7 @@ rustc_mir = { path = \"../librustc_mir\" }\n rustc_parse = { path = \"../librustc_parse\" }\n rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_interface = { path = \"../librustc_interface\" }"}, {"sha": "2e6dde6459a40eb3c42fd6f7f7df48780f75e933", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -26,25 +26,27 @@ use rustc::session::{config, DiagnosticOutput, Session};\n use rustc::session::{early_error, early_warn};\n use rustc::ty::TyCtxt;\n use rustc::util::common::ErrorReported;\n+use rustc_codegen_ssa::CodegenResults;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::{registry::Registry, PResult};\n use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_interface::util::get_builtin_codegen_backend;\n+use rustc_interface::util::{collect_crate_types, get_builtin_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_serialize::json::ToJson;\n+use rustc_serialize::json::{self, ToJson};\n \n use std::borrow::Cow;\n use std::cmp::max;\n use std::default::Default;\n use std::env;\n use std::ffi::OsString;\n+use std::fs;\n use std::io::{self, Read, Write};\n use std::mem;\n use std::panic::{self, catch_unwind};\n@@ -281,7 +283,8 @@ pub fn run_compiler(\n                 &matches,\n                 compiler.input(),\n             )\n-        });\n+        })\n+        .and_then(|| RustcDefaultCalls::try_process_rlink(sess, compiler));\n \n         if should_stop == Compilation::Stop {\n             return sess.compile_status();\n@@ -588,6 +591,34 @@ fn show_content_with_pager(content: &String) {\n }\n \n impl RustcDefaultCalls {\n+    fn process_rlink(sess: &Session, compiler: &interface::Compiler) -> Result<(), ErrorReported> {\n+        if let Input::File(file) = compiler.input() {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            let attrs = vec![];\n+            sess.crate_types.set(collect_crate_types(sess, &attrs));\n+            let outputs = compiler.build_output_filenames(&sess, &attrs);\n+            let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n+                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+            });\n+            let codegen_results: CodegenResults = json::decode(&rlink_data).unwrap_or_else(|err| {\n+                sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n+            });\n+            compiler.codegen_backend().link(&sess, Box::new(codegen_results), &outputs)\n+        } else {\n+            sess.fatal(&format!(\"rlink must be a file\"))\n+        }\n+    }\n+\n+    pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+        if sess.opts.debugging_opts.link_only {\n+            let result = RustcDefaultCalls::process_rlink(sess, compiler);\n+            abort_on_err(result, sess);\n+            Compilation::Stop\n+        } else {\n+            Compilation::Continue\n+        }\n+    }\n+\n     pub fn list_metadata(\n         sess: &Session,\n         metadata_loader: &dyn MetadataLoader,\n@@ -663,7 +694,7 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", id);\n                         continue;\n                     }\n-                    let crate_types = rustc_interface::util::collect_crate_types(sess, attrs);\n+                    let crate_types = collect_crate_types(sess, attrs);\n                     for &style in &crate_types {\n                         let fname = rustc_codegen_utils::link::filename_for_input(\n                             sess, style, &id, &t_outputs,"}, {"sha": "cff6413253202dde7ea183f829048b5dc9033b19", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -19,4 +19,5 @@ rustc_span = { path = \"../librustc_span\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n+lazy_static = \"1\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "cb5ebba463394c08353fdf1699da288c915f1b88", "filename": "src/librustc_hir/lang_items.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -0,0 +1,261 @@\n+//! Defines language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+pub use self::LangItem::*;\n+\n+use crate::def_id::DefId;\n+use crate::Target;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+// The actual lang items defined come at the end of this file in one handy table.\n+// So you probably just want to nip down to the end.\n+macro_rules! language_item_table {\n+    (\n+        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n+    ) => {\n+\n+        enum_from_u32! {\n+            /// A representation of all the valid language items in Rust.\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+            pub enum LangItem {\n+                $($variant,)*\n+            }\n+        }\n+\n+        impl LangItem {\n+            /// Returns the `name` in `#[lang = \"$name\"]`.\n+            /// For example, `LangItem::EqTraitLangItem`,\n+            /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $( $variant => $name, )*\n+                }\n+            }\n+        }\n+\n+        #[derive(HashStable_Generic)]\n+        pub struct LanguageItems {\n+            /// Mappings from lang items to their possibly found `DefId`s.\n+            /// The index corresponds to the order in `LangItem`.\n+            pub items: Vec<Option<DefId>>,\n+            /// Lang items that were not found during collection.\n+            pub missing: Vec<LangItem>,\n+        }\n+\n+        impl LanguageItems {\n+            /// Construct an empty collection of lang items and no missing ones.\n+            pub fn new() -> Self {\n+                fn init_none(_: LangItem) -> Option<DefId> { None }\n+\n+                Self {\n+                    items: vec![$(init_none($variant)),*],\n+                    missing: Vec::new(),\n+                }\n+            }\n+\n+            /// Returns the mappings to the possibly found `DefId`s for each lang item.\n+            pub fn items(&self) -> &[Option<DefId>] {\n+                &*self.items\n+            }\n+\n+            /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+            /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+            /// returns an error message as a string.\n+            pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n+                self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+            }\n+\n+            $(\n+                /// Returns the corresponding `DefId` for the lang item\n+                #[doc = $name]\n+                /// if it exists.\n+                #[allow(dead_code)]\n+                pub fn $method(&self) -> Option<DefId> {\n+                    self.items[$variant as usize]\n+                }\n+            )*\n+        }\n+\n+        lazy_static! {\n+            /// A mapping from the name of the lang item to its order and the form it must be of.\n+            pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n+                let mut item_refs = FxHashMap::default();\n+                $( item_refs.insert($name, ($variant as usize, $target)); )*\n+                item_refs\n+            };\n+        }\n+\n+// End of the macro\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for LangItem {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n+/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n+/// are also extracted out when found.\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n+    attrs.iter().find_map(|attr| {\n+        Some(match attr {\n+            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ => return None,\n+        })\n+    })\n+}\n+\n+language_item_table! {\n+//  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n+    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n+    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n+    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n+    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n+    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n+    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n+    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n+    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n+    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n+    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n+    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n+    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n+    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n+    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n+    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n+    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n+    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n+    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n+    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n+    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n+    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n+    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n+    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n+    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n+    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n+\n+    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n+    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n+    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n+    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n+    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n+    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n+\n+    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n+\n+    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n+    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n+\n+    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n+    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n+    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n+    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n+    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n+    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n+    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n+    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n+    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n+\n+    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n+\n+    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n+    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n+    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n+\n+    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n+    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n+    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n+\n+    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n+    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n+    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n+    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n+    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n+\n+    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n+    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n+    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to\n+    // divide-by-zero and various panic cases with `match`. The\n+    // `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n+    // a \"weak lang item\" in the sense that a crate is not required to have it\n+    // defined to use it, but a final product is required to define it\n+    // somewhere. Additionally, there are restrictions on crates that use a weak\n+    // lang item, but do not have it defined.\n+    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n+    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n+    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n+    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n+    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n+    // Libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n+\n+    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n+    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n+    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n+    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n+    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n+\n+    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n+\n+    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n+    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n+    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n+\n+    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n+\n+    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n+\n+    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n+\n+    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n+\n+    // Align offset for stride != 1; must not panic.\n+    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n+\n+    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n+\n+    Arc,                         \"arc\",                arc,                     Target::Struct;\n+    Rc,                          \"rc\",                 rc,                      Target::Struct;\n+}"}, {"sha": "d958dfc681b00fe0703c2770dbf5ef78807a3033", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -17,9 +17,15 @@ mod hir;\n pub mod hir_id;\n pub mod intravisit;\n pub mod itemlikevisit;\n+pub mod lang_items;\n pub mod pat_util;\n pub mod print;\n mod stable_hash_impls;\n+mod target;\n+pub mod weak_lang_items;\n+\n pub use hir::*;\n pub use hir_id::*;\n+pub use lang_items::{LangItem, LanguageItems};\n pub use stable_hash_impls::HashStableContext;\n+pub use target::{MethodKind, Target};"}, {"sha": "501976fc3cb39cb020f9bbb49c5c343309abaf8e", "filename": "src/librustc_hir/target.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ftarget.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -4,8 +4,8 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc_hir as hir;\n-use rustc_hir::{Item, ItemKind, TraitItem, TraitItemKind};\n+use crate::hir;\n+use crate::{Item, ItemKind, TraitItem, TraitItemKind};\n \n use std::fmt::{self, Display};\n ", "previous_filename": "src/librustc/hir/check_attr.rs"}, {"sha": "79182caae8c80e2c6346950924f5edad3855b88a", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -0,0 +1,48 @@\n+//! Validity checking for weak lang items\n+\n+use crate::def_id::DefId;\n+use crate::{lang_items, LangItem, LanguageItems};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{sym, Symbol};\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+macro_rules! weak_lang_items {\n+    ($($name:ident, $item:ident, $sym:ident;)*) => (\n+\n+lazy_static! {\n+    pub static ref WEAK_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n+        let mut map = FxHashMap::default();\n+        $(map.insert(sym::$name, lang_items::$item);)*\n+        map\n+    };\n+}\n+\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    lang_items::extract(attrs).and_then(|(name, _)| {\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n+        } else)* {\n+            None\n+        }\n+    })\n+}\n+\n+impl LanguageItems {\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        let did = Some(item_def_id);\n+\n+        $(self.$name() == did)||*\n+    }\n+}\n+\n+) }\n+\n+weak_lang_items! {\n+    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n+    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n+    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n+    oom,                OomLangItem,                rust_oom;\n+}"}, {"sha": "e213a4d33a6fb9921af19663df2a79235e31dab8", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -2,7 +2,7 @@ pub use crate::passes::BoxedResolver;\n use crate::util;\n \n use rustc::lint;\n-use rustc::session::config::{self, ErrorOutputType, Input};\n+use rustc::session::config::{self, ErrorOutputType, Input, OutputFilenames};\n use rustc::session::early_error;\n use rustc::session::{DiagnosticOutput, Session};\n use rustc::ty;\n@@ -20,7 +20,7 @@ use rustc_span::source_map::{FileLoader, FileName, SourceMap};\n use std::path::PathBuf;\n use std::result;\n use std::sync::{Arc, Mutex};\n-use syntax::ast::MetaItemKind;\n+use syntax::ast::{self, MetaItemKind};\n use syntax::token;\n \n pub type Result<T> = result::Result<T, ErrorReported>;\n@@ -61,6 +61,19 @@ impl Compiler {\n     pub fn output_file(&self) -> &Option<PathBuf> {\n         &self.output_file\n     }\n+    pub fn build_output_filenames(\n+        &self,\n+        sess: &Session,\n+        attrs: &[ast::Attribute],\n+    ) -> OutputFilenames {\n+        util::build_output_filenames(\n+            &self.input,\n+            &self.output_dir,\n+            &self.output_file,\n+            &attrs,\n+            &sess,\n+        )\n+    }\n }\n \n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`."}, {"sha": "73eb0dd56d772b1ba3d7a618bcbd03cfedced2b5", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -12,4 +12,3 @@ synstructure = \"0.12.1\"\n syn = { version = \"1\", features = [\"full\"] }\n proc-macro2 = \"1\"\n quote = \"1\"\n-itertools = \"0.8\""}, {"sha": "294cdb7643fc93ce10fce622efbbb64a5e72e311", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,4 +1,3 @@\n-use itertools::Itertools;\n use proc_macro::TokenStream;\n use proc_macro2::{Delimiter, TokenTree};\n use quote::quote;\n@@ -469,10 +468,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 attributes.push(quote! { eval_always });\n             };\n \n-            let mut attribute_stream = quote! {};\n-            for e in attributes.into_iter().intersperse(quote! {,}) {\n-                attribute_stream.extend(e);\n-            }\n+            let attribute_stream = quote! {#(#attributes),*};\n \n             // Add the query to the group\n             group_stream.extend(quote! {"}, {"sha": "bfd30ff5da553ee15c6c33ebe8f87b102a17e7f1", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -40,7 +40,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n+            let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) | Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "c109e9c618e73d391472bf0ad3a5da3a1549c652", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -11,7 +11,6 @@ doctest = false\n \n [dependencies]\n arena = { path = \"../libarena\" }\n-itertools = \"0.8\"\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "5cabf3c0262a1e446f06aa0ecf82dd5840ba4c9b", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -4,7 +4,6 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc::hir::check_attr::{MethodKind, Target};\n use rustc::hir::map::Map;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n@@ -15,6 +14,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::DUMMY_HIR_ID;\n use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n+use rustc_hir::{MethodKind, Target};\n use rustc_session::lint::builtin::{CONFLICTING_REPR_HINTS, UNUSED_ATTRIBUTES};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;"}, {"sha": "5f5acc7fdf8150eddc480f25811f23ca502b8ce5", "filename": "src/librustc_passes/lang_items.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -0,0 +1,174 @@\n+//! Detecting language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+use crate::weak_lang_items;\n+\n+use rustc::middle::cstore::ExternCrate;\n+use rustc::ty::TyCtxt;\n+\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::lang_items::{extract, ITEM_REFS};\n+use rustc_hir::{LangItem, LanguageItems, Target};\n+\n+use rustc::ty::query::Providers;\n+\n+struct LanguageItemCollector<'tcx> {\n+    items: LanguageItems,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n+        if let Some((value, span)) = extract(&item.attrs) {\n+            let actual_target = Target::from_item(item);\n+            match ITEM_REFS.get(&*value.as_str()).cloned() {\n+                // Known lang item with attribute on correct target.\n+                Some((item_index, expected_target)) if actual_target == expected_target => {\n+                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n+                    self.collect_item(item_index, def_id);\n+                }\n+                // Known lang item with attribute on incorrect target.\n+                Some((_, expected_target)) => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0718,\n+                        \"`{}` language item must be applied to a {}\",\n+                        value,\n+                        expected_target,\n+                    )\n+                    .span_label(\n+                        span,\n+                        format!(\n+                            \"attribute should be applied to a {}, not a {}\",\n+                            expected_target, actual_target,\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                // Unknown lang item.\n+                _ => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0522,\n+                        \"definition of an unknown language item: `{}`\",\n+                        value\n+                    )\n+                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n+        // At present, lang items are always items, not trait items.\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n+        // At present, lang items are always items, not impl items.\n+    }\n+}\n+\n+impl LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n+        LanguageItemCollector { tcx, items: LanguageItems::new() }\n+    }\n+\n+    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n+        // Check for duplicates.\n+        if let Some(original_def_id) = self.items.items[item_index] {\n+            if original_def_id != item_def_id {\n+                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n+                    Some(span) => struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0152,\n+                        \"found duplicate lang item `{}`\",\n+                        name\n+                    ),\n+                    None => match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            self.tcx.sess.struct_err(&format!(\n+                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n+                                self.tcx.crate_name(item_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of),\n+                                name\n+                            ))\n+                        }\n+                        _ => self.tcx.sess.struct_err(&format!(\n+                            \"duplicate lang item in crate `{}`: `{}`.\",\n+                            self.tcx.crate_name(item_def_id.krate),\n+                            name\n+                        )),\n+                    },\n+                };\n+                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n+                    err.span_note(span, \"the lang item is first defined here\");\n+                } else {\n+                    match self.tcx.extern_crate(original_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n+                                self.tcx.crate_name(original_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of)\n+                            ));\n+                        }\n+                        _ => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}`.\",\n+                                self.tcx.crate_name(original_def_id.krate)\n+                            ));\n+                        }\n+                    }\n+                }\n+                err.emit();\n+            }\n+        }\n+\n+        // Matched.\n+        self.items.items[item_index] = Some(item_def_id);\n+    }\n+}\n+\n+/// Traverses and collects all the lang items in all crates.\n+fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n+    // Initialize the collector.\n+    let mut collector = LanguageItemCollector::new(tcx);\n+\n+    // Collect lang items in other crates.\n+    for &cnum in tcx.crates().iter() {\n+        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n+            collector.collect_item(item_index, def_id);\n+        }\n+    }\n+\n+    // Collect lang items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    // Extract out the found lang items.\n+    let LanguageItemCollector { mut items, .. } = collector;\n+\n+    // Find all required but not-yet-defined lang items.\n+    weak_lang_items::check_crate(tcx, &mut items);\n+\n+    items\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.get_lang_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.arena.alloc(collect(tcx))\n+    };\n+}"}, {"sha": "afafbacb8fa88a6b4640600630c308242aa536d6", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -23,6 +23,7 @@ mod diagnostic_items;\n pub mod entry;\n pub mod hir_stats;\n mod intrinsicck;\n+mod lang_items;\n pub mod layout_test;\n mod lib_features;\n mod liveness;\n@@ -31,12 +32,14 @@ mod reachable;\n mod region;\n pub mod stability;\n mod upvars;\n+mod weak_lang_items;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n     check_const::provide(providers);\n     diagnostic_items::provide(providers);\n     entry::provide(providers);\n+    lang_items::provide(providers);\n     lib_features::provide(providers);\n     loops::provide(providers);\n     liveness::provide(providers);"}, {"sha": "010712c28ba753f1111bf2e4c2e472769b2450b4", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -0,0 +1,103 @@\n+//! Validity checking for weak lang items\n+\n+use rustc::middle::lang_items;\n+use rustc::middle::lang_items::whitelisted;\n+use rustc::session::config;\n+\n+use rustc::hir::map::Map;\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+struct Context<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    items: &'a mut lang_items::LanguageItems,\n+}\n+\n+/// Checks the crate for usage of weak lang items, returning a vector of all the\n+/// language items required by this crate, but not defined yet.\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n+    // These are never called by user code, they're generated by the compiler.\n+    // They will never implicitly be added to the `missing` array unless we do\n+    // so here.\n+    if items.eh_personality().is_none() {\n+        items.missing.push(lang_items::EhPersonalityLangItem);\n+    }\n+    if tcx.sess.target.target.options.custom_unwind_resume & items.eh_unwind_resume().is_none() {\n+        items.missing.push(lang_items::EhUnwindResumeLangItem);\n+    }\n+\n+    {\n+        let mut cx = Context { tcx, items };\n+        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n+    }\n+    verify(tcx, items);\n+}\n+\n+fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n+    // We only need to check for the presence of weak lang items if we're\n+    // emitting something that's not an rlib.\n+    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n+        config::CrateType::Dylib\n+        | config::CrateType::ProcMacro\n+        | config::CrateType::Cdylib\n+        | config::CrateType::Executable\n+        | config::CrateType::Staticlib => true,\n+        config::CrateType::Rlib => false,\n+    });\n+    if !needs_check {\n+        return;\n+    }\n+\n+    let mut missing = FxHashSet::default();\n+    for &cnum in tcx.crates().iter() {\n+        for &item in tcx.missing_lang_items(cnum).iter() {\n+            missing.insert(item);\n+        }\n+    }\n+\n+    for (name, &item) in WEAK_ITEMS_REFS.iter() {\n+        if missing.contains(&item) && !whitelisted(tcx, item) && items.require(item).is_err() {\n+            if item == lang_items::PanicImplLangItem {\n+                tcx.sess.err(&format!(\"`#[panic_handler]` function required, but not found\"));\n+            } else if item == lang_items::OomLangItem {\n+                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, but not found\"));\n+            } else {\n+                tcx.sess.err(&format!(\"language item required, but not found: `{}`\", name));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n+    fn register(&mut self, name: Symbol, span: Span) {\n+        if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n+            if self.items.require(item).is_err() {\n+                self.items.missing.push(item);\n+            }\n+        } else {\n+            struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n+                .emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n+    type Map = Map<'v>;\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Map<'v>> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n+        if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n+            self.register(lang_item, i.span);\n+        }\n+        intravisit::walk_foreign_item(self, i)\n+    }\n+}"}, {"sha": "aeb7e891cec02be3f8249aa61c6ddb54849d2b50", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -465,6 +465,7 @@ pub struct OutputFilenames {\n \n impl_stable_hash_via_hash!(OutputFilenames);\n \n+pub const RLINK_EXT: &str = \"rlink\";\n pub const RUST_CGU_EXT: &str = \"rcgu\";\n \n impl OutputFilenames {"}, {"sha": "4b3645cce723a3f1ef3297e92b10e6b49d5e1fdd", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -966,4 +966,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"use Windows Control Flow Guard (`disabled`, `nochecks` or `checks`)\"),\n     no_link: bool = (false, parse_bool, [TRACKED],\n         \"compile without linking\"),\n+    link_only: bool = (false, parse_bool, [TRACKED],\n+        \"link the `.rlink` file generated by `-Z no-link`\"),\n }"}, {"sha": "396534b3caeb7b63840254eeed815da3b4fd6e76", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .next();\n                 let kind = object_type\n                     .principal_def_id()\n-                    .and_then(|did| self.tcx.lang_items().fn_trait_kind(did));\n+                    .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n             .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n+            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n             .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n         (expected_sig, expected_kind)\n@@ -237,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        let is_fn = tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n         let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {"}, {"sha": "ea0e4719a24fd34b004dbc913039d82c2f257b43", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -20,8 +20,8 @@ use crate::astconv::{AstConv, Bounds, SizedByDefault};\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n use crate::lint;\n+use crate::middle::lang_items;\n use crate::middle::resolve_lifetime as rl;\n-use crate::middle::weak_lang_items;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -2977,7 +2977,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if tcx.is_weak_lang_item(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+    if let Some(name) = lang_items::link_name(&attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);\n     }"}, {"sha": "ef357056504529f9dd5245575ba7e148d7687675", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -138,7 +138,7 @@ pub fn external_generic_args(\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() => {\n             assert!(ty_kind.is_some());\n             let inputs = match ty_kind {\n                 Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),"}, {"sha": "58f4e76cd30b3d91285fdcf9655365e634be197e", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1100,10 +1100,28 @@ mod trait_keyword {}\n //\n /// A value of type [`bool`] representing logical **true**.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// Logically `true` is not equal to [`false`].\n+///\n+/// ## Control structures that check for **true**\n+///\n+/// Several of Rust's control structures will check for a `bool` condition evaluating to **true**.\n+///\n+///   * The condition in an [`if`] expression must be of type `bool`.\n+///     Whenever that condition evaluates to **true**, the `if` expression takes\n+///     on the value of the first block. If however, the condition evaluates\n+///     to `false`, the expression takes on value of the `else` block if there is one.\n ///\n+///   * [`while`] is another control flow construct expecting a `bool`-typed condition.\n+///     As long as the condition evaluates to **true**, the `while` loop will continually\n+///     evaluate its associated block.\n+///\n+///   * [`match`] arms can have guard clauses on them.\n+///\n+/// [`if`]: keyword.if.html\n+/// [`while`]: keyword.while.html\n+/// [`match`]: ../reference/expressions/match-expr.html#match-guards\n+/// [`false`]: keyword.false.html\n /// [`bool`]: primitive.bool.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod true_keyword {}\n \n #[doc(keyword = \"type\")]\n@@ -1186,12 +1204,33 @@ mod await_keyword {}\n \n #[doc(keyword = \"dyn\")]\n //\n-/// Name the type of a [trait object].\n+/// `dyn` is a prefix of a [trait object]'s type.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// The `dyn` keyword is used to highlight that calls to methods on the associated `Trait`\n+/// are dynamically dispatched. To use the trait this way, it must be 'object safe'.\n+///\n+/// Unlike generic parameters or `impl Trait`, the compiler does not know the concrete type that\n+/// is being passed. That is, the type has been [erased].\n+/// As such, a `dyn Trait` reference contains _two_ pointers.\n+/// One pointer goes to the data (e.g., an instance of a struct).\n+/// Another pointer goes to a map of method call names to function pointers\n+/// (known as a virtual method table or vtable).\n+///\n+/// At run-time, when a method needs to be called on the `dyn Trait`, the vtable is consulted to get\n+/// the function pointer and then that function pointer is called.\n+///\n+/// ## Trade-offs\n+///\n+/// The above indirection is the additional runtime cost of calling a function on a `dyn Trait`.\n+/// Methods called by dynamic dispatch generally cannot be inlined by the compiler.\n+///\n+/// However, `dyn Trait` is likely to produce smaller code than `impl Trait` / generic parameters as\n+/// the method won't be duplicated for each concrete type.\n+///\n+/// Read more about `object safety` and [trait object]s.\n ///\n /// [trait object]: ../book/ch17-02-trait-objects.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// [erased]: https://en.wikipedia.org/wiki/Type_erasure\n mod dyn_keyword {}\n \n #[doc(keyword = \"union\")]"}, {"sha": "b821a2c59396282462026cd60f03bee3b112cc00", "filename": "src/test/ui/allocator-alloc-one.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cba853b4f6080bf7831169fe5632ec9b6833242/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cba853b4f6080bf7831169fe5632ec9b6833242/src%2Ftest%2Fui%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-alloc-one.rs?ref=7cba853b4f6080bf7831169fe5632ec9b6833242", "patch": "@@ -1,18 +0,0 @@\n-// run-pass\n-\n-#![allow(stable_features)]\n-\n-#![feature(allocator_api, nonnull)]\n-\n-use std::alloc::{AllocRef, Global, Layout, handle_alloc_error};\n-\n-fn main() {\n-    unsafe {\n-        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| {\n-            handle_alloc_error(Layout::new::<i32>())\n-        });\n-        *ptr.as_ptr() = 4;\n-        assert_eq!(*ptr.as_ptr(), 4);\n-        Global.dealloc_one(ptr);\n-    }\n-}"}, {"sha": "fb09f62854d617a3a443e9b32be5004be9fa8233", "filename": "src/test/ui/consts/const-int-unchecked.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.rs?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,4 +1,5 @@\n #![feature(core_intrinsics)]\n+#![feature(const_int_unchecked_arith)]\n \n use std::intrinsics;\n \n@@ -117,4 +118,25 @@ const SHR_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -30) }\n const SHR_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -93) };\n //~^ ERROR any use of this value will cause an error\n \n+// Other arithmetic functions:\n+\n+const _: u16 = unsafe { std::intrinsics::unchecked_add(40000u16, 30000) };\n+//~^ ERROR any use of this value will cause an error\n+\n+const _: u32 = unsafe { std::intrinsics::unchecked_sub(14u32, 22) };\n+//~^ ERROR any use of this value will cause an error\n+\n+const _: u16 = unsafe { std::intrinsics::unchecked_mul(300u16, 250u16) };\n+//~^ ERROR any use of this value will cause an error\n+\n+const _: i32 = unsafe { std::intrinsics::unchecked_div(1, 0) };\n+//~^ ERROR any use of this value will cause an error\n+const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::min_value(), -1) };\n+//~^ ERROR any use of this value will cause an error\n+\n+const _: i32 = unsafe { std::intrinsics::unchecked_rem(1, 0) };\n+//~^ ERROR any use of this value will cause an error\n+const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::min_value(), -1) };\n+//~^ ERROR any use of this value will cause an error\n+\n fn main() {}"}, {"sha": "bf31e0b0732d8be34880cb26b0e17b4faccaa862", "filename": "src/test/ui/consts/const-int-unchecked.stderr", "status": "modified", "additions": 97, "deletions": 41, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,5 +1,5 @@\n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:14:29\n+  --> $DIR/const-int-unchecked.rs:15:29\n    |\n LL | const SHL_U8: u8 = unsafe { intrinsics::unchecked_shl(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n@@ -9,316 +9,372 @@ LL | const SHL_U8: u8 = unsafe { intrinsics::unchecked_shl(5_u8, 8) };\n    = note: `#[deny(const_err)]` on by default\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:16:31\n+  --> $DIR/const-int-unchecked.rs:17:31\n    |\n LL | const SHL_U16: u16 = unsafe { intrinsics::unchecked_shl(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:18:31\n+  --> $DIR/const-int-unchecked.rs:19:31\n    |\n LL | const SHL_U32: u32 = unsafe { intrinsics::unchecked_shl(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:20:31\n+  --> $DIR/const-int-unchecked.rs:21:31\n    |\n LL | const SHL_U64: u64 = unsafe { intrinsics::unchecked_shl(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:22:33\n+  --> $DIR/const-int-unchecked.rs:23:33\n    |\n LL | const SHL_U128: u128 = unsafe { intrinsics::unchecked_shl(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:27:29\n+  --> $DIR/const-int-unchecked.rs:28:29\n    |\n LL | const SHL_I8: i8 = unsafe { intrinsics::unchecked_shl(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n    |                             Overflowing shift by 8 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:29:31\n+  --> $DIR/const-int-unchecked.rs:30:31\n    |\n LL | const SHL_I16: i16 = unsafe { intrinsics::unchecked_shl(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:31:31\n+  --> $DIR/const-int-unchecked.rs:32:31\n    |\n LL | const SHL_I32: i32 = unsafe { intrinsics::unchecked_shl(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:33:31\n+  --> $DIR/const-int-unchecked.rs:34:31\n    |\n LL | const SHL_I64: i64 = unsafe { intrinsics::unchecked_shl(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:35:33\n+  --> $DIR/const-int-unchecked.rs:36:33\n    |\n LL | const SHL_I128: i128 = unsafe { intrinsics::unchecked_shl(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:40:33\n+  --> $DIR/const-int-unchecked.rs:41:33\n    |\n LL | const SHL_I8_NEG: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 255 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:42:35\n+  --> $DIR/const-int-unchecked.rs:43:35\n    |\n LL | const SHL_I16_NEG: i16 = unsafe { intrinsics::unchecked_shl(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 65535 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:44:35\n+  --> $DIR/const-int-unchecked.rs:45:35\n    |\n LL | const SHL_I32_NEG: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 4294967295 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:46:35\n+  --> $DIR/const-int-unchecked.rs:47:35\n    |\n LL | const SHL_I64_NEG: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 18446744073709551615 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:48:37\n+  --> $DIR/const-int-unchecked.rs:49:37\n    |\n LL | const SHL_I128_NEG: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n    |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:54:40\n+  --> $DIR/const-int-unchecked.rs:55:40\n    |\n LL | const SHL_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n    |                                        Overflowing shift by 250 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:56:42\n+  --> $DIR/const-int-unchecked.rs:57:42\n    |\n LL | const SHL_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shl(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 65523 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:58:42\n+  --> $DIR/const-int-unchecked.rs:59:42\n    |\n LL | const SHL_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 4294967271 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:60:42\n+  --> $DIR/const-int-unchecked.rs:61:42\n    |\n LL | const SHL_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 18446744073709551586 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:62:44\n+  --> $DIR/const-int-unchecked.rs:63:44\n    |\n LL | const SHL_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n    |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shl`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:69:29\n+  --> $DIR/const-int-unchecked.rs:70:29\n    |\n LL | const SHR_U8: u8 = unsafe { intrinsics::unchecked_shr(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n    |                             Overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:71:31\n+  --> $DIR/const-int-unchecked.rs:72:31\n    |\n LL | const SHR_U16: u16 = unsafe { intrinsics::unchecked_shr(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:73:31\n+  --> $DIR/const-int-unchecked.rs:74:31\n    |\n LL | const SHR_U32: u32 = unsafe { intrinsics::unchecked_shr(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:75:31\n+  --> $DIR/const-int-unchecked.rs:76:31\n    |\n LL | const SHR_U64: u64 = unsafe { intrinsics::unchecked_shr(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:77:33\n+  --> $DIR/const-int-unchecked.rs:78:33\n    |\n LL | const SHR_U128: u128 = unsafe { intrinsics::unchecked_shr(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:82:29\n+  --> $DIR/const-int-unchecked.rs:83:29\n    |\n LL | const SHR_I8: i8 = unsafe { intrinsics::unchecked_shr(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n    |                             Overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:84:31\n+  --> $DIR/const-int-unchecked.rs:85:31\n    |\n LL | const SHR_I16: i16 = unsafe { intrinsics::unchecked_shr(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:86:31\n+  --> $DIR/const-int-unchecked.rs:87:31\n    |\n LL | const SHR_I32: i32 = unsafe { intrinsics::unchecked_shr(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:88:31\n+  --> $DIR/const-int-unchecked.rs:89:31\n    |\n LL | const SHR_I64: i64 = unsafe { intrinsics::unchecked_shr(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n    |                               Overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:90:33\n+  --> $DIR/const-int-unchecked.rs:91:33\n    |\n LL | const SHR_I128: i128 = unsafe { intrinsics::unchecked_shr(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:95:33\n+  --> $DIR/const-int-unchecked.rs:96:33\n    |\n LL | const SHR_I8_NEG: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n    |                                 Overflowing shift by 255 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:97:35\n+  --> $DIR/const-int-unchecked.rs:98:35\n    |\n LL | const SHR_I16_NEG: i16 = unsafe { intrinsics::unchecked_shr(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 65535 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:99:35\n+  --> $DIR/const-int-unchecked.rs:100:35\n    |\n LL | const SHR_I32_NEG: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 4294967295 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:101:35\n+  --> $DIR/const-int-unchecked.rs:102:35\n    |\n LL | const SHR_I64_NEG: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n    |                                   Overflowing shift by 18446744073709551615 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:103:37\n+  --> $DIR/const-int-unchecked.rs:104:37\n    |\n LL | const SHR_I128_NEG: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n    |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:109:40\n+  --> $DIR/const-int-unchecked.rs:110:40\n    |\n LL | const SHR_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n    |                                        Overflowing shift by 250 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:111:42\n+  --> $DIR/const-int-unchecked.rs:112:42\n    |\n LL | const SHR_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shr(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 65523 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:113:42\n+  --> $DIR/const-int-unchecked.rs:114:42\n    |\n LL | const SHR_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 4294967271 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:115:42\n+  --> $DIR/const-int-unchecked.rs:116:42\n    |\n LL | const SHR_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n    |                                          Overflowing shift by 18446744073709551586 in `unchecked_shr`\n \n error: any use of this value will cause an error\n-  --> $DIR/const-int-unchecked.rs:117:44\n+  --> $DIR/const-int-unchecked.rs:118:44\n    |\n LL | const SHR_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n    |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shr`\n \n-error: aborting due to 40 previous errors\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:123:25\n+   |\n+LL | const _: u16 = unsafe { std::intrinsics::unchecked_add(40000u16, 30000) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         Overflow executing `unchecked_add`\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:126:25\n+   |\n+LL | const _: u32 = unsafe { std::intrinsics::unchecked_sub(14u32, 22) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         Overflow executing `unchecked_sub`\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:129:25\n+   |\n+LL | const _: u16 = unsafe { std::intrinsics::unchecked_mul(300u16, 250u16) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         Overflow executing `unchecked_mul`\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:132:25\n+   |\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(1, 0) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         dividing by zero\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:134:25\n+   |\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::min_value(), -1) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         Overflow executing `unchecked_div`\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:137:25\n+   |\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(1, 0) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         calculating the remainder with a divisor of zero\n+\n+error: any use of this value will cause an error\n+  --> $DIR/const-int-unchecked.rs:139:25\n+   |\n+LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::min_value(), -1) };\n+   | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                         |\n+   |                         Overflow executing `unchecked_rem`\n+\n+error: aborting due to 47 previous errors\n "}, {"sha": "967333c1ace4fc5a61b778019d904cd8dbba3b44", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/cd5441faf4e56d136d7c05d5eb55b4a41396edaf/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "patch": "@@ -1,11 +1,11 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n-## This script publishes the new \"current\" toolstate in the toolstate repo (not to be\n-## confused with publishing the test results, which happens in\n-## `src/ci/docker/x86_64-gnu-tools/checktools.sh`).\n-## It is set as callback for `src/ci/docker/x86_64-gnu-tools/repo.sh` by the CI scripts\n-## when a new commit lands on `master` (i.e., after it passed all checks on `auto`).\n+# This script publishes the new \"current\" toolstate in the toolstate repo (not to be\n+# confused with publishing the test results, which happens in\n+# `src/ci/docker/x86_64-gnu-tools/checktools.sh`).\n+# It is set as callback for `src/ci/docker/x86_64-gnu-tools/repo.sh` by the CI scripts\n+# when a new commit lands on `master` (i.e., after it passed all checks on `auto`).\n \n from __future__ import print_function\n \n@@ -103,6 +103,7 @@ def validate_maintainers(repo, github_token):\n         print(\"The build will fail due to this.\")\n         exit(1)\n \n+\n def read_current_status(current_commit, path):\n     '''Reads build status of `current_commit` from content of `history/*.tsv`\n     '''\n@@ -113,14 +114,17 @@ def read_current_status(current_commit, path):\n                 return json.loads(status)\n     return {}\n \n+\n def gh_url():\n     return os.environ['TOOLSTATE_ISSUES_API_URL']\n \n+\n def maybe_delink(message):\n     if os.environ.get('TOOLSTATE_SKIP_MENTIONS') is not None:\n         return message.replace(\"@\", \"\")\n     return message\n \n+\n def issue(\n     tool,\n     status,\n@@ -164,6 +168,7 @@ def issue(\n     ))\n     response.read()\n \n+\n def update_latest(\n     current_commit,\n     relevant_pr_number,\n@@ -194,7 +199,7 @@ def update_latest(\n         for status in latest:\n             tool = status['tool']\n             changed = False\n-            create_issue_for_status = None # set to the status that caused the issue\n+            create_issue_for_status = None  # set to the status that caused the issue\n \n             for os, s in current_status.items():\n                 old = status[os]"}]}