{"sha": "9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMGNmYTIzZThiM2QyZDE3MzAyZWVmZDlkNzI4ZTYzZTdjNmMxMDg=", "commit": {"author": {"name": "zslayton", "email": "zack.slayton@gmail.com", "date": "2014-03-09T06:30:27Z"}, "committer": {"name": "Zack Slayton", "email": "zslayton@us.ibm.com", "date": "2014-03-11T16:13:46Z"}, "message": "Added convenience methods and accompanying tests to the Json class.\n\nFixed some styling issues with trailing whitespace.\n\n- Removed redundant functions.\n- Renamed `get` to `find`\n- Renamed `get_path` to `find_path`\n- Renamed `find` to `search`\n- Changed as_object and as_list to return Object and List\n  rather than the underlying implementation types\n  of TreeMap<~str,Json> and ~[Json]\n- Refactored find_path to use a fold() instead of recursion\n\nFormatting fixes.\n\nFixed spacing, deleted comment.\n\nAdded convenience methods and accompanying tests to the Json class.\n\nUpdated tests to expect less pointer indirection.", "tree": {"sha": "2c6984d54f0234e53058d6232141120da72a3c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c6984d54f0234e53058d6232141120da72a3c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "html_url": "https://github.com/rust-lang/rust/commit/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108/comments", "author": {"login": "zslayton", "id": 611616, "node_id": "MDQ6VXNlcjYxMTYxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/611616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zslayton", "html_url": "https://github.com/zslayton", "followers_url": "https://api.github.com/users/zslayton/followers", "following_url": "https://api.github.com/users/zslayton/following{/other_user}", "gists_url": "https://api.github.com/users/zslayton/gists{/gist_id}", "starred_url": "https://api.github.com/users/zslayton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zslayton/subscriptions", "organizations_url": "https://api.github.com/users/zslayton/orgs", "repos_url": "https://api.github.com/users/zslayton/repos", "events_url": "https://api.github.com/users/zslayton/events{/privacy}", "received_events_url": "https://api.github.com/users/zslayton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0f20f09fde77fb7330b1a67918744149dca3318", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f20f09fde77fb7330b1a67918744149dca3318", "html_url": "https://github.com/rust-lang/rust/commit/a0f20f09fde77fb7330b1a67918744149dca3318"}], "stats": {"total": 247, "additions": 247, "deletions": 0}, "files": [{"sha": "c5d10d25838cede0a611bee63a6ac6289afa0629", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "patch": "@@ -709,6 +709,148 @@ impl Json {\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n+\n+     /// If the Json value is an Object, returns the value associated with the provided key.\n+    /// Otherwise, returns None.\n+    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n+        match self {\n+            &Object(ref map) => map.find(key),\n+            _ => None\n+        }\n+    }\n+\n+    /// Attempts to get a nested Json Object for each key in `keys`.\n+    /// If any key is found not to exist, get_path will return None.\n+    /// Otherwise, it will return the Json value associated with the final key.\n+    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n+        keys.iter().fold(Some(self), |target, key| target.map_or(None, |t| t.find(*key)))\n+    }\n+\n+    /// If the Json value is an Object, performs a depth-first search until\n+    /// a value associated with the provided key is found. If no value is found\n+    /// or the Json value is not an Object, returns None.\n+    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n+        match self {\n+            &Object(ref map) => {\n+                match map.find(key) {\n+                    Some(json_value) => Some(json_value),\n+                    None => {\n+                        let mut value : Option<&'a Json> = None;\n+                        for (_, v) in map.iter() {\n+                            value = v.search(key);\n+                            if value.is_some() {\n+                                break;\n+                            }\n+                        }\n+                        value\n+                    }\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is an Object. Returns false otherwise.\n+    pub fn is_object<'a>(&'a self) -> bool {\n+        match self {\n+            &Object(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is an Object, returns the associated TreeMap.\n+    /// Returns None otherwise.\n+    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n+        match self {\n+            &Object(ref map) => Some(&**map),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a List. Returns false otherwise.\n+    pub fn is_list<'a>(&'a self) -> bool {\n+        match self {\n+            &List(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a List, returns the associated vector.\n+    /// Returns None otherwise.\n+    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n+        match self {\n+            &List(ref list) => Some(&*list),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a String. Returns false otherwise.\n+    pub fn is_str<'a>(&'a self) -> bool {\n+        match self {\n+            &String(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a String, returns the associated str.\n+    /// Returns None otherwise.\n+    pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n+        match *self {\n+            String(ref s) => Some(s.as_slice()),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Number. Returns false otherwise.\n+    pub fn is_number(&self) -> bool {\n+        match self {\n+            &Number(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Number, returns the associated f64.\n+    /// Returns None otherwise.\n+    pub fn as_number(&self) -> Option<f64> {\n+        match self {\n+            &Number(n) => Some(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Boolean. Returns false otherwise.\n+    pub fn is_boolean(&self) -> bool {\n+        match self {\n+            &Boolean(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Boolean, returns the associated bool.\n+    /// Returns None otherwise.\n+    pub fn as_boolean(&self) -> Option<bool> {\n+        match self {\n+            &Boolean(b) => Some(b),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Null. Returns false otherwise.\n+    pub fn is_null(&self) -> bool {\n+        match self {\n+            &Null => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Null, returns ().\n+    /// Returns None otherwise.\n+    pub fn as_null(&self) -> Option<()> {\n+        match self {\n+            &Null => Some(()),\n+            _ => None\n+        }\n+    }\n }\n \n pub struct Parser<T> {\n@@ -2283,4 +2425,109 @@ mod tests {\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n                                 \"unknown variant name\");\n     }\n+\n+    #[test]\n+    fn test_find(){\n+        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n+        let found_str = json_value.find(&~\"dog\");\n+        assert!(found_str.is_some() && found_str.unwrap().as_str().unwrap() == &\"cat\");\n+    }\n+\n+    #[test]\n+    fn test_find_path(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.find_path(&[&~\"dog\", &~\"cat\", &~\"mouse\"]);\n+        assert!(found_str.is_some() && found_str.unwrap().as_str().unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_search(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.search(&~\"mouse\").and_then(|j| j.as_str());\n+        assert!(found_str.is_some());\n+        assert!(found_str.unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_is_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        assert!(json_value.is_object());\n+    }\n+\n+    #[test]\n+    fn test_as_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        let json_object = json_value.as_object();\n+        assert!(json_object.is_some());\n+    }\n+\n+    #[test]\n+    fn test_is_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        assert!(json_value.is_list());\n+    }\n+\n+    #[test]\n+    fn test_as_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        let json_list = json_value.as_list();\n+        let expected_length = 3;\n+        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n+    }\n+\n+    #[test]\n+    fn test_is_str(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        assert!(json_value.is_str());\n+    }\n+\n+    #[test]\n+    fn test_as_str(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        let json_str = json_value.as_str();\n+        let expected_str = &\"dog\";\n+        assert_eq!(json_str, Some(expected_str));\n+    }\n+\n+    #[test]\n+    fn test_is_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(json_value.is_number());\n+    }\n+\n+    #[test]\n+    fn test_as_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_number();\n+        let expected_num = 12f64;\n+        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n+    }\n+\n+    #[test]\n+    fn test_is_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        assert!(json_value.is_boolean());\n+    }\n+\n+    #[test]\n+    fn test_as_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        let json_bool = json_value.as_boolean();\n+        let expected_bool = false;\n+        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n+    }\n+\n+    #[test]\n+    fn test_is_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        assert!(json_value.is_null());\n+    }\n+\n+    #[test]\n+    fn test_as_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        let json_null = json_value.as_null();\n+        let expected_null = ();\n+        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n+    }\n }"}]}