{"sha": "5b3902fc6550f7646c4612c7ff8f4d8712f13334", "node_id": "C_kwDOAAsO6NoAKDViMzkwMmZjNjU1MGY3NjQ2YzQ2MTJjN2ZmOGY0ZDg3MTJmMTMzMzQ", "commit": {"author": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2021-12-17T00:08:30Z"}, "committer": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2021-12-17T00:08:30Z"}, "message": "attempt to make Report usable with Box dyn Error and fn main", "tree": {"sha": "a0c5cabfa29232927c91b73e0c9ad196b471e8cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0c5cabfa29232927c91b73e0c9ad196b471e8cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b3902fc6550f7646c4612c7ff8f4d8712f13334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3902fc6550f7646c4612c7ff8f4d8712f13334", "html_url": "https://github.com/rust-lang/rust/commit/5b3902fc6550f7646c4612c7ff8f4d8712f13334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b3902fc6550f7646c4612c7ff8f4d8712f13334/comments", "author": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be1cc9b6133fc8341ab605d426e675746144f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be1cc9b6133fc8341ab605d426e675746144f29", "html_url": "https://github.com/rust-lang/rust/commit/9be1cc9b6133fc8341ab605d426e675746144f29"}], "stats": {"total": 304, "additions": 201, "deletions": 103}, "files": [{"sha": "5514876c5d3b8c7127a7e550b791696fd4e583fd", "filename": "library/std/src/error.rs", "status": "modified", "additions": 201, "deletions": 103, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/5b3902fc6550f7646c4612c7ff8f4d8712f13334/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3902fc6550f7646c4612c7ff8f4d8712f13334/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=5b3902fc6550f7646c4612c7ff8f4d8712f13334", "patch": "@@ -914,106 +914,109 @@ impl dyn Error + Send + Sync {\n /// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: SuperError is here!: SuperErrorSideKick is here!', src/error.rs:34:40\n /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n /// ```\n-// /// TODO: Report doesn't yet support return from `main` gracefully, fix in followup (yaahc)\n-// /// ## Return from `main`\n-// ///\n-// /// `Report` also implements `From` for all types that implement [`Error`], this when combined with\n-// /// the `Debug` output means `Report` is an ideal starting place for formatting errors returned\n-// /// from `main`.\n-// ///\n-// /// ```\n-// /// #![feature(error_reporter)]\n-// /// use std::error::Report;\n-// /// # use std::error::Error;\n-// /// # use std::fmt;\n-// /// # #[derive(Debug)]\n-// /// # struct SuperError {\n-// /// #     source: SuperErrorSideKick,\n-// /// # }\n-// /// # impl fmt::Display for SuperError {\n-// /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-// /// #         write!(f, \"SuperError is here!\")\n-// /// #     }\n-// /// # }\n-// /// # impl Error for SuperError {\n-// /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n-// /// #         Some(&self.source)\n-// /// #     }\n-// /// # }\n-// /// # #[derive(Debug)]\n-// /// # struct SuperErrorSideKick;\n-// /// # impl fmt::Display for SuperErrorSideKick {\n-// /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-// /// #         write!(f, \"SuperErrorSideKick is here!\")\n-// /// #     }\n-// /// # }\n-// /// # impl Error for SuperErrorSideKick {}\n-// /// # fn get_super_error() -> Result<(), SuperError> {\n-// /// #     Err(SuperError { source: SuperErrorSideKick })\n-// /// # }\n-// ///\n-// /// fn main() -> Result<(), Report> {\n-// ///     get_super_error()?;\n-// /// }\n-// /// ```\n-// ///\n-// /// This example produces the following output:\n-// ///\n-// /// ```console\n-// /// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: SuperError is here!: SuperErrorSideKick is here!', src/error.rs:34:40\n-// /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-// /// ```\n-// ///\n-// /// **Note**: `Report`s constructed via `?` and `From` will be configured to use the single line\n-// /// output format, if you want to make sure your `Report`s are pretty printed and include backtrace\n-// /// you will need to manually convert and enable those flags.\n-// ///\n-// /// ```\n-// /// #![feature(error_reporter)]\n-// /// use std::error::Report;\n-// /// # use std::error::Error;\n-// /// # use std::fmt;\n-// /// # #[derive(Debug)]\n-// /// # struct SuperError {\n-// /// #     source: SuperErrorSideKick,\n-// /// # }\n-// /// # impl fmt::Display for SuperError {\n-// /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-// /// #         write!(f, \"SuperError is here!\")\n-// /// #     }\n-// /// # }\n-// /// # impl Error for SuperError {\n-// /// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n-// /// #         Some(&self.source)\n-// /// #     }\n-// /// # }\n-// /// # #[derive(Debug)]\n-// /// # struct SuperErrorSideKick;\n-// /// # impl fmt::Display for SuperErrorSideKick {\n-// /// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-// /// #         write!(f, \"SuperErrorSideKick is here!\")\n-// /// #     }\n-// /// # }\n-// /// # impl Error for SuperErrorSideKick {}\n-// /// # fn get_super_error() -> Result<(), SuperError> {\n-// /// #     Err(SuperError { source: SuperErrorSideKick })\n-// /// # }\n-// ///\n-// /// fn main() -> Result<(), Report> {\n-// ///     get_super_error()\n-// ///         .map_err(Report::new)\n-// ///         .map_err(|r| r.pretty(true).show_backtrace(true))?;\n-// /// }\n-// /// ```\n-// ///\n-// /// This example produces the following output:\n-// ///\n-// /// ```console\n-// /// thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: SuperError is here!: SuperErrorSideKick is here!', src/error.rs:34:40\n-// /// note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-// /// ```\n+///\n+/// ## Return from `main`\n+///\n+/// `Report` also implements `From` for all types that implement [`Error`], this when combined with\n+/// the `Debug` output means `Report` is an ideal starting place for formatting errors returned\n+/// from `main`.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!: SuperErrorSideKick is here!\n+/// ```\n+///\n+/// **Note**: `Report`s constructed via `?` and `From` will be configured to use the single line\n+/// output format, if you want to make sure your `Report`s are pretty printed and include backtrace\n+/// you will need to manually convert and enable those flags.\n+///\n+/// ```should_panic\n+/// #![feature(error_reporter)]\n+/// use std::error::Report;\n+/// # use std::error::Error;\n+/// # use std::fmt;\n+/// # #[derive(Debug)]\n+/// # struct SuperError {\n+/// #     source: SuperErrorSideKick,\n+/// # }\n+/// # impl fmt::Display for SuperError {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperError is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperError {\n+/// #     fn source(&self) -> Option<&(dyn Error + 'static)> {\n+/// #         Some(&self.source)\n+/// #     }\n+/// # }\n+/// # #[derive(Debug)]\n+/// # struct SuperErrorSideKick;\n+/// # impl fmt::Display for SuperErrorSideKick {\n+/// #     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+/// #         write!(f, \"SuperErrorSideKick is here!\")\n+/// #     }\n+/// # }\n+/// # impl Error for SuperErrorSideKick {}\n+/// # fn get_super_error() -> Result<(), SuperError> {\n+/// #     Err(SuperError { source: SuperErrorSideKick })\n+/// # }\n+///\n+/// fn main() -> Result<(), Report> {\n+///     get_super_error()\n+///         .map_err(Report::from)\n+///         .map_err(|r| r.pretty(true).show_backtrace(true))?;\n+///     Ok(())\n+/// }\n+/// ```\n+///\n+/// This example produces the following output:\n+///\n+/// ```console\n+/// Error: SuperError is here!\n+///\n+/// Caused by:\n+///       SuperErrorSideKick is here!\n+/// ```\n #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n-pub struct Report<E> {\n+pub struct Report<E = Box<dyn Error>> {\n     /// The error being reported.\n     error: E,\n     /// Whether a backtrace should be included as part of the report.\n@@ -1024,14 +1027,16 @@ pub struct Report<E> {\n \n impl<E> Report<E>\n where\n-    E: Error,\n+    Report<E>: From<E>,\n {\n     /// Create a new `Report` from an input error.\n     #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n     pub fn new(error: E) -> Report<E> {\n-        Report { error, show_backtrace: false, pretty: false }\n+        Self::from(error)\n     }\n+}\n \n+impl<E> Report<E> {\n     /// Enable pretty-printing the report across multiple lines.\n     ///\n     /// # Examples\n@@ -1232,7 +1237,81 @@ where\n         self.show_backtrace = show_backtrace;\n         self\n     }\n+}\n+\n+impl<E> Report<E>\n+where\n+    E: Error,\n+{\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        // have to grab the backtrace on the first error directly since that error may not be\n+        // 'static\n+        let backtrace = self.error.backtrace();\n+        let backtrace = backtrace.or_else(|| {\n+            self.error\n+                .source()\n+                .map(|source| source.chain().find_map(|source| source.backtrace()))\n+                .flatten()\n+        });\n+        backtrace\n+    }\n+\n+    /// Format the report as a single line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.error)?;\n+\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+\n+        for cause in sources {\n+            write!(f, \": {}\", cause)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Format the report as multiple lines, with each error cause on its own line.\n+    #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+    fn fmt_multiline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let error = &self.error;\n+\n+        write!(f, \"{}\", error)?;\n+\n+        if let Some(cause) = error.source() {\n+            write!(f, \"\\n\\nCaused by:\")?;\n+\n+            let multiple = cause.source().is_some();\n+\n+            for (ind, error) in cause.chain().enumerate() {\n+                writeln!(f)?;\n+                let mut indented = Indented {\n+                    inner: f,\n+                };\n+                if multiple {\n+                    write!(indented, \"{: >4}: {}\", ind, error)?;\n+                } else {\n+                    write!(indented, \"      {}\", error)?;\n+                }\n+            }\n+        }\n+\n+        if self.show_backtrace {\n+            let backtrace = self.backtrace();\n+\n+            if let Some(backtrace) = backtrace {\n+                let backtrace = backtrace.to_string();\n+\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n \n+impl Report<Box<dyn Error>>\n+{\n     fn backtrace(&self) -> Option<&Backtrace> {\n         // have to grab the backtrace on the first error directly since that error may not be\n         // 'static\n@@ -1306,7 +1385,18 @@ where\n     E: Error,\n {\n     fn from(error: E) -> Self {\n-        Report::new(error)\n+        Report { error, show_backtrace: false, pretty: false }\n+    }\n+}\n+\n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl<'a, E> From<E> for Report<Box<dyn Error + 'a>>\n+where\n+    E: Error + 'a,\n+{\n+    fn from(error: E) -> Self {\n+        let error = box error;\n+        Report { error, show_backtrace: false, pretty: false }\n     }\n }\n \n@@ -1320,12 +1410,20 @@ where\n     }\n }\n \n+#[unstable(feature = \"error_reporter\", issue = \"90172\")]\n+impl fmt::Display for Report<Box<dyn Error>>\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.pretty { self.fmt_multiline(f) } else { self.fmt_singleline(f) }\n+    }\n+}\n+\n // This type intentionally outputs the same format for `Display` and `Debug`for\n // situations where you unwrap a `Report` or return it from main.\n #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n impl<E> fmt::Debug for Report<E>\n where\n-    E: Error,\n+    Report<E>: fmt::Display,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)"}]}