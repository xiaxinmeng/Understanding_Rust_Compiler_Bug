{"sha": "c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f", "node_id": "C_kwDOAAsO6NoAKGMzZGRkNTlmNWIwZWQzMWM4M2E0NDIxZmRiZGZiNzNkYjhiYTM3OGY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-05-06T18:05:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-06T18:05:40Z"}, "message": "Rollup merge of #96733 - SparrowLii:place_to_string, r=davidtwco\n\nturn `append_place_to_string` from recursion into iteration\n\nThis PR fixes the FIXME in the impl of `append_place_to_string` which turns `append_place_to_string` from recursion into iteration, meanwhile simplifying the code relatively.", "tree": {"sha": "2a4758a2796efea3fbef08838752480e91ca368a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a4758a2796efea3fbef08838752480e91ca368a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJidWN0CRBK7hj4Ov3rIwAAD/cIAI+BSLrthkvxgcl0b+nGuzlA\nsqkqvKyt0XfEz9ADIw5eKCKGLmow1kCiOTwhaW56AeW3YQlhLxq9KDBjtrKo2onD\necM92zucx0Jiz24xi4hRclJBGgm0yboE3WGbGzEM2R8wNyKP1cF+j6wXwOOdwtRH\nrrj8DdyLt9MP1Bnsor1dA5V/WHzEV0SwxOSFKmHVwcc7kli8zm8L5rrIQtdow3zK\nkfIurqN9EvVgjV5aycPb+ZuFEfp0XxF56z3ydc6jDASHKqnrpdxazS6D5TELE+Yy\nyAZTLg52N9PUjExzNzpPqaQtRIhhppFA5TU5qNTYH6YWLTCJe0FLpxAL2f2L2Ao=\n=SwqE\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a4758a2796efea3fbef08838752480e91ca368a\nparent c7af4e67c34061ea0713e6aca46d09840b71993b\nparent 8ff01894a010690b9c7232d1217931dbc5d63333\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1651860340 +0200\ncommitter GitHub <noreply@github.com> 1651860340 +0200\n\nRollup merge of #96733 - SparrowLii:place_to_string, r=davidtwco\n\nturn `append_place_to_string` from recursion into iteration\n\nThis PR fixes the FIXME in the impl of `append_place_to_string` which turns `append_place_to_string` from recursion into iteration, meanwhile simplifying the code relatively.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f", "html_url": "https://github.com/rust-lang/rust/commit/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7af4e67c34061ea0713e6aca46d09840b71993b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7af4e67c34061ea0713e6aca46d09840b71993b", "html_url": "https://github.com/rust-lang/rust/commit/c7af4e67c34061ea0713e6aca46d09840b71993b"}, {"sha": "8ff01894a010690b9c7232d1217931dbc5d63333", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff01894a010690b9c7232d1217931dbc5d63333", "html_url": "https://github.com/rust-lang/rust/commit/8ff01894a010690b9c7232d1217931dbc5d63333"}], "stats": {"total": 210, "additions": 78, "deletions": 132}, "files": [{"sha": "05d29503180ef73a6b9aacdfb97a931f92f1d8db", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 78, "deletions": 132, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c3ddd59f5b0ed31c83a4421fdbdfb73db8ba378f", "patch": "@@ -1,5 +1,6 @@\n //! Borrow checker diagnostics.\n \n+use itertools::Itertools;\n use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -161,158 +162,103 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of `place` if one can be found.\n-    /// If the place is a temporary for instance, None will be returned.\n+    /// If the place is a temporary for instance, `None` will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }\n \n-    /// End-user visible description of `place` if one can be found. If the\n-    /// place is a temporary for instance, None will be returned.\n-    /// `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n+    /// End-user visible description of `place` if one can be found. If the place is a temporary\n+    /// for instance, `None` will be returned.\n+    /// `IncludingDowncast` parameter makes the function return `None` if `ProjectionElem` is\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n         place: PlaceRef<'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n+        let local = place.local;\n+        let mut autoderef_index = None;\n         let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false, &including_downcast) {\n-            Ok(()) => Some(buf),\n-            Err(()) => None,\n-        }\n-    }\n-\n-    /// Appends end-user visible description of `place` to `buf`.\n-    fn append_place_to_string(\n-        &self,\n-        place: PlaceRef<'tcx>,\n-        buf: &mut String,\n-        mut autoderef: bool,\n-        including_downcast: &IncludingDowncast,\n-    ) -> Result<(), ()> {\n-        match place {\n-            PlaceRef { local, projection: [] } => {\n-                self.append_local_to_string(local, buf)?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_for_guard() =>\n-            {\n-                self.append_place_to_string(\n-                    PlaceRef { local, projection: &[] },\n-                    buf,\n-                    autoderef,\n-                    &including_downcast,\n-                )?;\n-            }\n-            PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[local].is_ref_to_static() =>\n-            {\n-                let local_info = &self.body.local_decls[local].local_info;\n-                if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n-                    buf.push_str(self.infcx.tcx.item_name(def_id).as_str());\n-                } else {\n-                    unreachable!();\n-                }\n-            }\n-            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n-                match elem {\n-                    ProjectionElem::Deref => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            if self.upvars[var_index].by_ref {\n-                                buf.push_str(&name);\n-                            } else {\n-                                buf.push('*');\n-                                buf.push_str(&name);\n-                            }\n-                        } else {\n-                            if autoderef {\n-                                // FIXME turn this recursion into iteration\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            } else {\n-                                buf.push('*');\n-                                self.append_place_to_string(\n-                                    PlaceRef { local, projection: proj_base },\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n-                            }\n+        let mut ok = self.append_local_to_string(local, &mut buf);\n+\n+        for (index, elem) in place.projection.into_iter().enumerate() {\n+            match elem {\n+                ProjectionElem::Deref => {\n+                    if index == 0 {\n+                        if self.body.local_decls[local].is_ref_for_guard() {\n+                            continue;\n                         }\n-                    }\n-                    ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        if including_downcast.0 {\n-                            return Err(());\n+                        if let Some(box LocalInfo::StaticRef { def_id, .. }) =\n+                            &self.body.local_decls[local].local_info\n+                        {\n+                            buf.push_str(self.infcx.tcx.item_name(*def_id).as_str());\n+                            ok = Ok(());\n+                            continue;\n                         }\n                     }\n-                    ProjectionElem::Field(field, _ty) => {\n-                        autoderef = true;\n-\n-                        // FIXME(project-rfc_2229#36): print capture precisely here.\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n-                        if let Some(field) = upvar_field_projection {\n-                            let var_index = field.index();\n-                            let name = self.upvars[var_index].place.to_string(self.infcx.tcx);\n-                            buf.push_str(&name);\n-                        } else {\n-                            let field_name = self\n-                                .describe_field(PlaceRef { local, projection: proj_base }, *field);\n-                            self.append_place_to_string(\n-                                PlaceRef { local, projection: proj_base },\n-                                buf,\n-                                autoderef,\n-                                &including_downcast,\n-                            )?;\n-                            buf.push('.');\n-                            buf.push_str(&field_name);\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        let var_index = field.index();\n+                        buf = self.upvars[var_index].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                        if !self.upvars[var_index].by_ref {\n+                            buf.insert(0, '*');\n                         }\n-                    }\n-                    ProjectionElem::Index(index) => {\n-                        autoderef = true;\n-\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push('[');\n-                        if self.append_local_to_string(*index, buf).is_err() {\n-                            buf.push('_');\n+                    } else {\n+                        if autoderef_index.is_none() {\n+                            autoderef_index =\n+                                match place.projection.into_iter().rev().find_position(|elem| {\n+                                    !matches!(\n+                                        elem,\n+                                        ProjectionElem::Deref | ProjectionElem::Downcast(..)\n+                                    )\n+                                }) {\n+                                    Some((index, _)) => Some(place.projection.len() - index),\n+                                    None => Some(0),\n+                                };\n+                        }\n+                        if index >= autoderef_index.unwrap() {\n+                            buf.insert(0, '*');\n                         }\n-                        buf.push(']');\n                     }\n-                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n-                        autoderef = true;\n-                        // Since it isn't possible to borrow an element on a particular index and\n-                        // then use another while the borrow is held, don't output indices details\n-                        // to avoid confusing the end-user\n-                        self.append_place_to_string(\n-                            PlaceRef { local, projection: proj_base },\n-                            buf,\n-                            autoderef,\n-                            &including_downcast,\n-                        )?;\n-                        buf.push_str(\"[..]\");\n+                }\n+                ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n+                ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::Field(field, _ty) => {\n+                    // FIXME(project-rfc_2229#36): print capture precisely here.\n+                    if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                        local,\n+                        projection: place.projection.split_at(index + 1).0,\n+                    }) {\n+                        buf = self.upvars[field.index()].place.to_string(self.infcx.tcx);\n+                        ok = Ok(());\n+                    } else {\n+                        let field_name = self.describe_field(\n+                            PlaceRef { local, projection: place.projection.split_at(index).0 },\n+                            *field,\n+                        );\n+                        buf.push('.');\n+                        buf.push_str(&field_name);\n                     }\n-                };\n+                }\n+                ProjectionElem::Index(index) => {\n+                    buf.push('[');\n+                    if self.append_local_to_string(*index, &mut buf).is_err() {\n+                        buf.push('_');\n+                    }\n+                    buf.push(']');\n+                }\n+                ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                    // Since it isn't possible to borrow an element on a particular index and\n+                    // then use another while the borrow is held, don't output indices details\n+                    // to avoid confusing the end-user\n+                    buf.push_str(\"[..]\");\n+                }\n             }\n         }\n-\n-        Ok(())\n+        ok.ok().map(|_| buf)\n     }\n \n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have"}]}