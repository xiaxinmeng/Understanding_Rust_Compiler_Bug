{"sha": "2fba2fea121b616793287f33aa3ee05e8d8893b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYmEyZmVhMTIxYjYxNjc5MzI4N2YzM2FhM2VlMDVlOGQ4ODkzYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-06T08:41:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-06T08:41:48Z"}, "message": "auto merge of #12705 : alexcrichton/rust/issue-12692, r=brson\n\nDetails are in the commit messages, but this closes a few issues seen with `libnative` recently.", "tree": {"sha": "7b6d2bd1a7449d81b9b6acb7c1099eca91df414d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6d2bd1a7449d81b9b6acb7c1099eca91df414d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fba2fea121b616793287f33aa3ee05e8d8893b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fba2fea121b616793287f33aa3ee05e8d8893b0", "html_url": "https://github.com/rust-lang/rust/commit/2fba2fea121b616793287f33aa3ee05e8d8893b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fba2fea121b616793287f33aa3ee05e8d8893b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2153293ae434861c72469d41fc7c9dfe9b90b1c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2153293ae434861c72469d41fc7c9dfe9b90b1c4", "html_url": "https://github.com/rust-lang/rust/commit/2153293ae434861c72469d41fc7c9dfe9b90b1c4"}, {"sha": "9668ab58f338b27d8f53357c7fd4ea3d3f06305e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9668ab58f338b27d8f53357c7fd4ea3d3f06305e", "html_url": "https://github.com/rust-lang/rust/commit/9668ab58f338b27d8f53357c7fd4ea3d3f06305e"}], "stats": {"total": 181, "additions": 136, "deletions": 45}, "files": [{"sha": "cf9ada97a3254a28ae0d7658ad6c1938f7c462c5", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -19,6 +19,7 @@ use std::libc;\n use std::mem;\n use std::rt::rtio;\n use std::vec;\n+use std::vec_ng::Vec;\n \n use io::{IoResult, retry, keep_going};\n \n@@ -341,7 +342,7 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n \n pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     use std::libc::{dirent_t};\n-    use std::libc::{opendir, readdir, closedir};\n+    use std::libc::{opendir, readdir_r, closedir};\n \n     fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n@@ -353,23 +354,28 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     }\n \n     extern {\n-        fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+        fn rust_dirent_t_size() -> libc::c_int;\n+        fn rust_list_dir_val(ptr: *mut dirent_t) -> *libc::c_char;\n     }\n \n+    let size = unsafe { rust_dirent_t_size() };\n+    let mut buf = Vec::<u8>::with_capacity(size as uint);\n+    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n+\n     debug!(\"os::list_dir -- BEFORE OPENDIR\");\n \n     let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n \n     if dir_ptr as uint != 0 {\n         let mut paths = ~[];\n         debug!(\"os::list_dir -- opendir() SUCCESS\");\n-        let mut entry_ptr = unsafe { readdir(dir_ptr) };\n-        while entry_ptr as uint != 0 {\n+        let mut entry_ptr = 0 as *mut dirent_t;\n+        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n+            if entry_ptr.is_null() { break }\n             let cstr = unsafe {\n                 CString::new(rust_list_dir_val(entry_ptr), false)\n             };\n             paths.push(Path::new(cstr));\n-            entry_ptr = unsafe { readdir(dir_ptr) };\n         }\n         assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n         Ok(prune(p, paths))"}, {"sha": "62e41771423d46d0ba61f8888f7bef53af6f29cc", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -21,10 +21,10 @@\n //! time.\n \n use std::cast;\n+use std::rt::bookkeeping;\n use std::rt;\n use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-use bookkeeping;\n use io::timer::{Req, Shutdown};\n use task;\n \n@@ -36,6 +36,8 @@ use task;\n static mut HELPER_CHAN: *mut Chan<Req> = 0 as *mut Chan<Req>;\n static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n \n+static mut TIMER_HELPER_EXIT: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+\n pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n     static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     static mut INITIALIZED: bool = false;\n@@ -53,6 +55,7 @@ pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n             task::spawn(proc() {\n                 bookkeeping::decrement();\n                 helper(receive, msgp);\n+                TIMER_HELPER_EXIT.lock().signal()\n             });\n \n             rt::at_exit(proc() { shutdown() });\n@@ -70,17 +73,15 @@ pub fn send(req: Req) {\n }\n \n fn shutdown() {\n-    // We want to wait for the entire helper task to exit, and in doing so it\n-    // will attempt to decrement the global task count. When the helper was\n-    // created, it decremented the count so it wouldn't count towards preventing\n-    // the program to exit, so here we pair that manual decrement with a manual\n-    // increment. We will then wait for the helper thread to exit by calling\n-    // wait_for_other_tasks.\n-    bookkeeping::increment();\n-\n     // Request a shutdown, and then wait for the task to exit\n-    send(Shutdown);\n-    bookkeeping::wait_for_other_tasks();\n+    unsafe {\n+        let mut guard = TIMER_HELPER_EXIT.lock();\n+        send(Shutdown);\n+        guard.wait();\n+        drop(guard);\n+        TIMER_HELPER_EXIT.destroy();\n+    }\n+\n \n     // Clean up after ther helper thread\n     unsafe {"}, {"sha": "d7323ddf4995531e1f8606240ffbaa75f9c4cf7e", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -218,8 +218,15 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        // FIXME: this can fail because of EINTR, what do do?\n-        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n+        let mut to_sleep = libc::timespec {\n+            tv_sec: (ms / 1000) as libc::time_t,\n+            tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n+        };\n+        while unsafe { libc::nanosleep(&to_sleep, &mut to_sleep) } != 0 {\n+            if os::errno() as int != libc::EINTR as int {\n+                fail!(\"failed to sleep, but not because of EINTR?\");\n+            }\n+        }\n     }\n \n     fn inner(&mut self) -> ~Inner {"}, {"sha": "55301b6f7c8d66d29927b4e7dbca6d7283f1ca2d", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -23,8 +23,8 @@\n //! why).\n //!\n //! As with timer_other, timers just using sleep() do not use the timerfd at\n-//! all. They remove the timerfd from the worker thread and then invoke usleep()\n-//! to block the calling thread.\n+//! all. They remove the timerfd from the worker thread and then invoke\n+//! nanosleep() to block the calling thread.\n //!\n //! As with timer_other, all units in this file are in units of millseconds.\n \n@@ -183,8 +183,15 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        // FIXME: this can fail because of EINTR, what do do?\n-        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n+        let mut to_sleep = libc::timespec {\n+            tv_sec: (ms / 1000) as libc::time_t,\n+            tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n+        };\n+        while unsafe { libc::nanosleep(&to_sleep, &mut to_sleep) } != 0 {\n+            if os::errno() as int != libc::EINTR as int {\n+                fail!(\"failed to sleep, but not because of EINTR?\");\n+            }\n+        }\n     }\n \n     fn remove(&mut self) {"}, {"sha": "4b6942a1083163dcd0cdf9da9cd9e2d802c4b12b", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -58,7 +58,6 @@\n use std::os;\n use std::rt;\n \n-mod bookkeeping;\n pub mod io;\n pub mod task;\n \n@@ -105,6 +104,5 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n /// number of arguments.\n pub fn run(main: proc()) -> int {\n     main();\n-    bookkeeping::wait_for_other_tasks();\n     os::get_exit_status()\n }"}, {"sha": "793e4d48e13de22a5cb486b6bb414ed33f0056fb", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -16,19 +16,19 @@\n \n use std::any::Any;\n use std::cast;\n+use std::rt::bookkeeping;\n use std::rt::env;\n use std::rt::local::Local;\n use std::rt::rtio;\n+use std::rt::stack;\n use std::rt::task::{Task, BlockedTask, SendMessage};\n use std::rt::thread::Thread;\n use std::rt;\n use std::task::TaskOpts;\n use std::unstable::mutex::NativeMutex;\n-use std::rt::stack;\n \n use io;\n use task;\n-use bookkeeping;\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n pub fn new(stack_bounds: (uint, uint)) -> ~Task {"}, {"sha": "afd524e9d7afe38d0ad1508f9ac1000187a5dee5", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -3658,13 +3658,16 @@ pub mod funcs {\n             pub unsafe fn opendir(dirname: *c_char) -> *DIR {\n                 rust_opendir(dirname)\n             }\n-            pub unsafe fn readdir(dirp: *DIR) -> *dirent_t {\n-                rust_readdir(dirp)\n+            pub unsafe fn readdir_r(dirp: *DIR,\n+                                    entry: *mut dirent_t,\n+                                    result: *mut *mut dirent_t) -> c_int {\n+                rust_readdir_r(dirp, entry, result)\n             }\n \n             extern {\n                 fn rust_opendir(dirname: *c_char) -> *DIR;\n-                fn rust_readdir(dirp: *DIR) -> *dirent_t;\n+                fn rust_readdir_r(dirp: *DIR, entry: *mut dirent_t,\n+                                  result: *mut *mut dirent_t) -> c_int;\n             }\n \n             extern {\n@@ -3680,6 +3683,7 @@ pub mod funcs {\n             use libc::types::common::c95::c_void;\n             use libc::types::os::arch::c95::{c_char, c_int, c_long, c_uint};\n             use libc::types::os::arch::c95::{size_t};\n+            use libc::types::os::common::posix01::timespec;\n             use libc::types::os::arch::posix01::utimbuf;\n             use libc::types::os::arch::posix88::{gid_t, off_t, pid_t};\n             use libc::types::os::arch::posix88::{ssize_t, uid_t};\n@@ -3729,6 +3733,7 @@ pub mod funcs {\n                 pub fn setuid(uid: uid_t) -> c_int;\n                 pub fn sleep(secs: c_uint) -> c_uint;\n                 pub fn usleep(secs: c_uint) -> c_int;\n+                pub fn nanosleep(rqtp: *timespec, rmtp: *mut timespec) -> c_int;\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n                 pub fn ttyname(fd: c_int) -> *c_char;"}, {"sha": "5851a6a39c640fde161d35ff6e52da37bfa6609d", "filename": "src/libstd/rt/bookkeeping.rs", "status": "renamed", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Frt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Frt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbookkeeping.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -8,16 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! 1:1 Task bookkeeping\n+//! Task bookkeeping\n //!\n-//! This module keeps track of the number of running 1:1 tasks so that entry\n-//! points with libnative know when it's possible to exit the program (once all\n-//! tasks have exited).\n+//! This module keeps track of the number of running tasks so that entry points\n+//! with libnative know when it's possible to exit the program (once all tasks\n+//! have exited).\n //!\n-//! The green counterpart for this is bookkeeping on sched pools.\n+//! The green counterpart for this is bookkeeping on sched pools, and it's up to\n+//! each respective runtime to make sure that they call increment() and\n+//! decrement() manually.\n \n-use std::sync::atomics;\n-use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+#[experimental]; // this is a massive code smell\n+#[doc(hidden)];\n+\n+use sync::atomics;\n+use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -39,12 +44,9 @@ pub fn decrement() {\n /// the entry points of native programs\n pub fn wait_for_other_tasks() {\n     unsafe {\n-        {\n-            let mut guard = TASK_LOCK.lock();\n-            while TASK_COUNT.load(atomics::SeqCst) > 0 {\n-                guard.wait();\n-            }\n+        let mut guard = TASK_LOCK.lock();\n+        while TASK_COUNT.load(atomics::SeqCst) > 0 {\n+            guard.wait();\n         }\n-        TASK_LOCK.destroy();\n     }\n }", "previous_filename": "src/libnative/bookkeeping.rs"}, {"sha": "459bc061c569d175a499a6e235155955547b938a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -128,6 +128,9 @@ pub mod args;\n // Support for running procedures when a program has exited.\n mod at_exit_imp;\n \n+// Bookkeeping for task counts\n+pub mod bookkeeping;\n+\n // Stack overflow protection\n pub mod stack;\n \n@@ -207,6 +210,7 @@ pub fn at_exit(f: proc()) {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n+    bookkeeping::wait_for_other_tasks();\n     at_exit_imp::run();\n     args::cleanup();\n     local_ptr::cleanup();"}, {"sha": "6ba121c5d2d04be07e1f83e5320c1ff7b8c80128", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -279,9 +279,14 @@ rust_opendir(char *dirname) {\n     return opendir(dirname);\n }\n \n-struct dirent*\n-rust_readdir(DIR *dirp) {\n-    return readdir(dirp);\n+int\n+rust_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result) {\n+    return readdir_r(dirp, entry, result);\n+}\n+\n+int\n+rust_dirent_t_size() {\n+    return sizeof(struct dirent);\n }\n \n #else\n@@ -294,6 +299,10 @@ void\n rust_readdir() {\n }\n \n+void\n+rust_dirent_t_size() {\n+}\n+\n #endif\n \n uintptr_t"}, {"sha": "a6eef4e20215fd108885ec79739ab7809706d8b9", "filename": "src/test/run-pass/issue-12684.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+extern crate native;\n+extern crate green;\n+extern crate rustuv;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+\n+fn main() {\n+    native::task::spawn(proc() customtask());\n+}\n+\n+fn customtask() {\n+    let mut timer = std::io::timer::Timer::new().unwrap();\n+    let periodic = timer.periodic(10);\n+    periodic.recv();\n+}"}, {"sha": "6409ba5137584841e56a827d4f931dfad49d0069", "filename": "src/test/run-pass/issue-12699.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fba2fea121b616793287f33aa3ee05e8d8893b0/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=2fba2fea121b616793287f33aa3ee05e8d8893b0", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+extern crate native;\n+\n+use std::io::timer;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    native::start(argc, argv, main)\n+}\n+\n+fn main() {\n+    timer::sleep(250);\n+}"}]}