{"sha": "37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Nzk1YmFmNWYxYjJlMmI1YjlhYThjNTAyYTQ0MDE3ZDc5NWJmMDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-13T16:38:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-14T01:22:07Z"}, "message": "simplify HIR folder so that it only maps 1 item to 1 item,\nremoving a bunch of asserts", "tree": {"sha": "56952ffed08d55c74c3df30ad97abb2796a82843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56952ffed08d55c74c3df30ad97abb2796a82843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "html_url": "https://github.com/rust-lang/rust/commit/37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9c9513cf18e39715d6b58ce1912dc1c4dfc206", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9c9513cf18e39715d6b58ce1912dc1c4dfc206", "html_url": "https://github.com/rust-lang/rust/commit/8c9c9513cf18e39715d6b58ce1912dc1c4dfc206"}], "stats": {"total": 232, "additions": 95, "deletions": 137}, "files": [{"sha": "11f0fd1bb2c5efb39c4ba149759bb7a02c05f66e", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "patch": "@@ -847,14 +847,14 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n-        II::Item(i) => II::Item(fld.fold_item(i).expect_one(\"expected one item\")),\n+        II::Item(i) => II::Item(fld.fold_item(i)),\n         II::TraitItem(d, ti) => {\n             II::TraitItem(fld.fold_ops.new_def_id(d),\n-                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+                          fld.fold_trait_item(ti))\n         }\n         II::ImplItem(d, ii) => {\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n-                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+                         fld.fold_impl_item(ii))\n         }\n         II::Foreign(i) => II::Foreign(fld.fold_foreign_item(i))\n     };"}, {"sha": "a92fe1a0f2b5bcf7b3488abd13455b364dc17656", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "patch": "@@ -389,20 +389,13 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n     match ii {\n         // HACK we're not dropping items.\n         InlinedItemRef::Item(i) => {\n-            InlinedItem::Item(fold::noop_fold_item(P(i.clone()), &mut fld)\n-                            .expect_one(\"expected one item\"))\n+            InlinedItem::Item(fold::noop_fold_item(P(i.clone()), &mut fld))\n         }\n         InlinedItemRef::TraitItem(d, ti) => {\n-            InlinedItem::TraitItem(d,\n-                fold::noop_fold_trait_item(P(ti.clone()), &mut fld)\n-                    .expect_one(\"noop_fold_trait_item must produce \\\n-                                 exactly one trait item\"))\n+            InlinedItem::TraitItem(d, fold::noop_fold_trait_item(P(ti.clone()), &mut fld))\n         }\n         InlinedItemRef::ImplItem(d, ii) => {\n-            InlinedItem::ImplItem(d,\n-                fold::noop_fold_impl_item(P(ii.clone()), &mut fld)\n-                    .expect_one(\"noop_fold_impl_item must produce \\\n-                                 exactly one impl item\"))\n+            InlinedItem::ImplItem(d, fold::noop_fold_impl_item(P(ii.clone()), &mut fld))\n         }\n         InlinedItemRef::Foreign(i) => {\n             InlinedItem::Foreign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))"}, {"sha": "955de44b43f6e8710766fd68a67b3d883fd50623", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 89, "deletions": 124, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37795baf5f1b2e2b5b9aa8c502a44017d795bf07/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=37795baf5f1b2e2b5b9aa8c502a44017d795bf07", "patch": "@@ -20,8 +20,6 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::ptr;\n-use syntax::util::small_vector::SmallVector;\n-\n \n // This could have a better place to live.\n pub trait MoveMap<T> {\n@@ -79,14 +77,10 @@ pub trait Folder : Sized {\n         noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> {\n+    fn fold_item(&mut self, i: P<Item>) -> P<Item> {\n         noop_fold_item(i, self)\n     }\n \n-    fn fold_item_simple(&mut self, i: Item) -> Item {\n-        noop_fold_item_simple(i, self)\n-    }\n-\n     fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n@@ -95,11 +89,11 @@ pub trait Folder : Sized {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n+    fn fold_trait_item(&mut self, i: P<TraitItem>) -> P<TraitItem> {\n         noop_fold_trait_item(i, self)\n     }\n \n-    fn fold_impl_item(&mut self, i: P<ImplItem>) -> SmallVector<P<ImplItem>> {\n+    fn fold_impl_item(&mut self, i: P<ImplItem>) -> P<ImplItem> {\n         noop_fold_impl_item(i, self)\n     }\n \n@@ -111,8 +105,8 @@ pub trait Folder : Sized {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: P<Stmt>) -> SmallVector<P<Stmt>> {\n-        s.and_then(|s| noop_fold_stmt(s, self))\n+    fn fold_stmt(&mut self, s: P<Stmt>) -> P<Stmt> {\n+        noop_fold_stmt(s, self)\n     }\n \n     fn fold_arm(&mut self, a: Arm) -> Arm {\n@@ -123,7 +117,7 @@ pub trait Folder : Sized {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n+    fn fold_decl(&mut self, d: P<Decl>) -> P<Decl> {\n         noop_fold_decl(d, self)\n     }\n \n@@ -340,22 +334,17 @@ pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n-    d.and_then(|Spanned { node, span }| {\n+pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n+    d.map(|Spanned { node, span }| {\n         match node {\n-            DeclLocal(l) => SmallVector::one(P(Spanned {\n+            DeclLocal(l) => Spanned {\n                 node: DeclLocal(fld.fold_local(l)),\n                 span: fld.new_span(span),\n-            })),\n-            DeclItem(it) => fld.fold_item(it)\n-                               .into_iter()\n-                               .map(|i| {\n-                                   P(Spanned {\n-                                       node: DeclItem(i),\n-                                       span: fld.new_span(span),\n-                                   })\n-                               })\n-                               .collect(),\n+            },\n+            DeclItem(it) => Spanned {\n+                node: DeclItem(fld.fold_item(it)),\n+                span: fld.new_span(span),\n+            },\n         }\n     })\n }\n@@ -771,7 +760,7 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block { id, stmts, expr, rules, span }| {\n         Block {\n             id: folder.new_id(id),\n-            stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n+            stmts: stmts.into_iter().map(|s| folder.fold_stmt(s)).collect(),\n             expr: expr.map(|x| folder.fold_expr(x)),\n             rules: rules,\n             span: folder.new_span(span),\n@@ -819,9 +808,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n             let new_impl_items = impl_items.into_iter()\n-                                           .flat_map(|item| {\n-                                               folder.fold_impl_item(item).into_iter()\n-                                           })\n+                                           .map(|item| folder.fold_impl_item(item))\n                                            .collect();\n             let ifce = match ifce {\n                 None => None,\n@@ -839,7 +826,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         ItemTrait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n             let items = items.into_iter()\n-                             .flat_map(|item| folder.fold_trait_item(item).into_iter())\n+                             .map(|item| folder.fold_trait_item(item))\n                              .collect();\n             ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n         }\n@@ -848,8 +835,8 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n \n pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>,\n                                        folder: &mut T)\n-                                       -> SmallVector<P<TraitItem>> {\n-    SmallVector::one(i.map(|TraitItem { id, name, attrs, node, span }| {\n+                                       -> P<TraitItem> {\n+    i.map(|TraitItem { id, name, attrs, node, span }| {\n         TraitItem {\n             id: folder.new_id(id),\n             name: folder.fold_name(name),\n@@ -869,11 +856,11 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>,\n             },\n             span: folder.new_span(span),\n         }\n-    }))\n+    })\n }\n \n-pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> SmallVector<P<ImplItem>> {\n-    SmallVector::one(i.map(|ImplItem { id, name, attrs, node, vis, span }| {\n+pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> P<ImplItem> {\n+    i.map(|ImplItem { id, name, attrs, node, vis, span }| {\n         ImplItem {\n             id: folder.new_id(id),\n             name: folder.fold_name(name),\n@@ -890,13 +877,13 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> SmallVe\n             },\n             span: folder.new_span(span),\n         }\n-    }))\n+    })\n }\n \n pub fn noop_fold_mod<T: Folder>(Mod { inner, items }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n+        items: items.into_iter().map(|x| folder.fold_item(x)).collect(),\n     }\n }\n \n@@ -905,34 +892,22 @@ pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span, exported_\n                                   -> Crate {\n     let config = folder.fold_meta_items(config);\n \n-    let mut items = folder.fold_item(P(hir::Item {\n-                              name: token::special_idents::invalid.name,\n-                              attrs: attrs,\n-                              id: DUMMY_NODE_ID,\n-                              vis: hir::Public,\n-                              span: span,\n-                              node: hir::ItemMod(module),\n-                          }))\n-                          .into_iter();\n-\n-    let (module, attrs, span) = match items.next() {\n-        Some(item) => {\n-            assert!(items.next().is_none(),\n-                    \"a crate cannot expand to more than one item\");\n-            item.and_then(|hir::Item { attrs, span, node, .. }| {\n-                match node {\n-                    hir::ItemMod(m) => (m, attrs, span),\n-                    _ => panic!(\"fold converted a module to not a module\"),\n-                }\n-            })\n-        }\n-        None => (hir::Mod {\n-            inner: span,\n-            items: vec![],\n-        },\n-                 vec![],\n-                 span),\n-    };\n+    let crate_mod = folder.fold_item(P(hir::Item {\n+        name: token::special_idents::invalid.name,\n+        attrs: attrs,\n+        id: DUMMY_NODE_ID,\n+        vis: hir::Public,\n+        span: span,\n+        node: hir::ItemMod(module),\n+    }));\n+\n+    let (module, attrs, span) =\n+        crate_mod.and_then(|hir::Item { attrs, span, node, .. }| {\n+            match node {\n+                hir::ItemMod(m) => (m, attrs, span),\n+                _ => panic!(\"fold converted a module to not a module\"),\n+            }\n+        });\n \n     Crate {\n         module: module,\n@@ -943,34 +918,28 @@ pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span, exported_\n     }\n }\n \n-// fold one item into possibly many items\n-pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<Item>> {\n-    SmallVector::one(i.map(|i| folder.fold_item_simple(i)))\n-}\n-\n-// fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item { id, name, attrs, node, vis, span }: Item,\n-                                        folder: &mut T)\n-                                        -> Item {\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n-    // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n-    // let ident = match node {\n-    //     // The node may have changed, recompute the \"pretty\" impl name.\n-    //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n-    //         impl_pretty_name(maybe_trait, Some(&**ty))\n-    //     }\n-    //     _ => ident\n-    // };\n-\n-    Item {\n-        id: id,\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: vis,\n-        span: folder.new_span(span),\n-    }\n+pub fn noop_fold_item<T: Folder>(item: P<Item>, folder: &mut T) -> P<Item> {\n+    item.map(|Item { id, name, attrs, node, vis, span }| {\n+        let id = folder.new_id(id);\n+        let node = folder.fold_item_underscore(node);\n+        // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n+        // let ident = match node {\n+        //     // The node may have changed, recompute the \"pretty\" impl name.\n+        //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+        //         impl_pretty_name(maybe_trait, Some(&**ty))\n+        //     }\n+        //     _ => ident\n+        // };\n+\n+        Item {\n+            id: id,\n+            name: folder.fold_name(name),\n+            attrs: fold_attrs(attrs, folder),\n+            node: node,\n+            vis: vis,\n+            span: folder.new_span(span),\n+        }\n+    })\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n@@ -1184,36 +1153,32 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Spanned { node, span }: Stmt,\n-                                 folder: &mut T)\n-                                 -> SmallVector<P<Stmt>> {\n-    let span = folder.new_span(span);\n-    match node {\n-        StmtDecl(d, id) => {\n-            let id = folder.new_id(id);\n-            folder.fold_decl(d)\n-                  .into_iter()\n-                  .map(|d| {\n-                      P(Spanned {\n-                          node: StmtDecl(d, id),\n-                          span: span,\n-                      })\n-                  })\n-                  .collect()\n-        }\n-        StmtExpr(e, id) => {\n-            let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span,\n-            }))\n-        }\n-        StmtSemi(e, id) => {\n-            let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span,\n-            }))\n+pub fn noop_fold_stmt<T: Folder>(stmt: P<Stmt>, folder: &mut T)\n+                                 -> P<Stmt> {\n+    stmt.map(|Spanned { node, span }| {\n+        let span = folder.new_span(span);\n+        match node {\n+            StmtDecl(d, id) => {\n+                let id = folder.new_id(id);\n+                Spanned {\n+                    node: StmtDecl(folder.fold_decl(d), id),\n+                    span: span\n+                }\n+            }\n+            StmtExpr(e, id) => {\n+                let id = folder.new_id(id);\n+                Spanned {\n+                    node: StmtExpr(folder.fold_expr(e), id),\n+                    span: span,\n+                }\n+            }\n+            StmtSemi(e, id) => {\n+                let id = folder.new_id(id);\n+                Spanned {\n+                    node: StmtSemi(folder.fold_expr(e), id),\n+                    span: span,\n+                }\n+            }\n         }\n-    }\n+    })\n }"}]}