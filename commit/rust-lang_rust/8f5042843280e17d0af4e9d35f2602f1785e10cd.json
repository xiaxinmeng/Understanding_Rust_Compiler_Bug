{"sha": "8f5042843280e17d0af4e9d35f2602f1785e10cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNTA0Mjg0MzI4MGUxN2QwYWY0ZTlkMzVmMjYwMmYxNzg1ZTEwY2Q=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-17T13:36:38Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-18T11:48:53Z"}, "message": "Removed the `_frozen` methods from dataflow API.\n\nCalls to methods like `each_bit_on_entry_frozen` and\n`each_gen_bit_frozen` now go to the `each_bit_on_entry` and\n`each_gen_bit` methods.", "tree": {"sha": "2a40d352db822c3204c8026197ee807455c19a8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a40d352db822c3204c8026197ee807455c19a8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5042843280e17d0af4e9d35f2602f1785e10cd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5042843280e17d0af4e9d35f2602f1785e10cd", "html_url": "https://github.com/rust-lang/rust/commit/8f5042843280e17d0af4e9d35f2602f1785e10cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5042843280e17d0af4e9d35f2602f1785e10cd/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6", "html_url": "https://github.com/rust-lang/rust/commit/fc4f6eda96f6a31d9417a3a25977faf2e4684ba6"}], "stats": {"total": 96, "additions": 44, "deletions": 52}, "files": [{"sha": "285c5203af2f1ea7ac7e94a47d8408d8576c4232", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8f5042843280e17d0af4e9d35f2602f1785e10cd", "patch": "@@ -172,7 +172,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        self.dfcx_loans.each_bit_on_entry_frozen(scope_id, |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry(scope_id, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n         })\n@@ -271,7 +271,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         //! we encounter `scope_id`.\n \n         let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n+        self.dfcx_loans.each_gen_bit(scope_id, |loan_index| {\n             result.push(loan_index);\n             true\n         });"}, {"sha": "6ec3f82ad68e74ffb00d40b0734377d516e5d394", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=8f5042843280e17d0af4e9d35f2602f1785e10cd", "patch": "@@ -576,7 +576,7 @@ impl<'a> FlowedMoveData<'a> {\n          * Iterates through each path moved by `id`\n          */\n \n-        self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n+        self.dfcx_moves.each_gen_bit(id, |index| {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n@@ -592,7 +592,7 @@ impl<'a> FlowedMoveData<'a> {\n \n         let mut ret = None;\n         for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n-            self.dfcx_moves.each_gen_bit_frozen(id, |move_index| {\n+            self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let move = self.move_data.moves.borrow();\n                 let move = move.get(move_index);\n                 if move.path == **loan_path_index {\n@@ -637,7 +637,7 @@ impl<'a> FlowedMoveData<'a> {\n \n         let mut ret = true;\n \n-        self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n+        self.dfcx_moves.each_bit_on_entry(id, |index| {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n@@ -693,7 +693,7 @@ impl<'a> FlowedMoveData<'a> {\n             }\n         };\n \n-        self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n+        self.dfcx_assign.each_bit_on_entry(id, |index| {\n             let assignment = self.move_data.var_assignments.borrow();\n             let assignment = assignment.get(index);\n             if assignment.path == loan_path_index && !f(assignment) {"}, {"sha": "7c5b001354dbbf296c67fd59cd2c296fd32bcf13", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5042843280e17d0af4e9d35f2602f1785e10cd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8f5042843280e17d0af4e9d35f2602f1785e10cd", "patch": "@@ -97,15 +97,6 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         assert!(n != ast::DUMMY_NODE_ID);\n         self.nodeid_to_index.contains_key(&n)\n     }\n-    fn has_bitset_for_cfgidx(&self, _cfgidx: CFGIndex) -> bool {\n-        true\n-    }\n-    fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n-        cfgidx.node_id()\n-    }\n-    fn get_or_create_bitset_index(&mut self, cfgidx: CFGIndex) -> uint {\n-        cfgidx.node_id()\n-    }\n }\n \n impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n@@ -120,8 +111,9 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n         };\n \n         if self.has_bitset_for_nodeid(id) {\n+            assert!(self.bits_per_id > 0);\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-            let (start, end) = self.compute_id_range_frozen(cfgidx);\n+            let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n             let entry_str = bits_to_string(on_entry);\n \n@@ -232,6 +224,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.bits_per_id > 0);\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.mut_slice(start, end);\n@@ -243,32 +237,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.bits_per_id > 0);\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let kills = self.kills.mut_slice(start, end);\n         set_bit(kills, bit);\n     }\n \n-    fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n+    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n         debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n-        bitwise(bits, gens, &Union);\n-        let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, &Subtract);\n-\n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-    }\n+        assert!(self.bits_per_id > 0);\n \n-    fn apply_gen_kill_frozen(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n-        //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        //! Only useful after `propagate()` has been called.\n-        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, &Union);\n         let kills = self.kills.slice(start, end);\n@@ -278,15 +261,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n-    fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n-        let n = self.get_bitset_index(cfgidx);\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-        (start, end)\n-    }\n-\n-    fn compute_id_range(&mut self, cfgidx: CFGIndex) -> (uint, uint) {\n-        let n = self.get_or_create_bitset_index(cfgidx);\n+    fn compute_id_range(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = cfgidx.node_id();\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n \n@@ -299,10 +275,10 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     }\n \n \n-    pub fn each_bit_on_entry_frozen(&self,\n-                                    id: ast::NodeId,\n-                                    f: |uint| -> bool)\n-                                    -> bool {\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::NodeId,\n+                             f: |uint| -> bool)\n+                             -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -319,17 +295,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                              -> bool {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_cfgidx(cfgidx) {\n+\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n         let temp_bits;\n         let slice = match e {\n             Entry => on_entry,\n             Exit => {\n                 let mut t = on_entry.to_vec();\n-                self.apply_gen_kill_frozen(cfgidx, t.as_mut_slice());\n+                self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n                 temp_bits.as_slice()\n             }\n@@ -339,15 +319,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n-                               -> bool {\n+    pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)\n+                        -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n-        //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n+\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n+            return true;\n+        }\n+\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n         debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n@@ -356,6 +342,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n     fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n+        //! Returns false on the first call to `f` that returns false;\n+        //! if all calls to `f` return true, then returns true.\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n@@ -486,6 +474,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 in_out: &mut [uint]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n+        assert!(self.dfcx.bits_per_id > 0);\n+\n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n                    node_index, node.data.id, bits_to_string(in_out));\n@@ -529,6 +519,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n         let cfgidx = edge.target();\n         debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n                self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n+        assert!(self.dfcx.bits_per_id > 0);\n+\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)"}]}