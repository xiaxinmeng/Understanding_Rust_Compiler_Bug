{"sha": "07db8c8382888975fe1045686a73bba66e13034d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZGI4YzgzODI4ODg5NzVmZTEwNDU2ODZhNzNiYmE2NmUxMzAzNGQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-05-29T01:20:20Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-05-29T01:20:20Z"}, "message": "Merge pull request #2454 from killerswan/cargo_may2012\n\n(cargo) fixed a package installation bug, cleaned up usage", "tree": {"sha": "49fb6a5ae969883c42c0d56cf8e7dc95b2d7f4b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49fb6a5ae969883c42c0d56cf8e7dc95b2d7f4b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07db8c8382888975fe1045686a73bba66e13034d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07db8c8382888975fe1045686a73bba66e13034d", "html_url": "https://github.com/rust-lang/rust/commit/07db8c8382888975fe1045686a73bba66e13034d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07db8c8382888975fe1045686a73bba66e13034d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "163b0604dcd3494185bc3625c10a3d458d25f073", "url": "https://api.github.com/repos/rust-lang/rust/commits/163b0604dcd3494185bc3625c10a3d458d25f073", "html_url": "https://github.com/rust-lang/rust/commit/163b0604dcd3494185bc3625c10a3d458d25f073"}, {"sha": "b7393ecdf2feb1282abc0edb9b857291187671f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7393ecdf2feb1282abc0edb9b857291187671f2", "html_url": "https://github.com/rust-lang/rust/commit/b7393ecdf2feb1282abc0edb9b857291187671f2"}], "stats": {"total": 138, "additions": 81, "deletions": 57}, "files": [{"sha": "742c720246365df7313f2fd1211c468e13fdcf91", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 81, "deletions": 57, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/07db8c8382888975fe1045686a73bba66e13034d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07db8c8382888975fe1045686a73bba66e13034d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=07db8c8382888975fe1045686a73bba66e13034d", "patch": "@@ -61,12 +61,14 @@ type options = {\n     test: bool,\n     mode: mode,\n     free: [str],\n+    help: bool,\n };\n \n enum mode { system_mode, user_mode, local_mode }\n \n fn opts() -> [getopts::opt] {\n-    [optflag(\"g\"), optflag(\"G\"), optopt(\"mode\"), optflag(\"test\")]\n+    [optflag(\"g\"), optflag(\"G\"), optopt(\"mode\"), optflag(\"test\"),\n+     optflag(\"h\"), optflag(\"help\")]\n }\n \n fn info(msg: str) {\n@@ -172,7 +174,7 @@ fn rest(s: str, start: uint) -> str {\n \n fn need_dir(s: str) {\n     if os::path_is_dir(s) { ret; }\n-    if !os::make_dir(s, 0x1c0i32) {\n+    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n         fail #fmt[\"can't make_dir %s\", s];\n     }\n }\n@@ -337,49 +339,55 @@ fn build_cargo_options(argv: [str]) -> options {\n     };\n \n     let test = opt_present(match, \"test\");\n-    let G = opt_present(match, \"G\");\n-    let g = opt_present(match, \"g\");\n-    let m = opt_present(match, \"mode\");\n+    let G    = opt_present(match, \"G\");\n+    let g    = opt_present(match, \"g\");\n+    let m    = opt_present(match, \"mode\");\n+    let help = opt_present(match, \"h\") || opt_present(match, \"help\");\n+\n     let is_install = vec::len(match.free) > 1u && match.free[1] == \"install\";\n \n     if G && g { fail \"-G and -g both provided\"; }\n     if g && m { fail \"--mode and -g both provided\"; }\n     if G && m { fail \"--mode and -G both provided\"; }\n \n-    let mode = if is_install {\n-        if G { system_mode }\n-        else if g { user_mode }\n-        else if m {\n+    if !is_install && (g || G || m) {\n+        fail \"-g, -G, --mode are only valid for `install`\";\n+    }\n+\n+    let mode =\n+        if !is_install || G { system_mode }\n+        else if  g { user_mode }\n+        else if !m { local_mode }\n+        else {\n             alt getopts::opt_str(match, \"mode\") {\n                 \"system\" { system_mode }\n-                \"user\" { user_mode }\n-                \"local\" { local_mode }\n-                _ { fail \"argument to `mode` must be one of `system`\" +\n-                    \", `user`, or `local`\";\n-                }\n-            }\n-        } else { local_mode }\n-    } else { system_mode };\n+                \"user\"   { user_mode }\n+                \"local\"  { local_mode }\n+                _        { fail \"argument to `mode` must be\" +\n+                                \"one of `system`, `user`, or `local`\"; }}\n+        };\n \n-    {test: test, mode: mode, free: match.free}\n+    {test: test, mode: mode, free: match.free, help: help}\n }\n \n fn configure(opts: options) -> cargo {\n+    // NOTE: to make init and sync save into non-root level directories\n+    // simply get rid of syscargo, below\n+\n     let syscargo = result::get(get_cargo_sysroot());\n+\n     let get_cargo_dir = alt opts.mode {\n         system_mode { get_cargo_sysroot }\n         user_mode { get_cargo_root }\n         local_mode { get_cargo_root_nearest }\n     };\n \n-    let p = alt get_cargo_dir() {\n-        result::ok(p) { p }\n-        result::err(e) { fail e }\n-    };\n+    let p = result::get(get_cargo_dir());\n \n     let sources = map::str_hash::<source>();\n     try_parse_sources(path::connect(syscargo, \"sources.json\"), sources);\n     try_parse_sources(path::connect(syscargo, \"local-sources.json\"), sources);\n+\n     let mut c = {\n         pgp: pgp::supported(),\n         root: p,\n@@ -467,17 +475,20 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n     for newv.each {|ct|\n+        // FIXME: What's up with the dual installation?  Both `install_to_dir`\n+        // and `install_one_crate_to_sysroot` install the binary files...\n+\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {\n             #debug(\"  bin: %s\", ct);\n-            copy_warn(ct, c.bindir);\n+            install_to_dir(ct, c.bindir);\n             if c.opts.mode == system_mode {\n                 install_one_crate_to_sysroot(ct, \"bin\");\n             }\n         } else {\n             #debug(\"  lib: %s\", ct);\n-            copy_warn(ct, c.bindir);\n+            install_to_dir(ct, c.libdir);\n             if c.opts.mode == system_mode {\n                 install_one_crate_to_sysroot(ct, libdir());\n             }\n@@ -491,7 +502,7 @@ fn install_one_crate_to_sysroot(ct: str, target: str) {\n             let path = [_path, \"..\", target];\n             check vec::is_not_empty(path);\n             let target_dir = path::normalize(path::connect_many(path));\n-            copy_warn(ct, target_dir);\n+            install_to_dir(ct, target_dir);\n         }\n         none { }\n     }\n@@ -684,9 +695,10 @@ fn cmd_install(c: cargo) unsafe {\n \n     let target = c.opts.free[2];\n \n-    let wd = alt tempfile::mkdtemp(c.workdir + path::path_sep(), \"\") {\n+    let wd_base = c.workdir + path::path_sep();\n+    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n         some(_wd) { _wd }\n-        none { fail \"needed temp dir\"; }\n+        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n     };\n \n     if str::starts_with(target, \"uuid:\") {\n@@ -802,9 +814,9 @@ fn cmd_init(c: cargo) {\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n-        warn(#fmt[\"signature verification failed for sources.json\"]);\n+        warn(#fmt[\"signature verification failed for '%s'\", srcfile]);\n     } else {\n-        info(#fmt[\"signature ok for sources.json\"]);\n+        info(#fmt[\"signature ok for '%s'\", srcfile]);\n     }\n     copy_warn(srcfile, destsrcfile);\n \n@@ -847,44 +859,56 @@ fn cmd_search(c: cargo) {\n     info(#fmt[\"Found %d packages.\", n]);\n }\n \n-fn copy_warn(src: str, dest: str) {\n-  if !os::copy_file(src, dest) {\n-      warn(#fmt[\"Copying %s to %s failed\", src, dest]);\n+fn install_to_dir(srcfile: str, destdir: str) {\n+    let newfile = path::connect(destdir, path::basename(srcfile));\n+    info(#fmt[\"Installing '%s'...\", newfile]);\n+\n+    run::run_program(\"cp\", [srcfile, newfile]);\n+}\n+\n+fn copy_warn(srcfile: str, destfile: str) {\n+  if !os::copy_file(srcfile, destfile) {\n+      warn(#fmt[\"Copying %s to %s failed\", srcfile, destfile]);\n   }\n }\n \n+// FIXME: decide on either [-g | -G] or [--mode=...] and remove the other\n fn cmd_usage() {\n-    print(\"Usage: cargo <verb> [options] [args...]\" +\n-          \"\n-\n-    init                                          Set up .cargo\n-    install [options] [source/]package-name       Install by name\n-    install [options] uuid:[source/]package-uuid  Install by uuid\n-    list [source]                                 List packages\n-    search <name | '*'> [tags...]                 Search packages\n-    sync                                          Sync all sources\n-    usage                                         This\n-\n-Options:\n-\n-  cargo install\n-\n-    --mode=[system,user,local]   change mode as (system/user/local)\n-    --test                       run crate tests before installing\n-    -g                           equivalent to --mode=user\n-    -G                           equivalent to --mode=system\n-\n-NOTE:\n-\\\"cargo install\\\" installs bin/libs to local-level .cargo by default.\n-To install them into user-level .cargo,  use option -g/--mode=user.\n-To install them into bin/lib on sysroot, use option -G/--mode=system.\n+    print(\"Usage: cargo <verb> [options] [args...]\\n\" +\n+          \" e.g.: cargo [init | sync]\\n\" +\n+          \" e.g.: cargo install [-g | -G | --mode=MODE] ] [PACKAGE...]\n+\n+Initialization:\n+    init           Set up the cargo system near this binary,\n+                   for example, at  /usr/local/lib/cargo/\n+    sync           Sync all package sources\n+\n+Querying:\n+    list [source]                        List packages\n+    search <name | '*'> [tags...]        Search packages\n+    usage                                Display this message\n+\n+Package installation:\n+    [options] [source/]PKGNAME           Install a package by name\n+    [options] uuid:[source/]PKGUUID      Install a package by uuid\n+\n+Package installation options:\n+    --mode=MODE    Install to one of the following locations:\n+                   local (./.cargo/bin/, which is the default),\n+                   user (~/.cargo/bin/), or system (/usr/local/lib/cargo/bin/)\n+    --test         Run crate tests before installing\n+    -g             Equivalent to --mode=user\n+    -G             Equivalent to --mode=system\n+\n+Other:\n+    -h, --help     Display this message\n \");\n }\n \n fn main(argv: [str]) {\n     let o = build_cargo_options(argv);\n \n-    if vec::len(o.free) < 2u {\n+    if vec::len(o.free) < 2u || o.help {\n         cmd_usage();\n         ret;\n     }"}]}