{"sha": "fd542592f08ca0d1f7255600115c2eafdf6b5da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNTQyNTkyZjA4Y2EwZDFmNzI1NTYwMDExNWMyZWFmZGY2YjVkYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T21:16:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T21:16:33Z"}, "message": "Auto merge of #77187 - TimDiekmann:box-alloc, r=Amanieu\n\nSupport custom allocators in `Box`\n\nr? `@Amanieu`\n\nThis pull request requires a crater run.\n\n### Prior work:\n- #71873\n- #58457\n- [`alloc-wg`](https://github.com/TimDiekmann/alloc-wg)-crate\n\nCurrently blocked on:\n- ~#77118~\n- ~https://github.com/rust-lang/chalk/issues/615 (#77515)~", "tree": {"sha": "71b632fc8de2294cdf76bb8597c6de3ee70f2e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b632fc8de2294cdf76bb8597c6de3ee70f2e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd542592f08ca0d1f7255600115c2eafdf6b5da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd542592f08ca0d1f7255600115c2eafdf6b5da7", "html_url": "https://github.com/rust-lang/rust/commit/fd542592f08ca0d1f7255600115c2eafdf6b5da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd542592f08ca0d1f7255600115c2eafdf6b5da7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da6d42f297642a60f2640ec313b879b376b9ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da6d42f297642a60f2640ec313b879b376b9ad8", "html_url": "https://github.com/rust-lang/rust/commit/0da6d42f297642a60f2640ec313b879b376b9ad8"}, {"sha": "06e4497a04615ad95dff4240ca9980f19ed364ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/06e4497a04615ad95dff4240ca9980f19ed364ad", "html_url": "https://github.com/rust-lang/rust/commit/06e4497a04615ad95dff4240ca9980f19ed364ad"}], "stats": {"total": 792, "additions": 577, "deletions": 215}, "files": [{"sha": "0a4f88dedbb07ad4220c6f0620042f7eb5b309a7", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -2,8 +2,13 @@\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n-use core::intrinsics::{self, min_align_of_val, size_of_val};\n-use core::ptr::{self, NonNull, Unique};\n+#[cfg(not(test))]\n+use core::intrinsics;\n+use core::intrinsics::{min_align_of_val, size_of_val};\n+\n+use core::ptr::Unique;\n+#[cfg(not(test))]\n+use core::ptr::{self, NonNull};\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -39,8 +44,12 @@ extern \"Rust\" {\n /// accessed through the [free functions in `alloc`](self#functions).\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n+#[cfg(not(test))]\n pub struct Global;\n \n+#[cfg(test)]\n+pub use std::alloc::Global;\n+\n /// Allocate memory with the global allocator.\n ///\n /// This function forwards calls to the [`GlobalAlloc::alloc`] method\n@@ -144,6 +153,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n     unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n }\n \n+#[cfg(not(test))]\n impl Global {\n     #[inline]\n     fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {\n@@ -207,6 +217,7 @@ impl Global {\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[cfg(not(test))]\n unsafe impl AllocRef for Global {\n     #[inline]\n     fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n@@ -313,12 +324,12 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n+pub(crate) unsafe fn box_free<T: ?Sized, A: AllocRef>(ptr: Unique<T>, alloc: A) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr.cast().into(), layout)\n+        alloc.dealloc(ptr.cast().into(), layout)\n     }\n }\n "}, {"sha": "997dd975c83cd4dc7eff7cbce3610db365a2c2c2", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 380, "deletions": 110, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -145,7 +145,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocRef, Global};\n+use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -157,7 +157,10 @@ use crate::vec::Vec;\n #[lang = \"owned_box\"]\n #[fundamental]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Box<T: ?Sized>(Unique<T>);\n+pub struct Box<\n+    T: ?Sized,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+>(Unique<T>, A);\n \n impl<T> Box<T> {\n     /// Allocates memory on the heap and then places `x` into it.\n@@ -171,7 +174,7 @@ impl<T> Box<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n-    pub fn new(x: T) -> Box<T> {\n+    pub fn new(x: T) -> Self {\n         box x\n     }\n \n@@ -194,10 +197,9 @@ impl<T> Box<T> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n-        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast();\n-        unsafe { Box::from_raw(ptr.as_ptr()) }\n+        Self::new_uninit_in(Global)\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -219,13 +221,9 @@ impl<T> Box<T> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n-        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = Global\n-            .alloc_zeroed(layout)\n-            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .cast();\n-        unsafe { Box::from_raw(ptr.as_ptr()) }\n+        Self::new_zeroed_in(Global)\n     }\n \n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n@@ -235,14 +233,103 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+}\n+\n+impl<T, A: AllocRef> Box<T, A> {\n+    /// Allocates memory in the given allocator then places `x` into it.\n+    ///\n+    /// This doesn't actually allocate if `T` is zero-sized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let five = Box::new_in(5, System);\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn new_in(x: T, alloc: A) -> Self {\n+        let mut boxed = Self::new_uninit_in(alloc);\n+        unsafe {\n+            boxed.as_mut_ptr().write(x);\n+            boxed.assume_init()\n+        }\n+    }\n+\n+    /// Constructs a new box with uninitialized contents in the provided allocator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let mut five = Box::<u32, _>::new_uninit_in(System);\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+        let layout = Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = alloc.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n+        unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n+    }\n+\n+    /// Constructs a new `Box` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes in the provided allocator.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let zero = Box::<u32, _>::new_zeroed_in(System);\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0)\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+        let layout = Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = alloc.alloc_zeroed(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n+        unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n+    }\n+\n+    /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement `Unpin`, then\n+    /// `x` will be pinned in memory and unable to be moved.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline(always)]\n+    pub fn pin_in(x: T, alloc: A) -> Pin<Self> {\n+        Self::new_in(x, alloc).into()\n+    }\n \n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n-    pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n-        // *mut T and *mut [T; 1] have the same size and alignment\n-        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1]) }\n+    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n+        let (raw, alloc) = Box::into_raw_with_alloc(boxed);\n+        unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n }\n \n@@ -296,8 +383,64 @@ impl<T> Box<[T]> {\n     }\n }\n \n-impl<T> Box<mem::MaybeUninit<T>> {\n-    /// Converts to `Box<T>`.\n+impl<T, A: AllocRef> Box<[T], A> {\n+    /// Constructs a new boxed slice with uninitialized contents in the provided allocator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let mut values = Box::<[u32], _>::new_uninit_slice_in(3, System);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n+        unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }\n+    }\n+\n+    /// Constructs a new boxed slice with uninitialized contents in the provided allocator,\n+    /// with the memory being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let values = Box::<[u32], _>::new_zeroed_slice_in(3, System);\n+    /// let values = unsafe { values.assume_init() };\n+    ///\n+    /// assert_eq!(*values, [0, 0, 0])\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n+        unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }\n+    }\n+}\n+\n+impl<T, A: AllocRef> Box<mem::MaybeUninit<T>, A> {\n+    /// Converts to `Box<T, A>`.\n     ///\n     /// # Safety\n     ///\n@@ -327,13 +470,14 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n-    pub unsafe fn assume_init(self) -> Box<T> {\n-        unsafe { Box::from_raw(Box::into_raw(self) as *mut T) }\n+    pub unsafe fn assume_init(self) -> Box<T, A> {\n+        let (raw, alloc) = Box::into_raw_with_alloc(self);\n+        unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n }\n \n-impl<T> Box<[mem::MaybeUninit<T>]> {\n-    /// Converts to `Box<[T]>`.\n+impl<T, A: AllocRef> Box<[mem::MaybeUninit<T>], A> {\n+    /// Converts to `Box<[T], A>`.\n     ///\n     /// # Safety\n     ///\n@@ -365,8 +509,9 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n-    pub unsafe fn assume_init(self) -> Box<[T]> {\n-        unsafe { Box::from_raw(Box::into_raw(self) as *mut [T]) }\n+    pub unsafe fn assume_init(self) -> Box<[T], A> {\n+        let (raw, alloc) = Box::into_raw_with_alloc(self);\n+        unsafe { Box::from_raw_in(raw as *mut [T], alloc) }\n     }\n }\n \n@@ -412,7 +557,62 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        Box(unsafe { Unique::new_unchecked(raw) })\n+        unsafe { Self::from_raw_in(raw, Global) }\n+    }\n+}\n+\n+impl<T: ?Sized, A: AllocRef> Box<T, A> {\n+    /// Constructs a box from a raw pointer in the given allocator.\n+    ///\n+    /// After calling this function, the raw pointer is owned by the\n+    /// resulting `Box`. Specifically, the `Box` destructor will call\n+    /// the destructor of `T` and free the allocated memory. For this\n+    /// to be safe, the memory must have been allocated in accordance\n+    /// with the [memory layout] used by `Box` .\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because improper use may lead to\n+    /// memory problems. For example, a double-free may occur if the\n+    /// function is called twice on the same raw pointer.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// Recreate a `Box` which was previously converted to a raw pointer\n+    /// using [`Box::into_raw_with_alloc`]:\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let x = Box::new_in(5, System);\n+    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n+    /// ```\n+    /// Manually create a `Box` from scratch by using the system allocator:\n+    /// ```\n+    /// #![feature(allocator_api, slice_ptr_get)]\n+    ///\n+    /// use std::alloc::{AllocRef, Layout, System};\n+    ///\n+    /// unsafe {\n+    ///     let ptr = System.alloc(Layout::new::<i32>())?.as_mut_ptr();\n+    ///     // In general .write is required to avoid attempting to destruct\n+    ///     // the (uninitialized) previous contents of `ptr`, though for this\n+    ///     // simple example `*ptr = 5` would have worked as well.\n+    ///     ptr.write(5);\n+    ///     let x = Box::from_raw_in(ptr, System);\n+    /// }\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [memory layout]: self#memory-layout\n+    /// [`Layout`]: crate::Layout\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n+        Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n     }\n \n     /// Consumes the `Box`, returning a wrapped raw pointer.\n@@ -456,13 +656,61 @@ impl<T: ?Sized> Box<T> {\n     /// [memory layout]: self#memory-layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n-    pub fn into_raw(b: Box<T>) -> *mut T {\n-        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n-        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n-        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n-        // so all raw pointer methods go through `leak` which creates a (unique)\n-        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n-        Box::leak(b) as *mut T\n+    pub fn into_raw(b: Self) -> *mut T {\n+        Self::into_raw_with_alloc(b).0\n+    }\n+\n+    /// Consumes the `Box`, returning a wrapped raw pointer and the allocator.\n+    ///\n+    /// The pointer will be properly aligned and non-null.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Box`. In particular, the\n+    /// caller should properly destroy `T` and release the memory, taking\n+    /// into account the [memory layout] used by `Box`. The easiest way to\n+    /// do this is to convert the raw pointer back into a `Box` with the\n+    /// [`Box::from_raw_in`] function, allowing the `Box` destructor to perform\n+    /// the cleanup.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::into_raw_with_alloc(b)` instead of `b.into_raw_with_alloc()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// # Examples\n+    /// Converting the raw pointer back into a `Box` with [`Box::from_raw_in`]\n+    /// for automatic cleanup:\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let x = Box::new_in(String::from(\"Hello\"), System);\n+    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n+    /// ```\n+    /// Manual cleanup by explicitly running the destructor and deallocating\n+    /// the memory:\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::{AllocRef, Layout, System};\n+    /// use std::ptr::{self, NonNull};\n+    ///\n+    /// let x = Box::new_in(String::from(\"Hello\"), System);\n+    /// let (ptr, alloc) = Box::into_raw_with_alloc(x);\n+    /// unsafe {\n+    ///     ptr::drop_in_place(ptr);\n+    ///     let non_null = NonNull::new_unchecked(ptr);\n+    ///     alloc.dealloc(non_null.cast(), Layout::new::<String>());\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: self#memory-layout\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn into_raw_with_alloc(b: Self) -> (*mut T, A) {\n+        let (leaked, alloc) = Box::into_unique(b);\n+        (leaked.as_ptr(), alloc)\n     }\n \n     #[unstable(\n@@ -472,13 +720,30 @@ impl<T: ?Sized> Box<T> {\n     )]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Box<T>) -> Unique<T> {\n+    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n         // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n         // raw pointer for the type system. Turning it directly into a raw pointer would not be\n         // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n-        // so all raw pointer methods go through `leak` which creates a (unique)\n-        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n-        Box::leak(b).into()\n+        // so all raw pointer methods have to leak the box. Turning *that* to a raw pointer\n+        // behaves correctly.\n+        let b = mem::ManuallyDrop::new(b);\n+\n+        // The box is unitiliazed later when moving out the allocator. The pointer is stored\n+        // beforehand.\n+        let ptr = b.0;\n+        let alloc = unsafe { ptr::read(&b.1) };\n+        (ptr, alloc)\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `Box::alloc_ref(&b)` instead of `b.alloc_ref()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn alloc_ref(b: &Self) -> &A {\n+        &b.1\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -518,9 +783,9 @@ impl<T: ?Sized> Box<T> {\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n-    pub fn leak<'a>(b: Box<T>) -> &'a mut T\n+    pub fn leak<'a>(b: Self) -> &'a mut T\n     where\n-        T: 'a, // Technically not needed, but kept to be explicit.\n+        A: 'a,\n     {\n         unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n     }\n@@ -531,7 +796,7 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// This is also available via [`From`].\n     #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n-    pub fn into_pin(boxed: Box<T>) -> Pin<Box<T>> {\n+    pub fn into_pin(boxed: Self) -> Pin<Self> {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n         // when `T: !Unpin`,  so it's safe to pin it directly without any\n         // additional requirements.\n@@ -540,7 +805,7 @@ impl<T: ?Sized> Box<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n+unsafe impl<#[may_dangle] T: ?Sized, A: AllocRef> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // FIXME: Do nothing, drop is currently performed by compiler.\n     }\n@@ -549,27 +814,27 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     /// Creates a `Box<T>`, with the `Default` value for T.\n-    fn default() -> Box<T> {\n-        box Default::default()\n+    fn default() -> Self {\n+        box T::default()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n-    fn default() -> Box<[T]> {\n+    fn default() -> Self {\n         Box::<[T; 0]>::new([])\n     }\n }\n \n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n impl Default for Box<str> {\n-    fn default() -> Box<str> {\n+    fn default() -> Self {\n         unsafe { from_boxed_utf8_unchecked(Default::default()) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for Box<T> {\n+impl<T: Clone, A: AllocRef + Clone> Clone for Box<T, A> {\n     /// Returns a new box with a `clone()` of this box's contents.\n     ///\n     /// # Examples\n@@ -586,8 +851,8 @@ impl<T: Clone> Clone for Box<T> {\n     /// ```\n     #[rustfmt::skip]\n     #[inline]\n-    fn clone(&self) -> Box<T> {\n-        box { (**self).clone() }\n+    fn clone(&self) -> Self {\n+        Self::new_in((**self).clone(), self.1.clone())\n     }\n \n     /// Copies `source`'s contents into `self` without creating a new allocation.\n@@ -608,7 +873,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// assert_eq!(yp, &*y);\n     /// ```\n     #[inline]\n-    fn clone_from(&mut self, source: &Box<T>) {\n+    fn clone_from(&mut self, source: &Self) {\n         (**self).clone_from(&(**source));\n     }\n }\n@@ -623,58 +888,58 @@ impl Clone for Box<str> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n+impl<T: ?Sized + PartialEq, A: AllocRef> PartialEq for Box<T, A> {\n     #[inline]\n-    fn eq(&self, other: &Box<T>) -> bool {\n+    fn eq(&self, other: &Self) -> bool {\n         PartialEq::eq(&**self, &**other)\n     }\n     #[inline]\n-    fn ne(&self, other: &Box<T>) -> bool {\n+    fn ne(&self, other: &Self) -> bool {\n         PartialEq::ne(&**self, &**other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n+impl<T: ?Sized + PartialOrd, A: AllocRef> PartialOrd for Box<T, A> {\n     #[inline]\n-    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n     #[inline]\n-    fn lt(&self, other: &Box<T>) -> bool {\n+    fn lt(&self, other: &Self) -> bool {\n         PartialOrd::lt(&**self, &**other)\n     }\n     #[inline]\n-    fn le(&self, other: &Box<T>) -> bool {\n+    fn le(&self, other: &Self) -> bool {\n         PartialOrd::le(&**self, &**other)\n     }\n     #[inline]\n-    fn ge(&self, other: &Box<T>) -> bool {\n+    fn ge(&self, other: &Self) -> bool {\n         PartialOrd::ge(&**self, &**other)\n     }\n     #[inline]\n-    fn gt(&self, other: &Box<T>) -> bool {\n+    fn gt(&self, other: &Self) -> bool {\n         PartialOrd::gt(&**self, &**other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Ord> Ord for Box<T> {\n+impl<T: ?Sized + Ord, A: AllocRef> Ord for Box<T, A> {\n     #[inline]\n-    fn cmp(&self, other: &Box<T>) -> Ordering {\n+    fn cmp(&self, other: &Self) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> Eq for Box<T> {}\n+impl<T: ?Sized + Eq, A: AllocRef> Eq for Box<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Hash> Hash for Box<T> {\n+impl<T: ?Sized + Hash, A: AllocRef> Hash for Box<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-impl<T: ?Sized + Hasher> Hasher for Box<T> {\n+impl<T: ?Sized + Hasher, A: AllocRef> Hasher for Box<T, A> {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -739,11 +1004,11 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized> From<Box<T>> for Pin<Box<T>> {\n+impl<T: ?Sized, A: AllocRef> From<Box<T, A>> for Pin<Box<T, A>> {\n     /// Converts a `Box<T>` into a `Pin<Box<T>>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n-    fn from(boxed: Box<T>) -> Self {\n+    fn from(boxed: Box<T, A>) -> Self {\n         Box::into_pin(boxed)\n     }\n }\n@@ -814,7 +1079,7 @@ impl From<Cow<'_, str>> for Box<str> {\n }\n \n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n-impl From<Box<str>> for Box<[u8]> {\n+impl<A: AllocRef> From<Box<str, A>> for Box<[u8], A> {\n     /// Converts a `Box<str>` into a `Box<[u8]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n@@ -832,8 +1097,9 @@ impl From<Box<str>> for Box<[u8]> {\n     /// assert_eq!(boxed_slice, boxed_str);\n     /// ```\n     #[inline]\n-    fn from(s: Box<str>) -> Self {\n-        unsafe { Box::from_raw(Box::into_raw(s) as *mut [u8]) }\n+    fn from(s: Box<str, A>) -> Self {\n+        let (raw, alloc) = Box::into_raw_with_alloc(s);\n+        unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }\n     }\n }\n \n@@ -866,7 +1132,7 @@ impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]> {\n     }\n }\n \n-impl Box<dyn Any> {\n+impl<A: AllocRef> Box<dyn Any, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -886,19 +1152,19 @@ impl Box<dyn Any> {\n     /// print_if_string(Box::new(my_string));\n     /// print_if_string(Box::new(0i8));\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n+    pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n         if self.is::<T>() {\n             unsafe {\n-                let raw: *mut dyn Any = Box::into_raw(self);\n-                Ok(Box::from_raw(raw as *mut T))\n+                let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_alloc(self);\n+                Ok(Box::from_raw_in(raw as *mut T, alloc))\n             }\n         } else {\n             Err(self)\n         }\n     }\n }\n \n-impl Box<dyn Any + Send> {\n+impl<A: AllocRef> Box<dyn Any + Send, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -918,30 +1184,34 @@ impl Box<dyn Any + Send> {\n     /// print_if_string(Box::new(my_string));\n     /// print_if_string(Box::new(0i8));\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n-        <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {\n-            // reapply the Send marker\n-            Box::from_raw(Box::into_raw(s) as *mut (dyn Any + Send))\n-        })\n+    pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n+        if self.is::<T>() {\n+            unsafe {\n+                let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_alloc(self);\n+                Ok(Box::from_raw_in(raw as *mut T, alloc))\n+            }\n+        } else {\n+            Err(self)\n+        }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n+impl<T: fmt::Display + ?Sized, A: AllocRef> fmt::Display for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n+impl<T: fmt::Debug + ?Sized, A: AllocRef> fmt::Debug for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> fmt::Pointer for Box<T> {\n+impl<T: ?Sized, A: AllocRef> fmt::Pointer for Box<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // It's not possible to extract the inner Uniq directly from the Box,\n         // instead we cast it to a *const which aliases the Unique\n@@ -951,7 +1221,7 @@ impl<T: ?Sized> fmt::Pointer for Box<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Deref for Box<T> {\n+impl<T: ?Sized, A: AllocRef> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -960,17 +1230,17 @@ impl<T: ?Sized> Deref for Box<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> DerefMut for Box<T> {\n+impl<T: ?Sized, A: AllocRef> DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n }\n \n #[unstable(feature = \"receiver_trait\", issue = \"none\")]\n-impl<T: ?Sized> Receiver for Box<T> {}\n+impl<T: ?Sized, A: AllocRef> Receiver for Box<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator + ?Sized> Iterator for Box<I> {\n+impl<I: Iterator + ?Sized, A: AllocRef> Iterator for Box<I, A> {\n     type Item = I::Item;\n     fn next(&mut self) -> Option<I::Item> {\n         (**self).next()\n@@ -991,7 +1261,7 @@ trait BoxIter {\n     fn last(self) -> Option<Self::Item>;\n }\n \n-impl<I: Iterator + ?Sized> BoxIter for Box<I> {\n+impl<I: Iterator + ?Sized, A: AllocRef> BoxIter for Box<I, A> {\n     type Item = I::Item;\n     default fn last(self) -> Option<I::Item> {\n         #[inline]\n@@ -1006,14 +1276,14 @@ impl<I: Iterator + ?Sized> BoxIter for Box<I> {\n /// Specialization for sized `I`s that uses `I`s implementation of `last()`\n /// instead of the default.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> BoxIter for Box<I> {\n+impl<I: Iterator, A: AllocRef> BoxIter for Box<I, A> {\n     fn last(self) -> Option<I::Item> {\n         (*self).last()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n+impl<I: DoubleEndedIterator + ?Sized, A: AllocRef> DoubleEndedIterator for Box<I, A> {\n     fn next_back(&mut self) -> Option<I::Item> {\n         (**self).next_back()\n     }\n@@ -1022,7 +1292,7 @@ impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n+impl<I: ExactSizeIterator + ?Sized, A: AllocRef> ExactSizeIterator for Box<I, A> {\n     fn len(&self) -> usize {\n         (**self).len()\n     }\n@@ -1032,40 +1302,40 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n+impl<I: FusedIterator + ?Sized, A: AllocRef> FusedIterator for Box<I, A> {}\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<A, F: FnOnce<A> + ?Sized> FnOnce<A> for Box<F> {\n-    type Output = <F as FnOnce<A>>::Output;\n+impl<Args, F: FnOnce<Args> + ?Sized, A: AllocRef> FnOnce<Args> for Box<F, A> {\n+    type Output = <F as FnOnce<Args>>::Output;\n \n-    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n-        <F as FnOnce<A>>::call_once(*self, args)\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n+        <F as FnOnce<Args>>::call_once(*self, args)\n     }\n }\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<A, F: FnMut<A> + ?Sized> FnMut<A> for Box<F> {\n-    extern \"rust-call\" fn call_mut(&mut self, args: A) -> Self::Output {\n-        <F as FnMut<A>>::call_mut(self, args)\n+impl<Args, F: FnMut<Args> + ?Sized, A: AllocRef> FnMut<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n+        <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n-    extern \"rust-call\" fn call(&self, args: A) -> Self::Output {\n-        <F as Fn<A>>::call(self, args)\n+impl<Args, F: Fn<Args> + ?Sized, A: AllocRef> Fn<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n+        <F as Fn<Args>>::call(self, args)\n     }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: AllocRef> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T, Global> {}\n \n #[stable(feature = \"boxed_slice_from_iter\", since = \"1.32.0\")]\n-impl<A> FromIterator<A> for Box<[A]> {\n-    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self {\n+impl<I> FromIterator<I> for Box<[I]> {\n+    fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {\n         iter.into_iter().collect::<Vec<_>>().into_boxed_slice()\n     }\n }\n@@ -1086,28 +1356,28 @@ impl<T: Clone> Clone for Box<[T]> {\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]\n-impl<T: ?Sized> borrow::Borrow<T> for Box<T> {\n+impl<T: ?Sized, A: AllocRef> borrow::Borrow<T> for Box<T, A> {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]\n-impl<T: ?Sized> borrow::BorrowMut<T> for Box<T> {\n+impl<T: ?Sized, A: AllocRef> borrow::BorrowMut<T> for Box<T, A> {\n     fn borrow_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n }\n \n #[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n-impl<T: ?Sized> AsRef<T> for Box<T> {\n+impl<T: ?Sized, A: AllocRef> AsRef<T> for Box<T, A> {\n     fn as_ref(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n-impl<T: ?Sized> AsMut<T> for Box<T> {\n+impl<T: ?Sized, A: AllocRef> AsMut<T> for Box<T, A> {\n     fn as_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n@@ -1136,10 +1406,10 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized> Unpin for Box<T> {}\n+impl<T: ?Sized, A: AllocRef> Unpin for Box<T, A> {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n+impl<G: ?Sized + Generator<R> + Unpin, R, A: AllocRef> Generator<R> for Box<G, A> {\n     type Yield = G::Yield;\n     type Return = G::Return;\n \n@@ -1149,7 +1419,7 @@ impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n-impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n+impl<G: ?Sized + Generator<R>, R, A: AllocRef> Generator<R> for Pin<Box<G, A>> {\n     type Yield = G::Yield;\n     type Return = G::Return;\n \n@@ -1159,7 +1429,7 @@ impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n }\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n+impl<F: ?Sized + Future + Unpin, A: AllocRef> Future for Box<F, A> {\n     type Output = F::Output;\n \n     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {"}, {"sha": "c8d3de9e5cd5c70715965a43545bef53dac1d1e4", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -120,7 +120,7 @@ struct BoxedNode<K, V> {\n \n impl<K, V> BoxedNode<K, V> {\n     fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Box::into_unique(node) }\n+        BoxedNode { ptr: Box::into_unique(node).0 }\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {"}, {"sha": "a4240308bb35fec34f630518235b16c337b99c02", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -6,7 +6,7 @@ use core::cmp;\n use core::intrinsics;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n-use core::ptr::{NonNull, Unique};\n+use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n@@ -111,12 +111,37 @@ impl<T> RawVec<T, Global> {\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         unsafe { Self::from_raw_parts_in(ptr, capacity, Global) }\n     }\n+}\n+\n+impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n+    pub const fn new_in(alloc: A) -> Self {\n+        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n+        Self { ptr: Unique::dangling(), cap: 0, alloc }\n+    }\n+\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n+    }\n+\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n+    }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n-    pub fn from_box(slice: Box<[T]>) -> Self {\n+    pub fn from_box(slice: Box<[T], A>) -> Self {\n         unsafe {\n-            let mut slice = ManuallyDrop::new(slice);\n-            RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n+            let (slice, alloc) = Box::into_raw_with_alloc(slice);\n+            RawVec::from_raw_parts_in(slice.as_mut_ptr(), slice.len(), alloc)\n         }\n     }\n \n@@ -132,7 +157,7 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// Note, that the requested capacity and `self.capacity()` could differ, as\n     /// an allocator could overallocate and return a greater memory block than requested.\n-    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>], A> {\n         // Sanity-check one half of the safety requirement (we cannot check the other half).\n         debug_assert!(\n             len <= self.capacity(),\n@@ -142,34 +167,9 @@ impl<T> RawVec<T, Global> {\n         let me = ManuallyDrop::new(self);\n         unsafe {\n             let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n-            Box::from_raw(slice)\n+            Box::from_raw_in(slice, ptr::read(&me.alloc))\n         }\n     }\n-}\n-\n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Like `new`, but parameterized over the choice of allocator for\n-    /// the returned `RawVec`.\n-    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n-    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n-    pub const fn new_in(alloc: A) -> Self {\n-        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n-        Self { ptr: Unique::dangling(), cap: 0, alloc }\n-    }\n-\n-    /// Like `with_capacity`, but parameterized over the choice of\n-    /// allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n-    }\n-\n-    /// Like `with_capacity_zeroed`, but parameterized over the choice\n-    /// of allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n-    }\n \n     fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n         if mem::size_of::<T>() == 0 {"}, {"sha": "72e5e0a82424bf3d80c387c185a94aab4df63b08", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1034,7 +1034,7 @@ impl<T: ?Sized> Rc<T> {\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n-            let box_unique = Box::into_unique(v);\n+            let (box_unique, alloc) = Box::into_unique(v);\n             let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n@@ -1048,7 +1048,7 @@ impl<T: ?Sized> Rc<T> {\n             );\n \n             // Free the allocation without dropping its contents\n-            box_free(box_unique);\n+            box_free(box_unique, alloc);\n \n             Self::from_ptr(ptr)\n         }"}, {"sha": "73ff795c01aa88d31a97d158e3c5ba59b363a27c", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1008,7 +1008,7 @@ impl<T: ?Sized> Arc<T> {\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n-            let box_unique = Box::into_unique(v);\n+            let (box_unique, alloc) = Box::into_unique(v);\n             let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n@@ -1022,7 +1022,7 @@ impl<T: ?Sized> Arc<T> {\n             );\n \n             // Free the allocation without dropping its contents\n-            box_free(box_unique);\n+            box_free(box_unique, alloc);\n \n             Self::from_ptr(ptr)\n         }"}, {"sha": "49fe14babc50ff7cb382fe633314ab42285e6a8d", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -53,10 +53,10 @@\n -     }\n - \n -     bb4 (cleanup): {\n--         _3 = alloc::alloc::box_free::<Vec<u32>>(move (_2.0: std::ptr::Unique<std::vec::Vec<u32>>)) -> bb3; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n+-         _3 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_2.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_2.1: std::alloc::Global)) -> bb3; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:42: 8:43\n--                                          // + literal: Const { ty: unsafe fn(std::ptr::Unique<std::vec::Vec<u32>>) {alloc::alloc::box_free::<std::vec::Vec<u32>>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: unsafe fn(std::ptr::Unique<std::vec::Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<std::vec::Vec<u32>, std::alloc::Global>}, val: Value(Scalar(<ZST>)) }\n       }\n   }\n   "}, {"sha": "bb8ebc30cdd88c409365ab9b8b6989b03eef0ebd", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -53,10 +53,10 @@\n -     }\n - \n -     bb4 (cleanup): {\n--         _3 = alloc::alloc::box_free::<Vec<u32>>(move (_2.0: std::ptr::Unique<std::vec::Vec<u32>>)) -> bb3; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n+-         _3 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_2.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_2.1: std::alloc::Global)) -> bb3; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:42: 8:43\n--                                          // + literal: Const { ty: unsafe fn(std::ptr::Unique<std::vec::Vec<u32>>) {alloc::alloc::box_free::<std::vec::Vec<u32>>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: unsafe fn(std::ptr::Unique<std::vec::Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<std::vec::Vec<u32>, std::alloc::Global>}, val: Value(Scalar(<ZST>)) }\n       }\n   }\n   "}, {"sha": "9427571648c034367a884724c66b8018543ef412", "filename": "src/test/ui/box/alloc-unstable-fail.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -0,0 +1,6 @@\n+use std::boxed::Box;\n+\n+fn main() {\n+    let _boxed: Box<u32, _> = Box::new(10);\n+    //~^ ERROR use of unstable library feature 'allocator_api'\n+}"}, {"sha": "03ae36e889016b8420fa18744882dcfb9f830dbb", "filename": "src/test/ui/box/alloc-unstable-fail.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Falloc-unstable-fail.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: use of unstable library feature 'allocator_api'\n+  --> $DIR/alloc-unstable-fail.rs:4:26\n+   |\n+LL |     let _boxed: Box<u32, _> = Box::new(10);\n+   |                          ^\n+   |\n+   = note: see issue #32838 <https://github.com/rust-lang/rust/issues/32838> for more information\n+   = help: add `#![feature(allocator_api)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "66388d0d5126c9e4952a6fb46d570105540e36f8", "filename": "src/test/ui/box/alloc-unstable.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Falloc-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Falloc-unstable.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+#![feature(allocator_api)]\n+\n+use std::boxed::Box;\n+\n+fn main() {\n+    let _boxed: Box<u32, _> = Box::new(10);\n+}"}, {"sha": "49dbb170f8e7891a50d12891e33a87f2417e579c", "filename": "src/test/ui/box/into-boxed-slice-fail.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "previous_filename": "src/test/ui/box-into-boxed-slice-fail.rs"}, {"sha": "7a5ba16461f76001b598fd91fd0a6023a388add2", "filename": "src/test/ui/box/into-boxed-slice-fail.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,14 +1,14 @@\n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/box-into-boxed-slice-fail.rs:7:35\n+  --> $DIR/into-boxed-slice-fail.rs:7:35\n    |\n LL |     let _ = Box::into_boxed_slice(boxed_slice);\n    |                                   ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n-   = note: required by `Box::<T>::into_boxed_slice`\n+   = note: required by `Box::<T, A>::into_boxed_slice`\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/box-into-boxed-slice-fail.rs:7:13\n+  --> $DIR/into-boxed-slice-fail.rs:7:13\n    |\n LL |     let _ = Box::into_boxed_slice(boxed_slice);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -17,16 +17,16 @@ LL |     let _ = Box::into_boxed_slice(boxed_slice);\n    = note: slice and array elements must have `Sized` type\n \n error[E0277]: the size for values of type `dyn Debug` cannot be known at compilation time\n-  --> $DIR/box-into-boxed-slice-fail.rs:11:35\n+  --> $DIR/into-boxed-slice-fail.rs:11:35\n    |\n LL |     let _ = Box::into_boxed_slice(boxed_trait);\n    |                                   ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `dyn Debug`\n-   = note: required by `Box::<T>::into_boxed_slice`\n+   = note: required by `Box::<T, A>::into_boxed_slice`\n \n error[E0277]: the size for values of type `dyn Debug` cannot be known at compilation time\n-  --> $DIR/box-into-boxed-slice-fail.rs:11:13\n+  --> $DIR/into-boxed-slice-fail.rs:11:13\n    |\n LL |     let _ = Box::into_boxed_slice(boxed_trait);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time", "previous_filename": "src/test/ui/box-into-boxed-slice-fail.stderr"}, {"sha": "61b3d91525347ae01075cf817f27bdc6ed32a3d5", "filename": "src/test/ui/box/into-boxed-slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "previous_filename": "src/test/ui/box-into-boxed-slice.rs"}, {"sha": "2e73d6f143213428677f73f78bf8c455c606ec85", "filename": "src/test/ui/box/leak-alloc.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -0,0 +1,29 @@\n+#![feature(allocator_api)]\n+\n+use std::alloc::{AllocError, AllocRef, Layout, System};\n+use std::ptr::NonNull;\n+\n+use std::boxed::Box;\n+\n+struct Allocator {}\n+\n+unsafe impl AllocRef for Allocator {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n+        System.dealloc(ptr, layout)\n+    }\n+}\n+\n+fn use_value(_: u32) {}\n+\n+fn main() {\n+    let alloc = Allocator {};\n+    let boxed = Box::new_in(10, alloc.by_ref());\n+    let theref = Box::leak(boxed);\n+    drop(alloc);\n+    //~^ ERROR cannot move out of `alloc` because it is borrowed\n+    use_value(*theref)\n+}"}, {"sha": "09beb18146070712fbc5345c7f7c5977183664ec", "filename": "src/test/ui/box/leak-alloc.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fleak-alloc.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -0,0 +1,15 @@\n+error[E0505]: cannot move out of `alloc` because it is borrowed\n+  --> $DIR/leak-alloc.rs:26:10\n+   |\n+LL |     let boxed = Box::new_in(10, alloc.by_ref());\n+   |                                 ----- borrow of `alloc` occurs here\n+LL |     let theref = Box::leak(boxed);\n+LL |     drop(alloc);\n+   |          ^^^^^ move out of `alloc` occurs here\n+LL |\n+LL |     use_value(*theref)\n+   |               ------- borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0505`."}, {"sha": "be1a40cf779dab2b6774c0cc3f22d67121964936", "filename": "src/test/ui/box/new.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fnew.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fbox%2Fnew.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Fnew.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "previous_filename": "src/test/ui/box-new.rs"}, {"sha": "20dc955ffe42b9f4cac442ef8ae0fad3826032b9", "filename": "src/test/ui/coherence/impl-foreign-for-fundamental[foreign].stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-fundamental%5Bforeign%5D.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -2,9 +2,10 @@ error[E0117]: only traits defined in the current crate can be implemented for ar\n   --> $DIR/impl-foreign-for-fundamental[foreign].rs:10:1\n    |\n LL | impl Remote for Box<i32> {\n-   | ^^^^^^^^^^^^^^^^--------\n-   | |               |\n-   | |               `i32` is not defined in the current crate\n+   | ^^^^^------^^^^^--------\n+   | |    |          |\n+   | |    |          `i32` is not defined in the current crate\n+   | |    `std::alloc::Global` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n@@ -13,9 +14,10 @@ error[E0117]: only traits defined in the current crate can be implemented for ar\n   --> $DIR/impl-foreign-for-fundamental[foreign].rs:14:1\n    |\n LL | impl<T> Remote for Box<Rc<T>> {\n-   | ^^^^^^^^^^^^^^^^^^^----------\n-   | |                  |\n-   | |                  `Rc` is not defined in the current crate\n+   | ^^^^^^^^------^^^^^----------\n+   | |       |          |\n+   | |       |          `Rc` is not defined in the current crate\n+   | |       `std::alloc::Global` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead"}, {"sha": "c1e2fdaf5e302e4f0da96d9a609d906ee6d7c59a", "filename": "src/test/ui/coherence/impl-foreign[fundemental[foreign]]-for-foreign.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign%5Bfundemental%5Bforeign%5D%5D-for-foreign.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -6,6 +6,7 @@ LL | impl Remote1<Box<String>> for i32 {\n    | |    |                        |\n    | |    |                        `i32` is not defined in the current crate\n    | |    `String` is not defined in the current crate\n+   | |    `std::alloc::Global` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n@@ -18,6 +19,7 @@ LL | impl Remote1<Box<Rc<i32>>> for f64 {\n    | |    |                         |\n    | |    |                         `f64` is not defined in the current crate\n    | |    `Rc` is not defined in the current crate\n+   | |    `std::alloc::Global` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n@@ -30,6 +32,7 @@ LL | impl<T> Remote1<Box<Rc<T>>> for f32 {\n    | |       |                       |\n    | |       |                       `f32` is not defined in the current crate\n    | |       `Rc` is not defined in the current crate\n+   | |       `std::alloc::Global` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead"}, {"sha": "9dc1a509cd09f64e4334943d4b2edd9e4bcfd65d", "filename": "src/test/ui/error-codes/e0119/conflict-with-std.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fconflict-with-std.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -5,8 +5,8 @@ LL | impl AsRef<Q> for Box<Q> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: conflicting implementation in crate `alloc`:\n-           - impl<T> AsRef<T> for Box<T>\n-             where T: ?Sized;\n+           - impl<T, A> AsRef<T> for Box<T, A>\n+             where A: AllocRef, T: ?Sized;\n \n error[E0119]: conflicting implementations of trait `std::convert::From<S>` for type `S`:\n   --> $DIR/conflict-with-std.rs:12:1"}, {"sha": "3cfaa20a8b5ab07d3dfb658fabbaea47e11134b5", "filename": "src/test/ui/issues/issue-14092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14092.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,4 +1,4 @@\n fn fn1(0: Box) {}\n-        //~^ ERROR wrong number of type arguments: expected 1, found 0 [E0107]\n+        //~^ ERROR wrong number of type arguments: expected at least 1, found 0 [E0107]\n \n fn main() {}"}, {"sha": "b749c44780d962f7ae36743bde348b91d7a671e0", "filename": "src/test/ui/issues/issue-14092.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,8 +1,8 @@\n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of type arguments: expected at least 1, found 0\n   --> $DIR/issue-14092.rs:1:11\n    |\n LL | fn fn1(0: Box) {}\n-   |           ^^^ expected 1 type argument\n+   |           ^^^ expected at least 1 type argument\n \n error: aborting due to previous error\n "}, {"sha": "c873c20cca81bd2f8d70d1a6408a866a07c43603", "filename": "src/test/ui/issues/issue-3601.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Box(_)` not covered\n+error[E0004]: non-exhaustive patterns: `Box(_, _)` not covered\n   --> $DIR/issue-3601.rs:30:44\n    |\n LL |         box NodeKind::Element(ed) => match ed.kind {\n-   |                                            ^^^^^^^ pattern `Box(_)` not covered\n+   |                                            ^^^^^^^ pattern `Box(_, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `Box<ElementKind>`"}, {"sha": "cc4b3707dd66376949c13fbaf869de1e373ab826", "filename": "src/test/ui/issues/issue-41974.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,13 +1,13 @@\n-error[E0119]: conflicting implementations of trait `std::ops::Drop` for type `std::boxed::Box<_>`:\n+error[E0119]: conflicting implementations of trait `std::ops::Drop` for type `std::boxed::Box<_, _>`:\n   --> $DIR/issue-41974.rs:7:1\n    |\n LL | impl<T> Drop for T where T: A {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: conflicting implementation in crate `alloc`:\n-           - impl<T> Drop for Box<T>\n-             where T: ?Sized;\n-   = note: downstream crates may implement trait `A` for type `std::boxed::Box<_>`\n+           - impl<T, A> Drop for Box<T, A>\n+             where A: AllocRef, T: ?Sized;\n+   = note: downstream crates may implement trait `A` for type `std::boxed::Box<_, _>`\n \n error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n   --> $DIR/issue-41974.rs:7:18"}, {"sha": "c7084bfd9804935845ec2ce4a417571a183587b3", "filename": "src/test/ui/privacy/privacy-ns1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -33,7 +33,7 @@ fn test_glob2() {\n     use foo2::*;\n \n     let _x: Box<Bar>;  //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected 1, found 0\n+    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n }\n \n // neither public"}, {"sha": "ccbb5d5c90ff5d1bad7f5923a4a265cbc7e9b906", "filename": "src/test/ui/privacy/privacy-ns1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns1.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -58,11 +58,11 @@ error[E0107]: wrong number of const arguments: expected 0, found 1\n LL |     let _x: Box<Bar>;\n    |                 ^^^ unexpected const argument\n \n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of type arguments: expected at least 1, found 0\n   --> $DIR/privacy-ns1.rs:35:13\n    |\n LL |     let _x: Box<Bar>;\n-   |             ^^^^^^^^ expected 1 type argument\n+   |             ^^^^^^^^ expected at least 1 type argument\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b770c8f8f8610be5009a640e77b63b32875725b9", "filename": "src/test/ui/privacy/privacy-ns2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.rs?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -39,15 +39,15 @@ fn test_single2() {\n     use foo2::Bar;\n \n     let _x : Box<Bar>; //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected 1, found 0\n+    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n     let _x : Bar(); //~ ERROR expected type, found function `Bar`\n }\n \n fn test_list2() {\n     use foo2::{Bar,Baz};\n \n     let _x: Box<Bar>; //~ ERROR wrong number of const arguments: expected 0, found 1\n-    //~^ ERROR wrong number of type arguments: expected 1, found 0\n+    //~^ ERROR wrong number of type arguments: expected at least 1, found 0\n }\n \n // neither public"}, {"sha": "dbb269c0ba6973719de2e9274ae9e0dd1ec59f09", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -84,23 +84,23 @@ error[E0107]: wrong number of const arguments: expected 0, found 1\n LL |     let _x : Box<Bar>;\n    |                  ^^^ unexpected const argument\n \n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of type arguments: expected at least 1, found 0\n   --> $DIR/privacy-ns2.rs:41:14\n    |\n LL |     let _x : Box<Bar>;\n-   |              ^^^^^^^^ expected 1 type argument\n+   |              ^^^^^^^^ expected at least 1 type argument\n \n error[E0107]: wrong number of const arguments: expected 0, found 1\n   --> $DIR/privacy-ns2.rs:49:17\n    |\n LL |     let _x: Box<Bar>;\n    |                 ^^^ unexpected const argument\n \n-error[E0107]: wrong number of type arguments: expected 1, found 0\n+error[E0107]: wrong number of type arguments: expected at least 1, found 0\n   --> $DIR/privacy-ns2.rs:49:13\n    |\n LL |     let _x: Box<Bar>;\n-   |             ^^^^^^^^ expected 1 type argument\n+   |             ^^^^^^^^ expected at least 1 type argument\n \n error: aborting due to 10 previous errors\n "}, {"sha": "2e23ddd9053614fcbb5b92869079a8f06b733641", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,27 +1,30 @@\n error[E0599]: no method named `clone` found for struct `Box<dyn Foo>` in the current scope\n   --> $DIR/unique-object-noncopyable.rs:24:16\n    |\n-LL | trait Foo {\n-   | ---------\n-   | |\n-   | doesn't satisfy `dyn Foo: Clone`\n-   | doesn't satisfy `dyn Foo: Sized`\n+LL |   trait Foo {\n+   |   ---------\n+   |   |\n+   |   doesn't satisfy `dyn Foo: Clone`\n+   |   doesn't satisfy `dyn Foo: Sized`\n ...\n-LL |     let _z = y.clone();\n-   |                ^^^^^ method not found in `Box<dyn Foo>`\n+LL |       let _z = y.clone();\n+   |                  ^^^^^ method not found in `Box<dyn Foo>`\n    | \n-  ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n    |\n-LL | pub struct Box<T: ?Sized>(Unique<T>);\n-   | ------------------------------------- doesn't satisfy `Box<dyn Foo>: Clone`\n+LL |       fn clone(&self) -> Self;\n+   |          -----\n+   |          |\n+   |          the method is available for `Arc<Box<dyn Foo>>` here\n+   |          the method is available for `Rc<Box<dyn Foo>>` here\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Box<dyn Foo>>` here\n-   |        the method is available for `Rc<Box<dyn Foo>>` here\n+LL | / pub struct Box<\n+LL | |     T: ?Sized,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+LL | | >(Unique<T>, A);\n+   | |________________- doesn't satisfy `Box<dyn Foo>: Clone`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `dyn Foo: Sized`"}, {"sha": "d533724a009dc3664d36e08369d10a308582295e", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd542592f08ca0d1f7255600115c2eafdf6b5da7/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=fd542592f08ca0d1f7255600115c2eafdf6b5da7", "patch": "@@ -1,24 +1,27 @@\n error[E0599]: no method named `clone` found for struct `Box<R>` in the current scope\n   --> $DIR/unique-pinned-nocopy.rs:12:16\n    |\n-LL | struct R {\n-   | -------- doesn't satisfy `R: Clone`\n+LL |   struct R {\n+   |   -------- doesn't satisfy `R: Clone`\n ...\n-LL |     let _j = i.clone();\n-   |                ^^^^^ method not found in `Box<R>`\n+LL |       let _j = i.clone();\n+   |                  ^^^^^ method not found in `Box<R>`\n    | \n-  ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n    |\n-LL | pub struct Box<T: ?Sized>(Unique<T>);\n-   | ------------------------------------- doesn't satisfy `Box<R>: Clone`\n+LL |       fn clone(&self) -> Self;\n+   |          -----\n+   |          |\n+   |          the method is available for `Arc<Box<R>>` here\n+   |          the method is available for `Rc<Box<R>>` here\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Box<R>>` here\n-   |        the method is available for `Rc<Box<R>>` here\n+LL | / pub struct Box<\n+LL | |     T: ?Sized,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: AllocRef = Global,\n+LL | | >(Unique<T>, A);\n+   | |________________- doesn't satisfy `Box<R>: Clone`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `R: Clone`"}]}