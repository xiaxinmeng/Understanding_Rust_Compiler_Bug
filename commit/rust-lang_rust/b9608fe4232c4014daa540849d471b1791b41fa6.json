{"sha": "b9608fe4232c4014daa540849d471b1791b41fa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NjA4ZmU0MjMyYzQwMTRkYWE1NDA4NDlkNDcxYjE3OTFiNDFmYTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-20T07:38:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-24T01:35:34Z"}, "message": "std: Convert uv_global_loop to use pipes", "tree": {"sha": "10bd75fb21036ba97b406550c4c21ebe526ae2d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10bd75fb21036ba97b406550c4c21ebe526ae2d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9608fe4232c4014daa540849d471b1791b41fa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9608fe4232c4014daa540849d471b1791b41fa6", "html_url": "https://github.com/rust-lang/rust/commit/b9608fe4232c4014daa540849d471b1791b41fa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9608fe4232c4014daa540849d471b1791b41fa6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb9299346af9b951890db80e47eb65625997f160", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9299346af9b951890db80e47eb65625997f160", "html_url": "https://github.com/rust-lang/rust/commit/fb9299346af9b951890db80e47eb65625997f160"}], "stats": {"total": 319, "additions": 172, "deletions": 147}, "files": [{"sha": "d9230e08dc76d98954283300447230edc9ad49e7", "filename": "src/libcore/private/global.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -114,6 +114,21 @@ unsafe fn global_data_modify_<T: Owned>(\n     }\n }\n \n+pub unsafe fn global_data_clone<T: Owned Clone>(\n+    key: GlobalDataKey<T>) -> Option<T> {\n+    let mut maybe_clone: Option<T> = None;\n+    do global_data_modify(key) |current| {\n+        match &current {\n+            &Some(~ref value) => {\n+                maybe_clone = Some(value.clone());\n+            }\n+            &None => ()\n+        }\n+        current\n+    }\n+    return maybe_clone;\n+}\n+\n // GlobalState is a map from keys to unique pointers and a\n // destructor. Keys are pointers derived from the type of the\n // global value.  There is a single GlobalState instance per runtime."}, {"sha": "cc788dfee22f3d6fce11d7631d1ea7675ee54c6f", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -782,14 +782,14 @@ mod test {\n         let (finish_port, finish_chan) = pipes::stream();\n \n         let addr = ip::v4::parse_addr(\"127.0.0.1\");\n-        let iotask = uv::global_loop::get();\n \n         let begin_connect_chan = Cell(move begin_connect_chan);\n         let accept_chan = Cell(move accept_chan);\n \n         // The server task\n         do task::spawn |copy addr, move begin_connect_chan,\n                         move accept_chan| {\n+            let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n             let accept_chan = accept_chan.take();\n             let listen_res = do tcp::listen(\n@@ -821,6 +821,7 @@ mod test {\n             begin_connect_port.recv();\n \n             debug!(\"connecting\");\n+            let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n             assert connect_result.is_ok();\n             let sock = result::unwrap(move connect_result);"}, {"sha": "080c5514ac8bc3320fa40f8ca24c0b3ccab2e715", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -114,7 +114,7 @@ enum IpGetAddrErr {\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n  */\n-pub fn get_addr(node: &str, iotask: iotask)\n+pub fn get_addr(node: &str, iotask: &iotask)\n         -> result::Result<~[IpAddr], IpGetAddrErr> {\n     do oldcomm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| unsafe {\n@@ -413,7 +413,7 @@ mod test {\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr() {\n         let localhost_name = ~\"localhost\";\n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         if result::is_err(&ga_result) {\n             fail ~\"got err result from net::ip::get_addr();\"\n@@ -439,7 +439,7 @@ mod test {\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n         let localhost_name = ~\"sjkl234m,./sdf\";\n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         assert result::is_err(&ga_result);\n     }"}, {"sha": "75c7a7cbfb9f27074f06bd6247225c933f0a3011", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -142,7 +142,7 @@ pub enum TcpConnectErrData {\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n-           iotask: IoTask)\n+               iotask: &IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n     let result_po = oldcomm::Port::<ConnAttempt>();\n     let closed_signal_po = oldcomm::Port::<()>();\n@@ -164,7 +164,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             ip::Ipv4(_) => { false }\n             ip::Ipv6(_) => { true }\n         },\n-        iotask: iotask\n+        iotask: iotask.clone()\n     };\n     let socket_data_ptr = ptr::addr_of(&(*socket_data));\n     log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n@@ -496,17 +496,17 @@ pub fn accept(new_conn: TcpNewConnection)\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *TcpListenFcData;\n         let reader_po = oldcomm::Port();\n-        let iotask = (*server_data_ptr).iotask;\n+        let iotask = &(*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-        let client_socket_data = @{\n+        let client_socket_data: @TcpSocketData = @{\n             reader_po: reader_po,\n             reader_ch: oldcomm::Chan(&reader_po),\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n             ipv6: (*server_data_ptr).ipv6,\n-            iotask : iotask\n+            iotask : iotask.clone()\n         };\n         let client_socket_data_ptr = ptr::addr_of(&(*client_socket_data));\n         let client_stream_handle_ptr =\n@@ -588,10 +588,10 @@ pub fn accept(new_conn: TcpNewConnection)\n  * of listen exiting because of an error\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n-          iotask: IoTask,\n-          on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n-          new_connect_cb: fn~(TcpNewConnection,\n-                               oldcomm::Chan<Option<TcpErrData>>))\n+              iotask: &IoTask,\n+              on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n+              new_connect_cb: fn~(TcpNewConnection,\n+                                  oldcomm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     do listen_common(move host_ip, port, backlog, iotask,\n                      move on_establish_cb)\n@@ -606,7 +606,7 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n }\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n-          iotask: IoTask,\n+          iotask: &IoTask,\n           on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> unsafe {\n@@ -615,12 +615,12 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n     let kill_ch = oldcomm::Chan(&kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(&server_stream);\n-    let server_data = {\n+    let server_data: TcpListenFcData = {\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n         kill_ch: kill_ch,\n         on_connect_cb: move on_connect_cb,\n-        iotask: iotask,\n+        iotask: iotask.clone(),\n         ipv6: match &host_ip {\n             &ip::Ipv4(_) => { false }\n             &ip::Ipv6(_) => { true }\n@@ -895,7 +895,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n     };\n     let close_data_ptr = ptr::addr_of(&close_data);\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n+    do iotask::interact(&(*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, fmt!(\"interact dtor for tcp_socket stream %? loop %?\",\n             stream_handle_ptr, loop_ptr));\n         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -916,7 +916,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n     use timer;\n \n     log(debug, ~\"starting tcp::read\");\n-    let iotask = (*socket_data).iotask;\n+    let iotask = &(*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n     if result::is_err(&rs_result) {\n         let err_data = result::get_err(&rs_result);\n@@ -956,7 +956,7 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n     let stop_ch = oldcomm::Chan(&stop_po);\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n+    do iotask::interact(&(*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 => {\n@@ -984,7 +984,7 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n     let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n     let start_ch = oldcomm::Chan(&start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n-    do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n+    do iotask::interact(&(*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n         match uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n@@ -1024,7 +1024,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         result_ch: oldcomm::Chan(&result_po)\n     };\n     let write_data_ptr = ptr::addr_of(&write_data);\n-    do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| unsafe {\n+    do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| unsafe {\n         log(debug, fmt!(\"in interact cb for tcp::write %?\", loop_ptr));\n         match uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n@@ -1369,7 +1369,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_and_client() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8888u;\n         let expected_req = ~\"ping\";\n@@ -1381,6 +1381,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1389,7 +1390,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1415,7 +1416,7 @@ pub mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8887u;\n         let expected_resp = ~\"pong\";\n@@ -1426,6 +1427,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1434,7 +1436,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1445,10 +1447,11 @@ pub mod test {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let iotask = uv::global_loop::get();\n             let connect_result = connect(move server_ip_addr, server_port,\n-                                         iotask);\n+                                         &iotask);\n \n             let sock = result::unwrap(move connect_result);\n \n+            debug!(\"testing peer address\");\n             // This is what we are actually testing!\n             assert net::ip::format_addr(&sock.get_peer_addr()) ==\n                 ~\"127.0.0.1\";\n@@ -1457,12 +1460,14 @@ pub mod test {\n             // Fulfill the protocol the test server expects\n             let resp_bytes = str::to_bytes(~\"ping\");\n             tcp_write_single(&sock, resp_bytes);\n+            debug!(\"message sent\");\n             let read_result = sock.read(0u);\n             client_ch.send(str::from_bytes(read_result.get()));\n+            debug!(\"result read\");\n         };\n     }\n     pub fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8889u;\n         let expected_req = ~\"ping\";\n@@ -1482,7 +1487,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_address_in_use() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8890u;\n         let expected_req = ~\"ping\";\n@@ -1494,6 +1499,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1502,7 +1508,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1533,7 +1539,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_access_denied() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 80u;\n         // this one should fail..\n@@ -1553,7 +1559,7 @@ pub mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n \n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8891u;\n         let expected_req = ~\"ping\";\n@@ -1565,6 +1571,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let iotask_clone = iotask.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1573,7 +1580,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    iotask)\n+                    &iotask_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1604,7 +1611,7 @@ pub mod test {\n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n         use core::io::{Reader,ReaderUtil};\n \n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 10041u;\n         let expected_req = ~\"GET /\";\n@@ -1616,6 +1623,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1624,7 +1632,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1664,7 +1672,7 @@ pub mod test {\n     fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n                           server_ch: oldcomm::Chan<~str>,\n                           cont_ch: oldcomm::Chan<()>,\n-                          iotask: IoTask) -> ~str {\n+                          iotask: &IoTask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n                                    iotask,\n@@ -1751,7 +1759,7 @@ pub mod test {\n     }\n \n     fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n-                          iotask: IoTask) -> TcpListenErrData {\n+                                iotask: &IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n                                    iotask,\n@@ -1775,7 +1783,7 @@ pub mod test {\n \n     fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n                           client_ch: oldcomm::Chan<~str>,\n-                          iotask: IoTask) -> result::Result<~str,\n+                          iotask: &IoTask) -> result::Result<~str,\n                                                     TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n "}, {"sha": "0f0aa2a011eafca73448a81a69ae66e10fd6a10c", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -39,7 +39,7 @@ use core;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T: Owned>(iotask: IoTask,\n+pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: oldcomm::Chan<T>,\n                               val: T) {\n@@ -90,7 +90,7 @@ pub fn delayed_send<T: Owned>(iotask: IoTask,\n  * * `iotask` - a `uv::iotask` that the tcp request will run on\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n-pub fn sleep(iotask: IoTask, msecs: uint) {\n+pub fn sleep(iotask: &IoTask, msecs: uint) {\n     let exit_po = oldcomm::Port::<()>();\n     let exit_ch = oldcomm::Chan(&exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n@@ -117,7 +117,7 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `some(T)`. If not, then `none` will be returned.\n  */\n-pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n+pub fn recv_timeout<T: Copy Owned>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: oldcomm::Port<T>)\n                                 -> Option<T> {\n@@ -177,13 +177,13 @@ mod test {\n \n     #[test]\n     fn test_gl_timer_simple_sleep_test() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         sleep(hl_loop, 1u);\n     }\n \n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         for iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n@@ -193,7 +193,7 @@ mod test {\n     fn test_gl_timer_sleep_stress2() {\n         let po = oldcomm::Port();\n         let ch = oldcomm::Chan(&po);\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n \n         let repeat = 20u;\n         let spec = {\n@@ -208,11 +208,12 @@ mod test {\n \n             for spec.each |spec| {\n                 let (times, maxms) = *spec;\n+                let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use rand::*;\n                     let rng = Rng();\n                     for iter::repeat(times) {\n-                        sleep(hl_loop, rng.next() as uint % maxms);\n+                        sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n                     oldcomm::send(ch, ());\n                 }\n@@ -271,12 +272,12 @@ mod test {\n             let expected = rand::Rng().gen_str(16u);\n             let test_po = oldcomm::Port::<~str>();\n             let test_ch = oldcomm::Chan(&test_po);\n-\n+            let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {\n-                delayed_send(hl_loop, 50u, test_ch, expected);\n+                delayed_send(&hl_loop_clone, 50u, test_ch, expected);\n             };\n \n-            match recv_timeout(hl_loop, 1u, test_po) {\n+            match recv_timeout(&hl_loop, 1u, test_po) {\n               None => successes += 1,\n               _ => failures += 1\n             };"}, {"sha": "097e923225af17b9e937581e6060e0aaae173c0e", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -19,16 +19,16 @@ use uv_iotask::{IoTask, spawn_iotask};\n \n use core::either::{Left, Right};\n use core::libc;\n-use core::oldcomm::{Port, Chan, select2, listen};\n-use core::private::{chan_from_global_ptr, weaken_task};\n+use core::pipes::{Port, Chan, SharedChan, select2i};\n+use core::private::global::{global_data_clone_create,\n+                            global_data_clone};\n+use core::private::weak_task::weaken_task;\n use core::str;\n-use core::task::TaskBuilder;\n+use core::task::{task, SingleThreaded, spawn};\n use core::task;\n use core::vec;\n-\n-extern mod rustrt {\n-    unsafe fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n-}\n+use core::clone::Clone;\n+use core::option::{Some, None};\n \n /**\n  * Race-free helper to get access to a global task where a libuv\n@@ -49,64 +49,58 @@ pub fn get() -> IoTask {\n #[doc(hidden)]\n fn get_monitor_task_gl() -> IoTask unsafe {\n \n-    let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n+    type MonChan = Chan<IoTask>;\n \n-    debug!(\"ENTERING global_loop::get() loop chan: %?\",\n-           monitor_loop_chan_ptr);\n+    struct GlobalIoTask(IoTask);\n \n-    debug!(\"before priv::chan_from_global_ptr\");\n-    type MonChan = Chan<IoTask>;\n+    impl GlobalIoTask: Clone {\n+        fn clone(&self) -> GlobalIoTask {\n+            GlobalIoTask((**self).clone())\n+        }\n+    }\n \n-    let monitor_ch =\n-        do chan_from_global_ptr::<MonChan>(monitor_loop_chan_ptr,\n-                                           || {\n-                                                task::task().sched_mode\n-                                                (task::SingleThreaded)\n-                                                .unlinked()\n-                                           }) |msg_po| unsafe {\n-        debug!(\"global monitor task starting\");\n-\n-        // As a weak task the runtime will notify us when to exit\n-        do weaken_task() |weak_exit_po| {\n-            debug!(\"global monitor task is now weak\");\n-            let hl_loop = spawn_loop();\n-            loop {\n-                debug!(\"in outer_loop...\");\n-                match select2(weak_exit_po, msg_po) {\n-                  Left(weak_exit) => {\n-                    // all normal tasks have ended, tell the\n-                    // libuv loop to tear_down, then exit\n-                    debug!(\"weak_exit_po recv'd msg: %?\", weak_exit);\n-                    iotask::exit(hl_loop);\n-                    break;\n-                  }\n-                  Right(fetch_ch) => {\n-                    debug!(\"hl_loop req recv'd: %?\", fetch_ch);\n-                    fetch_ch.send(hl_loop);\n-                  }\n+    fn key(_: GlobalIoTask) { }\n+\n+    match global_data_clone(key) {\n+        Some(GlobalIoTask(iotask)) => iotask,\n+        None => {\n+            let iotask: IoTask = spawn_loop();\n+            let mut installed = false;\n+            let final_iotask = do global_data_clone_create(key) {\n+                installed = true;\n+                ~GlobalIoTask(iotask.clone())\n+            };\n+            if installed {\n+                do task().unlinked().spawn() unsafe {\n+                    debug!(\"global monitor task starting\");\n+                    // As a weak task the runtime will notify us when to exit\n+                    do weaken_task |weak_exit_po| {\n+                        debug!(\"global monitor task is now weak\");\n+                        weak_exit_po.recv();\n+                        iotask::exit(&iotask);\n+                        debug!(\"global monitor task is leaving weakend state\");\n+                    };\n+                    debug!(\"global monitor task exiting\");\n                 }\n+            } else {\n+                iotask::exit(&iotask);\n             }\n-            debug!(\"global monitor task is leaving weakend state\");\n-        };\n-        debug!(\"global monitor task exiting\");\n-    };\n \n-    // once we have a chan to the monitor loop, we ask it for\n-    // the libuv loop's async handle\n-    do listen |fetch_ch| {\n-        monitor_ch.send(fetch_ch);\n-        fetch_ch.recv()\n+            match final_iotask {\n+                GlobalIoTask(iotask) => iotask\n+            }\n+        }\n     }\n }\n \n fn spawn_loop() -> IoTask {\n-    let builder = do task::task().add_wrapper |task_body| {\n+    let builder = do task().add_wrapper |task_body| {\n         fn~(move task_body) {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             unsafe {\n-                do weaken_task |weak_exit_po| {\n-                    debug!(\"global libuv task is now weak %?\", weak_exit_po);\n+                do weaken_task |_| {\n+                    debug!(\"global libuv task is now weak\");\n                     task_body();\n \n                     // We don't wait for the exit message on weak_exit_po\n@@ -118,6 +112,7 @@ fn spawn_loop() -> IoTask {\n             }\n         }\n     };\n+    let builder = builder.unlinked();\n     spawn_iotask(move builder)\n }\n \n@@ -147,7 +142,7 @@ mod test {\n                              _status: libc::c_int) unsafe {\n         log(debug, ~\"in simple timer cb\");\n         ll::timer_stop(timer_ptr);\n-        let hl_loop = get_gl();\n+        let hl_loop = &get_gl();\n         do iotask::interact(hl_loop) |_loop_ptr| unsafe {\n             log(debug, ~\"closing timer\");\n             ll::close(timer_ptr, simple_timer_close_cb);\n@@ -157,7 +152,7 @@ mod test {\n         log(debug, ~\"exiting simple timer cb\");\n     }\n \n-    fn impl_uv_hl_simple_timer(iotask: IoTask) unsafe {\n+    fn impl_uv_hl_simple_timer(iotask: &IoTask) unsafe {\n         let exit_po = oldcomm::Port::<bool>();\n         let exit_ch = oldcomm::Chan(&exit_po);\n         let exit_ch_ptr = ptr::addr_of(&exit_ch);\n@@ -190,10 +185,11 @@ mod test {\n \n     #[test]\n     fn test_gl_uv_global_loop_high_level_global_timer() unsafe {\n-        let hl_loop = get_gl();\n+        let hl_loop = &get_gl();\n         let exit_po = oldcomm::Port::<()>();\n         let exit_ch = oldcomm::Chan(&exit_po);\n         task::spawn_sched(task::ManualThreads(1u), || {\n+            let hl_loop = &get_gl();\n             impl_uv_hl_simple_timer(hl_loop);\n             oldcomm::send(exit_ch, ());\n         });\n@@ -206,12 +202,12 @@ mod test {\n     #[test]\n     #[ignore]\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n-        let hl_loop = get_gl();\n         let exit_po = oldcomm::Port::<()>();\n         let exit_ch = oldcomm::Chan(&exit_po);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n             task::spawn_sched(task::ManualThreads(1u), || {\n+                let hl_loop = &get_gl();\n                 impl_uv_hl_simple_timer(hl_loop);\n                 oldcomm::send(exit_ch, ());\n             });"}, {"sha": "c50a19cc5c17c7ed588b1b6cd55ce392ab019944", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -20,7 +20,7 @@ use ll = uv_ll;\n \n use core::libc::c_void;\n use core::libc;\n-use core::oldcomm::{Port, Chan, listen};\n+use core::pipes::{stream, Port, Chan, SharedChan};\n use core::prelude::*;\n use core::ptr::addr_of;\n use core::task::TaskBuilder;\n@@ -30,22 +30,30 @@ use core::task;\n pub enum IoTask {\n     IoTask_({\n         async_handle: *ll::uv_async_t,\n-        op_chan: Chan<IoTaskMsg>\n+        op_chan: SharedChan<IoTaskMsg>\n     })\n }\n \n+impl IoTask: Clone {\n+    fn clone(&self) -> IoTask {\n+        IoTask_({\n+            async_handle: self.async_handle,\n+            op_chan: self.op_chan.clone()\n+        })\n+    }\n+}\n+\n pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n \n-    do listen |iotask_ch| {\n+    let (iotask_port, iotask_chan) = stream();\n \n-        do task.sched_mode(task::SingleThreaded).spawn {\n-            debug!(\"entering libuv task\");\n-            run_loop(iotask_ch);\n-            debug!(\"libuv task exiting\");\n-        };\n+    do task.sched_mode(task::SingleThreaded).spawn {\n+        debug!(\"entering libuv task\");\n+        run_loop(&iotask_chan);\n+        debug!(\"libuv task exiting\");\n+    };\n \n-        iotask_ch.recv()\n-    }\n+    iotask_port.recv()\n }\n \n \n@@ -71,7 +79,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-pub unsafe fn interact(iotask: IoTask,\n+pub unsafe fn interact(iotask: &IoTask,\n                    cb: fn~(*c_void)) {\n     send_msg(iotask, Interaction(move cb));\n }\n@@ -83,7 +91,7 @@ pub unsafe fn interact(iotask: IoTask,\n  * async handle and do a sanity check to make sure that all other handles are\n  * closed, causing a failure otherwise.\n  */\n-pub fn exit(iotask: IoTask) unsafe {\n+pub fn exit(iotask: &IoTask) unsafe {\n     send_msg(iotask, TeardownLoop);\n }\n \n@@ -96,8 +104,9 @@ enum IoTaskMsg {\n }\n \n /// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: Chan<IoTask>) unsafe {\n+fn run_loop(iotask_ch: &Chan<IoTask>) unsafe {\n \n+    debug!(\"creating loop\");\n     let loop_ptr = ll::loop_new();\n \n     // set up the special async handle we'll use to allow multi-task\n@@ -108,18 +117,20 @@ fn run_loop(iotask_ch: Chan<IoTask>) unsafe {\n     // associate the async handle with the loop\n     ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n+    let (msg_po, msg_ch) = stream::<IoTaskMsg>();\n+\n     // initialize our loop data and store it in the loop\n     let data: IoTaskLoopData = {\n         async_handle: async_handle,\n-        msg_po: Port()\n+        msg_po: msg_po\n     };\n     ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n \n     // Send out a handle through which folks can talk to us\n     // while we dwell in the I/O loop\n     let iotask = IoTask_({\n         async_handle: async_handle,\n-        op_chan: data.msg_po.chan()\n+        op_chan: SharedChan(msg_ch)\n     });\n     iotask_ch.send(iotask);\n \n@@ -136,7 +147,7 @@ type IoTaskLoopData = {\n     msg_po: Port<IoTaskMsg>\n };\n \n-fn send_msg(iotask: IoTask,\n+fn send_msg(iotask: &IoTask,\n             msg: IoTaskMsg) unsafe {\n     iotask.op_chan.send(move msg);\n     ll::async_send(iotask.async_handle);\n@@ -151,7 +162,7 @@ extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n \n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *IoTaskLoopData;\n-    let msg_po = (*data).msg_po;\n+    let msg_po = &(*data).msg_po;\n \n     while msg_po.peek() {\n         match msg_po.recv() {\n@@ -203,34 +214,37 @@ mod test {\n         iotask: IoTask,\n         exit_ch: oldcomm::Chan<()>\n     };\n-    fn impl_uv_iotask_async(iotask: IoTask) unsafe {\n+    fn impl_uv_iotask_async(iotask: &IoTask) unsafe {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(&async_handle);\n         let exit_po = oldcomm::Port::<()>();\n         let exit_ch = oldcomm::Chan(&exit_po);\n         let ah_data = {\n-            iotask: iotask,\n+            iotask: iotask.clone(),\n             exit_ch: exit_ch\n         };\n-        let ah_data_ptr = ptr::addr_of(&ah_data);\n+        let ah_data_ptr: *AhData = ptr::to_unsafe_ptr(&ah_data);\n+        debug!(\"about to interact\");\n         do interact(iotask) |loop_ptr| unsafe {\n+            debug!(\"interacting\");\n             ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n         };\n+        debug!(\"waiting for async close\");\n         oldcomm::recv(exit_po);\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n     unsafe fn spawn_test_loop(exit_ch: oldcomm::Chan<()>) -> IoTask {\n-        let iotask_port = oldcomm::Port::<IoTask>();\n-        let iotask_ch = oldcomm::Chan(&iotask_port);\n+        let (iotask_port, iotask_ch) = stream::<IoTask>();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            run_loop(iotask_ch);\n+            debug!(\"about to run a test loop\");\n+            run_loop(&iotask_ch);\n             exit_ch.send(());\n         };\n-        return oldcomm::recv(iotask_port);\n+        return iotask_port.recv();\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n@@ -247,7 +261,9 @@ mod test {\n     fn test_uv_iotask_async() unsafe {\n         let exit_po = oldcomm::Port::<()>();\n         let exit_ch = oldcomm::Chan(&exit_po);\n-        let iotask = spawn_test_loop(exit_ch);\n+        let iotask = &spawn_test_loop(exit_ch);\n+\n+        debug!(\"spawned iotask\");\n \n         // using this handle to manage the lifetime of the high_level_loop,\n         // as it will exit the first time one of the impl_uv_hl_async() is\n@@ -258,12 +274,16 @@ mod test {\n         let work_exit_po = oldcomm::Port::<()>();\n         let work_exit_ch = oldcomm::Chan(&work_exit_po);\n         for iter::repeat(7u) {\n+            let iotask_clone = iotask.clone();\n             do task::spawn_sched(task::ManualThreads(1u)) {\n-                impl_uv_iotask_async(iotask);\n+                debug!(\"async\");\n+                impl_uv_iotask_async(&iotask_clone);\n+                debug!(\"done async\");\n                 oldcomm::send(work_exit_ch, ());\n             };\n         };\n         for iter::repeat(7u) {\n+            debug!(\"waiting\");\n             oldcomm::recv(work_exit_po);\n         };\n         log(debug, ~\"sending teardown_loop msg..\");"}, {"sha": "8ca49ea6a57c3eaa77023e538f52cde18c4a7634", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -34,7 +34,6 @@ rust_kernel::rust_kernel(rust_env *env) :\n     sched_reaper(this),\n     osmain_driver(NULL),\n     non_weak_tasks(0),\n-    global_loop_chan(0),\n     at_exit_runner(NULL),\n     at_exit_started(false),\n     env(env),"}, {"sha": "8ba0405b86e0771422635104fcb7c4b21947040c", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -129,9 +129,6 @@ class rust_kernel {\n     void end_weak_tasks();\n     void begin_shutdown();\n \n-    // Used to communicate with the process-side, global libuv loop\n-    uintptr_t global_loop_chan;\n-\n     lock_and_signal at_exit_lock;\n     spawn_fn at_exit_runner;\n     bool at_exit_started;\n@@ -190,8 +187,6 @@ class rust_kernel {\n \n     bool send_to_port(rust_port_id chan, void *sptr);\n \n-    uintptr_t* get_global_loop() { return &global_loop_chan; }\n-\n     void register_exit_function(spawn_fn runner, fn_env_pair *f);\n };\n "}, {"sha": "2dc70088628f6aa9176d2e2e10c1df60961b5c59", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -513,15 +513,6 @@ rust_uv_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n-extern \"C\" uintptr_t*\n-rust_uv_get_kernel_global_chan_ptr() {\n-    uintptr_t* result = rust_get_current_task()->kernel->get_global_loop();\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib, \"global loop: %lu\", (unsigned long int)result);\n-    LOG(task, stdlib,\"global loop val: %lu\", (unsigned long int)*result);\n-    return result;\n-}\n-\n extern \"C\" void*\n rust_uv_current_kernel_malloc(size_t size) {\n     return current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");"}, {"sha": "8e8ce9ee509e29eb588e70b41f11049af2f3ffe3", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -158,7 +158,6 @@ rust_uv_get_data_for_req\n rust_uv_set_data_for_req\n rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n-rust_uv_get_kernel_global_chan_ptr\n rust_uv_current_kernel_malloc\n rust_uv_current_kernel_free\n rust_uv_getaddrinfo"}, {"sha": "10b13d8757fa2a251339eae34b2c41fb2cf4b2ee", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -27,7 +27,7 @@ proto! oneshot (\n )\n \n fn main() {\n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     \n     pipes::spawn_service(oneshot::init, |p| { \n         match try_recv(move p) {"}, {"sha": "e138f2562aaefbaeb4a2a3c67fb354a4da875042", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     use oneshot::client::*;\n     use stream::client::*;\n \n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     \n     let c = pipes::spawn_service(stream::init, |p| { \n         error!(\"waiting for pipes\");"}, {"sha": "ae7e4e7fb0ca7d6fd06408adce78d6576a7f12a6", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9608fe4232c4014daa540849d471b1791b41fa6/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=b9608fe4232c4014daa540849d471b1791b41fa6", "patch": "@@ -27,7 +27,7 @@ fn main() {\n \n     let c = pipes::spawn_service(oneshot::init, |p| { recv(move p); });\n \n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     sleep(iotask, 500);\n     \n     signal(move c);"}]}