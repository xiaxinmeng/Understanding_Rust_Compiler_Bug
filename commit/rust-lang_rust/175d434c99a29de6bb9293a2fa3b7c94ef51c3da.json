{"sha": "175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NWQ0MzRjOTlhMjlkZTZiYjkyOTNhMmZhM2I3Yzk0ZWY1MWMzZGE=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-08-29T21:12:08Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-08-29T21:12:08Z"}, "message": "Remove BinaryHeap bounds checking", "tree": {"sha": "f6afa4cfe4259853dcc46ffb975f82fa9b47e2f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6afa4cfe4259853dcc46ffb975f82fa9b47e2f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "html_url": "https://github.com/rust-lang/rust/commit/175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/175d434c99a29de6bb9293a2fa3b7c94ef51c3da/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86dde9bbda92c02c61282b5df5d38338a798ef3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/86dde9bbda92c02c61282b5df5d38338a798ef3b", "html_url": "https://github.com/rust-lang/rust/commit/86dde9bbda92c02c61282b5df5d38338a798ef3b"}], "stats": {"total": 43, "additions": 23, "deletions": 20}, "files": [{"sha": "0b923468c7416164611e935c4d579ccfed4b61ea", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/175d434c99a29de6bb9293a2fa3b7c94ef51c3da/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175d434c99a29de6bb9293a2fa3b7c94ef51c3da/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "patch": "@@ -884,58 +884,61 @@ struct Hole<'a, T: 'a> {\n \n impl<'a, T> Hole<'a, T> {\n     /// Create a new Hole at index `pos`.\n-    fn new(data: &'a mut [T], pos: usize) -> Self {\n-        unsafe {\n-            let elt = ptr::read(&data[pos]);\n-            Hole {\n-                data: data,\n-                elt: Some(elt),\n-                pos: pos,\n-            }\n+    ///\n+    /// Unsafe because pos must be within the data slice.\n+    #[inline]\n+    unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n+        debug_assert!(pos < data.len());\n+        let elt = ptr::read(&data[pos]);\n+        Hole {\n+            data: data,\n+            elt: Some(elt),\n+            pos: pos,\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn pos(&self) -> usize {\n         self.pos\n     }\n \n     /// Return a reference to the element removed\n-    #[inline(always)]\n+    #[inline]\n     fn element(&self) -> &T {\n         self.elt.as_ref().unwrap()\n     }\n \n     /// Return a reference to the element at `index`.\n     ///\n-    /// Panics if the index is out of bounds.\n-    ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n-        &self.data[index]\n+        debug_assert!(index < self.data.len());\n+        self.data.get_unchecked(index)\n     }\n \n     /// Move hole to new location\n     ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n-        let index_ptr: *const _ = &self.data[index];\n-        let hole_ptr = &mut self.data[self.pos];\n+        debug_assert!(index < self.data.len());\n+        let index_ptr: *const _ = self.data.get_unchecked(index);\n+        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n         ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n         self.pos = index;\n     }\n }\n \n impl<'a, T> Drop for Hole<'a, T> {\n+    #[inline]\n     fn drop(&mut self) {\n         // fill the hole again\n         unsafe {\n             let pos = self.pos;\n-            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+            ptr::write(self.data.get_unchecked_mut(pos), self.elt.take().unwrap());\n         }\n     }\n }"}]}