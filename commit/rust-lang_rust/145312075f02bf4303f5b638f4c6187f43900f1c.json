{"sha": "145312075f02bf4303f5b638f4c6187f43900f1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NTMxMjA3NWYwMmJmNDMwM2Y1YjYzOGY0YzYxODdmNDM5MDBmMWM=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-10-17T05:49:11Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-11T01:58:53Z"}, "message": "Add helper function for Capture Esclations and expressions\n\nCo-authored-by: Dhruv Jauhar <dhruvjhr@gmail.com>", "tree": {"sha": "1a8180f5742af1ab55f0de94bed55e2b4e1e16a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a8180f5742af1ab55f0de94bed55e2b4e1e16a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/145312075f02bf4303f5b638f4c6187f43900f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/145312075f02bf4303f5b638f4c6187f43900f1c", "html_url": "https://github.com/rust-lang/rust/commit/145312075f02bf4303f5b638f4c6187f43900f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/145312075f02bf4303f5b638f4c6187f43900f1c/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58e8f8fd2cac4cfcde6c7a1488dd8657dcacaad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/58e8f8fd2cac4cfcde6c7a1488dd8657dcacaad8", "html_url": "https://github.com/rust-lang/rust/commit/58e8f8fd2cac4cfcde6c7a1488dd8657dcacaad8"}], "stats": {"total": 177, "additions": 110, "deletions": 67}, "files": [{"sha": "52b49184cf1869a1d82ff9c60c42d923279f060f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/145312075f02bf4303f5b638f4c6187f43900f1c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145312075f02bf4303f5b638f4c6187f43900f1c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=145312075f02bf4303f5b638f4c6187f43900f1c", "patch": "@@ -765,7 +765,23 @@ pub struct UpvarBorrow<'tcx> {\n \n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n pub struct CaptureInfo<'tcx> {\n-    /// Expr Id pointing to use that resulting in selecting the current capture kind\n+    /// Expr Id pointing to use that resulted in selecting the current capture kind\n+    ///\n+    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n+    /// possible that we don't see the use of a particular place resulting in expr_id being\n+    /// None. In such case we fallback on uvpars_mentioned for span.\n+    ///\n+    /// Eg:\n+    /// ```rust\n+    /// let x = ...;\n+    ///\n+    /// let c = || {\n+    ///     let _ = x\n+    /// }\n+    /// ```\n+    ///\n+    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n+    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n     pub expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected"}, {"sha": "6365797148547b5fe7504a6b211295300425ba8a", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 84, "deletions": 64, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/145312075f02bf4303f5b638f4c6187f43900f1c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/145312075f02bf4303f5b638f4c6187f43900f1c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=145312075f02bf4303f5b638f4c6187f43900f1c", "patch": "@@ -284,30 +284,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let var_hir_id = upvar_id.var_path.hir_id;\n             closure_captures.insert(var_hir_id, upvar_id);\n \n-            let mut new_capture_kind = capture_info.capture_kind;\n-            if let Some(existing_capture_kind) =\n+            let new_capture_kind = if let Some(capture_kind) =\n                 self.typeck_results.borrow_mut().upvar_capture_map.get(&upvar_id)\n             {\n-                // FIXME(@azhng): refactor this later\n-                new_capture_kind = match (existing_capture_kind, new_capture_kind) {\n-                    (ty::UpvarCapture::ByValue(Some(_)), _) => *existing_capture_kind,\n-                    (_, ty::UpvarCapture::ByValue(Some(_))) => new_capture_kind,\n-                    (ty::UpvarCapture::ByValue(_), _) | (_, ty::UpvarCapture::ByValue(_)) => {\n-                        ty::UpvarCapture::ByValue(None)\n-                    }\n-                    (ty::UpvarCapture::ByRef(existing_ref), ty::UpvarCapture::ByRef(new_ref)) => {\n-                        match (existing_ref.kind, new_ref.kind) {\n-                            // Take RHS:\n-                            (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n-                            | (ty::UniqueImmBorrow, ty::MutBorrow) => new_capture_kind,\n-                            // Take LHS:\n-                            (ty::ImmBorrow, ty::ImmBorrow)\n-                            | (ty::UniqueImmBorrow, ty::ImmBorrow | ty::UniqueImmBorrow)\n-                            | (ty::MutBorrow, _) => *existing_capture_kind,\n-                        }\n-                    }\n-                };\n-            }\n+                // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n+                // so we create a fake capture info with no expression.\n+                let fake_capture_info =\n+                    ty::CaptureInfo { expr_id: None, capture_kind: capture_kind.clone() };\n+                self.determine_capture_info(fake_capture_info, capture_info.clone()).capture_kind\n+            } else {\n+                capture_info.capture_kind\n+            };\n             self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, new_capture_kind);\n         }\n \n@@ -353,6 +340,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn should_log_capture_analysis(&self, closure_def_id: DefId) -> bool {\n         self.tcx.has_attr(closure_def_id, sym::rustc_capture_analysis)\n     }\n+\n+    /// Helper function to determine if we need to escalate CaptureKind from\n+    /// CaptureInfo A to B and returns the escalated CaptureInfo.\n+    /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n+    ///\n+    /// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n+    /// on the `CaptureInfo` containing an associated expression id.\n+    ///\n+    /// If both the CaptureKind and Expression are considered to be equivalent,\n+    /// then `CaptureInfo` A is preferred.\n+    fn determine_capture_info(\n+        &self,\n+        capture_info_a: ty::CaptureInfo<'tcx>,\n+        capture_info_b: ty::CaptureInfo<'tcx>,\n+    ) -> ty::CaptureInfo<'tcx> {\n+        // If the capture kind is equivalent then, we don't need to escalate and can compare the\n+        // expressions.\n+        let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+            (ty::UpvarCapture::ByValue(_), ty::UpvarCapture::ByValue(_)) => true,\n+            (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+                ref_a.kind == ref_b.kind\n+            }\n+            _ => false,\n+        };\n+\n+        if eq_capture_kind {\n+            match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+                (Some(_), _) | (None, None) => capture_info_a,\n+                (None, Some(_)) => capture_info_b,\n+            }\n+        } else {\n+            match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+                (ty::UpvarCapture::ByValue(_), _) => capture_info_a,\n+                (_, ty::UpvarCapture::ByValue(_)) => capture_info_b,\n+                (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+                    match (ref_a.kind, ref_b.kind) {\n+                        // Take LHS:\n+                        (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n+                        | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n+\n+                        // Take RHS:\n+                        (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n+                        | (ty::UniqueImmBorrow, ty::MutBorrow) => capture_info_b,\n+\n+                        (ty::ImmBorrow, ty::ImmBorrow)\n+                        | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n+                        | (ty::MutBorrow, ty::MutBorrow) => {\n+                            bug!(\"Expected unequal capture kinds\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {\n@@ -426,16 +467,10 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n         };\n \n-        let curr_info = self.capture_information.get(&place_with_id.place);\n-        let updated_info = match curr_info {\n-            Some(info) => match info.capture_kind {\n-                ty::UpvarCapture::ByRef(_) | ty::UpvarCapture::ByValue(None) => capture_info,\n-                _ => *info,\n-            },\n-            None => capture_info,\n-        };\n+        let curr_info = self.capture_information[&place_with_id.place];\n+        let updated_info = self.fcx.determine_capture_info(curr_info, capture_info);\n \n-        self.capture_information.insert(place_with_id.place.clone(), updated_info);\n+        self.capture_information[&place_with_id.place] = updated_info;\n     }\n \n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n@@ -532,42 +567,28 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         diag_expr_id: hir::HirId,\n         kind: ty::BorrowKind,\n     ) {\n-        let capture_info = self\n-            .capture_information\n-            .get(&place_with_id.place)\n-            .unwrap_or_else(|| bug!(\"Upar capture info missing\"));\n-        // We init capture_information for each element\n+        let curr_capture_info = self.capture_information[&place_with_id.place];\n \n         debug!(\n-            \"adjust_upvar_borrow_kind(place={:?}, , diag_expr_id={:?}, capture_info={:?}, kind={:?})\",\n-            place_with_id, diag_expr_id, capture_info, kind\n+            \"adjust_upvar_borrow_kind(place={:?}, diag_expr_id={:?}, capture_info={:?}, kind={:?})\",\n+            place_with_id, diag_expr_id, curr_capture_info, kind\n         );\n \n-        match capture_info.capture_kind {\n-            ty::UpvarCapture::ByValue(_) => {\n-                // Upvar is already by-value, the strongest criteria.\n-            }\n-            ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                match (upvar_borrow.kind, kind) {\n-                    // Take RHS:\n-                    (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n-                    | (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-                        if let Some(ty::CaptureInfo { expr_id, capture_kind }) =\n-                            self.capture_information.get_mut(&place_with_id.place)\n-                        {\n-                            *expr_id = Some(diag_expr_id);\n-                            if let ty::UpvarCapture::ByRef(borrow_kind) = capture_kind {\n-                                borrow_kind.kind = kind;\n-                            }\n-                        }\n-                    }\n-                    // Take LHS:\n-                    (ty::ImmBorrow, ty::ImmBorrow)\n-                    | (ty::UniqueImmBorrow, ty::ImmBorrow | ty::UniqueImmBorrow)\n-                    | (ty::MutBorrow, _) => {}\n-                }\n-            }\n-        }\n+        if let ty::UpvarCapture::ByValue(_) = curr_capture_info.capture_kind {\n+            // It's already captured by value, we don't need to do anything here\n+            return;\n+        } else if let ty::UpvarCapture::ByRef(curr_upvar_borrow) = curr_capture_info.capture_kind {\n+            // Use the same region as the current capture information\n+            // Doesn't matter since only one of the UpvarBorrow will be used.\n+            let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n+\n+            let capture_info = ty::CaptureInfo {\n+                expr_id: Some(diag_expr_id),\n+                capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n+            };\n+            let updated_info = self.fcx.determine_capture_info(curr_capture_info, capture_info);\n+            self.capture_information[&place_with_id.place] = updated_info;\n+        };\n     }\n \n     fn adjust_closure_kind(\n@@ -622,7 +643,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             debug!(\"Capturing new place {:?}\", place_with_id);\n \n-            let tcx = self.fcx.tcx;\n             let capture_kind =\n                 self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n "}, {"sha": "3e352e2c52584987f98a69985d54946d0fc754d5", "filename": "src/test/ui/closures/2229_closure_analysis/slice-pat.stdout", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/145312075f02bf4303f5b638f4c6187f43900f1c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fslice-pat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/145312075f02bf4303f5b638f4c6187f43900f1c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fslice-pat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fslice-pat.stdout?ref=145312075f02bf4303f5b638f4c6187f43900f1c", "patch": "@@ -12,9 +12,16 @@ For closure=DefId(0:5 ~ slice_pat[317d]::main::{closure#0}): capture information\n             },\n         ],\n     }: CaptureInfo {\n-        expr_id: None,\n+        expr_id: Some(\n+            HirId {\n+                owner: DefId(0:3 ~ slice_pat[317d]::main),\n+                local_id: 179,\n+            },\n+        ),\n         capture_kind: ByValue(\n-            None,\n+            Some(\n+                $DIR/slice-pat.rs:21:33: 21:36 (#0),\n+            ),\n         ),\n     },\n }"}]}