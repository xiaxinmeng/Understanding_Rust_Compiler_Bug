{"sha": "60a4a2db8837be91bdae051bd51ab181077e5dc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYTRhMmRiODgzN2JlOTFiZGFlMDUxYmQ1MWFiMTgxMDc3ZTVkYzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-12T19:59:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-15T06:23:54Z"}, "message": "std: Remove ?Sized bounds from many I/O functions\n\nIt is a frequent pattern among I/O functions to take `P: AsPath + ?Sized` or\n`AsOsStr` instead of `AsPath`. Most of these functions do not need to take\nownership of their argument, but for libraries in general it's much more\nergonomic to not deal with `?Sized` at all and simply require an argument `P`\ninstead of `&P`.\n\nThis change is aimed at removing unsightly `?Sized` bounds while retaining the\nsame level of usability as before. All affected functions now take ownership of\ntheir arguments instead of taking them by reference, but due to the forwarding\nimplementations of `AsOsStr` and `AsPath` all code should continue to work as it\ndid before.\n\nThis is strictly speaking a breaking change due to the signatures of these\nfunctions changing, but normal idiomatic usage of these APIs should not break in\npractice.\n\n[breaking-change]", "tree": {"sha": "8eac4a81dd3e5437434c791cee3aa76204e20e9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eac4a81dd3e5437434c791cee3aa76204e20e9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a4a2db8837be91bdae051bd51ab181077e5dc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a4a2db8837be91bdae051bd51ab181077e5dc6", "html_url": "https://github.com/rust-lang/rust/commit/60a4a2db8837be91bdae051bd51ab181077e5dc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a4a2db8837be91bdae051bd51ab181077e5dc6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66853af9af79fdc4fb8e659c8b1f890918749d5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/66853af9af79fdc4fb8e659c8b1f890918749d5f", "html_url": "https://github.com/rust-lang/rust/commit/66853af9af79fdc4fb8e659c8b1f890918749d5f"}], "stats": {"total": 82, "additions": 39, "deletions": 43}, "files": [{"sha": "d072d1f102b3f3904afccfdb835fbb216c9c033c", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=60a4a2db8837be91bdae051bd51ab181077e5dc6", "patch": "@@ -124,7 +124,7 @@ impl File {\n     /// This function will return an error if `path` does not already exist.\n     /// Other errors may also be returned according to `OpenOptions::open`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n+    pub fn open<P: AsPath>(path: P) -> io::Result<File> {\n         OpenOptions::new().read(true).open(path)\n     }\n \n@@ -135,7 +135,7 @@ impl File {\n     ///\n     /// See the `OpenOptions::open` function for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn create<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n+    pub fn create<P: AsPath>(path: P) -> io::Result<File> {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path)\n     }\n \n@@ -297,7 +297,7 @@ impl OpenOptions {\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath + ?Sized>(&self, path: &P) -> io::Result<File> {\n+    pub fn open<P: AsPath>(&self, path: P) -> io::Result<File> {\n         let path = path.as_path();\n         let inner = try!(fs_imp::File::open(path, &self.0));\n         Ok(File { path: path.to_path_buf(), inner: inner })\n@@ -410,7 +410,7 @@ impl DirEntry {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+pub fn remove_file<P: AsPath>(path: P) -> io::Result<()> {\n     fs_imp::unlink(path.as_path())\n }\n \n@@ -438,7 +438,7 @@ pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// permissions to perform a `metadata` call on the given `path` or if there\n /// is no entry in the filesystem at the provided path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> {\n+pub fn metadata<P: AsPath>(path: P) -> io::Result<Metadata> {\n     fs_imp::stat(path.as_path()).map(Metadata)\n }\n \n@@ -459,8 +459,7 @@ pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> {\n /// reside on separate filesystems, or if some other intermittent I/O error\n /// occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n-                                                      -> io::Result<()> {\n+pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n     fs_imp::rename(from.as_path(), to.as_path())\n }\n \n@@ -490,9 +489,9 @@ pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n /// * The current process does not have the permission rights to access\n ///   `from` or write `to`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n-                                                    -> io::Result<u64> {\n+pub fn copy<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<u64> {\n     let from = from.as_path();\n+    let to = to.as_path();\n     if !from.is_file() {\n         return Err(Error::new(ErrorKind::MismatchedFileTypeForOperation,\n                               \"the source path is not an existing file\",\n@@ -513,17 +512,15 @@ pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn hard_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n-                                                         -> io::Result<()> {\n+pub fn hard_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::link(src.as_path(), dst.as_path())\n }\n \n /// Creates a new soft link on the filesystem.\n ///\n /// The `dst` path will be a soft link pointing to the `src` path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n-                                                         -> io::Result<()> {\n+pub fn soft_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::symlink(src.as_path(), dst.as_path())\n }\n \n@@ -535,7 +532,7 @@ pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n /// reading a file that does not exist or reading a file that is not a soft\n /// link.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> {\n+pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_path())\n }\n \n@@ -554,7 +551,7 @@ pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> {\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+pub fn create_dir<P: AsPath>(path: P) -> io::Result<()> {\n     fs_imp::mkdir(path.as_path())\n }\n \n@@ -568,7 +565,7 @@ pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n     let path = path.as_path();\n     if path.is_dir() { return Ok(()) }\n     if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n@@ -590,7 +587,7 @@ pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+pub fn remove_dir<P: AsPath>(path: P) -> io::Result<()> {\n     fs_imp::rmdir(path.as_path())\n }\n \n@@ -604,7 +601,7 @@ pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n ///\n /// See `file::remove_file` and `fs::remove_dir`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n+pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n     let path = path.as_path();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n@@ -657,7 +654,7 @@ pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> {\n+pub fn read_dir<P: AsPath>(path: P) -> io::Result<ReadDir> {\n     fs_imp::readdir(path.as_path()).map(ReadDir)\n }\n \n@@ -673,7 +670,7 @@ pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> {\n            reason = \"the precise semantics and defaults for a recursive walk \\\n                      may change and this may end up accounting for files such \\\n                      as symlinks differently\")]\n-pub fn walk_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<WalkDir> {\n+pub fn walk_dir<P: AsPath>(path: P) -> io::Result<WalkDir> {\n     let start = try!(read_dir(path));\n     Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n }\n@@ -759,8 +756,8 @@ impl PathExt for Path {\n            reason = \"the argument type of u64 is not quite appropriate for \\\n                      this function and may change if the standard library \\\n                      gains a type to represent a moment in time\")]\n-pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,\n-                                          modified: u64) -> io::Result<()> {\n+pub fn set_file_times<P: AsPath>(path: P, accessed: u64,\n+                                 modified: u64) -> io::Result<()> {\n     fs_imp::utimes(path.as_path(), accessed, modified)\n }\n \n@@ -788,8 +785,7 @@ pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,\n            reason = \"a more granual ability to set specific permissions may \\\n                      be exposed on the Permissions structure itself and this \\\n                      method may not always exist\")]\n-pub fn set_permissions<P: AsPath + ?Sized>(path: &P, perm: Permissions)\n-                                           -> io::Result<()> {\n+pub fn set_permissions<P: AsPath>(path: P, perm: Permissions) -> io::Result<()> {\n     fs_imp::set_perm(path.as_path(), perm.0)\n }\n "}, {"sha": "3082e63b8185204e4993da2867463ffcb5051960", "filename": "src/libstd/path.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=60a4a2db8837be91bdae051bd51ab181077e5dc6", "patch": "@@ -877,7 +877,7 @@ impl PathBuf {\n     /// Allocate a `PathBuf` with initial contents given by the\n     /// argument.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> PathBuf {\n+    pub fn new<S: AsOsStr>(s: S) -> PathBuf {\n         PathBuf { inner: s.as_os_str().to_os_string() }\n     }\n \n@@ -891,7 +891,7 @@ impl PathBuf {\n     ///   replaces everything except for the prefix (if any) of `self`.\n     /// * if `path` has a prefix but no root, it replaces `self.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n+    pub fn push<P: AsPath>(&mut self, path: P) {\n         let path = path.as_path();\n \n         // in general, a separator is needed if the rightmost byte is not a separator\n@@ -959,7 +959,7 @@ impl PathBuf {\n     /// assert!(buf == PathBuf::new(\"/baz.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_file_name<S: ?Sized>(&mut self, file_name: &S) where S: AsOsStr {\n+    pub fn set_file_name<S: AsOsStr>(&mut self, file_name: S) {\n         if self.file_name().is_some() {\n             let popped = self.pop();\n             debug_assert!(popped);\n@@ -974,7 +974,7 @@ impl PathBuf {\n     /// Otherwise, returns `true`; if `self.extension()` is `None`, the extension\n     /// is added; otherwise it is replaced.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool {\n+    pub fn set_extension<S: AsOsStr>(&mut self, extension: S) -> bool {\n         if self.file_name().is_none() { return false; }\n \n         let mut stem = match self.file_stem() {\n@@ -1000,17 +1000,17 @@ impl PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n-    fn from_iter<I: IntoIterator<Item = &'a P>>(iter: I) -> PathBuf {\n+impl<P: AsPath> iter::FromIterator<P> for PathBuf {\n+    fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n         let mut buf = PathBuf::new(\"\");\n         buf.extend(iter);\n         buf\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n-    fn extend<I: IntoIterator<Item = &'a P>>(&mut self, iter: I) {\n+impl<P: AsPath> iter::Extend<P> for PathBuf {\n+    fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n         for p in iter {\n             self.push(p)\n         }\n@@ -1253,13 +1253,13 @@ impl Path {\n \n     /// Determines whether `base` is a prefix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<P: ?Sized>(&self, base: &P) -> bool where P: AsPath {\n+    pub fn starts_with<P: AsPath>(&self, base: P) -> bool {\n         iter_after(self.components(), base.as_path().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<P: ?Sized>(&self, child: &P) -> bool where P: AsPath {\n+    pub fn ends_with<P: AsPath>(&self, child: P) -> bool {\n         iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n     }\n \n@@ -1293,7 +1293,7 @@ impl Path {\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join<P: ?Sized>(&self, path: &P) -> PathBuf where P: AsPath {\n+    pub fn join<P: AsPath>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.push(path);\n         buf\n@@ -1303,7 +1303,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_file_name<S: ?Sized>(&self, file_name: &S) -> PathBuf where S: AsOsStr {\n+    pub fn with_file_name<S: AsOsStr>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_file_name(file_name);\n         buf\n@@ -1313,7 +1313,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_extension` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_extension<S: ?Sized>(&self, extension: &S) -> PathBuf where S: AsOsStr {\n+    pub fn with_extension<S: AsOsStr>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_extension(extension);\n         buf"}, {"sha": "c344cbe08625206c4318528051aa8bb5180182c9", "filename": "src/libstd/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=60a4a2db8837be91bdae051bd51ab181077e5dc6", "patch": "@@ -147,7 +147,7 @@ impl Command {\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn new<S: AsOsStr + ?Sized>(program: &S) -> Command {\n+    pub fn new<S: AsOsStr>(program: S) -> Command {\n         Command {\n             inner: CommandImp::new(program.as_os_str()),\n             stdin: None,\n@@ -158,7 +158,7 @@ impl Command {\n \n     /// Add an argument to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn arg<S: AsOsStr + ?Sized>(&mut self, arg: &S) -> &mut Command {\n+    pub fn arg<S: AsOsStr>(&mut self, arg: S) -> &mut Command {\n         self.inner.arg(arg.as_os_str());\n         self\n     }\n@@ -175,7 +175,7 @@ impl Command {\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn env<K: ?Sized, V: ?Sized>(&mut self, key: &K, val: &V) -> &mut Command\n+    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n         where K: AsOsStr, V: AsOsStr\n     {\n         self.inner.env(key.as_os_str(), val.as_os_str());\n@@ -184,7 +184,7 @@ impl Command {\n \n     /// Removes an environment variable mapping.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn env_remove<K: ?Sized + AsOsStr>(&mut self, key: &K) -> &mut Command {\n+    pub fn env_remove<K: AsOsStr>(&mut self, key: K) -> &mut Command {\n         self.inner.env_remove(key.as_os_str());\n         self\n     }\n@@ -198,7 +198,7 @@ impl Command {\n \n     /// Set the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn current_dir<P: AsPath + ?Sized>(&mut self, dir: &P) -> &mut Command {\n+    pub fn current_dir<P: AsPath>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_path().as_os_str());\n         self\n     }"}, {"sha": "b0ad9ab6937e5362ed506b44f42f057bc62d6d30", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a4a2db8837be91bdae051bd51ab181077e5dc6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=60a4a2db8837be91bdae051bd51ab181077e5dc6", "patch": "@@ -253,7 +253,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(PathBuf::new::<OsString>(&OsStringExt::from_vec(v)))\n+        Ok(PathBuf::new(OsString::from_vec(v)))\n     }\n }\n "}]}