{"sha": "aa931e9c6f92557b99978f1cc562c99051190f79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhOTMxZTljNmY5MjU1N2I5OTk3OGYxY2M1NjJjOTkwNTExOTBmNzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-11T02:14:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-17T16:07:17Z"}, "message": "std: Move free-functions to associated functions\n\nThis commit moves the free functions in the `rc`, `arc`, and `boxed` modules to\nassociated functions on their respective types, following the recent trend\ntowards this pattern. The previous free functions are all left in-place with\n`#[deprecated]` pointers towards the new locations.\n\nThis commit also deprecates `arc::get_mut` and `Arc::make_unique` with no\nreplacement as they are racy in the face of weak pointers.", "tree": {"sha": "2a6dc3e11e44531edd1829143b9c0a86f90d4add", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a6dc3e11e44531edd1829143b9c0a86f90d4add"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa931e9c6f92557b99978f1cc562c99051190f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa931e9c6f92557b99978f1cc562c99051190f79", "html_url": "https://github.com/rust-lang/rust/commit/aa931e9c6f92557b99978f1cc562c99051190f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa931e9c6f92557b99978f1cc562c99051190f79/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3346fb044285c0b10480099ca3af921a053c38be", "url": "https://api.github.com/repos/rust-lang/rust/commits/3346fb044285c0b10480099ca3af921a053c38be", "html_url": "https://github.com/rust-lang/rust/commit/3346fb044285c0b10480099ca3af921a053c38be"}], "stats": {"total": 188, "additions": 153, "deletions": 35}, "files": [{"sha": "282fca8d6c29e9ab5acc1429fc95d8c7a78b0dc9", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=aa931e9c6f92557b99978f1cc562c99051190f79", "patch": "@@ -205,9 +205,21 @@ impl<T: ?Sized> Arc<T> {\n         self.inner().weak.fetch_add(1, Relaxed);\n         Weak { _ptr: self._ptr }\n     }\n-}\n \n-impl<T: ?Sized> Arc<T> {\n+    /// Get the number of weak references to this value.\n+    #[inline]\n+    #[unstable(feature = \"arc_counts\")]\n+    pub fn weak_count(this: &Arc<T>) -> usize {\n+        this.inner().weak.load(SeqCst) - 1\n+    }\n+\n+    /// Get the number of strong references to this value.\n+    #[inline]\n+    #[unstable(feature = \"arc_counts\")]\n+    pub fn strong_count(this: &Arc<T>) -> usize {\n+        this.inner().strong.load(SeqCst)\n+    }\n+\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // This unsafety is ok because while this arc is alive we're guaranteed\n@@ -237,12 +249,14 @@ impl<T: ?Sized> Arc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"arc_counts\")]\n-pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::weak_count\")]\n+pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::weak_count(this) }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"arc_counts\")]\n-pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::strong_count\")]\n+pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::strong_count(this) }\n \n \n /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n@@ -272,6 +286,8 @@ pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { this.inner().strong.loa\n /// ```\n #[inline]\n #[unstable(feature = \"arc_unique\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"this function is unsafe with weak pointers\")]\n pub unsafe fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n     // FIXME(#24880) potential race with upgraded weak pointers here\n     if strong_count(this) == 1 && weak_count(this) == 0 {\n@@ -353,6 +369,8 @@ impl<T: Clone> Arc<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"arc_unique\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"this function is unsafe with weak pointers\")]\n     pub unsafe fn make_unique(&mut self) -> &mut T {\n         // FIXME(#24880) potential race with upgraded weak pointers here\n         //"}, {"sha": "0e6554702bef9dd3ed87391f1e50f7b6b5a7dda4", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=aa931e9c6f92557b99978f1cc562c99051190f79", "patch": "@@ -127,6 +127,29 @@ impl<T : ?Sized> Box<T> {\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n         mem::transmute(raw)\n     }\n+\n+    /// Consumes the `Box`, returning the wrapped raw pointer.\n+    ///\n+    /// After call to this function, caller is responsible for the memory\n+    /// previously managed by `Box`, in particular caller should properly\n+    /// destroy `T` and release memory. The proper way to do it is to\n+    /// convert pointer back to `Box` with `Box::from_raw` function, because\n+    /// `Box` does not specify, how memory is allocated.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(box_raw)]\n+    /// use std::boxed;\n+    ///\n+    /// let seventeen = Box::new(17u32);\n+    /// let raw = boxed::into_raw(seventeen);\n+    /// let boxed_again = unsafe { Box::from_raw(raw) };\n+    /// ```\n+    #[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n+    #[inline]\n+    pub fn into_raw(b: Box<T>) -> *mut T {\n+        unsafe { mem::transmute(b) }\n+    }\n }\n \n /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -146,11 +169,11 @@ impl<T : ?Sized> Box<T> {\n /// let raw = boxed::into_raw(seventeen);\n /// let boxed_again = unsafe { Box::from_raw(raw) };\n /// ```\n-#[unstable(feature = \"box_raw\",\n-           reason = \"may be renamed\")]\n+#[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Box::into_raw\")]\n #[inline]\n pub fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n-    unsafe { mem::transmute(b) }\n+    Box::into_raw(b)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bdf02b23ff48946f1bc5eb719f510c3745877ba9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa931e9c6f92557b99978f1cc562c99051190f79/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=aa931e9c6f92557b99978f1cc562c99051190f79", "patch": "@@ -220,6 +220,42 @@ impl<T> Rc<T> {\n             }\n         }\n     }\n+\n+    /// Unwraps the contained value if the `Rc<T>` is unique.\n+    ///\n+    /// If the `Rc<T>` is not unique, an `Err` is returned with the same\n+    /// `Rc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc::{self, Rc};\n+    ///\n+    /// let x = Rc::new(3);\n+    /// assert_eq!(rc::try_unwrap(x), Ok(3));\n+    ///\n+    /// let x = Rc::new(4);\n+    /// let _y = x.clone();\n+    /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn try_unwrap(rc: Rc<T>) -> Result<T, Rc<T>> {\n+        if Rc::is_unique(&rc) {\n+            unsafe {\n+                let val = ptr::read(&*rc); // copy the contained object\n+                // destruct the box and skip our Drop\n+                // we can ignore the refcounts because we know we're unique\n+                deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n+                            min_align_of::<RcBox<T>>());\n+                forget(rc);\n+                Ok(val)\n+            }\n+        } else {\n+            Err(rc)\n+        }\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {\n@@ -241,17 +277,78 @@ impl<T: ?Sized> Rc<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n     }\n+\n+    /// Get the number of weak references to this value.\n+    #[inline]\n+    #[unstable(feature = \"rc_counts\")]\n+    pub fn weak_count(this: &Rc<T>) -> usize { this.weak() - 1 }\n+\n+    /// Get the number of strong references to this value.\n+    #[inline]\n+    #[unstable(feature = \"rc_counts\")]\n+    pub fn strong_count(this: &Rc<T>) -> usize { this.strong() }\n+\n+    /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n+    /// the same inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc;\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    ///\n+    /// rc::is_unique(&five);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn is_unique(rc: &Rc<T>) -> bool {\n+        weak_count(rc) == 0 && strong_count(rc) == 1\n+    }\n+\n+    /// Returns a mutable reference to the contained value if the `Rc<T>` is\n+    /// unique.\n+    ///\n+    /// Returns `None` if the `Rc<T>` is not unique.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(rc_unique)]\n+    /// use std::rc::{self, Rc};\n+    ///\n+    /// let mut x = Rc::new(3);\n+    /// *rc::get_mut(&mut x).unwrap() = 4;\n+    /// assert_eq!(*x, 4);\n+    ///\n+    /// let _y = x.clone();\n+    /// assert!(rc::get_mut(&mut x).is_none());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\")]\n+    pub fn get_mut(rc: &mut Rc<T>) -> Option<&mut T> {\n+        if Rc::is_unique(rc) {\n+            let inner = unsafe { &mut **rc._ptr };\n+            Some(&mut inner.value)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"rc_counts\")]\n-pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::weak_count\")]\n+pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::weak_count(this) }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"rc_counts\")]\n-pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::strong_count\")]\n+pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::strong_count(this) }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n /// same inner value.\n@@ -269,9 +366,8 @@ pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n /// ```\n #[inline]\n #[unstable(feature = \"rc_unique\")]\n-pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    weak_count(rc) == 0 && strong_count(rc) == 1\n-}\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::is_unique\")]\n+pub fn is_unique<T>(rc: &Rc<T>) -> bool { Rc::is_unique(rc) }\n \n /// Unwraps the contained value if the `Rc<T>` is unique.\n ///\n@@ -292,21 +388,8 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// ```\n #[inline]\n #[unstable(feature = \"rc_unique\")]\n-pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n-    if is_unique(&rc) {\n-        unsafe {\n-            let val = ptr::read(&*rc); // copy the contained object\n-            // destruct the box and skip our Drop\n-            // we can ignore the refcounts because we know we're unique\n-            deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                        min_align_of::<RcBox<T>>());\n-            forget(rc);\n-            Ok(val)\n-        }\n-    } else {\n-        Err(rc)\n-    }\n-}\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::try_unwrap\")]\n+pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> { Rc::try_unwrap(rc) }\n \n /// Returns a mutable reference to the contained value if the `Rc<T>` is unique.\n ///\n@@ -327,14 +410,8 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// ```\n #[inline]\n #[unstable(feature = \"rc_unique\")]\n-pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> {\n-    if is_unique(rc) {\n-        let inner = unsafe { &mut **rc._ptr };\n-        Some(&mut inner.value)\n-    } else {\n-        None\n-    }\n-}\n+#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::get_mut\")]\n+pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> { Rc::get_mut(rc) }\n \n impl<T: Clone> Rc<T> {\n     /// Make a mutable reference from the given `Rc<T>`."}]}