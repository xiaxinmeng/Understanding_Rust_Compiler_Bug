{"sha": "e9370d2b74d38720fed7887fc708b8fa67fe7adb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MzcwZDJiNzRkMzg3MjBmZWQ3ODg3ZmM3MDhiOGZhNjdmZTdhZGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T12:29:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-27T13:25:20Z"}, "message": "adjust for memory_allocated hook, make RangeMap preallocated with a fixed size", "tree": {"sha": "1859d32ec60181012bd05ab9c605b51070a9d3cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1859d32ec60181012bd05ab9c605b51070a9d3cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9370d2b74d38720fed7887fc708b8fa67fe7adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9370d2b74d38720fed7887fc708b8fa67fe7adb", "html_url": "https://github.com/rust-lang/rust/commit/e9370d2b74d38720fed7887fc708b8fa67fe7adb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9370d2b74d38720fed7887fc708b8fa67fe7adb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80a6e739424728d7505587ea6c53c39d6687cb59", "url": "https://api.github.com/repos/rust-lang/rust/commits/80a6e739424728d7505587ea6c53c39d6687cb59", "html_url": "https://github.com/rust-lang/rust/commit/80a6e739424728d7505587ea6c53c39d6687cb59"}], "stats": {"total": 147, "additions": 56, "deletions": 91}, "files": [{"sha": "591cf5766234b8eb4982e40498da256223d67190", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e9370d2b74d38720fed7887fc708b8fa67fe7adb", "patch": "@@ -301,6 +301,7 @@ type MiriEvalContext<'a, 'mir, 'tcx> = EvalContext<'a, 'mir, 'tcx, Evaluator<'tc\n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n+    type MemoryExtra = ();\n     type AllocExtra = stacked_borrows::Stacks;\n     type PointerTag = Borrow;\n \n@@ -405,8 +406,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn find_foreign_static(\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        memory_extra: &Self::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Borrow, Self::AllocExtra>>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n@@ -417,8 +419,10 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         let alloc = match &link_name[..] {\n             \"__cxa_thread_atexit_impl\" => {\n                 // This should be all-zero, pointer-sized\n-                let data = vec![0; tcx.data_layout.pointer_size.bytes() as usize];\n-                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align.abi)\n+                let size = tcx.data_layout.pointer_size;\n+                let data = vec![0; size.bytes() as usize];\n+                let extra = AllocationExtra::memory_allocated(size, memory_extra);\n+                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align.abi, extra)\n             }\n             _ => return err!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n@@ -434,9 +438,14 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(())\n     }\n \n-    fn adjust_static_allocation(\n-        alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Borrow, Self::AllocExtra>> {\n+    fn adjust_static_allocation<'b>(\n+        alloc: &'b Allocation,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Cow<'b, Allocation<Borrow, Self::AllocExtra>> {\n+        let extra = AllocationExtra::memory_allocated(\n+            Size::from_bytes(alloc.bytes.len() as u64),\n+            memory_extra,\n+        );\n         let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes.clone(),\n             relocations: Relocations::from_presorted(\n@@ -447,7 +456,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             undef_mask: alloc.undef_mask.clone(),\n             align: alloc.align,\n             mutability: alloc.mutability,\n-            extra: Self::AllocExtra::default(),\n+            extra,\n         };\n         Cow::Owned(alloc)\n     }"}, {"sha": "762b17b1ae3389a8a9fac9e06bb70e271e4fee20", "filename": "src/range_map.rs", "status": "modified", "additions": 29, "deletions": 79, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=e9370d2b74d38720fed7887fc708b8fa67fe7adb", "patch": "@@ -16,13 +16,6 @@ pub struct RangeMap<T> {\n     map: BTreeMap<Range, T>,\n }\n \n-impl<T> Default for RangeMap<T> {\n-    #[inline(always)]\n-    fn default() -> Self {\n-        RangeMap::new()\n-    }\n-}\n-\n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n // by the second field.\n // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n@@ -73,9 +66,15 @@ impl Range {\n }\n \n impl<T> RangeMap<T> {\n+    /// Create a new RangeMap for the given size, and with the given initial value used for\n+    /// the entire range.\n     #[inline(always)]\n-    pub fn new() -> RangeMap<T> {\n-        RangeMap { map: BTreeMap::new() }\n+    pub fn new(size: Size, init: T) -> RangeMap<T> {\n+        let mut map = RangeMap { map: BTreeMap::new() };\n+        if size.bytes() > 0 {\n+            map.map.insert(Range { start: 0, end: size.bytes() }, init);\n+        }\n+        map\n     }\n \n     fn iter_with_range<'a>(\n@@ -95,6 +94,9 @@ impl<T> RangeMap<T> {\n         )\n     }\n \n+    /// Provide read-only iteration over everything in the given range.  This does\n+    /// *not* split items if they overlap with the edges.  Do not use this to mutate\n+    /// through interior mutability.\n     pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n         self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n     }\n@@ -140,8 +142,7 @@ impl<T> RangeMap<T> {\n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n-    /// If there are gaps, leave them be.\n-    pub fn iter_mut_with_gaps<'a>(\n+    pub fn iter_mut<'a>(\n         &'a mut self,\n         offset: Size,\n         len: Size,\n@@ -174,93 +175,34 @@ impl<T> RangeMap<T> {\n             },\n         )\n     }\n-\n-    /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n-    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default\n-    /// before yielding them in the iterator.\n-    /// This is also how you insert.\n-    pub fn iter_mut<'a>(&'a mut self, offset: Size, len: Size) -> impl Iterator<Item = &'a mut T> + 'a\n-    where\n-        T: Clone + Default,\n-    {\n-        if len.bytes() > 0 {\n-            let offset = offset.bytes();\n-            let len = len.bytes();\n-\n-            // Do a first iteration to collect the gaps\n-            let mut gaps = Vec::new();\n-            let mut last_end = offset;\n-            for (range, _) in self.iter_with_range(offset, len) {\n-                if last_end < range.start {\n-                    gaps.push(Range {\n-                        start: last_end,\n-                        end: range.start,\n-                    });\n-                }\n-                last_end = range.end;\n-            }\n-            if last_end < offset + len {\n-                gaps.push(Range {\n-                    start: last_end,\n-                    end: offset + len,\n-                });\n-            }\n-\n-            // Add default for all gaps\n-            for gap in gaps {\n-                let old = self.map.insert(gap, Default::default());\n-                assert!(old.is_none());\n-            }\n-        }\n-\n-        // Now provide mutable iteration\n-        self.iter_mut_with_gaps(offset, len)\n-    }\n-\n-    pub fn retain<F>(&mut self, mut f: F)\n-    where\n-        F: FnMut(&T) -> bool,\n-    {\n-        let mut remove = Vec::new();\n-        for (range, data) in &self.map {\n-            if !f(data) {\n-                remove.push(*range);\n-            }\n-        }\n-\n-        for range in remove {\n-            self.map.remove(&range);\n-        }\n-    }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     /// Query the map at every offset in the range and collect the results.\n-    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64, default: Option<T>) -> Vec<T> {\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n             .map(|i| map\n                 .iter(Size::from_bytes(i), Size::from_bytes(1))\n                 .next()\n                 .map(|&t| t)\n-                .or(default)\n                 .unwrap()\n             )\n             .collect()\n     }\n \n     #[test]\n     fn basic_insert() {\n-        let mut map = RangeMap::<i32>::new();\n+        let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n         // Insert\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         // Check\n-        assert_eq!(to_vec(&map, 10, 1, None), vec![42]);\n+        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n \n         // Insert with size 0\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n@@ -269,34 +211,42 @@ mod tests {\n         for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n             *x = 19;\n         }\n-        assert_eq!(to_vec(&map, 10, 2, Some(-1)), vec![42, -1]);\n+        assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n     }\n \n     #[test]\n     fn gaps() {\n-        let mut map = RangeMap::<i32>::new();\n+        let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n         for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n             *x = 43;\n         }\n         assert_eq!(\n-            to_vec(&map, 10, 10, Some(-1)),\n+            to_vec(&map, 10, 10),\n             vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n         );\n \n-        // Now request a range that needs three gaps filled\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n             if *x < 42 {\n                 *x = 23;\n             }\n         }\n \n         assert_eq!(\n-            to_vec(&map, 10, 10, None),\n+            to_vec(&map, 10, 10),\n             vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n-        assert_eq!(to_vec(&map, 13, 5, None), vec![23, 23, 43, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n+\n+        // Now request a range that goes beyond the initial size\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(10)) {\n+            *x = 19;\n+        }\n+        assert_eq!(map.iter(Size::from_bytes(19), Size::from_bytes(1))\n+            .map(|&t| t).collect::<Vec<_>>(), vec![19]);\n+        assert_eq!(map.iter(Size::from_bytes(20), Size::from_bytes(1))\n+            .map(|&t| t).collect::<Vec<_>>(), vec![]);\n     }\n }"}, {"sha": "22ec6ffe6f50a2d3b472bee003592c88939f9134", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9370d2b74d38720fed7887fc708b8fa67fe7adb/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=e9370d2b74d38720fed7887fc708b8fa67fe7adb", "patch": "@@ -126,7 +126,7 @@ impl State {\n }\n \n /// Extra per-allocation state\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug)]\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n@@ -289,9 +289,8 @@ impl<'tcx> Stacks {\n     ) -> EvalResult<'tcx> {\n         trace!(\"deref for tag {:?} as {:?}: {:?}, size {}\",\n             ptr.tag, kind, ptr, size.bytes());\n-        let mut stacks = self.stacks.borrow_mut();\n-        // We need `iter_mut` because `iter` would skip gaps!\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n+        let stacks = self.stacks.borrow();\n+        for stack in stacks.iter(ptr.offset, size) {\n             stack.deref(ptr.tag, kind).map_err(EvalErrorKind::MachineError)?;\n         }\n         Ok(())\n@@ -359,7 +358,14 @@ impl<'tcx> Stacks {\n }\n \n /// Hooks and glue\n-impl AllocationExtra<Borrow> for Stacks {\n+impl AllocationExtra<Borrow, ()> for Stacks {\n+    #[inline(always)]\n+    fn memory_allocated<'tcx>(size: Size, _extra: &()) -> Self {\n+        Stacks {\n+            stacks: RefCell::new(RangeMap::new(size, Stack::default()))\n+        }\n+    }\n+\n     #[inline(always)]\n     fn memory_read<'tcx>(\n         alloc: &Allocation<Borrow, Stacks>,"}]}