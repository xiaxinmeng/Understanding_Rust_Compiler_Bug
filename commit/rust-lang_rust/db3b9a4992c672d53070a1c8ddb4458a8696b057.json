{"sha": "db3b9a4992c672d53070a1c8ddb4458a8696b057", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiM2I5YTQ5OTJjNjcyZDUzMDcwYTFjOGRkYjQ0NThhODY5NmIwNTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-07T18:54:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-07T18:54:23Z"}, "message": "Stop stringifying integers to get integral constants.", "tree": {"sha": "03e80470bd3093ef53265d63a06dc7ae8593dc97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03e80470bd3093ef53265d63a06dc7ae8593dc97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db3b9a4992c672d53070a1c8ddb4458a8696b057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db3b9a4992c672d53070a1c8ddb4458a8696b057", "html_url": "https://github.com/rust-lang/rust/commit/db3b9a4992c672d53070a1c8ddb4458a8696b057", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db3b9a4992c672d53070a1c8ddb4458a8696b057/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a71fda40b865e23f0d191174f4584298534f2f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a71fda40b865e23f0d191174f4584298534f2f75", "html_url": "https://github.com/rust-lang/rust/commit/a71fda40b865e23f0d191174f4584298534f2f75"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "80b216e6146d5e5c2908f6d1d48d7b526186afbc", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=db3b9a4992c672d53070a1c8ddb4458a8696b057", "patch": "@@ -864,6 +864,10 @@ native mod llvm = llvm_lib {\n     /** Parses the bitcode in the given memory buffer. */\n     fn LLVMRustParseBitcode(MemoryBufferRef MemBuf) -> ModuleRef;\n \n+    /** FiXME: Hacky adaptor for lack of ULongLong in FFI. */\n+    fn LLVMRustConstSmallInt(TypeRef IntTy, uint N,\n+                             Bool SignExtend) -> ValueRef;\n+\n     /** Links LLVM modules together. `Src` is destroyed by this call and\n         must never be referenced again. */\n     fn LLVMLinkModules(ModuleRef Dest, ModuleRef Src) -> Bool;"}, {"sha": "c6aea256946414656cfaf7a7b8518ce05671b977", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=db3b9a4992c672d53070a1c8ddb4458a8696b057", "patch": "@@ -42,6 +42,7 @@ import lib.llvm.llvm.BasicBlockRef;\n \n import lib.llvm.False;\n import lib.llvm.True;\n+import lib.llvm.Bool;\n \n state obj namegen(mutable int i) {\n     fn next(str prefix) -> str {\n@@ -887,14 +888,13 @@ fn C_null(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstNull(t);\n }\n \n-fn C_integral(int i, TypeRef t) -> ValueRef {\n+fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n     // FIXME. We can't use LLVM.ULongLong with our existing minimal native\n-    // API, which only knows word-sized args.  Lucky for us LLVM has a \"take a\n-    // string encoding\" version.  Hilarious. Please fix to handle:\n+    // API, which only knows word-sized args.\n     //\n     // ret llvm.LLVMConstInt(T_int(), t as LLVM.ULongLong, False);\n     //\n-    ret llvm.LLVMConstIntOfString(t, Str.buf(istr(i)), 10);\n+    ret llvm.LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n fn C_float(str s) -> ValueRef {\n@@ -907,23 +907,23 @@ fn C_floating(str s, TypeRef t) -> ValueRef {\n \n fn C_nil() -> ValueRef {\n     // NB: See comment above in T_void().\n-    ret C_integral(0, T_i1());\n+    ret C_integral(T_i1(), 0u, False);\n }\n \n fn C_bool(bool b) -> ValueRef {\n     if (b) {\n-        ret C_integral(1, T_bool());\n+        ret C_integral(T_bool(), 1u, False);\n     } else {\n-        ret C_integral(0, T_bool());\n+        ret C_integral(T_bool(), 0u, False);\n     }\n }\n \n fn C_int(int i) -> ValueRef {\n-    ret C_integral(i, T_int());\n+    ret C_integral(T_int(), i as uint, True);\n }\n \n-fn C_i8(uint i) -> ValueRef {\n-    ret C_integral(i as int, T_i8());\n+fn C_u8(uint i) -> ValueRef {\n+    ret C_integral(T_i8(), i, False);\n }\n \n // This is a 'c-like' raw string, which differs from\n@@ -961,7 +961,7 @@ fn C_zero_byte_arr(uint size) -> ValueRef {\n     auto i = 0u;\n     let vec[ValueRef] elts = vec();\n     while (i < size) {\n-        elts += vec(C_integral(0, T_i8()));\n+        elts += vec(C_u8(0u));\n         i += 1u;\n     }\n     ret llvm.LLVMConstArray(T_i8(), Vec.buf[ValueRef](elts),\n@@ -2175,7 +2175,7 @@ fn make_cmp_glue(@block_ctxt cx,\n             // == and <= default to true if they find == all the way. <\n             // defaults to false if it finds == all the way.\n             auto result_if_equal = scx.build.ICmp(lib.llvm.LLVMIntNE, llop,\n-                                                  C_i8(abi.cmp_glue_op_lt));\n+                                                  C_u8(abi.cmp_glue_op_lt));\n             scx.build.Store(result_if_equal, flag);\n             r = res(scx, C_nil());\n         }\n@@ -2211,7 +2211,7 @@ fn make_cmp_glue(@block_ctxt cx,\n \n             // First 'eq' comparison: if so, continue to next elts.\n             auto eq_r = call_cmp_glue(cx, av, bv, t,\n-                                      C_i8(abi.cmp_glue_op_eq));\n+                                      C_u8(abi.cmp_glue_op_eq));\n             eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n \n             // Second 'op' comparison: find out how this elt-pair decides.\n@@ -2299,9 +2299,9 @@ fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t fptype,\n     unreach_cx.build.Unreachable();\n \n     auto llswitch = cx.build.Switch(llop, unreach_cx.llbb, 3u);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_eq), eq_cx.llbb);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_lt), lt_cx.llbb);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_le), le_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_eq), eq_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_lt), lt_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_le), le_cx.llbb);\n \n     auto last_result =\n         last_cx.build.Phi(T_i1(), vec(eq_result, lt_result, le_result),\n@@ -2341,9 +2341,9 @@ fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n     unreach_cx.build.Unreachable();\n \n     auto llswitch = cx.build.Switch(llop, unreach_cx.llbb, 3u);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_eq), eq_cx.llbb);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_lt), lt_cx.llbb);\n-    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_le), le_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_eq), eq_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_lt), lt_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_u8(abi.cmp_glue_op_le), le_cx.llbb);\n \n     auto last_result =\n         last_cx.build.Phi(T_i1(), vec(eq_result, lt_result, le_result),\n@@ -2949,18 +2949,19 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n             // if target int width is larger than host, at the moment;\n             // re-do the mach-int types using 'big' when that works.\n             auto t = T_int();\n+            auto s = True;\n             alt (tm) {\n-                case (common.ty_u8) { t = T_i8(); }\n-                case (common.ty_u16) { t = T_i16(); }\n-                case (common.ty_u32) { t = T_i32(); }\n-                case (common.ty_u64) { t = T_i64(); }\n+                case (common.ty_u8) { t = T_i8(); s = False; }\n+                case (common.ty_u16) { t = T_i16(); s = False; }\n+                case (common.ty_u32) { t = T_i32(); s = False; }\n+                case (common.ty_u64) { t = T_i64(); s = False; }\n \n                 case (common.ty_i8) { t = T_i8(); }\n                 case (common.ty_i16) { t = T_i16(); }\n                 case (common.ty_i32) { t = T_i32(); }\n                 case (common.ty_i64) { t = T_i64(); }\n             }\n-            ret C_integral(i, t);\n+            ret C_integral(t, i as uint, s);\n         }\n         case(ast.lit_float(?fs)) {\n             ret C_float(fs);\n@@ -2974,7 +2975,7 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n             ret C_floating(s, t);\n         }\n         case (ast.lit_char(?c)) {\n-            ret C_integral(c as int, T_char());\n+            ret C_integral(T_char(), c as uint, False);\n         }\n         case (ast.lit_bool(?b)) {\n             ret C_bool(b);\n@@ -3116,12 +3117,12 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n     // FIXME: Use or-patterns when we have them.\n     auto llop;\n     alt (op) {\n-        case (ast.eq) { llop = C_i8(abi.cmp_glue_op_eq); }\n-        case (ast.lt) { llop = C_i8(abi.cmp_glue_op_lt); }\n-        case (ast.le) { llop = C_i8(abi.cmp_glue_op_le); }\n-        case (ast.ne) { llop = C_i8(abi.cmp_glue_op_eq); }\n-        case (ast.ge) { llop = C_i8(abi.cmp_glue_op_lt); }\n-        case (ast.gt) { llop = C_i8(abi.cmp_glue_op_le); }\n+        case (ast.eq) { llop = C_u8(abi.cmp_glue_op_eq); }\n+        case (ast.lt) { llop = C_u8(abi.cmp_glue_op_lt); }\n+        case (ast.le) { llop = C_u8(abi.cmp_glue_op_le); }\n+        case (ast.ne) { llop = C_u8(abi.cmp_glue_op_eq); }\n+        case (ast.ge) { llop = C_u8(abi.cmp_glue_op_lt); }\n+        case (ast.gt) { llop = C_u8(abi.cmp_glue_op_le); }\n     }\n \n     auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n@@ -7347,7 +7348,7 @@ fn make_bzero_glue(ValueRef fun) -> ValueRef {\n     // Loop-body block\n     auto lb = new_builder(loopbb);\n     i = lb.Load(ip);\n-    lb.Store(C_integral(0, T_i8()), lb.GEP(dst, vec(i)));\n+    lb.Store(C_u8(0u), lb.GEP(dst, vec(i)));\n     lb.Store(lb.Add(i, C_int(1)), ip);\n     lb.Br(hdrbb);\n "}, {"sha": "b57695199f9b707bf337df4574ae25c717781b50", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=db3b9a4992c672d53070a1c8ddb4458a8696b057", "patch": "@@ -116,3 +116,8 @@ extern \"C\" const char *LLVMRustGetHostTriple(void)\n   static std::string str = llvm::sys::getHostTriple();\n   return str.c_str();\n }\n+\n+extern \"C\" LLVMValueRef LLVMRustConstSmallInt(LLVMTypeRef IntTy, unsigned N,\n+                                              LLVMBool SignExtend) {\n+  return LLVMConstInt(IntTy, (unsigned long long)N, SignExtend);\n+}"}, {"sha": "2da66c2408e25ad54246c916bf1b34040687cff2", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/db3b9a4992c672d53070a1c8ddb4458a8696b057/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=db3b9a4992c672d53070a1c8ddb4458a8696b057", "patch": "@@ -2,6 +2,7 @@ LLVMRustCreateMemoryBufferWithContentsOfFile\n LLVMRustWriteOutputFile\n LLVMRustGetLastError\n LLVMRustGetHostTriple\n+LLVMRustConstSmallInt\n LLVMRustParseBitcode\n LLVMLinkModules\n LLVMCreateObjectFile"}]}