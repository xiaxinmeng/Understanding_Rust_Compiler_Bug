{"sha": "48ec25224b1e252608a0458585dc5e0847ed91c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZWMyNTIyNGIxZTI1MjYwOGEwNDU4NTg1ZGM1ZTA4NDdlZDkxYzQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-03-01T10:28:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-01T10:28:09Z"}, "message": "Rollup merge of #69562 - ecstatic-morse:dataflow-generator-discriminant, r=oli-obk\n\nDon't `bug` when taking discriminant of generator during dataflow\n\nThe proper fix for rust-lang/rust-clippy#5239. `Rvalue::Discriminant` is used on generators as well as `enum`s. This didn't cause a test failure in `rustc` since we don't need to do any dataflow passes until after the generator transform that adds the `Rvalue::Discriminant`.\n\nThis required a small refactoring. `diff -w` is beneficial.\n\nr? @oli-obk\ncc @JohnTitor", "tree": {"sha": "d40b9c2b40eaa924267f9ac0463a501fdd13ff24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d40b9c2b40eaa924267f9ac0463a501fdd13ff24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ec25224b1e252608a0458585dc5e0847ed91c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeW445CRBK7hj4Ov3rIwAAdHIIAHDWom8li3vV597cq/wSYjc7\n4T/vTRZJqD+oIdaCz7+zUEInzVBG6UjD6pYFwYDKWlax5rccGUPTlnUo9hb8PHDj\n2a+bal9BUjDudt0xSLBlcYYcMNs85zbjKi7ywxyFfNNhyHy2jqPLh9+nFYsKMKiM\nRFNypZh8DGCu7gFPElHRIDP6UPNbVhiw+g7lKcTweDF62chRqgQ1slOnrlYJ4dXW\nov95rDxweq1EX9PeW2y8eTdS1ECd0dyD7J+QVh2Z497CTsPsdHGhmBK+Zk1L4klf\nLEcAD1UxZMPB62NP8f2k+nifZfB7y4w6X38bU1SBsIYk1a1yxpyTxsENUigMLOQ=\n=lKsf\n-----END PGP SIGNATURE-----\n", "payload": "tree d40b9c2b40eaa924267f9ac0463a501fdd13ff24\nparent 559e5ab7ad564d3c30b8da2c067942aaaa7c985f\nparent 52ad1e73ceddcc746d2b6e01f238860cf4c53bde\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1583058489 +0900\ncommitter GitHub <noreply@github.com> 1583058489 +0900\n\nRollup merge of #69562 - ecstatic-morse:dataflow-generator-discriminant, r=oli-obk\n\nDon't `bug` when taking discriminant of generator during dataflow\n\nThe proper fix for rust-lang/rust-clippy#5239. `Rvalue::Discriminant` is used on generators as well as `enum`s. This didn't cause a test failure in `rustc` since we don't need to do any dataflow passes until after the generator transform that adds the `Rvalue::Discriminant`.\n\nThis required a small refactoring. `diff -w` is beneficial.\n\nr? @oli-obk\ncc @JohnTitor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ec25224b1e252608a0458585dc5e0847ed91c4", "html_url": "https://github.com/rust-lang/rust/commit/48ec25224b1e252608a0458585dc5e0847ed91c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ec25224b1e252608a0458585dc5e0847ed91c4/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "559e5ab7ad564d3c30b8da2c067942aaaa7c985f", "url": "https://api.github.com/repos/rust-lang/rust/commits/559e5ab7ad564d3c30b8da2c067942aaaa7c985f", "html_url": "https://github.com/rust-lang/rust/commit/559e5ab7ad564d3c30b8da2c067942aaaa7c985f"}, {"sha": "52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ad1e73ceddcc746d2b6e01f238860cf4c53bde", "html_url": "https://github.com/rust-lang/rust/commit/52ad1e73ceddcc746d2b6e01f238860cf4c53bde"}], "stats": {"total": 126, "additions": 72, "deletions": 54}, "files": [{"sha": "1487129f6c77c2a10473223681a96b4bde3e2ad0", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/48ec25224b1e252608a0458585dc5e0847ed91c4/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ec25224b1e252608a0458585dc5e0847ed91c4/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=48ec25224b1e252608a0458585dc5e0847ed91c4", "patch": "@@ -239,14 +239,24 @@ where\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, .. } => {\n-                self.propagate_bits_into_switch_int_successors(\n-                    in_out,\n-                    (bb, bb_data),\n-                    dirty_list,\n-                    discr,\n-                    &*values,\n-                    &*targets,\n-                );\n+                // If this is a switch on an enum discriminant, a custom effect may be applied\n+                // along each outgoing edge.\n+                if let Some(place) = discr.place() {\n+                    let enum_def = switch_on_enum_discriminant(self.tcx, self.body, bb_data, place);\n+                    if let Some(enum_def) = enum_def {\n+                        self.propagate_bits_into_enum_discriminant_switch_successors(\n+                            in_out, bb, enum_def, place, dirty_list, &*values, &*targets,\n+                        );\n+\n+                        return;\n+                    }\n+                }\n+\n+                // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n+                // exit state.\n+                for target in targets.iter().copied() {\n+                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n+                }\n             }\n \n             Call { cleanup, ref destination, ref func, ref args, .. } => {\n@@ -293,64 +303,72 @@ where\n         }\n     }\n \n-    fn propagate_bits_into_switch_int_successors(\n+    fn propagate_bits_into_enum_discriminant_switch_successors(\n         &mut self,\n         in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &mir::BasicBlockData<'tcx>),\n+        bb: BasicBlock,\n+        enum_def: &'tcx ty::AdtDef,\n+        enum_place: &mir::Place<'tcx>,\n         dirty_list: &mut WorkQueue<BasicBlock>,\n-        switch_on: &mir::Operand<'tcx>,\n         values: &[u128],\n         targets: &[BasicBlock],\n     ) {\n-        match bb_data.statements.last().map(|stmt| &stmt.kind) {\n-            // Look at the last statement to see if it is an assignment of an enum discriminant to\n-            // the local that determines the target of a `SwitchInt` like so:\n-            //   _42 = discriminant(..)\n-            //   SwitchInt(_42, ..)\n-            Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(enum_))))\n-                if Some(lhs) == switch_on.place() =>\n-            {\n-                let adt = match enum_.ty(self.body, self.tcx).ty.kind {\n-                    ty::Adt(def, _) => def,\n-                    _ => bug!(\"Switch on discriminant of non-ADT\"),\n-                };\n-\n-                // MIR building adds discriminants to the `values` array in the same order as they\n-                // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                // discriminant in `values` to its corresponding variant in linear time.\n-                let mut tmp = BitSet::new_empty(in_out.domain_size());\n-                let mut discriminants = adt.discriminants(self.tcx);\n-                for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                    let (variant_idx, _) =\n-                        discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                            \"Order of `AdtDef::discriminants` differed \\\n-                                 from that of `SwitchInt::values`\",\n-                        );\n+        // MIR building adds discriminants to the `values` array in the same order as they\n+        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+        // discriminant in `values` to its corresponding variant in linear time.\n+        let mut tmp = BitSet::new_empty(in_out.domain_size());\n+        let mut discriminants = enum_def.discriminants(self.tcx);\n+        for (value, target) in values.iter().zip(targets.iter().copied()) {\n+            let (variant_idx, _) = discriminants.find(|&(_, discr)| discr.val == *value).expect(\n+                \"Order of `AdtDef::discriminants` differed from that of `SwitchInt::values`\",\n+            );\n \n-                    tmp.overwrite(in_out);\n-                    self.analysis.apply_discriminant_switch_effect(\n-                        &mut tmp,\n-                        bb,\n-                        enum_,\n-                        adt,\n-                        variant_idx,\n-                    );\n-                    self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n-                }\n+            tmp.overwrite(in_out);\n+            self.analysis.apply_discriminant_switch_effect(\n+                &mut tmp,\n+                bb,\n+                enum_place,\n+                enum_def,\n+                variant_idx,\n+            );\n+            self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n+        }\n \n-                std::mem::drop(tmp);\n+        std::mem::drop(tmp);\n \n-                // Propagate dataflow state along the \"otherwise\" edge.\n-                let otherwise = targets.last().copied().unwrap();\n-                self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n-            }\n+        // Propagate dataflow state along the \"otherwise\" edge.\n+        let otherwise = targets.last().copied().unwrap();\n+        self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n+    }\n+}\n \n-            _ => {\n-                for target in targets.iter().copied() {\n-                    self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n-                }\n+/// Look at the last statement of a block that ends with  to see if it is an assignment of an enum\n+/// discriminant to the local that determines the target of a `SwitchInt` like so:\n+///   _42 = discriminant(..)\n+///   SwitchInt(_42, ..)\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mir::Body<'tcx>,\n+    block: &mir::BasicBlockData<'tcx>,\n+    switch_on: &mir::Place<'tcx>,\n+) -> Option<&'tcx ty::AdtDef> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind {\n+                ty::Adt(def, _) => Some(def),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n             }\n         }\n+\n+        _ => None,\n     }\n }\n "}]}