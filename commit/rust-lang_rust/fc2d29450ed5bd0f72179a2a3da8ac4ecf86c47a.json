{"sha": "fc2d29450ed5bd0f72179a2a3da8ac4ecf86c47a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMmQyOTQ1MGVkNWJkMGY3MjE3OWEyYTNkYThhYzRlY2Y4NmM0N2E=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-18T05:20:44Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-18T05:20:44Z"}, "message": "no really I deleted you", "tree": {"sha": "b0e988f5d4d1b4f7d507f294931f5b0aedf18da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0e988f5d4d1b4f7d507f294931f5b0aedf18da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc2d29450ed5bd0f72179a2a3da8ac4ecf86c47a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2d29450ed5bd0f72179a2a3da8ac4ecf86c47a", "html_url": "https://github.com/rust-lang/rust/commit/fc2d29450ed5bd0f72179a2a3da8ac4ecf86c47a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc2d29450ed5bd0f72179a2a3da8ac4ecf86c47a/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba459a5c2abf1c6869f0947e297b0805cdc27ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba459a5c2abf1c6869f0947e297b0805cdc27ef", "html_url": "https://github.com/rust-lang/rust/commit/eba459a5c2abf1c6869f0947e297b0805cdc27ef"}], "stats": {"total": 233, "additions": 0, "deletions": 233}, "files": [{"sha": "bd44bb6964af513fbf35bce9f4ba22f9c25ee7df", "filename": "src/doc/tarpl/lifetime-misc.md", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Flifetime-misc.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Flifetime-misc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-misc.md?ref=eba459a5c2abf1c6869f0947e297b0805cdc27ef", "patch": "@@ -1,233 +0,0 @@\n-% misc\n-\n-This is just a dumping ground while I work out what to do with this stuff\n-\n-\n-# PhantomData\n-\n-When working with unsafe code, we can often end up in a situation where\n-types or lifetimes are logically associated with a struct, but not actually\n-part of a field. This most commonly occurs with lifetimes. For instance, the `Iter`\n-for `&'a [T]` is (approximately) defined as follows:\n-\n-```rust,ignore\n-struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n-    end: *const T,\n-}\n-```\n-\n-However because `'a` is unused within the struct's body, it's *unbound*.\n-Because of the troubles this has historically caused, unbound lifetimes and\n-types are *illegal* in struct definitions. Therefore we must somehow refer\n-to these types in the body. Correctly doing this is necessary to have\n-correct variance and drop checking.\n-\n-We do this using *PhantomData*, which is a special marker type. PhantomData\n-consumes no space, but simulates a field of the given type for the purpose of\n-static analysis. This was deemed to be less error-prone than explicitly telling\n-the type-system the kind of variance that you want, while also providing other\n-useful information.\n-\n-Iter logically contains `&'a T`, so this is exactly what we tell\n-the PhantomData to simulate:\n-\n-```\n-use std::marker;\n-\n-struct Iter<'a, T: 'a> {\n-    ptr: *const T,\n-    end: *const T,\n-    _marker: marker::PhantomData<&'a T>,\n-}\n-```\n-\n-\n-\n-\n-# Dropck\n-\n-When a type is going out of scope, Rust will try to Drop it. Drop executes\n-arbitrary code, and in fact allows us to \"smuggle\" arbitrary code execution\n-into many places. As such additional soundness checks (dropck) are necessary to\n-ensure that a type T can be safely instantiated and dropped. It turns out that we\n-*really* don't need to care about dropck in practice, as it often \"just works\".\n-\n-However the one exception is with PhantomData. Given a struct like Vec:\n-\n-```\n-struct Vec<T> {\n-    data: *const T, // *const for variance!\n-    len: usize,\n-    cap: usize,\n-}\n-```\n-\n-dropck will generously determine that Vec<T> does not own any values of\n-type T. This will unfortunately allow people to construct unsound Drop\n-implementations that access data that has already been dropped. In order to\n-tell dropck that we *do* own values of type T, and may call destructors of that\n-type, we must add extra PhantomData:\n-\n-```\n-use std::marker;\n-\n-struct Vec<T> {\n-    data: *const T, // *const for covariance!\n-    len: usize,\n-    cap: usize,\n-    _marker: marker::PhantomData<T>,\n-}\n-```\n-\n-Raw pointers that own an allocation is such a pervasive pattern that the\n-standard library made a utility for itself called `Unique<T>` which:\n-\n-* wraps a `*const T`,\n-* includes a `PhantomData<T>`,\n-* auto-derives Send/Sync as if T was contained\n-* marks the pointer as NonZero for the null-pointer optimization\n-\n-\n-\n-\n-# Splitting Lifetimes\n-\n-The mutual exclusion property of mutable references can be very limiting when\n-working with a composite structure. The borrow checker understands some basic stuff, but\n-will fall over pretty easily. It *does* understand structs sufficiently to\n-know that it's possible to borrow disjoint fields of a struct simultaneously.\n-So this works today:\n-\n-```rust\n-struct Foo {\n-    a: i32,\n-    b: i32,\n-    c: i32,\n-}\n-\n-let mut x = Foo {a: 0, b: 0, c: 0};\n-let a = &mut x.a;\n-let b = &mut x.b;\n-let c = &x.c;\n-*b += 1;\n-let c2 = &x.c;\n-*a += 10;\n-println!(\"{} {} {} {}\", a, b, c, c2);\n-```\n-\n-However borrowck doesn't understand arrays or slices in any way, so this doesn't\n-work:\n-\n-```rust,ignore\n-let x = [1, 2, 3];\n-let a = &mut x[0];\n-let b = &mut x[1];\n-println!(\"{} {}\", a, b);\n-```\n-\n-```text\n-<anon>:3:18: 3:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n-<anon>:3     let a = &mut x[0];\n-                          ^~~~\n-<anon>:4:18: 4:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n-<anon>:4     let b = &mut x[1];\n-                          ^~~~\n-error: aborting due to 2 previous errors\n-```\n-\n-While it was plausible that borrowck could understand this simple case, it's\n-pretty clearly hopeless for borrowck to understand disjointness in general\n-container types like a tree, especially if distinct keys actually *do* map\n-to the same value.\n-\n-In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n-to unsafe code. For instance, mutable slices expose a `split_at_mut` function that\n-consumes the slice and returns *two* mutable slices. One for everything to the\n-left of the index, and one for everything to the right. Intuitively we know this\n-is safe because the slices don't alias. However the implementation requires some\n-unsafety:\n-\n-```rust,ignore\n-fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-    unsafe {\n-        let self2: &mut [T] = mem::transmute_copy(&self);\n-\n-        (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n-         ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n-    }\n-}\n-```\n-\n-This is pretty plainly dangerous. We use transmute to duplicate the slice with an\n-*unbounded* lifetime, so that it can be treated as disjoint from the other until\n-we unify them when we return.\n-\n-However more subtle is how iterators that yield mutable references work.\n-The iterator trait is defined as follows:\n-\n-```rust\n-trait Iterator {\n-    type Item;\n-\n-    fn next(&mut self) -> Option<Self::Item>;\n-}\n-```\n-\n-Given this definition, Self::Item has *no* connection to `self`. This means\n-that we can call `next` several times in a row, and hold onto all the results\n-*concurrently*. This is perfectly fine for by-value iterators, which have exactly\n-these semantics. It's also actually fine for shared references, as they admit\n-arbitrarily many references to the same thing (although the\n-iterator needs to be a separate object from the thing being shared). But mutable\n-references make this a mess. At first glance, they might seem completely\n-incompatible with this API, as it would produce multiple mutable references to\n-the same object!\n-\n-However it actually *does* work, exactly because iterators are one-shot objects.\n-Everything an IterMut yields will be yielded *at most* once, so we don't *actually*\n-ever yield multiple mutable references to the same piece of data.\n-\n-In general all mutable iterators require *some* unsafe code *somewhere*, though.\n-Whether it's raw pointers, or safely composing on top of *another* IterMut.\n-\n-For instance, VecDeque's IterMut:\n-\n-```rust,ignore\n-struct IterMut<'a, T:'a> {\n-    // The whole backing array. Some of these indices are initialized!\n-    ring: &'a mut [T],\n-    tail: usize,\n-    head: usize,\n-}\n-\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-\n-    fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-\n-        unsafe {\n-            // might as well do unchecked indexing since wrap_index has us\n-            // in-bounds, and many of the \"middle\" indices are uninitialized\n-            // anyway.\n-            let elem = self.ring.get_unchecked_mut(tail);\n-\n-            // round-trip through a raw pointer to unbound the lifetime from\n-            // ourselves\n-            Some(&mut *(elem as *mut _))\n-        }\n-    }\n-}\n-```\n-\n-A very subtle but interesting detail in this design is that it *relies on\n-privacy to be sound*. Borrowck works on some very simple rules. One of those rules\n-is that if we have a live &mut Foo and Foo contains an &mut Bar, then that &mut\n-Bar is *also* live. Since IterMut is always live when `next` can be called, if\n-`ring` were public then we could mutate `ring` while outstanding mutable borrows\n-to it exist!"}]}