{"sha": "de2b8d98eac98bed714be9524aaf80eedb78a74b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMmI4ZDk4ZWFjOThiZWQ3MTRiZTk1MjRhYWY4MGVlZGI3OGE3NGI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-27T21:49:08Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-27T21:49:08Z"}, "message": "Merge pull request #960 from rust-lang-nursery/big-closures\n\nBlock indent large closures and field/method chains", "tree": {"sha": "2aaef9867969f9345dea4a81fabac498b725a748", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aaef9867969f9345dea4a81fabac498b725a748"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de2b8d98eac98bed714be9524aaf80eedb78a74b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de2b8d98eac98bed714be9524aaf80eedb78a74b", "html_url": "https://github.com/rust-lang/rust/commit/de2b8d98eac98bed714be9524aaf80eedb78a74b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de2b8d98eac98bed714be9524aaf80eedb78a74b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9188ec0f7fd068608c9446cce99944c4cc33ede3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9188ec0f7fd068608c9446cce99944c4cc33ede3", "html_url": "https://github.com/rust-lang/rust/commit/9188ec0f7fd068608c9446cce99944c4cc33ede3"}, {"sha": "fcd2021583a9a708d8333b8dc3c8b0e8ac55380d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd2021583a9a708d8333b8dc3c8b0e8ac55380d", "html_url": "https://github.com/rust-lang/rust/commit/fcd2021583a9a708d8333b8dc3c8b0e8ac55380d"}], "stats": {"total": 1303, "additions": 843, "deletions": 460}, "files": [{"sha": "c84b66340a8a7a4d2e8a6bc0e7974c4a2beda0d3", "filename": "bootstrap.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bootstrap.sh?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+\n+# Make sure you double check the diffs after running this script - with great\n+# power comes great responsibility.\n+# We deliberately avoid reformatting files with rustfmt comment directives.\n+\n+cargo build\n+\n+target/debug/rustfmt --write-mode=overwrite src/lib.rs\n+target/debug/rustfmt --write-mode=overwrite src/bin/rustfmt.rs\n+target/debug/rustfmt --write-mode=overwrite src/bin/cargo-fmt.rs\n+target/debug/rustfmt --write-mode=overwrite tests/system.rs\n+\n+for filename in tests/target/*.rs; do\n+    if ! grep -q \"rustfmt-\" \"$filename\"; then\n+        target/debug/rustfmt --write-mode=overwrite $filename\n+    fi\n+done"}, {"sha": "909d62b20f87ed261eab7e44910f4659fa1f3bf9", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -98,14 +98,14 @@ fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n \n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets.into_iter()\n-                               .filter(|t| t.kind.is_lib() | t.kind.is_bin())\n-                               .inspect(|t| {\n-                                   if verbosity == Verbosity::Verbose {\n-                                       println!(\"[{:?}] {:?}\", t.kind, t.path)\n-                                   }\n-                               })\n-                               .map(|t| t.path)\n-                               .collect();\n+        .filter(|t| t.kind.is_lib() | t.kind.is_bin())\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{:?}] {:?}\", t.kind, t.path)\n+            }\n+        })\n+        .map(|t| t.path)\n+        .collect();\n \n     format_files(&files, &get_fmt_args(), verbosity)\n }\n@@ -201,9 +201,9 @@ fn format_files(files: &Vec<PathBuf>,\n         println!(\"\");\n     }\n     let mut command = try!(Command::new(\"rustfmt\")\n-                               .stdout(stdout)\n-                               .args(files)\n-                               .args(fmt_args)\n-                               .spawn());\n+        .stdout(stdout)\n+        .args(files)\n+        .args(fmt_args)\n+        .spawn());\n     command.wait()\n }"}, {"sha": "2105a962997773534ef54f36f411250cad639b78", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -191,7 +191,7 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n             let (mut config, _) = match_cli_path_or_file(config_path, &env::current_dir().unwrap())\n-                                      .expect(\"Error resolving config\");\n+                .expect(\"Error resolving config\");\n \n             // write_mode is always Plain for Stdin.\n             config.write_mode = WriteMode::Plain;\n@@ -205,8 +205,7 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             // Load the config path file if provided\n             if let Some(config_file) = config_path {\n                 let (cfg_tmp, path_tmp) = resolve_config(config_file.as_ref())\n-                                              .expect(&format!(\"Error resolving config for {:?}\",\n-                                                               config_file));\n+                    .expect(&format!(\"Error resolving config for {:?}\", config_file));\n                 config = cfg_tmp;\n                 path = path_tmp;\n             };\n@@ -219,9 +218,7 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                 // Check the file directory if the config-path could not be read or not provided\n                 if path.is_none() {\n                     let (config_tmp, path_tmp) = resolve_config(file.parent().unwrap())\n-                                                     .expect(&format!(\"Error resolving config \\\n-                                                                       for {}\",\n-                                                                      file.display()));\n+                        .expect(&format!(\"Error resolving config for {}\", file.display()));\n                     if let Some(path) = path_tmp.as_ref() {\n                         println!(\"Using rustfmt config file {} for {}\",\n                                  path.display(),\n@@ -301,13 +298,13 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n \n     // Read the config_path and convert to parent dir if a file is provided.\n     let config_path: Option<PathBuf> = matches.opt_str(\"config-path\")\n-                                              .map(PathBuf::from)\n-                                              .and_then(|dir| {\n-                                                  if dir.is_file() {\n-                                                      return dir.parent().map(|v| v.into());\n-                                                  }\n-                                                  Some(dir)\n-                                              });\n+        .map(PathBuf::from)\n+        .and_then(|dir| {\n+            if dir.is_file() {\n+                return dir.parent().map(|v| v.into());\n+            }\n+            Some(dir)\n+        });\n \n     // if no file argument is supplied, read from stdin\n     if matches.free.is_empty() {"}, {"sha": "aa6034aa6871eb030aae0755f07a821b70fdfda3", "filename": "src/chains.rs", "status": "modified", "additions": 207, "deletions": 88, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -8,16 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Formatting of chained expressions, i.e. expressions which are chained by\n-// dots: struct and enum field access and method calls.\n-//\n-// Instead of walking these subexpressions one-by-one, as is our usual strategy\n-// for expression formatting, we collect maximal sequences of these expressions\n-// and handle them simultaneously.\n-//\n-// Whenever possible, the entire chain is put on a single line. If that fails,\n-// we put each subexpression on a separate, much like the (default) function\n-// argument function argument strategy.\n+/// Formatting of chained expressions, i.e. expressions which are chained by\n+/// dots: struct and enum field access and method calls.\n+///\n+/// Instead of walking these subexpressions one-by-one, as is our usual strategy\n+/// for expression formatting, we collect maximal sequences of these expressions\n+/// and handle them simultaneously.\n+///\n+/// Whenever possible, the entire chain is put on a single line. If that fails,\n+/// we put each subexpression on a separate, much like the (default) function\n+/// argument function argument strategy.\n+///\n+/// Depends on config options: `chain_base_indent` is the indent to use for\n+/// blocks in the parent/root/base of the chain.\n+/// E.g., `let foo = { aaaa; bbb; ccc }.bar.baz();`, we would layout for the\n+/// following values of `chain_base_indent`:\n+/// Visual:\n+/// ```\n+/// let foo = {\n+///               aaaa;\n+///               bbb;\n+///               ccc\n+///           }\n+///           .bar\n+///           .baz();\n+/// ```\n+/// Inherit:\n+/// ```\n+/// let foo = {\n+///     aaaa;\n+///     bbb;\n+///     ccc\n+/// }\n+/// .bar\n+/// .baz();\n+/// ```\n+/// Tabbed:\n+/// ```\n+/// let foo = {\n+///         aaaa;\n+///         bbb;\n+///         ccc\n+///     }\n+///     .bar\n+///     .baz();\n+/// ```\n+///\n+/// `chain_indent` dictates how the rest of the chain is aligned.\n+/// If the first item in the chain is a block expression, we align the dots with\n+/// the braces.\n+/// Visual:\n+/// ```\n+/// let a = foo.bar\n+///            .baz()\n+///            .qux\n+/// ```\n+/// Inherit:\n+/// ```\n+/// let a = foo.bar\n+/// .baz()\n+/// .qux\n+/// ```\n+/// Tabbed:\n+/// ```\n+/// let a = foo.bar\n+///     .baz()\n+///     .qux\n+/// ```\n+/// `chains_overflow_last` applies only to chains where the last item is a\n+/// method call. Usually, any line break in a chain sub-expression causes the\n+/// whole chain to be split with newlines at each `.`. With `chains_overflow_last`\n+/// true, then we allow the last method call to spill over multiple lines without\n+/// forcing the rest of the chain to be split.\n+\n \n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n@@ -28,58 +91,48 @@ use config::BlockIndentStyle;\n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n-pub fn rewrite_chain(mut expr: &ast::Expr,\n+\n+pub fn rewrite_chain(expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n-    let mut subexpr_list = vec![expr];\n-\n-    while let Some(subexpr) = pop_expr_chain(expr) {\n-        subexpr_list.push(subexpr);\n-        expr = subexpr;\n-    }\n+    let (parent, subexpr_list) = make_subexpr_list(expr);\n \n-    let parent_block_indent = match context.config.chain_base_indent {\n-        BlockIndentStyle::Visual => offset,\n-        BlockIndentStyle::Inherit => context.block_indent,\n-        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n-    };\n+    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+    let parent_block_indent = chain_base_indent(context, offset);\n     let parent_context = &RewriteContext { block_indent: parent_block_indent, ..*context };\n-    let parent = subexpr_list.pop().unwrap();\n-    let parent_rewrite = try_opt!(expr.rewrite(parent_context, width, offset));\n+    let parent_rewrite = try_opt!(parent.rewrite(parent_context, width, offset));\n+\n+    // Decide how to layout the rest of the chain. `extend` is true if we can\n+    // put the first non-parent item on the same line as the parent.\n     let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n                               parent_rewrite.len() <= context.config.tab_spaces {\n-        (offset + Indent::new(0, parent_rewrite.len()), true)\n+        // Try and put at least the first two items on the same line.\n+        (chain_indent(context, offset + Indent::new(0, parent_rewrite.len())), true)\n     } else if is_block_expr(parent, &parent_rewrite) {\n+        // The parent is a block, so align the rest of the chain with the closing\n+        // brace.\n         (parent_block_indent, false)\n+    } else if parent_rewrite.contains('\\n') {\n+        (chain_indent(context, parent_block_indent.block_indent(context.config)), false)\n     } else {\n-        match context.config.chain_indent {\n-            BlockIndentStyle::Inherit => (context.block_indent, false),\n-            BlockIndentStyle::Tabbed => (context.block_indent.block_indent(context.config), false),\n-            BlockIndentStyle::Visual => (offset + Indent::new(context.config.tab_spaces, 0), false),\n-        }\n+        (chain_indent_newline(context, offset + Indent::new(0, parent_rewrite.len())), false)\n     };\n \n     let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n     let mut rewrites = try_opt!(subexpr_list.iter()\n-                                            .rev()\n-                                            .map(|e| {\n-                                                rewrite_chain_expr(e,\n-                                                                   total_span,\n-                                                                   context,\n-                                                                   max_width,\n-                                                                   indent)\n-                                            })\n-                                            .collect::<Option<Vec<_>>>());\n+        .rev()\n+        .map(|e| rewrite_chain_subexpr(e, total_span, context, max_width, indent))\n+        .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n     let almost_total = rewrites[..rewrites.len() - 1]\n-                           .iter()\n-                           .fold(0, |a, b| a + first_line_width(b)) +\n-                       parent_rewrite.len();\n+        .iter()\n+        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n     let total_width = almost_total + first_line_width(rewrites.last().unwrap());\n+\n     let veto_single_line = if context.config.take_source_hints && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n@@ -92,49 +145,40 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n         false\n     };\n \n-    let fits_single_line = !veto_single_line &&\n-                           match subexpr_list[0].node {\n-        ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions)\n-            if context.config.chains_overflow_last => {\n-            let len = rewrites.len();\n-            let (init, last) = rewrites.split_at_mut(len - 1);\n-            let last = &mut last[0];\n-\n-            if init.iter().all(|s| !s.contains('\\n')) && total_width <= width {\n-                let last_rewrite = width.checked_sub(almost_total)\n-                                        .and_then(|inner_width| {\n-                                            rewrite_method_call(method_name.node,\n-                                                                types,\n-                                                                expressions,\n-                                                                total_span,\n-                                                                context,\n-                                                                inner_width,\n-                                                                offset + almost_total)\n-                                        });\n-                match last_rewrite {\n-                    Some(mut string) => {\n-                        ::std::mem::swap(&mut string, last);\n-                        true\n-                    }\n-                    None => false,\n+    let mut fits_single_line = !veto_single_line && total_width <= width;\n+    if fits_single_line {\n+        let len = rewrites.len();\n+        let (init, last) = rewrites.split_at_mut(len - 1);\n+        fits_single_line = init.iter().all(|s| !s.contains('\\n'));\n+\n+        if fits_single_line {\n+            fits_single_line = match expr.node {\n+                ref e @ ast::ExprKind::MethodCall(..) if context.config.chains_overflow_last => {\n+                    rewrite_method_call_with_overflow(e,\n+                                                      &mut last[0],\n+                                                      almost_total,\n+                                                      width,\n+                                                      total_span,\n+                                                      context,\n+                                                      offset)\n                 }\n-            } else {\n-                false\n+                _ => !last[0].contains('\\n'),\n             }\n         }\n-        _ => total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')),\n-    };\n+    }\n \n     let connector = if fits_single_line && !parent_rewrite.contains('\\n') {\n+        // Yay, we can put everything on one line.\n         String::new()\n     } else {\n+        // Use new lines.\n         format!(\"\\n{}\", indent.to_string(context.config))\n     };\n \n     let first_connector = if extend {\n         \"\"\n     } else {\n-        &connector[..]\n+        &*connector\n     };\n \n     wrap_str(format!(\"{}{}{}\",\n@@ -147,7 +191,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n }\n \n // States whether an expression's last line exclusively consists of closing\n-// parens, braces and brackets in its idiomatic formatting.\n+// parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n         ast::ExprKind::Struct(..) |\n@@ -167,21 +211,96 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n     }\n }\n \n-fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n-    match expr.node {\n-        ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-        ast::ExprKind::TupField(ref subexpr, _) |\n-        ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n-        _ => None,\n+// Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n+// E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n+fn make_subexpr_list(mut expr: &ast::Expr) -> (&ast::Expr, Vec<&ast::Expr>) {\n+    fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n+        match expr.node {\n+            ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n+            ast::ExprKind::TupField(ref subexpr, _) |\n+            ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n+            _ => None,\n+        }\n+    }\n+\n+    let mut subexpr_list = vec![expr];\n+\n+    while let Some(subexpr) = pop_expr_chain(expr) {\n+        subexpr_list.push(subexpr);\n+        expr = subexpr;\n+    }\n+\n+    let parent = subexpr_list.pop().unwrap();\n+    (parent, subexpr_list)\n+}\n+\n+fn chain_base_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+    match context.config.chain_base_indent {\n+        BlockIndentStyle::Visual => offset,\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+    }\n+}\n+\n+fn chain_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+    match context.config.chain_indent {\n+        BlockIndentStyle::Visual => offset,\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+    }\n+}\n+\n+// Ignores visual indenting because this function should be called where it is\n+// not possible to use visual indentation because we are starting on a newline.\n+fn chain_indent_newline(context: &RewriteContext, _offset: Indent) -> Indent {\n+    match context.config.chain_indent {\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Visual | BlockIndentStyle::Tabbed => {\n+            context.block_indent.block_indent(context.config)\n+        }\n+    }\n+}\n+\n+fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n+                                     last: &mut String,\n+                                     almost_total: usize,\n+                                     width: usize,\n+                                     total_span: Span,\n+                                     context: &RewriteContext,\n+                                     offset: Indent)\n+                                     -> bool {\n+    if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n+        let budget = match width.checked_sub(almost_total) {\n+            Some(b) => b,\n+            None => return false,\n+        };\n+        let mut last_rewrite = rewrite_method_call(method_name.node,\n+                                                   types,\n+                                                   expressions,\n+                                                   total_span,\n+                                                   context,\n+                                                   budget,\n+                                                   offset + almost_total);\n+\n+        if let Some(ref mut s) = last_rewrite {\n+            ::std::mem::swap(s, last);\n+            true\n+        } else {\n+            false\n+        }\n+    } else {\n+        unreachable!();\n     }\n }\n \n-fn rewrite_chain_expr(expr: &ast::Expr,\n-                      span: Span,\n-                      context: &RewriteContext,\n-                      width: usize,\n-                      offset: Indent)\n-                      -> Option<String> {\n+// Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n+// `.c`.\n+fn rewrite_chain_subexpr(expr: &ast::Expr,\n+                         span: Span,\n+                         context: &RewriteContext,\n+                         width: usize,\n+                         offset: Indent)\n+                         -> Option<String> {\n     match expr.node {\n         ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n             let inner = &RewriteContext { block_indent: offset, ..*context };\n@@ -213,7 +332,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n     }\n }\n \n-// Determines we can continue formatting a given expression on the same line.\n+// Determines if we can continue formatting a given expression on the same line.\n fn is_continuable(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Path(..) => true,\n@@ -233,8 +352,8 @@ fn rewrite_method_call(method_name: ast::Ident,\n         (args[0].span.hi, String::new())\n     } else {\n         let type_list: Vec<_> = try_opt!(types.iter()\n-                                              .map(|ty| ty.rewrite(context, width, offset))\n-                                              .collect());\n+            .map(|ty| ty.rewrite(context, width, offset))\n+            .collect());\n \n         (types.last().unwrap().span.hi, format!(\"::<{}>\", type_list.join(\", \")))\n     };"}, {"sha": "991faa3c9c8ef1be898f7abd3e25088ee5989e68", "filename": "src/comment.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -70,24 +70,24 @@ pub fn rewrite_comment(orig: &str,\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n     let lines = s.lines()\n-                 .enumerate()\n-                 .map(|(i, mut line)| {\n-                     line = line.trim();\n-                     // Drop old closer.\n-                     if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                         line = &line[..(line.len() - 2)];\n-                     }\n-\n-                     line.trim_right()\n-                 })\n-                 .map(left_trim_comment_line)\n-                 .map(|line| {\n-                     if line_breaks == 0 {\n-                         line.trim_left()\n-                     } else {\n-                         line\n-                     }\n-                 });\n+        .enumerate()\n+        .map(|(i, mut line)| {\n+            line = line.trim();\n+            // Drop old closer.\n+            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                line = &line[..(line.len() - 2)];\n+            }\n+\n+            line.trim_right()\n+        })\n+        .map(left_trim_comment_line)\n+        .map(|line| {\n+            if line_breaks == 0 {\n+                line.trim_left()\n+            } else {\n+                line\n+            }\n+        });\n \n     let mut result = opener.to_owned();\n     for line in lines {\n@@ -538,7 +538,7 @@ fn changed_comment_content(orig: &str, new: &str) -> bool {\n     let code_comment_content = |code| {\n         let slices = UngroupedCommentCodeSlices::new(code);\n         slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n-              .flat_map(|(_, _, s)| CommentReducer::new(s))\n+            .flat_map(|(_, _, s)| CommentReducer::new(s))\n     };\n     let res = code_comment_content(orig).ne(code_comment_content(new));\n     debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\","}, {"sha": "333835b66cdc0ec72d39a342115e2afab582869f", "filename": "src/config.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -188,6 +188,12 @@ impl ConfigType for usize {\n     }\n }\n \n+impl ConfigType for isize {\n+    fn doc_hint() -> String {\n+        String::from(\"<signed integer>\")\n+    }\n+}\n+\n impl ConfigType for String {\n     fn doc_hint() -> String {\n         String::from(\"<string>\")\n@@ -369,13 +375,13 @@ create_config! {\n         \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n     report_fixme: ReportTactic, ReportTactic::Never,\n         \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n-    chain_base_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on chain base\";\n-    chain_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of chain\";\n+    chain_base_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indent on chain base\";\n+    chain_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indentation of chain\";\n+    chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n     single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n     format_strings: bool, true, \"Format string literals where necessary\";\n     force_format_strings: bool, false, \"Always format string literals\";\n-    chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";\n     hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n     wrap_comments: bool, false, \"Break comments to fit on the line\";\n@@ -384,6 +390,8 @@ create_config! {\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n+    closure_block_indent_threshold: isize, 5, \"How many lines a closure must have before it is \\\n+                                               block indented. -1 means never use block indent.\";\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n }"}, {"sha": "c2d5115ba754bd95b872969b7cff32e301ce432f", "filename": "src/expr.rs", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -283,12 +283,11 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                              |item| item.rewrite(&inner_context, max_item_width, offset),\n                              span.lo,\n                              span.hi)\n-                    .collect::<Vec<_>>();\n+        .collect::<Vec<_>>();\n \n     let has_long_item = try_opt!(items.iter()\n-                                      .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n-                                      .fold(Some(false),\n-                                            |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n+        .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+        .fold(Some(false), |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n     let tactic = if has_long_item || items.iter().any(ListItem::is_multiline) {\n         definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n@@ -410,8 +409,8 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     if try_single_line && !force_block {\n         let must_preserve_braces =\n             !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(inner_block.expr\n-                                                                                   .as_ref()\n-                                                                                   .unwrap()));\n+                .as_ref()\n+                .unwrap()));\n         if !(must_preserve_braces && had_braces) &&\n            (must_preserve_braces || !prefix.contains('\\n')) {\n             // If we got here, then we can try to format without braces.\n@@ -455,9 +454,19 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n     // We couldn't format the closure body as a single line expression; fall\n     // back to block formatting.\n-    let body_rewrite = inner_block.rewrite(&context, budget, Indent::empty());\n+    let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n \n-    Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n+    let block_threshold = context.config.closure_block_indent_threshold;\n+    if block_threshold < 0 || body_rewrite.matches('\\n').count() <= block_threshold as usize {\n+        return Some(format!(\"{} {}\", prefix, body_rewrite));\n+    }\n+\n+    // The body of the closure is big enough to be block indented, that means we\n+    // must re-format.\n+    let mut context = context.clone();\n+    context.block_indent.alignment = 0;\n+    let body_rewrite = try_opt!(inner_block.rewrite(&context, budget, Indent::empty()));\n+    Some(format!(\"{} {}\", prefix, body_rewrite))\n }\n \n fn and_one_line(x: Option<String>) -> Option<String> {\n@@ -513,9 +522,9 @@ impl Rewrite for ast::Block {\n \n                 if is_simple_block(self, context.codemap) && prefix.len() < width {\n                     let body = self.expr\n-                                   .as_ref()\n-                                   .unwrap()\n-                                   .rewrite(context, width - prefix.len(), offset);\n+                        .as_ref()\n+                        .unwrap()\n+                        .rewrite(context, width - prefix.len(), offset);\n                     if let Some(ref expr_str) = body {\n                         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n                         if result.len() <= width && !result.contains('\\n') {\n@@ -558,9 +567,9 @@ impl Rewrite for ast::Stmt {\n                 };\n \n                 ex.rewrite(context,\n-                           context.config.max_width - offset.width() - suffix.len(),\n-                           offset)\n-                  .map(|s| s + suffix)\n+                             context.config.max_width - offset.width() - suffix.len(),\n+                             offset)\n+                    .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) => None,\n         };\n@@ -795,8 +804,8 @@ fn rewrite_if_else(context: &RewriteContext,\n                                                             width);\n \n         let after_else = mk_sp(context.codemap\n-                                      .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n-                                                  \"else\"),\n+                                   .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n+                                               \"else\"),\n                                else_block.span.lo);\n         let after_else_comment = extract_comment(after_else, &context, offset, width);\n \n@@ -812,9 +821,9 @@ fn rewrite_if_else(context: &RewriteContext,\n         try_opt!(write!(&mut result,\n                         \"{}else{}\",\n                         between_if_else_block_comment.as_ref()\n-                                                     .map_or(between_sep, |str| &**str),\n+                            .map_or(between_sep, |str| &**str),\n                         after_else_comment.as_ref().map_or(after_sep, |str| &**str))\n-                     .ok());\n+            .ok());\n         result.push_str(&&try_opt!(rewrite));\n     }\n \n@@ -958,7 +967,7 @@ fn rewrite_match(context: &RewriteContext,\n     let arm_indent_str = arm_indent.to_string(context.config);\n \n     let open_brace_pos = context.codemap\n-                                .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -1063,8 +1072,8 @@ impl Rewrite for ast::Arm {\n         // 5 = ` => {`\n         let pat_budget = try_opt!(width.checked_sub(5));\n         let pat_strs = try_opt!(pats.iter()\n-                                    .map(|p| p.rewrite(context, pat_budget, offset))\n-                                    .collect::<Option<Vec<_>>>());\n+            .map(|p| p.rewrite(context, pat_budget, offset))\n+            .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(&p));\n         let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n@@ -1435,7 +1444,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n \n     let tactic = definitive_tactic(&item_vec,\n                                    ListTactic::LimitedHorizontalVertical(context.config\n-                                                                                .fn_call_width),\n+                                       .fn_call_width),\n                                    remaining_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n@@ -1515,52 +1524,46 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     };\n \n     let field_iter = fields.into_iter()\n-                           .map(StructLitField::Regular)\n-                           .chain(base.into_iter().map(StructLitField::Base));\n+        .map(StructLitField::Regular)\n+        .chain(base.into_iter().map(StructLitField::Base));\n \n     let inner_context = &RewriteContext { block_indent: indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n                              field_iter,\n                              \"}\",\n                              |item| {\n-                                 match *item {\n-                                     StructLitField::Regular(ref field) => field.span.lo,\n-                                     StructLitField::Base(ref expr) => {\n-                                         let last_field_hi = fields.last().map_or(span.lo,\n-                                                                                  |field| {\n-                                                                                      field.span.hi\n-                                                                                  });\n-                                         let snippet = context.snippet(mk_sp(last_field_hi,\n-                                                                             expr.span.lo));\n-                                         let pos = snippet.find_uncommented(\"..\").unwrap();\n-                                         last_field_hi + BytePos(pos as u32)\n-                                     }\n-                                 }\n-                             },\n+        match *item {\n+            StructLitField::Regular(ref field) => field.span.lo,\n+            StructLitField::Base(ref expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        }\n+    },\n                              |item| {\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.hi,\n                                      StructLitField::Base(ref expr) => expr.span.hi,\n                                  }\n                              },\n                              |item| {\n-                                 match *item {\n-                                     StructLitField::Regular(ref field) => {\n-                                         rewrite_field(inner_context,\n-                                                       &field,\n-                                                       v_budget.checked_sub(1).unwrap_or(0),\n-                                                       indent)\n-                                     }\n-                                     StructLitField::Base(ref expr) => {\n-                                         // 2 = ..\n-                                         expr.rewrite(inner_context,\n-                                                      try_opt!(v_budget.checked_sub(2)),\n-                                                      indent + 2)\n-                                             .map(|s| format!(\"..{}\", s))\n-                                     }\n-                                 }\n-                             },\n+        match *item {\n+            StructLitField::Regular(ref field) => {\n+                rewrite_field(inner_context,\n+                              &field,\n+                              v_budget.checked_sub(1).unwrap_or(0),\n+                              indent)\n+            }\n+            StructLitField::Base(ref expr) => {\n+                // 2 = ..\n+                expr.rewrite(inner_context, try_opt!(v_budget.checked_sub(2)), indent + 2)\n+                    .map(|s| format!(\"..{}\", s))\n+            }\n+        }\n+    },\n                              context.codemap.span_after(span, \"{\"),\n                              span.hi);\n     let item_vec = items.collect::<Vec<_>>();\n@@ -1607,8 +1610,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     let format_on_newline = || {\n         let inner_indent = context.block_indent\n-                                  .block_indent(context.config)\n-                                  .to_string(context.config);\n+            .block_indent(context.config)\n+            .to_string(context.config);\n         let outer_indent = context.block_indent.to_string(context.config);\n         Some(format!(\"{} {{\\n{}{}\\n{}}}\",\n                      path_str,\n@@ -1646,8 +1649,8 @@ fn rewrite_field(context: &RewriteContext,\n             let expr_offset = offset.block_indent(&context.config);\n             let expr = field.expr.rewrite(context,\n                                           try_opt!(context.config\n-                                                          .max_width\n-                                                          .checked_sub(expr_offset.width())),\n+                                              .max_width\n+                                              .checked_sub(expr_offset.width())),\n                                           expr_offset);\n             expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n         }\n@@ -1680,9 +1683,8 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n                              |item| item.span().hi,\n                              |item| {\n                                  let inner_width = try_opt!(context.config\n-                                                                   .max_width\n-                                                                   .checked_sub(indent.width() +\n-                                                                                1));\n+                                     .max_width\n+                                     .checked_sub(indent.width() + 1));\n                                  item.rewrite(context, inner_width, indent)\n                              },\n                              list_lo,\n@@ -1740,8 +1742,8 @@ fn rewrite_binary_op(context: &RewriteContext,\n \n     // Re-evaluate the lhs because we have more space now:\n     let budget = try_opt!(context.config\n-                                 .max_width\n-                                 .checked_sub(offset.width() + 1 + operator_str.len()));\n+        .max_width\n+        .checked_sub(offset.width() + 1 + operator_str.len()));\n     Some(format!(\"{} {}\\n{}{}\",\n                  try_opt!(lhs.rewrite(context, budget, offset)),\n                  operator_str,\n@@ -1756,9 +1758,9 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         offset: Indent)\n                                         -> Option<String> {\n     rewrite.rewrite(context,\n-                    try_opt!(width.checked_sub(prefix.len())),\n-                    offset + prefix.len())\n-           .map(|r| format!(\"{}{}\", prefix, r))\n+                 try_opt!(width.checked_sub(prefix.len())),\n+                 offset + prefix.len())\n+        .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,"}, {"sha": "5ded7c2c5e8f723dc15b63569587d50f62f3d897", "filename": "src/items.rs", "status": "modified", "additions": 72, "deletions": 80, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -277,10 +277,10 @@ impl<'a> FmtVisitor<'a> {\n                     };\n \n                     e.rewrite(&self.get_context(),\n-                              self.config.max_width - self.block_indent.width(),\n-                              self.block_indent)\n-                     .map(|s| s + suffix)\n-                     .or_else(|| Some(self.snippet(e.span)))\n+                                 self.config.max_width - self.block_indent.width(),\n+                                 self.block_indent)\n+                        .map(|s| s + suffix)\n+                        .or_else(|| Some(self.snippet(e.span)))\n                 } else if let Some(ref stmt) = block.stmts.first() {\n                     stmt.rewrite(&self.get_context(),\n                                  self.config.max_width - self.block_indent.width(),\n@@ -321,7 +321,7 @@ impl<'a> FmtVisitor<'a> {\n                                            self.block_indent,\n                                            self.block_indent.block_indent(self.config),\n                                            mk_sp(span.lo, body_start))\n-                               .unwrap();\n+            .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n@@ -359,12 +359,12 @@ impl<'a> FmtVisitor<'a> {\n                                  enum_def.variants.iter(),\n                                  \"}\",\n                                  |f| {\n-                                     if !f.node.attrs.is_empty() {\n-                                         f.node.attrs[0].span.lo\n-                                     } else {\n-                                         f.span.lo\n-                                     }\n-                                 },\n+            if !f.node.attrs.is_empty() {\n+                f.node.attrs[0].span.lo\n+            } else {\n+                f.span.lo\n+            }\n+        },\n                                  |f| f.span.hi,\n                                  |f| self.format_variant(f),\n                                  body_lo,\n@@ -397,10 +397,10 @@ impl<'a> FmtVisitor<'a> {\n \n         let indent = self.block_indent;\n         let mut result = try_opt!(field.node\n-                                       .attrs\n-                                       .rewrite(&self.get_context(),\n-                                                self.config.max_width - indent.width(),\n-                                                indent));\n+            .attrs\n+            .rewrite(&self.get_context(),\n+                     self.config.max_width - indent.width(),\n+                     indent));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -666,8 +666,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         };\n \n         let where_budget = try_opt!(context.config\n-                                           .max_width\n-                                           .checked_sub(last_line_width(&result)));\n+            .max_width\n+            .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config,\n@@ -803,13 +803,13 @@ fn format_struct_struct(context: &RewriteContext,\n                              fields.iter(),\n                              \"}\",\n                              |field| {\n-                                 // Include attributes and doc comments, if present\n-                                 if !field.node.attrs.is_empty() {\n-                                     field.node.attrs[0].span.lo\n-                                 } else {\n-                                     field.span.lo\n-                                 }\n-                             },\n+        // Include attributes and doc comments, if present\n+        if !field.node.attrs.is_empty() {\n+            field.node.attrs[0].span.lo\n+        } else {\n+            field.span.lo\n+        }\n+    },\n                              |field| field.node.ty.span.hi,\n                              |field| field.rewrite(context, item_budget, item_indent),\n                              context.codemap.span_after(span, \"{\"),\n@@ -864,8 +864,8 @@ fn format_tuple_struct(context: &RewriteContext,\n             result.push_str(&generics_str);\n \n             let where_budget = try_opt!(context.config\n-                                               .max_width\n-                                               .checked_sub(last_line_width(&result)));\n+                .max_width\n+                .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n                                           context.config,\n@@ -889,13 +889,13 @@ fn format_tuple_struct(context: &RewriteContext,\n                              fields.iter(),\n                              \")\",\n                              |field| {\n-                                 // Include attributes and doc comments, if present\n-                                 if !field.node.attrs.is_empty() {\n-                                     field.node.attrs[0].span.lo\n-                                 } else {\n-                                     field.span.lo\n-                                 }\n-                             },\n+        // Include attributes and doc comments, if present\n+        if !field.node.attrs.is_empty() {\n+            field.node.attrs[0].span.lo\n+        } else {\n+            field.span.lo\n+        }\n+    },\n                              |field| field.node.ty.span.hi,\n                              |field| field.rewrite(context, item_budget, item_indent),\n                              context.codemap.span_after(span, \"(\"),\n@@ -912,7 +912,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n         result.push_str(&(context.block_indent + (context.config.tab_spaces - 1))\n-                             .to_string(context.config));\n+            .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n \n@@ -946,8 +946,8 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     result.push_str(&generics_str);\n \n     let where_budget = try_opt!(context.config\n-                                       .max_width\n-                                       .checked_sub(last_line_width(&result)));\n+        .max_width\n+        .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n                                                          context.config,\n@@ -965,26 +965,25 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     // This checked_sub may fail as the extra space after '=' is not taken into account\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n     let budget = context.config\n-                        .max_width\n-                        .checked_sub(indent.width() + line_width + \";\".len())\n-                        .unwrap_or(0);\n+        .max_width\n+        .checked_sub(indent.width() + line_width + \";\".len())\n+        .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n     let ty_str = try_opt!(ty.rewrite(context, budget, type_indent)\n-                            .or_else(|| {\n-                                // The line was too short, try to put the type on the next line\n-\n-                                // Remove the space after '='\n-                                result.pop();\n-                                let type_indent = indent.block_indent(context.config);\n-                                result.push('\\n');\n-                                result.push_str(&type_indent.to_string(context.config));\n-                                let budget = try_opt!(context.config\n-                                                             .max_width\n-                                                             .checked_sub(type_indent.width() +\n-                                                                          \";\".len()));\n-                                ty.rewrite(context, budget, type_indent)\n-                            }));\n+        .or_else(|| {\n+            // The line was too short, try to put the type on the next line\n+\n+            // Remove the space after '='\n+            result.pop();\n+            let type_indent = indent.block_indent(context.config);\n+            result.push('\\n');\n+            result.push_str(&type_indent.to_string(context.config));\n+            let budget = try_opt!(context.config\n+                .max_width\n+                .checked_sub(type_indent.width() + \";\".len()));\n+            ty.rewrite(context, budget, type_indent)\n+        }));\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n     Some(result)\n@@ -1006,10 +1005,8 @@ impl Rewrite for ast::StructField {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         let mut attr_str = try_opt!(self.node\n-                                        .attrs\n-                                        .rewrite(context,\n-                                                 context.config.max_width - offset.width(),\n-                                                 offset));\n+            .attrs\n+            .rewrite(context, context.config.max_width - offset.width(), offset));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&offset.to_string(context.config));\n@@ -1069,11 +1066,9 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let bounds: &[_] = &ty_param_bounds.as_slice();\n         let bound_str = bounds.iter()\n-                              .filter_map(|ty_bound| {\n-                                  ty_bound.rewrite(context, context.config.max_width, indent)\n-                              })\n-                              .collect::<Vec<String>>()\n-                              .join(\" + \");\n+            .filter_map(|ty_bound| ty_bound.rewrite(context, context.config.max_width, indent))\n+            .collect::<Vec<String>>()\n+            .join(\" + \");\n         if bounds.len() > 0 {\n             format!(\": {}\", bound_str)\n         } else {\n@@ -1287,7 +1282,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     // Note that if the width and indent really matter, we'll re-layout the\n     // return type later anyway.\n     let ret_str = try_opt!(fd.output\n-                             .rewrite(&context, context.config.max_width - indent.width(), indent));\n+        .rewrite(&context, context.config.max_width - indent.width(), indent));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str {\n@@ -1332,8 +1327,8 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     // A conservative estimation, to goal is to be over all parens in generics\n     let args_start = generics.ty_params\n-                             .last()\n-                             .map_or(span.lo, |tp| end_typaram(tp));\n+        .last()\n+        .map_or(span.lo, |tp| end_typaram(tp));\n     let args_span = mk_sp(context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n                           span_for_return(&fd.output).lo);\n     let arg_str = try_opt!(rewrite_args(context,\n@@ -1408,7 +1403,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n             let budget = try_opt!(context.config.max_width.checked_sub(ret_indent.width()));\n             let ret_str = try_opt!(fd.output\n-                                     .rewrite(context, budget, ret_indent));\n+                .rewrite(context, budget, ret_indent));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1477,21 +1472,18 @@ fn rewrite_args(context: &RewriteContext,\n                 variadic: bool)\n                 -> Option<String> {\n     let mut arg_item_strs = try_opt!(args.iter()\n-                                         .map(|arg| {\n-                                             arg.rewrite(&context, multi_line_budget, arg_indent)\n-                                         })\n-                                         .collect::<Option<Vec<_>>>());\n+        .map(|arg| arg.rewrite(&context, multi_line_budget, arg_indent))\n+        .collect::<Option<Vec<_>>>());\n \n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n-    let min_args = explicit_self.and_then(|explicit_self| {\n-                                    rewrite_explicit_self(explicit_self, args, context)\n-                                })\n-                                .map_or(1, |self_str| {\n-                                    arg_item_strs[0] = self_str;\n-                                    2\n-                                });\n+    let min_args =\n+        explicit_self.and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n+            .map_or(1, |self_str| {\n+                arg_item_strs[0] = self_str;\n+                2\n+            });\n \n     // Comments between args.\n     let mut arg_items = Vec::new();\n@@ -1722,9 +1714,9 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     }\n \n     let bound_str = bounds.iter()\n-                          .filter_map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n-                          .collect::<Vec<String>>()\n-                          .join(\" + \");\n+        .filter_map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n+        .collect::<Vec<String>>()\n+        .join(\" + \");\n \n     let mut result = String::new();\n     result.push_str(\": \");"}, {"sha": "f966e41ce99a019b7d03f9a1558c9997010d907c", "filename": "src/lists.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -160,8 +160,8 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n           T: AsRef<ListItem>\n {\n     let pre_line_comments = items.clone()\n-                                 .into_iter()\n-                                 .any(|item| item.as_ref().has_line_pre_comment());\n+        .into_iter()\n+        .any(|item| item.as_ref().has_line_pre_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -353,9 +353,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n             let mut new_lines = false;\n             // Pre-comment\n             let pre_snippet = self.codemap\n-                                  .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n-                                                                  (self.get_lo)(&item)))\n-                                  .unwrap();\n+                .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n+                .unwrap();\n             let trimmed_pre_snippet = pre_snippet.trim();\n             let pre_comment = if !trimmed_pre_snippet.is_empty() {\n                 Some(trimmed_pre_snippet.to_owned())\n@@ -369,9 +368,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 None => self.next_span_start,\n             };\n             let post_snippet = self.codemap\n-                                   .span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n-                                                                   next_start))\n-                                   .unwrap();\n+                .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n+                .unwrap();\n \n             let comment_end = match self.inner.peek() {\n                 Some(..) => {\n@@ -413,7 +411,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n                 let first = test_snippet.find(|c: char| !c.is_whitespace())\n-                                        .unwrap_or(test_snippet.len());\n+                    .unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n \n@@ -494,8 +492,8 @@ fn calculate_width<I, T>(items: I) -> (usize, usize)\n           T: AsRef<ListItem>\n {\n     items.into_iter()\n-         .map(|item| total_item_width(item.as_ref()))\n-         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n+        .map(|item| total_item_width(item.as_ref()))\n+        .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n fn total_item_width(item: &ListItem) -> usize {"}, {"sha": "a0c7cd51bb797fe2bad3af1369507cd53120963c", "filename": "src/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -121,8 +121,9 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n             let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                                 mk_sp(context.codemap.span_after(mac.span,\n-                                                                  original_style.opener()),\n+                                                 mk_sp(context.codemap\n+                                                           .span_after(mac.span,\n+                                                                       original_style.opener()),\n                                                        mac.span.hi - BytePos(1)),\n                                                  context,\n                                                  try_opt!(width.checked_sub(extra_offset)),"}, {"sha": "2191a7812b1917306ba19e090c77b204543ac689", "filename": "src/missed_spans.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -93,14 +93,14 @@ impl<'a> FmtVisitor<'a> {\n \n         fn replace_chars(string: &str) -> String {\n             string.chars()\n-                  .map(|ch| {\n-                      if ch.is_whitespace() {\n-                          ch\n-                      } else {\n-                          'X'\n-                      }\n-                  })\n-                  .collect()\n+                .map(|ch| {\n+                    if ch.is_whitespace() {\n+                        ch\n+                    } else {\n+                        'X'\n+                    }\n+                })\n+                .collect()\n         }\n \n         let replaced = match self.config.write_mode {\n@@ -112,10 +112,10 @@ impl<'a> FmtVisitor<'a> {\n         for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n             if let CodeCharKind::Comment = kind {\n                 let last_char = big_snippet[..(offset + big_diff)]\n-                                    .chars()\n-                                    .rev()\n-                                    .skip_while(|rev_c| [' ', '\\t'].contains(&rev_c))\n-                                    .next();\n+                    .chars()\n+                    .rev()\n+                    .skip_while(|rev_c| [' ', '\\t'].contains(&rev_c))\n+                    .next();\n \n                 let fix_indent = last_char.map_or(true, |rev_c| ['{', '\\n'].contains(&rev_c));\n \n@@ -134,7 +134,7 @@ impl<'a> FmtVisitor<'a> {\n                                                           comment_width,\n                                                           self.block_indent,\n                                                           self.config)\n-                                              .unwrap());\n+                        .unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();"}, {"sha": "ba3621fc6d523fb1c110095e24f9e8bb436272c9", "filename": "src/patterns.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -103,15 +103,14 @@ impl Rewrite for Pat {\n             PatKind::Vec(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n-                let slice_pat = slice_pat.as_ref().map(|p| {\n-                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset))))\n-                });\n+                let slice_pat = slice_pat.as_ref()\n+                    .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset)))));\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, width, offset));\n \n                 // Munge them together.\n                 let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n-                                                      .chain(suffix)\n-                                                      .collect();\n+                    .chain(suffix)\n+                    .collect();\n \n                 // Check that all the rewrites succeeded, and if not return None.\n                 let pats = try_opt!(pats);"}, {"sha": "247b1df1c3faf6413db0353190f6bc63ba83a79f", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -27,6 +27,7 @@ pub trait Rewrite {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String>;\n }\n \n+#[derive(Clone)]\n pub struct RewriteContext<'a> {\n     pub parse_session: &'a ParseSess,\n     pub codemap: &'a CodeMap,"}, {"sha": "e90e24f7af2190476da763578924d6f24952ef6e", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -42,8 +42,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n     let mut result = String::with_capacity(stripped_str.len()\n-                                                       .checked_next_power_of_two()\n-                                                       .unwrap_or(usize::max_value()));\n+        .checked_next_power_of_two()\n+        .unwrap_or(usize::max_value()));\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();"}, {"sha": "a1d449f32492c5d8c38721eb7e83337eedc3300f", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -176,11 +176,11 @@ fn rewrite_segment(expr_context: bool,\n                                                          !data.types.is_empty() ||\n                                                          !data.bindings.is_empty() => {\n             let param_list = data.lifetimes\n-                                 .iter()\n-                                 .map(SegmentParam::LifeTime)\n-                                 .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n-                                 .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n-                                 .collect::<Vec<_>>();\n+                .iter()\n+                .map(SegmentParam::LifeTime)\n+                .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n+                .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n+                .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = context.codemap.span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n@@ -270,7 +270,7 @@ fn format_function_type<'a, I>(inputs: I,\n                              // FIXME Would be nice to avoid this allocation,\n                              // but I couldn't get the types to work out.\n                              inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n-                                   .chain(variadic_arg),\n+                                 .chain(variadic_arg),\n                              \")\",\n                              |arg| {\n                                  match *arg {\n@@ -285,13 +285,11 @@ fn format_function_type<'a, I>(inputs: I,\n                                  }\n                              },\n                              |arg| {\n-                                 match *arg {\n-                                     ArgumentKind::Regular(ref ty) => {\n-                                         ty.rewrite(context, budget, offset)\n-                                     }\n-                                     ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                                 }\n-                             },\n+        match *arg {\n+            ArgumentKind::Regular(ref ty) => ty.rewrite(context, budget, offset),\n+            ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+        }\n+    },\n                              list_lo,\n                              span.hi);\n \n@@ -408,8 +406,8 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n         Some(result)\n     } else {\n         let appendix: Vec<_> = try_opt!(bounds.into_iter()\n-                                              .map(|b| b.rewrite(context, width, offset))\n-                                              .collect());\n+            .map(|b| b.rewrite(context, width, offset))\n+            .collect());\n         let result = format!(\"{}: {}\", result, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, width, offset)\n     }\n@@ -442,8 +440,8 @@ impl Rewrite for ast::Lifetime {\n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let strs: Vec<_> = try_opt!(self.iter()\n-                                        .map(|b| b.rewrite(context, width, offset))\n-                                        .collect());\n+            .map(|b| b.rewrite(context, width, offset))\n+            .collect());\n         wrap_str(strs.join(\" + \"), context.config.max_width, width, offset)\n     }\n }\n@@ -456,10 +454,10 @@ impl Rewrite for ast::TyParam {\n             result.push_str(\": \");\n \n             let bounds = try_opt!(self.bounds\n-                                      .iter()\n-                                      .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n-                                      .collect::<Option<Vec<_>>>())\n-                             .join(\" + \");\n+                    .iter()\n+                    .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n+                    .collect::<Option<Vec<_>>>())\n+                .join(\" + \");\n \n             result.push_str(&bounds);\n         }\n@@ -483,15 +481,15 @@ impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str = try_opt!(self.bound_lifetimes\n-                                            .iter()\n-                                            .map(|lt| lt.rewrite(context, width, offset))\n-                                            .collect::<Option<Vec<_>>>())\n-                                   .join(\", \");\n+                    .iter()\n+                    .map(|lt| lt.rewrite(context, width, offset))\n+                    .collect::<Option<Vec<_>>>())\n+                .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));\n             let path_str = try_opt!(self.trait_ref\n-                                        .rewrite(context, max_path_width, offset + extra_offset));\n+                .rewrite(context, max_path_width, offset + extra_offset));\n \n             Some(format!(\"for<{}> {}\", lifetime_str, path_str))\n         } else {\n@@ -545,9 +543,8 @@ impl Rewrite for ast::Ty {\n                         format!(\"&{} {}{}\",\n                                 lt_str,\n                                 mut_str,\n-                                try_opt!(mt.ty.rewrite(context,\n-                                                       budget,\n-                                                       offset + 2 + mut_len + lt_len)))\n+                                try_opt!(mt.ty\n+                                    .rewrite(context, budget, offset + 2 + mut_len + lt_len)))\n                     }\n                     None => {\n                         let budget = try_opt!(width.checked_sub(1 + mut_len));"}, {"sha": "da690f1e8ead67cc036518913cffb311dce910e6", "filename": "src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -142,14 +142,14 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n #[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n     typaram.bounds\n-           .last()\n-           .map_or(typaram.span, |bound| {\n-               match *bound {\n-                   ast::RegionTyParamBound(ref lt) => lt.span,\n-                   ast::TraitTyParamBound(ref prt, _) => prt.span,\n-               }\n-           })\n-           .hi\n+        .last()\n+        .map_or(typaram.span, |bound| {\n+            match *bound {\n+                ast::RegionTyParamBound(ref lt) => lt.span,\n+                ast::TraitTyParamBound(ref prt, _) => prt.span,\n+            }\n+        })\n+        .hi\n }\n \n #[inline]"}, {"sha": "8fba02de2d1d4a05b43ce449704894464c23af73", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -86,9 +86,9 @@ impl<'a> FmtVisitor<'a> {\n         if let Some(ref e) = b.expr {\n             self.format_missing_with_indent(e.span.lo);\n             let rewrite = e.rewrite(&self.get_context(),\n-                                    self.config.max_width - self.block_indent.width(),\n-                                    self.block_indent)\n-                           .unwrap_or_else(|| self.snippet(e.span));\n+                         self.config.max_width - self.block_indent.width(),\n+                         self.block_indent)\n+                .unwrap_or_else(|| self.snippet(e.span));\n \n             self.buffer.push_str(&rewrite);\n             self.last_pos = e.span.hi;\n@@ -436,9 +436,9 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let outers: Vec<_> = attrs.iter()\n-                                  .filter(|a| a.node.style == ast::AttrStyle::Outer)\n-                                  .cloned()\n-                                  .collect();\n+            .filter(|a| a.node.style == ast::AttrStyle::Outer)\n+            .cloned()\n+            .collect();\n         if outers.is_empty() {\n             return false;\n         }\n@@ -447,9 +447,9 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_with_indent(first.span.lo);\n \n         let rewrite = outers.rewrite(&self.get_context(),\n-                                     self.config.max_width - self.block_indent.width(),\n-                                     self.block_indent)\n-                            .unwrap();\n+                     self.config.max_width - self.block_indent.width(),\n+                     self.block_indent)\n+            .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();\n         self.last_pos = last.span.hi;"}, {"sha": "a62ec4f492ecadd00ead8aa06f8eb5b8ca8c1eaf", "filename": "tests/source/chains-visual.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Fsource%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Fsource%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-visual.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -0,0 +1,116 @@\n+// rustfmt-chain_indent: Visual\n+// rustfmt-chain_base_indent: Visual\n+// Test chain formatting.\n+\n+fn main() {\n+    // Don't put chains on a single line if it wasn't so in source.\n+    let a = b .c\n+    .d.1\n+                .foo(|x| x + 1);\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd.eeeeeeee();\n+\n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n+    x()\n+        .y(|| match cond() { true => (), false => () });\n+\n+    loong_func()\n+        .quux(move || if true {\n+            1\n+        } else {\n+            2\n+        });\n+\n+    some_fuuuuuuuuunction()\n+        .method_call_a(aaaaa, bbbbb, |c| {\n+            let x = c;\n+            x\n+        });\n+\n+    some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {\n+        let x = c;\n+        x\n+    }).method_call_b(aaaaa, bbbbb, |c| {\n+        let x = c;\n+        x\n+    });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT\n+                                            .with(|root| {\n+                                                *root.borrow_mut()  =   Some(&script_task);\n+                                            });\n+                                        });                                        \n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx\n+        .map(|x| x + 5)\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                         x += 1;\n+                         x\n+                     }).filter(some_mod::some_filter)\n+}\n+\n+fn floaters() {\n+    let z = Foo {\n+        field1: val1,\n+        field2: val2,\n+    };\n+\n+    let x = Foo {\n+        field1: val1,\n+        field2: val2,\n+    }.method_call().method_call();\n+\n+    let y = if cond {\n+                val1\n+            } else {\n+                val2\n+            }\n+                .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                    Some(d) => d as usize - 1,\n+                    None => return Err(\"bad param number\".to_owned()),\n+                }]\n+                               .clone());\n+            }\n+        }\n+    }\n+\n+    if cond { some(); } else { none(); }\n+        .bar()\n+        .baz();\n+\n+    Foo { x: val } .baz(|| { /*force multiline    */    }) .quux(); \n+\n+    Foo { y: i_am_multi_line, z: ok }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux(); \n+\n+    a + match x { true => \"yay!\", false => \"boo!\" }.bar()\n+}\n+\n+fn is_replaced_content() -> bool {\n+    constellat.send(ConstellationMsg::ViewportConstrained(\n+            self.id, constraints)).unwrap();\n+}\n+\n+fn issue587() {\n+    a.b::<()>(c);\n+\n+    std::mem::transmute(dl.symbol::<()>(\"init\").unwrap())\n+}"}, {"sha": "1af9c0f3462f8c13d00d416f3e4396ef87363fd6", "filename": "tests/system.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -85,7 +85,7 @@ fn assert_output(source: &str, expected_filename: &str) {\n     let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n     let mut expected_text = String::new();\n     expected_file.read_to_string(&mut expected_text)\n-                 .expect(\"Failed reading target\");\n+        .expect(\"Failed reading target\");\n \n     let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n     if compare.len() > 0 {\n@@ -102,8 +102,8 @@ fn assert_output(source: &str, expected_filename: &str) {\n fn idempotence_tests() {\n     // Get all files in the tests/target directory.\n     let files = fs::read_dir(\"tests/target\")\n-                    .expect(\"Couldn't read target dir\")\n-                    .map(get_path_string);\n+        .expect(\"Couldn't read target dir\")\n+        .map(get_path_string);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n@@ -116,9 +116,9 @@ fn idempotence_tests() {\n #[test]\n fn self_tests() {\n     let files = fs::read_dir(\"src/bin\")\n-                    .expect(\"Couldn't read src dir\")\n-                    .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n-                    .map(get_path_string);\n+        .expect(\"Couldn't read src dir\")\n+        .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n+        .map(get_path_string);\n     // Hack because there's no `IntoIterator` impl for `[T; N]`.\n     let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n@@ -264,18 +264,18 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n \n     // Matches lines containing significant comments or whitespace.\n     let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n-                         .expect(\"Failed creating pattern 2\");\n+        .expect(\"Failed creating pattern 2\");\n \n     reader.lines()\n-          .map(|line| line.expect(\"Failed getting line\"))\n-          .take_while(|line| line_regex.is_match(&line))\n-          .filter_map(|line| {\n-              regex.captures_iter(&line).next().map(|capture| {\n-                  (capture.at(1).expect(\"Couldn't unwrap capture\").to_owned(),\n-                   capture.at(2).expect(\"Couldn't unwrap capture\").to_owned())\n-              })\n-          })\n-          .collect()\n+        .map(|line| line.expect(\"Failed getting line\"))\n+        .take_while(|line| line_regex.is_match(&line))\n+        .filter_map(|line| {\n+            regex.captures_iter(&line).next().map(|capture| {\n+                (capture.at(1).expect(\"Couldn't unwrap capture\").to_owned(),\n+                 capture.at(2).expect(\"Couldn't unwrap capture\").to_owned())\n+            })\n+        })\n+        .collect()\n }\n \n // Compare output to input."}, {"sha": "e3ab320c6e19405de0496099141370654db7241d", "filename": "tests/target/chains-indent-visual.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-indent-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-indent-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-indent-visual.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -2,9 +2,9 @@\n \n fn test() {\n     let x = my_long_function()\n-                .my_even_longer_function()\n-                .my_nested_function()\n-                .some_random_name()\n-                .another_function()\n-                .do_it();\n+        .my_even_longer_function()\n+        .my_nested_function()\n+        .some_random_name()\n+        .another_function()\n+        .do_it();\n }"}, {"sha": "2c78fbd91219a12904d2a7052bc2138da1a4b6ba", "filename": "tests/target/chains-no-overflow.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -3,16 +3,16 @@\n \n fn main() {\n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd();\n+        .ddddddddddddddddddddddddddd();\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd\n-                       .eeeeeeee();\n+        .ddddddddddddddddddddddddddd\n+        .eeeeeeee();\n \n     x().y(|| match cond() {\n-           true => (),\n-           false => (),\n-       });\n+            true => (),\n+            false => (),\n+        });\n \n     loong_func()\n         .quux(move || if true {\n@@ -24,19 +24,17 @@ fn main() {\n     fffffffffffffffffffffffffffffffffff(a,\n                                         {\n                                             SCRIPT_TASK_ROOT.with(|root| {\n-                                                                *root.borrow_mut() =\n-                                                                    Some(&script_task);\n-                                                            });\n+                                                    *root.borrow_mut() = Some(&script_task);\n+                                                });\n                                         });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n-                                                                          .map(|x| x / 2)\n-                                                                          .fold(0,\n-                                                                                |acc, x| acc + x);\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n \n     aaaaaaaaaaaaaaaa.map(|x| {\n-                        x += 1;\n-                        x\n-                    })\n-                    .filter(some_mod::some_filter)\n+            x += 1;\n+            x\n+        })\n+        .filter(some_mod::some_filter)\n }"}, {"sha": "c11070913d9e9634b127d9f3c038b04ebc4b0c98", "filename": "tests/target/chains-no-overlow-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-no-overlow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-no-overlow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overlow-2.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -2,15 +2,15 @@\n \n fn main() {\n     reader.lines()\n-          .map(|line| line.expect(\"Failed getting line\"))\n-          .take_while(|line| line_regex.is_match(&line))\n-          .filter_map(|line| {\n-              regex.captures_iter(&line)\n-                   .next()\n-                   .map(|capture| {\n-                       (capture.at(1).expect(\"Couldn\\'t unwrap capture\").to_owned(),\n-                        capture.at(2).expect(\"Couldn\\'t unwrap capture\").to_owned())\n-                   })\n-          })\n-          .collect();\n+        .map(|line| line.expect(\"Failed getting line\"))\n+        .take_while(|line| line_regex.is_match(&line))\n+        .filter_map(|line| {\n+            regex.captures_iter(&line)\n+                .next()\n+                .map(|capture| {\n+                    (capture.at(1).expect(\"Couldn\\'t unwrap capture\").to_owned(),\n+                     capture.at(2).expect(\"Couldn\\'t unwrap capture\").to_owned())\n+                })\n+        })\n+        .collect();\n }"}, {"sha": "d17a98e2ada70ea48cb8b605ee32ad8390e3d39b", "filename": "tests/target/chains-visual.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -0,0 +1,138 @@\n+// rustfmt-chain_indent: Visual\n+// rustfmt-chain_base_indent: Visual\n+// Test chain formatting.\n+\n+fn main() {\n+    // Don't put chains on a single line if it wasn't so in source.\n+    let a = b.c\n+             .d\n+             .1\n+             .foo(|x| x + 1);\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd\n+                       .eeeeeeee();\n+\n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n+    x().y(|| match cond() {\n+        true => (),\n+        false => (),\n+    });\n+\n+    loong_func().quux(move || if true {\n+        1\n+    } else {\n+        2\n+    });\n+\n+    some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {\n+        let x = c;\n+        x\n+    });\n+\n+    some_fuuuuuuuuunction()\n+        .method_call_a(aaaaa, bbbbb, |c| {\n+            let x = c;\n+            x\n+        })\n+        .method_call_b(aaaaa, bbbbb, |c| {\n+            let x = c;\n+            x\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a, {\n+        SCRIPT_TASK_ROOT.with(|root| {\n+            *root.borrow_mut() = Some(&script_task);\n+        });\n+    });\n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n+                                                                          .map(|x| x / 2)\n+                                                                          .fold(0,\n+                                                                                |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                        x += 1;\n+                        x\n+                    })\n+                    .filter(some_mod::some_filter)\n+}\n+\n+fn floaters() {\n+    let z = Foo {\n+        field1: val1,\n+        field2: val2,\n+    };\n+\n+    let x = Foo {\n+                field1: val1,\n+                field2: val2,\n+            }\n+            .method_call()\n+            .method_call();\n+\n+    let y = if cond {\n+                val1\n+            } else {\n+                val2\n+            }\n+            .method_call();\n+\n+    {\n+        match x {\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                               Some(d) => d as usize - 1,\n+                               None => return Err(\"bad param number\".to_owned()),\n+                           }]\n+                           .clone());\n+            }\n+        }\n+    }\n+\n+    if cond {\n+        some();\n+    } else {\n+        none();\n+    }\n+    .bar()\n+    .baz();\n+\n+    Foo { x: val }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux();\n+\n+    Foo {\n+        y: i_am_multi_line,\n+        z: ok,\n+    }\n+    .baz(|| {\n+        // force multiline\n+    })\n+    .quux();\n+\n+    a +\n+    match x {\n+        true => \"yay!\",\n+        false => \"boo!\",\n+    }\n+    .bar()\n+}\n+\n+fn is_replaced_content() -> bool {\n+    constellat.send(ConstellationMsg::ViewportConstrained(self.id, constraints))\n+              .unwrap();\n+}\n+\n+fn issue587() {\n+    a.b::<()>(c);\n+\n+    std::mem::transmute(dl.symbol::<()>(\"init\").unwrap())\n+}"}, {"sha": "aacdb8e93e151f0fcdbce36aaee9009b6afb8038", "filename": "tests/target/chains.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -3,16 +3,16 @@\n fn main() {\n     // Don't put chains on a single line if it wasn't so in source.\n     let a = b.c\n-             .d\n-             .1\n-             .foo(|x| x + 1);\n+        .d\n+        .1\n+        .foo(|x| x + 1);\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd();\n+        .ddddddddddddddddddddddddddd();\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd\n-                       .eeeeeeee();\n+        .ddddddddddddddddddddddddddd\n+        .eeeeeeee();\n \n     // Test case where first chain element isn't a path, but is shorter than\n     // the size of a tab.\n@@ -49,15 +49,14 @@ fn main() {\n     });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n-                                                                          .map(|x| x / 2)\n-                                                                          .fold(0,\n-                                                                                |acc, x| acc + x);\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n \n     aaaaaaaaaaaaaaaa.map(|x| {\n-                        x += 1;\n-                        x\n-                    })\n-                    .filter(some_mod::some_filter)\n+            x += 1;\n+            x\n+        })\n+        .filter(some_mod::some_filter)\n }\n \n fn floaters() {\n@@ -67,39 +66,39 @@ fn floaters() {\n     };\n \n     let x = Foo {\n-                field1: val1,\n-                field2: val2,\n-            }\n-            .method_call()\n-            .method_call();\n+            field1: val1,\n+            field2: val2,\n+        }\n+        .method_call()\n+        .method_call();\n \n     let y = if cond {\n-                val1\n-            } else {\n-                val2\n-            }\n-            .method_call();\n+            val1\n+        } else {\n+            val2\n+        }\n+        .method_call();\n \n     {\n         match x {\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                               Some(d) => d as usize - 1,\n-                               None => return Err(\"bad param number\".to_owned()),\n-                           }]\n-                           .clone());\n+                        Some(d) => d as usize - 1,\n+                        None => return Err(\"bad param number\".to_owned()),\n+                    }]\n+                    .clone());\n             }\n         }\n     }\n \n     if cond {\n-        some();\n-    } else {\n-        none();\n-    }\n-    .bar()\n-    .baz();\n+            some();\n+        } else {\n+            none();\n+        }\n+        .bar()\n+        .baz();\n \n     Foo { x: val }\n         .baz(|| {\n@@ -108,25 +107,25 @@ fn floaters() {\n         .quux();\n \n     Foo {\n-        y: i_am_multi_line,\n-        z: ok,\n-    }\n-    .baz(|| {\n-        // force multiline\n-    })\n-    .quux();\n+            y: i_am_multi_line,\n+            z: ok,\n+        }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux();\n \n     a +\n     match x {\n-        true => \"yay!\",\n-        false => \"boo!\",\n-    }\n-    .bar()\n+            true => \"yay!\",\n+            false => \"boo!\",\n+        }\n+        .bar()\n }\n \n fn is_replaced_content() -> bool {\n     constellat.send(ConstellationMsg::ViewportConstrained(self.id, constraints))\n-              .unwrap();\n+        .unwrap();\n }\n \n fn issue587() {"}, {"sha": "0914959ceb104e8ec33155f39b23d7fb1ebcb3dd", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -51,9 +51,9 @@ fn main() {\n \t}\n \n \tlet chain = funktion_kall()\n-\t\t            .go_to_next_line_with_tab()\n-\t\t            .go_to_next_line_with_tab()\n-\t\t            .go_to_next_line_with_tab();\n+\t\t.go_to_next_line_with_tab()\n+\t\t.go_to_next_line_with_tab()\n+\t\t.go_to_next_line_with_tab();\n \n \tlet z = [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n \t         yyyyyyyyyyyyyyyyyyyyyyyyyyy,\n@@ -88,8 +88,8 @@ fn main() {\n \t\t});\n \t});\n \ta.b\n-\t .c\n-\t .d();\n+\t\t.c\n+\t\t.d();\n \n \tx().y(|| {\n \t\tmatch cond() {"}, {"sha": "e4efd86b7f9e62c2771cf3534a4710af4cdd7ba6", "filename": "tests/target/long_field_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Flong_field_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2b8d98eac98bed714be9524aaf80eedb78a74b/tests%2Ftarget%2Flong_field_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flong_field_access.rs?ref=de2b8d98eac98bed714be9524aaf80eedb78a74b", "patch": "@@ -1,4 +1,4 @@\n fn f() {\n-    block_flow.base.stacking_relative_position_of_display_port =\n-        self.base.stacking_relative_position_of_display_port;\n+    block_flow.base.stacking_relative_position_of_display_port = self.base\n+        .stacking_relative_position_of_display_port;\n }"}]}