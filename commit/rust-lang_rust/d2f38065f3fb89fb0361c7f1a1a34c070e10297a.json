{"sha": "d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "node_id": "C_kwDOAAsO6NoAKGQyZjM4MDY1ZjNmYjg5ZmIwMzYxYzdmMWExYTM0YzA3MGUxMDI5N2E", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-02T10:13:48Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-02T15:20:34Z"}, "message": "render compiletest output with render_tests", "tree": {"sha": "b1f35044a191a234498a988417802208824aaeaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1f35044a191a234498a988417802208824aaeaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQAvsIACgkQzXazX3c0\ndp6OCg//YHce3B97N2LCs9DUdLFa4H4Jl3eOl78xEUBxEEGH2a2c63cObpFQFGLy\nZJQk8XWN+xdx+nycbF3z1mnV5QOlJLH8hkVkdoedgHRH9+A9eELm+wFQERvCLsVh\nvgpck2/jn2JCZDuuYBk2XpJfNWrW+Zy5sD1+zKmWKT/l/XeiHB+fwIeOPtkZJUCn\n+/XrfixQt5jmfsG2gE1AJBzOPzhjpTNgZRHK9R6jfyhCOBw7IxN5vpaw7qBOupFc\n6zz5QtYkORfyLfM4I65/7BZAGRjJ9H0T/sInYKj3jpGy+uRKPs7s7x0M6DiasLOG\n4WxAD2UrlD1HfgI7rpdOwCUtbsJ+HhgJMLGCvG5rkHdx+RIf7k6P7aeJhreiXaoS\nH8xHvLYayv5kru8EzuTVsZ0B3DoZqbwwM6ji6UaIMDKqf7SYeNx0VbxwQuN6FBuS\n7hE9WhJ/ecAZFVKfD0Ptg93RCQuLi8w9aiX5nsLgPAGKXs/f7IOBQzLS2Hmzqa4Q\nl1VrHb/o3t6jMJV2soReM61a7A4s0so0tLuDZB1WbQ+Vca9GMsPfbX4cupM1sCHM\npqabwVchHq8iw7K9nRU0kE1BjzS2XaE9cEtxY9FWnXiOaAFDlcJj/mLCyXk0cUpf\nQ0V1J1wtnIG2viEkBHFDf1ntb61SimFXPCWsolNvDOXaRYaB1Qs=\n=AuPS\n-----END PGP SIGNATURE-----", "payload": "tree b1f35044a191a234498a988417802208824aaeaa\nparent d7049cabd0a370ac5af8b4f03ce836b3f9384d98\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1677752028 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1677770434 +0100\n\nrender compiletest output with render_tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "html_url": "https://github.com/rust-lang/rust/commit/d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7049cabd0a370ac5af8b4f03ce836b3f9384d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7049cabd0a370ac5af8b4f03ce836b3f9384d98", "html_url": "https://github.com/rust-lang/rust/commit/d7049cabd0a370ac5af8b4f03ce836b3f9384d98"}], "stats": {"total": 229, "additions": 224, "deletions": 5}, "files": [{"sha": "f10d640a2090ca676c4218d0d1a27705445c8b36", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "patch": "@@ -55,6 +55,7 @@ mod format;\n mod install;\n mod metadata;\n mod native;\n+mod render_tests;\n mod run;\n mod sanity;\n mod setup;"}, {"sha": "6a0600fb708cca289e38889e0b47bca21f23453c", "filename": "src/bootstrap/render_tests.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "patch": "@@ -0,0 +1,220 @@\n+//! This module renders the JSON output of libtest into a human-readable form, trying to be as\n+//! similar to libtest's native output as possible.\n+//!\n+//! This is needed because we need to use libtest in JSON mode to extract granluar information\n+//! about the executed tests. Doing so suppresses the human-readable output, and (compared to Cargo\n+//! and rustc) libtest doesn't include the rendered human-readable output as a JSON field. We had\n+//! to reimplement all the rendering logic in this module because of that.\n+\n+use crate::builder::Builder;\n+use std::io::{BufRead, BufReader};\n+use std::process::{ChildStdout, Command, Stdio};\n+use std::time::Duration;\n+\n+pub(crate) fn try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if builder.config.dry_run() {\n+        return true;\n+    }\n+\n+    if !run_tests(builder, cmd) {\n+        if builder.fail_fast {\n+            crate::detail_exit(1);\n+        } else {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{cmd:?}\"));\n+            false\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+fn run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    cmd.stdout(Stdio::piped());\n+\n+    builder.verbose(&format!(\"running: {cmd:?}\"));\n+\n+    let mut process = cmd.spawn().unwrap();\n+    let stdout = process.stdout.take().unwrap();\n+    let handle = std::thread::spawn(move || Renderer::new(stdout).render_all());\n+\n+    let result = process.wait().unwrap();\n+    handle.join().expect(\"test formatter thread failed\");\n+\n+    if !result.success() && builder.is_verbose() {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {cmd:?}\\n\\\n+             expected success, got: {result}\"\n+        );\n+    }\n+\n+    result.success()\n+}\n+\n+struct Renderer {\n+    stdout: BufReader<ChildStdout>,\n+    failures: Vec<TestOutcome>,\n+}\n+\n+impl Renderer {\n+    fn new(stdout: ChildStdout) -> Self {\n+        Self { stdout: BufReader::new(stdout), failures: Vec::new() }\n+    }\n+\n+    fn render_all(mut self) {\n+        let mut line = String::new();\n+        loop {\n+            line.clear();\n+            match self.stdout.read_line(&mut line) {\n+                Ok(_) => {}\n+                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof => break,\n+                Err(err) => panic!(\"failed to read output of test runner: {err}\"),\n+            }\n+            if line.is_empty() {\n+                break;\n+            }\n+\n+            self.render_message(match serde_json::from_str(&line) {\n+                Ok(parsed) => parsed,\n+                Err(err) => {\n+                    panic!(\"failed to parse libtest json output; error: {err}, line: {line:?}\");\n+                }\n+            });\n+        }\n+    }\n+\n+    fn render_test_outcome(&self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        // TODO: add support for terse output\n+        self.render_test_outcome_verbose(outcome, test);\n+    }\n+\n+    fn render_test_outcome_verbose(&self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        if let Some(exec_time) = test.exec_time {\n+            println!(\n+                \"test {} ... {outcome} (in {:.2?})\",\n+                test.name,\n+                Duration::from_secs_f64(exec_time)\n+            );\n+        } else {\n+            println!(\"test {} ... {outcome}\", test.name);\n+        }\n+    }\n+\n+    fn render_suite_outcome(&self, outcome: Outcome<'_>, suite: &SuiteOutcome) {\n+        if !self.failures.is_empty() {\n+            println!(\"\\nfailures:\\n\");\n+            for failure in &self.failures {\n+                if let Some(stdout) = &failure.stdout {\n+                    println!(\"---- {} stdout ----\", failure.name);\n+                    println!(\"{stdout}\");\n+                }\n+            }\n+\n+            println!(\"\\nfailures:\");\n+            for failure in &self.failures {\n+                println!(\"    {}\", failure.name);\n+            }\n+        }\n+\n+        println!(\n+            \"\\ntest result: {outcome}. {} passed; {} failed; {} ignored; {} measured; \\\n+             {} filtered out; finished in {:.2?}\\n\",\n+            suite.passed,\n+            suite.failed,\n+            suite.ignored,\n+            suite.measured,\n+            suite.filtered_out,\n+            Duration::from_secs_f64(suite.exec_time)\n+        );\n+    }\n+\n+    fn render_message(&mut self, message: Message) {\n+        match message {\n+            Message::Suite(SuiteMessage::Started { test_count }) => {\n+                println!(\"\\nrunning {test_count} tests\");\n+            }\n+            Message::Suite(SuiteMessage::Ok(outcome)) => {\n+                self.render_suite_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Suite(SuiteMessage::Failed(outcome)) => {\n+                self.render_suite_outcome(Outcome::Failed, &outcome);\n+            }\n+            Message::Test(TestMessage::Ok(outcome)) => {\n+                self.render_test_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Test(TestMessage::Ignored(outcome)) => {\n+                self.render_test_outcome(\n+                    Outcome::Ignored { reason: outcome.reason.as_deref() },\n+                    &outcome,\n+                );\n+            }\n+            Message::Test(TestMessage::Failed(outcome)) => {\n+                self.render_test_outcome(Outcome::Failed, &outcome);\n+                self.failures.push(outcome);\n+            }\n+            Message::Test(TestMessage::Started) => {} // Not useful\n+            Message::Test(TestMessage::Bench) => todo!(\"benchmarks are not supported yet\"),\n+        }\n+    }\n+}\n+\n+enum Outcome<'a> {\n+    Ok,\n+    Failed,\n+    Ignored { reason: Option<&'a str> },\n+}\n+\n+impl std::fmt::Display for Outcome<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Outcome::Ok => f.write_str(\"ok\"),\n+            Outcome::Failed => f.write_str(\"FAILED\"),\n+            Outcome::Ignored { reason: None } => f.write_str(\"ignored\"),\n+            Outcome::Ignored { reason: Some(reason) } => write!(f, \"ignored, {reason}\"),\n+        }\n+    }\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"type\", rename_all = \"snake_case\")]\n+enum Message {\n+    Suite(SuiteMessage),\n+    Test(TestMessage),\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum SuiteMessage {\n+    Ok(SuiteOutcome),\n+    Failed(SuiteOutcome),\n+    Started { test_count: usize },\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct SuiteOutcome {\n+    passed: usize,\n+    failed: usize,\n+    ignored: usize,\n+    measured: usize,\n+    filtered_out: usize,\n+    exec_time: f64,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum TestMessage {\n+    Ok(TestOutcome),\n+    Failed(TestOutcome),\n+    Ignored(TestOutcome),\n+    // Ignored messages:\n+    Bench,\n+    Started,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct TestOutcome {\n+    name: String,\n+    exec_time: Option<f64>,\n+    stdout: Option<String>,\n+    reason: Option<String>,\n+}"}, {"sha": "1576326dfb040a2da3e911e4c5b83a3aed01a51b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f38065f3fb89fb0361c7f1a1a34c070e10297a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d2f38065f3fb89fb0361c7f1a1a34c070e10297a", "patch": "@@ -1616,9 +1616,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--verbose\");\n         }\n \n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n+        cmd.arg(\"--json\");\n \n         let mut llvm_components_passed = false;\n         let mut copts_passed = false;\n@@ -1769,7 +1767,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             suite, mode, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n-        try_run(builder, &mut cmd);\n+        crate::render_tests::try_run_tests(builder, &mut cmd);\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n@@ -1778,7 +1776,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n                 suite, mode, compare_mode, &compiler.host, target\n             ));\n             let _time = util::timeit(&builder);\n-            try_run(builder, &mut cmd);\n+            crate::render_tests::try_run_tests(builder, &mut cmd);\n         }\n     }\n }"}]}