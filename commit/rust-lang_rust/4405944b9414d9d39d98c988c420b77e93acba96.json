{"sha": "4405944b9414d9d39d98c988c420b77e93acba96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MDU5NDRiOTQxNGQ5ZDM5ZDk4Yzk4OGM0MjBiNzdlOTNhY2JhOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T20:59:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T20:59:15Z"}, "message": "Auto merge of #30826 - nagisa:rollup, r=nagisa\n\n- Successful merges: #30538, #30687, #30694, #30737, #30761, #30768, #30774, #30798, #30808, #30812, #30814\n- Failed merges:", "tree": {"sha": "0fee406ab2cbc075fb2fd11c1e819e203a9279ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fee406ab2cbc075fb2fd11c1e819e203a9279ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4405944b9414d9d39d98c988c420b77e93acba96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4405944b9414d9d39d98c988c420b77e93acba96", "html_url": "https://github.com/rust-lang/rust/commit/4405944b9414d9d39d98c988c420b77e93acba96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4405944b9414d9d39d98c988c420b77e93acba96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1586005a1d15e7d26b6c46a33e7a9643de9a77ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/1586005a1d15e7d26b6c46a33e7a9643de9a77ac", "html_url": "https://github.com/rust-lang/rust/commit/1586005a1d15e7d26b6c46a33e7a9643de9a77ac"}, {"sha": "8dd7eabad79f0aad6786374bed892c0d37de89ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd7eabad79f0aad6786374bed892c0d37de89ac", "html_url": "https://github.com/rust-lang/rust/commit/8dd7eabad79f0aad6786374bed892c0d37de89ac"}], "stats": {"total": 1199, "additions": 939, "deletions": 260}, "files": [{"sha": "f72737566a493a7dccfec64ca79eda27cffd41d6", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -303,10 +303,10 @@ prints the string to the screen. Easy enough!\n \n [statically allocated]: the-stack-and-the-heap.html\n \n-The line ends with a semicolon (`;`). Rust is an *[expression oriented]*\n-language, which means that most things are expressions, rather than statements.\n-The `;` indicates that this expression is over, and the next one is ready to\n-begin. Most lines of Rust code end with a `;`.\n+The line ends with a semicolon (`;`). Rust is an *[expression-oriented\n+language]*, which means that most things are expressions, rather than\n+statements. The `;` indicates that this expression is over, and the next one is\n+ready to begin. Most lines of Rust code end with a `;`.\n \n [expression-oriented language]: glossary.html#expression-oriented-language\n "}, {"sha": "f8a1ec134d9242faa877a156868a53dfc5efa110", "filename": "src/doc/index.md", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -10,12 +10,28 @@ This is an index of the documentation included with the Rust\n compiler. For more comprehensive documentation see [the\n website](https://www.rust-lang.org).\n \n-[**The Rust Programming Language**](book/index.html)\n+[**The Rust Programming Language**][book]. Also known as \"The Book\",\n+The Rust Programming Language is the most comprehensive resource for\n+all topics related to Rust, and is the primary official document of\n+the language.\n \n-[**The Rust Reference**](reference.html)\n+[**The Rust Reference**][ref]. While Rust does not have a\n+specification, the reference tries to describe its working in\n+detail. It tends to be out of date.\n \n-[**The Standard Library API Reference**](std/index.html)\n+[**Standard Library API Reference**][api]. Documentation for the\n+standard library.\n \n-[**The Rustonomicon**](nomicon/index.html)\n+[**The Rustonomicon**][nomicon]. An entire book dedicated to\n+explaining how to write unsafe Rust code. It is for advanced Rust\n+programmers.\n+\n+[**Compiler Error Index**][err]. Extended explanations of\n+the errors produced by the Rust compiler.\n+\n+[book]: book/index.html\n+[ref]: reference.html\n+[api]: std/index.html\n+[nomicon]: nomicon/index.html\n+[err]: error-index.html\n \n-[**The Compiler Error Index**](error-index.html)"}, {"sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee", "filename": "src/libbacktrace/ChangeLog.jit", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FChangeLog.jit", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog.jit?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -6,7 +6,7 @@\n \n \t* configure.ac: Add --enable-host-shared.\n \t* configure: Regenerate.\n-\n+\f\n Copyright (C) 2013-2014 Free Software Foundation, Inc.\n \n Copying and distribution of this file, with or without modification,"}, {"sha": "c5f0dcbcf7a19157326dec3e9e408d4cdafd8e60", "filename": "src/libbacktrace/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -6,12 +6,12 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer.\n+#     notice, this list of conditions and the following disclaimer. \n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.\n+#     distribution.  \n \n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without"}, {"sha": "b434d76edb620e81aa048bdea1019c0fd8213a4a", "filename": "src/libbacktrace/Makefile.in", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -23,12 +23,12 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer.\n+#     notice, this list of conditions and the following disclaimer. \n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.\n+#     distribution.  \n \n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without\n@@ -137,10 +137,10 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n \t$(btest_SOURCES) $(stest_SOURCES)\n-MULTISRCTOP =\n-MULTIBUILDTOP =\n-MULTIDIRS =\n-MULTISUBDIR =\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n am__can_run_installinfo = \\\n@@ -389,7 +389,7 @@ config.h: stamp-h1\n stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n \t@rm -f stamp-h1\n \tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n \t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n \trm -f stamp-h1\n \ttouch $@\n@@ -407,7 +407,7 @@ clean-noinstLTLIBRARIES:\n \t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n-libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES)\n+libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES) \n \t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n \n clean-checkPROGRAMS:\n@@ -418,10 +418,10 @@ clean-checkPROGRAMS:\n \tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n \techo \" rm -f\" $$list; \\\n \trm -f $$list\n-btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES)\n+btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES) \n \t@rm -f btest$(EXEEXT)\n \t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n-stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES)\n+stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n \t@rm -f stest$(EXEEXT)\n \t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n "}, {"sha": "143ef68ca5148943104b14eb40cc1f3fa8808f7a", "filename": "src/libbacktrace/alloc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "fdd2490da7c6bdcd50e9e328e5ba495b11557e47", "filename": "src/libbacktrace/atomic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "ab051a1689826ba57d4bdf8688beb1a643a97e98", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "d352d27a4006d98a755a1a16cbeeb53a4c2d3cf2", "filename": "src/libbacktrace/backtrace.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "50dcd40751b22c7268ef001e8a397cf274d79b7a", "filename": "src/libbacktrace/backtrace.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "9821e34c0c1ba69c48b98e71b75e46533c8a030e", "filename": "src/libbacktrace/btest.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission.\n@@ -460,7 +460,7 @@ f23 (int f1line, int f2line)\n \t\t       (unsigned int) bdata.index, j + 1);\n \t      bdata.failed = 1;\n \t    }\n-\t}\n+\t}      \n \n       check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n       check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);"}, {"sha": "a0e487bb42d71fa88cda59a0b16cbf733716cfaa", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -6,13 +6,13 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer.\n+#     notice, this list of conditions and the following disclaimer. \n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.\n-\n+#     distribution.  \n+    \n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without\n #     specific prior written permission."}, {"sha": "54e5ace9b4a68cc557fcc96dce7477ea01af4a62", "filename": "src/libbacktrace/dwarf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission.\n@@ -1246,7 +1246,7 @@ add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n \n static int\n find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n-\t\t     struct dwarf_buf *unit_buf,\n+\t\t     struct dwarf_buf *unit_buf, \n \t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n \t\t     const unsigned char *dwarf_ranges,\n \t\t     size_t dwarf_ranges_size,\n@@ -1605,7 +1605,7 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \n   if (!advance (line_buf, hdrlen))\n     return 0;\n-\n+  \n   hdr->min_insn_len = read_byte (&hdr_buf);\n   if (hdr->version < 4)\n     hdr->max_ops_per_insn = 1;\n@@ -1614,7 +1614,7 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \n   /* We don't care about default_is_stmt.  */\n   read_byte (&hdr_buf);\n-\n+  \n   hdr->line_base = read_sbyte (&hdr_buf);\n   hdr->line_range = read_byte (&hdr_buf);\n "}, {"sha": "71a37b30c9f87b429bab08a4a420caa9a6385503", "filename": "src/libbacktrace/dwarf2.def", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf2.def", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.def?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -47,27 +47,27 @@\n \n /* This file declares various DWARF-related constants using a set of\n    macros which can be redefined by the including file.\n-\n+   \n    The macros are in sections.  Each section corresponds to a single\n    set of DWARF constants and has a corresponding key.  The key is\n    used in all the macro names.\n-\n+   \n    The sections are TAG (for DW_TAG_ constants), FORM (DW_FORM_), AT\n    (DW_AT_), OP (DW_OP_), ATE (DW_ATE_), and CFA (DW_CFA_).\n-\n+   \n    Using TAG as an example, the following macros may be used for each\n    key:\n-\n+   \n    DW_FIRST_TAG(name, value) - Introduce the first DW_TAG constant.\n-\n+   \n    DW_TAG(name, value) - Define a subsequent constant.\n-\n+   \n    DW_TAG_DUP(name, value) - Define a subsequent constant whose value\n    is a duplicate of some other constant.  Not all keys use the _DUP\n    macro form.  If more than one name shares a value, then the base\n    (DW_TAG) form will be the preferred name and DW_TAG_DUP will hold\n    any alternate names.\n-\n+   \n    DW_END_TAG - Invoked at the end of the DW_TAG constants.  */\n \n DW_FIRST_TAG (DW_TAG_padding, 0x00)"}, {"sha": "120e2c16b4820f823c75ab8b2aa7c00bab6291fa", "filename": "src/libbacktrace/dwarf2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf2.h", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.h?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -352,7 +352,7 @@ enum dwarf_macro_record_type\n     DW_MACRO_GNU_lo_user = 0xe0,\n     DW_MACRO_GNU_hi_user = 0xff\n   };\n-\n+\f\n /* @@@ For use with GNU frame unwind information.  */\n \n #define DW_EH_PE_absptr\t\t0x00"}, {"sha": "3f14b11a43c8388f9220122ce8b3e47e1137e0b5", "filename": "src/libbacktrace/elf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "0acad0603eeb071a4b114cf3a7f544536a1be405", "filename": "src/libbacktrace/fileline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "30f99ca127f8e8035b18c4b772adf989aa508fbf", "filename": "src/libbacktrace/internal.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "1ecf131191142879ca808b864eb47810a71c5bbe", "filename": "src/libbacktrace/mmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "b5a787e0aa6fd8bd8a50a37167b1d0ef3c9922bc", "filename": "src/libbacktrace/mmapio.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "f53f906b5a89cb2c617067ed3b43b99acd0cec01", "filename": "src/libbacktrace/nounwind.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "7fa7cd0d5da6760713ca827d90858105a4d4ab12", "filename": "src/libbacktrace/posix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "90ecaf89edad0258b80aed7232cba4fe87352500", "filename": "src/libbacktrace/print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "299f77ba7c629848f8e22b113f15f2c96747c0ea", "filename": "src/libbacktrace/read.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "39c2e902ff77b17adf036f388fd6bc8b25f36aa4", "filename": "src/libbacktrace/simple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "bcc765e93aa777e736ed0b685015398c5fb67dc5", "filename": "src/libbacktrace/sort.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fsort.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fsort.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsort.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "a846378e903c2c7876b9a875cde369c5ffa0332e", "filename": "src/libbacktrace/state.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "ec93e680e89ed8cda9571e03ff92939190d89e5f", "filename": "src/libbacktrace/stest.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fstest.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Fstest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstest.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "e89cba96f7d91565d1ab307c238cc6b23dbed283", "filename": "src/libbacktrace/unknown.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Funknown.c", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Funknown.c?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n+    notice, this list of conditions and the following disclaimer. \n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.\n-\n+    distribution.  \n+    \n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "c3bea050558035c747d743fa084c928ed26376d8", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -321,7 +321,6 @@ fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n ///\n /// [module-level documentation]: index.html\n /// [impl]: index.html#implementing-iterator\n-#[lang = \"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                             `.iter()` or a similar method\"]"}, {"sha": "3aabe4b4931307d10bf6e12b3967a6066ae56d5a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -1822,6 +1822,30 @@ let x: i32 = \"I am not a number!\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n+\n+Another situation in which this occurs is when you attempt to use the `try!`\n+macro inside a function that does not return a `Result<T, E>`:\n+\n+```\n+use std::fs::File;\n+\n+fn main() {\n+    let mut f = try!(File::create(\"foo.txt\"));\n+}\n+```\n+\n+This code gives an error like this:\n+\n+```text\n+<std macros>:5:8: 6:42 error: mismatched types:\n+ expected `()`,\n+     found `core::result::Result<_, _>`\n+ (expected (),\n+     found enum `core::result::Result`) [E0308]\n+```\n+\n+`try!` returns a `Result<T, E>`, and so the function must. But `main()` has\n+`()` as its return type, hence the error.\n \"##,\n \n E0309: r##\""}, {"sha": "a33142433463adb5b0760b50b4a49abc57b10a3e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -19,9 +19,8 @@ use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def::*;\n use middle::def_id::{DefId};\n-use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n-use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n-use middle::expr_use_visitor::WriteAndRead;\n+use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n+use middle::expr_use_visitor::{LoanCause, MutateMode};\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization::{cmt};\n@@ -1161,10 +1160,10 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n     fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n-            JustWrite | WriteAndRead => {\n+            MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n             }\n-            Init => {}\n+            MutateMode::Init => {}\n         }\n     }\n }"}, {"sha": "e746f3ac57914a712f61b39e935902a1219e72fe", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -12,7 +12,6 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n-pub use self::MutateMode::*;\n pub use self::LoanCause::*;\n pub use self::ConsumeMode::*;\n pub use self::MoveReason::*;\n@@ -465,7 +464,11 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         self.consume_expr(&*output.expr);\n                     } else {\n                         self.mutate_expr(expr, &*output.expr,\n-                                         if output.is_rw { WriteAndRead } else { JustWrite });\n+                                         if output.is_rw {\n+                                             MutateMode::WriteAndRead\n+                                         } else {\n+                                             MutateMode::JustWrite\n+                                         });\n                     }\n                 }\n             }\n@@ -519,7 +522,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.mutate_expr(expr, &**lhs, JustWrite);\n+                self.mutate_expr(expr, &**lhs, MutateMode::JustWrite);\n                 self.consume_expr(&**rhs);\n             }\n \n@@ -532,7 +535,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 assert!(::rustc_front::util::is_by_value_binop(op.node));\n \n                 if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n-                    self.mutate_expr(expr, &**lhs, WriteAndRead);\n+                    self.mutate_expr(expr, &**lhs, MutateMode::WriteAndRead);\n                     self.consume_expr(&**rhs);\n                 }\n             }\n@@ -991,7 +994,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n                     Err(_) => { }\n                 }"}, {"sha": "1b0dfc73229613a56babad1cd099123edd233fe2", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -314,10 +314,19 @@ impl<'tcx> CallKind<'tcx> {\n         }\n     }\n \n-    pub fn destination(&self) -> Option<Lvalue<'tcx>> {\n+    pub fn destination(&self) -> Option<&Lvalue<'tcx>> {\n         match *self {\n             CallKind::Converging { ref destination, .. } |\n-            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination.clone()),\n+            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination),\n+            CallKind::Diverging |\n+            CallKind::DivergingCleanup(_) => None\n+        }\n+    }\n+\n+    pub fn destination_mut(&mut self) -> Option<&mut Lvalue<'tcx>> {\n+        match *self {\n+            CallKind::Converging { ref mut destination, .. } |\n+            CallKind::ConvergingCleanup { ref mut destination, .. } => Some(destination),\n             CallKind::Diverging |\n             CallKind::DivergingCleanup(_) => None\n         }"}, {"sha": "2d30b827750acda7b2bbba833b7689d829066dff", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -21,6 +21,7 @@ use self::UseError::*;\n use borrowck::*;\n use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -161,7 +162,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n                 match mode {\n-                    euv::Init | euv::JustWrite => {\n+                    MutateMode::Init | MutateMode::JustWrite => {\n                         // In a case like `path = 1`, then path does not\n                         // have to be *FULLY* initialized, but we still\n                         // must be careful lest it contains derefs of\n@@ -171,7 +172,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                                                              MovedInUse,\n                                                              &lp);\n                     }\n-                    euv::WriteAndRead => {\n+                    MutateMode::WriteAndRead => {\n                         // In a case like `path += 1`, then path must be\n                         // fully initialized, since we will read it before\n                         // we write it."}, {"sha": "735e618cc732b1f0da607b438e7e58c57de0369c", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n+use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::ty;\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n@@ -406,10 +407,10 @@ impl<'tcx> MoveData<'tcx> {\n         self.fragments.borrow_mut().add_assignment(path_index);\n \n         match mode {\n-            euv::Init | euv::JustWrite => {\n+            MutateMode::Init | MutateMode::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n             }\n-            euv::WriteAndRead => { }\n+            MutateMode::WriteAndRead => { }\n         }\n \n         let assignment = Assignment {"}, {"sha": "825dee9f659f5cad64306b9f2221e00de18e7ff4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -38,6 +38,7 @@\n #![feature(staged_api)]\n #![feature(str_char)]\n \n+#[macro_use]\n extern crate syntax;\n #[macro_use]\n extern crate rustc;\n@@ -154,4 +155,5 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_renamed(\"unknown_features\", \"unused_features\");\n \n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n+    store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");\n }"}, {"sha": "891c1aebcdf30704afa57221a73bfaf68c4fb7cb", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(non_snake_case)]\n+\n use middle::{infer};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n@@ -24,13 +26,39 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n \n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::util::is_shift_binop;\n \n+register_long_diagnostics! {\n+E0519: r##\"\n+It is not allowed to negate an unsigned integer.\n+You can negate a signed integer and cast it to an\n+unsigned integer or use the `!` operator.\n+\n+```\n+let x: usize = -1isize as usize;\n+let y: usize = !0;\n+assert_eq!(x, y);\n+```\n+\n+Alternatively you can use the `Wrapping` newtype\n+or the `wrapping_neg` operation that all\n+integral types support:\n+\n+```\n+use std::num::Wrapping;\n+let x: Wrapping<usize> = -Wrapping(1);\n+let Wrapping(x) = x;\n+let y: usize = 1.wrapping_neg();\n+assert_eq!(x, y);\n+```\n+\n+\"##\n+}\n+\n declare_lint! {\n     UNUSED_COMPARISONS,\n     Warn,\n@@ -73,30 +101,24 @@ impl LateLintPass for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n-                match expr.node  {\n-                    hir::ExprLit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n-                                check_unsigned_negation_feature(cx, e.span);\n-                            },\n-                            ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-                                if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n-                                    check_unsigned_negation_feature(cx, e.span);\n-                                }\n-                            },\n-                            _ => ()\n-                        }\n-                    },\n-                    _ => {\n-                        let t = cx.tcx.node_id_to_type(expr.id);\n-                        match t.sty {\n-                            ty::TyUint(_) => {\n-                                check_unsigned_negation_feature(cx, e.span);\n-                            },\n-                            _ => ()\n-                        }\n+                if let hir::ExprLit(ref lit) = expr.node {\n+                    match lit.node {\n+                        ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n+                            forbid_unsigned_negation(cx, e.span);\n+                        },\n+                        ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n+                            if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n+                                forbid_unsigned_negation(cx, e.span);\n+                            }\n+                        },\n+                        _ => ()\n                     }\n-                };\n+                } else {\n+                    let t = cx.tcx.node_id_to_type(expr.id);\n+                    if let ty::TyUint(_) = t.sty {\n+                        forbid_unsigned_negation(cx, e.span);\n+                    }\n+                }\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n@@ -322,15 +344,11 @@ impl LateLintPass for TypeLimits {\n             }\n         }\n \n-        fn check_unsigned_negation_feature(cx: &LateContext, span: Span) {\n-            if !cx.sess().features.borrow().negate_unsigned {\n-                emit_feature_err(\n-                    &cx.sess().parse_sess.span_diagnostic,\n-                    \"negate_unsigned\",\n-                    span,\n-                    GateIssue::Language,\n-                    \"unary negation of unsigned integers may be removed in the future\");\n-            }\n+        fn forbid_unsigned_negation(cx: &LateContext, span: Span) {\n+            cx.sess()\n+              .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n+              .span_help(span, \"use a cast or the `!` operator\")\n+              .emit();\n         }\n     }\n }"}, {"sha": "90d6a90682f6eb1680cd467d1730a56fa6e0ed47", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -34,7 +34,7 @@ you but duty compels me to mention. In the course of translating\n matches, it sometimes happen that certain code (namely guards) gets\n executed multiple times. This means that the scope lexical scope may\n in fact correspond to multiple, disjoint SEME regions. So in fact our\n-mapping os from one scope to a vector of SEME regions.\n+mapping is from one scope to a vector of SEME regions.\n \n ### Drops\n "}, {"sha": "9679654d958e9a24e202443a272f5a52e762a9f8", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n             Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n-                if let Some(ref mut destination) = kind.destination() {\n+                if let Some(destination) = kind.destination_mut() {\n                     self.erase_regions_lvalue(destination);\n                 }\n                 self.erase_regions_operand(func);"}, {"sha": "18a9aad0e915d1a885ea49c439ae64183f4b4e94", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -100,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let mut llargs = Vec::with_capacity(args.len() + 1);\n \n                 // Prepare the return value destination\n-                let (ret_dest_ty, must_copy_dest) = if let Some(ref d) = kind.destination() {\n+                let (ret_dest_ty, must_copy_dest) = if let Some(d) = kind.destination() {\n                     let dest = self.trans_lvalue(bcx, d);\n                     let ret_ty = dest.ty.to_ty(bcx.tcx());\n                     if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {"}, {"sha": "84cc87e9b13850000069d9a0dd769a0579188a1e", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -15,13 +15,14 @@ use middle::ty::{Ty, TypeFoldable};\n use rustc::middle::const_eval::ConstVal;\n use rustc::mir::repr as mir;\n use trans::common::{self, Block, C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n-use trans::consts::{self, TrueConst};\n-use trans::{type_of, expr};\n-\n+use trans::consts;\n+use trans::expr;\n+use trans::type_of;\n \n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n+\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constval(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n@@ -66,13 +67,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Uint(v) => C_integral(llty, v, false),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n-            ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n-                let expr = bcx.tcx().map.expect_expr(id);\n-                match consts::const_expr(ccx, expr, param_substs, None, TrueConst::Yes) {\n-                    Ok((val, _)) => val,\n-                    Err(e) => panic!(\"const eval failure: {}\", e.description()),\n-                }\n-            },\n+            ConstVal::Struct(id) | ConstVal::Tuple(id) |\n             ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n                 let expr = bcx.tcx().map.expect_expr(id);\n                 expr::trans(bcx, expr).datum.val"}, {"sha": "9f069cb17ed9033b6174d720e148d563331de281", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 507, "deletions": 20, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -25,8 +25,9 @@ use ptr::P;\n use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n+use std::collections::{HashMap};\n+use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n-use std::iter::once;\n \n struct ParserAnyMacro<'a> {\n     parser: RefCell<Parser<'a>>,\n@@ -320,15 +321,18 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }\n \n+// why is this here? because of https://github.com/rust-lang/rust/issues/27774\n+fn ref_slice<A>(s: &A) -> &[A] { use std::slice::from_raw_parts; unsafe { from_raw_parts(s, 1) } }\n+\n fn check_lhs_nt_follows(cx: &mut ExtCtxt, lhs: &TokenTree, sp: Span) {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     match lhs {\n         &TokenTree::Delimited(_, ref tts) => {\n-            check_matcher(cx, tts.tts.iter(), &Eof);\n+            check_matcher(cx, &tts.tts);\n         },\n         tt @ &TokenTree::Sequence(..) => {\n-            check_matcher(cx, Some(tt).into_iter(), &Eof);\n+            check_matcher(cx, ref_slice(tt));\n         },\n         _ => cx.span_err(sp, \"invalid macro matcher; matchers must be contained \\\n                               in balanced delimiters or a repetition indicator\")\n@@ -345,10 +349,59 @@ fn check_rhs(cx: &mut ExtCtxt, rhs: &TokenTree) -> bool {\n     false\n }\n \n-// returns the last token that was checked, for TokenTree::Sequence. this gets used later on.\n-fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n+// Issue 30450: when we are through a warning cycle, we can just error\n+// on all failure conditions and remove this struct and enum.\n+\n+#[derive(Debug)]\n+struct OnFail {\n+    saw_failure: bool,\n+    action: OnFailAction,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum OnFailAction { Warn, Error, DoNothing }\n+\n+impl OnFail {\n+    fn warn() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::Warn } }\n+    fn error() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::Error } }\n+    fn do_nothing() -> OnFail { OnFail { saw_failure: false, action: OnFailAction::DoNothing } }\n+    fn react(&mut self, cx: &mut ExtCtxt, sp: Span, msg: &str) {\n+        match self.action {\n+            OnFailAction::DoNothing => {}\n+            OnFailAction::Error => cx.span_err(sp, msg),\n+            OnFailAction::Warn => {\n+                cx.struct_span_warn(sp, msg)\n+                    .span_note(sp, \"The above warning will be a hard error in the next release.\")\n+                    .emit();\n+            }\n+        };\n+        self.saw_failure = true;\n+    }\n+}\n+\n+fn check_matcher(cx: &mut ExtCtxt, matcher: &[TokenTree]) {\n+    // Issue 30450: when we are through a warning cycle, we can just\n+    // error on all failure conditions (and remove check_matcher_old).\n+\n+    // First run the old-pass, but *only* to find out if it would have failed.\n+    let mut on_fail = OnFail::do_nothing();\n+    check_matcher_old(cx, matcher.iter(), &Eof, &mut on_fail);\n+    // Then run the new pass, but merely warn if the old pass accepts and new pass rejects.\n+    // (Note this silently accepts code if new pass accepts.)\n+    let mut on_fail = if on_fail.saw_failure {\n+        OnFail::error()\n+    } else {\n+        OnFail::warn()\n+    };\n+    check_matcher_new(cx, matcher, &mut on_fail);\n+}\n+\n+// returns the last token that was checked, for TokenTree::Sequence.\n+// return value is used by recursive calls.\n+fn check_matcher_old<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token, on_fail: &mut OnFail)\n -> Option<(Span, Token)> where I: Iterator<Item=&'a TokenTree> {\n     use print::pprust::token_to_string;\n+    use std::iter::once;\n \n     let mut last = None;\n \n@@ -375,7 +428,7 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                             // look at the token that follows the\n                             // sequence, which may itself be a sequence,\n                             // and so on).\n-                            cx.span_err(sp,\n+                            on_fail.react(cx, sp,\n                                         &format!(\"`${0}:{1}` is followed by a \\\n                                                   sequence repetition, which is not \\\n                                                   allowed for `{1}` fragments\",\n@@ -398,13 +451,13 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                     // If T' is in the set FOLLOW(NT), continue. Else, reject.\n                     match (&next_token, is_in_follow(cx, &next_token, &frag_spec.name.as_str())) {\n                         (_, Err(msg)) => {\n-                            cx.span_err(sp, &msg);\n+                            on_fail.react(cx, sp, &msg);\n                             continue\n                         }\n                         (&Eof, _) => return Some((sp, tok.clone())),\n                         (_, Ok(true)) => continue,\n                         (next, Ok(false)) => {\n-                            cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n+                            on_fail.react(cx, sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n                                                       is not allowed for `{1}` fragments\",\n                                                      name, frag_spec,\n                                                      token_to_string(next)));\n@@ -420,7 +473,7 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                     // run the algorithm on the contents with F set to U. If it\n                     // accepts, continue, else, reject.\n                     Some(ref u) => {\n-                        let last = check_matcher(cx, seq.tts.iter(), u);\n+                        let last = check_matcher_old(cx, seq.tts.iter(), u, on_fail);\n                         match last {\n                             // Since the delimiter isn't required after the last\n                             // repetition, make sure that the *next* token is\n@@ -434,14 +487,14 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                                     Some(&&TokenTree::Delimited(_, ref delim)) =>\n                                         delim.close_token(),\n                                     Some(_) => {\n-                                        cx.span_err(sp, \"sequence repetition followed by \\\n+                                        on_fail.react(cx, sp, \"sequence repetition followed by \\\n                                                 another sequence repetition, which is not allowed\");\n                                         Eof\n                                     },\n                                     None => Eof\n                                 };\n-                                check_matcher(cx, once(&TokenTree::Token(span, tok.clone())),\n-                                              &fol)\n+                                check_matcher_old(cx, once(&TokenTree::Token(span, tok.clone())),\n+                                                  &fol, on_fail)\n                             },\n                             None => last,\n                         }\n@@ -454,13 +507,13 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n                             Some(&&TokenTree::Token(_, ref tok)) => tok.clone(),\n                             Some(&&TokenTree::Delimited(_, ref delim)) => delim.close_token(),\n                             Some(_) => {\n-                                cx.span_err(sp, \"sequence repetition followed by another \\\n+                                on_fail.react(cx, sp, \"sequence repetition followed by another \\\n                                              sequence repetition, which is not allowed\");\n                                 Eof\n                             },\n                             None => Eof\n                         };\n-                        check_matcher(cx, seq.tts.iter(), &fol)\n+                        check_matcher_old(cx, seq.tts.iter(), &fol, on_fail)\n                     }\n                 }\n             },\n@@ -471,13 +524,425 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n             TokenTree::Delimited(_, ref tts) => {\n                 // if we don't pass in that close delimiter, we'll incorrectly consider the matcher\n                 // `{ $foo:ty }` as having a follow that isn't `RBrace`\n-                check_matcher(cx, tts.tts.iter(), &tts.close_token())\n+                check_matcher_old(cx, tts.tts.iter(), &tts.close_token(), on_fail)\n             }\n         }\n     }\n     last\n }\n \n+fn check_matcher_new(cx: &mut ExtCtxt, matcher: &[TokenTree], on_fail: &mut OnFail) {\n+    let first_sets = FirstSets::new(matcher);\n+    let empty_suffix = TokenSet::empty();\n+    check_matcher_core(cx, &first_sets, matcher, &empty_suffix, on_fail);\n+}\n+\n+// The FirstSets for a matcher is a mapping from subsequences in the\n+// matcher to the FIRST set for that subsequence.\n+//\n+// This mapping is partially precomputed via a backwards scan over the\n+// token trees of the matcher, which provides a mapping from each\n+// repetition sequence to its FIRST set.\n+//\n+// (Hypothetically sequences should be uniquely identifiable via their\n+// spans, though perhaps that is false e.g. for macro-generated macros\n+// that do not try to inject artificial span information. My plan is\n+// to try to catch such cases ahead of time and not include them in\n+// the precomputed mapping.)\n+struct FirstSets {\n+    // this maps each TokenTree::Sequence `$(tt ...) SEP OP` that is uniquely identified by its\n+    // span in the original matcher to the First set for the inner sequence `tt ...`.\n+    //\n+    // If two sequences have the same span in a matcher, then map that\n+    // span to None (invalidating the mapping here and forcing the code to\n+    // use a slow path).\n+    first: HashMap<Span, Option<TokenSet>>,\n+}\n+\n+impl FirstSets {\n+    fn new(tts: &[TokenTree]) -> FirstSets {\n+        let mut sets = FirstSets { first: HashMap::new() };\n+        build_recur(&mut sets, tts);\n+        return sets;\n+\n+        // walks backward over `tts`, returning the FIRST for `tts`\n+        // and updating `sets` at the same time for all sequence\n+        // substructure we find within `tts`.\n+        fn build_recur(sets: &mut FirstSets, tts: &[TokenTree]) -> TokenSet {\n+            let mut first = TokenSet::empty();\n+            for tt in tts.iter().rev() {\n+                match *tt {\n+                    TokenTree::Token(sp, ref tok) => {\n+                        first.replace_with((sp, tok.clone()));\n+                    }\n+                    TokenTree::Delimited(_, ref delimited) => {\n+                        build_recur(sets, &delimited.tts[..]);\n+                        first.replace_with((delimited.open_span,\n+                                            Token::OpenDelim(delimited.delim)));\n+                    }\n+                    TokenTree::Sequence(sp, ref seq_rep) => {\n+                        let subfirst = build_recur(sets, &seq_rep.tts[..]);\n+\n+                        match sets.first.entry(sp) {\n+                            Entry::Vacant(vac) => {\n+                                vac.insert(Some(subfirst.clone()));\n+                            }\n+                            Entry::Occupied(mut occ) => {\n+                                // if there is already an entry, then a span must have collided.\n+                                // This should not happen with typical macro_rules macros,\n+                                // but syntax extensions need not maintain distinct spans,\n+                                // so distinct syntax trees can be assigned the same span.\n+                                // In such a case, the map cannot be trusted; so mark this\n+                                // entry as unusable.\n+                                occ.insert(None);\n+                            }\n+                        }\n+\n+                        // If the sequence contents can be empty, then the first\n+                        // token could be the separator token itself.\n+\n+                        if let (Some(ref sep), true) = (seq_rep.separator.clone(),\n+                                                        subfirst.maybe_empty) {\n+                            first.add_one_maybe((sp, sep.clone()));\n+                        }\n+\n+                        // Reverse scan: Sequence comes before `first`.\n+                        if subfirst.maybe_empty || seq_rep.op == ast::KleeneOp::ZeroOrMore {\n+                            // If sequence is potentially empty, then\n+                            // union them (preserving first emptiness).\n+                            first.add_all(&TokenSet { maybe_empty: true, ..subfirst });\n+                        } else {\n+                            // Otherwise, sequence guaranteed\n+                            // non-empty; replace first.\n+                            first = subfirst;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return first;\n+        }\n+    }\n+\n+    // walks forward over `tts` until all potential FIRST tokens are\n+    // identified.\n+    fn first(&self, tts: &[TokenTree]) -> TokenSet {\n+        let mut first = TokenSet::empty();\n+        for tt in tts.iter() {\n+            assert!(first.maybe_empty);\n+            match *tt {\n+                TokenTree::Token(sp, ref tok) => {\n+                    first.add_one((sp, tok.clone()));\n+                    return first;\n+                }\n+                TokenTree::Delimited(_, ref delimited) => {\n+                    first.add_one((delimited.open_span,\n+                                   Token::OpenDelim(delimited.delim)));\n+                    return first;\n+                }\n+                TokenTree::Sequence(sp, ref seq_rep) => {\n+                    match self.first.get(&sp) {\n+                        Some(&Some(ref subfirst)) => {\n+\n+                            // If the sequence contents can be empty, then the first\n+                            // token could be the separator token itself.\n+\n+                            if let (Some(ref sep), true) = (seq_rep.separator.clone(),\n+                                                            subfirst.maybe_empty) {\n+                                first.add_one_maybe((sp, sep.clone()));\n+                            }\n+\n+                            assert!(first.maybe_empty);\n+                            first.add_all(subfirst);\n+                            if subfirst.maybe_empty || seq_rep.op == ast::KleeneOp::ZeroOrMore {\n+                                // continue scanning for more first\n+                                // tokens, but also make sure we\n+                                // restore empty-tracking state\n+                                first.maybe_empty = true;\n+                                continue;\n+                            } else {\n+                                return first;\n+                            }\n+                        }\n+\n+                        Some(&None) => {\n+                            panic!(\"assume all sequences have (unique) spans for now\");\n+                        }\n+\n+                        None => {\n+                            panic!(\"We missed a sequence during FirstSets construction\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // we only exit the loop if `tts` was empty or if every\n+        // element of `tts` matches the empty sequence.\n+        assert!(first.maybe_empty);\n+        return first;\n+    }\n+}\n+\n+// A set of Tokens, which may include MatchNt tokens (for\n+// macro-by-example syntactic variables). It also carries the\n+// `maybe_empty` flag; that is true if and only if the matcher can\n+// match an empty token sequence.\n+//\n+// The First set is computed on submatchers like `$($a:expr b),* $(c)* d`,\n+// which has corresponding FIRST = {$a:expr, c, d}.\n+// Likewise, `$($a:expr b),* $(c)+ d` has FIRST = {$a:expr, c}.\n+//\n+// (Notably, we must allow for *-op to occur zero times.)\n+#[derive(Clone, Debug)]\n+struct TokenSet {\n+    tokens: Vec<(Span, Token)>,\n+    maybe_empty: bool,\n+}\n+\n+impl TokenSet {\n+    // Returns a set for the empty sequence.\n+    fn empty() -> Self { TokenSet { tokens: Vec::new(), maybe_empty: true } }\n+\n+    // Returns the set `{ tok }` for the single-token (and thus\n+    // non-empty) sequence [tok].\n+    fn singleton(tok: (Span, Token)) -> Self {\n+        TokenSet { tokens: vec![tok], maybe_empty: false }\n+    }\n+\n+    // Changes self to be the set `{ tok }`.\n+    // Since `tok` is always present, marks self as non-empty.\n+    fn replace_with(&mut self, tok: (Span, Token)) {\n+        self.tokens.clear();\n+        self.tokens.push(tok);\n+        self.maybe_empty = false;\n+    }\n+\n+    // Changes self to be the empty set `{}`; meant for use when\n+    // the particular token does not matter, but we want to\n+    // record that it occurs.\n+    fn replace_with_irrelevant(&mut self) {\n+        self.tokens.clear();\n+        self.maybe_empty = false;\n+    }\n+\n+    // Adds `tok` to the set for `self`, marking sequence as non-empy.\n+    fn add_one(&mut self, tok: (Span, Token)) {\n+        if !self.tokens.contains(&tok) {\n+            self.tokens.push(tok);\n+        }\n+        self.maybe_empty = false;\n+    }\n+\n+    // Adds `tok` to the set for `self`. (Leaves `maybe_empty` flag alone.)\n+    fn add_one_maybe(&mut self, tok: (Span, Token)) {\n+        if !self.tokens.contains(&tok) {\n+            self.tokens.push(tok);\n+        }\n+    }\n+\n+    // Adds all elements of `other` to this.\n+    //\n+    // (Since this is a set, we filter out duplicates.)\n+    //\n+    // If `other` is potentially empty, then preserves the previous\n+    // setting of the empty flag of `self`. If `other` is guaranteed\n+    // non-empty, then `self` is marked non-empty.\n+    fn add_all(&mut self, other: &Self) {\n+        for tok in &other.tokens {\n+            if !self.tokens.contains(tok) {\n+                self.tokens.push(tok.clone());\n+            }\n+        }\n+        if !other.maybe_empty {\n+            self.maybe_empty = false;\n+        }\n+    }\n+}\n+\n+// Checks that `matcher` is internally consistent and that it\n+// can legally by followed by a token N, for all N in `follow`.\n+// (If `follow` is empty, then it imposes no constraint on\n+// the `matcher`.)\n+//\n+// Returns the set of NT tokens that could possibly come last in\n+// `matcher`. (If `matcher` matches the empty sequence, then\n+// `maybe_empty` will be set to true.)\n+//\n+// Requires that `first_sets` is pre-computed for `matcher`;\n+// see `FirstSets::new`.\n+fn check_matcher_core(cx: &mut ExtCtxt,\n+                      first_sets: &FirstSets,\n+                      matcher: &[TokenTree],\n+                      follow: &TokenSet,\n+                      on_fail: &mut OnFail) -> TokenSet {\n+    use print::pprust::token_to_string;\n+\n+    let mut last = TokenSet::empty();\n+\n+    // 2. For each token and suffix  [T, SUFFIX] in M:\n+    // ensure that T can be followed by SUFFIX, and if SUFFIX may be empty,\n+    // then ensure T can also be followed by any element of FOLLOW.\n+    'each_token: for i in 0..matcher.len() {\n+        let token = &matcher[i];\n+        let suffix = &matcher[i+1..];\n+\n+        let build_suffix_first = || {\n+            let mut s = first_sets.first(suffix);\n+            if s.maybe_empty { s.add_all(follow); }\n+            return s;\n+        };\n+\n+        // (we build `suffix_first` on demand below; you can tell\n+        // which cases are supposed to fall through by looking for the\n+        // initialization of this variable.)\n+        let suffix_first;\n+\n+        // First, update `last` so that it corresponds to the set\n+        // of NT tokens that might end the sequence `... token`.\n+        match *token {\n+            TokenTree::Token(sp, ref tok) => {\n+                let can_be_followed_by_any;\n+                if let Err(bad_frag) = has_legal_fragment_specifier(tok) {\n+                    on_fail.react(cx, sp, &format!(\"invalid fragment specifier `{}`\", bad_frag));\n+                    // (This eliminates false positives and duplicates\n+                    // from error messages.)\n+                    can_be_followed_by_any = true;\n+                } else {\n+                    can_be_followed_by_any = token_can_be_followed_by_any(tok);\n+                }\n+\n+                if can_be_followed_by_any {\n+                    // don't need to track tokens that work with any,\n+                    last.replace_with_irrelevant();\n+                    // ... and don't need to check tokens that can be\n+                    // followed by anything against SUFFIX.\n+                    continue 'each_token;\n+                } else {\n+                    last.replace_with((sp, tok.clone()));\n+                    suffix_first = build_suffix_first();\n+                }\n+            }\n+            TokenTree::Delimited(_, ref d) => {\n+                let my_suffix = TokenSet::singleton((d.close_span, Token::CloseDelim(d.delim)));\n+                check_matcher_core(cx, first_sets, &d.tts, &my_suffix, on_fail);\n+                // don't track non NT tokens\n+                last.replace_with_irrelevant();\n+\n+                // also, we don't need to check delimited sequences\n+                // against SUFFIX\n+                continue 'each_token;\n+            }\n+            TokenTree::Sequence(sp, ref seq_rep) => {\n+                suffix_first = build_suffix_first();\n+                // The trick here: when we check the interior, we want\n+                // to include the separator (if any) as a potential\n+                // (but not guaranteed) element of FOLLOW. So in that\n+                // case, we make a temp copy of suffix and stuff\n+                // delimiter in there.\n+                //\n+                // FIXME: Should I first scan suffix_first to see if\n+                // delimiter is already in it before I go through the\n+                // work of cloning it? But then again, this way I may\n+                // get a \"tighter\" span?\n+                let mut new;\n+                let my_suffix = if let Some(ref u) = seq_rep.separator {\n+                    new = suffix_first.clone();\n+                    new.add_one_maybe((sp, u.clone()));\n+                    &new\n+                } else {\n+                    &suffix_first\n+                };\n+\n+                // At this point, `suffix_first` is built, and\n+                // `my_suffix` is some TokenSet that we can use\n+                // for checking the interior of `seq_rep`.\n+                let next = check_matcher_core(cx, first_sets, &seq_rep.tts, my_suffix, on_fail);\n+                if next.maybe_empty {\n+                    last.add_all(&next);\n+                } else {\n+                    last = next;\n+                }\n+\n+                // the recursive call to check_matcher_core already ran the 'each_last\n+                // check below, so we can just keep going forward here.\n+                continue 'each_token;\n+            }\n+        }\n+\n+        // (`suffix_first` guaranteed initialized once reaching here.)\n+\n+        // Now `last` holds the complete set of NT tokens that could\n+        // end the sequence before SUFFIX. Check that every one works with `suffix`.\n+        'each_last: for &(_sp, ref t) in &last.tokens {\n+            if let MatchNt(ref name, ref frag_spec, _, _) = *t {\n+                for &(sp, ref next_token) in &suffix_first.tokens {\n+                    match is_in_follow(cx, next_token, &frag_spec.name.as_str()) {\n+                        Err(msg) => {\n+                            on_fail.react(cx, sp, &msg);\n+                            // don't bother reporting every source of\n+                            // conflict for a particular element of `last`.\n+                            continue 'each_last;\n+                        }\n+                        Ok(true) => {}\n+                        Ok(false) => {\n+                            let may_be = if last.tokens.len() == 1 &&\n+                                suffix_first.tokens.len() == 1\n+                            {\n+                                \"is\"\n+                            } else {\n+                                \"may be\"\n+                            };\n+\n+                            on_fail.react(\n+                                cx, sp,\n+                                &format!(\"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n+                                          is not allowed for `{frag}` fragments\",\n+                                         name=name,\n+                                         frag=frag_spec,\n+                                         next=token_to_string(next_token),\n+                                         may_be=may_be));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    last\n+}\n+\n+\n+fn token_can_be_followed_by_any(tok: &Token) -> bool {\n+    if let &MatchNt(_, ref frag_spec, _, _) = tok {\n+        frag_can_be_followed_by_any(&frag_spec.name.as_str())\n+    } else {\n+        // (Non NT's can always be followed by anthing in matchers.)\n+        true\n+    }\n+}\n+\n+/// True if a fragment of type `frag` can be followed by any sort of\n+/// token.  We use this (among other things) as a useful approximation\n+/// for when `frag` can be followed by a repetition like `$(...)*` or\n+/// `$(...)+`. In general, these can be a bit tricky to reason about,\n+/// so we adopt a conservative position that says that any fragment\n+/// specifier which consumes at most one token tree can be followed by\n+/// a fragment specifier (indeed, these fragments can be followed by\n+/// ANYTHING without fear of future compatibility hazards).\n+fn frag_can_be_followed_by_any(frag: &str) -> bool {\n+    match frag {\n+        \"item\" |  // always terminated by `}` or `;`\n+        \"block\" | // exactly one token tree\n+        \"ident\" | // exactly one token tree\n+        \"meta\" |  // exactly one token tree\n+        \"tt\" =>    // exactly one token tree\n+            true,\n+\n+        _ =>\n+            false,\n+    }\n+}\n+\n /// True if a fragment of type `frag` can be followed by any sort of\n /// token.  We use this (among other things) as a useful approximation\n /// for when `frag` can be followed by a repetition like `$(...)*` or\n@@ -501,7 +966,7 @@ fn can_be_followed_by_any(frag: &str) -> bool {\n }\n \n /// True if `frag` can legally be followed by the token `tok`. For\n-/// fragments that can consume an unbounded numbe of tokens, `tok`\n+/// fragments that can consume an unbounded number of tokens, `tok`\n /// must be within a well-defined follow set. This is intended to\n /// guarantee future compatibility: for example, without this rule, if\n /// we expanded `expr` to include a new binary operator, we might\n@@ -532,15 +997,18 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             },\n             \"pat\" => {\n                 match *tok {\n-                    FatArrow | Comma | Eq => Ok(true),\n-                    Ident(i, _) if i.name.as_str() == \"if\" || i.name.as_str() == \"in\" => Ok(true),\n+                    FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n+                    Ident(i, _) if (i.name.as_str() == \"if\" ||\n+                                    i.name.as_str() == \"in\") => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n-                    Comma | FatArrow | Colon | Eq | Gt | Semi => Ok(true),\n-                    Ident(i, _) if i.name.as_str() == \"as\" => Ok(true),\n+                    OpenDelim(token::DelimToken::Brace) |\n+                    Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n+                    Ident(i, _) if (i.name.as_str() == \"as\" ||\n+                                    i.name.as_str() == \"where\") => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n@@ -557,3 +1025,22 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n         }\n     }\n }\n+\n+fn has_legal_fragment_specifier(tok: &Token) -> Result<(), String> {\n+    debug!(\"has_legal_fragment_specifier({:?})\", tok);\n+    if let &MatchNt(_, ref frag_spec, _, _) = tok {\n+        let s = &frag_spec.name.as_str();\n+        if !is_legal_fragment_specifier(s) {\n+            return Err(s.to_string());\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn is_legal_fragment_specifier(frag: &str) -> bool {\n+    match frag {\n+        \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n+        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "3054c307f36d95cfed856979318c8539571d5883", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -170,7 +170,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"slice_patterns\", \"1.0.0\", Some(23121), Active),\n \n     // Allows use of unary negate on unsigned integers, e.g. -e for e: u8\n-    (\"negate_unsigned\", \"1.0.0\", Some(29645), Active),\n+    (\"negate_unsigned\", \"1.0.0\", Some(29645), Removed),\n \n     // Allows the definition of associated constants in `trait` or `impl`\n     // blocks.\n@@ -548,7 +548,6 @@ pub struct Features {\n     pub allow_pushpop_unsafe: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n-    pub negate_unsigned: bool,\n     /// spans of #![feature] attrs for stable language features. for error reporting\n     pub declared_stable_lang_features: Vec<Span>,\n     /// #![feature] attrs for non-language (library) features\n@@ -585,7 +584,6 @@ impl Features {\n             allow_pushpop_unsafe: false,\n             simd_ffi: false,\n             unmarked_api: false,\n-            negate_unsigned: false,\n             declared_stable_lang_features: Vec::new(),\n             declared_lib_features: Vec::new(),\n             const_fn: false,\n@@ -1174,7 +1172,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         allow_pushpop_unsafe: cx.has_feature(\"pushpop_unsafe\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),\n-        negate_unsigned: cx.has_feature(\"negate_unsigned\"),\n         declared_stable_lang_features: accepted_features,\n         declared_lib_features: unknown_features,\n         const_fn: cx.has_feature(\"const_fn\"),"}, {"sha": "2a2fc2ef080dbf30cacd440ff6d482e0c7eda65d", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![allow(unused_imports)]\n-#![feature(negate_unsigned)]\n \n // Note: the relevant lint pass here runs before some of the constant\n // evaluation below (e.g. that performed by trans and llvm), so if you\n@@ -65,7 +64,7 @@ const VALS_I64: (i64, i64, i64, i64) =\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n-    (-u8::MIN,\n+    (-(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n      //~^ ERROR attempted to sub with overflow\n      u8::MAX + 1,\n@@ -75,7 +74,7 @@ const VALS_U8: (u8, u8, u8, u8) =\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n-    (-u16::MIN,\n+    (-(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n      //~^ ERROR attempted to sub with overflow\n      u16::MAX + 1,\n@@ -85,7 +84,7 @@ const VALS_U16: (u16, u16, u16, u16) =\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n-    (-u32::MIN,\n+    (-(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n      //~^ ERROR attempted to sub with overflow\n      u32::MAX + 1,\n@@ -95,7 +94,7 @@ const VALS_U32: (u32, u32, u32, u32) =\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n-    (-u64::MIN,\n+    (-(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n      //~^ ERROR attempted to sub with overflow\n      u64::MAX + 1,"}, {"sha": "7db7de9cee30cb70d13bdc39ec07c6e7c08eee28", "filename": "src/test/compile-fail/const-eval-overflow0.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow0.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8, i8, i8, i8) =\n+    (-i8::MIN,\n+     i8::MIN - 1,\n+     i8::MAX + 1,\n+     i8::MIN * 2,\n+     );\n+\n+const VALS_I16: (i16, i16, i16, i16) =\n+    (-i16::MIN,\n+     i16::MIN - 1,\n+     i16::MAX + 1,\n+     i16::MIN * 2,\n+     );\n+\n+const VALS_I32: (i32, i32, i32, i32) =\n+    (-i32::MIN,\n+     i32::MIN - 1,\n+     i32::MAX + 1,\n+     i32::MIN * 2,\n+     );\n+\n+const VALS_I64: (i64, i64, i64, i64) =\n+    (-i64::MIN,\n+     i64::MIN - 1,\n+     i64::MAX + 1,\n+     i64::MAX * 2,\n+     );\n+\n+const VALS_U8: (u8, u8, u8, u8) =\n+    (-u8::MIN,\n+     //~^ ERROR unary negation of unsigned integer\n+     //~| HELP use a cast or the `!` operator\n+     u8::MIN - 1,\n+     u8::MAX + 1,\n+     u8::MAX * 2,\n+     );\n+\n+const VALS_U16: (u16, u16, u16, u16) =\n+    (-u16::MIN,\n+     //~^ ERROR unary negation of unsigned integer\n+     //~| HELP use a cast or the `!` operator\n+     u16::MIN - 1,\n+     u16::MAX + 1,\n+     u16::MAX * 2,\n+     );\n+\n+const VALS_U32: (u32, u32, u32, u32) =\n+    (-u32::MIN,\n+     //~^ ERROR unary negation of unsigned integer\n+     //~| HELP use a cast or the `!` operator\n+     u32::MIN - 1,\n+     u32::MAX + 1,\n+     u32::MAX * 2,\n+     );\n+\n+const VALS_U64: (u64, u64, u64, u64) =\n+    (-u64::MIN,\n+     //~^ ERROR unary negation of unsigned integer\n+     //~| HELP use a cast or the `!` operator\n+     u64::MIN - 1,\n+     u64::MAX + 1,\n+     u64::MAX * 2,\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "84a27a382006988820be6dac882733a5b7b3c9f0", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n \n #[repr(u8)] //~ NOTE discriminant type specified here\n enum Eu8 {"}, {"sha": "15cc17b19db33bfc9bb1b2695d95fa6bdfb3df20", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that negating unsigned integers is gated by `negate_unsigned` feature\n-// gate\n+// Test that negating unsigned integers doesn't compile\n \n struct S;\n impl std::ops::Neg for S {\n@@ -18,21 +17,26 @@ impl std::ops::Neg for S {\n }\n \n const _MAX: usize = -1;\n-//~^ ERROR unary negation of unsigned integers may be removed in the future\n+//~^ ERROR unary negation of unsigned integer\n+//~| HELP use a cast or the `!` operator\n \n fn main() {\n     let a = -1;\n-    //~^ ERROR unary negation of unsigned integers may be removed in the future\n+    //~^ ERROR unary negation of unsigned integer\n+    //~| HELP use a cast or the `!` operator\n     let _b : u8 = a; // for infering variable a to u8.\n \n     -a;\n-    //~^ ERROR unary negation of unsigned integers may be removed in the future\n+    //~^ ERROR unary negation of unsigned integer\n+    //~| HELP use a cast or the `!` operator\n \n     let _d = -1u8;\n-    //~^ ERROR unary negation of unsigned integers may be removed in the future\n+    //~^ ERROR unary negation of unsigned integer\n+    //~| HELP use a cast or the `!` operator\n \n     for _ in -10..10u8 {}\n-    //~^ ERROR unary negation of unsigned integers may be removed in the future\n+    //~^ ERROR unary negation of unsigned integer\n+    //~| HELP use a cast or the `!` operator\n \n     -S; // should not trigger the gate; issue 26840\n }"}, {"sha": "7ad43954010b9b4333e422e3cdab9c47a16ceaad", "filename": "src/test/compile-fail/issue-30715.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -10,7 +10,12 @@\n \n macro_rules! parallel {\n     (\n-        for $id:ident in $iter:expr {\n+        // If future has `pred`/`moelarry` fragments (where \"pred\" is\n+        // \"like expr, but with `{` in its FOLLOW set\"), then could\n+        // use `pred` instead of future-proof erroring here. See also:\n+        //\n+        // https://github.com/rust-lang/rfcs/pull/1384#issuecomment-160165525\n+        for $id:ident in $iter:expr { //~ WARN `$iter:expr` is followed by `{`\n             $( $inner:expr; )*\n         }\n     ) => {};"}, {"sha": "0b414ad73db6f9109bd33fc5106102bae088e7e5", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n #![allow(dead_code)]\n-#![feature(negate_unsigned)]\n \n // compile-flags: -D unused-comparisons\n fn main() { }"}, {"sha": "fe758a4a6310fbfe925eeb75d0a1e9c234d0209c", "filename": "src/test/compile-fail/macro-input-future-proofing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -18,13 +18,14 @@ macro_rules! errors_everywhere {\n     ($bl:block < ) => ();\n     ($pa:pat >) => (); //~ ERROR `$pa:pat` is followed by `>`, which is not allowed for `pat`\n     ($pa:pat , ) => ();\n-    ($pa:pat | ) => (); //~ ERROR `$pa:pat` is followed by `|`\n     ($pa:pat $pb:pat $ty:ty ,) => ();\n     //~^ ERROR `$pa:pat` is followed by `$pb:pat`, which is not allowed\n     //~^^ ERROR `$pb:pat` is followed by `$ty:ty`, which is not allowed\n     ($($ty:ty)* -) => (); //~ ERROR `$ty:ty` is followed by `-`\n     ($($a:ty, $b:ty)* -) => (); //~ ERROR `$b:ty` is followed by `-`\n     ($($ty:ty)-+) => (); //~ ERROR `$ty:ty` is followed by `-`, which is not allowed for `ty`\n+    ( $($a:expr)* $($b:tt)* ) => { };\n+    //~^ ERROR `$a:expr` is followed by `$b:tt`, which is not allowed for `expr` fragments\n }\n \n fn main() { }"}, {"sha": "b4f71343d546afba29b2aa1b4a680d29b3118a19", "filename": "src/test/compile-fail/macro-seq-followed-by-seq.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1586005a1d15e7d26b6c46a33e7a9643de9a77ac/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586005a1d15e7d26b6c46a33e7a9643de9a77ac/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-seq-followed-by-seq.rs?ref=1586005a1d15e7d26b6c46a33e7a9643de9a77ac", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that we cannot have two sequence repetitions in a row.\n-\n-macro_rules! foo {\n-  ( $($a:expr)* $($b:tt)* ) => { }; //~ ERROR sequence repetition followed by another sequence\n-  ( $($a:tt)* $($b:tt)* ) => { }; //~ ERROR sequence repetition followed by another sequence\n-}\n-\n-fn main() { }"}, {"sha": "ac24ed8d9160482dd16b583ae006eb512cd477ab", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n-\n #[cfg(any(target_arch = \"x86\", target_arch = \"arm\"))]\n fn target() {\n-    assert_eq!(-1000 as usize >> 3_usize, 536870787_usize);\n+    assert_eq!(-1000isize as usize >> 3_usize, 536870787_usize);\n }\n \n #[cfg(any(target_arch = \"x86_64\", target_arch = \"aarch64\"))]\n fn target() {\n-    assert_eq!(-1000 as usize >> 3_usize, 2305843009213693827_usize);\n+    assert_eq!(-1000isize as usize >> 3_usize, 2305843009213693827_usize);\n }\n \n fn general() {"}, {"sha": "759dc515456de1784a2421661821f348a7b4a16d", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(negate_unsigned)]\n #![feature(intrinsics)]\n \n mod rusti {\n@@ -45,10 +43,10 @@ pub fn main() {\n         assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n         assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n \n-        assert_eq!(ctpop(-1u8), 8); assert_eq!(ctpop(-1i8), 8);\n-        assert_eq!(ctpop(-1u16), 16); assert_eq!(ctpop(-1i16), 16);\n-        assert_eq!(ctpop(-1u32), 32); assert_eq!(ctpop(-1i32), 32);\n-        assert_eq!(ctpop(-1u64), 64); assert_eq!(ctpop(-1i64), 64);\n+        assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n+        assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n+        assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n+        assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n \n         assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n         assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n@@ -70,10 +68,10 @@ pub fn main() {\n         assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n         assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n \n-        assert_eq!(cttz(-1u8), 0); assert_eq!(cttz(-1i8), 0);\n-        assert_eq!(cttz(-1u16), 0); assert_eq!(cttz(-1i16), 0);\n-        assert_eq!(cttz(-1u32), 0); assert_eq!(cttz(-1i32), 0);\n-        assert_eq!(cttz(-1u64), 0); assert_eq!(cttz(-1i64), 0);\n+        assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n+        assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n+        assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n+        assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n \n         assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n         assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);"}, {"sha": "c1abebd5f9040caa068c2813bbe2cafdbad9470c", "filename": "src/test/run-pass/macro-pat-follow.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmacro-pat-follow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmacro-pat-follow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat-follow.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -24,7 +24,17 @@ macro_rules! pat_if {\n     }}\n }\n \n+macro_rules! pat_bar {\n+    ($p:pat | $p2:pat) => {{\n+        match Some(1u8) {\n+            $p | $p2 => {},\n+            _ => {}\n+        }\n+    }}\n+}\n+\n fn main() {\n     pat_in!(Some(_) in 0..10);\n     pat_if!(Some(x) if x > 0);\n+    pat_bar!(Some(1u8) | None);\n }"}, {"sha": "23c7d2516a27e832933d696c8614f45a30772803", "filename": "src/test/run-pass/macro-seq-followed-by-seq.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmacro-seq-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmacro-seq-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-seq-followed-by-seq.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test of allowing two sequences repetitions in a row,\n+// functionality added as byproduct of RFC amendment #1384\n+//   https://github.com/rust-lang/rfcs/pull/1384\n+\n+// Old version of Rust would reject this macro definition, even though\n+// there are no local ambiguities (the initial `banana` and `orange`\n+// tokens are enough for the expander to distinguish which case is\n+// intended).\n+macro_rules! foo {\n+    ( $(banana $a:ident)* $(orange $b:tt)* ) => { };\n+}\n+\n+fn main() {\n+    foo!( banana id1 banana id2\n+          orange hi  orange (hello world) );\n+}"}, {"sha": "8a1f68dbea3eede0adb7fa8ddd1c8a46058da6ad", "filename": "src/test/run-pass/mir_constval_adts.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+\n+#[derive(PartialEq, Debug)]\n+struct Point {\n+    _x: i32,\n+    _y: i32,\n+}\n+const STRUCT: Point = Point { _x: 42, _y: 42 };\n+const TUPLE1: (i32, i32) = (42, 42);\n+const TUPLE2: (&'static str, &'static str) = (\"hello\",\"world\");\n+\n+#[rustc_mir]\n+fn mir() -> (Point, (i32, i32), (&'static str, &'static str)){\n+    let struct1 = STRUCT;\n+    let tuple1 = TUPLE1;\n+    let tuple2 = TUPLE2;\n+    (struct1, tuple1, tuple2)\n+}\n+\n+fn main(){\n+    assert_eq!(mir(), (STRUCT, TUPLE1, TUPLE2));\n+}\n+"}, {"sha": "cff260c3ba63e01f9cafd8dbeffb53d5fe6122f8", "filename": "src/test/run-pass/unary-minus-suffix-inference.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4405944b9414d9d39d98c988c420b77e93acba96/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs?ref=4405944b9414d9d39d98c988c420b77e93acba96", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(negate_unsigned)]\n-\n pub fn main() {\n     let a = 1;\n     let a_neg: i8 = -a;\n@@ -30,26 +28,4 @@ pub fn main() {\n     let e = 1;\n     let e_neg: isize = -e;\n     println!(\"{}\", e_neg);\n-\n-    // intentional overflows\n-\n-    let f = 1;\n-    let f_neg: u8 = -f;\n-    println!(\"{}\", f_neg);\n-\n-    let g = 1;\n-    let g_neg: u16 = -g;\n-    println!(\"{}\", g_neg);\n-\n-    let h = 1;\n-    let h_neg: u32 = -h;\n-    println!(\"{}\", h_neg);\n-\n-    let i = 1;\n-    let i_neg: u64 = -i;\n-    println!(\"{}\", i_neg);\n-\n-    let j = 1;\n-    let j_neg: usize = -j;\n-    println!(\"{}\", j_neg);\n }"}]}