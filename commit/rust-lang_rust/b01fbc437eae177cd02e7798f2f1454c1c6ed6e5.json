{"sha": "b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWZiYzQzN2VhZTE3N2NkMDJlNzc5OGYyZjE0NTRjMWM2ZWQ2ZTU=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-07-29T09:41:36Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-07-29T09:41:36Z"}, "message": "Simplify implementations of `AllocRef` for `Global` and `System`", "tree": {"sha": "85c9b547edca31684cd602bfb0777810b55ab65c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c9b547edca31684cd602bfb0777810b55ab65c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "html_url": "https://github.com/rust-lang/rust/commit/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "076ef66ba2f647a627806f376c23b332fb04d3ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/076ef66ba2f647a627806f376c23b332fb04d3ff", "html_url": "https://github.com/rust-lang/rust/commit/076ef66ba2f647a627806f376c23b332fb04d3ff"}], "stats": {"total": 338, "additions": 143, "deletions": 195}, "files": [{"sha": "111ef406c001d0c05f84ee41230649f40e86b05c", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 70, "deletions": 71, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "patch": "@@ -165,34 +165,33 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n unsafe impl AllocRef for Global {\n     #[inline]\n     fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = alloc(layout);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n+    #[inline]\n     fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = alloc_zeroed(layout);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n             unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n@@ -204,59 +203,55 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if layout.size() == 0 {\n-            let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-            self.alloc(new_layout)\n-        } else {\n-            // `realloc` probably checks for `new_size > size` or something similar.\n-            let ptr = unsafe {\n-                intrinsics::assume(new_size > size);\n-                realloc(ptr.as_ptr(), layout, new_size)\n-            };\n-            Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n+            }\n         }\n     }\n \n+    #[inline]\n     unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if layout.size() == 0 {\n-            let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-            self.alloc(new_layout)\n-        } else {\n-            // `realloc` probably checks for `new_size > size` or something similar.\n-            let ptr = unsafe {\n-                intrinsics::assume(new_size > size);\n-                realloc(ptr.as_ptr(), layout, new_size)\n-            };\n-            let memory = MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-            unsafe {\n-                memory.ptr.as_ptr().add(size).write_bytes(0, memory.size - size);\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n             }\n-            Ok(memory)\n         }\n     }\n \n@@ -267,29 +262,33 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if new_size == 0 {\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n             unsafe {\n                 self.dealloc(ptr, layout);\n             }\n-            Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            layout.dangling()\n         } else {\n-            // `realloc` probably checks for `new_size < size` or something similar.\n-            let ptr = unsafe {\n-                intrinsics::assume(new_size < size);\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n                 realloc(ptr.as_ptr(), layout, new_size)\n             };\n-            Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n-        }\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(MemoryBlock { ptr, size: new_size })\n     }\n }\n "}, {"sha": "b71a392b703a248568f58c45003ab5b76561a5bb", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 73, "deletions": 124, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01fbc437eae177cd02e7798f2f1454c1c6ed6e5/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=b01fbc437eae177cd02e7798f2f1454c1c6ed6e5", "patch": "@@ -141,38 +141,34 @@ pub struct System;\n unsafe impl AllocRef for System {\n     #[inline]\n     fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = GlobalAlloc::alloc(self, layout);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n     #[inline]\n     fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = GlobalAlloc::alloc_zeroed(self, layout);\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc_zeroed(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            // SAFETY: The safety guarantees are explained in the documentation\n-            // for the `GlobalAlloc` trait and its `dealloc` method.\n-            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n+            unsafe { GlobalAlloc::dealloc(&System, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -183,44 +179,24 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if layout.size() == 0 {\n-            let new_layout =\n-                // SAFETY: The new size and layout alignement guarantees\n-                // are transfered to the caller (they come from parameters).\n-                //\n-                // See the preconditions for `Layout::from_size_align` to\n-                // see what must be checked.\n-                unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-            self.alloc(new_layout)\n-        } else {\n-            // SAFETY:\n-            //\n-            // The safety guarantees are explained in the documentation\n-            // for the `GlobalAlloc` trait and its `dealloc` method.\n-            //\n-            // `realloc` probably checks for `new_size > size` or something\n-            // similar.\n-            //\n-            // For the guarantees about `init_offset`, see its documentation:\n-            // `ptr` is assumed valid (and checked for non-NUL) and\n-            // `memory.size` is set to `new_size` so the offset being `size`\n-            // is valid.\n-            unsafe {\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                Ok(memory)\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n             }\n         }\n     }\n@@ -232,47 +208,26 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if layout.size() == 0 {\n-            let new_layout =\n-                // SAFETY: The new size and layout alignement guarantees\n-                // are transfered to the caller (they come from parameters).\n-                //\n-                // See the preconditions for `Layout::from_size_align` to\n-                // see what must be checked.\n-                unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-            self.alloc_zeroed(new_layout)\n-        } else {\n-            // SAFETY:\n-            //\n-            // The safety guarantees are explained in the documentation\n-            // for the `GlobalAlloc` trait and its `dealloc` method.\n-            //\n-            // `realloc` probably checks for `new_size > size` or something\n-            // similar.\n-            //\n-            // For the guarantees about `init_offset`, see its documentation:\n-            // `ptr` is assumed valid (and checked for non-NUL) and\n-            // `memory.size` is set to `new_size` so the offset being `size`\n-            // is valid.\n-            let memory = unsafe {\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                memory.ptr.as_ptr().add(size).write_bytes(0, memory.size - size);\n-                memory\n-            };\n-            Ok(memory)\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n+            }\n         }\n     }\n \n@@ -283,39 +238,33 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        if new_size == 0 {\n-            // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n-            // must be respected. `ptr` and `layout` are parameters and so\n-            // those guarantees must be checked by the caller.\n-            unsafe { self.dealloc(ptr, layout) };\n-            Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n+            unsafe {\n+                self.dealloc(ptr, layout);\n+            }\n+            layout.dangling()\n         } else {\n-            // SAFETY:\n-            //\n-            // See `GlobalAlloc::realloc` for more informations about the\n-            // guarantees expected by this method. `ptr`, `layout` and\n-            // `new_size` are parameters and the responsability for their\n-            // correctness is left to the caller.\n-            //\n-            // `realloc` probably checks for `new_size < size` or something\n-            // similar.\n-            let memory = unsafe {\n-                intrinsics::assume(new_size < size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size)\n             };\n-            Ok(memory)\n-        }\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(MemoryBlock { ptr, size: new_size })\n     }\n }\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());"}]}