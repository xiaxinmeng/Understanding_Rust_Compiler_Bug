{"sha": "feedd37653b32a97e2d10c12f2cf1b14c0058c19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZWRkMzc2NTNiMzJhOTdlMmQxMGMxMmYyY2YxYjE0YzAwNThjMTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-08T16:33:39Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-13T12:21:45Z"}, "message": "Apply @nikomatsakis' nits and comments patch.", "tree": {"sha": "997596ecd199435548ac2caed69f18c09403ec3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/997596ecd199435548ac2caed69f18c09403ec3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feedd37653b32a97e2d10c12f2cf1b14c0058c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feedd37653b32a97e2d10c12f2cf1b14c0058c19", "html_url": "https://github.com/rust-lang/rust/commit/feedd37653b32a97e2d10c12f2cf1b14c0058c19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feedd37653b32a97e2d10c12f2cf1b14c0058c19/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "html_url": "https://github.com/rust-lang/rust/commit/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e"}], "stats": {"total": 232, "additions": 149, "deletions": 83}, "files": [{"sha": "ff63b74444c614238e4c9d78dc6983b2aeaab7a8", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -173,10 +173,13 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n     let type_params = node_id_type_params(bcx, node);\n     let vtables = match node {\n         ExprId(id) => node_vtables(bcx, id),\n-        MethodCall(method_call) if method_call.autoderef == 0 => {\n-            node_vtables(bcx, method_call.expr_id)\n+        MethodCall(ref method_call) => {\n+            if method_call.autoderef == 0 {\n+                node_vtables(bcx, method_call.expr_id)\n+            } else {\n+                None\n+            }\n         }\n-        _ => None\n     };\n     debug!(\"trans_fn_ref(def_id={}, node={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n@@ -381,15 +384,15 @@ pub fn trans_fn_ref_with_vtables(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n-        let ref_id = match node {\n-            ExprId(id) if id != 0 => Some(id),\n-            _ => None\n+        let opt_ref_id = match node {\n+            ExprId(id) => if id != 0 { Some(id) } else { None },\n+            MethodCall(_) => None,\n         };\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, self_vtables,\n-                                         ref_id);\n+                                         opt_ref_id);\n         let mut val = val;\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n@@ -758,9 +761,19 @@ pub fn trans_call_inner<'a>(\n }\n \n pub enum CallArgs<'a> {\n+    // Supply value of arguments as a list of expressions that must be\n+    // translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [@ast::Expr]),\n+\n+    // Supply value of arguments as a list of LLVM value refs; frequently\n+    // used with lang items and so forth, when the argument is an internal\n+    // value.\n+    ArgVals(&'a [ValueRef]),\n+\n+    // For overloaded operators: `(lhs, Option(rhs, rhs_id))`. `lhs`\n+    // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n+    // the right-hand-side (if any).\n     ArgOverloadedOp(Datum<Expr>, Option<(Datum<Expr>, ast::NodeId)>),\n-    ArgVals(&'a [ValueRef])\n }\n \n fn trans_args<'a>(cx: &'a Block<'a>,"}, {"sha": "e3a996e33d392d62f3e5f5cfce730e1cb9edfcac", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -809,9 +809,13 @@ pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n+// Key used to lookup values supplied for type parameters in an expr.\n #[deriving(Eq)]\n pub enum ExprOrMethodCall {\n+    // Type parameters for a path like `None::<int>`\n     ExprId(ast::NodeId),\n+\n+    // Type parameters for a method call like `a.foo::<int>()`\n     MethodCall(typeck::MethodCall)\n }\n "}, {"sha": "d143d6743052cb9a5722b2665263c64c1c88e8c5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -1160,9 +1160,13 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n     let method_call = MethodCall::expr(expr.id);\n-    let overloaded = bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call);\n-    // if overloaded, would be RvalueDpsExpr\n-    assert!(!overloaded || op == ast::UnDeref);\n+\n+    // The only overloaded operator that is translated to a datum\n+    // is an overloaded deref, since it is always yields a `&T`.\n+    // Otherwise, we should be in the RvalueDpsExpr path.\n+    assert!(\n+        op == ast::UnDeref ||\n+        !bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1779,6 +1783,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n \n+    // Check for overloaded deref.\n     let method_call = MethodCall {\n         expr_id: expr.id,\n         autoderef: derefs as u32\n@@ -1787,6 +1792,11 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {\n+            // Overloaded. Evaluate `trans_overloaded_op`, which will\n+            // invoke the user's deref() method, which basically\n+            // converts from the `Shaht<T>` pointer that we have into\n+            // a `&T` pointer.  We can then proceed down the normal\n+            // path (below) to dereference that `&T`.\n             let datum = if derefs == 0 {\n                 datum\n             } else {\n@@ -1798,7 +1808,10 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n             Datum(val, ref_ty, RvalueExpr(Rvalue(ByValue)))\n         }\n-        None => datum\n+        None => {\n+            // Not overloaded. We already have a pointer we know how to deref.\n+            datum\n+        }\n     };\n \n     let r = match ty::get(datum.ty).sty {"}, {"sha": "89f3377643142985a1e14e81a415d2f6e0c333da", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -335,10 +335,13 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     // exist, in which case we need to make them.\n     let vtables = match node {\n         ExprId(id) => node_vtables(bcx, id),\n-        MethodCall(method_call) if method_call.autoderef == 0 => {\n-            node_vtables(bcx, method_call.expr_id)\n+        MethodCall(method_call) => {\n+            if method_call.autoderef == 0 {\n+                node_vtables(bcx, method_call.expr_id)\n+            } else {\n+                None\n+            }\n         }\n-        _ => None\n     };\n     let r_m_origins = match vtables {\n         Some(vt) => vt,"}, {"sha": "c0ad18d9520e3f52abecb2ae7fa85378579cc16a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -229,7 +229,7 @@ pub struct AutoDerefRef {\n     autoref: Option<AutoRef>\n }\n \n-#[deriving(Decodable, Encodable)]\n+#[deriving(Decodable, Encodable, Eq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n@@ -3271,11 +3271,15 @@ pub fn expr_kind(tcx: ctxt,\n                  expr: &ast::Expr) -> ExprKind {\n     if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n-        // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n-        // exception, as its result is always unit.\n+        // generated via DPS, but there are two exceptions:\n         return match expr.node {\n+            // `a += b` has a unit result.\n             ast::ExprAssignOp(..) => RvalueStmtExpr,\n+\n+            // the deref method invoked for `*a` always yields an `&T`\n             ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n+\n+            // in the general case, result could be any type, use DPS\n             _ => RvalueDpsExpr\n         };\n     }"}, {"sha": "0d37904445ff6c4482f1786028747dcc6ef760ad", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 78, "deletions": 52, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -201,7 +201,13 @@ pub fn lookup_in_trait<'a>(\n struct LookupContext<'a> {\n     fcx: @FnCtxt,\n     span: Span,\n+\n+    // The receiver to the method call. Only `None` in the case of\n+    // an overloaded autoderef, where the receiver may be an intermediate\n+    // state like \"the expression `x` when it has been autoderef'd\n+    // twice already\".\n     self_expr: Option<&'a ast::Expr>,\n+\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n@@ -243,51 +249,69 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n         let (self_ty, autoderefs, result) =\n-            check::autoderef(self.fcx, span, self_ty, self_expr_id,\n-                             PreferMutLvalue, |self_ty, autoderefs| {\n-\n-            debug!(\"loop: self_ty={} autoderefs={}\",\n-                   self.ty_to_str(self_ty), autoderefs);\n+            check::autoderef(\n+                self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n+                |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n-            match self.deref_args {\n-                check::DontDerefArgs => {\n-                    match self.search_for_autoderefd_method(self_ty, autoderefs) {\n-                        Some(result) => return Some(Some(result)),\n-                        None => {}\n-                    }\n+        match result {\n+            Some(Some(result)) => Some(result),\n+            _ => {\n+                if self.is_overloaded_deref() {\n+                    // If we are searching for an overloaded deref, no\n+                    // need to try coercing a `~[T]` to an `&[T]` and\n+                    // searching for an overloaded deref on *that*.\n+                    None\n+                } else {\n+                    self.search_for_autosliced_method(self_ty, autoderefs)\n+                }\n+            }\n+        }\n+    }\n \n-                    match self.search_for_autoptrd_method(self_ty, autoderefs) {\n-                        Some(result) => return Some(Some(result)),\n-                        None => {}\n-                    }\n+    fn search_step(&self,\n+                   self_ty: ty::t,\n+                   autoderefs: uint)\n+                   -> Option<Option<MethodCallee>> {\n+        debug!(\"search_step: self_ty={} autoderefs={}\",\n+               self.ty_to_str(self_ty), autoderefs);\n+\n+        match self.deref_args {\n+            check::DontDerefArgs => {\n+                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n                 }\n-                check::DoDerefArgs => {\n-                    match self.search_for_autoptrd_method(self_ty, autoderefs) {\n-                        Some(result) => return Some(Some(result)),\n-                        None => {}\n-                    }\n \n-                    match self.search_for_autoderefd_method(self_ty, autoderefs) {\n-                        Some(result) => return Some(Some(result)),\n-                        None => {}\n-                    }\n+                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n                 }\n             }\n+            check::DoDerefArgs => {\n+                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n+                }\n \n-            // Don't autoderef if we aren't supposed to.\n-            if self.autoderef_receiver == DontAutoderefReceiver {\n-                Some(None)\n-            } else {\n-                None\n+                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n+                    Some(result) => return Some(Some(result)),\n+                    None => {}\n+                }\n             }\n-        });\n+        }\n \n-        match result {\n-            Some(Some(result)) => Some(result),\n-            _ => self.search_for_autosliced_method(self_ty, autoderefs)\n+        // Don't autoderef if we aren't supposed to.\n+        if self.autoderef_receiver == DontAutoderefReceiver {\n+            Some(None)\n+        } else {\n+            None\n         }\n     }\n \n+    fn is_overloaded_deref(&self) -> bool {\n+        self.self_expr.is_none()\n+    }\n+\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n@@ -625,17 +649,13 @@ impl<'a> LookupContext<'a> {\n         let (self_ty, auto_deref_ref) =\n             self.consider_reborrow(self_ty, autoderefs);\n \n-        // HACK(eddyb) only overloaded auto-deref calls should be missing\n-        // adjustments, because we imply an AutoPtr adjustment for them.\n-        let adjustment = match auto_deref_ref {\n-            ty::AutoDerefRef {\n-                autoderefs: 0,\n-                autoref: Some(ty::AutoPtr(..))\n-            } => None,\n-            _ => match self.self_expr {\n-                Some(expr) => Some((expr.id, @ty::AutoDerefRef(auto_deref_ref))),\n-                None => return None\n-            }\n+        // Hacky. For overloaded derefs, there may be an adjustment\n+        // added to the expression from the outside context, so we do not store\n+        // an explicit adjustment, but rather we hardwire the single deref\n+        // that occurs in trans and mem_categorization.\n+        let adjustment = match self.self_expr {\n+            Some(expr) => Some((expr.id, @ty::AutoDerefRef(auto_deref_ref))),\n+            None => return None\n         };\n \n         match self.search_for_method(self_ty) {\n@@ -733,9 +753,9 @@ impl<'a> LookupContext<'a> {\n                                     autoderefs: uint)\n                                     -> Option<MethodCallee> {\n         /*!\n-         *\n          * Searches for a candidate by converting things like\n-         * `~[]` to `&[]`. */\n+         * `~[]` to `&[]`.\n+         */\n \n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n@@ -843,15 +863,20 @@ impl<'a> LookupContext<'a> {\n             mutbls: &[ast::Mutability],\n             mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n             -> Option<MethodCallee> {\n-        // HACK(eddyb) only overloaded auto-deref calls should be missing\n-        // adjustments, because we imply an AutoPtr adjustment for them.\n+        // Hacky. For overloaded derefs, there may be an adjustment\n+        // added to the expression from the outside context, so we do not store\n+        // an explicit adjustment, but rather we hardwire the single deref\n+        // that occurs in trans and mem_categorization.\n         let self_expr_id = match self.self_expr {\n             Some(expr) => Some(expr.id),\n-            None => match kind(ty::ReEmpty, ast::MutImmutable) {\n-                ty::AutoPtr(..) if autoderefs == 0 => None,\n-                _ => return None\n+            None => {\n+                assert_eq!(autoderefs, 0);\n+                assert_eq!(kind(ty::ReEmpty, ast::MutImmutable),\n+                           ty::AutoPtr(ty::ReEmpty, ast::MutImmutable));\n+                None\n             }\n         };\n+\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region =\n@@ -1119,7 +1144,8 @@ impl<'a> LookupContext<'a> {\n         &self,\n         trait_def_id: ast::DefId,\n         rcvr_substs: &ty::substs,\n-        method_ty: &ty::Method) -> ty::t {\n+        method_ty: &ty::Method)\n+        -> ty::t {\n         /*!\n          * This is a bit tricky. We have a match against a trait method\n          * being invoked on an object, and we want to generate the"}, {"sha": "51efcb7d1c3879c613480ceaec1fd394522ed624", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -1247,11 +1247,14 @@ pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n                     should_stop: |ty::t, uint| -> Option<T>)\n                     -> (ty::t, uint, Option<T>) {\n     /*!\n+     * Executes an autoderef loop for the type `t`. At each step, invokes\n+     * `should_stop` to decide whether to terminate the loop. Returns\n+     * the final type and number of derefs that it performed.\n      *\n-     * Autoderefs the type `t` as many times as possible, returning a new type\n-     * and an autoderef count. If the count is not zero, the receiver is\n-     * responsible for inserting an AutoAdjustment record into `tcx.adjustments`\n-     * so that trans/borrowck/etc know about this autoderef. */\n+     * Note: this method does not modify the adjustments table. The caller is\n+     * responsible for inserting an AutoAdjustment record into the `fcx`\n+     * using one of the suitable methods.\n+     */\n \n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n@@ -2282,15 +2285,15 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n-            match ty::get(base_t).sty {\n-                ty::ty_struct(base_id, ref substs) => {\n-                    debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n-                    let fields = ty::lookup_struct_fields(tcx, base_id);\n-                    lookup_field_ty(tcx, base_id, fields.as_slice(), field, &(*substs))\n+                match ty::get(base_t).sty {\n+                    ty::ty_struct(base_id, ref substs) => {\n+                        debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n+                        let fields = ty::lookup_struct_fields(tcx, base_id);\n+                        lookup_field_ty(tcx, base_id, fields.as_slice(), field, &(*substs))\n+                    }\n+                    _ => None\n                 }\n-                _ => None\n-            }\n-        });\n+            });\n         match field_ty {\n             Some(field_ty) => {\n                 fcx.write_ty(expr.id, field_ty);"}, {"sha": "7fef6da560783c3b5327e3888b9e99d5d28c4982", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feedd37653b32a97e2d10c12f2cf1b14c0058c19/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=feedd37653b32a97e2d10c12f2cf1b14c0058c19", "patch": "@@ -354,7 +354,7 @@ pub enum Pat_ {\n     PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> )\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,"}]}