{"sha": "ae8545bd146659f6ed4b063166e382da623bc6f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlODU0NWJkMTQ2NjU5ZjZlZDRiMDYzMTY2ZTM4MmRhNjIzYmM2Zjg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-06-19T15:44:05Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-06-19T15:44:57Z"}, "message": "Memoize types in `is_representable` to avoid exponential worst-case\n\nI could have made representability a cached query, but that would have\nbeen added complexity for not much benefit - outside of the exponential\nworst-case, this pass is fast enough already.\n\nFixes #42747.", "tree": {"sha": "8ce656f01c7fd7c1b274bec337243cf233cab8d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce656f01c7fd7c1b274bec337243cf233cab8d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8545bd146659f6ed4b063166e382da623bc6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8545bd146659f6ed4b063166e382da623bc6f8", "html_url": "https://github.com/rust-lang/rust/commit/ae8545bd146659f6ed4b063166e382da623bc6f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8545bd146659f6ed4b063166e382da623bc6f8/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ce5126199d0edf278ef0d9bb60534770d96f3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce5126199d0edf278ef0d9bb60534770d96f3f6", "html_url": "https://github.com/rust-lang/rust/commit/5ce5126199d0edf278ef0d9bb60534770d96f3f6"}], "stats": {"total": 112, "additions": 99, "deletions": 13}, "files": [{"sha": "1bbc767348563142d80d820066eb1ebdcbaf13dd", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ae8545bd146659f6ed4b063166e382da623bc6f8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8545bd146659f6ed4b063166e382da623bc6f8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ae8545bd146659f6ed4b063166e382da623bc6f8", "patch": "@@ -25,6 +25,7 @@ use middle::lang_items;\n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n+use rustc_data_structures::fx::FxHashMap;\n use std::cmp;\n use std::hash::Hash;\n use std::intrinsics;\n@@ -835,27 +836,33 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             })\n         }\n \n-        fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n-                                               seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n-                                               -> Representability {\n+        fn are_inner_types_recursive<'a, 'tcx>(\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n+            seen: &mut Vec<Ty<'tcx>>,\n+            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+            ty: Ty<'tcx>)\n+            -> Representability\n+        {\n             match ty.sty {\n                 TyTuple(ref ts, _) => {\n                     // Find non representable\n                     fold_repr(ts.iter().map(|ty| {\n-                        is_type_structurally_recursive(tcx, sp, seen, ty)\n+                        is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                     }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n-                    is_type_structurally_recursive(tcx, sp, seen, ty)\n+                    is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                 }\n                 TyAdt(def, substs) => {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n                         let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n-                        match is_type_structurally_recursive(tcx, span, seen, ty) {\n+                        match is_type_structurally_recursive(tcx, span, seen,\n+                                                             representable_cache, ty)\n+                        {\n                             Representability::SelfRecursive(_) => {\n                                 Representability::SelfRecursive(vec![span])\n                             }\n@@ -896,12 +903,34 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                    sp: Span,\n-                                                    seen: &mut Vec<Ty<'tcx>>,\n-                                                    ty: Ty<'tcx>) -> Representability {\n+        fn is_type_structurally_recursive<'a, 'tcx>(\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            sp: Span,\n+            seen: &mut Vec<Ty<'tcx>>,\n+            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+            ty: Ty<'tcx>) -> Representability\n+        {\n             debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n+            if let Some(representability) = representable_cache.get(ty) {\n+                debug!(\"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n+                       ty, sp, representability);\n+                return representability.clone();\n+            }\n+\n+            let representability = is_type_structurally_recursive_inner(\n+                tcx, sp, seen, representable_cache, ty);\n+\n+            representable_cache.insert(ty, representability.clone());\n+            representability\n+        }\n \n+        fn is_type_structurally_recursive_inner<'a, 'tcx>(\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            sp: Span,\n+            seen: &mut Vec<Ty<'tcx>>,\n+            representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n+            ty: Ty<'tcx>) -> Representability\n+        {\n             match ty.sty {\n                 TyAdt(def, _) => {\n                     {\n@@ -948,13 +977,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     // For structs and enums, track all previously seen types by pushing them\n                     // onto the 'seen' stack.\n                     seen.push(ty);\n-                    let out = are_inner_types_recursive(tcx, sp, seen, ty);\n+                    let out = are_inner_types_recursive(tcx, sp, seen, representable_cache, ty);\n                     seen.pop();\n                     out\n                 }\n                 _ => {\n                     // No need to push in other cases.\n-                    are_inner_types_recursive(tcx, sp, seen, ty)\n+                    are_inner_types_recursive(tcx, sp, seen, representable_cache, ty)\n                 }\n             }\n         }\n@@ -965,7 +994,9 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         // contains a different, structurally recursive type, maintain a stack\n         // of seen types and check recursion for each of them (issues #3008, #3779).\n         let mut seen: Vec<Ty> = Vec::new();\n-        let r = is_type_structurally_recursive(tcx, sp, &mut seen, self);\n+        let mut representable_cache = FxHashMap();\n+        let r = is_type_structurally_recursive(\n+            tcx, sp, &mut seen, &mut representable_cache, self);\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }"}, {"sha": "05043ae6b2145694366d60702d3a42891b31c350", "filename": "src/test/run-pass/issue-42747.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ae8545bd146659f6ed4b063166e382da623bc6f8/src%2Ftest%2Frun-pass%2Fissue-42747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8545bd146659f6ed4b063166e382da623bc6f8/src%2Ftest%2Frun-pass%2Fissue-42747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-42747.rs?ref=ae8545bd146659f6ed4b063166e382da623bc6f8", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! fooN {\n+    ($cur:ident $prev:ty) => {\n+        #[allow(dead_code)]\n+        enum $cur {\n+            Empty,\n+            First($prev),\n+            Second($prev),\n+            Third($prev),\n+            Fourth($prev),\n+        }\n+    }\n+}\n+\n+fooN!(Foo0 ());\n+fooN!(Foo1 Foo0);\n+fooN!(Foo2 Foo1);\n+fooN!(Foo3 Foo2);\n+fooN!(Foo4 Foo3);\n+fooN!(Foo5 Foo4);\n+fooN!(Foo6 Foo5);\n+fooN!(Foo7 Foo6);\n+fooN!(Foo8 Foo7);\n+fooN!(Foo9 Foo8);\n+fooN!(Foo10 Foo9);\n+fooN!(Foo11 Foo10);\n+fooN!(Foo12 Foo11);\n+fooN!(Foo13 Foo12);\n+fooN!(Foo14 Foo13);\n+fooN!(Foo15 Foo14);\n+fooN!(Foo16 Foo15);\n+fooN!(Foo17 Foo16);\n+fooN!(Foo18 Foo17);\n+fooN!(Foo19 Foo18);\n+fooN!(Foo20 Foo19);\n+fooN!(Foo21 Foo20);\n+fooN!(Foo22 Foo21);\n+fooN!(Foo23 Foo22);\n+fooN!(Foo24 Foo23);\n+fooN!(Foo25 Foo24);\n+fooN!(Foo26 Foo25);\n+fooN!(Foo27 Foo26);\n+\n+fn main() {\n+    let _foo = Foo27::Empty;\n+}"}]}