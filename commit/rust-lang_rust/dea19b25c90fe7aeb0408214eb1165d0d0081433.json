{"sha": "dea19b25c90fe7aeb0408214eb1165d0d0081433", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYTE5YjI1YzkwZmU3YWViMDQwODIxNGViMTE2NWQwZDAwODE0MzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-06T22:46:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-06T22:48:47Z"}, "message": "rustdoc: Detect when pandoc isn't available", "tree": {"sha": "09a4ff2aaa6170b01d5e9742c47aa5756e54ff3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a4ff2aaa6170b01d5e9742c47aa5756e54ff3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dea19b25c90fe7aeb0408214eb1165d0d0081433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dea19b25c90fe7aeb0408214eb1165d0d0081433", "html_url": "https://github.com/rust-lang/rust/commit/dea19b25c90fe7aeb0408214eb1165d0d0081433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dea19b25c90fe7aeb0408214eb1165d0d0081433/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c8e43381b2b5814ca4965d2e883f78a771f262", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c8e43381b2b5814ca4965d2e883f78a771f262", "html_url": "https://github.com/rust-lang/rust/commit/b8c8e43381b2b5814ca4965d2e883f78a771f262"}], "stats": {"total": 128, "additions": 104, "deletions": 24}, "files": [{"sha": "bcc3d53fd08debabbbe5ea0d798d3abbed9388c4", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dea19b25c90fe7aeb0408214eb1165d0d0081433/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dea19b25c90fe7aeb0408214eb1165d0d0081433/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=dea19b25c90fe7aeb0408214eb1165d0d0081433", "patch": "@@ -74,14 +74,33 @@ fn default_config(input_crate: str) -> config {\n     }\n }\n \n+type program_output = fn~(str, [str]) -> {status: int, out: str, err: str};\n+\n+fn mock_program_output(_prog: str, _args: [str]) -> {\n+    status: int, out: str, err: str\n+} {\n+    {\n+        status: 0,\n+        out: \"\",\n+        err: \"\"\n+    }\n+}\n+\n fn parse_config(args: [str]) -> result::t<config, str> {\n+    parse_config_(args, std::run::program_output)\n+}\n+\n+fn parse_config_(\n+    args: [str],\n+    program_output: program_output\n+) -> result::t<config, str> {\n     let args = vec::tail(args);\n     let opts = tuple::first(vec::unzip(opts()));\n     alt getopts::getopts(args, opts) {\n         result::ok(match) {\n             if vec::len(match.free) == 1u {\n                 let input_crate = vec::head(match.free);\n-                config_from_opts(input_crate, match)\n+                config_from_opts(input_crate, match, program_output)\n             } else if vec::is_empty(match.free) {\n                 result::err(\"no crates specified\")\n             } else {\n@@ -96,7 +115,8 @@ fn parse_config(args: [str]) -> result::t<config, str> {\n \n fn config_from_opts(\n     input_crate: str,\n-    match: getopts::match\n+    match: getopts::match,\n+    program_output: program_output\n ) -> result::t<config, str> {\n \n     let config = default_config(input_crate);\n@@ -133,7 +153,8 @@ fn config_from_opts(\n     };\n     let result = result::chain(result) {|config|\n         let pandoc_cmd = getopts::opt_maybe_str(match, opt_pandoc_cmd());\n-        let pandoc_cmd = maybe_find_pandoc(config, pandoc_cmd);\n+        let pandoc_cmd = maybe_find_pandoc(\n+            config, pandoc_cmd, program_output);\n         result::chain(pandoc_cmd) {|pandoc_cmd|\n             result::ok({\n                 pandoc_cmd: pandoc_cmd\n@@ -161,113 +182,172 @@ fn parse_output_style(output_style: str) -> result::t<output_style, str> {\n }\n \n fn maybe_find_pandoc(\n-    _config: config,\n-    maybe_pandoc_cmd: option<str>\n+    config: config,\n+    maybe_pandoc_cmd: option<str>,\n+    program_output: program_output\n ) -> result::t<option<str>, str> {\n-    // FIXME: When we actually need pandoc then look for it first\n-    // on the path, then in cabal; test to make sure pandoc works\n-    alt maybe_pandoc_cmd {\n-      some(pandoc_cmd) { result::ok(some(pandoc_cmd)) }\n-      none { result::ok(some(\"pandoc\")) }\n+    if config.output_format != pandoc_html {\n+        ret result::ok(maybe_pandoc_cmd);\n+    }\n+\n+    let possible_pandocs = alt maybe_pandoc_cmd {\n+      some(pandoc_cmd) { [pandoc_cmd] }\n+      none {\n+        // FIXME (1936): Need to be able to expand ~ to look in .cabal\n+        [\"pandoc\"]\n+      }\n+    };\n+\n+    let pandoc = vec::find(possible_pandocs) {|pandoc|\n+        let output = program_output(pandoc, [\"--version\"]);\n+        #debug(\"testing pandoc cmd %s: %?\", pandoc, output);\n+        output.status == 0\n+    };\n+\n+    if option::is_some(pandoc) {\n+        result::ok(pandoc)\n+    } else {\n+        result::err(\"couldn't find pandoc\")\n+    }\n+}\n+\n+#[test]\n+fn should_find_pandoc() {\n+    let config = {\n+        output_format: pandoc_html\n+        with default_config(\"test\")\n+    };\n+    let mock_program_output = fn~(_prog: str, _args: [str]) -> {\n+        status: int, out: str, err: str\n+    } {\n+        {\n+            status: 0, out: \"pandoc 1.8.2.1\", err: \"\"\n+        }\n+    };\n+    let result = maybe_find_pandoc(config, none, mock_program_output);\n+    assert result == result::ok(some(\"pandoc\"));\n+}\n+\n+#[test]\n+fn should_error_with_no_pandoc() {\n+    let config = {\n+        output_format: pandoc_html\n+        with default_config(\"test\")\n+    };\n+    let mock_program_output = fn~(_prog: str, _args: [str]) -> {\n+        status: int, out: str, err: str\n+    } {\n+        {\n+            status: 1, out: \"\", err: \"\"\n+        }\n+    };\n+    let result = maybe_find_pandoc(config, none, mock_program_output);\n+    assert result == result::err(\"couldn't find pandoc\");\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn parse_config(args: [str]) -> result::t<config, str> {\n+        parse_config_(args, mock_program_output)\n     }\n }\n \n #[test]\n fn should_error_with_no_crates() {\n-    let config = parse_config([\"rustdoc\"]);\n+    let config = test::parse_config([\"rustdoc\"]);\n     assert result::get_err(config) == \"no crates specified\";\n }\n \n #[test]\n fn should_error_with_multiple_crates() {\n-    let config = parse_config([\"rustdoc\", \"crate1.rc\", \"crate2.rc\"]);\n+    let config = test::parse_config([\"rustdoc\", \"crate1.rc\", \"crate2.rc\"]);\n     assert result::get_err(config) == \"multiple crates specified\";\n }\n \n #[test]\n fn should_set_output_dir_to_cwd_if_not_provided() {\n-    let config = parse_config([\"rustdoc\", \"crate.rc\"]);\n+    let config = test::parse_config([\"rustdoc\", \"crate.rc\"]);\n     assert result::get(config).output_dir == \".\";\n }\n \n #[test]\n fn should_set_output_dir_if_provided() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-dir\", \"snuggles\"\n     ]);\n     assert result::get(config).output_dir == \"snuggles\";\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-    let config = parse_config([\"rustdoc\", \"crate.rc\"]);\n+    let config = test::parse_config([\"rustdoc\", \"crate.rc\"]);\n     assert result::get(config).output_format == pandoc_html;\n }\n \n #[test]\n fn should_set_output_format_to_markdown_if_requested() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-format\", \"markdown\"\n     ]);\n     assert result::get(config).output_format == markdown;\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_requested() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-format\", \"html\"\n     ]);\n     assert result::get(config).output_format == pandoc_html;\n }\n \n #[test]\n fn should_error_on_bogus_format() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-format\", \"bogus\"\n     ]);\n     assert result::get_err(config) == \"unknown output format 'bogus'\";\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_by_default() {\n-    let config = parse_config([\"rustdoc\", \"crate.rc\"]);\n+    let config = test::parse_config([\"rustdoc\", \"crate.rc\"]);\n     assert result::get(config).output_style == doc_per_mod;\n }\n \n #[test]\n fn should_set_output_style_to_one_doc_if_requested() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-style\", \"doc-per-crate\"\n     ]);\n     assert result::get(config).output_style == doc_per_crate;\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_if_requested() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-style\", \"doc-per-mod\"\n     ]);\n     assert result::get(config).output_style == doc_per_mod;\n }\n \n #[test]\n fn should_error_on_bogus_output_style() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--output-style\", \"bogus\"\n     ]);\n     assert result::get_err(config) == \"unknown output style 'bogus'\";\n }\n \n #[test]\n fn should_set_pandoc_command_if_requested() {\n-    let config = parse_config([\n+    let config = test::parse_config([\n         \"rustdoc\", \"crate.rc\", \"--pandoc-cmd\", \"panda-bear-doc\"\n     ]);\n     assert result::get(config).pandoc_cmd == some(\"panda-bear-doc\");\n }\n \n #[test]\n fn should_set_pandoc_command_when_using_pandoc() {\n-    let config = parse_config([\"rustdoc\", \"crate.rc\"]);\n+    let config = test::parse_config([\"rustdoc\", \"crate.rc\"]);\n     assert result::get(config).pandoc_cmd == some(\"pandoc\");\n }\n\\ No newline at end of file"}]}