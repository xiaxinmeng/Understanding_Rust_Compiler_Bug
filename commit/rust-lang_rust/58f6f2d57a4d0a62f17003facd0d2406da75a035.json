{"sha": "58f6f2d57a4d0a62f17003facd0d2406da75a035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZjZmMmQ1N2E0ZDBhNjJmMTcwMDNmYWNkMGQyNDA2ZGE3NWEwMzU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T16:56:10Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T16:56:10Z"}, "message": "nits and realigning", "tree": {"sha": "b91cc0a385a8c4ffa423cb96032ca349daeb466f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b91cc0a385a8c4ffa423cb96032ca349daeb466f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58f6f2d57a4d0a62f17003facd0d2406da75a035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58f6f2d57a4d0a62f17003facd0d2406da75a035", "html_url": "https://github.com/rust-lang/rust/commit/58f6f2d57a4d0a62f17003facd0d2406da75a035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58f6f2d57a4d0a62f17003facd0d2406da75a035/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dba548d3634d1f69b6210b642e700c2c41e69ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dba548d3634d1f69b6210b642e700c2c41e69ce9", "html_url": "https://github.com/rust-lang/rust/commit/dba548d3634d1f69b6210b642e700c2c41e69ce9"}], "stats": {"total": 982, "additions": 501, "deletions": 481}, "files": [{"sha": "0b627737138adc724d90602b3f3f9615bf797f45", "filename": "src/doc/tarpl/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FREADME.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -34,6 +34,6 @@ Due to the nature of advanced Rust programming, we will be spending a lot of tim\n talking about *safety* and *guarantees*. In particular, a significant portion of\n the book will be dedicated to correctly writing and understanding Unsafe Rust.\n \n-[trpl]: https://doc.rust-lang.org/book/\n-[The stack and heap]: https://doc.rust-lang.org/book/the-stack-and-the-heap.html\n-[Basic Rust]: https://doc.rust-lang.org/book/syntax-and-semantics.html\n+[trpl]: ../book/\n+[The stack and heap]: ../book/the-stack-and-the-heap.html\n+[Basic Rust]: ../book/syntax-and-semantics.html"}, {"sha": "fcafe55e409b8293827f5e6804c164e023e8de62", "filename": "src/doc/tarpl/arc-and-mutex.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,6 +1,6 @@\n % Implementing Arc and Mutex\n \n-Knowing the theory is all fine and good, but the *best* was to understand\n+Knowing the theory is all fine and good, but the *best* way to understand\n something is to use it. To better understand atomics and interior mutability,\n we'll be implementing versions of the standard library's Arc and Mutex types.\n "}, {"sha": "8395b22c8d8e8264cbd0280c543335c35f091493", "filename": "src/doc/tarpl/atomics.md", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fatomics.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -2,21 +2,22 @@\n \n Rust pretty blatantly just inherits C11's memory model for atomics. This is not\n due this model being particularly excellent or easy to understand. Indeed, this\n-model is quite complex and known to have [several flaws][C11-busted]. Rather,\n-it is a pragmatic concession to the fact that *everyone* is pretty bad at modeling\n+model is quite complex and known to have [several flaws][C11-busted]. Rather, it\n+is a pragmatic concession to the fact that *everyone* is pretty bad at modeling\n atomics. At very least, we can benefit from existing tooling and research around\n C.\n \n Trying to fully explain the model in this book is fairly hopeless. It's defined\n-in terms of madness-inducing causality graphs that require a full book to properly\n-understand in a practical way. If you want all the nitty-gritty details, you\n-should check out [C's specification (Section 7.17)][C11-model]. Still, we'll try\n-to cover the basics and some of the problems Rust developers face.\n+in terms of madness-inducing causality graphs that require a full book to\n+properly understand in a practical way. If you want all the nitty-gritty\n+details, you should check out [C's specification (Section 7.17)][C11-model].\n+Still, we'll try to cover the basics and some of the problems Rust developers\n+face.\n \n-The C11 memory model is fundamentally about trying to bridge the gap between\n-the semantics we want, the optimizations compilers want, and the inconsistent\n-chaos our hardware wants. *We* would like to just write programs and have them\n-do exactly what we said but, you know, *fast*. Wouldn't that be great?\n+The C11 memory model is fundamentally about trying to bridge the gap between the\n+semantics we want, the optimizations compilers want, and the inconsistent chaos\n+our hardware wants. *We* would like to just write programs and have them do\n+exactly what we said but, you know, *fast*. Wouldn't that be great?\n \n \n \n@@ -41,33 +42,35 @@ x = 2;\n y = 3;\n ```\n \n-This has inverted the order of events *and* completely eliminated one event. From\n-a single-threaded perspective this is completely unobservable: after all the\n-statements have executed we are in exactly the same state. But if our program is\n-multi-threaded, we may have been relying on `x` to *actually* be assigned to 1 before\n-`y` was assigned. We would *really* like the compiler to be able to make these kinds\n-of optimizations, because they can seriously improve performance. On the other hand,\n-we'd really like to be able to depend on our program *doing the thing we said*.\n+This has inverted the order of events *and* completely eliminated one event.\n+From a single-threaded perspective this is completely unobservable: after all\n+the statements have executed we are in exactly the same state. But if our\n+program is multi-threaded, we may have been relying on `x` to *actually* be\n+assigned to 1 before `y` was assigned. We would *really* like the compiler to be\n+able to make these kinds of optimizations, because they can seriously improve\n+performance. On the other hand, we'd really like to be able to depend on our\n+program *doing the thing we said*.\n \n \n \n \n # Hardware Reordering\n \n On the other hand, even if the compiler totally understood what we wanted and\n-respected our wishes, our *hardware* might instead get us in trouble. Trouble comes\n-from CPUs in the form of memory hierarchies. There is indeed a global shared memory\n-space somewhere in your hardware, but from the perspective of each CPU core it is\n-*so very far away* and *so very slow*. Each CPU would rather work with its local\n-cache of the data and only go through all the *anguish* of talking to shared\n-memory *only* when it doesn't actually have that memory in cache.\n+respected our wishes, our *hardware* might instead get us in trouble. Trouble\n+comes from CPUs in the form of memory hierarchies. There is indeed a global\n+shared memory space somewhere in your hardware, but from the perspective of each\n+CPU core it is *so very far away* and *so very slow*. Each CPU would rather work\n+with its local cache of the data and only go through all the *anguish* of\n+talking to shared memory *only* when it doesn't actually have that memory in\n+cache.\n \n After all, that's the whole *point* of the cache, right? If every read from the\n cache had to run back to shared memory to double check that it hadn't changed,\n what would the point be? The end result is that the hardware doesn't guarantee\n-that events that occur in the same order on *one* thread, occur in the same order\n-on *another* thread. To guarantee this, we must issue special instructions to\n-the CPU telling it to be a bit less smart.\n+that events that occur in the same order on *one* thread, occur in the same\n+order on *another* thread. To guarantee this, we must issue special instructions\n+to the CPU telling it to be a bit less smart.\n \n For instance, say we convince the compiler to emit this logic:\n \n@@ -82,86 +85,82 @@ x = 1;              y *= 2;\n \n Ideally this program has 2 possible final states:\n \n-* `y = 3`: (thread 2 did the check before thread 1 completed)\n-* `y = 6`: (thread 2 did the check after thread 1 completed)\n+* `y = 3`: (thread 2 did the check before thread 1 completed) y = 6`: (thread 2\n+* `did the check after thread 1 completed)\n \n However there's a third potential state that the hardware enables:\n \n * `y = 2`: (thread 2 saw `x = 2`, but not `y = 3`, and then overwrote `y = 3`)\n \n It's worth noting that different kinds of CPU provide different guarantees. It\n-is common to seperate hardware into two categories: strongly-ordered and weakly-\n-ordered. Most notably x86/64 provides strong ordering guarantees, while ARM and\n-provides weak ordering guarantees. This has two consequences for\n-concurrent programming:\n+is common to separate hardware into two categories: strongly-ordered and weakly-\n+ordered. Most notably x86/64 provides strong ordering guarantees, while ARM\n+provides weak ordering guarantees. This has two consequences for concurrent\n+programming:\n \n * Asking for stronger guarantees on strongly-ordered hardware may be cheap or\n   even *free* because they already provide strong guarantees unconditionally.\n   Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n \n-* Asking for guarantees that are *too* weak on strongly-ordered hardware\n-  is more likely to *happen* to work, even though your program is strictly\n-  incorrect. If possible, concurrent algorithms should be tested on\n-  weakly-ordered hardware.\n+* Asking for guarantees that are *too* weak on strongly-ordered hardware   is\n+  more likely to *happen* to work, even though your program is strictly\n+  incorrect. If possible, concurrent algorithms should be tested on   weakly-\n+  ordered hardware.\n \n \n \n \n \n # Data Accesses\n \n-The C11 memory model attempts to bridge the gap by allowing us to talk about\n-the *causality* of our program. Generally, this is by establishing a\n-*happens before* relationships between parts of the program and the threads\n-that are running them. This gives the hardware and compiler room to optimize the\n-program more aggressively where a strict happens-before relationship isn't\n-established, but forces them to be more careful where one *is* established.\n-The way we communicate these relationships are through *data accesses* and\n-*atomic accesses*.\n+The C11 memory model attempts to bridge the gap by allowing us to talk about the\n+*causality* of our program. Generally, this is by establishing a *happens\n+before* relationships between parts of the program and the threads that are\n+running them. This gives the hardware and compiler room to optimize the program\n+more aggressively where a strict happens-before relationship isn't established,\n+but forces them to be more careful where one *is* established. The way we\n+communicate these relationships are through *data accesses* and *atomic\n+accesses*.\n \n Data accesses are the bread-and-butter of the programming world. They are\n fundamentally unsynchronized and compilers are free to aggressively optimize\n-them. In particular, data accesses are free to be reordered by the compiler\n-on the assumption that the program is single-threaded. The hardware is also free\n-to propagate the changes made in data accesses to other threads\n-as lazily and inconsistently as it wants. Mostly critically, data accesses are\n-how data races happen. Data accesses are very friendly to the hardware and\n-compiler, but as we've seen they offer *awful* semantics to try to\n-write synchronized code with. Actually, that's too weak. *It is literally\n-impossible to write correct synchronized code using only data accesses*.\n+them. In particular, data accesses are free to be reordered by the compiler on\n+the assumption that the program is single-threaded. The hardware is also free to\n+propagate the changes made in data accesses to other threads as lazily and\n+inconsistently as it wants. Mostly critically, data accesses are how data races\n+happen. Data accesses are very friendly to the hardware and compiler, but as\n+we've seen they offer *awful* semantics to try to write synchronized code with.\n+Actually, that's too weak. *It is literally impossible to write correct\n+synchronized code using only data accesses*.\n \n Atomic accesses are how we tell the hardware and compiler that our program is\n-multi-threaded. Each atomic access can be marked with\n-an *ordering* that specifies what kind of relationship it establishes with\n-other accesses. In practice, this boils down to telling the compiler and hardware\n-certain things they *can't* do. For the compiler, this largely revolves\n-around re-ordering of instructions. For the hardware, this largely revolves\n-around how writes are propagated to other threads. The set of orderings Rust\n-exposes are:\n-\n-* Sequentially Consistent (SeqCst)\n-* Release\n-* Acquire\n-* Relaxed\n+multi-threaded. Each atomic access can be marked with an *ordering* that\n+specifies what kind of relationship it establishes with other accesses. In\n+practice, this boils down to telling the compiler and hardware certain things\n+they *can't* do. For the compiler, this largely revolves around re-ordering of\n+instructions. For the hardware, this largely revolves around how writes are\n+propagated to other threads. The set of orderings Rust exposes are:\n+\n+* Sequentially Consistent (SeqCst) Release Acquire Relaxed\n \n (Note: We explicitly do not expose the C11 *consume* ordering)\n \n-TODO: negative reasoning vs positive reasoning?\n-TODO: \"can't forget to synchronize\"\n+TODO: negative reasoning vs positive reasoning? TODO: \"can't forget to\n+synchronize\"\n \n \n \n # Sequentially Consistent\n \n Sequentially Consistent is the most powerful of all, implying the restrictions\n-of all other orderings. Intuitively, a sequentially consistent operation *cannot*\n-be reordered: all accesses on one thread that happen before and after it *stay*\n-before and after it. A data-race-free program that uses only sequentially consistent\n-atomics and data accesses has the very nice property that there is a single global\n-execution of the program's instructions that all threads agree on. This execution\n-is also particularly nice to reason about: it's just an interleaving of each thread's\n-individual executions. This *does not* hold if you start using the weaker atomic\n-orderings.\n+of all other orderings. Intuitively, a sequentially consistent operation\n+*cannot* be reordered: all accesses on one thread that happen before and after a\n+SeqCst access *stay* before and after it. A data-race-free program that uses\n+only sequentially consistent atomics and data accesses has the very nice\n+property that there is a single global execution of the program's instructions\n+that all threads agree on. This execution is also particularly nice to reason\n+about: it's just an interleaving of each thread's individual executions. This\n+*does not* hold if you start using the weaker atomic orderings.\n \n The relative developer-friendliness of sequential consistency doesn't come for\n free. Even on strongly-ordered platforms sequential consistency involves\n@@ -173,26 +172,26 @@ confident about the other memory orders. Having your program run a bit slower\n than it needs to is certainly better than it running incorrectly! It's also\n *mechanically* trivial to downgrade atomic operations to have a weaker\n consistency later on. Just change `SeqCst` to e.g. `Relaxed` and you're done! Of\n-course, proving that this transformation is *correct* is whole other matter.\n+course, proving that this transformation is *correct* is a whole other matter.\n \n \n \n \n # Acquire-Release\n \n-Acquire and Release are largely intended to be paired. Their names hint at\n-their use case: they're perfectly suited for acquiring and releasing locks,\n-and ensuring that critical sections don't overlap.\n+Acquire and Release are largely intended to be paired. Their names hint at their\n+use case: they're perfectly suited for acquiring and releasing locks, and\n+ensuring that critical sections don't overlap.\n \n Intuitively, an acquire access ensures that every access after it *stays* after\n it. However operations that occur before an acquire are free to be reordered to\n occur after it. Similarly, a release access ensures that every access before it\n-*stays* before it. However operations that occur after a release are free to\n-be reordered to occur before it.\n+*stays* before it. However operations that occur after a release are free to be\n+reordered to occur before it.\n \n When thread A releases a location in memory and then thread B subsequently\n acquires *the same* location in memory, causality is established. Every write\n-that happened *before* A's release will be observed by B *after* it's release.\n+that happened *before* A's release will be observed by B *after* its release.\n However no causality is established with any other threads. Similarly, no\n causality is established if A and B access *different* locations in memory.\n "}, {"sha": "cbcf81d8371214dd7663a1f5c3a0cb6a77787790", "filename": "src/doc/tarpl/casts.md", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,12 +1,13 @@\n % Casts\n \n-Casts are a superset of coercions: every coercion can be explicitly invoked via a\n-cast, but some conversions *require* a cast. These \"true casts\" are generally regarded\n-as dangerous or problematic actions. True casts revolve around raw pointers and\n-the primitive numeric types. True casts aren't checked.\n+Casts are a superset of coercions: every coercion can be explicitly invoked via\n+a cast, but some conversions *require* a cast. These \"true casts\" are generally\n+regarded as dangerous or problematic actions. True casts revolve around raw\n+pointers and the primitive numeric types. True casts aren't checked.\n \n Here's an exhaustive list of all the true casts. For brevity, we will use `*`\n-to denote either a `*const` or `*mut`, and `integer` to denote any integral primitive:\n+to denote either a `*const` or `*mut`, and `integer` to denote any integral\n+primitive:\n \n  * `*T as *U` where `T, U: Sized`\n  * `*T as *U` TODO: explain unsized situation\n@@ -37,19 +38,21 @@ expression, `e as U2` is not necessarily so (in fact it will only be valid if\n For numeric casts, there are quite a few cases to consider:\n \n * casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n-* casting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate\n+* casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n+  truncate\n * casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n     * zero-extend if the source is unsigned\n     * sign-extend if the source is signed\n * casting from a float to an integer will round the float towards zero\n     * **NOTE: currently this will cause Undefined Behaviour if the rounded\n-      value cannot be represented by the target integer type**. This is a bug\n-      and will be fixed. (TODO: figure out what Inf and NaN do)\n-* casting from an integer to float will produce the floating point representation\n-  of the integer, rounded if necessary (rounding strategy unspecified).\n-* casting from an f32 to an f64 is perfect and lossless.\n+      value cannot be represented by the target integer type**. This includes\n+      Inf and NaN. This is a bug and will be fixed.\n+* casting from an integer to float will produce the floating point\n+  representation of the integer, rounded if necessary (rounding strategy\n+  unspecified)\n+* casting from an f32 to an f64 is perfect and lossless\n * casting from an f64 to an f32 will produce the closest possible value\n-  (rounding strategy unspecified).\n+  (rounding strategy unspecified)\n     * **NOTE: currently this will cause Undefined Behaviour if the value\n       is finite but larger or smaller than the largest or smallest finite\n       value representable by f32**. This is a bug and will be fixed."}, {"sha": "667afe012d557ad1eba6b4d3e965c688ef770b68", "filename": "src/doc/tarpl/checked-uninit.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,13 +1,13 @@\n % Checked Uninitialized Memory\n \n-Like C, all stack variables in Rust are uninitialized until a\n-value is explicitly assigned to them. Unlike C, Rust statically prevents you\n-from ever reading them until you do:\n+Like C, all stack variables in Rust are uninitialized until a value is\n+explicitly assigned to them. Unlike C, Rust statically prevents you from ever\n+reading them until you do:\n \n ```rust\n fn main() {\n-\tlet x: i32;\n-\tprintln!(\"{}\", x);\n+    let x: i32;\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -25,13 +25,13 @@ or anything like that. So this compiles:\n \n ```rust\n fn main() {\n-\tlet x: i32;\n+    let x: i32;\n \n-\tif true {\n-\t\tx = 1;\n-\t} else {\n-\t\tx = 2;\n-\t}\n+    if true {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n \n     println!(\"{}\", x);\n }\n@@ -41,30 +41,30 @@ but this doesn't:\n \n ```rust\n fn main() {\n-\tlet x: i32;\n-\tif true {\n-\t\tx = 1;\n-\t}\n-\tprintln!(\"{}\", x);\n+    let x: i32;\n+    if true {\n+        x = 1;\n+    }\n+    println!(\"{}\", x);\n }\n ```\n \n ```text\n src/main.rs:6:17: 6:18 error: use of possibly uninitialized variable: `x`\n-src/main.rs:6 \tprintln!(\"{}\", x);\n+src/main.rs:6   println!(\"{}\", x);\n ```\n \n while this does:\n \n ```rust\n fn main() {\n-\tlet x: i32;\n-\tif true {\n-\t\tx = 1;\n-\t\tprintln!(\"{}\", x);\n-\t}\n-\t// Don't care that there are branches where it's not initialized\n-\t// since we don't use the value in those branches\n+    let x: i32;\n+    if true {\n+        x = 1;\n+        println!(\"{}\", x);\n+    }\n+    // Don't care that there are branches where it's not initialized\n+    // since we don't use the value in those branches\n }\n ```\n \n@@ -73,10 +73,10 @@ uninitialized if the type of the value isn't Copy. That is:\n \n ```rust\n fn main() {\n-\tlet x = 0;\n-\tlet y = Box::new(0);\n-\tlet z1 = x; // x is still valid because i32 is Copy\n-\tlet z2 = y; // y is now logically uninitialized because Box isn't Copy\n+    let x = 0;\n+    let y = Box::new(0);\n+    let z1 = x; // x is still valid because i32 is Copy\n+    let z2 = y; // y is now logically uninitialized because Box isn't Copy\n }\n ```\n "}, {"sha": "023dea08444a436f403fbdb209e326486d993e76", "filename": "src/doc/tarpl/constructors.md", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconstructors.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -5,41 +5,41 @@ and initialize all its fields at once:\n \n ```rust\n struct Foo {\n-\ta: u8,\n-\tb: u32,\n-\tc: bool,\n+    a: u8,\n+    b: u32,\n+    c: bool,\n }\n \n enum Bar {\n-\tX(u32),\n-\tY(bool),\n+    X(u32),\n+    Y(bool),\n }\n \n-struct Empty;\n+struct Unit;\n \n let foo = Foo { a: 0, b: 1, c: false };\n let bar = Bar::X(0);\n-let empty = Empty;\n+let empty = Unit;\n ```\n \n That's it. Every other way you make an instance of a type is just calling a\n totally vanilla function that does some stuff and eventually bottoms out to The\n One True Constructor.\n \n-Unlike C++, Rust does not come with a slew of built in kinds of constructor.\n+Unlike C++, Rust does not come with a slew of built-in kinds of constructor.\n There are no Copy, Default, Assignment, Move, or whatever constructors. The\n-reasons for this are varied, but it largely boils down to Rust's philosophy\n-of *being explicit*.\n+reasons for this are varied, but it largely boils down to Rust's philosophy of\n+*being explicit*.\n \n Move constructors are meaningless in Rust because we don't enable types to\n \"care\" about their location in memory. Every type must be ready for it to be\n blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n still-movable intrusive linked lists are simply not happening in Rust (safely).\n \n Assignment and copy constructors similarly don't exist because move semantics\n-are the *only* semantics in Rust. At most `x = y` just moves the bits of y into the x\n-variable. Rust *does* provide two facilities for providing C++'s copy-oriented\n-semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n+are the *only* semantics in Rust. At most `x = y` just moves the bits of y into\n+the x variable. Rust *does* provide two facilities for providing C++'s copy-\n+oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n constructor, but it's never implicitly invoked. You have to explicitly call\n `clone` on an element you want to be cloned. Copy is a special case of Clone\n where the implementation is just \"copy the bits\". Copy types *are* implicitly\n@@ -53,3 +53,7 @@ only useful for generic programming. In concrete contexts, a type will provide a\n static `new` method for any kind of \"default\" constructor. This has no relation\n to `new` in other languages and has no special meaning. It's just a naming\n convention.\n+\n+TODO: talk about \"placement new\"?\n+\n+[uninit]: uninitialized.html"}, {"sha": "56c050072b976bb5ad962f63eb5426f9db7ff45f", "filename": "src/doc/tarpl/conversions.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconversions.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,13 +1,13 @@\n % Type Conversions\n \n-At the end of the day, everything is just a pile of bits somewhere, and type systems\n-are just there to help us use those bits right. Needing to reinterpret those piles\n-of bits as different types is a common problem and Rust consequently gives you\n-several ways to do that.\n+At the end of the day, everything is just a pile of bits somewhere, and type\n+systems are just there to help us use those bits right. Needing to reinterpret\n+those piles of bits as different types is a common problem and Rust consequently\n+gives you several ways to do that.\n \n-First we'll look at the ways that *Safe Rust* gives you to reinterpret values. The\n-most trivial way to do this is to just destructure a value into its constituent\n-parts and then build a new type out of them. e.g.\n+First we'll look at the ways that *Safe Rust* gives you to reinterpret values.\n+The most trivial way to do this is to just destructure a value into its\n+constituent parts and then build a new type out of them. e.g.\n \n ```rust\n struct Foo {\n@@ -26,6 +26,6 @@ fn reinterpret(foo: Foo) -> Bar {\n }\n ```\n \n-But this is, at best, annoying to do. For common conversions, rust provides\n+But this is, at best, annoying to do. For common conversions, Rust provides\n more ergonomic alternatives.\n "}, {"sha": "cf6378c3e25a33724ee6bf8dfbfadc07ce1d9a75", "filename": "src/doc/tarpl/destructors.md", "status": "modified", "additions": 65, "deletions": 62, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,67 +1,68 @@\n % Destructors\n \n-What the language *does* provide is full-blown automatic destructors through the `Drop` trait,\n-which provides the following method:\n+What the language *does* provide is full-blown automatic destructors through the\n+`Drop` trait, which provides the following method:\n \n ```rust\n fn drop(&mut self);\n ```\n \n-This method gives the type time to somehow finish what it was doing. **After `drop` is run,\n-Rust will recursively try to drop all of the fields of `self`**. This is a\n-convenience feature so that you don't have to write \"destructor boilerplate\" to drop\n-children. If a struct has no special logic for being dropped other than dropping its\n-children, then it means `Drop` doesn't need to be implemented at all!\n+This method gives the type time to somehow finish what it was doing. **After\n+`drop` is run, Rust will recursively try to drop all of the fields of `self`**.\n+This is a convenience feature so that you don't have to write \"destructor\n+boilerplate\" to drop children. If a struct has no special logic for being\n+dropped other than dropping its children, then it means `Drop` doesn't need to\n+be implemented at all!\n \n-**There is no stable way to prevent this behaviour in Rust 1.0**.\n+**There is no stable way to prevent this behaviour in Rust 1.0.\n \n-Note that taking `&mut self` means that even if you *could* suppress recursive Drop,\n-Rust will prevent you from e.g. moving fields out of self. For most types, this\n-is totally fine.\n+Note that taking `&mut self` means that even if you *could* suppress recursive\n+Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n+this is totally fine.\n \n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n ```rust\n struct Box<T>{ ptr: *mut T }\n \n impl<T> Drop for Box<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\t(*self.ptr).drop();\n-\t\t\theap::deallocate(self.ptr);\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            (*self.ptr).drop();\n+            heap::deallocate(self.ptr);\n+        }\n+    }\n }\n ```\n \n-and this works fine because when Rust goes to drop the `ptr` field it just sees a *mut that\n-has no actual `Drop` implementation. Similarly nothing can use-after-free the `ptr` because\n-the Box is immediately marked as uninitialized.\n+and this works fine because when Rust goes to drop the `ptr` field it just sees\n+a *mut that has no actual `Drop` implementation. Similarly nothing can use-\n+after-free the `ptr` because the Box is immediately marked as uninitialized.\n \n However this wouldn't work:\n \n ```rust\n struct Box<T>{ ptr: *mut T }\n \n impl<T> Drop for Box<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\t(*self.ptr).drop();\n-\t\t\theap::deallocate(self.ptr);\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            (*self.ptr).drop();\n+            heap::deallocate(self.ptr);\n+        }\n+    }\n }\n \n struct SuperBox<T> { box: Box<T> }\n \n impl<T> Drop for SuperBox<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\t// Hyper-optimized: deallocate the box's contents for it\n-\t\t\t// without `drop`ing the contents\n-\t\t\theap::deallocate(self.box.ptr);\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Hyper-optimized: deallocate the box's contents for it\n+            // without `drop`ing the contents\n+            heap::deallocate(self.box.ptr);\n+        }\n+    }\n }\n ```\n \n@@ -74,9 +75,9 @@ regardless of whether they implement Drop. Therefore something like\n \n ```rust\n struct Boxy<T> {\n-\tdata1: Box<T>,\n-\tdata2: Box<T>,\n-\tinfo: u32,\n+    data1: Box<T>,\n+    data2: Box<T>,\n+    info: u32,\n }\n ```\n \n@@ -88,16 +89,18 @@ Similarly,\n \n ```rust\n enum Link {\n-\tNext(Box<Link>),\n-\tNone,\n+    Next(Box<Link>),\n+    None,\n }\n ```\n \n-will have its inner Box field dropped *if and only if* an instance stores the Next variant.\n+will have its inner Box field dropped *if and only if* an instance stores the\n+Next variant.\n \n-In general this works really nice because you don't need to worry about adding/removing\n-drops when you refactor your data layout. Still there's certainly many valid usecases for\n-needing to do trickier things with destructors.\n+In general this works really nice because you don't need to worry about\n+adding/removing drops when you refactor your data layout. Still there's\n+certainly many valid usecases for needing to do trickier things with\n+destructors.\n \n The classic safe solution to overriding recursive drop and allowing moving out\n of Self during `drop` is to use an Option:\n@@ -106,35 +109,35 @@ of Self during `drop` is to use an Option:\n struct Box<T>{ ptr: *mut T }\n \n impl<T> Drop for Box<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\t(*self.ptr).drop();\n-\t\t\theap::deallocate(self.ptr);\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            (*self.ptr).drop();\n+            heap::deallocate(self.ptr);\n+        }\n+    }\n }\n \n struct SuperBox<T> { box: Option<Box<T>> }\n \n impl<T> Drop for SuperBox<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\t// Hyper-optimized: deallocate the box's contents for it\n-\t\t\t// without `drop`ing the contents. Need to set the `box`\n-\t\t\t// field as `None` to prevent Rust from trying to Drop it.\n-\t\t\theap::deallocate(self.box.take().unwrap().ptr);\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Hyper-optimized: deallocate the box's contents for it\n+            // without `drop`ing the contents. Need to set the `box`\n+            // field as `None` to prevent Rust from trying to Drop it.\n+            heap::deallocate(self.box.take().unwrap().ptr);\n+        }\n+    }\n }\n ```\n \n-However this has fairly odd semantics: you're saying that a field that *should* always\n-be Some may be None, just because that happens in the destructor. Of course this\n-conversely makes a lot of sense: you can call arbitrary methods on self during\n-the destructor, and this should prevent you from ever doing so after deinitializing\n-the field. Not that it will prevent you from producing any other\n+However this has fairly odd semantics: you're saying that a field that *should*\n+always be Some may be None, just because that happens in the destructor. Of\n+course this conversely makes a lot of sense: you can call arbitrary methods on\n+self during the destructor, and this should prevent you from ever doing so after\n+deinitializing the field. Not that it will prevent you from producing any other\n arbitrarily invalid state in there.\n \n On balance this is an ok choice. Certainly what you should reach for by default.\n However, in the future we expect there to be a first-class way to announce that\n-a field shouldn't be automatically dropped.\n\\ No newline at end of file\n+a field shouldn't be automatically dropped."}, {"sha": "68f7ffc77b006c1e2aed10f624e3ad1dd14bf49d", "filename": "src/doc/tarpl/drop-flags.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -3,62 +3,62 @@\n The examples in the previous section introduce an interesting problem for Rust.\n We have seen that's possible to conditionally initialize, deinitialize, and\n *reinitialize* locations of memory totally safely. For Copy types, this isn't\n-particularly notable since they're just a random pile of bits. However types with\n-destructors are a different story: Rust needs to know whether to call a destructor\n-whenever a variable is assigned to, or a variable goes out of scope. How can it\n-do this with conditional initialization?\n+particularly notable since they're just a random pile of bits. However types\n+with destructors are a different story: Rust needs to know whether to call a\n+destructor whenever a variable is assigned to, or a variable goes out of scope.\n+How can it do this with conditional initialization?\n \n-It turns out that Rust actually tracks whether a type should be dropped or not *at\n-runtime*. As a variable becomes initialized and uninitialized, a *drop flag* for\n-that variable is toggled. When a variable *might* need to be dropped, this flag\n-is evaluated to determine if it *should* be dropped.\n+It turns out that Rust actually tracks whether a type should be dropped or not\n+*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n+for that variable is toggled. When a variable *might* need to be dropped, this\n+flag is evaluated to determine if it *should* be dropped.\n \n Of course, it is *often* the case that a value's initialization state can be\n *statically* known at every point in the program. If this is the case, then the\n-compiler can theoretically generate more effecient code! For instance,\n-straight-line code has such *static drop semantics*:\n+compiler can theoretically generate more effecient code! For instance, straight-\n+line code has such *static drop semantics*:\n \n ```rust\n-let mut x = Box::new(0); // x was uninit\n-let mut y = x;\t\t\t // y was uninit\n-x = Box::new(0);\t \t // x was uninit\n-y = x;\t\t\t\t \t // y was init; Drop y!\n-\t\t\t\t     \t // y was init; Drop y!\n-\t\t\t\t     \t // x was uninit\n+let mut x = Box::new(0); // x was uninit; just overwrite.\n+let mut y = x;           // y was uninit; just overwrite and make x uninit.\n+x = Box::new(0);         // x was uninit; just overwrite.\n+y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n+                         // y was init; Drop y!\n+                         // x was uninit; do nothing.\n ```\n \n And even branched code where all branches have the same behaviour with respect\n to initialization:\n \n ```rust\n-let mut x = Box::new(0);\t// x was uninit\n+let mut x = Box::new(0);    // x was uninit; just overwrite.\n if condition {\n-\tdrop(x)\t\t\t\t\t// x gets moved out\n+    drop(x)                 // x gets moved out; make x uninit.\n } else {\n-\tprintln!(\"{}\", x);\n-\tdrop(x)\t\t\t\t\t// x gets moved out\n+    println!(\"{}\", x);\n+    drop(x)                 // x gets moved out; make x uninit.\n }\n-x = Box::new(0);\t\t\t// x was uninit\n-\t\t\t\t\t\t\t// x was init; Drop x!\n+x = Box::new(0);            // x was uninit; just overwrite.\n+                            // x was init; Drop x!\n ```\n \n However code like this *requires* runtime information to correctly Drop:\n \n ```rust\n let x;\n if condition {\n-\tx = Box::new(0);\t\t// x was uninit\n-\tprintln!(\"{}\", x);\n+    x = Box::new(0);        // x was uninit; just overwrite.\n+    println!(\"{}\", x);\n }\n-\t\t\t\t\t\t\t// x might be uninit; check the flag!\n+                            // x *might* be uninit; check the flag!\n ```\n \n Of course, in this case it's trivial to retrieve static drop semantics:\n \n ```rust\n if condition {\n-\tlet x = Box::new(0);\n-\tprintln!(\"{}\", x);\n+    let x = Box::new(0);\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -75,4 +75,4 @@ as it requires fairly substantial changes to the compiler.\n Regardless, Rust programs don't need to worry about uninitialized values on\n the stack for correctness. Although they might care for performance. Thankfully,\n Rust makes it easy to take control here! Uninitialized values are there, and\n-you can work with them in Safe Rust, but you're *never* in danger.\n\\ No newline at end of file\n+you can work with them in Safe Rust, but you're *never* in danger."}, {"sha": "ca331097811275154e6fee1d5799f8c0e1356579", "filename": "src/doc/tarpl/exception-safety.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -7,7 +7,7 @@ if it overflows. Unless you are very careful and tightly control what code runs,\n pretty much everything can unwind, and you need to be ready for it.\n \n Being ready for unwinding is often referred to as *exception safety*\n-in the broader programming world. In Rust, their are two levels of exception\n+in the broader programming world. In Rust, there are two levels of exception\n safety that one may concern themselves with:\n \n * In unsafe code, we *must* be exception safe to the point of not violating\n@@ -58,16 +58,17 @@ impl<T: Clone> Vec<T> {\n We bypass `push` in order to avoid redundant capacity and `len` checks on the\n Vec that we definitely know has capacity. The logic is totally correct, except\n there's a subtle problem with our code: it's not exception-safe! `set_len`,\n-`offset`, and `write` are all fine, but *clone* is the panic bomb we over-looked.\n+`offset`, and `write` are all fine, but *clone* is the panic bomb we over-\n+looked.\n \n-Clone is completely out of our control, and is totally free to panic. If it does,\n-our function will exit early with the length of the Vec set too large. If\n+Clone is completely out of our control, and is totally free to panic. If it\n+does, our function will exit early with the length of the Vec set too large. If\n the Vec is looked at or dropped, uninitialized memory will be read!\n \n The fix in this case is fairly simple. If we want to guarantee that the values\n we *did* clone are dropped we can set the len *in* the loop. If we just want to\n-guarantee that uninitialized memory can't be observed, we can set the len *after*\n-the loop.\n+guarantee that uninitialized memory can't be observed, we can set the len\n+*after* the loop.\n \n \n "}, {"sha": "5eeb4850d876e49aaf12c5b01b4c05b2cf51bc76", "filename": "src/doc/tarpl/exotic-sizes.md", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -9,18 +9,19 @@ is not always the case, however.\n \n # Dynamically Sized Types (DSTs)\n \n-Rust also supports types without a statically known size. On the surface,\n-this is a bit nonsensical: Rust *must* know the size of something in order to\n-work with it! DSTs are generally produced as views, or through type-erasure\n-of types that *do* have a known size. Due to their lack of a statically known\n-size, these types can only exist *behind* some kind of pointer. They consequently\n-produce a *fat* pointer consisting of the pointer and the information that\n-*completes* them.\n-\n-For instance, the slice type, `[T]`, is some statically unknown number of elements\n-stored contiguously. `&[T]` consequently consists of a `(&T, usize)` pair that specifies\n-where the slice starts, and how many elements it contains. Similarly, Trait Objects\n-support interface-oriented type erasure through a `(data_ptr, vtable_ptr)` pair.\n+Rust also supports types without a statically known size. On the surface, this\n+is a bit nonsensical: Rust *must* know the size of something in order to work\n+with it! DSTs are generally produced as views, or through type-erasure of types\n+that *do* have a known size. Due to their lack of a statically known size, these\n+types can only exist *behind* some kind of pointer. They consequently produce a\n+*fat* pointer consisting of the pointer and the information that *completes*\n+them.\n+\n+For instance, the slice type, `[T]`, is some statically unknown number of\n+elements stored contiguously. `&[T]` consequently consists of a `(&T, usize)`\n+pair that specifies where the slice starts, and how many elements it contains.\n+Similarly, Trait Objects support interface-oriented type erasure through a\n+`(data_ptr, vtable_ptr)` pair.\n \n Structs can actually store a single DST directly as their last field, but this\n makes them a DST as well:\n@@ -50,38 +51,39 @@ struct Foo; // No fields = no size\n // All fields have no size = no size\n struct Baz {\n     foo: Foo,\n-    qux: (), \t  // empty tuple has no size\n+    qux: (),      // empty tuple has no size\n     baz: [u8; 0], // empty array has no size\n }\n ```\n \n-On their own, ZSTs are, for obvious reasons, pretty useless. However\n-as with many curious layout choices in Rust, their potential is realized in a generic\n+On their own, ZSTs are, for obvious reasons, pretty useless. However as with\n+many curious layout choices in Rust, their potential is realized in a generic\n context.\n \n-Rust largely understands that any operation that produces or stores a ZST\n-can be reduced to a no-op. For instance, a `HashSet<T>` can be effeciently implemented\n-as a thin wrapper around `HashMap<T, ()>` because all the operations `HashMap` normally\n-does to store and retrieve keys will be completely stripped in monomorphization.\n+Rust largely understands that any operation that produces or stores a ZST can be\n+reduced to a no-op. For instance, a `HashSet<T>` can be effeciently implemented\n+as a thin wrapper around `HashMap<T, ()>` because all the operations `HashMap`\n+normally does to store and retrieve keys will be completely stripped in\n+monomorphization.\n \n Similarly `Result<(), ()>` and `Option<()>` are effectively just fancy `bool`s.\n \n Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\n-consequence of types with no size. In particular, pointer offsets are no-ops, and\n-standard allocators (including jemalloc, the one used by Rust) generally consider\n-passing in `0` as Undefined Behaviour.\n+consequence of types with no size. In particular, pointer offsets are no-ops,\n+and standard allocators (including jemalloc, the one used by Rust) generally\n+consider passing in `0` as Undefined Behaviour.\n \n \n \n \n \n-# Void Types\n+# Empty Types\n \n Rust also enables types to be declared that *cannot even be instantiated*. These\n types can only be talked about at the type level, and never at the value level.\n \n ```rust\n-enum Foo { } // No variants = VOID\n+enum Foo { } // No variants = EMPTY\n ```\n \n-TODO: WHY?!\n\\ No newline at end of file\n+TODO: WHY?!"}, {"sha": "1e1e95a243dd47f3a010b0a487e509a59856e300", "filename": "src/doc/tarpl/leaking.md", "status": "modified", "additions": 106, "deletions": 105, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,46 +1,46 @@\n % Leaking\n \n-Ownership based resource management is intended to simplify composition. You\n-acquire resources when you create the object, and you release the resources\n-when it gets destroyed. Since destruction is handled for you, it means you\n-can't forget to release the resources, and it happens as soon as possible!\n-Surely this is perfect and all of our problems are solved.\n+Ownership-based resource management is intended to simplify composition. You\n+acquire resources when you create the object, and you release the resources when\n+it gets destroyed. Since destruction is handled for you, it means you can't\n+forget to release the resources, and it happens as soon as possible! Surely this\n+is perfect and all of our problems are solved.\n \n Everything is terrible and we have new and exotic problems to try to solve.\n \n-Many people like to believe that Rust eliminates resource leaks, but this\n-is absolutely not the case, no matter how you look at it. In the strictest\n-sense, \"leaking\" is so abstract as to be unpreventable. It's quite trivial\n-to initialize a collection at the start of a program, fill it with tons of\n-objects with destructors, and then enter an infinite event loop that never\n-refers to it. The collection will sit around uselessly, holding on to its\n-precious resources until the program terminates (at which point all those\n-resources would have been reclaimed by the OS anyway).\n+Many people like to believe that Rust eliminates resource leaks, but this is\n+absolutely not the case, no matter how you look at it. In the strictest sense,\n+\"leaking\" is so abstract as to be unpreventable. It's quite trivial to\n+initialize a collection at the start of a program, fill it with tons of objects\n+with destructors, and then enter an infinite event loop that never refers to it.\n+The collection will sit around uselessly, holding on to its precious resources\n+until the program terminates (at which point all those resources would have been\n+reclaimed by the OS anyway).\n \n-We may consider a more restricted form of leak: failing to drop a value that\n-is unreachable. Rust also doesn't prevent this. In fact Rust has a *function\n-for doing this*: `mem::forget`. This function consumes the value it is passed\n-*and then doesn't run its destructor*.\n+We may consider a more restricted form of leak: failing to drop a value that is\n+unreachable. Rust also doesn't prevent this. In fact Rust has a *function for\n+doing this*: `mem::forget`. This function consumes the value it is passed *and\n+then doesn't run its destructor*.\n \n In the past `mem::forget` was marked as unsafe as a sort of lint against using\n it, since failing to call a destructor is generally not a well-behaved thing to\n do (though useful for some special unsafe code). However this was generally\n determined to be an untenable stance to take: there are *many* ways to fail to\n-call a destructor in safe code. The most famous example is creating a cycle\n-of reference counted pointers using interior mutability.\n+call a destructor in safe code. The most famous example is creating a cycle of\n+reference-counted pointers using interior mutability.\n \n-It is reasonable for safe code to assume that destructor leaks do not happen,\n-as any program that leaks destructors is probably wrong. However *unsafe* code\n+It is reasonable for safe code to assume that destructor leaks do not happen, as\n+any program that leaks destructors is probably wrong. However *unsafe* code\n cannot rely on destructors to be run to be *safe*. For most types this doesn't\n-matter: if you leak the destructor then the type is *by definition* inaccessible,\n-so it doesn't matter, right? For instance, if you leak a `Box<u8>` then you\n-waste some memory but that's hardly going to violate memory-safety.\n+matter: if you leak the destructor then the type is *by definition*\n+inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\n+then you waste some memory but that's hardly going to violate memory-safety.\n \n-However where we must be careful with destructor leaks are *proxy* types.\n-These are types which manage access to a distinct object, but don't actually\n-own it. Proxy objects are quite rare. Proxy objects you'll need to care about\n-are even rarer. However we'll focus on three interesting examples in the\n-standard library:\n+However where we must be careful with destructor leaks are *proxy* types. These\n+are types which manage access to a distinct object, but don't actually own it.\n+Proxy objects are quite rare. Proxy objects you'll need to care about are even\n+rarer. However we'll focus on three interesting examples in the standard\n+library:\n \n * `vec::Drain`\n * `Rc`\n@@ -58,7 +58,8 @@ after claiming ownership over all of its contents. It produces an iterator\n Now, consider Drain in the middle of iteration: some values have been moved out,\n and others haven't. This means that part of the Vec is now full of logically\n uninitialized data! We could backshift all the elements in the Vec every time we\n-remove a value, but this would have pretty catastrophic performance consequences.\n+remove a value, but this would have pretty catastrophic performance\n+consequences.\n \n Instead, we would like Drain to *fix* the Vec's backing storage when it is\n dropped. It should run itself to completion, backshift any elements that weren't\n@@ -71,35 +72,35 @@ Now consider the following:\n let mut vec = vec![Box::new(0); 4];\n \n {\n-\t// start draining, vec can no longer be accessed\n-\tlet mut drainer = vec.drain(..);\n+    // start draining, vec can no longer be accessed\n+    let mut drainer = vec.drain(..);\n \n-\t// pull out two elements and immediately drop them\n-\tdrainer.next();\n-\tdrainer.next();\n+    // pull out two elements and immediately drop them\n+    drainer.next();\n+    drainer.next();\n \n-\t// get rid of drainer, but don't call its destructor\n-\tmem::forget(drainer);\n+    // get rid of drainer, but don't call its destructor\n+    mem::forget(drainer);\n }\n \n // Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\n println!(\"{}\", vec[0]);\n ```\n \n-This is pretty clearly Not Good. Unfortunately, we're kind've stuck between\n-a rock and a hard place: maintaining consistent state at every step has\n-an enormous cost (and would negate any benefits of the API). Failing to maintain\n+This is pretty clearly Not Good. Unfortunately, we're kind've stuck between a\n+rock and a hard place: maintaining consistent state at every step has an\n+enormous cost (and would negate any benefits of the API). Failing to maintain\n consistent state gives us Undefined Behaviour in safe code (making the API\n unsound).\n \n So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n len to be 0 when we *start* the iteration, and fix it up if necessary in the\n destructor. That way, if everything executes like normal we get the desired\n-behaviour with minimal overhead. But if someone has the *audacity* to mem::forget\n-us in the middle of the iteration, all that does is *leak even more* (and possibly\n-leave the Vec in an *unexpected* but consistent state). Since we've\n-accepted that mem::forget is safe, this is definitely safe. We call leaks causing\n-more leaks a *leak amplification*.\n+behaviour with minimal overhead. But if someone has the *audacity* to\n+mem::forget us in the middle of the iteration, all that does is *leak even more*\n+(and possibly leave the Vec in an *unexpected* but consistent state). Since\n+we've accepted that mem::forget is safe, this is definitely safe. We call leaks\n+causing more leaks a *leak amplification*.\n \n \n \n@@ -108,8 +109,8 @@ more leaks a *leak amplification*.\n \n Rc is an interesting case because at first glance it doesn't appear to be a\n proxy value at all. After all, it manages the data it points to, and dropping\n-all the Rcs for a value will drop that value. leaking an Rc doesn't seem like\n-it would be particularly dangerous. It will leave the refcount permanently\n+all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\n+would be particularly dangerous. It will leave the refcount permanently\n incremented and prevent the data from being freed or dropped, but that seems\n just like Box, right?\n \n@@ -119,47 +120,47 @@ Let's consider a simplified implementation of Rc:\n \n ```rust\n struct Rc<T> {\n-\tptr: *mut RcBox<T>,\n+    ptr: *mut RcBox<T>,\n }\n \n struct RcBox<T> {\n-\tdata: T,\n-\tref_count: usize,\n+    data: T,\n+    ref_count: usize,\n }\n \n impl<T> Rc<T> {\n-\tfn new(data: T) -> Self {\n-\t\tunsafe {\n-\t\t\t// Wouldn't it be nice if heap::allocate worked like this?\n-\t\t\tlet ptr = heap::allocate<RcBox<T>>();\n-\t\t\tptr::write(ptr, RcBox {\n-\t\t\t\tdata: data,\n-\t\t\t\tref_count: 1,\n-\t\t\t});\n-\t\t\tRc { ptr: ptr }\n-\t\t}\n-\t}\n-\n-\tfn clone(&self) -> Self {\n-\t\tunsafe {\n-\t\t\t(*self.ptr).ref_count += 1;\n-\t\t}\n-\t\tRc { ptr: self.ptr }\n-\t}\n+    fn new(data: T) -> Self {\n+        unsafe {\n+            // Wouldn't it be nice if heap::allocate worked like this?\n+            let ptr = heap::allocate<RcBox<T>>();\n+            ptr::write(ptr, RcBox {\n+                data: data,\n+                ref_count: 1,\n+            });\n+            Rc { ptr: ptr }\n+        }\n+    }\n+\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            (*self.ptr).ref_count += 1;\n+        }\n+        Rc { ptr: self.ptr }\n+    }\n }\n \n impl<T> Drop for Rc<T> {\n-\tfn drop(&mut self) {\n-\t\tunsafe {\n-\t\t\tlet inner = &mut ;\n-\t\t\t(*self.ptr).ref_count -= 1;\n-\t\t\tif (*self.ptr).ref_count == 0 {\n-\t\t\t\t// drop the data and then free it\n-\t\t\t\tptr::read(self.ptr);\n-\t\t\t\theap::deallocate(self.ptr);\n-\t\t\t}\n-\t\t}\n-\t}\n+    fn drop(&mut self) {\n+        unsafe {\n+            let inner = &mut ;\n+            (*self.ptr).ref_count -= 1;\n+            if (*self.ptr).ref_count == 0 {\n+                // drop the data and then free it\n+                ptr::read(self.ptr);\n+                heap::deallocate(self.ptr);\n+            }\n+        }\n+    }\n }\n ```\n \n@@ -185,24 +186,24 @@ data on the stack without any synchronization over that data. Usage looked like:\n ```rust\n let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n {\n-\tlet guards = vec![];\n-\tfor x in &mut data {\n-\t\t// Move the mutable reference into the closure, and execute\n-\t\t// it on a different thread. The closure has a lifetime bound\n-\t\t// by the lifetime of the mutable reference `x` we store in it.\n-\t\t// The guard that is returned is in turn assigned the lifetime\n-\t\t// of the closure, so it also mutably borrows `data` as `x` did.\n-\t\t// This means we cannot access `data` until the guard goes away.\n-\t\tlet guard = thread::scoped(move || {\n-\t\t\t*x *= 2;\n-\t\t});\n-\t\t// store the thread's guard for later\n-\t\tguards.push(guard);\n-\t}\n-\t// All guards are dropped here, forcing the threads to join\n-\t// (this thread blocks here until the others terminate).\n-\t// Once the threads join, the borrow expires and the data becomes\n-\t// accessible again in this thread.\n+    let guards = vec![];\n+    for x in &mut data {\n+        // Move the mutable reference into the closure, and execute\n+        // it on a different thread. The closure has a lifetime bound\n+        // by the lifetime of the mutable reference `x` we store in it.\n+        // The guard that is returned is in turn assigned the lifetime\n+        // of the closure, so it also mutably borrows `data` as `x` did.\n+        // This means we cannot access `data` until the guard goes away.\n+        let guard = thread::scoped(move || {\n+            *x *= 2;\n+        });\n+        // store the thread's guard for later\n+        guards.push(guard);\n+    }\n+    // All guards are dropped here, forcing the threads to join\n+    // (this thread blocks here until the others terminate).\n+    // Once the threads join, the borrow expires and the data becomes\n+    // accessible again in this thread.\n }\n // data is definitely mutated here.\n ```\n@@ -213,17 +214,17 @@ In principle, this totally works! Rust's ownership system perfectly ensures it!\n ```\n let mut data = Box::new(0);\n {\n-\tlet guard = thread::scoped(|| {\n-\t\t// This is at best a data race. At worst, it's *also* a use-after-free.\n-\t\t*data += 1;\n-\t});\n-\t// Because the guard is forgotten, expiring the loan without blocking this\n-\t// thread.\n-\tmem::forget(guard);\n+    let guard = thread::scoped(|| {\n+        // This is at best a data race. At worst, it's *also* a use-after-free.\n+        *data += 1;\n+    });\n+    // Because the guard is forgotten, expiring the loan without blocking this\n+    // thread.\n+    mem::forget(guard);\n }\n // So the Box is dropped here while the scoped thread may or may not be trying\n // to access it.\n ```\n \n Dang. Here the destructor running was pretty fundamental to the API, and it had\n-to be scrapped in favour of a completely different design.\n\\ No newline at end of file\n+to be scrapped in favour of a completely different design."}, {"sha": "d4c6134c5432b89a7f00ed5aed0fbcbeef702f00", "filename": "src/doc/tarpl/other-reprs.md", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fother-reprs.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -8,30 +8,31 @@ Rust allows you to specify alternative data layout strategies from the default.\n # repr(C)\n \n This is the most important `repr`. It has fairly simple intent: do what C does.\n-The order, size, and alignment of fields is exactly what you would expect from\n-C or C++. Any type you expect to pass through an FFI boundary should have `repr(C)`,\n-as C is the lingua-franca of the programming world. This is also necessary\n-to soundly do more elaborate tricks with data layout such as reintepretting values\n-as a different type.\n+The order, size, and alignment of fields is exactly what you would expect from C\n+or C++. Any type you expect to pass through an FFI boundary should have\n+`repr(C)`, as C is the lingua-franca of the programming world. This is also\n+necessary to soundly do more elaborate tricks with data layout such as\n+reintepretting values as a different type.\n \n-However, the interaction with Rust's more exotic data layout features must be kept\n-in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\", `repr(C)`\n-can be applied to types that will be nonsensical or problematic if passed through\n-the FFI boundary.\n+However, the interaction with Rust's more exotic data layout features must be\n+kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n+`repr(C)` can be applied to types that will be nonsensical or problematic if\n+passed through the FFI boundary.\n \n-* ZSTs are still zero-sized, even though this is not a standard behaviour\n-  in C, and is explicitly contrary to the behaviour of an empty type in C++, which\n-  still consumes a byte of space.\n+* ZSTs are still zero-sized, even though this is not a standard behaviour   in\n+C, and is explicitly contrary to the behaviour of an empty type in C++, which\n+still consumes a byte of space.\n \n * DSTs, tuples, and tagged unions are not a concept in C and as such are never\n-  FFI safe.\n+FFI safe.\n \n * **The [drop flag][] will still be added**\n \n * This is equivalent to one of `repr(u*)` (see the next section) for enums. The\n-  chosen size is the default enum size for the target platform's C ABI. Note that\n-  enum representation in C is undefined, and this may be incorrect when the C\n-  code is compiled with certain flags.\n+chosen size is the default enum size for the target platform's C ABI. Note that\n+enum representation in C is implementation defined, so this is really a \"best\n+guess\". In particular, this may be incorrect when the C code of interest is\n+compiled with certain flags.\n \n \n \n@@ -40,10 +41,11 @@ the FFI boundary.\n These specify the size to make a C-like enum. If the discriminant overflows the\n integer it has to fit in, it will be an error. You can manually ask Rust to\n allow this by setting the overflowing element to explicitly be 0. However Rust\n-will not allow you to create an enum where two variants have the same discriminant.\n+will not allow you to create an enum where two variants have the same\n+discriminant.\n \n-On non-C-like enums, this will inhibit certain optimizations like the null-pointer\n-optimization.\n+On non-C-like enums, this will inhibit certain optimizations like the null-\n+pointer optimization.\n \n These reprs have no affect on a struct.\n \n@@ -53,15 +55,15 @@ These reprs have no affect on a struct.\n # repr(packed)\n \n `repr(packed)` forces rust to strip any padding, and only align the type to a\n-byte. This may improve the memory footprint, but will likely have other\n-negative side-effects.\n+byte. This may improve the memory footprint, but will likely have other negative\n+side-effects.\n \n In particular, most architectures *strongly* prefer values to be aligned. This\n-may mean the unaligned loads are penalized (x86), or even fault (some ARM chips).\n-For simple cases like directly loading or storing a packed field, the compiler\n-might be able to paper over alignment issues with shifts and masks. However if\n-you take a reference to a packed field, it's unlikely that the compiler will be\n-able to emit code to avoid an unaligned load.\n+may mean the unaligned loads are penalized (x86), or even fault (some ARM\n+chips). For simple cases like directly loading or storing a packed field, the\n+compiler might be able to paper over alignment issues with shifts and masks.\n+However if you take a reference to a packed field, it's unlikely that the\n+compiler will be able to emit code to avoid an unaligned load.\n \n `repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n this should not be used."}, {"sha": "993e2a52aebfaf58fdf9b6e1a7d3729366d8fdda", "filename": "src/doc/tarpl/references.md", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Freferences.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Freferences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Freferences.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -2,13 +2,11 @@\n \n There are two kinds of reference:\n \n-* Shared reference: `&`\n-* Mutable reference: `&mut`\n+* Shared reference: `&` Mutable reference: `&mut`\n \n Which obey the following rules:\n \n-* A reference cannot outlive its referent\n-* A mutable reference cannot be aliased\n+* A reference cannot outlive its referent A mutable reference cannot be aliased\n \n To define aliasing, we must define the notion of *paths* and *liveness*.\n \n@@ -17,60 +15,66 @@ To define aliasing, we must define the notion of *paths* and *liveness*.\n \n # Paths\n \n-If all Rust had were values, then every value would be uniquely owned\n-by a variable or composite structure. From this we naturally derive a *tree*\n-of ownership. The stack itself is the root of the tree, with every variable\n-as its direct children. Each variable's direct children would be their fields\n-(if any), and so on.\n+If all Rust had were values, then every value would be uniquely owned by a\n+variable or composite structure. From this we naturally derive a *tree* of\n+ownership. The stack itself is the root of the tree, with every variable as its\n+direct children. Each variable's direct children would be their fields (if any),\n+and so on.\n \n-From this view, every value in Rust has a unique *path* in the tree of ownership.\n-References to a value can subsequently be interpreted as a path in this tree.\n-Of particular interest are *ancestors* and *descendants*: if `x` owns `y`, then\n-`x` is an *ancestor* of `y`, and `y` is a *descendant* of `x`. Note that this is\n-an inclusive relationship: `x` is a descendant and ancestor of itself.\n+From this view, every value in Rust has a unique *path* in the tree of\n+ownership. References to a value can subsequently be interpreted as a path in\n+this tree. Of particular interest are *ancestors* and *descendants*: if `x` owns\n+`y`, then `x` is an *ancestor* of `y`, and `y` is a *descendant* of `x`. Note\n+that this is an inclusive relationship: `x` is a descendant and ancestor of\n+itself.\n \n-Tragically, plenty of data doesn't reside on the stack, and we must also accommodate this.\n-Globals and thread-locals are simple enough to model as residing at the bottom\n-of the stack (though we must be careful with mutable globals). Data on\n-the heap poses a different problem.\n+Tragically, plenty of data doesn't reside on the stack, and we must also\n+accommodate this. Globals and thread-locals are simple enough to model as\n+residing at the bottom of the stack (though we must be careful with mutable\n+globals). Data on the heap poses a different problem.\n \n If all Rust had on the heap was data uniquely owned by a pointer on the stack,\n-then we can just treat that pointer as a struct that owns the value on\n-the heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n-own data on the heap.\n+then we can just treat that pointer as a struct that owns the value on the heap.\n+Box, Vec, String, and HashMap, are examples of types which uniquely own data on\n+the heap.\n \n Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance\n introduces a notion of *shared* ownership. Shared ownership means there is no\n-unique path. A value with no unique path limits what we can do with it. In general, only\n-shared references can be created to these values. However mechanisms which ensure\n-mutual exclusion may establish One True Owner temporarily, establishing a unique path\n-to that value (and therefore all its children).\n+unique path. A value with no unique path limits what we can do with it. In\n+general, only shared references can be created to these values. However\n+mechanisms which ensure mutual exclusion may establish One True Owner\n+temporarily, establishing a unique path to that value (and therefore all its\n+children).\n \n The most common way to establish such a path is through *interior mutability*,\n in contrast to the *inherited mutability* that everything in Rust normally uses.\n-Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types. These\n-types provide exclusive access through runtime restrictions. However it is also\n-possible to establish unique ownership without interior mutability. For instance,\n-if an Rc has refcount 1, then it is safe to mutate or move its internals.\n+Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.\n+These types provide exclusive access through runtime restrictions. However it is\n+also possible to establish unique ownership without interior mutability. For\n+instance, if an Rc has refcount 1, then it is safe to mutate or move its\n+internals.\n \n In order to correctly communicate to the type system that a variable or field of\n a struct can have interior mutability, it must be wrapped in an UnsafeCell. This\n-does not in itself make it safe to perform interior mutability operations on that\n-value. You still must yourself ensure that mutual exclusion is upheld.\n+does not in itself make it safe to perform interior mutability operations on\n+that value. You still must yourself ensure that mutual exclusion is upheld.\n \n \n \n # Liveness\n \n+Note: Liveness is not the same thing as a *lifetime*, which will be explained\n+in detail in the next section of this chapter.\n+\n Roughly, a reference is *live* at some point in a program if it can be\n-dereferenced. Shared references are always live unless they are literally unreachable\n-(for instance, they reside in freed or leaked memory). Mutable references can be\n-reachable but *not* live through the process of *reborrowing*.\n+dereferenced. Shared references are always live unless they are literally\n+unreachable (for instance, they reside in freed or leaked memory). Mutable\n+references can be reachable but *not* live through the process of *reborrowing*.\n \n A mutable reference can be reborrowed to either a shared or mutable reference to\n one of its descendants. A reborrowed reference will only be live again once all\n-reborrows derived from it expire. For instance, a mutable reference can be reborrowed\n-to point to a field of its referent:\n+reborrows derived from it expire. For instance, a mutable reference can be\n+reborrowed to point to a field of its referent:\n \n ```rust\n let x = &mut (1, 2);\n@@ -110,18 +114,18 @@ to make such a borrow*, just that Rust isn't as smart as you want.\n \n To simplify things, we can model variables as a fake type of reference: *owned*\n references. Owned references have much the same semantics as mutable references:\n-they can be re-borrowed in a mutable or shared manner, which makes them no longer\n-live. Live owned references have the unique property that they can be moved\n-out of (though mutable references *can* be swapped out of). This power is\n+they can be re-borrowed in a mutable or shared manner, which makes them no\n+longer live. Live owned references have the unique property that they can be\n+moved out of (though mutable references *can* be swapped out of). This power is\n only given to *live* owned references because moving its referent would of\n course invalidate all outstanding references prematurely.\n \n As a local lint against inappropriate mutation, only variables that are marked\n as `mut` can be borrowed mutably.\n \n-It is interesting to note that Box behaves exactly like an owned\n-reference. It can be moved out of, and Rust understands it sufficiently to\n-reason about its paths like a normal variable.\n+It is interesting to note that Box behaves exactly like an owned reference. It\n+can be moved out of, and Rust understands it sufficiently to reason about its\n+paths like a normal variable.\n \n \n \n@@ -130,21 +134,21 @@ reason about its paths like a normal variable.\n \n With liveness and paths defined, we can now properly define *aliasing*:\n \n-**A mutable reference is aliased if there exists another live reference to one of\n-its ancestors or descendants.**\n+**A mutable reference is aliased if there exists another live reference to one\n+of its ancestors or descendants.**\n \n (If you prefer, you may also say the two live references alias *each other*.\n This has no semantic consequences, but is probably a more useful notion when\n verifying the soundness of a construct.)\n \n-That's it. Super simple right? Except for the fact that it took us two pages\n-to define all of the terms in that definition. You know: Super. Simple.\n+That's it. Super simple right? Except for the fact that it took us two pages to\n+define all of the terms in that definition. You know: Super. Simple.\n \n-Actually it's a bit more complicated than that. In addition to references,\n-Rust has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent\n-ownership or aliasing semantics. As a result, Rust makes absolutely no effort\n-to track that they are used correctly, and they are wildly unsafe.\n+Actually it's a bit more complicated than that. In addition to references, Rust\n+has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent\n+ownership or aliasing semantics. As a result, Rust makes absolutely no effort to\n+track that they are used correctly, and they are wildly unsafe.\n \n **It is an open question to what degree raw pointers have alias semantics.\n-However it is important for these definitions to be sound that the existence\n-of a raw pointer does not imply some kind of live path.**\n+However it is important for these definitions to be sound that the existence of\n+a raw pointer does not imply some kind of live path.**"}, {"sha": "6045d3d0378ade8430555e3a4d6bcdb40e3e4b6b", "filename": "src/doc/tarpl/send-and-sync.md", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/58f6f2d57a4d0a62f17003facd0d2406da75a035/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=58f6f2d57a4d0a62f17003facd0d2406da75a035", "patch": "@@ -1,38 +1,40 @@\n % Send and Sync\n \n-Not everything obeys inherited mutability, though. Some types allow you to multiply\n-alias a location in memory while mutating it. Unless these types use synchronization\n-to manage this access, they are absolutely not thread safe. Rust captures this with\n-through the `Send` and `Sync` traits.\n+Not everything obeys inherited mutability, though. Some types allow you to\n+multiply alias a location in memory while mutating it. Unless these types use\n+synchronization to manage this access, they are absolutely not thread safe. Rust\n+captures this with through the `Send` and `Sync` traits.\n \n-* A type is Send if it is safe to send it to another thread.\n-* A type is Sync if it is safe to share between threads (`&T` is Send).\n+* A type is Send if it is safe to send it to another thread. A type is Sync if\n+* it is safe to share between threads (`&T` is Send).\n \n Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n-foremost, they're *unsafe traits*. This means that they are unsafe *to implement*,\n-and other unsafe code can *trust* that they are correctly implemented. Since\n-they're *marker traits* (they have no associated items like methods), correctly\n-implemented simply means that they have the intrinsic properties an implementor\n-should have. Incorrectly implementing Send or Sync can cause Undefined Behaviour.\n-\n-Send and Sync are also what Rust calls *opt-in builtin traits*.\n-This means that, unlike every other trait, they are *automatically* derived:\n-if a type is composed entirely of Send or Sync types, then it is Send or Sync.\n-Almost all primitives are Send and Sync, and as a consequence pretty much\n-all types you'll ever interact with are Send and Sync.\n+foremost, they're *unsafe traits*. This means that they are unsafe *to\n+implement*, and other unsafe code can *trust* that they are correctly\n+implemented. Since they're *marker traits* (they have no associated items like\n+methods), correctly implemented simply means that they have the intrinsic\n+properties an implementor should have. Incorrectly implementing Send or Sync can\n+cause Undefined Behaviour.\n+\n+Send and Sync are also what Rust calls *opt-in builtin traits*. This means that,\n+unlike every other trait, they are *automatically* derived: if a type is\n+composed entirely of Send or Sync types, then it is Send or Sync. Almost all\n+primitives are Send and Sync, and as a consequence pretty much all types you'll\n+ever interact with are Send and Sync.\n \n Major exceptions include:\n \n * raw pointers are neither Send nor Sync (because they have no safety guards)\n-* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't)\n-* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized)\n+* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't) `Rc` isn't\n+* Send or Sync (because the refcount is shared and unsynchronized)\n \n `Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n-unsynchronized shared mutable state. However raw pointers are, strictly speaking,\n-marked as thread-unsafe as more of a *lint*. Doing anything useful\n+unsynchronized shared mutable state. However raw pointers are, strictly\n+speaking, marked as thread-unsafe as more of a *lint*. Doing anything useful\n with a raw pointer requires dereferencing it, which is already unsafe. In that\n-sense, one could argue that it would be \"fine\" for them to be marked as thread safe.\n+sense, one could argue that it would be \"fine\" for them to be marked as thread\n+safe.\n \n However it's important that they aren't thread safe to prevent types that\n *contain them* from being automatically marked as thread safe. These types have\n@@ -60,17 +62,16 @@ impl !Send for SpecialThreadToken {}\n impl !Sync for SpecialThreadToken {}\n ```\n \n-Note that *in and of itself* it is impossible to incorrectly derive Send and Sync.\n-Only types that are ascribed special meaning by other unsafe code can possible cause\n-trouble by being incorrectly Send or Sync.\n+Note that *in and of itself* it is impossible to incorrectly derive Send and\n+Sync. Only types that are ascribed special meaning by other unsafe code can\n+possible cause trouble by being incorrectly Send or Sync.\n \n Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n that Send and Sync can be derived. For instance all of Rust's standard\n-collections are Send and Sync (when they contain Send and Sync types)\n-in spite of their pervasive use raw pointers to\n-manage allocations and complex ownership. Similarly, most iterators into these\n-collections are Send and Sync because they largely behave like an `&` or `&mut`\n-into the collection.\n+collections are Send and Sync (when they contain Send and Sync types) in spite\n+of their pervasive use raw pointers to manage allocations and complex ownership.\n+Similarly, most iterators into these collections are Send and Sync because they\n+largely behave like an `&` or `&mut` into the collection.\n \n TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n-only to data races?\n\\ No newline at end of file\n+only to data races?"}]}