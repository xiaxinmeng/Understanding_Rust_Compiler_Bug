{"sha": "d8ecf45da8e6969f04d4d22f9a4f364231d205e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZWNmNDVkYThlNjk2OWYwNGQ0ZDIyZjlhNGYzNjQyMzFkMjA1ZTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-16T15:09:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-16T15:09:44Z"}, "message": "Rollup merge of #64499 - nnethercote:use-Symbol-in-two-more-functions, r=petrochenkov\n\nUse `Symbol` in two more functions.\n\nr? @petrochenkov", "tree": {"sha": "fca41baa91bdfd9f09e2cc47dd4e119e98729795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fca41baa91bdfd9f09e2cc47dd4e119e98729795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8ecf45da8e6969f04d4d22f9a4f364231d205e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdf6W4CRBK7hj4Ov3rIwAAdHIIAGCs6g+ue6osSzVecogSxa9O\nqaJLMZU2tAbJjLs3h4zPHhbxVNS8Pt9rFeYFoMqi6ekfzYeRPTsd35qRfEI5xsgp\nd/zCk/sJYczcnTib/0b6D8M5eEFR0hS+6EFBnlgbIny+wf/k/cDKv4gVBR4+U/Ru\nQ7HnsTXE9lwke5ilZrO2y3tOY9VVrdJRjPG/RSEx8FOxwcgxsfqMfayQ/EQkiLwN\n2C+jWpSSmyAp4LcIDTeXbXJEuZFIEcRL9LscjzeAazo0e9dTTkAVoznqbhkxA85s\n2D//WY0fRXMDEVwB8NTiMfh/8tFhXk3Kixj7wDTf411uLCR0MviKZZlO4iUWMl8=\n=MjpX\n-----END PGP SIGNATURE-----\n", "payload": "tree fca41baa91bdfd9f09e2cc47dd4e119e98729795\nparent acbbcda39974636ee3838063373ec0ce68d454cf\nparent 163892cf50a0f5ffaf4367475e7d4a412b008794\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568646584 +0200\ncommitter GitHub <noreply@github.com> 1568646584 +0200\n\nRollup merge of #64499 - nnethercote:use-Symbol-in-two-more-functions, r=petrochenkov\n\nUse `Symbol` in two more functions.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8ecf45da8e6969f04d4d22f9a4f364231d205e9", "html_url": "https://github.com/rust-lang/rust/commit/d8ecf45da8e6969f04d4d22f9a4f364231d205e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8ecf45da8e6969f04d4d22f9a4f364231d205e9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acbbcda39974636ee3838063373ec0ce68d454cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbbcda39974636ee3838063373ec0ce68d454cf", "html_url": "https://github.com/rust-lang/rust/commit/acbbcda39974636ee3838063373ec0ce68d454cf"}, {"sha": "163892cf50a0f5ffaf4367475e7d4a412b008794", "url": "https://api.github.com/repos/rust-lang/rust/commits/163892cf50a0f5ffaf4367475e7d4a412b008794", "html_url": "https://github.com/rust-lang/rust/commit/163892cf50a0f5ffaf4367475e7d4a412b008794"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "b27e9c543377ac0845b90605906f1ca505ca20c3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d8ecf45da8e6969f04d4d22f9a4f364231d205e9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8ecf45da8e6969f04d4d22f9a4f364231d205e9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d8ecf45da8e6969f04d4d22f9a4f364231d205e9", "patch": "@@ -877,9 +877,9 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, ref name, ref frag_spec) = *token {\n+            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, &frag_spec.as_str()) {\n+                    match is_in_follow(next_token, frag_spec.name) {\n                         IsInFollow::Invalid(msg, help) => {\n                             sess.span_diagnostic\n                                 .struct_span_err(next_token.span(), &msg)\n@@ -948,7 +948,7 @@ fn check_matcher_core(\n \n fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n     if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(&frag_spec.as_str())\n+        frag_can_be_followed_by_any(frag_spec.name)\n     } else {\n         // (Non NT's can always be followed by anthing in matchers.)\n         true\n@@ -963,15 +963,15 @@ fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: &str) -> bool {\n+fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n     match frag {\n-        \"item\"     | // always terminated by `}` or `;`\n-        \"block\"    | // exactly one token tree\n-        \"ident\"    | // exactly one token tree\n-        \"literal\"  | // exactly one token tree\n-        \"meta\"     | // exactly one token tree\n-        \"lifetime\" | // exactly one token tree\n-        \"tt\" =>   // exactly one token tree\n+        sym::item     | // always terminated by `}` or `;`\n+        sym::block    | // exactly one token tree\n+        sym::ident    | // exactly one token tree\n+        sym::literal  | // exactly one token tree\n+        sym::meta     | // exactly one token tree\n+        sym::lifetime | // exactly one token tree\n+        sym::tt =>   // exactly one token tree\n             true,\n \n         _ =>\n@@ -993,7 +993,7 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n+fn is_in_follow(tok: &quoted::TokenTree, frag: Symbol) -> IsInFollow {\n     use quoted::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n@@ -1002,17 +1002,17 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n         IsInFollow::Yes\n     } else {\n         match frag {\n-            \"item\" => {\n+            sym::item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            \"block\" => {\n+            sym::block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            \"stmt\" | \"expr\" => {\n+            sym::stmt | sym::expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1022,7 +1022,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"pat\" => {\n+            sym::pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1033,7 +1033,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"path\" | \"ty\" => {\n+            sym::path | sym::ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1061,20 +1061,20 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"ident\" | \"lifetime\" => {\n+            sym::ident | sym::lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            \"literal\" => {\n+            sym::literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            \"meta\" | \"tt\" => {\n+            sym::meta | sym::tt => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            \"vis\" => {\n+            sym::vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1099,7 +1099,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"\" => IsInFollow::Yes, // kw::Invalid\n+            kw::Invalid => IsInFollow::Yes,\n             _ => IsInFollow::Invalid(\n                 format!(\"invalid fragment specifier `{}`\", frag),\n                 VALID_FRAGMENT_NAMES_MSG,"}]}