{"sha": "061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MTI0NWUyYjFhMTExZWQ0NmE2MGFkM2Q4OGZhZGY0ZWI0OGRjYzY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-11T19:18:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-11T19:18:40Z"}, "message": "Rollup merge of #63346 - RalfJung:zeroed-lint, r=eddyb\n\nLint on some incorrect uses of mem::zeroed / mem::uninitialized\n\nCc https://github.com/rust-lang/rust/issues/62825 and https://internals.rust-lang.org/t/make-mem-uninitialized-and-mem-zeroed-panic-for-some-types-where-0-is-a-niche/10605\n\nThis does not yet handle `NonNull`/`NonZero*`, but it is a start.\n\nI also improved some doc issues I hit on the way, and added a useful helper to `TyS`.\n\nEDIT: I added the relnotes label mostly as a proposal -- I think this is worth mentioning, but leave the decision up to the release team.", "tree": {"sha": "2f3612b1ab89b661c90fefb8c8a60a0ffd19c0e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f3612b1ab89b661c90fefb8c8a60a0ffd19c0e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdUGoQCRBK7hj4Ov3rIwAAdHIIAE886ALFoz6ftEsHk6vjPci/\nFbmeWOYmTI5lKoWUwaIv6B/oyEKIXZWjWDmXRA+Ds9k7Wsfq2iPvzFHozsEDehhr\nGcagE82/HAEqAeOcy4GsKXM1eGm/3p1wzCPvgqzBCUHDQEm71+TecKUR6cx+llPy\nZDcBw889Y6QN30YDvGMdjhQo3FYBC0zij4/AU5xXgwmV4Sa95puYyoJHqZ7ETgNK\nOHoAGrKyP50YuReOl+trv37wyhxaj5FnbjJOqMkrO1DPhQIaEJo7fMagLFIJCsNq\nRjPfd5RbQFelxqslVI+262UGVW5eS9Ebr/z6KfHRJp+D1r+YpBh4C//hVEnNr9A=\n=Ftc7\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f3612b1ab89b661c90fefb8c8a60a0ffd19c0e2\nparent 88629778e6faeda18409ffaa9a00291e3605bae3\nparent 09307474c28eacf0d971ef95ecab0a2186a18c3b\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1565551120 -0400\ncommitter GitHub <noreply@github.com> 1565551120 -0400\n\nRollup merge of #63346 - RalfJung:zeroed-lint, r=eddyb\n\nLint on some incorrect uses of mem::zeroed / mem::uninitialized\n\nCc https://github.com/rust-lang/rust/issues/62825 and https://internals.rust-lang.org/t/make-mem-uninitialized-and-mem-zeroed-panic-for-some-types-where-0-is-a-niche/10605\n\nThis does not yet handle `NonNull`/`NonZero*`, but it is a start.\n\nI also improved some doc issues I hit on the way, and added a useful helper to `TyS`.\n\nEDIT: I added the relnotes label mostly as a proposal -- I think this is worth mentioning, but leave the decision up to the release team.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "html_url": "https://github.com/rust-lang/rust/commit/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88629778e6faeda18409ffaa9a00291e3605bae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/88629778e6faeda18409ffaa9a00291e3605bae3", "html_url": "https://github.com/rust-lang/rust/commit/88629778e6faeda18409ffaa9a00291e3605bae3"}, {"sha": "09307474c28eacf0d971ef95ecab0a2186a18c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/09307474c28eacf0d971ef95ecab0a2186a18c3b", "html_url": "https://github.com/rust-lang/rust/commit/09307474c28eacf0d971ef95ecab0a2186a18c3b"}], "stats": {"total": 371, "additions": 354, "deletions": 17}, "files": [{"sha": "1bbea02e0c7c984b8a6d3a12c031368f01c6cd17", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -13,6 +13,7 @@ use crate::mem::ManuallyDrop;\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n@@ -27,6 +28,7 @@ use crate::mem::ManuallyDrop;\n /// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -40,6 +42,7 @@ use crate::mem::ManuallyDrop;\n /// which otherwise can hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!"}, {"sha": "2534400b8334f43915ad5e7e019a84d477d2d67a", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -445,7 +445,8 @@ pub const fn needs_drop<T>() -> bool {\n ///\n /// *Incorrect* usage of this function: initializing a reference with zero.\n ///\n-/// ```no_run\n+/// ```rust,no_run\n+/// # #![allow(invalid_value)]\n /// use std::mem;\n ///\n /// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!"}, {"sha": "9d563e290de966f78e9e0a084fc59d40e1f585c1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -1842,7 +1842,8 @@ pub struct VariantDef {\n     pub ctor_kind: CtorKind,\n     /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n-    /// Recovered?\n+    /// Variant is obtained as part of recovering from a syntactic error.\n+    /// May be incomplete or bogus.\n     pub recovered: bool,\n }\n \n@@ -1949,7 +1950,7 @@ pub struct FieldDef {\n pub struct AdtDef {\n     /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n-    /// Variants of the ADT. If this is a struct or enum, then there will be a single variant.\n+    /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n     pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n     /// Flags of the ADT (e.g. is this a struct? is this non-exhaustive?)\n     flags: AdtFlags,\n@@ -2565,6 +2566,8 @@ impl<'tcx> AdtDef {\n }\n \n impl<'tcx> FieldDef {\n+    /// Returns the type of this field. The `subst` is typically obtained\n+    /// via the second field of `TyKind::AdtDef`.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }"}, {"sha": "129ea9b5b674a8737a701c8239d8538e1f7aecc2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -171,6 +171,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n+    /// Use `TyS::tuple_fields` to iterate over the field types.\n     Tuple(SubstsRef<'tcx>),\n \n     /// The projection of an associated type. For example,\n@@ -1723,8 +1724,8 @@ impl<'tcx> TyS<'tcx> {\n                     })\n                 })\n             }\n-            ty::Tuple(tys) => tys.iter().any(|ty| {\n-                ty.expect_ty().conservative_is_privately_uninhabited(tcx)\n+            ty::Tuple(..) => self.tuple_fields().any(|ty| {\n+                ty.conservative_is_privately_uninhabited(tcx)\n             }),\n             ty::Array(ty, len) => {\n                 match len.try_eval_usize(tcx, ParamEnv::empty()) {\n@@ -2103,6 +2104,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Iterates over tuple fields.\n+    /// Panics when called on anything but a tuple.\n+    pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> {\n+        match self.sty {\n+            Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n+            _ => bug!(\"tuple_fields called on non-tuple\"),\n+        }\n+    }\n+\n     /// If the type contains variants, returns the valid range of variant indices.\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]"}, {"sha": "96e16efd1300af0a144ab9a10681cfe13cbe2b4a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -845,15 +845,15 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty: Ty<'tcx>,\n         ) -> Representability {\n             match ty.sty {\n-                Tuple(ref ts) => {\n+                Tuple(..) => {\n                     // Find non representable\n-                    fold_repr(ts.iter().map(|ty| {\n+                    fold_repr(ty.tuple_fields().map(|ty| {\n                         is_type_structurally_recursive(\n                             tcx,\n                             sp,\n                             seen,\n                             representable_cache,\n-                            ty.expect_ty(),\n+                            ty,\n                         )\n                     }))\n                 }\n@@ -1095,7 +1095,7 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n         // state transformation pass\n         ty::Generator(..) => true,\n \n-        ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).any(needs_drop),\n+        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n \n         // unions don't have destructors because of the child types,\n         // only if they manually implement `Drop` (handled above)."}, {"sha": "8c3110792a8b4152b3b64314ee0c78fcaf161dce", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -119,8 +119,8 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::GeneratorWitness(ts) => {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n-        ty::Tuple(ts) => {\n-            stack.extend(ts.iter().map(|k| k.expect_ty()).rev());\n+        ty::Tuple(..) => {\n+            stack.extend(parent_ty.tuple_fields().rev());\n         }\n         ty::FnDef(_, substs) => {\n             stack.extend(substs.types().rev());"}, {"sha": "13ec27aa1ab3f67ccd67b85a50f05210eb581859", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -23,7 +23,7 @@\n \n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::HirIdSet;\n@@ -1862,3 +1862,92 @@ impl EarlyLintPass for IncompleteFeatures {\n             });\n     }\n }\n+\n+declare_lint! {\n+    pub INVALID_VALUE,\n+    Warn,\n+    \"an invalid value is being created (such as a NULL reference)\"\n+}\n+\n+declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n+\n+        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+\n+        /// Return `false` only if we are sure this type does *not*\n+        /// allow zero initialization.\n+        fn ty_maybe_allows_zero_init<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+            use rustc::ty::TyKind::*;\n+            match ty.sty {\n+                // Primitive types that don't like 0 as a value.\n+                Ref(..) | FnPtr(..) | Never => false,\n+                Adt(..) if ty.is_box() => false,\n+                // Recurse for some compound types.\n+                Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    match adt_def.variants.len() {\n+                        0 => false, // Uninhabited enum!\n+                        1 => {\n+                            // Struct, or enum with exactly one variant.\n+                            // Proceed recursively, check all fields.\n+                            let variant = &adt_def.variants[VariantIdx::from_u32(0)];\n+                            variant.fields.iter().all(|field| {\n+                                ty_maybe_allows_zero_init(\n+                                    tcx,\n+                                    field.ty(tcx, substs),\n+                                )\n+                            })\n+                        }\n+                        _ => true, // Conservative fallback for multi-variant enum.\n+                    }\n+                }\n+                Tuple(..) => {\n+                    // Proceed recursively, check all fields.\n+                    ty.tuple_fields().all(|field| ty_maybe_allows_zero_init(tcx, field))\n+                }\n+                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n+                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n+                //        `char`, and any multivariant enum.\n+                // Conservative fallback.\n+                _ => true,\n+            }\n+        }\n+\n+        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n+            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n+                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n+                        cx.match_def_path(def_id, &UININIT_PATH)\n+                    {\n+                        // This conjures an instance of a type out of nothing,\n+                        // using zeroed or uninitialized memory.\n+                        // We are extremely conservative with what we warn about.\n+                        let conjured_ty = cx.tables.expr_ty(expr);\n+\n+                        if !ty_maybe_allows_zero_init(cx.tcx, conjured_ty) {\n+                            cx.struct_span_lint(\n+                                INVALID_VALUE,\n+                                expr.span,\n+                                &format!(\n+                                    \"the type `{}` does not permit {}\",\n+                                    conjured_ty,\n+                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n+                                        \"zero-initialization\"\n+                                    } else {\n+                                        \"being left uninitialized\"\n+                                    }\n+                                ),\n+                            )\n+                            .note(\"this means that this code causes undefined behavior \\\n+                                when executed\")\n+                            .help(\"use `MaybeUninit` instead\")\n+                            .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3a540fdf4b91f80c292478e22f03ccfa80cfba6f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -177,6 +177,7 @@ macro_rules! late_lint_mod_passes {\n             UnreachablePub: UnreachablePub,\n \n             ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+            InvalidValue: InvalidValue,\n         ]);\n     )\n }"}, {"sha": "33447eba7492a03418ac96b55db9e826f6acd9f6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -324,7 +324,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n                 substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().map(|k| k.expect_ty())),\n+        ty::Tuple(..) => builder.tuple_like_shim(dest, src, self_ty.tuple_fields()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }"}, {"sha": "52fd645e38e2248421ecad3ca54f5efde6b6d2bb", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -804,8 +804,8 @@ where\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n-            ty::Tuple(tys) => {\n-                let tys: Vec<_> = tys.iter().map(|k| k.expect_ty()).collect();\n+            ty::Tuple(..) => {\n+                let tys: Vec<_> = ty.tuple_fields().collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n             ty::Adt(def, substs) => {"}, {"sha": "2d9556233d15fb85a557462bbb2ea13a7312e73a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -412,6 +412,7 @@ symbols! {\n         match_beginning_vert,\n         match_default_bindings,\n         may_dangle,\n+        mem,\n         member_constraints,\n         message,\n         meta,\n@@ -695,6 +696,7 @@ symbols! {\n         underscore_imports,\n         underscore_lifetimes,\n         uniform_paths,\n+        uninitialized,\n         universal_impl_trait,\n         unmarked_api,\n         unreachable_code,\n@@ -726,6 +728,7 @@ symbols! {\n         windows,\n         windows_subsystem,\n         Yield,\n+        zeroed,\n     }\n }\n "}, {"sha": "8f9ca8717bda6b1ed77847b7247b3d9c636f2c52", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -0,0 +1,58 @@\n+// ignore-tidy-linelength\n+// This test checks that calling `mem::{uninitialized,zeroed}` with certain types results\n+// in a lint.\n+\n+#![feature(never_type)]\n+#![allow(deprecated)]\n+#![deny(invalid_value)]\n+\n+use std::mem::{self, MaybeUninit};\n+\n+enum Void {}\n+\n+struct Ref(&'static i32);\n+\n+struct Wrap<T> { wrapped: T }\n+\n+#[allow(unused)]\n+fn generic<T: 'static>() {\n+    unsafe {\n+        let _val: &'static T = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static T = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<&'static T> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<&'static T> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: (i32, !) = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: (i32, !) = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Void = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Void = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: &'static i32 = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static i32 = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Ref = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Ref = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: fn() = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: fn() = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<fn()> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<fn()> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Some types that should work just fine.\n+        let _val: Option<&'static i32> = mem::zeroed();\n+        let _val: Option<fn()> = mem::zeroed();\n+        let _val: MaybeUninit<&'static i32> = mem::zeroed();\n+        let _val: bool = mem::zeroed();\n+        let _val: i32 = mem::zeroed();\n+    }\n+}"}, {"sha": "af54b16bd0b242552b7766bfcf41c85561f16fd8", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -0,0 +1,169 @@\n+error: the type `&'static T` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:20:32\n+   |\n+LL |         let _val: &'static T = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/uninitialized-zeroed.rs:7:9\n+   |\n+LL | #![deny(invalid_value)]\n+   |         ^^^^^^^^^^^^^\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static T` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:21:32\n+   |\n+LL |         let _val: &'static T = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:23:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::zeroed();\n+   |                                      ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<&'static T>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:24:38\n+   |\n+LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `!` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:30:23\n+   |\n+LL |         let _val: ! = mem::zeroed();\n+   |                       ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `!` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:31:23\n+   |\n+LL |         let _val: ! = mem::uninitialized();\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:33:30\n+   |\n+LL |         let _val: (i32, !) = mem::zeroed();\n+   |                              ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `(i32, !)` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:34:30\n+   |\n+LL |         let _val: (i32, !) = mem::uninitialized();\n+   |                              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:36:26\n+   |\n+LL |         let _val: Void = mem::zeroed();\n+   |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Void` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:37:26\n+   |\n+LL |         let _val: Void = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:39:34\n+   |\n+LL |         let _val: &'static i32 = mem::zeroed();\n+   |                                  ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `&'static i32` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:40:34\n+   |\n+LL |         let _val: &'static i32 = mem::uninitialized();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:42:25\n+   |\n+LL |         let _val: Ref = mem::zeroed();\n+   |                         ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Ref` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:43:25\n+   |\n+LL |         let _val: Ref = mem::uninitialized();\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `fn()` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:45:26\n+   |\n+LL |         let _val: fn() = mem::zeroed();\n+   |                          ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `fn()` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n+   |\n+LL |         let _val: fn() = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:48:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::zeroed();\n+   |                                ^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: the type `Wrap<fn()>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:49:32\n+   |\n+LL |         let _val: Wrap<fn()> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this means that this code causes undefined behavior when executed\n+   = help: use `MaybeUninit` instead\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "b0d6629561803077c5324c0c2d9d61e553657557", "filename": "src/test/ui/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/061245e2b1a111ed46a60ad3d88fadf4eb48dcc6/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-uninitialized-zeroed.rs?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -4,7 +4,7 @@\n // in a runtime panic.\n \n #![feature(never_type)]\n-#![allow(deprecated)]\n+#![allow(deprecated, invalid_value)]\n \n use std::{mem, panic};\n "}, {"sha": "72da1015d6d918fe1b29170acbf486d30e0c2695", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=061245e2b1a111ed46a60ad3d88fadf4eb48dcc6", "patch": "@@ -1 +1 @@\n-Subproject commit b041511b5fcd386c4ae74a30b60a5081f8717fbe\n+Subproject commit 72da1015d6d918fe1b29170acbf486d30e0c2695"}]}