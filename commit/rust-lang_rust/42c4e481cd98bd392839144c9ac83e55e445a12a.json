{"sha": "42c4e481cd98bd392839144c9ac83e55e445a12a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzRlNDgxY2Q5OGJkMzkyODM5MTQ0YzlhYzgzZTU1ZTQ0NWExMmE=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-03-09T15:49:10Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-03-12T23:38:58Z"}, "message": "Stabilize std::path\n\nThis commit stabilizes essentially all of the new `std::path` API. The\nAPI itself is changed in a couple of ways (which brings it in closer\nalignment with the RFC):\n\n* `.` components are now normalized away, unless they appear at the\n  start of a path. This in turn effects the semantics of e.g. asking for\n  the file name of `foo/` or `foo/.`, both of which yield `Some(\"foo\")`\n  now. This semantics is what the original RFC specified, and is also\n  desirable given early experience rolling out the new API.\n\n* The `parent` function now succeeds if, and only if, the path has at\n  least one non-root/prefix component. This change affects `pop` as\n  well.\n\n* The `Prefix` component now involves a separate `PrefixComponent`\n  struct, to better allow for keeping both parsed and unparsed prefix data.\n\nIn addition, the `old_path` module is now deprecated.\n\nCloses #23264\n\n[breaking-change]", "tree": {"sha": "9b630066fe5ee9a68f31f65f4a09be0f8a47faad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b630066fe5ee9a68f31f65f4a09be0f8a47faad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c4e481cd98bd392839144c9ac83e55e445a12a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c4e481cd98bd392839144c9ac83e55e445a12a", "html_url": "https://github.com/rust-lang/rust/commit/42c4e481cd98bd392839144c9ac83e55e445a12a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c4e481cd98bd392839144c9ac83e55e445a12a/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f899513a30165946a75ff7f515ab37a226e72172", "url": "https://api.github.com/repos/rust-lang/rust/commits/f899513a30165946a75ff7f515ab37a226e72172", "html_url": "https://github.com/rust-lang/rust/commit/f899513a30165946a75ff7f515ab37a226e72172"}], "stats": {"total": 722, "additions": 405, "deletions": 317}, "files": [{"sha": "a2bb3defe31071eeb057eb159e1238eb543823dc", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -20,7 +20,6 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(core)]\n-#![feature(path)]\n #![feature(io)]\n #![feature(net)]\n #![feature(path_ext)]"}, {"sha": "56e37ca1093155175a1dcbc135ad0d74654f3307", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)] // for old path, for dynamic_lib\n+\n use std::process::{ExitStatus, Command, Child, Output, Stdio};\n use std::io::prelude::*;\n use std::dynamic_lib::DynamicLibrary;"}, {"sha": "444b050952fa4c6707fcc01f4ebedadbdb71952f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -40,7 +40,6 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(path)]\n #![feature(io)]\n #![feature(path_ext)]\n #![feature(str_words)]"}, {"sha": "6fd74479f759654c12e1d78211606cd568082864", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -18,7 +18,10 @@ use std::borrow::ToOwned;\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::mem;\n+\n+#[allow(deprecated)]\n use std::old_path;\n+\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n@@ -100,6 +103,7 @@ impl<'a> PluginLoader<'a> {\n     }\n \n     // Dynamically link a registrar function into the compiler process.\n+    #[allow(deprecated)] // until #23197\n     fn dylink_registrar(&mut self,\n                         span: Span,\n                         path: PathBuf,"}, {"sha": "20335bc8c09a95bd5b960dffae5a6b3eb043210d", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -11,6 +11,7 @@\n use std::io;\n use std::old_io::fs;\n use std::old_io;\n+#[allow(deprecated)]\n use std::old_path;\n use std::os;\n use std::path::{Path, PathBuf};"}, {"sha": "77338dddefa049e0ce3c92aca784752de06ff7d8", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -42,11 +42,12 @@\n #![feature(old_io)]\n #![feature(old_path)]\n #![feature(os)]\n-#![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n #![feature(path_ext)]\n+#![feature(std_misc)]\n+#![feature(path_relative_from)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "38a8feff7c6f08b965632013cbdc41a81e9adecb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -37,7 +37,6 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(exit_status)]\n-#![feature(path)]\n #![feature(io)]\n \n extern crate arena;"}, {"sha": "71233ff5003933844898b8e860b380662b28e459", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -31,7 +31,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n-#![feature(path)]\n #![cfg_attr(unix, feature(std_misc))]\n \n extern crate libc;"}, {"sha": "66dd49f241fbe7224a368c2f70a104cd83bf8978", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -39,10 +39,10 @@\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(io)]\n-#![feature(path)]\n #![feature(path_ext)]\n #![feature(fs)]\n #![feature(hash)]\n+#![feature(path_relative_from)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "246004751c58e6b25d57992be9a363a06695a752", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -37,9 +37,9 @@\n #![feature(unicode)]\n #![feature(str_words)]\n #![feature(io)]\n-#![feature(path)]\n #![feature(file_path)]\n #![feature(path_ext)]\n+#![feature(path_relative_from)]\n \n extern crate arena;\n extern crate getopts;\n@@ -362,6 +362,7 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n+#[allow(deprecated)] // for old Path in plugin manager\n fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");"}, {"sha": "3db0162969f46b04a5a45f7e8f92d95182b11bea", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)] // old path, used for compatibility with dynamic lib\n+\n use clean;\n \n use std::dynamic_lib as dl;"}, {"sha": "8d58ba99e13138268c3176989fc883a386eda668", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -37,7 +37,6 @@ Core encoding and decoding interfaces.\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n-#![feature(path)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "77e2da7ec79139332a256923f5e8a476bcafa6ae", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+#[allow(deprecated)]\n use std::old_path;\n use std::path;\n use std::rc::Rc;\n@@ -539,25 +540,29 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n+#[allow(deprecated)]\n impl Encodable for old_path::posix::Path {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n+#[allow(deprecated)]\n impl Decodable for old_path::posix::Path {\n     fn decode<D: Decoder>(d: &mut D) -> Result<old_path::posix::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(old_path::posix::Path::new(bytes))\n     }\n }\n \n+#[allow(deprecated)]\n impl Encodable for old_path::windows::Path {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n+#[allow(deprecated)]\n impl Decodable for old_path::windows::Path {\n     fn decode<D: Decoder>(d: &mut D) -> Result<old_path::windows::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));"}, {"sha": "90373441edcad0e2ccfdf986773a5c6f45ef230e", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -14,6 +14,7 @@\n \n #![unstable(feature = \"std_misc\")]\n #![allow(missing_docs)]\n+#![allow(deprecated)] // will be addressed by #23197\n \n use prelude::v1::*;\n "}, {"sha": "c90ddb3096a2f33dc3e9fadeb4112bbcd340a021", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -18,6 +18,7 @@\n \n use prelude::v1::*;\n \n+use iter::IntoIterator;\n use error::Error;\n use ffi::{OsString, AsOsStr};\n use fmt;\n@@ -338,9 +339,9 @@ pub struct JoinPathsError {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsOsStr\n+    where I: IntoIterator<Item=T>, T: AsOsStr\n {\n-    os_imp::join_paths(paths).map_err(|e| {\n+    os_imp::join_paths(paths.into_iter()).map_err(|e| {\n         JoinPathsError { inner: e }\n     })\n }"}, {"sha": "feacbf1e98b81e9fe0e3a9cec8b1975a606041fd", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -346,6 +346,7 @@ impl AsOsStr for String {\n     }\n }\n \n+#[allow(deprecated)]\n impl AsOsStr for Path {\n     #[cfg(unix)]\n     fn as_os_str(&self) -> &OsStr {"}, {"sha": "d8ee62ac239d02659510b2b56e9db96360feef93", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -571,18 +571,8 @@ pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n     let path = path.as_path();\n     if path.is_dir() { return Ok(()) }\n-    match path.parent() {\n-        Some(p) if p != path => try!(create_dir_all(p)),\n-        _ => {}\n-    }\n-    // If the file name of the given `path` is blank then the creation of the\n-    // parent directory will have taken care of the whole path for us, so we're\n-    // good to go.\n-    if path.file_name().is_none() {\n-        Ok(())\n-    } else {\n-        create_dir(path)\n-    }\n+    if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n+    create_dir(path)\n }\n \n /// Remove an existing, empty directory"}, {"sha": "8dabde38642fb68f89f5307752750add9c2dd825", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -60,6 +60,7 @@\n //! ```\n \n #![unstable(feature = \"old_path\")]\n+#![deprecated(since = \"1.0.0\", reason = \"use std::path instead\")]\n #![allow(deprecated)] // seriously this is all deprecated\n #![allow(unused_imports)]\n "}, {"sha": "7eafc083978324c699f81517f3cdbccce75421de", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -29,6 +29,7 @@\n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n #![allow(unused_imports)]\n+#![allow(deprecated)]\n \n use self::MemoryMapKind::*;\n use self::MapOption::*;"}, {"sha": "a6dcd03978ad9345b0ca14dbfbd3af4fd2b5bdc6", "filename": "src/libstd/path.rs", "status": "modified", "additions": 354, "deletions": 273, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -17,7 +17,7 @@\n //!\n //! ## Simple usage\n //!\n-//! Path manipulation involves both parsing components from slices and building\n+//! Path manipulation includes both parsing components from slices and building\n //! new owned paths.\n //!\n //! To parse a path, you can create a `Path` slice from a `str`\n@@ -50,9 +50,9 @@\n //! `\\`). The APIs for path parsing are largely specified in terms of the path's\n //! components, so it's important to clearly understand how those are determined.\n //!\n-//! A path can always be reconstructed into an equivalent path by putting\n-//! together its components via `push`. Syntactically, the paths may differ by\n-//! the normalization described below.\n+//! A path can always be reconstructed into an *equivalent* path by\n+//! putting together its components via `push`. Syntactically, the\n+//! paths may differ by the normalization described below.\n //!\n //! ### Component types\n //!\n@@ -62,26 +62,20 @@\n //! directories. The path `a/b` has two normal components, `a` and `b`.\n //!\n //! * Current directory components represent the `.` character. For example,\n-//! `a/.` has a normal component `a` and a current directory component.\n+//! `./a` has a current directory component and a normal component `a`.\n //!\n //! * The root directory component represents a separator that designates\n //!   starting from root. For example, `/a/b` has a root directory component\n //!   followed by normal components `a` and `b`.\n //!\n-//! On Windows, two additional component types come into play:\n+//! On Windows, an additional component type comes into play:\n //!\n //! * Prefix components, of which there is a large variety. For example, `C:`\n //! and `\\\\server\\share` are prefixes. The path `C:windows` has a prefix\n //! component `C:` and a normal component `windows`; the path `C:\\windows` has a\n //! prefix component `C:`, a root directory component, and a normal component\n //! `windows`.\n //!\n-//! * Empty components, a special case for so-called \"verbatim\" paths where very\n-//! little normalization is allowed. For example, `\\\\?\\C:\\` has a \"verbatim\"\n-//! prefix `\\\\?\\C:`, a root component, and an empty component (as a way of\n-//! representing the trailing `\\`. Such a trailing `\\` is in fact the only\n-//! situation in which an empty component is produced.\n-//!\n //! ### Normalization\n //!\n //! Aside from splitting on the separator(s), there is a small amount of\n@@ -90,20 +84,19 @@\n //! * Repeated separators are ignored: `a/b` and `a//b` both have components `a`\n //!   and `b`.\n //!\n-//! * Paths ending in a separator are treated as if they have a current directory\n-//!   component at the end (or, in verbatim paths, an empty component).  For\n-//!   example, while `a/b` has components `a` and `b`, the paths `a/b/` and\n-//!   `a/b/.` both have components `a`, `b`, and `.` (current directory).  The\n-//!   reason for this normalization is that `a/b` and `a/b/` are treated\n-//!   differently in some contexts, but `a/b/` and `a/b/.` are always treated\n-//!   the same.\n+//! * Occurrences of `.` are normalized away, *except* if they are at\n+//! the beginning of the path (in which case they are often meaningful\n+//! in terms of path searching). So, fore xample, `a/./b`, `a/b/`,\n+//! `/a/b/.` and `a/b` all ahve components `a` and `b`, but `./a/b`\n+//! has a leading current directory component.\n //!\n-//! No other normalization takes place by default. In particular, `a/./b/` and\n-//! `a/b` are treated distinctly in terms of components, as are `a/c` and\n-//! `a/b/../c`. Further normalization is possible to build on top of the\n-//! components APIs, and will be included in this library very soon.\n+//! No other normalization takes place by default. In particular,\n+//! `a/c` and `a/b/../c` are distinct, to account for the possibility\n+//! that `b` is a symbolic link (so its parent isn't `a`). Further\n+//! normalization is possible to build on top of the components APIs,\n+//! and will be included in this library in the near future.\n \n-#![unstable(feature = \"path\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -270,23 +263,30 @@ mod platform {\n /// `/` is *not* treated as a separator and essentially no normalization is\n /// performed.\n #[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Prefix<'a> {\n     /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Verbatim(&'a OsStr),\n \n     /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimUNC(&'a OsStr, &'a OsStr),\n \n     /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     VerbatimDisk(u8),\n \n     /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     DeviceNS(&'a OsStr),\n \n     /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     UNC(&'a OsStr, &'a OsStr),\n \n     /// Prefix `C:` for the given disk drive.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disk(u8),\n }\n \n@@ -314,6 +314,7 @@ impl<'a> Prefix<'a> {\n \n     /// Determine if the prefix is verbatim, i.e. begins `\\\\?\\`.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_verbatim(&self) -> bool {\n         use self::Prefix::*;\n         match *self {\n@@ -342,12 +343,14 @@ impl<'a> Prefix<'a> {\n \n /// Determine whether the character is one of the permitted path\n /// separators for the current platform.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn is_separator(c: char) -> bool {\n     use ascii::*;\n     c.is_ascii() && is_sep_byte(c as u8)\n }\n \n /// The primary sperator for the current platform\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -383,37 +386,15 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Cross-platform parsing\n+// Cross-platform, iterator-independent parsing\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Says whether the path ends in a separator character and therefore needs to\n-/// be treated as if it ended with an additional `.`\n-fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n-    let (prefix_len, verbatim) = if let Some(p) = prefix {\n-        (p.len(), p.is_verbatim())\n-    } else { (0, false) };\n-    if prefix_len > 0 && prefix_len == s.len() && !verbatim { return true; }\n-    let mut splits = s[prefix_len..].split(|b| is_sep_byte(*b));\n-    let last = splits.next_back().unwrap();\n-    let more = splits.next_back().is_some();\n-    more && last == b\"\"\n-}\n-\n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n     let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n     path.len() > 0 && is_sep_byte(path[0])\n }\n \n-fn parse_single_component(comp: &[u8]) -> Option<Component> {\n-    match comp {\n-        b\".\" => Some(Component::CurDir),\n-        b\"..\" => Some(Component::ParentDir),\n-        b\"\" => None,\n-        _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) }))\n-    }\n-}\n-\n // basic workhorse for splitting stem and extension\n #[allow(unused_unsafe)] // FIXME\n fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n@@ -445,59 +426,100 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n /// front and back of the path each keep track of what parts of the path have\n /// been consumed so far.\n ///\n-/// Going front to back, a path is made up of a prefix, a root component, a body\n-/// (of normal components), and a suffix/emptycomponent (normalized `.` or ``\n-/// for a path ending with the separator)\n+/// Going front to back, a path is made up of a prefix, a starting\n+/// directory component, and a body (of normal components)\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n enum State {\n     Prefix = 0,         // c:\n-    Root = 1,           // /\n+    StartDir = 1,       // / or . or nothing\n     Body = 2,           // foo/bar/baz\n-    Suffix = 3,         // .\n-    Done = 4,\n+    Done = 3,\n+}\n+\n+/// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n+///\n+/// Does not occur on Unix.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Copy, Clone, Eq, Hash, Debug)]\n+pub struct PrefixComponent<'a> {\n+    /// The prefix as an unparsed `OsStr` slice.\n+    raw: &'a OsStr,\n+\n+    /// The parsed prefix data.\n+    parsed: Prefix<'a>,\n+}\n+\n+impl<'a> PrefixComponent<'a> {\n+    /// The parsed prefix data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn kind(&self) -> Prefix<'a> {\n+        self.parsed\n+    }\n+\n+    /// The raw `OsStr` slice for this prefix.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_os_str(&self) -> &'a OsStr {\n+        self.raw\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> cmp::PartialEq for PrefixComponent<'a> {\n+    fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n+        cmp::PartialEq::eq(&self.parsed, &other.parsed)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n+    fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n+        cmp::PartialOrd::partial_cmp(&self.parsed, &other.parsed)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> cmp::Ord for PrefixComponent<'a> {\n+    fn cmp(&self, other: &PrefixComponent<'a>) -> cmp::Ordering {\n+        cmp::Ord::cmp(&self.parsed, &other.parsed)\n+    }\n }\n \n /// A single component of a path.\n ///\n /// See the module documentation for an in-depth explanation of components and\n /// their role in the API.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n     /// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n     ///\n     /// Does not occur on Unix.\n-    Prefix {\n-        /// The prefix as an unparsed `OsStr` slice.\n-        raw: &'a OsStr,\n-\n-        /// The parsed prefix data.\n-        parsed: Prefix<'a>\n-    },\n-\n-    /// An empty component. Only used on Windows for the last component of\n-    /// verbatim paths ending with a separator (e.g. the last component of\n-    /// `\\\\?\\C:\\windows\\` but not `\\\\?\\C:\\windows` or `C:\\windows`).\n-    Empty,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Prefix(PrefixComponent<'a>),\n \n     /// The root directory component, appears after any prefix and before anything else\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     RootDir,\n \n     /// A reference to the current directory, i.e. `.`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     CurDir,\n \n     /// A reference to the parent directory, i.e. `..`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     ParentDir,\n \n     /// A normal component, i.e. `a` and `b` in `a/b`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal(&'a OsStr),\n }\n \n impl<'a> Component<'a> {\n     /// Extract the underlying `OsStr` slice\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n-            Component::Prefix { raw, .. } => &raw,\n-            Component::Empty => OsStr::from_str(\"\"),\n+            Component::Prefix(p) => p.as_os_str(),\n             Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n             Component::CurDir => OsStr::from_str(\".\"),\n             Component::ParentDir => OsStr::from_str(\"..\"),\n@@ -511,6 +533,7 @@ impl<'a> Component<'a> {\n /// See the module documentation for an in-depth explanation of components and\n /// their role in the API.\n #[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n     // The path left to parse components from\n     path: &'a [u8],\n@@ -531,6 +554,7 @@ pub struct Components<'a> {\n \n /// An iterator over the components of a path, as `OsStr` slices.\n #[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n     inner: Components<'a>\n }\n@@ -554,9 +578,12 @@ impl<'a> Components<'a> {\n         else { 0 }\n     }\n \n-    fn prefix_and_root(&self) -> usize {\n-        let root = if self.front <= State::Root && self.has_physical_root { 1 } else { 0 };\n-        self.prefix_remaining() + root\n+    // Given the iteration so far, how much of the pre-State::Body path is left?\n+    #[inline]\n+    fn len_before_body(&self) -> usize {\n+        let root = if self.front <= State::StartDir && self.has_physical_root { 1 } else { 0 };\n+        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() { 1 } else { 0 };\n+        self.prefix_remaining() + root + cur_dir\n     }\n \n     // is the iteration complete?\n@@ -579,11 +606,7 @@ impl<'a> Components<'a> {\n         let mut comps = self.clone();\n         if comps.front == State::Body { comps.trim_left(); }\n         if comps.back == State::Body { comps.trim_right(); }\n-        if comps.path.is_empty() && comps.front < comps.back && comps.back == State::Suffix {\n-            Path::new(\".\")\n-        } else {\n-            unsafe { Path::from_u8_slice(comps.path) }\n-        }\n+        unsafe { Path::from_u8_slice(comps.path) }\n     }\n \n     /// Is the *original* path rooted?\n@@ -595,6 +618,30 @@ impl<'a> Components<'a> {\n         false\n     }\n \n+    /// Should the normalized path include a leading . ?\n+    fn include_cur_dir(&self) -> bool {\n+        if self.has_root() { return false }\n+        let mut iter = self.path[self.prefix_len()..].iter();\n+        match (iter.next(), iter.next()) {\n+            (Some(&b'.'), None) => true,\n+            (Some(&b'.'), Some(&b)) => self.is_sep_byte(b),\n+            _ => false\n+        }\n+    }\n+\n+    // parse a given byte sequence into the corresponding path component\n+    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n+        match comp {\n+            b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n+            b\".\" => None, // . components are normalized away, except at\n+                          // the beginning of a path, which is treated\n+                          // separately via `include_cur_dir`\n+            b\"..\" => Some(Component::ParentDir),\n+            b\"\" => None,\n+            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) }))\n+        }\n+    }\n+\n     // parse a component from the left, saying how many bytes to consume to\n     // remove the component\n     fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n@@ -603,19 +650,19 @@ impl<'a> Components<'a> {\n             None => (0, self.path),\n             Some(i) => (1, &self.path[.. i]),\n         };\n-        (comp.len() + extra, parse_single_component(comp))\n+        (comp.len() + extra, self.parse_single_component(comp))\n     }\n \n     // parse a component from the right, saying how many bytes to consume to\n     // remove the component\n     fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n         debug_assert!(self.back == State::Body);\n-        let start = self.prefix_and_root();\n+        let start = self.len_before_body();\n         let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep_byte(*b)) {\n             None => (0, &self.path[start ..]),\n             Some(i) => (1, &self.path[start + i + 1 ..]),\n         };\n-        (comp.len() + extra, parse_single_component(comp))\n+        (comp.len() + extra, self.parse_single_component(comp))\n     }\n \n     // trim away repeated separators (i.e. emtpy components) on the left\n@@ -632,7 +679,7 @@ impl<'a> Components<'a> {\n \n     // trim away repeated separators (i.e. emtpy components) on the right\n     fn trim_right(&mut self) {\n-        while self.path.len() > self.prefix_and_root() {\n+        while self.path.len() > self.len_before_body() {\n             let (size, comp) = self.parse_next_component_back();\n             if comp.is_some() {\n                 return;\n@@ -643,18 +690,21 @@ impl<'a> Components<'a> {\n     }\n \n     /// Examine the next component without consuming it.\n+    #[unstable(feature = \"path_components_peek\")]\n     pub fn peek(&self) -> Option<Component<'a>> {\n         self.clone().next()\n     }\n }\n \n impl<'a> Iter<'a> {\n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         self.inner.as_path()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = &'a OsStr;\n \n@@ -663,32 +713,34 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n     fn next_back(&mut self) -> Option<&'a OsStr> {\n         self.inner.next_back().map(Component::as_os_str)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Components<'a> {\n     type Item = Component<'a>;\n \n     fn next(&mut self) -> Option<Component<'a>> {\n         while !self.finished() {\n             match self.front {\n                 State::Prefix if self.prefix_len() > 0 => {\n-                    self.front = State::Root;\n+                    self.front = State::StartDir;\n                     debug_assert!(self.prefix_len() <= self.path.len());\n                     let raw = &self.path[.. self.prefix_len()];\n                     self.path = &self.path[self.prefix_len() .. ];\n-                    return Some(Component::Prefix {\n+                    return Some(Component::Prefix(PrefixComponent {\n                         raw: unsafe { u8_slice_as_os_str(raw) },\n                         parsed: self.prefix.unwrap()\n-                    })\n+                    }))\n                 }\n                 State::Prefix => {\n-                    self.front = State::Root;\n+                    self.front = State::StartDir;\n                 }\n-                State::Root => {\n+                State::StartDir => {\n                     self.front = State::Body;\n                     if self.has_physical_root {\n                         debug_assert!(self.path.len() > 0);\n@@ -698,6 +750,10 @@ impl<'a> Iterator for Components<'a> {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n                             return Some(Component::RootDir)\n                         }\n+                    } else if self.include_cur_dir() {\n+                        debug_assert!(self.path.len() > 0);\n+                        self.path = &self.path[1..];\n+                        return Some(Component::CurDir)\n                     }\n                 }\n                 State::Body if !self.path.is_empty() => {\n@@ -706,15 +762,7 @@ impl<'a> Iterator for Components<'a> {\n                     if comp.is_some() { return comp }\n                 }\n                 State::Body => {\n-                    self.front = State::Suffix;\n-                }\n-                State::Suffix => {\n                     self.front = State::Done;\n-                    if self.prefix_verbatim() {\n-                        return Some(Component::Empty)\n-                    } else {\n-                        return Some(Component::CurDir)\n-                    }\n                 }\n                 State::Done => unreachable!()\n             }\n@@ -723,27 +771,20 @@ impl<'a> Iterator for Components<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Components<'a> {\n     fn next_back(&mut self) -> Option<Component<'a>> {\n         while !self.finished() {\n             match self.back {\n-                State::Suffix => {\n-                    self.back = State::Body;\n-                    if self.prefix_verbatim() {\n-                        return Some(Component::Empty)\n-                    } else {\n-                        return Some(Component::CurDir)\n-                    }\n-                }\n-                State::Body if self.path.len() > self.prefix_and_root() => {\n+                State::Body if self.path.len() > self.len_before_body() => {\n                     let (size, comp) = self.parse_next_component_back();\n                     self.path = &self.path[.. self.path.len() - size];\n                     if comp.is_some() { return comp }\n                 }\n                 State::Body => {\n-                    self.back = State::Root;\n+                    self.back = State::StartDir;\n                 }\n-                State::Root => {\n+                State::StartDir => {\n                     self.back = State::Prefix;\n                     if self.has_physical_root {\n                         self.path = &self.path[.. self.path.len() - 1];\n@@ -752,14 +793,17 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n                             return Some(Component::RootDir)\n                         }\n+                    } else if self.include_cur_dir() {\n+                        self.path = &self.path[.. self.path.len() - 1];\n+                        return Some(Component::CurDir)\n                     }\n                 }\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n-                    return Some(Component::Prefix {\n+                    return Some(Component::Prefix(PrefixComponent {\n                         raw: unsafe { u8_slice_as_os_str(self.path) },\n                         parsed: self.prefix.unwrap()\n-                    })\n+                    }))\n                 }\n                 State::Prefix => {\n                     self.back = State::Done;\n@@ -772,24 +816,24 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n     }\n }\n \n-fn optional_path(path: &Path) -> Option<&Path> {\n-    if path.as_u8_slice().is_empty() { None } else { Some(path) }\n-}\n-\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for Components<'a> {\n     fn eq(&self, other: &Components<'a>) -> bool {\n         iter::order::eq(self.clone(), other.clone())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::Eq for Components<'a> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for Components<'a> {\n     fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n         iter::order::partial_cmp(self.clone(), other.clone())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::Ord for Components<'a> {\n     fn cmp(&self, other: &Components<'a>) -> cmp::Ordering {\n         iter::order::cmp(self.clone(), other.clone())\n@@ -820,6 +864,7 @@ impl<'a> cmp::Ord for Components<'a> {\n /// path.set_extension(\"dll\");\n /// ```\n #[derive(Clone, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PathBuf {\n     inner: OsString\n }\n@@ -831,6 +876,7 @@ impl PathBuf {\n \n     /// Allocate a `PathBuf` with initial contents given by the\n     /// argument.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: ?Sized + AsOsStr>(s: &S) -> PathBuf {\n         PathBuf { inner: s.as_os_str().to_os_string() }\n     }\n@@ -844,7 +890,10 @@ impl PathBuf {\n     /// * if `path` has a root but no prefix (e.g. `\\windows`), it\n     ///   replaces everything except for the prefix (if any) of `self`.\n     /// * if `path` has a prefix but no root, it replaces `self.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n+        let path = path.as_path();\n+\n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n \n@@ -859,8 +908,6 @@ impl PathBuf {\n             }\n         }\n \n-        let path = path.as_path();\n-\n         // absolute `path` replaces `self`\n         if path.is_absolute() || path.prefix().is_some() {\n             self.as_mut_vec().truncate(0);\n@@ -880,8 +927,9 @@ impl PathBuf {\n \n     /// Truncate `self` to `self.parent()`.\n     ///\n-    /// Returns `false` and does nothing if `self.parent()` is `None`.\n+    /// Returns false and does nothing if `self.file_name()` is `None`.\n     /// Otherwise, returns `true`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> bool {\n         match self.parent().map(|p| p.as_u8_slice().len()) {\n             Some(len) => {\n@@ -900,23 +948,21 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::path::{Path, PathBuf};\n+    /// use std::path::PathBuf;\n     ///\n-    /// let mut buf = PathBuf::new(\"/foo/\");\n+    /// let mut buf = PathBuf::new(\"/\");\n     /// assert!(buf.file_name() == None);\n     /// buf.set_file_name(\"bar\");\n-    /// assert!(buf == PathBuf::new(\"/foo/bar\"));\n+    /// assert!(buf == PathBuf::new(\"/bar\"));\n     /// assert!(buf.file_name().is_some());\n     /// buf.set_file_name(\"baz.txt\");\n-    /// assert!(buf == PathBuf::new(\"/foo/baz.txt\"));\n+    /// assert!(buf == PathBuf::new(\"/baz.txt\"));\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_file_name<S: ?Sized>(&mut self, file_name: &S) where S: AsOsStr {\n-        if self.file_name().is_some() && !self.pop() {\n-            // Given that there is a file name, this is reachable only for\n-            // Windows paths like c:file or paths like `foo`, but not `c:\\` or\n-            // `/`.\n-            let prefix_len = self.components().prefix_remaining();\n-            self.as_mut_vec().truncate(prefix_len);\n+        if self.file_name().is_some() {\n+            let popped = self.pop();\n+            debug_assert!(popped);\n         }\n         self.push(file_name.as_os_str());\n     }\n@@ -927,6 +973,7 @@ impl PathBuf {\n     ///\n     /// Otherwise, returns `true`; if `self.extension()` is `None`, the extension\n     /// is added; otherwise it is replaced.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool {\n         if self.file_name().is_none() { return false; }\n \n@@ -946,11 +993,13 @@ impl PathBuf {\n     }\n \n     /// Consume the `PathBuf`, yielding its internal `OsString` storage\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_os_string(self) -> OsString {\n         self.inner\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n     fn from_iter<I: IntoIterator<Item = &'a P>>(iter: I) -> PathBuf {\n         let mut buf = PathBuf::new(\"\");\n@@ -959,6 +1008,7 @@ impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n     fn extend<I: IntoIterator<Item = &'a P>>(&mut self, iter: I) {\n         for p in iter {\n@@ -967,12 +1017,14 @@ impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for PathBuf {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         fmt::Debug::fmt(&**self, formatter)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for PathBuf {\n     type Target = Path;\n \n@@ -981,49 +1033,58 @@ impl ops::Deref for PathBuf {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<Path> for PathBuf {\n     fn borrow(&self) -> &Path {\n         self.deref()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl IntoCow<'static, Path> for PathBuf {\n     fn into_cow(self) -> Cow<'static, Path> {\n         Cow::Owned(self)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> IntoCow<'a, Path> for &'a Path {\n     fn into_cow(self) -> Cow<'a, Path> {\n         Cow::Borrowed(self)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for Path {\n     type Owned = PathBuf;\n     fn to_owned(&self) -> PathBuf { self.to_path_buf() }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for PathBuf {\n     fn eq(&self, other: &PathBuf) -> bool {\n         self.components() == other.components()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for PathBuf {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for PathBuf {\n     fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(&other.components())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PathBuf {\n     fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n         self.components().cmp(&other.components())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsOsStr for PathBuf {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner[..]\n@@ -1053,6 +1114,7 @@ impl AsOsStr for PathBuf {\n /// ```\n ///\n #[derive(Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Path {\n     inner: OsStr\n }\n@@ -1071,25 +1133,29 @@ impl Path {\n     /// Directly wrap a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path {\n         unsafe { mem::transmute(s.as_os_str()) }\n     }\n \n     /// Yield a `&str` slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n \n     /// Convert a `Path` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n \n     /// Convert a `Path` to an owned `PathBuf`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n         PathBuf::new(self)\n     }\n@@ -1102,12 +1168,14 @@ impl Path {\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n     /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_absolute(&self) -> bool {\n         self.has_root() &&\n             (cfg!(unix) || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n     }\n@@ -1117,12 +1185,9 @@ impl Path {\n     /// Prefixes are relevant only for Windows paths, and consist of volumes\n     /// like `C:`, UNC prefixes like `\\\\server`, and others described in more\n     /// detail in `std::os::windows::PathExt`.\n-    pub fn prefix(&self) -> Option<&Path> {\n-        let iter = self.components();\n-        optional_path(unsafe {\n-            Path::from_u8_slice(\n-                &self.as_u8_slice()[.. iter.prefix_remaining()])\n-        })\n+    #[unstable(feature = \"path_prefix\", reason = \"uncertain whether to expose this convenience\")]\n+    pub fn prefix(&self) -> Option<Prefix> {\n+        self.components().prefix\n     }\n \n     /// A path has a root if the body of the path begins with the directory separator.\n@@ -1133,14 +1198,14 @@ impl Path {\n     ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n     ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n     ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn has_root(&self) -> bool {\n          self.components().has_root()\n     }\n \n-    /// The path without its final component.\n+    /// The path without its final component, if any.\n     ///\n-    /// Does nothing, returning `None` if the path consists of just a prefix\n-    /// and/or root directory reference.\n+    /// Returns `None` if the path terminates in a root or prefix.\n     ///\n     /// # Examples\n     ///\n@@ -1154,26 +1219,23 @@ impl Path {\n     /// assert!(root == Path::new(\"/\"));\n     /// assert!(root.parent() == None);\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn parent(&self) -> Option<&Path> {\n         let mut comps = self.components();\n         let comp = comps.next_back();\n-        let rest = optional_path(comps.as_path());\n-\n-        match (comp, comps.next_back()) {\n-            (Some(Component::CurDir), Some(Component::RootDir)) => None,\n-            (Some(Component::CurDir), Some(Component::Prefix { .. })) => None,\n-            (Some(Component::Empty), Some(Component::RootDir)) => None,\n-            (Some(Component::Empty), Some(Component::Prefix { .. })) => None,\n-            (Some(Component::Prefix { .. }), None) => None,\n-            (Some(Component::RootDir), Some(Component::Prefix { .. })) => None,\n-            _ => rest\n-        }\n+        comp.and_then(|p| match p {\n+            Component::Normal(_) |\n+            Component::CurDir |\n+            Component::ParentDir => Some(comps.as_path()),\n+            _ => None\n+        })\n     }\n \n     /// The final component of the path, if it is a normal file.\n     ///\n     /// If the path terminates in `.`, `..`, or consists solely or a root of\n-    /// prefix, `file` will return `None`.\n+    /// prefix, `file_name` will return `None`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n             Component::Normal(p) => Some(p.as_os_str()),\n@@ -1182,18 +1244,21 @@ impl Path {\n     }\n \n     /// Returns a path that, when joined onto `base`, yields `self`.\n+    #[unstable(feature = \"path_relative_from\", reason = \"see #23284\")]\n     pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where\n         P: AsPath\n     {\n         iter_after(self.components(), base.as_path().components()).map(|c| c.as_path())\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: ?Sized>(&self, base: &P) -> bool where P: AsPath {\n         iter_after(self.components(), base.as_path().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ends_with<P: ?Sized>(&self, child: &P) -> bool where P: AsPath {\n         iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n     }\n@@ -1206,6 +1271,7 @@ impl Path {\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_stem(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n     }\n@@ -1218,13 +1284,15 @@ impl Path {\n     /// * None, if there is no embedded `.`;\n     /// * None, if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn extension(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n     }\n \n     /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join<P: ?Sized>(&self, path: &P) -> PathBuf where P: AsPath {\n         let mut buf = self.to_path_buf();\n         buf.push(path);\n@@ -1234,6 +1302,7 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given file name.\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_file_name<S: ?Sized>(&self, file_name: &S) -> PathBuf where S: AsOsStr {\n         let mut buf = self.to_path_buf();\n         buf.set_file_name(file_name);\n@@ -1243,92 +1312,107 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given extension.\n     ///\n     /// See `PathBuf::set_extension` for more details.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: ?Sized>(&self, extension: &S) -> PathBuf where S: AsOsStr {\n         let mut buf = self.to_path_buf();\n         buf.set_extension(extension);\n         buf\n     }\n \n     /// Produce an iterator over the components of the path.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n         Components {\n             path: self.as_u8_slice(),\n             prefix: prefix,\n             has_physical_root: has_physical_root(self.as_u8_slice(), prefix),\n             front: State::Prefix,\n-            back: if has_suffix(self.as_u8_slice(), prefix) { State::Suffix }\n-                  else { State::Body },\n+            back: State::Body,\n         }\n     }\n \n     /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { inner: self.components() }\n     }\n \n     /// Returns an object that implements `Display` for safely printing paths\n     /// that may contain non-Unicode data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn display(&self) -> Display {\n         Display { path: self }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsOsStr for Path {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         self.inner.fmt(formatter)\n     }\n }\n \n /// Helper struct for safely printing paths with `format!()` and `{}`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Display<'a> {\n     path: &'a Path\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> fmt::Debug for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.path.to_string_lossy(), f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> fmt::Display for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.path.to_string_lossy(), f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Path {\n     fn eq(&self, other: &Path) -> bool {\n         iter::order::eq(self.components(), other.components())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for Path {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for Path {\n     fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n         self.components().partial_cmp(&other.components())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Path {\n     fn cmp(&self, other: &Path) -> cmp::Ordering {\n         self.components().cmp(&other.components())\n     }\n }\n \n /// Freely convertible to a `Path`.\n+#[unstable(feature = \"std_misc\")]\n pub trait AsPath {\n     /// Convert to a `Path`.\n+    #[unstable(feature = \"std_misc\")]\n     fn as_path(&self) -> &Path;\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl<T: AsOsStr + ?Sized> AsPath for T {\n     fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n }\n@@ -1460,14 +1544,14 @@ mod tests {\n            iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: None,\n+           parent: Some(\"\"),\n            file_name: Some(\"foo\"),\n            file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"/\",\n-           iter: [\"/\", \".\"],\n+           iter: [\"/\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -1487,22 +1571,22 @@ mod tests {\n            );\n \n         t!(\"foo/\",\n-           iter: [\"foo\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"/foo/\",\n-           iter: [\"/\", \"foo\", \".\"],\n+           iter: [\"/\", \"foo\"],\n            has_root: true,\n            is_absolute: true,\n-           parent: Some(\"/foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1527,12 +1611,12 @@ mod tests {\n            );\n \n         t!(\"///foo///\",\n-           iter: [\"/\", \"foo\", \".\"],\n+           iter: [\"/\", \"foo\"],\n            has_root: true,\n            is_absolute: true,\n-           parent: Some(\"///foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1547,20 +1631,10 @@ mod tests {\n            );\n \n         t!(\"./.\",\n-           iter: [\".\", \".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n-        t!(\"./.\",\n-           iter: [\".\", \".\"],\n+           iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\".\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -1577,22 +1651,22 @@ mod tests {\n            );\n \n         t!(\"../\",\n-           iter: [\"..\", \".\"],\n+           iter: [\"..\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"..\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n            );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1607,30 +1681,30 @@ mod tests {\n            );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\", \".\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/.\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \".\", \"bar\"],\n+           iter: [\"foo\", \"bar\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/.\"),\n+           parent: Some(\"foo\"),\n            file_name: Some(\"bar\"),\n            file_stem: Some(\"bar\"),\n            extension: None\n            );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\", \".\"],\n+           iter: [\"foo\", \"..\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/..\"),\n+           parent: Some(\"foo\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -1660,17 +1734,17 @@ mod tests {\n            iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: None,\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n            );\n \n         t!(\"./\",\n-           iter: [\".\", \".\"],\n+           iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\".\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -1697,10 +1771,10 @@ mod tests {\n            );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \".\", \"b\"],\n+           iter: [\"a\", \"b\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"a/.\"),\n+           parent: Some(\"a\"),\n            file_name: Some(\"b\"),\n            file_stem: Some(\"b\"),\n            extension: None\n@@ -1715,6 +1789,16 @@ mod tests {\n            file_stem: Some(\"c\"),\n            extension: None\n            );\n+\n+        t!(\".foo\",\n+           iter: [\".foo\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"\"),\n+           file_name: Some(\".foo\"),\n+           file_stem: Some(\".foo\"),\n+           extension: None\n+           );\n     }\n \n     #[test]\n@@ -1734,14 +1818,14 @@ mod tests {\n            iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: None,\n+           parent: Some(\"\"),\n            file_name: Some(\"foo\"),\n            file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"/\",\n-           iter: [\"\\\\\", \".\"],\n+           iter: [\"\\\\\"],\n            has_root: true,\n            is_absolute: false,\n            parent: None,\n@@ -1751,7 +1835,7 @@ mod tests {\n            );\n \n         t!(\"\\\\\",\n-           iter: [\"\\\\\", \".\"],\n+           iter: [\"\\\\\"],\n            has_root: true,\n            is_absolute: false,\n            parent: None,\n@@ -1761,7 +1845,7 @@ mod tests {\n            );\n \n         t!(\"c:\",\n-           iter: [\"c:\", \".\"],\n+           iter: [\"c:\"],\n            has_root: false,\n            is_absolute: false,\n            parent: None,\n@@ -1771,17 +1855,7 @@ mod tests {\n            );\n \n         t!(\"c:\\\\\",\n-           iter: [\"c:\", \"\\\\\", \".\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n-        t!(\"c:\\\\\",\n-           iter: [\"c:\", \"\\\\\", \".\"],\n+           iter: [\"c:\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -1791,7 +1865,7 @@ mod tests {\n            );\n \n         t!(\"c:/\",\n-           iter: [\"c:\", \"\\\\\", \".\"],\n+           iter: [\"c:\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -1811,22 +1885,22 @@ mod tests {\n            );\n \n         t!(\"foo/\",\n-           iter: [\"foo\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"/foo/\",\n-           iter: [\"\\\\\", \"foo\", \".\"],\n+           iter: [\"\\\\\", \"foo\"],\n            has_root: true,\n            is_absolute: false,\n-           parent: Some(\"/foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1851,12 +1925,12 @@ mod tests {\n            );\n \n         t!(\"///foo///\",\n-           iter: [\"\\\\\", \"foo\", \".\"],\n+           iter: [\"\\\\\", \"foo\"],\n            has_root: true,\n            is_absolute: false,\n-           parent: Some(\"///foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1871,20 +1945,10 @@ mod tests {\n            );\n \n         t!(\"./.\",\n-           iter: [\".\", \".\"],\n+           iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n-        t!(\"./.\",\n-           iter: [\".\", \".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -1901,22 +1965,22 @@ mod tests {\n            );\n \n         t!(\"../\",\n-           iter: [\"..\", \".\"],\n+           iter: [\"..\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"..\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n            );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n@@ -1931,30 +1995,30 @@ mod tests {\n            );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\", \".\", \".\"],\n+           iter: [\"foo\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/.\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n            extension: None\n            );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \".\", \"bar\"],\n+           iter: [\"foo\", \"bar\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/.\"),\n+           parent: Some(\"foo\"),\n            file_name: Some(\"bar\"),\n            file_stem: Some(\"bar\"),\n            extension: None\n            );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\", \".\"],\n+           iter: [\"foo\", \"..\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"foo/..\"),\n+           parent: Some(\"foo\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -1984,17 +2048,17 @@ mod tests {\n            iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: None,\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n            );\n \n         t!(\"./\",\n-           iter: [\".\", \".\"],\n+           iter: [\".\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\".\"),\n+           parent: Some(\"\"),\n            file_name: None,\n            file_stem: None,\n            extension: None\n@@ -2021,10 +2085,10 @@ mod tests {\n            );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \".\", \"b\"],\n+           iter: [\"a\", \"b\"],\n            has_root: false,\n            is_absolute: false,\n-           parent: Some(\"a/.\"),\n+           parent: Some(\"a\"),\n            file_name: Some(\"b\"),\n            file_stem: Some(\"b\"),\n            extension: None\n@@ -2080,7 +2144,7 @@ mod tests {\n            );\n \n         t!(\"\\\\\\\\server\\\\share\",\n-           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \".\"],\n+           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -2171,7 +2235,7 @@ mod tests {\n \n \n         t!(\"\\\\\\\\?\\\\C:\\\\\",\n-           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"\"],\n+           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -2226,7 +2290,7 @@ mod tests {\n \n \n         t!(\"\\\\\\\\.\\\\foo\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \".\"],\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -2237,7 +2301,7 @@ mod tests {\n \n \n         t!(\"\\\\\\\\.\\\\foo/bar\",\n-           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\", \".\"],\n+           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -2259,7 +2323,7 @@ mod tests {\n \n \n         t!(\"\\\\\\\\.\\\\\",\n-           iter: [\"\\\\\\\\.\\\\\", \"\\\\\", \".\"],\n+           iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n            has_root: true,\n            is_absolute: true,\n            parent: None,\n@@ -2269,12 +2333,12 @@ mod tests {\n            );\n \n         t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n-           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\", \"\"],\n+           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n            has_root: true,\n            is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\a\\\\b\"),\n-           file_name: None,\n-           file_stem: None,\n+           parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n            extension: None\n            );\n     }\n@@ -2430,12 +2494,12 @@ mod tests {\n \n         tp!(\"\", \"\", false);\n         tp!(\"/\", \"/\", false);\n-        tp!(\"foo\", \"foo\", false);\n-        tp!(\".\", \".\", false);\n+        tp!(\"foo\", \"\", true);\n+        tp!(\".\", \"\", true);\n         tp!(\"/foo\", \"/\", true);\n         tp!(\"/foo/bar\", \"/foo\", true);\n         tp!(\"foo/bar\", \"foo\", true);\n-        tp!(\"foo/.\", \"foo\", true);\n+        tp!(\"foo/.\", \"\", true);\n         tp!(\"foo//bar\", \"foo\", true);\n \n         if cfg!(windows) {\n@@ -2465,7 +2529,7 @@ mod tests {\n             tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n             tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n \n-            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\\", true);\n         }\n     }\n \n@@ -2488,15 +2552,15 @@ mod tests {\n         tfn!(\"\", \"foo\", \"foo\");\n         if cfg!(unix) {\n             tfn!(\".\", \"foo\", \"./foo\");\n-            tfn!(\"foo/\", \"bar\", \"foo/bar\");\n-            tfn!(\"foo/.\", \"bar\", \"foo/./bar\");\n+            tfn!(\"foo/\", \"bar\", \"bar\");\n+            tfn!(\"foo/.\", \"bar\", \"bar\");\n             tfn!(\"..\", \"foo\", \"../foo\");\n             tfn!(\"foo/..\", \"bar\", \"foo/../bar\");\n             tfn!(\"/\", \"foo\", \"/foo\");\n         } else {\n             tfn!(\".\", \"foo\", r\".\\foo\");\n-            tfn!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n-            tfn!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n+            tfn!(r\"foo\\\", \"bar\", r\"bar\");\n+            tfn!(r\"foo\\.\", \"bar\", r\"bar\");\n             tfn!(\"..\", \"foo\", r\"..\\foo\");\n             tfn!(r\"foo\\..\", \"bar\", r\"foo\\..\\bar\");\n             tfn!(r\"\\\", \"foo\", r\"\\foo\");\n@@ -2524,8 +2588,8 @@ mod tests {\n         tfe!(\"foo\", \"\", \"foo\", true);\n         tfe!(\"\", \"foo\", \"\", false);\n         tfe!(\".\", \"foo\", \".\", false);\n-        tfe!(\"foo/\", \"bar\", \"foo/\", false);\n-        tfe!(\"foo/.\", \"bar\", \"foo/.\", false);\n+        tfe!(\"foo/\", \"bar\", \"foo.bar\", true);\n+        tfe!(\"foo/.\", \"bar\", \"foo.bar\", true);\n         tfe!(\"..\", \"foo\", \"..\",  false);\n         tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n         tfe!(\"/\", \"foo\", \"/\", false);\n@@ -2591,10 +2655,10 @@ mod tests {\n             );\n \n         tc!(\"foo/\", \"foo\",\n-            eq: false,\n+            eq: true,\n             starts_with: true,\n-            ends_with: false,\n-            relative_from: Some(\".\")\n+            ends_with: true,\n+            relative_from: Some(\"\")\n             );\n \n         tc!(\"foo/bar\", \"foo\",\n@@ -2621,8 +2685,25 @@ mod tests {\n         tc!(\"./foo/bar/\", \".\",\n             eq: false,\n             starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"foo/bar/\")\n+            ends_with: false,\n+            relative_from: Some(\"foo/bar\")\n             );\n+\n+        if cfg!(windows) {\n+            tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n+                r\"c:\\src\\rust\\cargo-test\\test\",\n+                eq: false,\n+                starts_with: true,\n+                ends_with: false,\n+                relative_from: Some(\"Cargo.toml\")\n+                );\n+\n+            tc!(r\"c:\\foo\", r\"C:\\foo\",\n+                eq: true,\n+                starts_with: true,\n+                ends_with: true,\n+                relative_from: Some(\"\")\n+                );\n+        }\n     }\n }"}, {"sha": "dc4ad209251d270272e563c52e3ce279d1421731", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -16,7 +16,10 @@ use prelude::v1::*;\n use sys::{last_error, retry};\n use ffi::CString;\n use num::Int;\n+\n+#[allow(deprecated)]\n use old_path::BytesContainer;\n+\n use collections;\n \n pub mod backtrace;\n@@ -120,6 +123,7 @@ pub trait FromInner<Inner> {\n }\n \n #[doc(hidden)]\n+#[allow(deprecated)]\n pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn program(&self) -> &CString;\n     fn args(&self) -> &[CString];"}, {"sha": "f23619955e2dd71c5eb72a7376db6165b9d7aca4", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -10,6 +10,8 @@\n \n //! Blocking posix-based file I/O\n \n+#![allow(deprecated)] // this module itself is essentially deprecated\n+\n use prelude::v1::*;\n \n use ffi::{CString, CStr};"}, {"sha": "79bdaafa52e3eaf702c51da241d9b121c38cafbf", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n+#![allow(deprecated)] // this module itself is essentially deprecated\n \n use prelude::v1::*;\n use self::Req::*;"}, {"sha": "4f3f6b0858c3804156ea731c00b927f9b59e1a27", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -23,6 +23,7 @@\n //! this takes the route of using StackWalk64 in order to walk the stack.\n \n #![allow(dead_code)]\n+#![allow(deprecated)] // for old path for dynamic lib\n \n use dynamic_lib::DynamicLibrary;\n use ffi::CStr;"}, {"sha": "1d63da813c9837a201d574cf4bc646fbb320a456", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -122,7 +122,7 @@ impl AsRawSocket for net::UdpSocket {\n     fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n }\n \n-// Windows-specific extensions to `OsString`.\n+/// Windows-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units.\n     ///\n@@ -137,8 +137,12 @@ impl OsStringExt for OsString {\n     }\n }\n \n-// Windows-specific extensions to `OsStr`.\n+/// Windows-specific extensions to `OsStr`.\n pub trait OsStrExt {\n+    /// Re-encode an `OsStr` as a wide character sequence,\n+    /// i.e. potentially ill-formed UTF-16.\n+    ///\n+    /// This is lossless. Note that the encoding does not include a final null.\n     fn encode_wide(&self) -> EncodeWide;\n }\n "}, {"sha": "6818880a4de80309e93450b005996dfa60dd5ebe", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -10,6 +10,8 @@\n \n //! Blocking Windows-based file I/O\n \n+#![allow(deprecated)] // this module itself is essentially deprecated\n+\n use libc::{self, c_int};\n \n use mem;"}, {"sha": "c9ef88d15ddfe20aa8b54da73c269ab05186f91d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n+#![allow(deprecated)] // this module itself is essentially deprecated\n \n use prelude::v1::*;\n "}, {"sha": "eb0daac3ab84cec07907f5bf9924dd6661e3d722", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -195,11 +195,7 @@ fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n         let mut cu = PathBuf::new(&cx.codemap().span_to_filename(sp));\n-        if cu.parent().is_some() {\n-            cu.pop();\n-        } else {\n-            cu = PathBuf::new(\"\");\n-        }\n+        cu.pop();\n         cu.push(arg);\n         cu\n     } else {"}, {"sha": "90f0dc30c75fe4bf829c26becb971d41f5f999bc", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -38,7 +38,6 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n-#![feature(path)]\n #![feature(io)]\n #![feature(path_ext)]\n "}, {"sha": "495c619c273d7c87432602cb711179717fd66d30", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -5254,13 +5254,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = PathBuf::new(&self.sess.span_diagnostic.cm\n                                            .span_to_filename(self.span));\n-        // FIXME(acrichto): right now \"a\".pop() == \"a\", but need to confirm with\n-        //                  aturon whether this is expected or not.\n-        if prefix.parent().is_some() {\n-            prefix.pop();\n-        } else {\n-            prefix = PathBuf::new(\"\");\n-        }\n+        prefix.pop();\n         let mut dir_path = prefix;\n         for part in &self.mod_path_stack {\n             dir_path.push(&**part);"}, {"sha": "17b42e4e05ca5cf32fa312c74aa774b7b7fbb220", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -25,6 +25,7 @@ use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n use std::mem;\n use std::ops::Deref;\n+#[allow(deprecated)]\n use std::old_path::BytesContainer;\n use std::rc::Rc;\n \n@@ -638,6 +639,7 @@ impl Deref for InternedString {\n     fn deref(&self) -> &str { &*self.string }\n }\n \n+#[allow(deprecated)]\n impl BytesContainer for InternedString {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         // FIXME #12938: This is a workaround for the incorrect signature"}, {"sha": "be467c1f1fb30844c9d490933616f0192ac2bcf2", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -57,7 +57,6 @@\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(old_io)]\n-#![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "19da658ed4f8e21e9db64710eed7d5db641ea366", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -40,7 +40,6 @@\n #![feature(core)]\n #![feature(int_uint)]\n #![feature(old_io)]\n-#![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "dadea634bf0eef4182e4f3d24957c4d736907842", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -14,7 +14,6 @@\n #![feature(exit_status)]\n #![feature(io)]\n #![feature(old_io)]\n-#![feature(path)]\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n "}, {"sha": "91a480ac86bdb6d47c680a79c17e7457d824e2dd", "filename": "src/test/auxiliary/cross_crate_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcross_crate_spans.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -23,4 +23,4 @@ pub fn generic_function<T: Clone>(val: T) -> (T, T) {\n }\n \n #[inline(never)]\n-fn zzz() {()}\n\\ No newline at end of file\n+fn zzz() {()}"}, {"sha": "4e089a4e59c427e41e66f2886997531de8e47119", "filename": "src/test/compile-fail/custom_attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e481cd98bd392839144c9ac83e55e445a12a/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs?ref=42c4e481cd98bd392839144c9ac83e55e445a12a", "patch": "@@ -11,4 +11,4 @@\n #[foo] //~ ERROR The attribute `foo`\n fn main() {\n \n-}\n\\ No newline at end of file\n+}"}]}