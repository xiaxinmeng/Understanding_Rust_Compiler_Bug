{"sha": "a719c058162804480358ef16c9e3ca1c8f5e3957", "node_id": "C_kwDOAAsO6NoAKGE3MTljMDU4MTYyODA0NDgwMzU4ZWYxNmM5ZTNjYTFjOGY1ZTM5NTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T22:05:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T22:05:42Z"}, "message": "Auto merge of #2426 - saethlin:unix-exec, r=RalfJung\n\nUse real exec on cfg(unix) targets\n\nCloses https://github.com/rust-lang/miri/issues/2421\n\nThe standard library has a platform extension trait that lets us get the behavior we want on cfg(unix), so why not use it?\n\nI tried this out and it produces the correct behavior in concert with nextest.", "tree": {"sha": "e524c840d9867455c7860fe41b1de94c954356dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e524c840d9867455c7860fe41b1de94c954356dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a719c058162804480358ef16c9e3ca1c8f5e3957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a719c058162804480358ef16c9e3ca1c8f5e3957", "html_url": "https://github.com/rust-lang/rust/commit/a719c058162804480358ef16c9e3ca1c8f5e3957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a719c058162804480358ef16c9e3ca1c8f5e3957/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "530abacbf762d27eba20c730b422ca1537e46c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/530abacbf762d27eba20c730b422ca1537e46c68", "html_url": "https://github.com/rust-lang/rust/commit/530abacbf762d27eba20c730b422ca1537e46c68"}, {"sha": "622613f957e07ffe1398fa17bc84f185e62df27f", "url": "https://api.github.com/repos/rust-lang/rust/commits/622613f957e07ffe1398fa17bc84f185e62df27f", "html_url": "https://github.com/rust-lang/rust/commit/622613f957e07ffe1398fa17bc84f185e62df27f"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "faa116ff7e3849ced9f892dd75cfad639578c0d9", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a719c058162804480358ef16c9e3ca1c8f5e3957/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a719c058162804480358ef16c9e3ca1c8f5e3957/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=a719c058162804480358ef16c9e3ca1c8f5e3957", "patch": "@@ -51,7 +51,7 @@ enum MiriCommand {\n }\n \n /// The information to run a crate with the given environment.\n-#[derive(Serialize, Deserialize)]\n+#[derive(Clone, Serialize, Deserialize)]\n struct CrateRunEnv {\n     /// The command-line arguments.\n     args: Vec<String>,\n@@ -250,27 +250,56 @@ fn xargo_check() -> Command {\n     Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n }\n \n-/// Execute the command. If it fails, fail this process with the same exit code.\n-/// Otherwise, continue.\n-fn exec(mut cmd: Command) {\n-    let exit_status = cmd.status().expect(\"failed to run command\");\n-    if exit_status.success().not() {\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+fn exec(mut cmd: Command) -> ! {\n+    // On non-Unix imitate POSIX exec as closely as we can\n+    #[cfg(not(unix))]\n+    {\n+        let exit_status = cmd.status().expect(\"failed to run command\");\n         std::process::exit(exit_status.code().unwrap_or(-1))\n     }\n+    // On Unix targets, actually exec.\n+    // If exec returns, process setup has failed. This is the same error condition as the expect in\n+    // the non-Unix case.\n+    #[cfg(unix)]\n+    {\n+        use std::os::unix::process::CommandExt;\n+        let error = cmd.exec();\n+        Err(error).expect(\"failed to run command\")\n+    }\n }\n \n-/// Execute the command and pipe `input` into its stdin.\n-/// If it fails, fail this process with the same exit code.\n-/// Otherwise, continue.\n-fn exec_with_pipe(mut cmd: Command, input: &[u8]) {\n-    cmd.stdin(process::Stdio::piped());\n-    let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+/// Execute the `Command`, where possible by replacing the current process with a new process\n+/// described by the `Command`. Then exit this process with the exit code of the new process.\n+/// `input` is also piped to the new process's stdin, on cfg(unix) platforms by writing its\n+/// contents to `path` first, then setting stdin to that file.\n+fn exec_with_pipe<P>(mut cmd: Command, input: &[u8], path: P) -> !\n+where\n+    P: AsRef<Path>,\n+{\n+    #[cfg(unix)]\n     {\n-        let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n-        stdin.write_all(input).expect(\"failed to write out test source\");\n+        // Write the bytes we want to send to stdin out to a file\n+        std::fs::write(&path, input).unwrap();\n+        // Open the file for reading, and set our new stdin to it\n+        let stdin = File::open(&path).unwrap();\n+        cmd.stdin(stdin);\n+        // Unlink the file so that it is fully cleaned up as soon as the new process exits\n+        std::fs::remove_file(&path).unwrap();\n+        // Finally, we can hand off control.\n+        exec(cmd)\n     }\n-    let exit_status = child.wait().expect(\"failed to run command\");\n-    if exit_status.success().not() {\n+    #[cfg(not(unix))]\n+    {\n+        drop(path); // We don't need the path, we can pipe the bytes directly\n+        cmd.stdin(process::Stdio::piped());\n+        let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+        {\n+            let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n+            stdin.write_all(input).expect(\"failed to write out test source\");\n+        }\n+        let exit_status = child.wait().expect(\"failed to run command\");\n         std::process::exit(exit_status.code().unwrap_or(-1))\n     }\n }\n@@ -890,6 +919,8 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n         let env = CrateRunEnv::collect(args, inside_rustdoc);\n \n+        store_json(CrateRunInfo::RunWith(env.clone()));\n+\n         // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n         // just creating the JSON file is not enough: we need to detect syntax errors,\n         // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n@@ -906,7 +937,15 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n                 cmd.arg(\"--emit=metadata\");\n             }\n \n-            cmd.args(&env.args);\n+            // Alter the `-o` parameter so that it does not overwrite the JSON file we stored above.\n+            let mut args = env.args.clone();\n+            for i in 0..args.len() {\n+                if args[i] == \"-o\" {\n+                    args[i + 1].push_str(\".miri\");\n+                }\n+            }\n+\n+            cmd.args(&args);\n             cmd.env(\"MIRI_BE_RUSTC\", \"target\");\n \n             if verbose > 0 {\n@@ -917,11 +956,9 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n                 eprintln!(\"[cargo-miri rustc inside rustdoc] going to run:\\n{:?}\", cmd);\n             }\n \n-            exec_with_pipe(cmd, &env.stdin);\n+            exec_with_pipe(cmd, &env.stdin, format!(\"{}.stdin\", out_filename(\"\", \"\").display()));\n         }\n \n-        store_json(CrateRunInfo::RunWith(env));\n-\n         return;\n     }\n \n@@ -997,8 +1034,6 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             \"[cargo-miri rustc] target_crate={target_crate} runnable_crate={runnable_crate} info_query={info_query}\"\n         );\n     }\n-    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n-    exec(cmd);\n \n     // Create a stub .rlib file if \"link\" was requested by cargo.\n     // This is necessary to prevent cargo from doing rebuilds all the time.\n@@ -1013,6 +1048,9 @@ fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n         File::create(out_filename(\"\", \".dll\")).expect(\"failed to create fake .dll file\");\n         File::create(out_filename(\"\", \".lib\")).expect(\"failed to create fake .lib file\");\n     }\n+\n+    debug_cmd(\"[cargo-miri rustc]\", verbose, &cmd);\n+    exec(cmd);\n }\n \n #[derive(Debug, Copy, Clone, PartialEq)]\n@@ -1117,7 +1155,7 @@ fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: RunnerPhas\n     // Run it.\n     debug_cmd(\"[cargo-miri runner]\", verbose, &cmd);\n     match phase {\n-        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin),\n+        RunnerPhase::Rustdoc => exec_with_pipe(cmd, &info.stdin, format!(\"{}.stdin\", binary)),\n         RunnerPhase::Cargo => exec(cmd),\n     }\n }"}]}