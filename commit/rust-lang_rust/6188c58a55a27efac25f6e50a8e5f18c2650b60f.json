{"sha": "6188c58a55a27efac25f6e50a8e5f18c2650b60f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxODhjNThhNTVhMjdlZmFjMjVmNmU1MGE4ZTVmMThjMjY1MGI2MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-01T10:16:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-01T10:16:00Z"}, "message": "Auto merge of #54711 - kennytm:rollup, r=kennytm\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #53784 (Document that slices cannot be larger than `isize::MAX` bytes)\n - #54308 (Better user experience when attempting to call associated functions with dot notation)\n - #54488 (in which we include attributes in unused `extern crate` suggestion spans)\n - #54544 (Indicate how to move value out of Box in docs.)\n - #54623 (Added help message for `impl_trait_in_bindings` feature gate)\n - #54641 (A few cleanups and minor improvements to rustc/infer)\n - #54656 (Correct doc for WorkQueue<T>::pop().)\n - #54674 (update miri)\n - #54676 (Remove `-Z disable_ast_check_for_mutation_in_guard`)\n - #54679 (Improve bug! message for impossible case in Relate)\n - #54681 (Rename sanitizer runtime libraries on OSX)\n - #54708 (Make ./x.py help <cmd> invoke ./x.py <cmd> -h on its own)\n - #54713 (Add nightly check for tool_lints warning)", "tree": {"sha": "867c17d68b0dce674e3ed4905b07d726ec4171ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/867c17d68b0dce674e3ed4905b07d726ec4171ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6188c58a55a27efac25f6e50a8e5f18c2650b60f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6188c58a55a27efac25f6e50a8e5f18c2650b60f", "html_url": "https://github.com/rust-lang/rust/commit/6188c58a55a27efac25f6e50a8e5f18c2650b60f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6188c58a55a27efac25f6e50a8e5f18c2650b60f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55129d0037c112a80276ee1de0c2245ddc6462c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55129d0037c112a80276ee1de0c2245ddc6462c", "html_url": "https://github.com/rust-lang/rust/commit/f55129d0037c112a80276ee1de0c2245ddc6462c"}, {"sha": "5b08200223d7307edca13a925a4ae58a68bc9872", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b08200223d7307edca13a925a4ae58a68bc9872", "html_url": "https://github.com/rust-lang/rust/commit/5b08200223d7307edca13a925a4ae58a68bc9872"}], "stats": {"total": 789, "additions": 491, "deletions": 298}, "files": [{"sha": "c27f4f056d747c8f5ed52f74e703546290c1d99a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -844,6 +844,11 @@ def bootstrap(help_triggered):\n def main():\n     \"\"\"Entry point for the bootstrap process\"\"\"\n     start_time = time()\n+\n+    # x.py help <cmd> ...\n+    if len(sys.argv) > 1 and sys.argv[1] == 'help':\n+        sys.argv = sys.argv[:1] + [sys.argv[2], '-h'] + sys.argv[3:]\n+\n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:"}, {"sha": "7d235743c2c46834fc3a8ebfaabfa5f719b081be", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -249,7 +249,7 @@ impl Step for StdLink {\n \n fn copy_apple_sanitizer_dylibs(builder: &Builder, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n-        let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n+        let filename = format!(\"lib__rustc__clang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");"}, {"sha": "ec94f57861dbeb1efce4a827795c0dfb954f73d9", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -178,6 +178,37 @@ pub struct NativeLibBoilerplate {\n     pub out_dir: PathBuf,\n }\n \n+impl NativeLibBoilerplate {\n+    /// On OSX we don't want to ship the exact filename that compiler-rt builds.\n+    /// This conflicts with the system and ours is likely a wildly different\n+    /// version, so they can't be substituted.\n+    ///\n+    /// As a result, we rename it here but we need to also use\n+    /// `install_name_tool` on OSX to rename the commands listed inside of it to\n+    /// ensure it's linked against correctly.\n+    pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n+        if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {\n+            return\n+        }\n+\n+        let dir = self.out_dir.join(\"build/lib/darwin\");\n+        let name = format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name);\n+        let src = dir.join(&format!(\"lib{}.dylib\", name));\n+        let new_name = format!(\"lib__rustc__{}.dylib\", name);\n+        let dst = dir.join(&new_name);\n+\n+        println!(\"{} => {}\", src.display(), dst.display());\n+        fs::rename(&src, &dst).unwrap();\n+        let status = Command::new(\"install_name_tool\")\n+            .arg(\"-id\")\n+            .arg(format!(\"@rpath/{}\", new_name))\n+            .arg(&dst)\n+            .status()\n+            .expect(\"failed to execute `install_name_tool`\");\n+        assert!(status.success());\n+    }\n+}\n+\n impl Drop for NativeLibBoilerplate {\n     fn drop(&mut self) {\n         if !thread::panicking() {\n@@ -229,7 +260,7 @@ pub fn native_lib_boilerplate(\n pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n     -> Result<(NativeLibBoilerplate, String), ()>\n {\n-    let (link_name, search_path, dynamic) = match &*env::var(\"TARGET\").unwrap() {\n+    let (link_name, search_path, apple) = match &*env::var(\"TARGET\").unwrap() {\n         \"x86_64-unknown-linux-gnu\" => (\n             format!(\"clang_rt.{}-x86_64\", sanitizer_name),\n             \"build/lib/linux\",\n@@ -242,8 +273,8 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n         ),\n         _ => return Err(()),\n     };\n-    let to_link = if dynamic {\n-        format!(\"dylib={}\", link_name)\n+    let to_link = if apple {\n+        format!(\"dylib=__rustc__{}\", link_name)\n     } else {\n         format!(\"static={}\", link_name)\n     };"}, {"sha": "f989e701913a573750578d0a32bab6a6598f60fc", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -16,10 +16,18 @@\n //!\n //! # Examples\n //!\n-//! Creating a box:\n+//! Move a value from the stack to the heap by creating a [`Box`]:\n //!\n //! ```\n-//! let x = Box::new(5);\n+//! let val: u8 = 5;\n+//! let boxed: Box<u8> = Box::new(val);\n+//! ```\n+//!\n+//! Move a value from a [`Box`] back to the stack by [dereferencing]:\n+//!\n+//! ```\n+//! let boxed: Box<u8> = Box::new(5);\n+//! let val: u8 = *boxed;\n //! ```\n //!\n //! Creating a recursive data structure:\n@@ -52,6 +60,9 @@\n //! elements are in the list, and so we don't know how much memory to allocate\n //! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n //! big `Cons` needs to be.\n+//!\n+//! [dereferencing]: ../../std/ops/trait.Deref.html\n+//! [`Box`]: struct.Box.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "d400bd49050a965835578b59a52da87ffd5b37a5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -34,6 +34,7 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n use cmp;\n use fmt;\n use intrinsics::assume;\n+use isize;\n use iter::*;\n use ops::{FnMut, Try, self};\n use option::Option;\n@@ -4080,6 +4081,9 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n /// them from other data. You can obtain a pointer that is usable as `data`\n /// for zero-length slices using [`NonNull::dangling()`].\n ///\n+/// The total size of the slice must be no larger than `isize::MAX` **bytes**\n+/// in memory. See the safety documentation of [`pointer::offset`].\n+///\n /// # Caveat\n ///\n /// The lifetime for the returned slice is inferred from its usage. To\n@@ -4101,10 +4105,13 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n /// ```\n ///\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n+/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n+    debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n+                  \"attempt to create slice covering half the address space\");\n     Repr { raw: FatPtr { data, len } }.rust\n }\n \n@@ -4114,15 +4121,19 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n /// This function is unsafe for the same reasons as [`from_raw_parts`], as well\n /// as not being able to provide a non-aliasing guarantee of the returned\n /// mutable slice. `data` must be non-null and aligned even for zero-length\n-/// slices as with [`from_raw_parts`]. See the documentation of\n-/// [`from_raw_parts`] for more details.\n+/// slices as with [`from_raw_parts`]. The total size of the slice must be no\n+/// larger than `isize::MAX` **bytes** in memory.\n+///\n+/// See the documentation of [`from_raw_parts`] for more details.\n ///\n /// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n-    Repr { raw: FatPtr { data, len} }.rust_mut\n+    debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n+                  \"attempt to create slice covering half the address space\");\n+    Repr { raw: FatPtr { data, len } }.rust_mut\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying)."}, {"sha": "81d8a803c395870f2fb9516d24b7658cb8981755", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 82, "deletions": 56, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -54,6 +54,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n use session::Session;\n+use session::config::nightly_options;\n use util::common::FN_OUTPUT_NAME;\n use util::nodemap::{DefIdMap, NodeMap};\n \n@@ -188,16 +189,28 @@ enum ImplTraitContext<'a> {\n     Existential(Option<DefId>),\n \n     /// `impl Trait` is not accepted in this position.\n-    Disallowed,\n+    Disallowed(ImplTraitPosition),\n+}\n+\n+/// Position in which `impl Trait` is disallowed. Used for error reporting.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum ImplTraitPosition {\n+    Binding,\n+    Other,\n }\n \n impl<'a> ImplTraitContext<'a> {\n+    #[inline]\n+    fn disallowed() -> Self {\n+        ImplTraitContext::Disallowed(ImplTraitPosition::Other)\n+    }\n+\n     fn reborrow(&'b mut self) -> ImplTraitContext<'b> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n             Existential(did) => Existential(*did),\n-            Disallowed => Disallowed,\n+            Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n }\n@@ -1142,7 +1155,7 @@ impl<'a> LoweringContext<'a> {\n                                 generic_params: this.lower_generic_params(\n                                     &f.generic_params,\n                                     &NodeMap(),\n-                                    ImplTraitContext::Disallowed,\n+                                    ImplTraitContext::disallowed(),\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n@@ -1255,20 +1268,27 @@ impl<'a> LoweringContext<'a> {\n                             }),\n                         ))\n                     }\n-                    ImplTraitContext::Disallowed => {\n+                    ImplTraitContext::Disallowed(pos) => {\n                         let allowed_in = if self.sess.features_untracked()\n                                                 .impl_trait_in_bindings {\n                             \"bindings or function and inherent method return types\"\n                         } else {\n                             \"function and inherent method return types\"\n                         };\n-                        span_err!(\n+                        let mut err = struct_span_err!(\n                             self.sess,\n                             t.span,\n                             E0562,\n                             \"`impl Trait` not allowed outside of {}\",\n                             allowed_in,\n                         );\n+                        if pos == ImplTraitPosition::Binding &&\n+                            nightly_options::is_nightly_build() {\n+                            help!(err,\n+                                  \"add #![feature(impl_trait_in_bindings)] to the crate attributes \\\n+                                   to enable\");\n+                        }\n+                        err.emit();\n                         hir::TyKind::Err\n                     }\n                 }\n@@ -1742,7 +1762,7 @@ impl<'a> LoweringContext<'a> {\n                         param_mode,\n                         0,\n                         ParenthesizedGenericArgs::Err,\n-                        ImplTraitContext::Disallowed,\n+                        ImplTraitContext::disallowed(),\n                     )\n                 })\n                 .chain(ident.map(|ident| hir::PathSegment::from_ident(ident)))\n@@ -1872,9 +1892,11 @@ impl<'a> LoweringContext<'a> {\n         self.with_anonymous_lifetime_mode(\n             AnonymousLifetimeMode::PassThrough,\n             |this| {\n-                const DISALLOWED: ImplTraitContext<'_> = ImplTraitContext::Disallowed;\n                 let &ParenthesisedArgs { ref inputs, ref output, span } = data;\n-                let inputs = inputs.iter().map(|ty| this.lower_ty_direct(ty, DISALLOWED)).collect();\n+                let inputs = inputs\n+                    .iter()\n+                    .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n+                    .collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n                     hir::Ty { node: hir::TyKind::Tup(tys), id: node_id, hir_id, span }\n@@ -1889,7 +1911,7 @@ impl<'a> LoweringContext<'a> {\n                                 ident: Ident::from_str(FN_OUTPUT_NAME),\n                                 ty: output\n                                     .as_ref()\n-                                    .map(|ty| this.lower_ty(&ty, DISALLOWED))\n+                                    .map(|ty| this.lower_ty(&ty, ImplTraitContext::disallowed()))\n                                     .unwrap_or_else(|| P(mk_tup(this, hir::HirVec::new(), span))),\n                                 span: output.as_ref().map_or(span, |ty| ty.span),\n                             }\n@@ -1921,7 +1943,7 @@ impl<'a> LoweringContext<'a> {\n                     if self.sess.features_untracked().impl_trait_in_bindings {\n                         ImplTraitContext::Existential(Some(parent_def_id))\n                     } else {\n-                        ImplTraitContext::Disallowed\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     }\n                 )),\n             pat: self.lower_pat(&l.pat),\n@@ -1983,7 +2005,7 @@ impl<'a> LoweringContext<'a> {\n                 if let Some((_, ref mut ibty)) = in_band_ty_params {\n                     self.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n                 } else {\n-                    self.lower_ty_direct(&arg.ty, ImplTraitContext::Disallowed)\n+                    self.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n                 }\n             })\n             .collect::<HirVec<_>>();\n@@ -1999,9 +2021,12 @@ impl<'a> LoweringContext<'a> {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n-                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(Some(def_id))))\n+                        hir::Return(self.lower_ty(ty,\n+                            ImplTraitContext::Existential(Some(def_id))))\n+                    }\n+                    _ => {\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::disallowed()))\n                     }\n-                    _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             }\n@@ -2369,7 +2394,7 @@ impl<'a> LoweringContext<'a> {\n                     span: ident.span,\n                     kind: hir::GenericParamKind::Type {\n                         default: default.as_ref().map(|x| {\n-                            self.lower_ty(x, ImplTraitContext::Disallowed)\n+                            self.lower_ty(x, ImplTraitContext::disallowed())\n                         }),\n                         synthetic: param.attrs.iter()\n                                               .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n@@ -2472,9 +2497,9 @@ impl<'a> LoweringContext<'a> {\n                             bound_generic_params: this.lower_generic_params(\n                                 bound_generic_params,\n                                 &NodeMap(),\n-                                ImplTraitContext::Disallowed,\n+                                ImplTraitContext::disallowed(),\n                             ),\n-                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n+                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n                             bounds: bounds\n                                 .iter()\n                                 .filter_map(|bound| match *bound {\n@@ -2483,7 +2508,7 @@ impl<'a> LoweringContext<'a> {\n                                     GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n                                     _ => Some(this.lower_param_bound(\n                                         bound,\n-                                        ImplTraitContext::Disallowed,\n+                                        ImplTraitContext::disallowed(),\n                                     )),\n                                 })\n                                 .collect(),\n@@ -2499,7 +2524,7 @@ impl<'a> LoweringContext<'a> {\n             }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                 span,\n                 lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n+                bounds: self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate {\n                 id,\n@@ -2508,8 +2533,8 @@ impl<'a> LoweringContext<'a> {\n                 span,\n             }) => hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                 id: self.lower_node_id(id).node_id,\n-                lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::Disallowed),\n-                rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::Disallowed),\n+                lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n+                rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n                 span,\n             }),\n         }\n@@ -2579,7 +2604,7 @@ impl<'a> LoweringContext<'a> {\n                 None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n-            ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),\n+            ty: self.lower_ty(&f.ty, ImplTraitContext::disallowed()),\n             attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n@@ -2686,7 +2711,7 @@ impl<'a> LoweringContext<'a> {\n                         if self.sess.features_untracked().impl_trait_in_bindings {\n                             ImplTraitContext::Existential(None)\n                         } else {\n-                            ImplTraitContext::Disallowed\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n                     self.lower_mutability(m),\n@@ -2701,7 +2726,7 @@ impl<'a> LoweringContext<'a> {\n                         if self.sess.features_untracked().impl_trait_in_bindings {\n                             ImplTraitContext::Existential(None)\n                         } else {\n-                            ImplTraitContext::Disallowed\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n                     value\n@@ -2740,12 +2765,12 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::Ty(ref t, ref generics) => hir::ItemKind::Ty(\n-                self.lower_ty(t, ImplTraitContext::Disallowed),\n-                self.lower_generics(generics, ImplTraitContext::Disallowed),\n+                self.lower_ty(t, ImplTraitContext::disallowed()),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(hir::ExistTy {\n-                generics: self.lower_generics(generics, ImplTraitContext::Disallowed),\n-                bounds: self.lower_param_bounds(b, ImplTraitContext::Disallowed),\n+                generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                bounds: self.lower_param_bounds(b, ImplTraitContext::disallowed()),\n                 impl_trait_fn: None,\n             }),\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n@@ -2756,20 +2781,20 @@ impl<'a> LoweringContext<'a> {\n                         .map(|x| self.lower_variant(x))\n                         .collect(),\n                 },\n-                self.lower_generics(generics, ImplTraitContext::Disallowed),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n-                    self.lower_generics(generics, ImplTraitContext::Disallowed),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n                 let vdata = self.lower_variant_data(vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n-                    self.lower_generics(generics, ImplTraitContext::Disallowed),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Impl(\n@@ -2802,7 +2827,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::CreateParameter,\n                     |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n-                            this.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n+                            this.lower_trait_ref(trait_ref, ImplTraitContext::disallowed())\n                         });\n \n                         if let Some(ref trait_ref) = trait_ref {\n@@ -2811,7 +2836,7 @@ impl<'a> LoweringContext<'a> {\n                             }\n                         }\n \n-                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::Disallowed);\n+                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::disallowed());\n \n                         (trait_ref, lowered_ty)\n                     },\n@@ -2838,22 +2863,22 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n-                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::Disallowed);\n+                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n                 let items = items\n                     .iter()\n                     .map(|item| self.lower_trait_item_ref(item))\n                     .collect();\n                 hir::ItemKind::Trait(\n                     self.lower_is_auto(is_auto),\n                     self.lower_unsafety(unsafety),\n-                    self.lower_generics(generics, ImplTraitContext::Disallowed),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n                     bounds,\n                     items,\n                 )\n             }\n             ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n-                self.lower_generics(generics, ImplTraitContext::Disallowed),\n-                self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n         }\n@@ -3043,9 +3068,9 @@ impl<'a> LoweringContext<'a> {\n \n         let (generics, node) = match i.node {\n             TraitItemKind::Const(ref ty, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::TraitItemKind::Const(\n-                    self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n@@ -3077,12 +3102,12 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             TraitItemKind::Type(ref bounds, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::TraitItemKind::Type(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n-                        .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n                 ),\n             ),\n             TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -3132,9 +3157,9 @@ impl<'a> LoweringContext<'a> {\n             ImplItemKind::Const(ref ty, ref expr) => {\n                 let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n                 (\n-                    self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                    self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                     hir::ImplItemKind::Const(\n-                        self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n                         body_id,\n                     ),\n                 )\n@@ -3152,13 +3177,13 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n             ImplItemKind::Type(ref ty) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                hir::ImplItemKind::Type(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Type(self.lower_ty(ty, ImplTraitContext::disallowed())),\n             ),\n             ImplItemKind::Existential(ref bounds) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::ImplItemKind::Existential(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                 ),\n             ),\n             ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -3349,7 +3374,8 @@ impl<'a> LoweringContext<'a> {\n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n-                    hir::ForeignItemKind::Static(self.lower_ty(t, ImplTraitContext::Disallowed), m)\n+                    hir::ForeignItemKind::Static(\n+                        self.lower_ty(t, ImplTraitContext::disallowed()), m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n@@ -3488,7 +3514,7 @@ impl<'a> LoweringContext<'a> {\n                     &None,\n                     path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 );\n                 self.check_self_struct_ctor_feature(&qpath);\n                 hir::PatKind::TupleStruct(\n@@ -3503,7 +3529,7 @@ impl<'a> LoweringContext<'a> {\n                     qself,\n                     path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 );\n                 self.check_self_struct_ctor_feature(&qpath);\n                 hir::PatKind::Path(qpath)\n@@ -3514,7 +3540,7 @@ impl<'a> LoweringContext<'a> {\n                     &None,\n                     path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 );\n \n                 let fs = fields\n@@ -3608,7 +3634,7 @@ impl<'a> LoweringContext<'a> {\n                     ParamMode::Optional,\n                     0,\n                     ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n@@ -3627,11 +3653,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Lit(ref l) => hir::ExprKind::Lit(P((**l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n                 let m = self.lower_mutability(m);\n@@ -3900,7 +3926,7 @@ impl<'a> LoweringContext<'a> {\n                     qself,\n                     path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 );\n                 self.check_self_struct_ctor_feature(&qpath);\n                 hir::ExprKind::Path(qpath)\n@@ -3965,7 +3991,7 @@ impl<'a> LoweringContext<'a> {\n                     &None,\n                     path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed,\n+                    ImplTraitContext::disallowed(),\n                 ),\n                 fields.iter().map(|x| self.lower_field(x)).collect(),\n                 maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),"}, {"sha": "a327f1f5c9d50b462a5e1319da2eb57ac9d879cf", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 56, "deletions": 64, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -135,10 +135,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         // Select everything, returning errors.\n-        let true_errors = match fulfill_cx.select_where_possible(self) {\n-            Ok(()) => vec![],\n-            Err(errors) => errors,\n-        };\n+        let true_errors = fulfill_cx.select_where_possible(self).err().unwrap_or_else(Vec::new);\n         debug!(\"true_errors = {:#?}\", true_errors);\n \n         if !true_errors.is_empty() {\n@@ -148,10 +145,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // Anything left unselected *now* must be an ambiguity.\n-        let ambig_errors = match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => vec![],\n-            Err(errors) => errors,\n-        };\n+        let ambig_errors = fulfill_cx.select_all_or_error(self).err().unwrap_or_else(Vec::new);\n         debug!(\"ambig_errors = {:#?}\", ambig_errors);\n \n         let region_obligations = self.take_registered_region_obligations();\n@@ -316,16 +310,18 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // ...also include the other query region constraints from the query.\n-        output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n-        for r_c in query_result.value.region_constraints.iter() {\n-            let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n-            let k1 = substitute_value(self.tcx, &result_subst, &k1);\n-            let r2 = substitute_value(self.tcx, &result_subst, &r2);\n-            if k1 != r2.into() {\n-                output_query_region_constraints\n-                    .push(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)));\n-            }\n-        }\n+        output_query_region_constraints.extend(\n+            query_result.value.region_constraints.iter().filter_map(|r_c| {\n+                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n+                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                if k1 != r2.into() {\n+                    Some(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)))\n+                } else {\n+                    None\n+                }\n+            })\n+        );\n \n         let user_result: R =\n             query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n@@ -448,10 +444,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .variables\n                 .iter()\n                 .enumerate()\n-                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n-                    Some(k) => k,\n-                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n-                })\n+                .map(|(index, info)| opt_values[CanonicalVar::new(index)].unwrap_or_else(||\n+                    self.fresh_inference_var_for_canonical_var(cause.span, *info)\n+                ))\n                 .collect(),\n         };\n \n@@ -504,24 +499,22 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n                     let k1 = substitute_value(self.tcx, result_subst, k1);\n                     let r2 = substitute_value(self.tcx, result_subst, r2);\n-                    match k1.unpack() {\n-                        UnpackedKind::Lifetime(r1) => Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            ty::Predicate::RegionOutlives(ty::Binder::dummy(\n-                                ty::OutlivesPredicate(r1, r2),\n+\n+                    Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        match k1.unpack() {\n+                            UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                                ty::Binder::dummy(\n+                                    ty::OutlivesPredicate(r1, r2)\n                             )),\n-                        ),\n-\n-                        UnpackedKind::Type(t1) => Obligation::new(\n-                            cause.clone(),\n-                            param_env,\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                                t1, r2,\n-                            ))),\n-                        ),\n-                    }\n-                }),\n+                            UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n+                                ty::Binder::dummy(ty::OutlivesPredicate(\n+                                    t1, r2\n+                            )))\n+                        }\n+                    )\n+                })\n         ) as Box<dyn Iterator<Item = _>>\n     }\n \n@@ -583,31 +576,30 @@ pub fn make_query_outlives<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n-    let mut outlives: Vec<_> = constraints\n-            .into_iter()\n-            .map(|(k, _)| match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            })\n-            .map(ty::Binder::dummy) // no bound regions in the code above\n-            .collect();\n-\n-    outlives.extend(\n-        outlives_obligations\n-            .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-            .map(ty::Binder::dummy), // no bound regions in the code above\n-    );\n+    let outlives: Vec<_> = constraints\n+        .into_iter()\n+        .map(|(k, _)| match *k {\n+            // Swap regions because we are going from sub (<=) to outlives\n+            // (>=).\n+            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                tcx.mk_region(ty::ReVar(v2)).into(),\n+                tcx.mk_region(ty::ReVar(v1)),\n+            ),\n+            Constraint::VarSubReg(v1, r2) => {\n+                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+            }\n+            Constraint::RegSubVar(r1, v2) => {\n+                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+            }\n+            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        })\n+        .map(ty::Binder::dummy) // no bound regions in the code above\n+        .chain(\n+            outlives_obligations\n+                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n+                .map(ty::Binder::dummy), // no bound regions in the code above\n+        )\n+        .collect();\n \n     outlives\n }"}, {"sha": "854960492c9bd4c897e3f357747a3c1dcdbbecf5", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -77,24 +77,22 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         match (&a.sty, &b.sty) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);\n-                Ok(a)\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n-                Ok(a)\n             }\n \n             (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n-                Ok(a)\n             }\n \n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n-                Ok(a)\n             }\n         }\n+\n+        Ok(a)\n     }\n \n     fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)"}, {"sha": "a68241ff2c0201c761894a3736e9d4c72aa44f2d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -406,10 +406,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             errors.clone()\n         } else {\n             errors\n-                .iter()\n-                .filter(|&e| !is_bound_failure(e))\n-                .cloned()\n-                .collect()\n+            .iter()\n+            .filter(|&e| !is_bound_failure(e))\n+            .cloned()\n+            .collect()\n         };\n \n         // sort the errors by span, for better error message stability.\n@@ -455,11 +455,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             TypeError::Sorts(ref exp_found) => {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n-                match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) => {\n-                        report_path_match(err, exp_adt.did, found_adt.did);\n-                    }\n-                    _ => (),\n+                if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _))\n+                     = (&exp_found.expected.sty, &exp_found.found.sty)\n+                {\n+                    report_path_match(err, exp_adt.did, found_adt.did);\n                 }\n             }\n             TypeError::Traits(ref exp_found) => {"}, {"sha": "efb316243fad036933d94c2cee3436074323fb9f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut labels = vec![(\n             span,\n             if &name == \"_\" {\n-                \"cannot infer type\".to_string()\n+                \"cannot infer type\".to_owned()\n             } else {\n                 format!(\"cannot infer type for `{}`\", name)\n             },\n@@ -138,20 +138,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // ```\n             labels.clear();\n             labels.push(\n-                (pattern.span, \"consider giving this closure parameter a type\".to_string()));\n+                (pattern.span, \"consider giving this closure parameter a type\".to_owned()));\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.compiler_desugaring_kind() {\n                     None => labels.push((pattern.span,\n                                          format!(\"consider giving `{}` a type\", simple_ident))),\n                     Some(CompilerDesugaringKind::ForLoop) => labels.push((\n                         pattern.span,\n-                        \"the element type for this iterator is not specified\".to_string(),\n+                        \"the element type for this iterator is not specified\".to_owned(),\n                     )),\n                     _ => {}\n                 }\n             } else {\n-                labels.push((pattern.span, \"consider giving the pattern a type\".to_string()));\n+                labels.push((pattern.span, \"consider giving the pattern a type\".to_owned()));\n             }\n         }\n "}, {"sha": "1f84c73a715833fae46ac4cd09fea46b17f8bd1b", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -113,12 +113,12 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             (None, None) => {\n                 let (main_label_1, span_label_1) = if ty_sup.id == ty_sub.id {\n                     (\n-                        \"this type is declared with multiple lifetimes...\".to_string(),\n-                        \"...but data with one lifetime flows into the other here\".to_string()\n+                        \"this type is declared with multiple lifetimes...\".to_owned(),\n+                        \"...but data with one lifetime flows into the other here\".to_owned()\n                     )\n                 } else {\n                     (\n-                        \"these two types are declared with different lifetimes...\".to_string(),\n+                        \"these two types are declared with different lifetimes...\".to_owned(),\n                         format!(\n                             \"...but data{} flows{} here\",\n                             span_label_var1,\n@@ -133,15 +133,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 ty_sub.span,\n                 ret_span,\n                 \"this parameter and the return type are declared \\\n-                 with different lifetimes...\".to_string()\n+                 with different lifetimes...\".to_owned()\n                 ,\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),\n             (_, Some(ret_span)) => (\n                 ty_sup.span,\n                 ret_span,\n                 \"this parameter and the return type are declared \\\n-                 with different lifetimes...\".to_string()\n+                 with different lifetimes...\".to_owned()\n                 ,\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),"}, {"sha": "009a823568131fb6b007e44aabd6b58c2ecce3cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -58,18 +58,17 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n-                    match hir.get(node_id) {\n-                        Node::Expr(Expr {\n-                            node: Closure(_, _, _, closure_span, None),\n-                            ..\n-                        }) => {\n-                            let sup_sp = sup_origin.span();\n-                            let origin_sp = origin.span();\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                sup_sp,\n-                                \"borrowed data cannot be stored outside of its closure\");\n-                            err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n-                            if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n+                    if let Node::Expr(Expr {\n+                        node: Closure(_, _, _, closure_span, None),\n+                        ..\n+                    }) = hir.get(node_id) {\n+                        let sup_sp = sup_origin.span();\n+                        let origin_sp = origin.span();\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            sup_sp,\n+                            \"borrowed data cannot be stored outside of its closure\");\n+                        err.span_label(sup_sp, \"cannot be stored outside of its closure\");\n+                        if origin_sp == sup_sp || origin_sp.contains(sup_sp) {\n // // sup_sp == origin.span():\n //\n // let mut x = None;\n@@ -87,11 +86,11 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //                         ------------ ... because it cannot outlive this closure\n //     f = Some(x);\n //              ^ cannot be stored outside of its closure\n-                                err.span_label(*external_span,\n-                                               \"borrowed data cannot be stored into here...\");\n-                                err.span_label(*closure_span,\n-                                               \"...because it cannot outlive this closure\");\n-                            } else {\n+                            err.span_label(*external_span,\n+                                           \"borrowed data cannot be stored into here...\");\n+                            err.span_label(*closure_span,\n+                                           \"...because it cannot outlive this closure\");\n+                        } else {\n // FIXME: the wording for this case could be much improved\n //\n // let mut lines_to_use: Vec<&CrateId> = Vec::new();\n@@ -102,18 +101,16 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n //     ...so that variable is valid at time of its declaration\n //     lines_to_use.push(installed_id);\n //                       ^^^^^^^^^^^^ cannot be stored outside of its closure\n-                                err.span_label(origin_sp,\n-                                               \"cannot infer an appropriate lifetime...\");\n-                                err.span_label(*external_span,\n-                                               \"...so that variable is valid at time of its \\\n-                                                declaration\");\n-                                err.span_label(*closure_span,\n-                                               \"borrowed data cannot outlive this closure\");\n-                            }\n-                            err.emit();\n-                            return Some(ErrorReported);\n+                            err.span_label(origin_sp,\n+                                           \"cannot infer an appropriate lifetime...\");\n+                            err.span_label(*external_span,\n+                                           \"...so that variable is valid at time of its \\\n+                                            declaration\");\n+                            err.span_label(*closure_span,\n+                                           \"borrowed data cannot outlive this closure\");\n                         }\n-                        _ => {}\n+                        err.emit();\n+                        return Some(ErrorReported);\n                     }\n                 }\n             }"}, {"sha": "766173bf66283d4118d8250137a5e19daaf04381", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -20,64 +20,62 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {\n-            match error.clone() {\n-                RegionResolutionError::SubSupConflict(\n+            if let RegionResolutionError::SubSupConflict(\n                     var_origin,\n                     sub_origin,\n                     sub_r,\n                     sup_origin,\n                     sup_r,\n-                ) => {\n-                    let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n-                    if sub_r == &RegionKind::ReStatic &&\n-                        self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n-                    {\n-                        let sp = var_origin.span();\n-                        let return_sp = sub_origin.span();\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            sp,\n-                            \"cannot infer an appropriate lifetime\",\n+                ) = error.clone()\n+            {\n+                let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n+                if sub_r == &RegionKind::ReStatic &&\n+                    self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n+                {\n+                    let sp = var_origin.span();\n+                    let return_sp = sub_origin.span();\n+                    let mut err = self.tcx.sess.struct_span_err(\n+                        sp,\n+                        \"cannot infer an appropriate lifetime\",\n+                    );\n+                    err.span_label(\n+                        return_sp,\n+                        \"this return type evaluates to the `'static` lifetime...\",\n+                    );\n+                    err.span_label(\n+                        sup_origin.span(),\n+                        \"...but this borrow...\",\n+                    );\n+\n+                    let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n+                    if let Some(lifetime_sp) = lt_sp_opt {\n+                        err.span_note(\n+                            lifetime_sp,\n+                            &format!(\"...can't outlive {}\", lifetime),\n                         );\n-                        err.span_label(\n+                    }\n+\n+                    let lifetime_name = match sup_r {\n+                        RegionKind::ReFree(FreeRegion {\n+                            bound_region: BoundRegion::BrNamed(_, ref name), ..\n+                        }) => name.to_string(),\n+                        _ => \"'_\".to_owned(),\n+                    };\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n+                        err.span_suggestion_with_applicability(\n                             return_sp,\n-                            \"this return type evaluates to the `'static` lifetime...\",\n+                            &format!(\n+                                \"you can add a constraint to the return type to make it last \\\n+                                 less than `'static` and match {}\",\n+                                lifetime,\n+                            ),\n+                            format!(\"{} + {}\", snippet, lifetime_name),\n+                            Applicability::Unspecified,\n                         );\n-                        err.span_label(\n-                            sup_origin.span(),\n-                            \"...but this borrow...\",\n-                        );\n-\n-                        let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n-                        if let Some(lifetime_sp) = lt_sp_opt {\n-                            err.span_note(\n-                                lifetime_sp,\n-                                &format!(\"...can't outlive {}\", lifetime),\n-                            );\n-                        }\n-\n-                        let lifetime_name = match sup_r {\n-                            RegionKind::ReFree(FreeRegion {\n-                                bound_region: BoundRegion::BrNamed(_, ref name), ..\n-                            }) => name.to_string(),\n-                            _ => \"'_\".to_owned(),\n-                        };\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n-                            err.span_suggestion_with_applicability(\n-                                return_sp,\n-                                &format!(\n-                                    \"you can add a constraint to the return type to make it last \\\n-                                     less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                        err.emit();\n-                        return Some(ErrorReported);\n                     }\n+                    err.emit();\n+                    return Some(ErrorReported);\n                 }\n-                _ => {}\n             }\n         }\n         None"}, {"sha": "013c02f75b88315f1a7f776d2ed8d70c93e4522d", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -119,16 +119,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         decl: &hir::FnDecl,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n-        match ret_ty.sty {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(self.tcx);\n-                let late_bound_regions = self.tcx\n-                    .collect_referenced_late_bound_regions(&sig.output());\n-                if late_bound_regions.iter().any(|r| *r == br) {\n-                    return Some(decl.output.span());\n-                }\n+        if let ty::FnDef(_, _) = ret_ty.sty {\n+            let sig = ret_ty.fn_sig(self.tcx);\n+            let late_bound_regions = self.tcx\n+                .collect_referenced_late_bound_regions(&sig.output());\n+            if late_bound_regions.iter().any(|r| *r == br) {\n+                return Some(decl.output.span());\n             }\n-            _ => {}\n         }\n         None\n     }\n@@ -140,8 +137,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n         is_first\n             && self.tcx\n-                .opt_associated_item(scope_def_id)\n-                .map(|i| i.method_has_self_argument) == Some(true)\n+                   .opt_associated_item(scope_def_id)\n+                   .map(|i| i.method_has_self_argument) == Some(true)\n     }\n \n }"}, {"sha": "b55727d2c84f0902a5d8f266d783c6d77314400e", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -112,12 +112,9 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    match dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        Ok(()) => {}\n-        Err(e) => {\n-            let msg = format!(\"io error dumping region constraints: {}\", e);\n-            tcx.sess.err(&msg)\n-        }\n+    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n+        let msg = format!(\"io error dumping region constraints: {}\", e);\n+        tcx.sess.err(&msg)\n     }\n }\n \n@@ -187,12 +184,9 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n             None => bug!(\"no node_id found for node: {:?}\", n),\n         };\n         let name = || format!(\"node_{}\", node_id);\n-        match dot::Id::new(name()) {\n-            Ok(id) => id,\n-            Err(_) => {\n-                bug!(\"failed to create graphviz node identified by {}\", name());\n-            }\n-        }\n+\n+        dot::Id::new(name()).unwrap_or_else(|_|\n+            bug!(\"failed to create graphviz node identified by {}\", name()))\n     }\n     fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n         match *n {\n@@ -204,7 +198,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         match *e {\n             Edge::Constraint(ref c) =>\n                 dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap())),\n-            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_string()),\n+            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_owned()),\n         }\n     }\n }"}, {"sha": "ca49d053210c7c0026ada442afc0ca14f55bed34", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -147,9 +147,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.types.re_static,\n-            values: (0..self.num_vars())\n-                .map(|_| VarValue::Value(tcx.types.re_empty))\n-                .collect(),\n+            values: IndexVec::from_elem_n(VarValue::Value(tcx.types.re_empty), self.num_vars())\n         }\n     }\n "}, {"sha": "49858972416d8f1c025b18e4fbd256d9a47bf87a", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -803,6 +803,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n+        self.obligations.reserve(bounds.predicates.len());\n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type."}, {"sha": "87bfbaef54c4e7748bf3cb6dee249b4fcf2b3ea2", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -443,7 +443,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n         if snapshot.length == 0 {\n-            self.undo_log.truncate(0);\n+            self.undo_log.clear();\n         } else {\n             (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n@@ -661,11 +661,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        match verify.bound {\n-            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => {\n+        if let VerifyBound::AllBounds(ref bs) = verify.bound {\n+            if bs.len() == 0 {\n                 return;\n             }\n-            _ => {}\n         }\n \n         let index = self.data.verifys.len();"}, {"sha": "0ef97618572640f4ac5e1003963d1a3e56c7971b", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -153,8 +153,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.needs_infer() && !ty::keep_local(&t) {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n-                // ^ we need to have the `keep_local` check to un-default\n-                // defaulted tuples.\n+              // ^ we need to have the `keep_local` check to un-default\n+              // defaulted tuples.\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {"}, {"sha": "970b6e096ffe4d04370e482d43e079e29daa214e", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -273,11 +273,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n         debug!(\"rollback_to{:?}\", {\n             for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                match *action {\n-                    sv::UndoLog::NewElem(index) => {\n-                        debug!(\"inference variable _#{}t popped\", index)\n-                    }\n-                    _ => { }\n+                if let sv::UndoLog::NewElem(index) = *action {\n+                    debug!(\"inference variable _#{}t popped\", index)\n                 }\n             }\n         });"}, {"sha": "87d33e473e7f6cd97bc392e3f6bf926518744264", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -18,7 +18,7 @@ use lint::context::CheckLintNameResult;\n use lint::{self, Lint, LintId, Level, LintSource};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n-use session::Session;\n+use session::{config::nightly_options, Session};\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n@@ -299,7 +299,13 @@ impl<'a> LintLevelsBuilder<'a> {\n                                     \"change it to\",\n                                     new_lint_name.to_string(),\n                                     Applicability::MachineApplicable,\n-                                ).emit();\n+                                );\n+\n+                                if nightly_options::is_nightly_build() {\n+                                    err.emit();\n+                                } else {\n+                                    err.cancel();\n+                                }\n \n                                 let src = LintSource::Node(Symbol::intern(&new_lint_name), li.span);\n                                 for id in ids {"}, {"sha": "c532b5ee56f47d2d908cf442795842f84b0182e5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -1322,8 +1322,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n-    disable_ast_check_for_mutation_in_guard: bool = (false, parse_bool, [UNTRACKED],\n-        \"skip AST-based mutation-in-guard check (mir-borrowck provides more precise check)\"),\n     nll_subminimal_causes: bool = (false, parse_bool, [UNTRACKED],\n         \"when tracking region error causes, accept subminimal results for faster execution.\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "64e9d15092eb8d0aa74524ec0931bfdbc9531f39", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -1467,11 +1467,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If true, we should use a naive AST walk to determine if match\n     /// guard could perform bad mutations (or mutable-borrows).\n     pub fn check_for_mutation_in_guard_via_ast_walk(self) -> bool {\n-        // If someone passes the `-Z` flag, they're asking for the footgun.\n-        if self.sess.opts.debugging_opts.disable_ast_check_for_mutation_in_guard {\n-            return false;\n-        }\n-\n         // If someone requests the feature, then be a little more\n         // careful and ensure that MIR-borrowck is enabled (which can\n         // happen via edition selection, via `feature(nll)`, or via an"}, {"sha": "547f7cecc4e060c404ab65ee49b6a5b23722790d", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -702,7 +702,12 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n             (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n                 Ok(relation.relate(&a_ty, &b_ty)?.into())\n             }\n-            (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => bug!()\n+            (UnpackedKind::Lifetime(unpacked), x) => {\n+                bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n+            }\n+            (UnpackedKind::Type(unpacked), x) => {\n+                bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n+            }\n         }\n     }\n }"}, {"sha": "a5905df57c8cfd62f9624adb2bc030ab39d76cd6", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -31,6 +31,7 @@ fn main() {\n             .out_dir(&native.out_dir)\n             .build_target(&target)\n             .build();\n+        native.fixup_sanitizer_lib_name(\"asan\");\n     }\n     println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "eff80a98c9de905a6b293fea73d7c2c8aa08743f", "filename": "src/librustc_data_structures/work_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_data_structures%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_data_structures%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fwork_queue.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -53,7 +53,7 @@ impl<T: Idx> WorkQueue<T> {\n         }\n     }\n \n-    /// Attempt to enqueue `element` in the work queue. Returns false if it was already present.\n+    /// Attempt to pop an element from the work queue.\n     #[inline]\n     pub fn pop(&mut self) -> Option<T> {\n         if let Some(element) = self.deque.pop_front() {"}, {"sha": "15bf837b526b1b2e8fdc436346f2884cbbff5e0c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -3147,11 +3147,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             // parser issue where a struct literal is being used on an expression\n                             // where a brace being opened means a block is being started. Look\n                             // ahead for the next text to see if `span` is followed by a `{`.\n-                            let cm = this.session.source_map();\n+                            let sm = this.session.source_map();\n                             let mut sp = span;\n                             loop {\n-                                sp = cm.next_point(sp);\n-                                match cm.span_to_snippet(sp) {\n+                                sp = sm.next_point(sp);\n+                                match sm.span_to_snippet(sp) {\n                                     Ok(ref snippet) => {\n                                         if snippet.chars().any(|c| { !c.is_whitespace() }) {\n                                             break;\n@@ -3160,20 +3160,51 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                     _ => break,\n                                 }\n                             }\n-                            let followed_by_brace = match cm.span_to_snippet(sp) {\n+                            let followed_by_brace = match sm.span_to_snippet(sp) {\n                                 Ok(ref snippet) if snippet == \"{\" => true,\n                                 _ => false,\n                             };\n-                            if let (PathSource::Expr(None), true) = (source, followed_by_brace) {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                                );\n+                            match source {\n+                                PathSource::Expr(Some(parent)) => {\n+                                    match parent.node {\n+                                        ExprKind::MethodCall(ref path_assignment, _)  => {\n+                                            err.span_suggestion_with_applicability(\n+                                                sm.start_point(parent.span)\n+                                                  .to(path_assignment.ident.span),\n+                                                \"use `::` to access an associated function\",\n+                                                format!(\"{}::{}\",\n+                                                        path_str,\n+                                                        path_assignment.ident),\n+                                                Applicability::MaybeIncorrect\n+                                            );\n+                                            return (err, candidates);\n+                                        },\n+                                        _ => {\n+                                            err.span_label(\n+                                                span,\n+                                                format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                                        path_str),\n+                                            );\n+                                            return (err, candidates);\n+                                        },\n+                                    }\n+                                },\n+                                PathSource::Expr(None) if followed_by_brace == true => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `({} {{ /* fields */ }})`?\",\n+                                                path_str),\n+                                    );\n+                                    return (err, candidates);\n+                                },\n+                                _ => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                                path_str),\n+                                    );\n+                                    return (err, candidates);\n+                                },\n                             }\n                         }\n                         return (err, candidates);"}, {"sha": "d23c71e2c1286cf9fdecf0eff3948e2a9fa70dc4", "filename": "src/librustc_tsan/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_tsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_tsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Fbuild.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -31,6 +31,7 @@ fn main() {\n             .out_dir(&native.out_dir)\n             .build_target(&target)\n             .build();\n+        native.fixup_sanitizer_lib_name(\"tsan\");\n     }\n     println!(\"cargo:rerun-if-env-changed=LLVM_CONFIG\");\n }"}, {"sha": "62ffffab07661304f48df4af1bdd9a0baa587413", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -138,9 +138,15 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n         if extern_crate.warn_if_unused {\n             if let Some(&span) = unused_extern_crates.get(&extern_crate.def_id) {\n                 let msg = \"unused extern crate\";\n+\n+                // Removal suggestion span needs to include attributes (Issue #54400)\n+                let span_with_attrs = tcx.get_attrs(extern_crate.def_id).iter()\n+                    .map(|attr| attr.span)\n+                    .fold(span, |acc, attr_span| acc.to(attr_span));\n+\n                 tcx.struct_span_lint_node(lint, id, span, msg)\n                     .span_suggestion_short_with_applicability(\n-                        span,\n+                        span_with_attrs,\n                         \"remove it\",\n                         String::new(),\n                         Applicability::MachineApplicable)"}, {"sha": "10a4678107e1c88cb44f69313055f20ced709ac8", "filename": "src/test/run-pass/issues/issue-24535-allow-mutable-borrow-in-match-guard.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -12,12 +12,11 @@\n // This test illustrates that under NLL, we can remove our overly\n // conservative approach for disallowing mutations of match inputs.\n \n-// See further discussion on rust-lang/rust#24535 and\n-// rust-lang/rfcs#1006.\n-\n-// compile-flags: -Z disable-ast-check-for-mutation-in-guard\n+// See further discussion on rust-lang/rust#24535,\n+// rust-lang/rfcs#1006, and rust-lang/rfcs#107\n \n #![feature(nll)]\n+#![feature(bind_by_move_pattern_guards)]\n \n fn main() {\n     rust_issue_24535();"}, {"sha": "82bc6194483c04234e920f1ed53e019a9545134b", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_bindings.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -9,12 +9,16 @@ error[E0562]: `impl Trait` not allowed outside of function and inherent method r\n    |\n LL | const FOO: impl Copy = 42;\n    |            ^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n   --> $DIR/feature-gate-impl_trait_in_bindings.rs:13:13\n    |\n LL | static BAR: impl Copy = 42;\n    |             ^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c43271c7371d27b27ff05c5815882206f37ec9cc", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -231,6 +231,8 @@ error[E0562]: `impl Trait` not allowed outside of function and inherent method r\n    |\n LL |     let _in_local_variable: impl Fn() = || {};\n    |                             ^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n   --> $DIR/where-allowed.rs:232:46"}, {"sha": "6cbd493b9918207623952629ac01f00eb983f83b", "filename": "src/test/ui/issues/issue-27282-reborrow-ref-mut-in-guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fissues%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fissues%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-reborrow-ref-mut-in-guard.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -15,8 +15,8 @@\n // reject it. But I want to make sure that we continue to reject it\n // (under NLL) even when that conservaive check goes away.\n \n-// compile-flags: -Z disable-ast-check-for-mutation-in-guard\n \n+#![feature(bind_by_move_pattern_guards)]\n #![feature(nll)]\n \n fn main() {"}, {"sha": "f359800812c87a733ccf55b00b75a79cbcd0a041", "filename": "src/test/ui/nll/match-guards-partially-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -5,8 +5,8 @@\n // Test that we don't allow mutating the value being matched on in a way that\n // changes which patterns it matches, until we have chosen an arm.\n \n-// compile-flags: -Zdisable-ast-check-for-mutation-in-guard\n \n+#![feature(bind_by_move_pattern_guards)]\n #![feature(nll)]\n \n fn ok_mutation_in_guard(mut q: i32) {"}, {"sha": "06648c599534f60ba1a85145e8107c982ca44198", "filename": "src/test/ui/resolve/issue-22692.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _ = String.new();\n+}"}, {"sha": "ecdd4ff855fb930c6abbc200dfa851bed9ad2040", "filename": "src/test/ui/resolve/issue-22692.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -0,0 +1,11 @@\n+error[E0423]: expected value, found struct `String`\n+  --> $DIR/issue-22692.rs:12:13\n+   |\n+LL |     let _ = String.new();\n+   |             ^^^^^^----\n+   |             |\n+   |             help: use `::` to access an associated function: `String::new`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0423`."}, {"sha": "20ebe6bb543362cf1a64ef8088e0b518d77d90f5", "filename": "src/test/ui/rust-2018/issue-54400-unused-extern-crate-attr-span.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.fixed?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:edition-lint-paths.rs\n+// run-rustfix\n+// compile-flags:--extern edition_lint_paths --cfg blandiloquence\n+// edition:2018\n+\n+#![deny(rust_2018_idioms)]\n+#![allow(dead_code)]\n+\n+// The suggestion span should include the attribute.\n+\n+\n+//~^ ERROR unused extern crate\n+\n+fn main() {}"}, {"sha": "11febe5e87d86666c963511a8f944889043191a3", "filename": "src/test/ui/rust-2018/issue-54400-unused-extern-crate-attr-span.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.rs?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:edition-lint-paths.rs\n+// run-rustfix\n+// compile-flags:--extern edition_lint_paths --cfg blandiloquence\n+// edition:2018\n+\n+#![deny(rust_2018_idioms)]\n+#![allow(dead_code)]\n+\n+// The suggestion span should include the attribute.\n+\n+#[cfg(blandiloquence)] //~ HELP remove it\n+extern crate edition_lint_paths;\n+//~^ ERROR unused extern crate\n+\n+fn main() {}"}, {"sha": "cb945ba1c78d1dea9341e5abb503872c795eb8b6", "filename": "src/test/ui/rust-2018/issue-54400-unused-extern-crate-attr-span.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6188c58a55a27efac25f6e50a8e5f18c2650b60f/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fissue-54400-unused-extern-crate-attr-span.stderr?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -0,0 +1,18 @@\n+error: unused extern crate\n+  --> $DIR/issue-54400-unused-extern-crate-attr-span.rs:22:1\n+   |\n+LL | / #[cfg(blandiloquence)] //~ HELP remove it\n+LL | | extern crate edition_lint_paths;\n+   | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   | |________________________________|\n+   |                                  help: remove it\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-54400-unused-extern-crate-attr-span.rs:16:9\n+   |\n+LL | #![deny(rust_2018_idioms)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: #[deny(unused_extern_crates)] implied by #[deny(rust_2018_idioms)]\n+\n+error: aborting due to previous error\n+"}, {"sha": "e8f6973e2d40ab39e30cdbe0cf8e77a72c867d4f", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=6188c58a55a27efac25f6e50a8e5f18c2650b60f", "patch": "@@ -1 +1 @@\n-Subproject commit 130d803b3243a92f5c2d9230935cba7fa88e263e\n+Subproject commit e8f6973e2d40ab39e30cdbe0cf8e77a72c867d4f"}]}