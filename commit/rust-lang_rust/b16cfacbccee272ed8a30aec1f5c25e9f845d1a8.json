{"sha": "b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNmNmYWNiY2NlZTI3MmVkOGEzMGFlYzFmNWMyNWU5Zjg0NWQxYTg=", "commit": {"author": {"name": "Christopher Chambers", "email": "chris.chambers@peanutcode.com", "date": "2015-04-11T02:50:23Z"}, "committer": {"name": "Christopher Chambers", "email": "chris.chambers@peanutcode.com", "date": "2015-04-11T02:50:23Z"}, "message": "Improves semicolon expansion efficiency, corrects bt_pop placement.\n\nImplements pop() on SmallVector, and uses it to expand the final semicolon\nin a statement macro expansion more efficiently.\n\nCorrects the placement of the call to fld.cx.bt_pop().  It must run\nunconditionally to reverse the corresponding push.", "tree": {"sha": "47cefbeacca81d789e8462d3ce82f787fbd13edb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47cefbeacca81d789e8462d3ce82f787fbd13edb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "html_url": "https://github.com/rust-lang/rust/commit/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8/comments", "author": {"login": "chris-chambers", "id": 6810256, "node_id": "MDQ6VXNlcjY4MTAyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/6810256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-chambers", "html_url": "https://github.com/chris-chambers", "followers_url": "https://api.github.com/users/chris-chambers/followers", "following_url": "https://api.github.com/users/chris-chambers/following{/other_user}", "gists_url": "https://api.github.com/users/chris-chambers/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-chambers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-chambers/subscriptions", "organizations_url": "https://api.github.com/users/chris-chambers/orgs", "repos_url": "https://api.github.com/users/chris-chambers/repos", "events_url": "https://api.github.com/users/chris-chambers/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-chambers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chris-chambers", "id": 6810256, "node_id": "MDQ6VXNlcjY4MTAyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/6810256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-chambers", "html_url": "https://github.com/chris-chambers", "followers_url": "https://api.github.com/users/chris-chambers/followers", "following_url": "https://api.github.com/users/chris-chambers/following{/other_user}", "gists_url": "https://api.github.com/users/chris-chambers/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-chambers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-chambers/subscriptions", "organizations_url": "https://api.github.com/users/chris-chambers/orgs", "repos_url": "https://api.github.com/users/chris-chambers/repos", "events_url": "https://api.github.com/users/chris-chambers/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-chambers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19343860aa44d1c31a7802df22349f055ed9da16", "url": "https://api.github.com/repos/rust-lang/rust/commits/19343860aa44d1c31a7802df22349f055ed9da16", "html_url": "https://github.com/rust-lang/rust/commit/19343860aa44d1c31a7802df22349f055ed9da16"}], "stats": {"total": 67, "additions": 51, "deletions": 16}, "files": [{"sha": "9c1b32aadbda547ba4a5d4a9fe4e8c29a8d43d40", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "patch": "@@ -758,39 +758,38 @@ fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n                          |stmts, mark| stmts.move_map(|m| mark_stmt(m, mark)),\n                          fld);\n \n-    let fully_expanded = match maybe_new_items {\n+    let mut fully_expanded = match maybe_new_items {\n         Some(stmts) => {\n             // Keep going, outside-in.\n-            let new_items = stmts.into_iter().flat_map(|s| {\n+            stmts.into_iter().flat_map(|s| {\n                 fld.fold_stmt(s).into_iter()\n-            }).collect();\n-            fld.cx.bt_pop();\n-            new_items\n+            }).collect()\n         }\n         None => SmallVector::zero()\n     };\n+    fld.cx.bt_pop();\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n-    if style == MacStmtWithSemicolon && fully_expanded.len() > 0 {\n-        let last_index = fully_expanded.len() - 1;\n-        fully_expanded.into_iter().enumerate().map(|(i, stmt)|\n-            if i == last_index {\n-                stmt.map(|Spanned {node, span}| {\n+    if style == MacStmtWithSemicolon && !fully_expanded.is_empty() {\n+        match fully_expanded.pop() {\n+            Some(stmt) => {\n+                let new_stmt = stmt.map(|Spanned {node, span}| {\n                     Spanned {\n                         node: match node {\n                             StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n                             _ => node /* might already have a semi */\n                         },\n                         span: span\n                     }\n-                })\n-            } else {\n-                stmt\n-            }).collect()\n-    } else {\n-        fully_expanded\n+                });\n+                fully_expanded.push(new_stmt);\n+            }\n+            None => (),\n+        }\n     }\n+\n+    fully_expanded\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for"}, {"sha": "c4b096d656f1b55a655903dd33a490e2bc07528c", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b16cfacbccee272ed8a30aec1f5c25e9f845d1a8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=b16cfacbccee272ed8a30aec1f5c25e9f845d1a8", "patch": "@@ -69,6 +69,42 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n+    pub fn pop(&mut self) -> Option<T> {\n+        match self.repr {\n+            Zero => None,\n+            One(..) => {\n+                let one = mem::replace(&mut self.repr, Zero);\n+                match one {\n+                    One(v1) => Some(v1),\n+                    _ => unreachable!()\n+                }\n+            }\n+            Many(..) => {\n+                let mut many = mem::replace(&mut self.repr, Zero);\n+                let item =\n+                    match many {\n+                        Many(ref mut vs) if vs.len() == 1 => {\n+                            // self.repr is already Zero\n+                            vs.pop()\n+                        },\n+                        Many(ref mut vs) if vs.len() == 2 => {\n+                            let item = vs.pop();\n+                            mem::replace(&mut self.repr, One(vs.pop().unwrap()));\n+                            item\n+                        },\n+                        Many(ref mut vs) if vs.len() > 2 => {\n+                            let item = vs.pop();\n+                            let rest = mem::replace(vs, vec!());\n+                            mem::replace(&mut self.repr, Many(rest));\n+                            item\n+                        },\n+                        _ => unreachable!()\n+                    };\n+                item\n+            }\n+        }\n+    }\n+\n     pub fn push(&mut self, v: T) {\n         match self.repr {\n             Zero => self.repr = One(v),"}]}