{"sha": "74dd65edfe640e0c37979031abfb1a8ad2b7785b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZGQ2NWVkZmU2NDBlMGMzNzk3OTAzMWFiZmIxYThhZDJiNzc4NWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:06:02Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:06:02Z"}, "message": "typeck/expr.rs: extract out check_expr_break.", "tree": {"sha": "8f7eda780dbc547fb33bb3b816c8878b05fb8246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f7eda780dbc547fb33bb3b816c8878b05fb8246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74dd65edfe640e0c37979031abfb1a8ad2b7785b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74dd65edfe640e0c37979031abfb1a8ad2b7785b", "html_url": "https://github.com/rust-lang/rust/commit/74dd65edfe640e0c37979031abfb1a8ad2b7785b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74dd65edfe640e0c37979031abfb1a8ad2b7785b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "html_url": "https://github.com/rust-lang/rust/commit/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a"}], "stats": {"total": 176, "additions": 93, "deletions": 83}, "files": [{"sha": "bb8f331578a3d066feee782977f8db1ba7036620", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 92, "deletions": 83, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/74dd65edfe640e0c37979031abfb1a8ad2b7785b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dd65edfe640e0c37979031abfb1a8ad2b7785b/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=74dd65edfe640e0c37979031abfb1a8ad2b7785b", "patch": "@@ -76,89 +76,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.mk_unit()\n             }\n             ExprKind::Break(destination, ref expr_opt) => {\n-                if let Ok(target_id) = destination.target_id {\n-                    let (e_ty, cause);\n-                    if let Some(ref e) = *expr_opt {\n-                        // If this is a break with a value, we need to type-check\n-                        // the expression. Get an expected type from the loop context.\n-                        let opt_coerce_to = {\n-                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                            enclosing_breakables.find_breakable(target_id)\n-                                                .coerce\n-                                                .as_ref()\n-                                                .map(|coerce| coerce.expected_ty())\n-                        };\n-\n-                        // If the loop context is not a `loop { }`, then break with\n-                        // a value is illegal, and `opt_coerce_to` will be `None`.\n-                        // Just set expectation to error in that case.\n-                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n-\n-                        // Recurse without `enclosing_breakables` borrowed.\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                    } else {\n-                        // Otherwise, this is a break *without* a value. That's\n-                        // always legal, and is equivalent to `break ()`.\n-                        e_ty = tcx.mk_unit();\n-                        cause = self.misc(expr.span);\n-                    }\n-\n-                    // Now that we have type-checked `expr_opt`, borrow\n-                    // the `enclosing_loops` field and let's coerce the\n-                    // type of `expr_opt` into what is expected.\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    let ctxt = enclosing_breakables.find_breakable(target_id);\n-                    if let Some(ref mut coerce) = ctxt.coerce {\n-                        if let Some(ref e) = *expr_opt {\n-                            coerce.coerce(self, &cause, e, e_ty);\n-                        } else {\n-                            assert!(e_ty.is_unit());\n-                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                        }\n-                    } else {\n-                        // If `ctxt.coerce` is `None`, we can just ignore\n-                        // the type of the expresison.  This is because\n-                        // either this was a break *without* a value, in\n-                        // which case it is always a legal type (`()`), or\n-                        // else an error would have been flagged by the\n-                        // `loops` pass for using break with an expression\n-                        // where you are not supposed to.\n-                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n-                    }\n-\n-                    ctxt.may_break = true;\n-\n-                    // the type of a `break` is always `!`, since it diverges\n-                    tcx.types.never\n-                } else {\n-                    // Otherwise, we failed to find the enclosing loop;\n-                    // this can only happen if the `break` was not\n-                    // inside a loop at all, which is caught by the\n-                    // loop-checking pass.\n-                    if self.tcx.sess.err_count() == 0 {\n-                        self.tcx.sess.delay_span_bug(expr.span,\n-                            \"break was outside loop, but no error was emitted\");\n-                    }\n-\n-                    // We still need to assign a type to the inner expression to\n-                    // prevent the ICE in #43162.\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr_with_hint(e, tcx.types.err);\n-\n-                        // ... except when we try to 'break rust;'.\n-                        // ICE this expression in particular (see #43162).\n-                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 &&\n-                               path.segments[0].ident.name == sym::rust {\n-                                fatally_break_rust(self.tcx.sess);\n-                            }\n-                        }\n-                    }\n-                    // There was an error; make type-check fail.\n-                    tcx.types.err\n-                }\n-\n+                self.check_expr_break(destination, expr_opt.deref(), expr)\n             }\n             ExprKind::Continue(destination) => {\n                 if destination.target_id.is_ok() {\n@@ -725,4 +643,95 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         ty\n     }\n+\n+    fn check_expr_break(\n+        &self,\n+        destination: hir::Destination,\n+        expr_opt: Option<&'tcx hir::Expr>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        if let Ok(target_id) = destination.target_id {\n+            let (e_ty, cause);\n+            if let Some(ref e) = expr_opt {\n+                // If this is a break with a value, we need to type-check\n+                // the expression. Get an expected type from the loop context.\n+                let opt_coerce_to = {\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    enclosing_breakables.find_breakable(target_id)\n+                                        .coerce\n+                                        .as_ref()\n+                                        .map(|coerce| coerce.expected_ty())\n+                };\n+\n+                // If the loop context is not a `loop { }`, then break with\n+                // a value is illegal, and `opt_coerce_to` will be `None`.\n+                // Just set expectation to error in that case.\n+                let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                // Recurse without `enclosing_breakables` borrowed.\n+                e_ty = self.check_expr_with_hint(e, coerce_to);\n+                cause = self.misc(e.span);\n+            } else {\n+                // Otherwise, this is a break *without* a value. That's\n+                // always legal, and is equivalent to `break ()`.\n+                e_ty = tcx.mk_unit();\n+                cause = self.misc(expr.span);\n+            }\n+\n+            // Now that we have type-checked `expr_opt`, borrow\n+            // the `enclosing_loops` field and let's coerce the\n+            // type of `expr_opt` into what is expected.\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(target_id);\n+            if let Some(ref mut coerce) = ctxt.coerce {\n+                if let Some(ref e) = expr_opt {\n+                    coerce.coerce(self, &cause, e, e_ty);\n+                } else {\n+                    assert!(e_ty.is_unit());\n+                    coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                }\n+            } else {\n+                // If `ctxt.coerce` is `None`, we can just ignore\n+                // the type of the expresison.  This is because\n+                // either this was a break *without* a value, in\n+                // which case it is always a legal type (`()`), or\n+                // else an error would have been flagged by the\n+                // `loops` pass for using break with an expression\n+                // where you are not supposed to.\n+                assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+            }\n+\n+            ctxt.may_break = true;\n+\n+            // the type of a `break` is always `!`, since it diverges\n+            tcx.types.never\n+        } else {\n+            // Otherwise, we failed to find the enclosing loop;\n+            // this can only happen if the `break` was not\n+            // inside a loop at all, which is caught by the\n+            // loop-checking pass.\n+            if self.tcx.sess.err_count() == 0 {\n+                self.tcx.sess.delay_span_bug(expr.span,\n+                    \"break was outside loop, but no error was emitted\");\n+            }\n+\n+            // We still need to assign a type to the inner expression to\n+            // prevent the ICE in #43162.\n+            if let Some(ref e) = expr_opt {\n+                self.check_expr_with_hint(e, tcx.types.err);\n+\n+                // ... except when we try to 'break rust;'.\n+                // ICE this expression in particular (see #43162).\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+                    if path.segments.len() == 1 &&\n+                        path.segments[0].ident.name == sym::rust {\n+                        fatally_break_rust(self.tcx.sess);\n+                    }\n+                }\n+            }\n+            // There was an error; make type-check fail.\n+            tcx.types.err\n+        }\n+    }\n }"}, {"sha": "cc6f7a07d9621c841099ca8045a359097be8bb47", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74dd65edfe640e0c37979031abfb1a8ad2b7785b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dd65edfe640e0c37979031abfb1a8ad2b7785b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=74dd65edfe640e0c37979031abfb1a8ad2b7785b", "patch": "@@ -68,6 +68,7 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(never_type)]\n+#![feature(inner_deref)]\n \n #![recursion_limit=\"256\"]\n "}]}