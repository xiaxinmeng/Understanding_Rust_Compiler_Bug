{"sha": "7c7b22e62cd3aa34ef60ec98b145258caa55261f", "node_id": "C_kwDOAAsO6NoAKDdjN2IyMmU2MmNkM2FhMzRlZjYwZWM5OGIxNDUyNThjYWE1NTI2MWY", "commit": {"author": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2023-05-03T22:22:24Z"}, "committer": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2023-05-09T20:04:19Z"}, "message": "CFI: Fix SIGILL reached via trait objects\n\nFix #106547 by transforming the concrete self into a reference to a\ntrait object before emitting type metadata identifiers for trait\nmethods.", "tree": {"sha": "ca585ce832e8a356ca78d1b6da720dc853471707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca585ce832e8a356ca78d1b6da720dc853471707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c7b22e62cd3aa34ef60ec98b145258caa55261f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7b22e62cd3aa34ef60ec98b145258caa55261f", "html_url": "https://github.com/rust-lang/rust/commit/7c7b22e62cd3aa34ef60ec98b145258caa55261f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c7b22e62cd3aa34ef60ec98b145258caa55261f/comments", "author": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac35583d2ffb5ed9e564dee0822c9a244058ee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac35583d2ffb5ed9e564dee0822c9a244058ee0", "html_url": "https://github.com/rust-lang/rust/commit/eac35583d2ffb5ed9e564dee0822c9a244058ee0"}], "stats": {"total": 275, "additions": 247, "deletions": 28}, "files": [{"sha": "4b9ca2e7d19c3f9fb2cc9cbd3f040ddd31944bfc", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -94,11 +94,11 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n             // LLVM will prefix the name with `__imp_`. Ideally, we'd like the\n             // existing logic below to set the Storage Class, but it has an\n             // exemption for MinGW for backwards compatability.\n-            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi);\n+            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi, Some(instance));\n             unsafe { llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport); }\n             llfn\n         } else {\n-            cx.declare_fn(sym, fn_abi)\n+            cx.declare_fn(sym, fn_abi, Some(instance))\n         };\n         debug!(\"get_fn: not casting pointer!\");\n "}, {"sha": "cd261293e9b2dd2262a19056fd75cc1635347e8b", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -207,6 +207,7 @@ fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: DefId) -> Instance<\n             )),\n             ty::List::empty(),\n         ),\n+        None,\n     );\n \n     llvm::set_linkage(llfn, llvm::Linkage::PrivateLinkage);"}, {"sha": "164b12cf8d4118686fed81eeef0a50bc35d41664", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -19,8 +19,11 @@ use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::TypeMembershipMethods;\n-use rustc_middle::ty::Ty;\n-use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi, TypeIdOptions};\n+use rustc_middle::ty::{Instance, Ty};\n+use rustc_symbol_mangling::typeid::{\n+    kcfi_typeid_for_fnabi, kcfi_typeid_for_instance, typeid_for_fnabi, typeid_for_instance,\n+    TypeIdOptions,\n+};\n use smallvec::SmallVec;\n \n /// Declare a function.\n@@ -116,7 +119,12 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    pub fn declare_fn(\n+        &self,\n+        name: &str,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        instance: Option<Instance<'tcx>>,\n+    ) -> &'ll Value {\n         debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n         // Function addresses in Rust are never significant, allowing functions to\n@@ -132,18 +140,35 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         fn_abi.apply_attrs_llfn(self, llfn);\n \n         if self.tcx.sess.is_sanitizer_cfi_enabled() {\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::empty());\n-            self.set_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::GENERALIZE_POINTERS);\n-            self.add_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::NORMALIZE_INTEGERS);\n-            self.add_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(\n-                self.tcx,\n-                fn_abi,\n-                TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n-            );\n-            self.add_type_metadata(llfn, typeid);\n+            if let Some(instance) = instance {\n+                let typeid = typeid_for_instance(self.tcx, &instance, TypeIdOptions::empty());\n+                self.set_type_metadata(llfn, typeid);\n+                let typeid =\n+                    typeid_for_instance(self.tcx, &instance, TypeIdOptions::GENERALIZE_POINTERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid =\n+                    typeid_for_instance(self.tcx, &instance, TypeIdOptions::NORMALIZE_INTEGERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_instance(\n+                    self.tcx,\n+                    &instance,\n+                    TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n+                );\n+                self.add_type_metadata(llfn, typeid);\n+            } else {\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::empty());\n+                self.set_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::GENERALIZE_POINTERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::NORMALIZE_INTEGERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(\n+                    self.tcx,\n+                    fn_abi,\n+                    TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n+                );\n+                self.add_type_metadata(llfn, typeid);\n+            }\n         }\n \n         if self.tcx.sess.is_sanitizer_kcfi_enabled() {\n@@ -156,8 +181,13 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n                 options.insert(TypeIdOptions::NORMALIZE_INTEGERS);\n             }\n \n-            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi, options);\n-            self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            if let Some(instance) = instance {\n+                let kcfi_typeid = kcfi_typeid_for_instance(self.tcx, &instance, options);\n+                self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            } else {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi, options);\n+                self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            }\n         }\n \n         llfn"}, {"sha": "4e28034a8507b1df9ab5525c1949cf777821019b", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -772,7 +772,7 @@ fn gen_fn<'ll, 'tcx>(\n ) -> (&'ll Type, &'ll Value) {\n     let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n     let llty = fn_abi.llvm_type(cx);\n-    let llfn = cx.declare_fn(name, fn_abi);\n+    let llfn = cx.declare_fn(name, fn_abi, None);\n     cx.set_frame_pointer_type(llfn);\n     cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this."}, {"sha": "e8f8c321510a269d98f227bc2d208c8385b5d112", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n-        let lldecl = self.declare_fn(symbol_name, fn_abi);\n+        let lldecl = self.declare_fn(symbol_name, fn_abi, Some(instance));\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n         let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n         base::set_link_section(lldecl, attrs);"}, {"sha": "cda16e3a3f5661879b8edafa4490873c28c4e344", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -4,7 +4,7 @@\n /// For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler,\n /// see design document in the tracking issue #89653.\n use bitflags::bitflags;\n-use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n+use rustc_middle::ty::{FnSig, Instance, Ty, TyCtxt};\n use rustc_target::abi::call::FnAbi;\n use std::hash::Hasher;\n use twox_hash::XxHash64;\n@@ -38,6 +38,15 @@ pub fn typeid_for_fnsig<'tcx>(\n     typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options)\n }\n \n+/// Returns a type metadata identifier for the specified Instance.\n+pub fn typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_instance(tcx, instance, options)\n+}\n+\n /// Returns a KCFI type metadata identifier for the specified FnAbi.\n pub fn kcfi_typeid_for_fnabi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -63,3 +72,16 @@ pub fn kcfi_typeid_for_fnsig<'tcx>(\n     hash.write(typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options).as_bytes());\n     hash.finish() as u32\n }\n+\n+/// Returns a KCFI type metadata identifier for the specified Instance.\n+pub fn kcfi_typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> u32 {\n+    // A KCFI type metadata identifier is a 32-bit constant produced by taking the lower half of the\n+    // xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(typeid_itanium_cxx_abi::typeid_for_instance(tcx, instance, options).as_bytes());\n+    hash.finish() as u32\n+}"}, {"sha": "c281aa7e83a85d80140cf79e57df2ff70565a3ee", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -14,8 +14,8 @@ use rustc_errors::DiagnosticMessage;\n use rustc_hir as hir;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind, TermKind,\n-    Ty, TyCtxt, UintTy,\n+    self, Const, ExistentialPredicate, FloatTy, FnSig, Instance, IntTy, List, Region, RegionKind,\n+    TermKind, Ty, TyCtxt, UintTy,\n };\n use rustc_span::def_id::DefId;\n use rustc_span::sym;\n@@ -1010,3 +1010,56 @@ pub fn typeid_for_fnsig<'tcx>(\n \n     typeid\n }\n+\n+/// Returns a type metadata identifier for the specified Instance using the Itanium C++ ABI with\n+/// vendor extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+pub fn typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    let fn_abi = tcx\n+        .fn_abi_of_instance(tcx.param_env(instance.def_id()).and((*instance, ty::List::empty())))\n+        .unwrap_or_else(|instance| {\n+            bug!(\"typeid_for_instance: couldn't get fn_abi of instance {:?}\", instance)\n+        });\n+\n+    // If this instance is a method and self is a reference, get the impl it belongs to\n+    let impl_def_id = tcx.impl_of_method(instance.def_id());\n+    if impl_def_id.is_some() && !fn_abi.args.is_empty() && fn_abi.args[0].layout.ty.is_ref() {\n+        // If this impl is not an inherent impl, get the trait it implements\n+        if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id.unwrap()) {\n+            // Transform the concrete self into a reference to a trait object\n+            let existential_predicate = trait_ref.map_bound(|trait_ref| {\n+                ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                    tcx, trait_ref,\n+                ))\n+            });\n+            let existential_predicates = tcx.mk_poly_existential_predicates(&[ty::Binder::dummy(\n+                existential_predicate.skip_binder(),\n+            )]);\n+            // Is the concrete self mutable?\n+            let self_ty = if fn_abi.args[0].layout.ty.is_mutable_ptr() {\n+                tcx.mk_mut_ref(\n+                    tcx.lifetimes.re_erased,\n+                    tcx.mk_dynamic(existential_predicates, tcx.lifetimes.re_erased, ty::Dyn),\n+                )\n+            } else {\n+                tcx.mk_imm_ref(\n+                    tcx.lifetimes.re_erased,\n+                    tcx.mk_dynamic(existential_predicates, tcx.lifetimes.re_erased, ty::Dyn),\n+                )\n+            };\n+\n+            // Replace the concrete self in an fn_abi clone by the reference to a trait object\n+            let mut fn_abi = fn_abi.clone();\n+            // HACK(rcvalle): It is okay to not replace or update the entire ArgAbi here because the\n+            //   other fields are never used.\n+            fn_abi.args[0].layout.ty = self_ty;\n+\n+            return typeid_for_fnabi(tcx, &fn_abi, options);\n+        }\n+    }\n+\n+    typeid_for_fnabi(tcx, &fn_abi, options)\n+}"}, {"sha": "0aacc8ba5de95045eec06b1b97d6af0c866c9d3b", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -28,7 +28,7 @@ mod x86;\n mod x86_64;\n mod x86_win64;\n \n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum PassMode {\n     /// Ignore the argument.\n     ///\n@@ -211,7 +211,7 @@ impl Uniform {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct CastTarget {\n     pub prefix: [Option<Reg>; 8],\n     pub rest: Uniform,\n@@ -458,7 +458,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n /// Information about how to pass an argument to,\n /// or return a value from, a function, under some ABI.\n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAbi<'a, Ty> {\n     pub layout: TyAndLayout<'a, Ty>,\n     pub mode: PassMode,\n@@ -605,7 +605,7 @@ pub enum Conv {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct FnAbi<'a, Ty> {\n     /// The LLVM types of each argument.\n     pub args: Box<[ArgAbi<'a, Ty>]>,"}, {"sha": "ab5dcec7936ca2db6621aa9f2860e54d0ab54510", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-trait-objects.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -0,0 +1,44 @@\n+// Verifies that type metadata identifiers for trait objects are emitted correctly.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+trait Trait1 {\n+    fn foo(&self);\n+}\n+\n+struct Type1;\n+\n+impl Trait1 for Type1 {\n+    fn foo(&self) {\n+    }\n+}\n+\n+pub fn foo() {\n+    let a = Type1;\n+    a.foo();\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_cfi_emit_type_metadata_trait_objects::Type1 as sanitizer_cfi_emit_type_metadata_trait_objects::Trait1>::foo\n+}\n+\n+pub fn bar() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}bar{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0|%1}}, metadata !\"[[TYPE1:[[:print:]]+]]\")\n+}\n+\n+pub fn baz() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    a.foo();\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}baz{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_cfi_emit_type_metadata_trait_objects::Type1 as sanitizer_cfi_emit_type_metadata_trait_objects::Trait1>::foo\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0|%1}}, metadata !\"[[TYPE1:[[:print:]]+]]\")\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i64 0, !\"[[TYPE1]]\"}"}, {"sha": "81e0d9344f7e4413d88f4a31c1d8efdaad181b0d", "filename": "tests/codegen/sanitizer-kcfi-emit-type-metadata-trait-objects.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7c7b22e62cd3aa34ef60ec98b145258caa55261f/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7b22e62cd3aa34ef60ec98b145258caa55261f/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs?ref=7c7b22e62cd3aa34ef60ec98b145258caa55261f", "patch": "@@ -0,0 +1,69 @@\n+// Verifies that type metadata identifiers for trait objects are emitted correctly.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Copt-level=0\n+\n+#![crate_type=\"lib\"]\n+#![feature(arbitrary_self_types, no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+#[lang=\"receiver\"]\n+trait Receiver { }\n+#[lang=\"dispatch_from_dyn\"]\n+trait DispatchFromDyn<T> { }\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+#[lang = \"unsize\"]\n+trait Unsize<T: ?Sized> { }\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T: ?Sized> { }\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+#[lang=\"freeze\"]\n+trait Freeze { }\n+#[lang=\"drop_in_place\"]\n+fn drop_in_place_fn<T>() { }\n+\n+trait Trait1 {\n+    fn foo(&self);\n+}\n+\n+struct Type1;\n+\n+impl Trait1 for Type1 {\n+    fn foo(&self) {\n+    }\n+}\n+\n+pub fn foo() {\n+    let a = Type1;\n+    a.foo();\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_kcfi_emit_type_metadata_trait_objects::Type1 as sanitizer_kcfi_emit_type_metadata_trait_objects::Trait1>::foo\n+}\n+\n+pub fn bar() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}bar{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call void %0({{\\{\\}\\*|ptr}} align 1 {{%b\\.0|%_1}}){{.*}}[ \"kcfi\"(i32 [[TYPE1:[[:print:]]+]]) ]\n+}\n+\n+pub fn baz() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    a.foo();\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}baz{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_kcfi_emit_type_metadata_trait_objects::Type1 as sanitizer_kcfi_emit_type_metadata_trait_objects::Trait1>::foo\n+    // CHECK:       call void %0({{\\{\\}\\*|ptr}} align 1 {{%b\\.0|%_1}}){{.*}}[ \"kcfi\"(i32 [[TYPE1:[[:print:]]+]]) ]\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 [[TYPE1]]}"}]}