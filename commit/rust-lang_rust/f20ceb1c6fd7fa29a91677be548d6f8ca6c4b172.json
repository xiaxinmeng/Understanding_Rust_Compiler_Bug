{"sha": "f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "node_id": "C_kwDOAAsO6NoAKGYyMGNlYjFjNmZkN2ZhMjlhOTE2NzdiZTU0OGQ2ZjhjYTZjNGIxNzI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T20:33:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T20:33:06Z"}, "message": "Encode index of SourceFile along with span.", "tree": {"sha": "0ca3de1afd8d7fd9f648263550c4fa4ed91f9b45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca3de1afd8d7fd9f648263550c4fa4ed91f9b45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "html_url": "https://github.com/rust-lang/rust/commit/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55f46419afd2e49acfc6be176ad4aeadaa5686d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f46419afd2e49acfc6be176ad4aeadaa5686d7", "html_url": "https://github.com/rust-lang/rust/commit/55f46419afd2e49acfc6be176ad4aeadaa5686d7"}], "stats": {"total": 134, "additions": 65, "deletions": 69}, "files": [{"sha": "444b58841873273376d2b1ba9e0e40b199763ae6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "patch": "@@ -527,6 +527,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n+        // Index of the file in the corresponding crate's list of encoded files.\n+        let metadata_index = usize::decode(decoder);\n+\n         // There are two possibilities here:\n         // 1. This is a 'local span', which is located inside a `SourceFile`\n         // that came from this crate. In this case, we use the source map data\n@@ -587,27 +590,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             foreign_data.imported_source_files(sess)\n         };\n \n-        let source_file = {\n-            // Optimize for the case that most spans within a translated item\n-            // originate from the same source_file.\n-            let last_source_file = &imported_source_files[decoder.last_source_file_index];\n-\n-            if lo >= last_source_file.original_start_pos && lo <= last_source_file.original_end_pos\n-            {\n-                last_source_file\n-            } else {\n-                let index = imported_source_files\n-                    .binary_search_by_key(&lo, |source_file| source_file.original_start_pos)\n-                    .unwrap_or_else(|index| index - 1);\n-\n-                // Don't try to cache the index for foreign spans,\n-                // as this would require a map from CrateNums to indices\n-                if tag == TAG_VALID_SPAN_LOCAL {\n-                    decoder.last_source_file_index = index;\n-                }\n-                &imported_source_files[index]\n-            }\n-        };\n+        // Optimize for the case that most spans within a translated item\n+        // originate from the same source_file.\n+        let source_file = &imported_source_files[metadata_index];\n \n         // Make sure our binary search above is correct.\n         debug_assert!(\n@@ -1545,7 +1530,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             let external_source_map = self.root.source_map.decode(self);\n \n             external_source_map\n-                .map(|source_file_to_import| {\n+                .enumerate()\n+                .map(|(source_file_index, source_file_to_import)| {\n                     // We can't reuse an existing SourceFile, so allocate a new one\n                     // containing the information we need.\n                     let rustc_span::SourceFile {\n@@ -1605,6 +1591,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         normalized_pos,\n                         start_pos,\n                         end_pos,\n+                        source_file_index\n+                            .try_into()\n+                            .expect(\"cannot import more than U32_MAX files\"),\n                     );\n                     debug!(\n                         \"CrateMetaData::imported_source_files alloc \\"}, {"sha": "de78ab41f05b7384005eb8098c82bb4701088faa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "patch": "@@ -17,7 +17,6 @@ use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -66,13 +65,10 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     // The indices (into the `SourceMap`'s `MonotonicVec`)\n     // of all of the `SourceFiles` that we need to serialize.\n     // When we serialize a `Span`, we insert the index of its\n-    // `SourceFile` into the `GrowableBitSet`.\n-    //\n-    // This needs to be a `GrowableBitSet` and not a\n-    // regular `BitSet` because we may actually import new `SourceFiles`\n-    // during metadata encoding, due to executing a query\n-    // with a result containing a foreign `Span`.\n-    required_source_files: Option<GrowableBitSet<usize>>,\n+    // `SourceFile` into the `FxIndexSet`.\n+    // The order inside the `FxIndexSet` is used as on-disk\n+    // order of `SourceFiles`, and encoded inside `Span`s.\n+    required_source_files: Option<FxIndexSet<usize>>,\n     is_proc_macro: bool,\n     hygiene_ctxt: &'a HygieneEncodeContext,\n }\n@@ -245,10 +241,6 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n-        let source_files = s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n-        // Record the fact that we need to encode the data for this `SourceFile`\n-        source_files.insert(s.source_file_cache.1);\n-\n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n         // crate we are writing metadata for. When the metadata for *this* crate gets\n@@ -265,30 +257,38 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, hi) = if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n-            // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n-            // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n-            // are relative to the source map information for the 'foreign' crate whose CrateNum\n-            // we write into the metadata. This allows `imported_source_files` to binary\n-            // search through the 'foreign' crate's source map information, using the\n-            // deserialized 'lo' and 'hi' values directly.\n-            //\n-            // All of this logic ensures that the final result of deserialization is a 'normal'\n-            // Span that can be used without any additional trouble.\n-            let external_start_pos = {\n-                // Introduce a new scope so that we drop the 'lock()' temporary\n-                match &*s.source_file_cache.0.external_src.lock() {\n-                    ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n-                    src => panic!(\"Unexpected external source {:?}\", src),\n-                }\n-            };\n-            let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n-            let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n+        let (tag, lo, hi, metadata_index) =\n+            if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n+                // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n+                // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n+                // are relative to the source map information for the 'foreign' crate whose CrateNum\n+                // we write into the metadata. This allows `imported_source_files` to binary\n+                // search through the 'foreign' crate's source map information, using the\n+                // deserialized 'lo' and 'hi' values directly.\n+                //\n+                // All of this logic ensures that the final result of deserialization is a 'normal'\n+                // Span that can be used without any additional trouble.\n+                let (external_start_pos, metadata_index) = {\n+                    // Introduce a new scope so that we drop the 'lock()' temporary\n+                    match &*s.source_file_cache.0.external_src.lock() {\n+                        ExternalSource::Foreign { original_start_pos, metadata_index, .. } => {\n+                            (*original_start_pos, *metadata_index as usize)\n+                        }\n+                        src => panic!(\"Unexpected external source {:?}\", src),\n+                    }\n+                };\n+                let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n+                let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n \n-            (TAG_VALID_SPAN_FOREIGN, lo, hi)\n-        } else {\n-            (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n-        };\n+                (TAG_VALID_SPAN_FOREIGN, lo, hi, metadata_index)\n+            } else {\n+                // Record the fact that we need to encode the data for this `SourceFile`\n+                let source_files =\n+                    s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+                let (source_file_index, _) = source_files.insert_full(s.source_file_cache.1);\n+\n+                (TAG_VALID_SPAN_LOCAL, span.lo, span.hi, source_file_index)\n+            };\n \n         tag.encode(s);\n         lo.encode(s);\n@@ -298,6 +298,9 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         let len = hi - lo;\n         len.encode(s);\n \n+        // Encode the index of the `SourceFile` for the span, in order to make decoding faster.\n+        metadata_index.encode(s);\n+\n         if tag == TAG_VALID_SPAN_FOREIGN {\n             // This needs to be two lines to avoid holding the `s.source_file_cache`\n             // while calling `cnum.encode(s)`\n@@ -460,18 +463,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let working_directory = &self.tcx.sess.opts.working_dir;\n \n-        let adapted = all_source_files\n+        // Only serialize `SourceFile`s that were used during the encoding of a `Span`.\n+        //\n+        // The order in which we encode source files is important here: the on-disk format for\n+        // `Span` contains the index of the corresponding `SourceFile`.\n+        let adapted = required_source_files\n             .iter()\n-            .enumerate()\n-            .filter(|(idx, source_file)| {\n-                // Only serialize `SourceFile`s that were used\n-                // during the encoding of a `Span`\n-                required_source_files.contains(*idx) &&\n-                // Don't serialize imported `SourceFile`s, unless\n-                // we're in a proc-macro crate.\n-                (!source_file.is_imported() || self.is_proc_macro)\n-            })\n-            .map(|(_, source_file)| {\n+            .map(|&source_file_index| &all_source_files[source_file_index])\n+            .map(|source_file| {\n+                // Don't serialize imported `SourceFile`s, unless we're in a proc-macro crate.\n+                assert!(!source_file.is_imported() || self.is_proc_macro);\n+\n                 // At export time we expand all source file paths to absolute paths because\n                 // downstream compilation sessions can have a different compiler working\n                 // directory, so relative paths from this or any other upstream crate\n@@ -2228,7 +2230,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n \n     let source_map_files = tcx.sess.source_map().files();\n     let source_file_cache = (source_map_files[0].clone(), 0);\n-    let required_source_files = Some(GrowableBitSet::with_capacity(source_map_files.len()));\n+    let required_source_files = Some(FxIndexSet::default());\n     drop(source_map_files);\n \n     let hygiene_ctxt = HygieneEncodeContext::default();"}, {"sha": "bae05f2f02efbd8a98d6203d94a48cd56c1f08e4", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "patch": "@@ -1098,6 +1098,8 @@ pub enum ExternalSource {\n         original_start_pos: BytePos,\n         /// The end of this SourceFile within the source_map of its original crate.\n         original_end_pos: BytePos,\n+        /// Index of the file inside metadata.\n+        metadata_index: u32,\n     },\n }\n "}, {"sha": "387777f7af64b5acfffb1ce920b66f5dd6b3b476", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "patch": "@@ -337,6 +337,7 @@ impl SourceMap {\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n         original_start_pos: BytePos,\n         original_end_pos: BytePos,\n+        metadata_index: u32,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self\n             .allocate_address_space(source_len)\n@@ -383,6 +384,7 @@ impl SourceMap {\n                 kind: ExternalSourceKind::AbsentOk,\n                 original_start_pos,\n                 original_end_pos,\n+                metadata_index,\n             }),\n             start_pos,\n             end_pos,"}, {"sha": "2cada019b7f84788e8e7c701c07a2920deb49498", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "patch": "@@ -252,6 +252,7 @@ fn t10() {\n         normalized_pos,\n         start_pos,\n         end_pos,\n+        0,\n     );\n \n     assert!("}]}