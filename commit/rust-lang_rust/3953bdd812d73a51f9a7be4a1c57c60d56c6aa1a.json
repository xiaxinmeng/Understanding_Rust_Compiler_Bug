{"sha": "3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NTNiZGQ4MTJkNzNhNTFmOWE3YmU0YTFjNTdjNjBkNTZjNmFhMWE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-28T15:25:31Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-28T15:25:31Z"}, "message": "Merge remote-tracking branch 'remotes/origin/incoming' into incoming", "tree": {"sha": "8dbdab63811771af7a14543a97636fc30ccc07f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dbdab63811771af7a14543a97636fc30ccc07f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "html_url": "https://github.com/rust-lang/rust/commit/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5d4cbda027482cfeb554c5bc30551377a668a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5d4cbda027482cfeb554c5bc30551377a668a2", "html_url": "https://github.com/rust-lang/rust/commit/7f5d4cbda027482cfeb554c5bc30551377a668a2"}, {"sha": "d0a12347dec3045eaf8dcded7add914d4491276f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a12347dec3045eaf8dcded7add914d4491276f", "html_url": "https://github.com/rust-lang/rust/commit/d0a12347dec3045eaf8dcded7add914d4491276f"}], "stats": {"total": 2110, "additions": 1302, "deletions": 808}, "files": [{"sha": "17e4e042a5afce94f4bb411633fe52d28713e91e", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -74,10 +74,53 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     }\n }\n \n+impl<A:ToStr> ToStr for &[A] {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        unsafe {\n+            // FIXME #4568\n+            // Bleh -- not really unsafe\n+            // push_str and push_char\n+            let mut acc = ~\"[\", first = true;\n+            for self.each |elt| {\n+                unsafe {\n+                    if first { first = false; }\n+                    else { str::push_str(&mut acc, ~\", \"); }\n+                    str::push_str(&mut acc, elt.to_str());\n+                }\n+            }\n+            str::push_char(&mut acc, ']');\n+            acc\n+        }\n+    }\n+}\n+\n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         unsafe {\n+            // FIXME #4568\n+            // Bleh -- not really unsafe\n+            // push_str and push_char\n+            let mut acc = ~\"[\", first = true;\n+            for self.each |elt| {\n+                unsafe {\n+                    if first { first = false; }\n+                    else { str::push_str(&mut acc, ~\", \"); }\n+                    str::push_str(&mut acc, elt.to_str());\n+                }\n+            }\n+            str::push_char(&mut acc, ']');\n+            acc\n+        }\n+    }\n+}\n+\n+impl<A:ToStr> ToStr for @[A] {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        unsafe {\n+            // FIXME #4568\n             // Bleh -- not really unsafe\n             // push_str and push_char\n             let mut acc = ~\"[\", first = true;"}, {"sha": "94b49e9d266e4e1ee71932f2b01f3103f13d082a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -202,14 +202,14 @@ fn is_bench_fn(i: @ast::item) -> bool {\n         vec::len(attr::find_attrs_by_name(i.attrs, ~\"bench\")) > 0u;\n \n     fn has_test_signature(i: @ast::item) -> bool {\n-        match /*bad*/copy i.node {\n-            ast::item_fn(decl, _, tps, _) => {\n+        match i.node {\n+            ast::item_fn(ref decl, _, ref generics, _) => {\n                 let input_cnt = vec::len(decl.inputs);\n                 let no_output = match decl.output.node {\n                     ast::ty_nil => true,\n                     _ => false\n                 };\n-                let tparm_cnt = vec::len(tps);\n+                let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n                 input_cnt == 1u"}, {"sha": "a5932775003249c344626b743d2b7b96e2f2aba7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -49,6 +49,8 @@ use syntax::diagnostic::span_handler;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n use syntax;\n use writer = std::ebml::writer;\n \n@@ -187,10 +189,11 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @EncodeContext,\n-                            params: &[ty_param]) {\n+fn encode_type_param_bounds(ebml_w: writer::Encoder,\n+                            ecx: @EncodeContext,\n+                            params: &OptVec<TyParam>) {\n     let ty_param_bounds =\n-        @params.map(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n+        @params.map_to_vec(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n@@ -265,7 +268,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                             id: node_id, variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n-                            ty_params: &[ty_param]) {\n+                            generics: &ast::Generics) {\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n@@ -281,7 +284,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                     node_id_to_type(ecx.tcx, variant.node.id));\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args)\n-                    if args.len() > 0 && ty_params.len() == 0 => {\n+                    if args.len() > 0 && generics.ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n             ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) |\n@@ -292,7 +295,7 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, ty_params);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_path(ecx, ebml_w, path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n@@ -465,14 +468,18 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @EncodeContext, ebml_w: writer::Encoder,\n-                        id: node_id, ident: ident, path: &[ast_map::path_elt],\n-                        item: Option<inlined_item>, tps: &[ty_param]) {\n+fn encode_info_for_ctor(ecx: @EncodeContext,\n+                        ebml_w: writer::Encoder,\n+                        id: node_id,\n+                        ident: ident,\n+                        path: &[ast_map::path_elt],\n+                        item: Option<inlined_item>,\n+                        generics: &ast::Generics) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n         encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n                *ecx.tcx.sess.str_of(ident),\n@@ -518,9 +525,12 @@ fn encode_info_for_method(ecx: @EncodeContext,\n                           should_inline: bool,\n                           parent_id: node_id,\n                           m: @method,\n-                          +all_tps: ~[ty_param]) {\n-    debug!(\"encode_info_for_method: %d %s %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident), all_tps.len());\n+                          owner_generics: &ast::Generics,\n+                          method_generics: &ast::Generics) {\n+    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n+           *ecx.tcx.sess.str_of(m.ident),\n+           owner_generics.ty_params.len(),\n+           method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     match m.self_ty.node {\n@@ -529,8 +539,13 @@ fn encode_info_for_method(ecx: @EncodeContext,\n         }\n         _ => encode_family(ebml_w, purity_fn_family(m.purity))\n     }\n-    let len = all_tps.len();\n-    encode_type_param_bounds(ebml_w, ecx, all_tps);\n+\n+    let mut combined_ty_params = opt_vec::Empty;\n+    combined_ty_params.push_all(&owner_generics.ty_params);\n+    combined_ty_params.push_all(&method_generics.ty_params);\n+    let len = combined_ty_params.len();\n+    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n@@ -604,13 +619,13 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_fn(_, purity, tps, _) => {\n+      item_fn(_, purity, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        let tps_len = tps.len();\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        let tps_len = generics.ty_params.len();\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n@@ -634,24 +649,24 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_ty(_, tps) => {\n+      item_ty(_, ref generics) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n-      item_enum(ref enum_definition, ref tps) => {\n+      item_enum(ref enum_definition, ref generics) => {\n         add_to_index();\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, *tps);\n+            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ecx, ebml_w, item.ident);\n             for (*enum_definition).variants.each |v| {\n@@ -667,9 +682,9 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                  (*enum_definition).variants,\n                                  path,\n                                  index,\n-                                 *tps);\n+                                 generics);\n       }\n-      item_struct(struct_def, tps) => {\n+      item_struct(struct_def, ref generics) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -686,24 +701,25 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                                    *ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n                                path,\n-                               if tps.len() > 0u {\n+                               if generics.ty_params.len() > 0u {\n                                    Some(ii_dtor(copy *dtor,\n                                                 item.ident,\n-                                                copy tps,\n+                                                copy *generics,\n                                                 local_def(item.id))) }\n                                else {\n                                    None\n                                },\n-                               tps);\n+                               generics);\n         }\n \n         /* Index the class*/\n         add_to_index();\n+\n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'S');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n \n         // If this is a tuple- or enum-like struct, encode the type of the\n@@ -759,13 +775,13 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, opt_trait, ty, methods) => {\n+      item_impl(ref generics, opt_trait, ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -797,18 +813,18 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                                    should_inline(m.attrs),\n                                    item.id, *m,\n-                                   vec::append(/*bad*/copy tps, m.tps));\n+                                   generics, &m.generics);\n         }\n       }\n-      item_trait(ref tps, ref traits, ref ms) => {\n+      item_trait(ref generics, ref traits, ref ms) => {\n         let provided_methods = dvec::DVec();\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, *tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -820,7 +836,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_def_id(ebml_w, local_def((*ty_m).id));\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx,\n-                                         (*ty_m).tps);\n+                                         &ty_m.generics.ty_params);\n                 encode_type(ecx, ebml_w,\n                             ty::mk_bare_fn(tcx, copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n@@ -834,7 +850,8 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, m.tps);\n+                encode_type_param_bounds(ebml_w, ecx,\n+                                         &m.generics.ty_params);\n                 encode_type(ecx, ebml_w,\n                             ty::mk_bare_fn(tcx, copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n@@ -880,8 +897,14 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         // Finally, output all the provided methods as items.\n         for provided_methods.each |m| {\n             index.push(entry { val: m.id, pos: ebml_w.writer.tell() });\n+\n+            // We do not concatenate the generics of the owning impl and that\n+            // of provided methods.  I am not sure why this is. -ndm\n+            let owner_generics = ast_util::empty_generics();\n+\n             encode_info_for_method(ecx, ebml_w, /*bad*/copy path,\n-                                   true, item.id, *m, /*bad*/copy m.tps);\n+                                   true, item.id, *m,\n+                                   &owner_generics, &m.generics);\n         }\n       }\n       item_mac(*) => fail!(~\"item macros unimplemented\")\n@@ -898,11 +921,11 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n-    match /*bad*/copy nitem.node {\n-      foreign_item_fn(_, purity, tps) => {\n+    match nitem.node {\n+      foreign_item_fn(_, purity, ref generics) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));"}, {"sha": "ecc0ce905531990efe24ffb775f5f7c181c87048", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -371,10 +371,10 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n+      ast::ii_dtor(ref dtor, nm, ref generics, parent_id) => {\n         let dtor_body = fld.fold_block(&dtor.node.body);\n         let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n-        let new_params = fold::fold_ty_params(/*bad*/copy *tps, fld);\n+        let new_generics = fold::fold_generics(generics, fld);\n         let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n@@ -386,7 +386,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n                                           body: dtor_body },\n                 .. (/*bad*/copy *dtor)\n             },\n-            nm, new_params, new_parent)\n+            nm, new_generics, new_parent)\n       }\n      }\n }"}, {"sha": "1df59b64fe68128ac2257c36cca3a72c3e0258e9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -753,7 +753,7 @@ fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n-                       decl: &ast::fn_decl) {\n+                        decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {"}, {"sha": "95764050898cdfede6062a01f3f3916965c897a8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -621,7 +621,8 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n             }\n         }\n         (visitor.visit_ty)(decl.output, cx, visitor);\n-        (visitor.visit_ty_params)(visit::tps_of_fn(fk), cx, visitor);\n+        let generics = visit::generics_of_fn(fk);\n+        (visitor.visit_generics)(&generics, cx, visitor);\n         (visitor.visit_block)(body, cx, visitor);\n     }\n }"}, {"sha": "6b7d4669621a2c0e11c364b3ba55907a47996052", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 63, "deletions": 68, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -42,6 +42,7 @@ use syntax::ast::{enum_variant_kind, expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_fn_block, expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n+use syntax::ast::{Generics};\n use syntax::ast::{gt, ident, impure_fn, inherited, item, item_struct};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n@@ -53,9 +54,9 @@ use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_dtor, struct_field, struct_variant_kind, sty_by_ref};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n-use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param, ty_path};\n+use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, TyParam, ty_path};\n use syntax::ast::{ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8, ty_uint};\n-use syntax::ast::{type_value_ns, ty_param_bound, unnamed_field};\n+use syntax::ast::{type_value_ns, unnamed_field};\n use syntax::ast::{variant, view_item, view_item_extern_mod};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n@@ -73,6 +74,8 @@ use syntax::visit::{default_visitor, fk_method, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n use managed::ptr_eq;\n use dvec::DVec;\n@@ -216,9 +219,9 @@ pub impl<T> ResolveResult<T> {\n }\n \n pub enum TypeParameters/& {\n-    NoTypeParameters,               //< No type parameters.\n-    HasTypeParameters(&~[ty_param], //< Type parameters.\n-                      node_id,      //< ID of the enclosing item\n+    NoTypeParameters,              //< No type parameters.\n+    HasTypeParameters(&Generics,   //< Type parameters.\n+                      node_id,     //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n                       // This is zero if this is the outermost set of type\n@@ -231,7 +234,6 @@ pub enum TypeParameters/& {\n                       //\n                       // The index at the method site will be 1, because the\n                       // outer T had index 0.\n-\n                       uint,\n \n                       // The kind of the rib used for type parameters.\n@@ -1500,14 +1502,15 @@ pub impl Resolver {\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n-        match /*bad*/copy foreign_item.node {\n-            foreign_item_fn(_, _, type_parameters) => {\n+        match foreign_item.node {\n+            foreign_item_fn(_, _, ref generics) => {\n                 let def = def_fn(local_def(foreign_item.id), unsafe_fn);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, foreign_item.id,\n-                                           0, NormalRibKind)) {\n+                do self.with_type_parameter_rib(\n+                    HasTypeParameters(\n+                        generics, foreign_item.id, 0, NormalRibKind))\n+                {\n                     visit_foreign_item(foreign_item, new_parent, visitor);\n                 }\n             }\n@@ -3582,8 +3585,7 @@ pub impl Resolver {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n-            item_enum(ref enum_def, ref type_parameters) => {\n-\n+            item_enum(ref enum_def, ref generics) => {\n                 for (*enum_def).variants.each() |variant| {\n                     do variant.node.disr_expr.iter() |dis_expr| {\n                         // resolve the discriminator expr\n@@ -3599,35 +3601,35 @@ pub impl Resolver {\n                 // error if there is one? -- tjc\n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n-                        type_parameters, item.id, 0, NormalRibKind)) {\n+                        generics, item.id, 0, NormalRibKind)) {\n                     visit_item(item, (), visitor);\n                 }\n             }\n \n-            item_ty(_, type_parameters) => {\n+            item_ty(_, ref generics) => {\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0,\n+                        (HasTypeParameters(generics, item.id, 0,\n                                            NormalRibKind))\n                         || {\n \n                     visit_item(item, (), visitor);\n                 }\n             }\n \n-            item_impl(type_parameters,\n+            item_impl(ref generics,\n                       implemented_traits,\n                       self_type,\n-                      methods) => {\n+                      ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             item.span,\n-                                            type_parameters,\n+                                            generics,\n                                             implemented_traits,\n                                             self_type,\n-                                            methods,\n+                                            *methods,\n                                             visitor);\n             }\n \n-            item_trait(ref type_parameters, ref traits, ref methods) => {\n+            item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -3636,10 +3638,10 @@ pub impl Resolver {\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(type_parameters, item.id, 0,\n+                        (HasTypeParameters(generics, item.id, 0,\n                                            NormalRibKind)) {\n \n-                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                    self.resolve_type_parameters(&generics.ty_params,\n                                                  visitor);\n \n                     // Resolve derived traits.\n@@ -3672,18 +3674,18 @@ pub impl Resolver {\n                         match *method {\n                           required(ref ty_m) => {\n                             do self.with_type_parameter_rib\n-                                (HasTypeParameters(&(*ty_m).tps,\n+                                (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n-                                                   type_parameters.len(),\n+                                                   generics.ty_params.len(),\n                                         MethodRibKind(item.id, Required))) {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n                                 self.resolve_type_parameters(\n-                                    /*bad*/copy (*ty_m).tps,\n+                                    &ty_m.generics.ty_params,\n                                     visitor);\n \n-                                for (*ty_m).decl.inputs.each |argument| {\n+                                for ty_m.decl.inputs.each |argument| {\n                                     self.resolve_type(argument.ty, visitor);\n                                 }\n \n@@ -3694,7 +3696,7 @@ pub impl Resolver {\n                               self.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n                                                   m,\n-                                                  type_parameters.len(),\n+                                                  generics.ty_params.len(),\n                                                   visitor)\n                           }\n                         }\n@@ -3704,12 +3706,12 @@ pub impl Resolver {\n                 (*self.type_ribs).pop();\n             }\n \n-            item_struct(struct_def, ty_params) => {\n+            item_struct(struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n-                                   @copy ty_params,\n-                                   /*bad*/copy struct_def.fields,\n-                                   struct_def.dtor,\n-                                   visitor);\n+                                    generics,\n+                                    struct_def.fields,\n+                                    struct_def.dtor,\n+                                    visitor);\n             }\n \n             item_mod(ref module_) => {\n@@ -3722,18 +3724,14 @@ pub impl Resolver {\n             item_foreign_mod(foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n-                        match /*bad*/copy foreign_item.node {\n-                            foreign_item_fn(_, _, type_parameters) => {\n-                                do self.with_type_parameter_rib\n-                                    (HasTypeParameters(&type_parameters,\n-                                                       foreign_item.id,\n-                                                       0,\n-                                                       OpaqueFunctionRibKind))\n-                                        || {\n-\n-                                    visit_foreign_item(*foreign_item, (),\n-                                                       visitor);\n-                                }\n+                        match foreign_item.node {\n+                            foreign_item_fn(_, _, ref generics) => {\n+                                self.with_type_parameter_rib(\n+                                    HasTypeParameters(\n+                                        generics, foreign_item.id, 0,\n+                                        NormalRibKind),\n+                                    || visit_foreign_item(*foreign_item, (),\n+                                                          visitor));\n                             }\n                             foreign_item_const(_) => {\n                                 visit_foreign_item(*foreign_item, (),\n@@ -3744,7 +3742,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            item_fn(ref fn_decl, _, ref ty_params, ref block) => {\n+            item_fn(ref fn_decl, _, ref generics, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 // FIXME #4404 android JNI hacks\n@@ -3771,7 +3769,7 @@ pub impl Resolver {\n                 self.resolve_function(OpaqueFunctionRibKind,\n                                       Some(@/*bad*/copy *fn_decl),\n                                       HasTypeParameters\n-                                        (ty_params,\n+                                        (generics,\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n@@ -3798,13 +3796,13 @@ pub impl Resolver {\n                                type_parameters: TypeParameters,\n                                f: fn()) {\n         match type_parameters {\n-            HasTypeParameters(type_parameters, node_id, initial_index,\n+            HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n \n                 let function_type_rib = @Rib(rib_kind);\n-                (*self.type_ribs).push(function_type_rib);\n+                self.type_ribs.push(function_type_rib);\n \n-                for (*type_parameters).eachi |index, type_parameter| {\n+                for generics.ty_params.eachi |index, type_parameter| {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n@@ -3815,7 +3813,7 @@ pub impl Resolver {\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n                                     def_typaram_binder(node_id));\n-                    (*function_type_rib).bindings.insert(name, def_like);\n+                    function_type_rib.bindings.insert(name, def_like);\n                 }\n             }\n \n@@ -3828,7 +3826,7 @@ pub impl Resolver {\n \n         match type_parameters {\n             HasTypeParameters(*) => {\n-                (*self.type_ribs).pop();\n+                self.type_ribs.pop();\n             }\n \n             NoTypeParameters => {\n@@ -3871,8 +3869,8 @@ pub impl Resolver {\n                 NoTypeParameters => {\n                     // Continue.\n                 }\n-                HasTypeParameters(type_parameters, _, _, _) => {\n-                    self.resolve_type_parameters(/*bad*/copy *type_parameters,\n+                HasTypeParameters(ref generics, _, _, _) => {\n+                    self.resolve_type_parameters(&generics.ty_params,\n                                                  visitor);\n                 }\n             }\n@@ -3927,7 +3925,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_type_parameters(@mut self,\n-                               type_parameters: ~[ty_param],\n+                               type_parameters: &OptVec<TyParam>,\n                                visitor: ResolveVisitor) {\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |&bound| {\n@@ -3941,19 +3939,17 @@ pub impl Resolver {\n \n     fn resolve_struct(@mut self,\n                       id: node_id,\n-                      type_parameters: @~[ty_param],\n-                      fields: ~[@struct_field],\n+                      generics: &Generics,\n+                      fields: &[@struct_field],\n                       optional_destructor: Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n-        let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0,\n+                                        (generics, id, 0,\n                                          OpaqueFunctionRibKind)) {\n \n             // Resolve the type parameters.\n-            self.resolve_type_parameters(/*bad*/copy *type_parameters,\n-                                         visitor);\n+            self.resolve_type_parameters(&generics.ty_params, visitor);\n \n             // Resolve fields.\n             for fields.each |field| {\n@@ -3986,9 +3982,9 @@ pub impl Resolver {\n                       method: @method,\n                       outer_type_parameter_count: uint,\n                       visitor: ResolveVisitor) {\n-        let borrowed_method_type_parameters = &method.tps;\n+        let method_generics = &method.generics;\n         let type_parameters =\n-            HasTypeParameters(borrowed_method_type_parameters,\n+            HasTypeParameters(method_generics,\n                               method.id,\n                               outer_type_parameter_count,\n                               rib_kind);\n@@ -4010,19 +4006,18 @@ pub impl Resolver {\n     fn resolve_implementation(@mut self,\n                               id: node_id,\n                               span: span,\n-                              type_parameters: ~[ty_param],\n+                              generics: &Generics,\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n                               methods: ~[@method],\n                               visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n-        let outer_type_parameter_count = type_parameters.len();\n-        let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n+        let outer_type_parameter_count = generics.ty_params.len();\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0,\n+                                        (generics, id, 0,\n                                          NormalRibKind)) {\n             // Resolve the type parameters.\n-            self.resolve_type_parameters(/*bad*/copy type_parameters,\n+            self.resolve_type_parameters(&generics.ty_params,\n                                          visitor);\n \n             // Resolve the trait reference, if necessary."}, {"sha": "bb670822ae88af42a6c426510562ffe9587aaeae", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -2103,9 +2103,9 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms) => {\n-        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, ms, tps, None,\n-                         item.id);\n+      ast::item_impl(ref generics, _, _, ref ms) => {\n+        meth::trans_impl(ccx, /*bad*/copy *path, item.ident, *ms,\n+                         generics, None, item.id);\n       }\n       ast::item_mod(ref m) => {\n         trans_mod(ccx, m);"}, {"sha": "b352b078a473c5ad460221c3feaff45ae8eeff09", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -91,7 +91,9 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                 region_param: _,\n                 ty: _\n             } = ty::lookup_item_type(ccx.tcx, impl_did);\n-            if translate && (*impl_bnds).len() + mth.tps.len() == 0u {\n+            if translate &&\n+                impl_bnds.len() + mth.generics.ty_params.len() == 0u\n+            {\n                 let llfn = get_item_val(ccx, mth.id);\n                 let path = vec::append(\n                     ty::item_path(ccx.tcx, impl_did),"}, {"sha": "d836bcb9df9a7b7c2aa6927c58d0dc2eb6113243", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -46,13 +46,13 @@ be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n-                  methods: ~[@ast::method], tps: ~[ast::ty_param],\n+                  methods: ~[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n-    if tps.len() > 0u { return; }\n+    if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {\n-        if method.tps.len() == 0u {\n+        if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(/*bad*/copy sub_path,\n                                        path_name(method.ident));\n@@ -410,7 +410,7 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n         match ccx.tcx.items.find(&m_id.node) {\n-            Some(ast_map::node_method(m, _, _)) => m.tps.len(),\n+            Some(ast_map::node_method(m, _, _)) => m.generics.ty_params.len(),\n             None => {\n                 match ccx.tcx.provided_method_sources.find(&m_id) {\n                     Some(source) => {\n@@ -420,9 +420,9 @@ pub fn method_ty_param_count(ccx: @CrateContext, m_id: ast::def_id,\n                     None => fail!()\n                 }\n             }\n-            Some(ast_map::node_trait_method(@ast::provided(@ref m), _, _))\n-                => {\n-                m.tps.len()\n+            Some(ast_map::node_trait_method(@ast::provided(@ref m),\n+                                            _, _)) => {\n+                m.generics.ty_params.len()\n             }\n             copy e => fail!(fmt!(\"method_ty_param_count %?\", e))\n         }"}, {"sha": "d93886dbb3e85ecfa5e02755ea61a56a86862f74", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -99,36 +99,39 @@ fn traverse_public_item(cx: ctx, item: @item) {\n     cx.rmap.insert(item.id, ());\n     match /*bad*/copy item.node {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n-      item_foreign_mod(nm) => {\n+      item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n                   cx.rmap.insert(item.id, ());\n               }\n           }\n       }\n-      item_fn(_, _, ref tps, ref blk) => {\n-        if tps.len() > 0u ||\n+      item_fn(_, _, ref generics, ref blk) => {\n+        if generics.ty_params.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n             traverse_inline_body(cx, blk);\n         }\n       }\n-      item_impl(tps, _, _, ms) => {\n-        for vec::each(ms) |m| {\n-            if tps.len() > 0u || m.tps.len() > 0u ||\n-               attr::find_inline_attr(m.attrs) != attr::ia_none {\n+      item_impl(ref generics, _, _, ref ms) => {\n+        for ms.each |m| {\n+            if generics.ty_params.len() > 0u ||\n+                m.generics.ty_params.len() > 0u ||\n+                attr::find_inline_attr(m.attrs) != attr::ia_none\n+            {\n                 cx.rmap.insert(m.id, ());\n                 traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n-      item_struct(struct_def, tps) => {\n+      item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n             cx.rmap.insert(ctor_id, ());\n         }\n-        do option::iter(&struct_def.dtor) |dtor| {\n+        do struct_def.dtor.iter |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n-            if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n-                     != attr::ia_none {\n+            if generics.ty_params.len() > 0u ||\n+                attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n+            {\n                 traverse_inline_body(cx, &dtor.node.body);\n             }\n         }"}, {"sha": "c34e8dae21fca96d4ebebe69bd2937cb4b67f8de", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -4143,10 +4143,11 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     return tbl[tycat(ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n-    vec::from_fn(tps.len(), |i| {\n-                ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n-        })\n+pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n+    vec::from_fn(generics.ty_params.len(), |i| {\n+        let id = generics.ty_params.get(i).id;\n+        ty::mk_param(tcx, i, ast_util::local_def(id))\n+    })\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed."}, {"sha": "3bf474b2bed1c1f2b706b23d946c95a7b9a76c9b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -127,6 +127,8 @@ use syntax::codemap;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n use syntax;\n \n pub mod _match;\n@@ -603,9 +605,9 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_struct(struct_def, _) => {\n         check_struct(ccx, struct_def, it.id, it.span);\n       }\n-      ast::item_ty(t, tps) => {\n+      ast::item_ty(t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n-        check_bounds_are_used(ccx, t.span, tps, tpt_ty);\n+        check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n         // If this is a record ty, check for duplicate fields\n         match t.node {\n             ast::ty_rec(ref fields) => {\n@@ -1073,8 +1075,9 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n               }, _)) => {\n-            (ts.len(), region_param,\n-                vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n+            (ts.ty_params.len(),\n+             region_param,\n+             vcx.ccx.to_ty(rscope::type_rscope(region_param), st))\n           }\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_struct(_, ref ts),\n@@ -1085,12 +1088,13 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n-              (ts.len(), region_param,\n-                  ty::mk_struct(tcx, local_def(class_id),\n+              (ts.ty_params.len(),\n+               region_param,\n+               ty::mk_struct(tcx, local_def(class_id),\n                       substs {\n                         self_r: rscope::bound_self_region(region_param),\n                         self_ty: None,\n-                        tps: ty::ty_params_to_tys(tcx, /*bad*/copy *ts)\n+                        tps: ty::ty_params_to_tys(tcx, ts)\n                       }))\n           }\n           _ => { tcx.sess.bug(~\"impl_self_ty: unbound item or item that \\\n@@ -1873,11 +1877,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.region_paramd_items.find(&class_id.node);\n             match tcx.items.find(&class_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n-                        node: ast::item_struct(_, ref type_parameters),\n+                        node: ast::item_struct(_, ref generics),\n                         _\n                     }, _)) => {\n \n-                    type_parameter_count = type_parameters.len();\n+                    type_parameter_count = generics.ty_params.len();\n \n                     let self_region =\n                         bound_self_region(region_parameterized);\n@@ -1887,7 +1891,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n                             tcx,\n-                            /*bad*/copy *type_parameters)\n+                            generics)\n                     });\n                 }\n                 _ => {\n@@ -1957,11 +1961,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.region_paramd_items.find(&enum_id.node);\n             match tcx.items.find(&enum_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n-                        node: ast::item_enum(_, ref type_parameters),\n+                        node: ast::item_enum(_, ref generics),\n                         _\n                     }, _)) => {\n \n-                    type_parameter_count = type_parameters.len();\n+                    type_parameter_count = generics.ty_params.len();\n \n                     let self_region =\n                         bound_self_region(region_parameterized);\n@@ -1971,7 +1975,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(\n                             tcx,\n-                            /*bad*/copy *type_parameters)\n+                            generics)\n                     });\n                 }\n                 _ => {\n@@ -3137,7 +3141,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n \n pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: span,\n-                             tps: ~[ast::ty_param],\n+                             tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n@@ -3164,7 +3168,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n-                           *ccx.tcx.sess.str_of(tps[i].ident)));\n+                           *ccx.tcx.sess.str_of(tps.get(i).ident)));\n         }\n     }\n }"}, {"sha": "f8fcef7580b1d272bdbcb04b327dc0ecec1f8a58", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -147,7 +147,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     @MethodInfo {\n         did: local_def(ast_method.id),\n-        n_tps: ast_method.tps.len(),\n+        n_tps: ast_method.generics.ty_params.len(),\n         ident: ast_method.ident,\n         self_type: ast_method.self_ty.node\n     }"}, {"sha": "67dca7ea81196c0bdb44810bfb2a033669558b59", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -60,6 +60,8 @@ use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust::path_to_str;\n use syntax::visit;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n@@ -70,8 +72,8 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n         if crate_item.ident\n             == ::syntax::parse::token::special_idents::intrinsic {\n \n-            match /*bad*/copy crate_item.node {\n-              ast::item_mod(m) => {\n+            match crate_item.node {\n+              ast::item_mod(ref m) => {\n                 for m.items.each |intrinsic_item| {\n                     let def_id = ast::def_id { crate: ast::local_crate,\n                                                node: intrinsic_item.id };\n@@ -153,7 +155,7 @@ impl AstConv for CrateCtxt {\n pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n-                              +ty_params: ~[ast::ty_param],\n+                              generics: &ast::Generics,\n                               rp: Option<ty::region_variance>) {\n     let tcx = ccx.tcx;\n \n@@ -175,15 +177,15 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, ty_params),\n+                    bounds: ty_param_bounds(ccx, generics),\n                     region_param: rp,\n                     ty: enum_ty\n                 };\n \n                 convert_struct(ccx,\n                                rp,\n                                struct_def,\n-                               ty_params.to_vec(),\n+                               generics,\n                                tpt,\n                                variant.node.id);\n \n@@ -196,7 +198,7 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n                 get_enum_variant_types(ccx,\n                                        enum_ty,\n                                        enum_definition.variants,\n-                                       copy ty_params,\n+                                       generics,\n                                        rp);\n                 result_ty = None;\n             }\n@@ -206,7 +208,7 @@ pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n             None => {}\n             Some(result_ty) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    bounds: ty_param_bounds(ccx, ty_params),\n+                    bounds: ty_param_bounds(ccx, generics),\n                     region_param: rp,\n                     ty: result_ty\n                 };\n@@ -276,7 +278,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n     let region_paramd = tcx.region_paramd_items.find(&id);\n     match tcx.items.get(&id) {\n       ast_map::node_item(@ast::item {\n-                node: ast::item_trait(ref params, _, ref ms),\n+                node: ast::item_trait(ref generics, _, ref ms),\n                 _\n             }, _) => {\n         store_methods::<ast::trait_method>(ccx, id, (/*bad*/copy *ms), |m| {\n@@ -288,10 +290,14 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n-            let trait_bounds = ty_param_bounds(ccx, *params);\n+            let trait_bounds = ty_param_bounds(ccx, generics);\n             let ty_m = trait_method_to_ty_method(m);\n-            let method_ty = ty_of_ty_method(ccx, &ty_m, region_paramd,\n-                                            def_id);\n+            let method_ty = ty_of_ty_method(\n+                ccx,\n+                &ty_m,\n+                region_paramd,\n+                def_id\n+            );\n             if ty_m.self_ty.node == ast::sty_static {\n                 make_static_method_ty(ccx, &ty_m, region_paramd,\n                                       method_ty, trait_ty,\n@@ -489,7 +495,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n }\n \n pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n-                                   tps: ~[ast::ty_param],\n+                                   generics: &ast::Generics,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n                                    a_trait_ty: @ast::trait_ref,\n@@ -523,8 +529,9 @@ pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n     for impl_ms.each |impl_m| {\n         match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(ref trait_m) => {\n+                let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n-                    ccx.tcx, tps.len(), impl_m, trait_m,\n+                    ccx.tcx, num_impl_tps, impl_m, trait_m,\n                     &tpt.substs, selfty);\n             }\n             None => {\n@@ -569,7 +576,7 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, m.tps);\n+        let bounds = ty_param_bounds(ccx, &m.generics);\n         let mty = ty_of_method(ccx, *m, rp);\n         let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n@@ -590,9 +597,9 @@ pub fn convert_methods(ccx: @mut CrateCtxt,\n \n pub fn ensure_no_ty_param_bounds(ccx: @mut CrateCtxt,\n                                  span: span,\n-                                 ty_params: &[ast::ty_param],\n+                                 generics: &ast::Generics,\n                                  thing: &static/str) {\n-    for ty_params.each |ty_param| {\n+    for generics.ty_params.each |ty_param| {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n@@ -607,21 +614,21 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n            *tcx.sess.str_of(it.ident), it.id, rp);\n-    match /*bad*/copy it.node {\n+    match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(ref enum_definition, ref ty_params) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"enumeration\");\n+      ast::item_enum(ref enum_definition, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         get_enum_variant_types(ccx,\n                                tpt.ty,\n                                enum_definition.variants,\n-                               copy *ty_params,\n+                               generics,\n                                rp);\n       }\n-      ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, *tps);\n+      ast::item_impl(ref generics, trait_ref, selfty, ref ms) => {\n+        let i_bounds = ty_param_bounds(ccx, generics);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n@@ -633,11 +640,11 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n         // XXX: Bad copy of `ms` below.\n         let cms = convert_methods(ccx, /*bad*/copy *ms, rp, i_bounds);\n         for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, /*bad*/copy *tps, rp, selfty,\n+            check_methods_against_trait(ccx, generics, rp, selfty,\n                                         *t, /*bad*/copy cms);\n         }\n       }\n-      ast::item_trait(ref tps, ref supertraits, ref trait_methods) => {\n+      ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n         let tpt = ty_of_item(ccx, it);\n         debug!(\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ppaux::ty_to_str(tcx, tpt.ty));\n@@ -647,21 +654,21 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n \n         let (_, provided_methods) =\n             split_trait_methods(/*bad*/copy *trait_methods);\n-        let (bounds, _) = mk_substs(ccx, /*bad*/copy *tps, rp);\n+        let (bounds, _) = mk_substs(ccx, generics, rp);\n         let _ = convert_methods(ccx, provided_methods, rp, bounds);\n       }\n-      ast::item_struct(struct_def, tps) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, tps, \"structure\");\n+      ast::item_struct(struct_def, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n \n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        convert_struct(ccx, rp, struct_def, tps, tpt, it.id);\n+        convert_struct(ccx, rp, struct_def, generics, tpt, it.id);\n       }\n-      ast::item_ty(_, ref ty_params) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"type\");\n+      ast::item_ty(_, ref generics) => {\n+        ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n       }\n@@ -678,7 +685,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n pub fn convert_struct(ccx: @mut CrateCtxt,\n                       rp: Option<ty::region_variance>,\n                       struct_def: @ast::struct_def,\n-                      +tps: ~[ast::ty_param],\n+                      generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::node_id) {\n     let tcx = ccx.tcx;\n@@ -703,7 +710,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, *f);\n     }\n-    let (_, substs) = mk_substs(ccx, tps, rp);\n+    let (_, substs) = mk_substs(ccx, generics, rp);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -747,7 +754,7 @@ pub fn ty_of_method(ccx: @mut CrateCtxt,\n                     rp: Option<ty::region_variance>) -> ty::method {\n     ty::method {\n         ident: m.ident,\n-        tps: ty_param_bounds(ccx, m.tps),\n+        tps: ty_param_bounds(ccx, &m.generics),\n         fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n                                     ast::RustAbi, &m.decl),\n         self_ty: m.self_ty.node,\n@@ -762,7 +769,7 @@ pub fn ty_of_ty_method(self: @mut CrateCtxt,\n                        id: ast::def_id) -> ty::method {\n     ty::method {\n         ident: m.ident,\n-        tps: ty_param_bounds(self, m.tps),\n+        tps: ty_param_bounds(self, &m.generics),\n         fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n                                     ast::RustAbi, &m.decl),\n         // assume public, because this is only invoked on trait methods\n@@ -810,17 +817,17 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n       _ => {}\n     }\n     let rp = tcx.region_paramd_items.find(&it.id);\n-    match /*bad*/copy it.node {\n+    match it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_fn(decl, purity, tps, _) => {\n-        let bounds = ty_param_bounds(ccx, tps);\n+      ast::item_fn(ref decl, purity, ref generics, _) => {\n+        let bounds = ty_param_bounds(ccx, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n-                                          ast::RustAbi, &decl);\n+                                          ast::RustAbi, decl);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n             region_param: None,\n@@ -833,7 +840,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_ty(t, tps) => {\n+      ast::item_ty(t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n           Some(tpt) => return tpt,\n           None => { }\n@@ -847,12 +854,12 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n                 // reconstruct the value of X.\n-                if !vec::is_empty(tps) { t0 } else {\n+                if !generics.is_empty() { t0 } else {\n                     ty::mk_with_id(tcx, t0, def_id)\n                 }\n             };\n             ty_param_bounds_and_ty {\n-                bounds: ty_param_bounds(ccx, tps),\n+                bounds: ty_param_bounds(ccx, generics),\n                 region_param: rp,\n                 ty: ty\n             }\n@@ -861,9 +868,9 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_enum(_, tps) => {\n+      ast::item_enum(_, ref generics) => {\n         // Create a new generic polytype.\n-        let (bounds, substs) = mk_substs(ccx, tps, rp);\n+        let (bounds, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_enum(tcx, local_def(it.id), substs);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -873,8 +880,8 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_trait(tps, _, _) => {\n-        let (bounds, substs) = mk_substs(ccx, tps, rp);\n+      ast::item_trait(ref generics, _, _) => {\n+        let (bounds, substs) = mk_substs(ccx, generics, rp);\n         let t = ty::mk_trait(tcx, local_def(it.id), substs, ty::vstore_box);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -884,8 +891,8 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_struct(_, tps) => {\n-          let (bounds, substs) = mk_substs(ccx, tps, rp);\n+      ast::item_struct(_, ref generics) => {\n+          let (bounds, substs) = mk_substs(ccx, generics, rp);\n           let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n@@ -904,8 +911,13 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match /*bad*/copy it.node {\n-        ast::foreign_item_fn(ref fn_decl, _, ref params) => {\n-            ty_of_foreign_fn_decl(ccx, fn_decl, *params, local_def(it.id))\n+        ast::foreign_item_fn(ref fn_decl, _, ref generics) => {\n+            ty_of_foreign_fn_decl(\n+                ccx,\n+                fn_decl,\n+                local_def(it.id),\n+                generics\n+            )\n         }\n         ast::foreign_item_const(t) => {\n             let rb = in_binding_rscope(empty_rscope);\n@@ -923,9 +935,9 @@ pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n // either be user-defined traits, or one of the four built-in traits (formerly\n // known as kinds): Const, Copy, Durable, and Send.\n pub fn compute_bounds(ccx: @mut CrateCtxt,\n-                      ast_bounds: @~[ast::ty_param_bound])\n+                      ast_bounds: @OptVec<ast::TyParamBound>)\n                    -> ty::param_bounds {\n-    @do vec::flat_map(*ast_bounds) |b| {\n+    @ast_bounds.flat_map_to_vec(|b| {\n         match b {\n             &TraitTyParamBound(b) => {\n                 let li = &ccx.tcx.lang_items;\n@@ -955,13 +967,13 @@ pub fn compute_bounds(ccx: @mut CrateCtxt,\n             }\n             &RegionTyParamBound => ~[ty::bound_durable]\n         }\n-    }\n+    })\n }\n \n pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n-                       params: &[ast::ty_param])\n+                       generics: &ast::Generics)\n                     -> @~[ty::param_bounds] {\n-    @do params.map |param| {\n+    @do generics.ty_params.map_to_vec |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n           Some(bs) => bs,\n           None => {\n@@ -975,10 +987,10 @@ pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n \n pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n                              decl: &ast::fn_decl,\n-                             ty_params: &[ast::ty_param],\n-                             def_id: ast::def_id)\n+                             def_id: ast::def_id,\n+                             generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(ccx, ty_params);\n+    let bounds = ty_param_bounds(ccx, generics);\n     let rb = in_binding_rscope(empty_rscope);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n@@ -999,24 +1011,25 @@ pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n     return tpt;\n }\n \n-pub fn mk_ty_params(ccx: @mut CrateCtxt, atps: ~[ast::ty_param])\n-    -> (@~[ty::param_bounds], ~[ty::t]) {\n-\n+pub fn mk_generics(ccx: @mut CrateCtxt, generics: &ast::Generics)\n+    -> (@~[ty::param_bounds], ~[ty::t])\n+{\n     let mut i = 0u;\n-    let bounds = ty_param_bounds(ccx, atps);\n+    let bounds = ty_param_bounds(ccx, generics);\n     (bounds,\n-     vec::map(atps, |atp| {\n+     generics.ty_params.map_to_vec(|atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n      }))\n }\n \n pub fn mk_substs(ccx: @mut CrateCtxt,\n-                 +atps: ~[ast::ty_param],\n+                 generics: &ast::Generics,\n                  rp: Option<ty::region_variance>)\n-              -> (@~[ty::param_bounds], ty::substs) {\n-    let (bounds, params) = mk_ty_params(ccx, atps);\n+              -> (@~[ty::param_bounds], ty::substs)\n+{\n+    let (bounds, params) = mk_generics(ccx, generics);\n     let self_r = rscope::bound_self_region(rp);\n     (bounds, substs { self_r: self_r, self_ty: None, tps: params })\n }"}, {"sha": "afd3ca0ef6af309b7102a11ef0c4222f5760c458", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -77,7 +77,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n             ident: ident,\n             node: ast::foreign_item_fn(ref decl, _, ref tys), _\n           }, _, _) => {\n-            Some(pprust::fun_to_str(*decl, ident, copy *tys,\n+            Some(pprust::fun_to_str(decl, ident, tys,\n                                     extract::interner()))\n           }\n           _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n@@ -213,17 +213,17 @@ fn get_method_sig(\n                   match method {\n                     ast::required(ty_m) => {\n                       Some(pprust::fun_to_str(\n-                          ty_m.decl,\n+                          &ty_m.decl,\n                           ty_m.ident,\n-                          copy ty_m.tps,\n+                          &ty_m.generics,\n                           extract::interner()\n                       ))\n                     }\n                     ast::provided(m) => {\n                       Some(pprust::fun_to_str(\n-                          m.decl,\n+                          &m.decl,\n                           m.ident,\n-                          copy m.tps,\n+                          &m.generics,\n                           extract::interner()\n                       ))\n                     }\n@@ -240,9 +240,9 @@ fn get_method_sig(\n             }) {\n                 Some(method) => {\n                     Some(pprust::fun_to_str(\n-                        method.decl,\n+                        &method.decl,\n                         method.ident,\n-                        copy method.tps,\n+                        &method.generics,\n                         extract::interner()\n                     ))\n                 }\n@@ -339,7 +339,7 @@ fn fold_type(\n                         Some(fmt!(\n                             \"type %s%s = %s\",\n                             to_str(ident),\n-                            pprust::typarams_to_str(*params,\n+                            pprust::generics_to_str(params,\n                                                     extract::interner()),\n                             pprust::ty_to_str(ty,\n                                               extract::interner())"}, {"sha": "69c3de5ff6285c8d18d44129947cb8ec84b46c15", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -251,7 +251,11 @@ pub fn sha1() -> Sha1 {\n             let rr = mk_result(self);\n             let mut s = ~\"\";\n             for vec::each(rr) |b| {\n-                s += uint::to_str_radix(*b as uint, 16u);\n+                let hex = uint::to_str_radix(*b as uint, 16u);\n+                if hex.len() == 1 {\n+                    s += \"0\";\n+                }\n+                s += hex;\n             }\n             return s;\n         }\n@@ -283,6 +287,7 @@ mod tests {\n             struct Test {\n                 input: ~str,\n                 output: ~[u8],\n+                output_str: ~str,\n             }\n \n             fn a_million_letter_a() -> ~str {\n@@ -306,6 +311,7 @@ mod tests {\n                         0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n                         0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n                     ],\n+                    output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n                 },\n                 Test {\n                     input:\n@@ -318,6 +324,7 @@ mod tests {\n                         0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n                         0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n                     ],\n+                    output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n                 },\n                 Test {\n                     input: a_million_letter_a(),\n@@ -328,6 +335,7 @@ mod tests {\n                         0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n                         0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n                     ],\n+                    output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n                 },\n             ];\n             // Examples from wikipedia\n@@ -342,6 +350,7 @@ mod tests {\n                         0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n                         0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n                     ],\n+                    output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n                 },\n                 Test {\n                     input: ~\"The quick brown fox jumps over the lazy cog\",\n@@ -352,6 +361,7 @@ mod tests {\n                         0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n                         0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n                     ],\n+                    output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n                 },\n             ];\n             let tests = fips_180_1_tests + wikipedia_tests;\n@@ -373,6 +383,11 @@ mod tests {\n                 sh.input_str(t.input);\n                 let out = sh.result();\n                 check_vec_eq(t.output, out);\n+\n+                let out_str = sh.result_str();\n+                assert(out_str.len() == 40);\n+                assert(out_str == t.output_str);\n+\n                 sh.reset();\n             }\n \n@@ -389,6 +404,11 @@ mod tests {\n                 }\n                 let out = sh.result();\n                 check_vec_eq(t.output, out);\n+\n+                let out_str = sh.result_str();\n+                assert(out_str.len() == 40);\n+                assert(out_str == t.output_str);\n+\n                 sh.reset();\n             }\n         }"}, {"sha": "46ecd96bef1fd6819106ac31f3e1be24292ccce3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -21,6 +21,8 @@ use core::to_bytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use opt_vec::OptVec;\n+\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n@@ -96,6 +98,9 @@ impl to_bytes::IterBytes for ident {\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n@@ -135,18 +140,32 @@ pub const crate_node_id: node_id = 0;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n-pub enum ty_param_bound {\n+pub enum TyParamBound {\n     TraitTyParamBound(@Ty),\n     RegionTyParamBound\n }\n \n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-pub struct ty_param {\n+pub struct TyParam {\n     ident: ident,\n     id: node_id,\n-    bounds: @~[ty_param_bound]\n+    bounds: @OptVec<TyParamBound>\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub struct Generics {\n+    lifetimes: OptVec<Lifetime>,\n+    ty_params: OptVec<TyParam>\n+}\n+\n+impl Generics {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.len() + self.ty_params.len() == 0\n+    }\n }\n \n #[auto_encode]\n@@ -273,8 +292,8 @@ pub enum pat_ {\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     pat_ident(binding_mode, @path, Option<@pat>),\n-    pat_enum(@path, Option<~[@pat]>), // \"none\" means a * pattern where\n-                                  // we don't bind the fields to names\n+    pat_enum(@path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+                                       * we don't bind the fields to names */\n     pat_rec(~[field_pat], bool),\n     pat_struct(@path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n@@ -749,7 +768,7 @@ pub struct ty_method {\n     attrs: ~[attribute],\n     purity: purity,\n     decl: fn_decl,\n-    tps: ~[ty_param],\n+    generics: Generics,\n     self_ty: self_ty,\n     id: node_id,\n     span: span,\n@@ -1012,7 +1031,7 @@ pub type self_ty = spanned<self_ty_>;\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n-    tps: ~[ty_param],\n+    generics: Generics,\n     self_ty: self_ty,\n     purity: purity,\n     decl: fn_decl,\n@@ -1248,14 +1267,14 @@ pub struct item {\n #[deriving_eq]\n pub enum item_ {\n     item_const(@Ty, @expr),\n-    item_fn(fn_decl, purity, ~[ty_param], blk),\n+    item_fn(fn_decl, purity, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@Ty, ~[ty_param]),\n-    item_enum(enum_def, ~[ty_param]),\n-    item_struct(@struct_def, ~[ty_param]),\n-    item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n-    item_impl(~[ty_param],\n+    item_ty(@Ty, Generics),\n+    item_enum(enum_def, Generics),\n+    item_struct(@struct_def, Generics),\n+    item_trait(Generics, ~[@trait_ref], ~[trait_method]),\n+    item_impl(Generics,\n               Option<@trait_ref>, // (optional) trait this impl implements\n               @Ty, // self\n               ~[@method]),\n@@ -1302,7 +1321,7 @@ pub struct foreign_item {\n #[auto_decode]\n #[deriving_eq]\n pub enum foreign_item_ {\n-    foreign_item_fn(fn_decl, purity, ~[ty_param]),\n+    foreign_item_fn(fn_decl, purity, Generics),\n     foreign_item_const(@Ty)\n }\n \n@@ -1316,7 +1335,7 @@ pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_dtor(struct_dtor, ident, ~[ty_param], def_id /* parent id */)\n+    ii_dtor(struct_dtor, ident, Generics, def_id /* parent id */)\n }\n \n #[cfg(test)]"}, {"sha": "88c0363917fbe67bfca8dc06520fa4e24ff93de7", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -101,7 +101,7 @@ pub enum ast_node {\n     node_arg(arg, uint),\n     node_local(uint),\n     // Destructor for a struct\n-    node_dtor(~[ty_param], @struct_dtor, def_id, @path),\n+    node_dtor(Generics, @struct_dtor, def_id, @path),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n }\n@@ -199,7 +199,7 @@ pub fn map_fn(\n         cx.local_id += 1u;\n     }\n     match *fk {\n-        visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n+        visit::fk_dtor(generics, ref attrs, self_id, parent_id) => {\n             let dt = @spanned {\n                 node: ast::struct_dtor_ {\n                     id: id,\n@@ -212,7 +212,7 @@ pub fn map_fn(\n             cx.map.insert(\n                 id,\n                 node_dtor(\n-                    /* FIXME (#2543) */ vec::from_slice(tps),\n+                    /* FIXME (#2543) */ copy *generics,\n                     dt,\n                     parent_id,\n                     @/* FIXME (#2543) */ copy cx.path));"}, {"sha": "cede82d03dc6f42bb21509b03dea4a01dec0d12a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -16,6 +16,7 @@ use ast_util;\n use codemap::{span, BytePos, dummy_sp};\n use parse::token;\n use visit;\n+use opt_vec;\n \n use core::cmp;\n use core::int;\n@@ -269,7 +270,7 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n                 attrs: copy m.attrs,\n                 purity: m.purity,\n                 decl: copy m.decl,\n-                tps: copy m.tps,\n+                generics: copy m.generics,\n                 self_ty: m.self_ty,\n                 id: m.id,\n                 span: m.span,\n@@ -327,8 +328,9 @@ impl inlined_item_utils for inlined_item {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n             ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-            ii_dtor(/*bad*/ copy dtor, _, /*bad*/ copy tps, parent_id) => {\n-                visit::visit_struct_dtor_helper(dtor, tps, parent_id, e, v);\n+            ii_dtor(/*bad*/ copy dtor, _, ref generics, parent_id) => {\n+                visit::visit_struct_dtor_helper(dtor, generics,\n+                                                parent_id, e, v);\n             }\n         }\n     }\n@@ -375,6 +377,11 @@ pub fn dtor_dec() -> fn_decl {\n     }\n }\n \n+pub fn empty_generics() -> Generics {\n+    Generics {lifetimes: opt_vec::Empty,\n+              ty_params: opt_vec::Empty}\n+}\n+\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n@@ -390,6 +397,14 @@ pub fn empty(range: id_range) -> bool {\n }\n \n pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n+    let visit_generics = fn@(generics: &Generics) {\n+        for generics.ty_params.each |p| {\n+            vfn(p.id);\n+        }\n+        for generics.lifetimes.each |p| {\n+            vfn(p.id);\n+        }\n+    };\n     visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_mod: |_m, _sp, id| vfn(id),\n \n@@ -457,29 +472,25 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_params: fn@(ps: &[ty_param]) {\n-            for ps.each |p| {\n-                vfn(p.id);\n-            }\n-        },\n+        visit_generics: visit_generics,\n \n         visit_fn: fn@(fk: &visit::fn_kind, d: &ast::fn_decl,\n                       _b: &ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             match *fk {\n-                visit::fk_dtor(ref tps, _, self_id, parent_id) => {\n-                    for tps.each |tp| { vfn(tp.id); }\n+                visit::fk_dtor(generics, _, self_id, parent_id) => {\n+                    visit_generics(generics);\n                     vfn(id);\n                     vfn(self_id);\n                     vfn(parent_id.node);\n                 }\n-                visit::fk_item_fn(_, ref tps, _) => {\n-                    for tps.each |tp| { vfn(tp.id); }\n+                visit::fk_item_fn(_, generics, _) => {\n+                    visit_generics(generics);\n                 }\n-                visit::fk_method(_, ref tps, m) => {\n+                visit::fk_method(_, generics, m) => {\n                     vfn(m.self_id);\n-                    for tps.each |tp| { vfn(tp.id); }\n+                    visit_generics(generics);\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n@@ -497,7 +508,9 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_trait_method: fn@(_ty_m: &trait_method) {\n         },\n \n-        visit_struct_def: fn@(_sd: @struct_def, _id: ident, _tps: &[ty_param],\n+        visit_struct_def: fn@(_sd: @struct_def,\n+                              _id: ident,\n+                              _generics: &Generics,\n                               _id: node_id) {\n         },\n "}, {"sha": "973b2ae20666fbcfc2f236ca5972f1782a893c92", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n+/*!\n \n The compiler code necessary to implement the #[auto_encode] and\n #[auto_decode] extension.  The idea here is that type-defining items may\n@@ -96,6 +96,9 @@ use attr;\n use codemap::span;\n use ext::base::*;\n use parse;\n+use opt_vec;\n+use opt_vec::OptVec;\n+use ext::build;\n \n use core::vec;\n use std::oldmap;\n@@ -127,24 +130,24 @@ pub fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_struct(ref struct_def, ref tps) => {\n+                ast::item_struct(ref struct_def, ref generics) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         struct_def.fields,\n-                        *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_enum(ref enum_def, ref tps) => {\n+                ast::item_enum(ref enum_def, ref generics) => {\n                     let ser_impl = mk_enum_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         copy *enum_def,\n-                        copy *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n@@ -182,24 +185,24 @@ pub fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_struct(ref struct_def, ref tps) => {\n+                ast::item_struct(ref struct_def, ref generics) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         struct_def.fields,\n-                        copy *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_enum(ref enum_def, ref tps) => {\n+                ast::item_enum(ref enum_def, ref generics) => {\n                     let deser_impl = mk_enum_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n                         copy *enum_def,\n-                        copy *tps\n+                        generics\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -222,18 +225,18 @@ priv impl ext_ctxt {\n         span: span,\n         ident: ast::ident,\n         path: @ast::path,\n-        bounds: @~[ast::ty_param_bound]\n-    ) -> ast::ty_param {\n+        bounds: @OptVec<ast::TyParamBound>\n+    ) -> ast::TyParam {\n         let bound = ast::TraitTyParamBound(@ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),\n             span: span,\n         });\n \n-        ast::ty_param {\n+        ast::TyParam {\n             ident: ident,\n             id: self.next_id(),\n-            bounds: @vec::append(~[bound], *bounds)\n+            bounds: @bounds.prepend(bound)\n         }\n     }\n \n@@ -417,28 +420,45 @@ fn mk_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    ty_param: ast::ty_param,\n+    ty_param: ast::TyParam,\n     path: @ast::path,\n-    tps: &[ast::ty_param],\n+    generics: &ast::Generics,\n     f: fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n+    /*!\n+     *\n+     * Given that we are deriving auto-encode a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr, ..., Z:Tr> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where Tr is either Serializable and Deserialize.\n+     *\n+     * FIXME(#5090): Remove code duplication between this and the code\n+     * in deriving.rs\n+     */\n+\n+\n+    // Copy the lifetimes\n+    let impl_lifetimes = generics.lifetimes.map(|l| {\n+        build::mk_lifetime(cx, l.span, l.ident)\n+    });\n+\n     // All the type parameters need to bound to the trait.\n-    let mut trait_tps = vec::append(\n-        ~[ty_param],\n-         do tps.map |tp| {\n-            let t_bound = ast::TraitTyParamBound(@ast::Ty {\n-                id: cx.next_id(),\n-                node: ast::ty_path(path, cx.next_id()),\n-                span: span,\n-            });\n+    let mut impl_tps = opt_vec::with(ty_param);\n+    for generics.ty_params.each |tp| {\n+        let t_bound = ast::TraitTyParamBound(@ast::Ty {\n+            id: cx.next_id(),\n+            node: ast::ty_path(path, cx.next_id()),\n+            span: span,\n+        });\n \n-            ast::ty_param {\n-                ident: tp.ident,\n-                id: cx.next_id(),\n-                bounds: @vec::append(~[t_bound], *tp.bounds)\n-            }\n-        }\n-    );\n+        impl_tps.push(ast::TyParam {\n+            ident: tp.ident,\n+            id: cx.next_id(),\n+            bounds: @tp.bounds.prepend(t_bound)\n+        })\n+    }\n \n     let opt_trait = Some(@ast::trait_ref {\n         path: path,\n@@ -448,16 +468,22 @@ fn mk_impl(\n     let ty = cx.ty_path(\n         span,\n         ~[ident],\n-        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+        generics.ty_params.map(\n+            |tp| cx.ty_path(span, ~[tp.ident], ~[])).to_vec()\n     );\n \n+    let generics = ast::Generics {\n+        lifetimes: impl_lifetimes,\n+        ty_params: impl_tps\n+    };\n+\n     @ast::item {\n         // This is a new-style impl declaration.\n         // XXX: clownshoes\n         ident: parse::token::special_idents::clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        node: ast::item_impl(generics, opt_trait, ty, ~[f(ty)]),\n         vis: ast::public,\n         span: span,\n     }\n@@ -467,7 +493,7 @@ fn mk_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: &[ast::ty_param],\n+    generics: &ast::Generics,\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Encodable typaram.\n@@ -482,7 +508,7 @@ fn mk_ser_impl(\n                 cx.ident_of(~\"Encoder\"),\n             ]\n         ),\n-        @~[]\n+        @opt_vec::Empty\n     );\n \n     // Make a path to the std::serialize::Encodable trait.\n@@ -502,7 +528,7 @@ fn mk_ser_impl(\n         ident,\n         ty_param,\n         path,\n-        tps,\n+        generics,\n         |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n     )\n }\n@@ -511,7 +537,7 @@ fn mk_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: ~[ast::ty_param],\n+    generics: &ast::Generics,\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Decodable typaram.\n@@ -526,7 +552,7 @@ fn mk_deser_impl(\n                 cx.ident_of(~\"Decoder\"),\n             ]\n         ),\n-        @~[]\n+        @opt_vec::Empty\n     );\n \n     // Make a path to the std::serialize::Decodable trait.\n@@ -546,7 +572,7 @@ fn mk_deser_impl(\n         ident,\n         ty_param,\n         path,\n-        tps,\n+        generics,\n         |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n     )\n }\n@@ -601,7 +627,7 @@ fn mk_ser_method(\n     @ast::method {\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned { node: ast::sty_region(ast::m_imm),\n                                 span: span },\n         purity: ast::impure_fn,\n@@ -659,7 +685,7 @@ fn mk_deser_method(\n     @ast::method {\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n@@ -676,7 +702,7 @@ fn mk_struct_ser_impl(\n     span: span,\n     ident: ast::ident,\n     fields: &[@ast::struct_field],\n-    tps: &[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n@@ -729,15 +755,15 @@ fn mk_struct_ser_impl(\n         ]\n     );\n \n-    mk_ser_impl(cx, span, ident, tps, ser_body)\n+    mk_ser_impl(cx, span, ident, generics, ser_body)\n }\n \n fn mk_struct_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| std::serialize::decode(__d)`\n@@ -805,7 +831,7 @@ fn mk_struct_deser_impl(\n         ]\n     );\n \n-    mk_deser_impl(cx, span, ident, tps, body)\n+    mk_deser_impl(cx, span, ident, generics, body)\n }\n \n // Records and structs don't have the same fields types, but they share enough\n@@ -841,7 +867,7 @@ fn mk_enum_ser_impl(\n     span: span,\n     ident: ast::ident,\n     +enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n         cx,\n@@ -850,15 +876,15 @@ fn mk_enum_ser_impl(\n         copy enum_def.variants\n     );\n \n-    mk_ser_impl(cx, span, ident, tps, body)\n+    mk_ser_impl(cx, span, ident, generics, body)\n }\n \n fn mk_enum_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     +enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n+    generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n         cx,\n@@ -867,7 +893,7 @@ fn mk_enum_deser_impl(\n         enum_def.variants\n     );\n \n-    mk_deser_impl(cx, span, ident, tps, body)\n+    mk_deser_impl(cx, span, ident, generics, body)\n }\n \n fn ser_variant("}, {"sha": "c6e6e677348a10f0cfcc5caca1d1d0e5ddd85906", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -16,6 +16,9 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n \n+use opt_vec;\n+use opt_vec::OptVec;\n+\n use core::dvec;\n use core::option;\n \n@@ -362,8 +365,14 @@ pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n }\n pub fn mk_ty_param(cx: ext_ctxt,\n                    ident: ast::ident,\n-                   bounds: @~[ast::ty_param_bound])\n-                -> ast::ty_param {\n-    ast::ty_param { ident: ident, id: cx.next_id(), bounds: bounds }\n+                   bounds: @OptVec<ast::TyParamBound>)\n+                -> ast::TyParam {\n+    ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n+}\n+pub fn mk_lifetime(cx: ext_ctxt,\n+                   span: span,\n+                   ident: ast::ident) -> ast::Lifetime\n+{\n+    ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n }\n "}, {"sha": "fc603cdee984ef51f2265be9a114a72f09147ade", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -16,15 +16,19 @@ use core::prelude::*;\n use ast;\n use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n use ast::{enum_variant_kind, expr, expr_match, ident, item, item_};\n-use ast::{item_enum, item_impl, item_struct, m_imm, meta_item, method};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n use ast::{re_anon, stmt, struct_def, struct_variant_kind};\n-use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, ty_param};\n-use ast::{ty_param_bound, ty_path, ty_rptr, unnamed_field, variant};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n use codemap::{span, spanned};\n use parse::token::special_idents::clownshoes_extensions;\n+use ast_util;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::dvec;\n use core::uint;\n@@ -47,13 +51,13 @@ type ExpandDerivingStructDefFn = &fn(ext_ctxt,\n                                      span,\n                                      x: &struct_def,\n                                      ident,\n-                                     +y: ~[ty_param])\n+                                     y: &Generics)\n                                   -> @item;\n type ExpandDerivingEnumDefFn = &fn(ext_ctxt,\n                                    span,\n                                    x: &enum_def,\n                                    ident,\n-                                   +y: ~[ty_param])\n+                                   y: &Generics)\n                                 -> @item;\n \n pub fn expand_deriving_eq(cx: ext_ctxt,\n@@ -90,19 +94,19 @@ fn expand_deriving(cx: ext_ctxt,\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n-            item_struct(struct_def, copy ty_params) => {\n+            item_struct(struct_def, ref generics) => {\n                 result.push(expand_deriving_struct_def(cx,\n                                                        span,\n                                                        struct_def,\n                                                        item.ident,\n-                                                       ty_params));\n+                                                       generics));\n             }\n-            item_enum(ref enum_definition, copy ty_params) => {\n+            item_enum(ref enum_definition, ref generics) => {\n                 result.push(expand_deriving_enum_def(cx,\n                                                      span,\n                                                      enum_definition,\n                                                      item.ident,\n-                                                     ty_params));\n+                                                     generics));\n             }\n             _ => ()\n         }\n@@ -127,14 +131,14 @@ fn create_eq_method(cx: ext_ctxt,\n                     span: span,\n                     method_ident: ident,\n                     type_ident: ident,\n-                    ty_params: &[ty_param],\n+                    generics: &Generics,\n                     body: @expr)\n                  -> @method {\n     // Create the type of the `other` parameter.\n     let arg_path_type = create_self_type_with_params(cx,\n                                                      span,\n                                                      type_ident,\n-                                                     ty_params);\n+                                                     generics);\n     let arg_region = @ast::region { id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(\n         arg_region,\n@@ -171,7 +175,7 @@ fn create_eq_method(cx: ext_ctxt,\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n         purity: pure_fn,\n         decl: fn_decl,\n@@ -186,11 +190,11 @@ fn create_eq_method(cx: ext_ctxt,\n fn create_self_type_with_params(cx: ext_ctxt,\n                                 span: span,\n                                 type_ident: ident,\n-                                ty_params: &[ty_param])\n+                                generics: &Generics)\n                              -> @Ty {\n     // Create the type parameters on the `self` path.\n     let self_ty_params = dvec::DVec();\n-    for ty_params.each |ty_param| {\n+    for generics.ty_params.each |ty_param| {\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n@@ -209,21 +213,34 @@ fn create_self_type_with_params(cx: ext_ctxt,\n fn create_derived_impl(cx: ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n-                       +ty_params: ~[ty_param],\n+                       generics: &Generics,\n                        methods: &[@method],\n                        trait_path: &[ident])\n                     -> @item {\n+    /*!\n+     *\n+     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n+     *\n+     * FIXME(#5090): Remove code duplication between this and the\n+     * code in auto_encode.rs\n+     */\n+\n+    // Copy the lifetimes\n+    let impl_lifetimes = generics.lifetimes.map(|l| {\n+        build::mk_lifetime(cx, l.span, l.ident)\n+    });\n+\n     // Create the type parameters.\n-    let impl_ty_params = dvec::DVec();\n-    for ty_params.each |ty_param| {\n+    let impl_ty_params = generics.ty_params.map(|ty_param| {\n         let bound = build::mk_ty_path_global(cx,\n                                              span,\n                                              trait_path.map(|x| *x));\n-        let bounds = @~[ TraitTyParamBound(bound) ];\n-        let impl_ty_param = build::mk_ty_param(cx, ty_param.ident, bounds);\n-        impl_ty_params.push(impl_ty_param);\n-    }\n-    let impl_ty_params = dvec::unwrap(impl_ty_params);\n+        let bounds = @opt_vec::with(TraitTyParamBound(bound));\n+        build::mk_ty_param(cx, ty_param.ident, bounds)\n+    });\n \n     // Create the reference to the trait.\n     let trait_path = ast::path {\n@@ -244,10 +261,11 @@ fn create_derived_impl(cx: ext_ctxt,\n     let self_type = create_self_type_with_params(cx,\n                                                  span,\n                                                  type_ident,\n-                                                 ty_params);\n+                                                 generics);\n \n     // Create the impl item.\n-    let impl_item = item_impl(impl_ty_params,\n+    let impl_item = item_impl(Generics {lifetimes: impl_lifetimes,\n+                                        ty_params: impl_ty_params},\n                               Some(trait_ref),\n                               self_type,\n                               methods.map(|x| *x));\n@@ -257,7 +275,7 @@ fn create_derived_impl(cx: ext_ctxt,\n fn create_derived_eq_impl(cx: ext_ctxt,\n                           span: span,\n                           type_ident: ident,\n-                          +ty_params: ~[ty_param],\n+                          generics: &Generics,\n                           eq_method: @method,\n                           ne_method: @method)\n                        -> @item {\n@@ -267,13 +285,13 @@ fn create_derived_eq_impl(cx: ext_ctxt,\n         cx.ident_of(~\"cmp\"),\n         cx.ident_of(~\"Eq\")\n     ];\n-    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n                                   span: span,\n                                   type_ident: ident,\n-                                  +ty_params: ~[ty_param],\n+                                  generics: &Generics,\n                                   method: @method)\n                                -> @item {\n     let methods = [ method ];\n@@ -282,7 +300,7 @@ fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n         cx.ident_of(~\"to_bytes\"),\n         cx.ident_of(~\"IterBytes\")\n     ];\n-    create_derived_impl(cx, span, type_ident, ty_params, methods, trait_path)\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -322,7 +340,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n-        tps: ~[],\n+        generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n         purity: pure_fn,\n         decl: fn_decl,\n@@ -484,7 +502,7 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n-                                 +ty_params: ~[ty_param])\n+                                 generics: &Generics)\n                               -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n@@ -510,21 +528,21 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                      struct_def,\n                                      eq_ident,\n                                      type_ident,\n-                                     ty_params,\n+                                     generics,\n                                      Conjunction);\n     let ne_method = derive_struct_fn(cx,\n                                      span,\n                                      struct_def,\n                                      ne_ident,\n                                      type_ident,\n-                                     ty_params,\n+                                     generics,\n                                      Disjunction);\n \n     // Create the implementation.\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  ty_params,\n+                                  generics,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -533,7 +551,7 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n                                span: span,\n                                enum_definition: &enum_def,\n                                type_ident: ident,\n-                               +ty_params: ~[ty_param])\n+                               generics: &Generics)\n                             -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n@@ -543,21 +561,21 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n                                                    enum_definition,\n                                                    eq_ident,\n                                                    type_ident,\n-                                                   ty_params,\n+                                                   generics,\n                                                    Conjunction);\n     let ne_method = expand_deriving_eq_enum_method(cx,\n                                                    span,\n                                                    enum_definition,\n                                                    ne_ident,\n                                                    type_ident,\n-                                                   ty_params,\n+                                                   generics,\n                                                    Disjunction);\n \n     // Create the implementation.\n     return create_derived_eq_impl(cx,\n                                   span,\n                                   type_ident,\n-                                  ty_params,\n+                                  generics,\n                                   eq_method,\n                                   ne_method);\n }\n@@ -566,7 +584,7 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n                                          span: span,\n                                          struct_def: &struct_def,\n                                          type_ident: ident,\n-                                         +ty_params: ~[ty_param])\n+                                         generics: &Generics)\n                                       -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_struct_method(cx,\n@@ -577,15 +595,15 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          ty_params,\n+                                          generics,\n                                           method);\n }\n \n fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n                                        span: span,\n                                        enum_definition: &enum_def,\n                                        type_ident: ident,\n-                                       +ty_params: ~[ty_param])\n+                                       generics: &Generics)\n                                     -> @item {\n     // Create the method.\n     let method = expand_deriving_iter_bytes_enum_method(cx,\n@@ -596,7 +614,7 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n     return create_derived_iter_bytes_impl(cx,\n                                           span,\n                                           type_ident,\n-                                          ty_params,\n+                                          generics,\n                                           method);\n }\n \n@@ -605,7 +623,7 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                                     struct_def: &struct_def,\n                                     method_ident: ident,\n                                     type_ident: ident,\n-                                    ty_params: &[ty_param],\n+                                    generics: &Generics,\n                                     junction: Junction)\n                                  -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -652,7 +670,7 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                             span,\n                             method_ident,\n                             type_ident,\n-                            ty_params,\n+                            generics,\n                             body);\n }\n \n@@ -696,7 +714,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                   enum_definition: &enum_def,\n                                   method_ident: ident,\n                                   type_ident: ident,\n-                                  ty_params: &[ty_param],\n+                                  generics: &Generics,\n                                   junction: Junction)\n                                -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n@@ -823,7 +841,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                             span,\n                             method_ident,\n                             type_ident,\n-                            ty_params,\n+                            generics,\n                             self_match_expr);\n }\n \n@@ -832,7 +850,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n                                           struct_def: &struct_def,\n                                           method_ident: ident,\n                                           type_ident: ident,\n-                                          ty_params: &[ty_param],\n+                                          generics: &Generics,\n                                           junction: Junction)\n                                         -> @method {\n     let self_str = ~\"self\";\n@@ -883,7 +901,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n     let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n     create_eq_method(cx, span, method_ident,\n-        type_ident, ty_params, self_match_expr)\n+        type_ident, generics, self_match_expr)\n }\n \n fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,"}, {"sha": "105b65c35c905315b1ec931155fd98e2c0de1400", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -583,13 +583,17 @@ mod test {\n \n     // make a \"meta_word\" outer attribute with the given name\n     fn make_dummy_attr(s: @~str) -> ast::attribute {\n-        spanned {span:codemap::dummy_sp(),\n-                 node: attribute_\n-                     {style:attr_outer,\n-                      value:spanned\n-                          {node:meta_word(s),\n-                           span:codemap::dummy_sp()},\n-                      is_sugared_doc:false}}\n+        spanned {\n+            span:codemap::dummy_sp(),\n+            node: attribute_ {\n+                style: attr_outer,\n+                value: @spanned {\n+                    node: meta_word(s),\n+                    span: codemap::dummy_sp(),\n+                },\n+                is_sugared_doc: false,\n+            }\n+        }\n     }\n \n }"}, {"sha": "973a4f0a4f0882889b7023a41f1f9375c933a00f", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 96, "deletions": 56, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -24,6 +24,8 @@ use codemap::{span, respan, dummy_sp};\n use codemap;\n use ext::base::{ext_ctxt, mk_ctxt};\n use ext::quote::rt::*;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::vec;\n \n@@ -71,50 +73,61 @@ impl append_types for @ast::path {\n }\n \n pub trait ext_ctxt_ast_builder {\n-    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n-        -> ast::ty_param;\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam;\n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n     fn expr_block(&self, e: @ast::expr) -> ast::blk;\n     fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n     fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n     fn item_fn_poly(&self,\n-        name: ident,\n-        +inputs: ~[ast::arg],\n-        output: @ast::Ty,\n-        +ty_params: ~[ast::ty_param],\n-        +body: ast::blk) -> @ast::item;\n+                    ame: ident,\n+                    +inputs: ~[ast::arg],\n+                    output: @ast::Ty,\n+                    +generics: Generics,\n+                    +body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n-        name: ident,\n-        +inputs: ~[ast::arg],\n-        output: @ast::Ty,\n-        +body: ast::blk) -> @ast::item;\n+               name: ident,\n+               +inputs: ~[ast::arg],\n+               output: @ast::Ty,\n+               +body: ast::blk) -> @ast::item;\n     fn item_enum_poly(&self,\n-        name: ident,\n-        span: span,\n-        +enum_definition: ast::enum_def,\n-        +ty_params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_enum(&self, name: ident, span: span,\n+                      name: ident,\n+                      span: span,\n+                      +enum_definition: ast::enum_def,\n+                      +generics: Generics) -> @ast::item;\n+    fn item_enum(&self,\n+                 name: ident,\n+                 span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n     fn item_struct_poly(&self,\n-        name: ident, span: span,\n-        +struct_def: ast::struct_def,\n-        +ty_params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_struct(&self, name: ident, span: span,\n+                        name: ident,\n+                        span: span,\n+                        +struct_def: ast::struct_def,\n+                        +generics: Generics) -> @ast::item;\n+    fn item_struct(&self,\n+                   name: ident,\n+                   span: span,\n                    +struct_def: ast::struct_def) -> @ast::item;\n-    fn struct_expr(&self, path: @ast::path,\n+    fn struct_expr(&self,\n+                   path: @ast::path,\n                    +fields: ~[ast::field]) -> @ast::expr;\n-    fn variant(&self, name: ident, span: span,\n+    fn variant(&self,\n+               name: ident,\n+               span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(&self, name: ident, span: span,\n+    fn item_mod(&self,\n+                name: ident,\n+                span: span,\n                 +items: ~[@ast::item]) -> @ast::item;\n     fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty;\n-    fn item_ty_poly(&self, name: ident,\n+    fn item_ty_poly(&self,\n+                    name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n-                    +params: ~[ast::ty_param]) -> @ast::item;\n+                    +generics: Generics) -> @ast::item;\n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n-    fn ty_vars(&self, ty_params: &[ast::ty_param]) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n     fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n     fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n@@ -124,7 +137,7 @@ pub trait ext_ctxt_ast_builder {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer(&self) -> @ast::Ty;\n     fn ty_nil_ast_builder(&self) -> @ast::Ty;\n-    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n+    fn strip_bounds(&self, bounds: &Generics) -> Generics;\n }\n \n impl ext_ctxt_ast_builder for ext_ctxt {\n@@ -180,10 +193,10 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn ty_param(&self, id: ast::ident, +bounds: ~[ast::ty_param_bound])\n-        -> ast::ty_param\n+    fn ty_param(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>)\n+        -> ast::TyParam\n     {\n-        ast::ty_param { ident: id, id: self.next_id(), bounds: @bounds }\n+        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n \n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n@@ -255,43 +268,64 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n     fn item_fn_poly(&self, name: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +ty_params: ~[ast::ty_param],\n+                    +generics: Generics,\n                     +body: ast::blk) -> @ast::item {\n         self.item(name,\n                   dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n                                ast::impure_fn,\n-                               ty_params,\n+                               generics,\n                                body))\n     }\n \n-    fn item_fn(&self, name: ident,\n+    fn item_fn(&self,\n+               name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk) -> @ast::item {\n-        self.item_fn_poly(name, inputs, output, ~[], body)\n+               +body: ast::blk\n+    ) -> @ast::item {\n+        self.item_fn_poly(\n+            name,\n+            inputs,\n+            output,\n+            ast_util::empty_generics(),\n+            body\n+        )\n     }\n \n     fn item_enum_poly(&self, name: ident, span: span,\n                       +enum_definition: ast::enum_def,\n-                      +ty_params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_enum(enum_definition, ty_params))\n+                      +generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item {\n-        self.item_enum_poly(name, span, enum_definition, ~[])\n+        self.item_enum_poly(name, span, enum_definition,\n+                            ast_util::empty_generics())\n     }\n \n-    fn item_struct(&self, name: ident, span: span,\n-                   +struct_def: ast::struct_def) -> @ast::item {\n-        self.item_struct_poly(name, span, struct_def, ~[])\n+    fn item_struct(\n+        &self, name: ident,\n+        span: span,\n+        +struct_def: ast::struct_def\n+    ) -> @ast::item {\n+        self.item_struct_poly(\n+            name,\n+            span,\n+            struct_def,\n+            ast_util::empty_generics()\n+        )\n     }\n \n-    fn item_struct_poly(&self, name: ident, span: span,\n-                        +struct_def: ast::struct_def,\n-                        +ty_params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_struct(@struct_def, ty_params))\n+    fn item_struct_poly(\n+        &self,\n+        name: ident,\n+        span: span,\n+        +struct_def: ast::struct_def,\n+        +generics: Generics\n+    ) -> @ast::item {\n+        self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n     fn struct_expr(&self, path: @ast::path,\n@@ -379,28 +413,34 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n         }\n     }\n \n-    fn strip_bounds(&self, bounds: &[ast::ty_param]) -> ~[ast::ty_param] {\n-        do bounds.map |ty_param| {\n-            ast::ty_param { bounds: @~[], ..copy *ty_param }\n+    fn strip_bounds(&self, generics: &Generics) -> Generics {\n+        let no_bounds = @opt_vec::Empty;\n+        let new_params = do generics.ty_params.map |ty_param| {\n+            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+        };\n+        Generics {\n+            ty_params: new_params,\n+            .. copy *generics\n         }\n     }\n \n     fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    +params: ~[ast::ty_param]) -> @ast::item {\n-        self.item(name, span, ast::item_ty(ty, params))\n+                    +generics: Generics) -> @ast::item {\n+        self.item(name, span, ast::item_ty(ty, generics))\n     }\n \n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n-        self.item_ty_poly(name, span, ty, ~[])\n+        self.item_ty_poly(name, span, ty, ast_util::empty_generics())\n     }\n \n-    fn ty_vars(&self, +ty_params: &[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(~[p.ident], dummy_sp())))\n+            path(~[p.ident], dummy_sp()))).to_vec()\n     }\n \n-    fn ty_vars_global(&self, ty_params: &[ast::ty_param]) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self,\n+                      ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(~[p.ident], dummy_sp())))\n+            path(~[p.ident], dummy_sp()))).to_vec()\n     }\n }"}, {"sha": "b543ef5fdaef00202e3e0eadaf8fa7c89e4000a6", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -67,13 +67,13 @@ impl proto::visitor<(), (), ()> for ext_ctxt {\n             else {\n                 let next = proto.get_state(next_state.state);\n \n-                if next.ty_params.len() != next_state.tys.len() {\n+                if next.generics.ty_params.len() != next_state.tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n                         fmt!(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              name, next.name,\n-                             next.ty_params.len(),\n+                             next.generics.ty_params.len(),\n                              next_state.tys.len()));\n                 }\n             }"}, {"sha": "bdcdf61fc582e9ee9593035cc980995ad287b655", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -55,13 +55,13 @@ impl proto_parser for parser::Parser {\n           _ => fail!()\n         };\n \n-        let typarms = if *self.token == token::LT {\n-            self.parse_ty_params()\n+        let generics = if *self.token == token::LT {\n+            self.parse_generics()\n         } else {\n-            ~[]\n+            ast_util::empty_generics()\n         };\n \n-        let state = proto.add_state_poly(name, id, dir, typarms);\n+        let state = proto.add_state_poly(name, id, dir, generics);\n \n         // parse the messages\n         self.parse_unspanned_seq("}, {"sha": "7b0f6c1529cc2455f74312cee1be02831215788a", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -19,6 +19,8 @@ use ext::pipes::proto::*;\n use ext::quote::rt::*;\n use parse::*;\n use util::interner;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::dvec::DVec;\n use core::prelude::*;\n@@ -50,19 +52,18 @@ impl gen_send for message {\n     fn gen_send(&mut self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n-        let params = self.get_params();\n \n         match *self {\n           message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next_state.state);\n-            assert next_state.tys.len() == next.ty_params.len();\n+            assert next_state.tys.len() == next.generics.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n             let args_ast = vec::map2(arg_names, *tys, |n, t| cx.arg(*n, *t));\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars_global(this.ty_params)));\n+                .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n             let args_ast = vec::append(\n                 ~[cx.arg(cx.ident_of(~\"pipe\"),\n                               pipe_ty)],\n@@ -128,7 +129,7 @@ impl gen_send for message {\n             cx.item_fn_poly(name,\n                             args_ast,\n                             rty,\n-                            params,\n+                            self.get_generics(),\n                             cx.expr_block(body))\n           }\n \n@@ -142,10 +143,10 @@ impl gen_send for message {\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(cx.ident_of(~\"pipe\"),\n-                                  cx.ty_path_ast_builder(\n-                                      path(~[this.data_name()], span)\n-                                      .add_tys(cx.ty_vars_global(\n-                                        this.ty_params))))],\n+                             cx.ty_path_ast_builder(\n+                                 path(~[this.data_name()], span)\n+                                 .add_tys(cx.ty_vars_global(\n+                                     &this.generics.ty_params))))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -183,15 +184,15 @@ impl gen_send for message {\n                                 } else {\n                                     cx.ty_nil_ast_builder()\n                                 },\n-                                params,\n+                                self.get_generics(),\n                                 cx.expr_block(body))\n             }\n           }\n         }\n \n     fn to_ty(&mut self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars_global(self.get_params())))\n+          .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n     }\n }\n \n@@ -242,7 +243,7 @@ impl to_type_decls for state {\n                 ast::enum_def(enum_def_ {\n                     variants: items_msg,\n                     common: None }),\n-                cx.strip_bounds(self.ty_params)\n+                cx.strip_bounds(&self.generics)\n             )\n         ]\n     }\n@@ -280,8 +281,9 @@ impl to_type_decls for state {\n                             path(~[cx.ident_of(~\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n-                            .add_tys(cx.ty_vars_global(self.ty_params))))),\n-                    cx.strip_bounds(self.ty_params)));\n+                            .add_tys(cx.ty_vars_global(\n+                                &self.generics.ty_params))))),\n+                    cx.strip_bounds(&self.generics)));\n         }\n         else {\n             items.push(\n@@ -298,9 +300,10 @@ impl to_type_decls for state {\n                             path(~[cx.ident_of(~\"super\"),\n                                    self.data_name()],\n                                         dummy_sp())\n-                            .add_tys(cx.ty_vars_global(self.ty_params))),\n+                            .add_tys(cx.ty_vars_global(\n+                                &self.generics.ty_params))),\n                                    self.proto.buffer_ty_path(cx)])),\n-                    cx.strip_bounds(self.ty_params)));\n+                    cx.strip_bounds(&self.generics)));\n         };\n         items\n     }\n@@ -339,7 +342,7 @@ impl gen_init for protocol {\n \n         cx.parse_item(fmt!(\"pub fn init%s() -> (client::%s, server::%s)\\\n                             { use core::pipes::HasBuffer; %s }\",\n-                           start_state.ty_params.to_source(cx),\n+                           start_state.generics.to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            body.to_source(cx)))\n@@ -384,9 +387,9 @@ impl gen_init for protocol {\n     }\n \n     fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty {\n-        let mut params: ~[ast::ty_param] = ~[];\n+        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).each |s| {\n-            for s.ty_params.each |tp| {\n+            for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n@@ -397,19 +400,20 @@ impl gen_init for protocol {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(~\"super\"),\n                                       cx.ident_of(~\"__Buffer\")],\n                                     copy self.span)\n-                               .add_tys(cx.ty_vars_global(params)))\n+                               .add_tys(cx.ty_vars_global(&params)))\n     }\n \n     fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n-        let mut params: ~[ast::ty_param] = ~[];\n+        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).map_to_vec |s| {\n-            for s.ty_params.each |tp| {\n+            for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n                 }\n             }\n+\n             let ty = s.to_ty(cx);\n             let fty = quote_ty!( ::core::pipes::Packet<$ty> );\n \n@@ -426,6 +430,11 @@ impl gen_init for protocol {\n             }\n         };\n \n+        let generics = Generics {\n+            lifetimes: opt_vec::Empty,\n+            ty_params: params\n+        };\n+\n         cx.item_struct_poly(\n             cx.ident_of(~\"__Buffer\"),\n             dummy_sp(),\n@@ -434,7 +443,7 @@ impl gen_init for protocol {\n                 dtor: None,\n                 ctor_id: None\n             },\n-            cx.strip_bounds(params))\n+            cx.strip_bounds(&generics))\n     }\n \n     fn compile(&self, cx: ext_ctxt) -> @ast::item {"}, {"sha": "db5c6541e264ddca603f0fc1dbd658f35a99ad74", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -61,9 +61,9 @@ pub impl message {\n     }\n \n     /// Return the type parameters actually used by this message\n-    fn get_params(&mut self) -> ~[ast::ty_param] {\n+    fn get_generics(&self) -> ast::Generics {\n         match *self {\n-          message(_, _, _, this, _) => copy this.ty_params\n+          message(_, _, _, this, _) => copy this.generics\n         }\n     }\n }\n@@ -76,7 +76,7 @@ pub struct state_ {\n     ident: ast::ident,\n     span: span,\n     dir: direction,\n-    ty_params: ~[ast::ty_param],\n+    generics: ast::Generics,\n     messages: @mut ~[message],\n     proto: protocol\n }\n@@ -100,7 +100,7 @@ pub impl state_ {\n     fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(self.ty_params)))\n+                cx.ty_vars(&self.generics.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n@@ -161,7 +161,7 @@ pub impl protocol_ {\n \n     fn has_ty_params(&mut self) -> bool {\n         for self.states.each |s| {\n-            if s.ty_params.len() > 0 {\n+            if s.generics.ty_params.len() > 0 {\n                 return true;\n             }\n         }\n@@ -175,7 +175,7 @@ pub impl protocol_ {\n \n pub impl protocol {\n     fn add_state_poly(&self, +name: ~str, ident: ast::ident, dir: direction,\n-                      +ty_params: ~[ast::ty_param]) -> state {\n+                      +generics: ast::Generics) -> state {\n         let messages = @mut ~[];\n \n         let state = @state_ {\n@@ -184,7 +184,7 @@ pub impl protocol {\n             ident: ident,\n             span: self.span,\n             dir: dir,\n-            ty_params: ty_params,\n+            generics: generics,\n             messages: messages,\n             proto: *self\n         };"}, {"sha": "e09d75550058910a77c8064b4493a3c2a6e6027e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -50,12 +50,12 @@ pub mod rt {\n     use print::pprust::{item_to_str, ty_to_str};\n \n     trait ToTokens {\n-        pub fn to_tokens(_cx: ext_ctxt) -> ~[token_tree];\n+        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        pub fn to_tokens(_cx: ext_ctxt) -> ~[token_tree] {\n-            copy self\n+        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree] {\n+            copy *self\n         }\n     }\n \n@@ -75,91 +75,91 @@ pub mod rt {\n \n     trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: ext_ctxt) -> ~str;\n+        pub fn to_source(&self, cx: ext_ctxt) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            copy *cx.parse_sess().interner.get(self)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            copy *cx.parse_sess().interner.get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            item_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            item_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::item] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            ty_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            ty_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::Ty] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n         }\n     }\n \n-    impl ToSource for ~[ast::ty_param] {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            pprust::typarams_to_str(self, cx.parse_sess().interner)\n+    impl ToSource for Generics {\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            pprust::generics_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(cx: ext_ctxt) -> ~str {\n-            pprust::expr_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+            pprust::expr_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::item {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::item] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::Ty] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n-    impl ToTokens for ~[ast::ty_param] {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+    impl ToTokens for Generics {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n-        fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }"}, {"sha": "f9eb2d7e0afca5ff210d9b1ec14dec10a201a633", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -119,19 +119,27 @@ pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n \n // recur along an ExpnInfo chain to find the original expression\n fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n-    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n-    match call_site.expn_info {\n-        Some(next_expn_info) => {\n-            let ExpandedFrom(CallInfo {\n-                callee: NameAndSpan {name, _},\n-                _\n-            }) = *next_expn_info;\n-            // Don't recurse into file using \"include!\"\n-            if name == ~\"include\" { return expn_info; }\n-\n-            topmost_expn_info(next_expn_info)\n-        },\n-        None => expn_info\n+    match *expn_info {\n+        ExpandedFrom(CallInfo { call_site: ref call_site, _ }) => {\n+            match call_site.expn_info {\n+                Some(next_expn_info) => {\n+                    match *next_expn_info {\n+                        ExpandedFrom(CallInfo {\n+                            callee: NameAndSpan { name: ref name, _ },\n+                            _\n+                        }) => {\n+                            // Don't recurse into file using \"include!\"\n+                            if *name == ~\"include\" {\n+                                expn_info\n+                            } else {\n+                                topmost_expn_info(next_expn_info)\n+                            }\n+                        }\n+                    }\n+                },\n+                None => expn_info\n+            }\n+        }\n     }\n }\n "}, {"sha": "8e1d0d7f3e4699a2cd6381fea9dcaf699cfe0bf9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -132,26 +132,38 @@ pub fn fold_fn_decl(decl: &ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     }\n }\n \n-fn fold_ty_param_bound(\n-    tpb: &ty_param_bound,\n-    fld: ast_fold\n-) -> ty_param_bound {\n+fn fold_ty_param_bound(tpb: &TyParamBound, fld: ast_fold) -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param(tp: &ty_param, fld: ast_fold) -> ty_param {\n-    ast::ty_param {\n-        ident: /* FIXME (#2543) */ copy tp.ident,\n-        id: fld.new_id(tp.id),\n-        bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n-    }\n+pub fn fold_ty_param(tp: TyParam, fld: ast_fold) -> TyParam {\n+    TyParam {ident: tp.ident,\n+             id: fld.new_id(tp.id),\n+             bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n+}\n+\n+pub fn fold_ty_params(tps: &OptVec<TyParam>,\n+                      fld: ast_fold) -> OptVec<TyParam> {\n+    tps.map(|tp| fold_ty_param(*tp, fld))\n+}\n+\n+pub fn fold_lifetime(l: &Lifetime, fld: ast_fold) -> Lifetime {\n+    Lifetime {id: fld.new_id(l.id),\n+              span: fld.new_span(l.span),\n+              ident: l.ident}\n+}\n+\n+pub fn fold_lifetimes(lts: &OptVec<Lifetime>,\n+                      fld: ast_fold) -> OptVec<Lifetime> {\n+    lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_ty_params(tps: &[ty_param], fld: ast_fold) -> ~[ty_param] {\n-    tps.map(|x| fold_ty_param(x, fld))\n+pub fn fold_generics(generics: &Generics, fld: ast_fold) -> Generics {\n+    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n+              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n pub fn noop_fold_crate(c: &crate_, fld: ast_fold) -> crate_ {\n@@ -180,15 +192,15 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: ast_fold)\n         attrs: ni.attrs.map(|x| fold_attribute(*x)),\n         node:\n             match ni.node {\n-                foreign_item_fn(ref fdec, purity, ref tps) => {\n+                foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n                             inputs: fdec.inputs.map(|a| fold_arg(*a)),\n                             output: fld.fold_ty(fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n-                        fold_ty_params(*tps, fld))\n+                        fold_generics(generics, fld))\n                 }\n                 foreign_item_const(t) => {\n                     foreign_item_const(fld.fold_ty(t))\n@@ -221,25 +233,23 @@ fn noop_fold_struct_field(sf: @struct_field, fld: ast_fold)\n \n pub fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n     match *i {\n-        item_const(t, e) => {\n-            item_const(fld.fold_ty(t), fld.fold_expr(e))\n-        }\n-        item_fn(ref decl, purity, ref tps, ref body) => {\n+        item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n+        item_fn(ref decl, purity, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n                 purity,\n-                fold_ty_params(*tps, fld),\n+                fold_generics(generics, fld),\n                 fld.fold_block(body)\n             )\n         }\n         item_mod(ref m) => item_mod(fld.fold_mod(m)),\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(fld.fold_foreign_mod(nm))\n         }\n-        item_ty(t, ref tps) => {\n-            item_ty(fld.fold_ty(t), fold_ty_params(*tps, fld))\n+        item_ty(t, ref generics) => {\n+            item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n         }\n-        item_enum(ref enum_definition, ref tps) => {\n+        item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n                 ast::enum_def(\n                     ast::enum_def_ {\n@@ -251,29 +261,29 @@ pub fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n                         }\n                     }\n                 ),\n-                fold_ty_params(*tps, fld))\n+                fold_generics(generics, fld))\n         }\n-        item_struct(ref struct_def, ref tps) => {\n+        item_struct(ref struct_def, ref generics) => {\n             let struct_def = fold_struct_def(*struct_def, fld);\n-            item_struct(struct_def, /* FIXME (#2543) */ copy *tps)\n+            item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n         }\n-        item_impl(ref tps, ifce, ty, ref methods) => {\n+        item_impl(ref generics, ifce, ty, ref methods) => {\n             item_impl(\n-                fold_ty_params(*tps, fld),\n+                fold_generics(generics, fld),\n                 ifce.map(|p| fold_trait_ref(*p, fld)),\n                 fld.fold_ty(ty),\n                 methods.map(|x| fld.fold_method(*x))\n             )\n         }\n-        item_trait(ref tps, ref traits, ref methods) => {\n+        item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n                     required(*) => copy *method,\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n             item_trait(\n-                fold_ty_params(*tps, fld),\n+                fold_generics(generics, fld),\n                 traits.map(|p| fold_trait_ref(*p, fld)),\n                 methods\n             )\n@@ -328,7 +338,7 @@ fn noop_fold_method(m: @method, fld: ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n-        tps: fold_ty_params(m.tps, fld),\n+        generics: fold_generics(&m.generics, fld),\n         self_ty: m.self_ty,\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),"}, {"sha": "052a3e48791b7bad72780a0c9e31ac9f6b96b457", "filename": "src/libsyntax/opt_vec.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ *\n+ * Defines a type OptVec<T> that can be used in place of ~[T].\n+ * OptVec avoids the need for allocation for empty vectors.\n+ * OptVec implements the iterable interface as well as\n+ * other useful things like `push()` and `len()`.\n+ */\n+\n+use core::prelude::*;\n+use core::iter;\n+use core::iter::BaseIter;\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub enum OptVec<T> {\n+    Empty,\n+    Vec(~[T])\n+}\n+\n+pub fn with<T>(+t: T) -> OptVec<T> {\n+    Vec(~[t])\n+}\n+\n+impl<T> OptVec<T> {\n+    fn push(&mut self, +t: T) {\n+        match *self {\n+            Vec(ref mut v) => {\n+                v.push(t);\n+                return;\n+            }\n+            Empty => {}\n+        }\n+\n+        // FIXME(#5074): flow insensitive means we can't move\n+        // assignment inside `match`\n+        *self = Vec(~[t]);\n+    }\n+\n+    fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+        match *self {\n+            Empty => Empty,\n+            Vec(ref v) => Vec(v.map(op))\n+        }\n+    }\n+\n+    pure fn get(&self, i: uint) -> &self/T {\n+        match *self {\n+            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n+            Vec(ref v) => &v[i]\n+        }\n+    }\n+\n+    pure fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    pure fn len(&self) -> uint {\n+        match *self {\n+            Empty => 0,\n+            Vec(ref v) => v.len()\n+        }\n+    }\n+\n+    pure fn to_vec(self) -> ~[T] {\n+        match self {\n+            Empty => ~[],\n+            Vec(v) => v\n+        }\n+    }\n+}\n+\n+impl<T:Copy> OptVec<T> {\n+    fn prepend(&self, +t: T) -> OptVec<T> {\n+        let mut v0 = ~[t];\n+        match *self {\n+            Empty => {}\n+            Vec(ref v1) => { v0.push_all(*v1); }\n+        }\n+        return Vec(v0);\n+    }\n+\n+    fn push_all<I: BaseIter<T>>(&mut self, from: &I) {\n+        for from.each |e| {\n+            self.push(copy *e);\n+        }\n+    }\n+}\n+\n+impl<A:Eq> Eq for OptVec<A> {\n+    pure fn eq(&self, other: &OptVec<A>) -> bool {\n+        // Note: cannot use #[deriving_eq] here because\n+        // (Empty, Vec(~[])) ought to be equal.\n+        match (self, other) {\n+            (&Empty, &Empty) => true,\n+            (&Empty, &Vec(ref v)) => v.is_empty(),\n+            (&Vec(ref v), &Empty) => v.is_empty(),\n+            (&Vec(ref v1), &Vec(ref v2)) => *v1 == *v2\n+        }\n+    }\n+\n+    pure fn ne(&self, other: &OptVec<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl<A> BaseIter<A> for OptVec<A> {\n+    pure fn each(&self, blk: fn(v: &A) -> bool) {\n+        match *self {\n+            Empty => {}\n+            Vec(ref v) => v.each(blk)\n+        }\n+    }\n+\n+    pure fn size_hint(&self) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n+\n+impl<A> iter::ExtendedIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn eachi(&self, blk: fn(+v: uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    #[inline(always)]\n+    pure fn foldl<B>(&self, +b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    #[inline(always)]\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    #[inline(always)]\n+    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    #[inline(always)]\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n+    }\n+\n+}\n+\n+impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    #[inline(always)]\n+    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+}\n+\n+impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n+    }\n+    #[inline(always)]\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    #[inline(always)]\n+    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n+    }\n+}\n+\n+impl<A: Copy+Ord> iter::CopyableOrderedIter<A> for OptVec<A> {\n+    #[inline(always)]\n+    pure fn min(&self) -> A { iter::min(self) }\n+    #[inline(always)]\n+    pure fn max(&self) -> A { iter::max(self) }\n+}"}, {"sha": "f538ed8030c13504a02c04653f7039c70f7caf65", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -20,6 +20,9 @@ use core::option::{None, Option, Some};\n use core::option;\n use std::oldmap::HashMap;\n \n+use opt_vec;\n+use opt_vec::OptVec;\n+\n // SeqSep : a sequence separator (token)\n // and whether a trailing separator is allowed.\n pub struct SeqSep {\n@@ -251,9 +254,9 @@ pub impl Parser {\n     fn parse_seq_to_before_gt<T: Copy>(\n         sep: Option<token::Token>,\n         f: fn(&Parser) -> T\n-    ) -> ~[T] {\n+    ) -> OptVec<T> {\n         let mut first = true;\n-        let mut v = ~[];\n+        let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n             && *self.token != token::BINOP(token::SHR) {\n             match sep {\n@@ -265,33 +268,18 @@ pub impl Parser {\n             }\n             v.push(f(&self));\n         }\n-\n         return v;\n     }\n \n     fn parse_seq_to_gt<T: Copy>(\n         sep: Option<token::Token>,\n         f: fn(&Parser) -> T\n-    ) -> ~[T] {\n+    ) -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n-\n         return v;\n     }\n \n-    // parse a sequence bracketed by '<' and '>'\n-    fn parse_seq_lt_gt<T: Copy>(\n-        sep: Option<token::Token>,\n-        f: fn(&Parser) -> T\n-    ) -> spanned<~[T]> {\n-        let lo = self.span.lo;\n-        self.expect(&token::LT);\n-        let result = self.parse_seq_to_before_gt::<T>(sep, f);\n-        let hi = self.span.hi;\n-        self.expect_gt();\n-        return spanned(lo, hi, result);\n-    }\n-\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket."}, {"sha": "69afa88276543a94d4a7aac5b2668dfabccb7dcf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 117, "deletions": 145, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -51,7 +51,7 @@ use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n use ast::{ty_infer, ty_mac, ty_method};\n-use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr};\n+use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rec, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n use ast::{view_item_, view_item_extern_mod, view_item_use};\n@@ -84,6 +84,8 @@ use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use print::pprust::expr_to_str;\n use util::interner::Interner;\n+use opt_vec;\n+use opt_vec::OptVec;\n \n use core::cmp;\n use core::either::{Either, Left, Right};\n@@ -458,7 +460,7 @@ pub impl Parser {\n             // could change.\n             let ident = p.parse_method_name();\n \n-            let tps = p.parse_ty_params();\n+            let generics = p.parse_generics();\n \n             let (self_ty, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n@@ -483,7 +485,7 @@ pub impl Parser {\n                     attrs: attrs,\n                     purity: pur,\n                     decl: d,\n-                    tps: tps,\n+                    generics: generics,\n                     self_ty: self_ty,\n                     id: p.get_id(),\n                     span: mk_sp(lo, hi)\n@@ -497,7 +499,7 @@ pub impl Parser {\n                 provided(@ast::method {\n                     ident: ident,\n                     attrs: attrs,\n-                    tps: tps,\n+                    generics: generics,\n                     self_ty: self_ty,\n                     purity: pur,\n                     decl: d,\n@@ -958,19 +960,7 @@ pub impl Parser {\n         };\n \n         // Parse any lifetime or type parameters which may appear:\n-        let tps = {\n-            if !self.eat(&token::LT) {\n-                ~[]\n-            } else {\n-                // First consume lifetimes.\n-                let _lifetimes = self.parse_lifetimes();\n-                let result = self.parse_seq_to_gt(\n-                    Some(token::COMMA),\n-                    |p| p.parse_ty(false));\n-                result\n-            }\n-        };\n-\n+        let tps = self.parse_generic_values();\n         let hi = self.span.lo;\n \n         @ast::path { span: mk_sp(lo, hi),\n@@ -1016,7 +1006,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_lifetimes() -> ~[ast::Lifetime] {\n+    fn parse_lifetimes() -> OptVec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -1025,7 +1015,7 @@ pub impl Parser {\n          * lists, where we expect something like `<'a, 'b, T>`.\n          */\n \n-        let mut res = ~[];\n+        let mut res = opt_vec::Empty;\n         loop {\n             match *self.token {\n                 token::LIFETIME(_) => {\n@@ -1201,7 +1191,7 @@ pub impl Parser {\n                         &token::RBRACKET,\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_expr()\n-                    );\n+                    ).to_vec();\n                     ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n@@ -1335,10 +1325,7 @@ pub impl Parser {\n                     self.bump();\n                     let tys = if self.eat(&token::MOD_SEP) {\n                         self.expect(&token::LT);\n-                        self.parse_seq_to_gt(\n-                            Some(token::COMMA),\n-                            |p| p.parse_ty(false)\n-                        )\n+                        self.parse_generic_values_after_lt()\n                     } else {\n                         ~[]\n                     };\n@@ -1487,7 +1474,7 @@ pub impl Parser {\n                                 &ket,\n                                 seq_sep_none(),\n                                 |p| p.parse_token_tree()\n-                            ),\n+                            ).to_vec(),\n                             // the close delimiter:\n                             ~[parse_any_tt_tok(&self)]\n                         )\n@@ -2719,82 +2706,103 @@ pub impl Parser {\n         if self.eat_keyword(&~\"once\") { ast::Once } else { ast::Many }\n     }\n \n-    fn parse_optional_ty_param_bounds() -> @~[ty_param_bound] {\n-        let mut bounds = ~[];\n-        if self.eat(&token::COLON) {\n-            loop {\n-                if self.eat(&token::BINOP(token::AND)) {\n-                    if self.eat_keyword(&~\"static\") {\n-                        bounds.push(RegionTyParamBound);\n-                    } else {\n-                        self.span_err(*self.span,\n-                                      ~\"`&static` is the only permissible \\\n-                                        region bound here\");\n-                    }\n-                } else if is_ident(&*self.token) {\n-                    let maybe_bound = match *self.token {\n-                      token::IDENT(copy sid, _) => {\n-                        match *self.id_to_str(sid) {\n+    fn parse_optional_ty_param_bounds() -> @OptVec<TyParamBound> {\n+        if !self.eat(&token::COLON) {\n+            return @opt_vec::Empty;\n+        }\n \n-                          ~\"send\"\n-                          | ~\"copy\"\n-                          | ~\"const\"\n-                          | ~\"owned\" => {\n-                            self.obsolete(*self.span,\n-                                          ObsoleteLowerCaseKindBounds);\n-                            // Bogus value, but doesn't matter, since\n-                            // is an error\n-                            Some(TraitTyParamBound(self.mk_ty_path(sid)))\n-                          }\n-\n-                          _ => None\n+        let mut result = opt_vec::Empty;\n+        loop {\n+            if self.eat(&token::BINOP(token::AND)) {\n+                if self.eat_keyword(&~\"static\") {\n+                    result.push(RegionTyParamBound);\n+                } else {\n+                    self.span_err(*self.span,\n+                                  ~\"`&static` is the only permissible \\\n+                                    region bound here\");\n+                }\n+            } else if is_ident(&*self.token) {\n+                let maybe_bound = match *self.token {\n+                    token::IDENT(copy sid, _) => {\n+                        match *self.id_to_str(sid) {\n+                            ~\"send\" |\n+                            ~\"copy\" |\n+                            ~\"const\" |\n+                            ~\"owned\" => {\n+                                self.obsolete(\n+                                    *self.span,\n+                                    ObsoleteLowerCaseKindBounds);\n+\n+                                // Bogus value, but doesn't matter, since\n+                                // is an error\n+                                Some(TraitTyParamBound(\n+                                    self.mk_ty_path(sid)))\n+                            }\n+                            _ => None\n                         }\n-                      }\n-                      _ => self.bug(\n-                          ~\"is_ident() said this would be an identifier\")\n-                    };\n+                    }\n+                    _ => fail!()\n+                };\n \n-                    match maybe_bound {\n-                        Some(bound) => {\n-                            self.bump();\n-                            bounds.push(bound);\n-                        }\n-                        None => {\n-                            let ty = self.parse_ty(false);\n-                            bounds.push(TraitTyParamBound(ty));\n-                        }\n+                match maybe_bound {\n+                    Some(bound) => {\n+                        self.bump();\n+                        result.push(bound);\n+                    }\n+                    None => {\n+                        let ty = self.parse_ty(false);\n+                        result.push(TraitTyParamBound(ty));\n                     }\n-                } else {\n-                    break;\n                 }\n+            } else {\n+                break;\n+            }\n \n-                if self.eat(&token::BINOP(token::PLUS)) {\n-                    loop;\n-                }\n+            if self.eat(&token::BINOP(token::PLUS)) {\n+                loop;\n+            }\n \n-                if is_ident_or_path(&*self.token) {\n-                    self.obsolete(*self.span,\n-                                  ObsoleteTraitBoundSeparator);\n-                }\n+            if is_ident_or_path(&*self.token) {\n+                self.obsolete(*self.span,\n+                              ObsoleteTraitBoundSeparator);\n             }\n         }\n-        return @bounds;\n+\n+        return @result;\n     }\n \n-    fn parse_ty_param() -> ty_param {\n+    fn parse_ty_param() -> TyParam {\n         let ident = self.parse_ident();\n         let bounds = self.parse_optional_ty_param_bounds();\n-        ast::ty_param { ident: ident, id: self.get_id(), bounds: bounds }\n+        ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n-    fn parse_ty_params() -> ~[ty_param] {\n+    fn parse_generics() -> ast::Generics {\n         if self.eat(&token::LT) {\n-            let _lifetimes = self.parse_lifetimes();\n-            self.parse_seq_to_gt(\n+            let lifetimes = self.parse_lifetimes();\n+            let ty_params = self.parse_seq_to_gt(\n                 Some(token::COMMA),\n-                |p| p.parse_ty_param()\n-            )\n-        } else { ~[] }\n+                |p| p.parse_ty_param());\n+            ast::Generics { lifetimes: lifetimes, ty_params: ty_params }\n+        } else {\n+            ast_util::empty_generics()\n+        }\n+    }\n+\n+    fn parse_generic_values() -> ~[@Ty] {\n+        if !self.eat(&token::LT) {\n+            ~[]\n+        } else {\n+            self.parse_generic_values_after_lt()\n+        }\n+    }\n+\n+    fn parse_generic_values_after_lt() -> ~[@Ty] {\n+        let _lifetimes = self.parse_lifetimes();\n+        let result = self.parse_seq_to_gt(\n+            Some(token::COMMA),\n+            |p| p.parse_ty(false));\n+        result.to_vec()\n     }\n \n     fn parse_fn_decl(parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n@@ -2896,7 +2904,7 @@ pub impl Parser {\n                         &token::RPAREN,\n                         sep,\n                         parse_arg_fn\n-                    );\n+                    ).to_vec();\n                 }\n                 token::RPAREN => {\n                     args_or_capture_items = ~[];\n@@ -2916,7 +2924,7 @@ pub impl Parser {\n                 &token::RPAREN,\n                 sep,\n                 parse_arg_fn\n-            );\n+            ).to_vec();\n         }\n \n         self.expect(&token::RPAREN);\n@@ -2961,10 +2969,10 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_fn_header() -> (ident, ~[ty_param]) {\n+    fn parse_fn_header() -> (ident, ast::Generics) {\n         let id = self.parse_value_ident();\n-        let ty_params = self.parse_ty_params();\n-        (id, ty_params)\n+        let generics = self.parse_generics();\n+        (id, generics)\n     }\n \n     fn mk_item(+lo: BytePos, +hi: BytePos, +ident: ident,\n@@ -2979,10 +2987,10 @@ pub impl Parser {\n     }\n \n     fn parse_item_fn(purity: purity) -> item_info {\n-        let (ident, tps) = self.parse_fn_header();\n+        let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (ident, item_fn(decl, purity, tps, body), Some(inner_attrs))\n+        (ident, item_fn(decl, purity, generics, body), Some(inner_attrs))\n     }\n \n     fn parse_method_name() -> ident {\n@@ -2999,7 +3007,7 @@ pub impl Parser {\n         let visa = self.parse_visibility();\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n-        let tps = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         let (self_ty, decl) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n@@ -3012,7 +3020,7 @@ pub impl Parser {\n         @ast::method {\n             ident: ident,\n             attrs: attrs,\n-            tps: tps,\n+            generics: generics,\n             self_ty: self_ty,\n             purity: pur,\n             decl: decl,\n@@ -3027,7 +3035,7 @@ pub impl Parser {\n     fn parse_item_trait() -> item_info {\n         let ident = self.parse_ident();\n         self.parse_region_param();\n-        let tps = self.parse_ty_params();\n+        let tps = self.parse_generics();\n \n         // Parse traits, if necessary.\n         let traits;\n@@ -3055,12 +3063,7 @@ pub impl Parser {\n         }\n \n         // First, parse type parameters if necessary.\n-        let mut tps;\n-        if *self.token == token::LT {\n-            tps = self.parse_ty_params();\n-        } else {\n-            tps = ~[];\n-        }\n+        let generics = self.parse_generics();\n \n         // This is a new-style impl declaration.\n         // XXX: clownshoes\n@@ -3108,37 +3111,7 @@ pub impl Parser {\n             }\n         }\n \n-        (ident, item_impl(tps, opt_trait, ty, meths), None)\n-    }\n-\n-    // Instantiates ident <i> with references to <typarams> as arguments.\n-    // Used to create a path that refers to a class which will be defined as\n-    // the return type of the ctor function.\n-    fn ident_to_path_tys(i: ident,\n-                         typarams: ~[ty_param]) -> @path {\n-        let s = *self.last_span;\n-\n-        @ast::path {\n-             span: s,\n-             global: false,\n-             idents: ~[i],\n-             rp: None,\n-             types: do typarams.map |tp| {\n-                @Ty {\n-                    id: self.get_id(),\n-                    node: ty_path(ident_to_path(s, tp.ident), self.get_id()),\n-                    span: s\n-                }\n-            }\n-         }\n-    }\n-\n-    fn ident_to_path(i: ident) -> @path {\n-        @ast::path { span: *self.last_span,\n-                     global: false,\n-                     idents: ~[i],\n-                     rp: None,\n-                     types: ~[] }\n+        (ident, item_impl(generics, opt_trait, ty, meths), None)\n     }\n \n     fn parse_trait_ref() -> @trait_ref {\n@@ -3153,13 +3126,13 @@ pub impl Parser {\n             ket,\n             seq_sep_none(),\n             |p| p.parse_trait_ref()\n-        )\n+        ).to_vec()\n     }\n \n     fn parse_item_struct() -> item_info {\n         let class_name = self.parse_value_ident();\n         self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         if self.eat(&token::COLON) {\n             self.obsolete(copy *self.span, ObsoleteClassTraits);\n             let _ = self.parse_trait_ref_list(&token::LBRACE);\n@@ -3242,7 +3215,7 @@ pub impl Parser {\n              fields: fields,\n              dtor: actual_dtor,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None }\n-         }, ty_params),\n+         }, generics),\n          None)\n     }\n \n@@ -3520,13 +3493,13 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n-        let (ident, tps) = self.parse_fn_header();\n+        let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n-                             node: foreign_item_fn(decl, purity, tps),\n+                             node: foreign_item_fn(decl, purity, generics),\n                              id: self.get_id(),\n                              span: mk_sp(lo, hi),\n                              vis: vis }\n@@ -3696,7 +3669,7 @@ pub impl Parser {\n     fn parse_item_type() -> item_info {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n-        let tps = self.parse_ty_params();\n+        let tps = self.parse_generics();\n         self.expect(&token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(&token::SEMI);\n@@ -3752,9 +3725,8 @@ pub impl Parser {\n         };\n     }\n \n-    fn parse_enum_def(ty_params: ~[ast::ty_param])\n-                   -> enum_def {\n-        let mut variants: ~[variant] = ~[];\n+    fn parse_enum_def(generics: &ast::Generics) -> enum_def {\n+        let mut variants = ~[];\n         let mut all_nullary = true, have_disr = false;\n         let mut common_fields = None;\n \n@@ -3780,7 +3752,7 @@ pub impl Parser {\n             if self.eat_keyword(&~\"enum\") {\n                 ident = self.parse_ident();\n                 self.expect(&token::LBRACE);\n-                let nested_enum_def = self.parse_enum_def(ty_params);\n+                let nested_enum_def = self.parse_enum_def(generics);\n                 kind = enum_variant_kind(nested_enum_def);\n                 needs_comma = false;\n             } else {\n@@ -3838,7 +3810,7 @@ pub impl Parser {\n     fn parse_item_enum() -> item_info {\n         let id = self.parse_ident();\n         self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n+        let generics = self.parse_generics();\n         // Newtype syntax\n         if *self.token == token::EQ {\n             self.bump();\n@@ -3861,14 +3833,14 @@ pub impl Parser {\n                     enum_def(\n                         ast::enum_def_ { variants: ~[variant], common: None }\n                     ),\n-                    ty_params),\n+                    generics),\n                 None\n             );\n         }\n         self.expect(&token::LBRACE);\n \n-        let enum_definition = self.parse_enum_def(ty_params);\n-        (id, item_enum(enum_definition, ty_params), None)\n+        let enum_definition = self.parse_enum_def(&generics);\n+        (id, item_enum(enum_definition, generics), None)\n     }\n \n     fn parse_fn_ty_sigil() -> Option<Sigil> {"}, {"sha": "208ef6fa845ece3fdda5618bd22912d8c86e0f6a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -14,6 +14,8 @@ use ast::{RegionTyParamBound, TraitTyParamBound, required, provided};\n use ast;\n use ast_util;\n use ast_util::{operator_prec};\n+use opt_vec;\n+use opt_vec::OptVec;\n use attr;\n use codemap::{CodeMap, BytePos};\n use codemap;\n@@ -166,19 +168,20 @@ pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n-pub fn typarams_to_str(tps: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n-    to_str(tps, print_type_params, intr)\n+pub fn generics_to_str(generics: &ast::Generics,\n+                       intr: @ident_interner) -> ~str {\n+    to_str(generics, print_generics, intr)\n }\n \n pub fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n-pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n-                  params: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n+pub fn fun_to_str(decl: &ast::fn_decl, name: ast::ident,\n+                  generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        print_fn(s, decl, None, name, params, None, ast::inherited);\n+        print_fn(s, decl, None, name, generics, None, ast::inherited);\n         end(s); // Close the head box\n         end(s); // Close the outer box\n         eof(s.s);\n@@ -302,7 +305,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN)) {\n+pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -424,12 +427,12 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n       }\n       ast::ty_bare_fn(f) => {\n           print_ty_fn(s, Some(f.abi), None, None,\n-                      f.purity, ast::Many, f.decl, None,\n+                      f.purity, ast::Many, &f.decl, None,\n                       None, None);\n       }\n       ast::ty_closure(f) => {\n           print_ty_fn(s, None, Some(f.sigil), f.region,\n-                      f.purity, f.onceness, f.decl, None,\n+                      f.purity, f.onceness, &f.decl, None,\n                       None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n@@ -461,8 +464,8 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     match /*bad*/ copy item.node {\n-      ast::foreign_item_fn(decl, purity, typarams) => {\n-        print_fn(s, decl, Some(purity), item.ident, typarams, None,\n+      ast::foreign_item_fn(ref decl, purity, ref generics) => {\n+        print_fn(s, decl, Some(purity), item.ident, generics, None,\n                  ast::inherited);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n@@ -504,10 +507,10 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n       ast::item_fn(ref decl, purity, ref typarams, ref body) => {\n         print_fn(\n             s,\n-            /* FIXME (#2543) */ copy *decl,\n+            decl,\n             Some(purity),\n             item.ident,\n-            /* FIXME (#2543) */ copy *typarams,\n+            typarams,\n             None,\n             item.vis\n         );\n@@ -538,12 +541,12 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, params) => {\n+      ast::item_ty(ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, ~\"type\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, params);\n+        print_generics(s, params);\n         end(s); // end the inner ibox\n \n         space(s.s);\n@@ -556,21 +559,21 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         print_enum_def(\n             s,\n             *enum_definition,\n-            /* FIXME (#2543) */ copy *params,\n+            params,\n             item.ident,\n             item.span,\n             item.vis\n         );\n       }\n-      ast::item_struct(struct_def, tps) => {\n+      ast::item_struct(struct_def, ref generics) => {\n           head(s, visibility_qualified(item.vis, ~\"struct\"));\n-          print_struct(s, struct_def, tps, item.ident, item.span);\n+          print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(tps, opt_trait, ty, methods) => {\n+      ast::item_impl(ref generics, opt_trait, ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"impl\"));\n-        if !tps.is_empty() {\n-            print_type_params(s, tps);\n+        if !generics.is_empty() {\n+            print_generics(s, generics);\n             space(s.s);\n         }\n \n@@ -596,10 +599,10 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_trait(ref tps, ref traits, ref methods) => {\n+      ast::item_trait(ref generics, ref traits, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, /* FIXME (#2543) */ copy *tps);\n+        print_generics(s, generics);\n         if traits.len() != 0u {\n             word(s.s, ~\":\");\n             for traits.each |trait_| {\n@@ -631,7 +634,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n-                      params: ~[ast::ty_param], ident: ast::ident,\n+                      generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n     let mut newtype =\n         vec::len(enum_definition.variants) == 1u &&\n@@ -650,7 +653,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n     }\n \n     print_ident(s, ident);\n-    print_type_params(s, params);\n+    print_generics(s, generics);\n     space(s.s);\n     if newtype {\n         word_space(s, ~\"=\");\n@@ -707,12 +710,12 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n \n pub fn print_struct(s: @ps,\n                     struct_def: @ast::struct_def,\n-                    tps: ~[ast::ty_param],\n+                    generics: &ast::Generics,\n                     ident: ast::ident,\n                     span: codemap::span) {\n     print_ident(s, ident);\n     nbsp(s);\n-    print_type_params(s, tps);\n+    print_generics(s, generics);\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         popen(s);\n         let mut first = true;\n@@ -824,7 +827,8 @@ pub fn print_variant(s: @ps, v: ast::variant) {\n         }\n         ast::struct_variant_kind(struct_def) => {\n             head(s, ~\"\");\n-            print_struct(s, struct_def, ~[], v.node.name, v.span);\n+            let generics = ast_util::empty_generics();\n+            print_struct(s, struct_def, &generics, v.node.name, v.span);\n         }\n         ast::enum_variant_kind(ref enum_definition) => {\n             print_variants(s, (*enum_definition).variants, v.span);\n@@ -845,7 +849,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n-                m.decl, Some(m.ident), Some(/*bad*/ copy m.tps),\n+                &m.decl, Some(m.ident), Some(&m.generics),\n                 Some(/*bad*/ copy m.self_ty.node));\n     word(s.s, ~\";\");\n }\n@@ -861,8 +865,8 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, meth.decl, Some(meth.purity),\n-             meth.ident, meth.tps, Some(meth.self_ty.node),\n+    print_fn(s, &meth.decl, Some(meth.purity),\n+             meth.ident, &meth.generics, Some(meth.self_ty.node),\n              meth.vis);\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n@@ -1353,7 +1357,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n                              Some(sigil), ast::inherited);\n-        print_fn_args_and_ret(s, /* FIXME (#2543) */ copy *decl, None);\n+        print_fn_args_and_ret(s, decl, None);\n         space(s.s);\n         print_block(s, body);\n       }\n@@ -1363,7 +1367,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        print_fn_block_args(s, /* FIXME (#2543) */ copy *decl);\n+        print_fn_block_args(s, decl);\n         space(s.s);\n         // }\n         assert body.node.stmts.is_empty();\n@@ -1712,21 +1716,21 @@ pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n }\n \n pub fn print_fn(s: @ps,\n-                decl: ast::fn_decl,\n+                decl: &ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 name: ast::ident,\n-                typarams: ~[ast::ty_param],\n+                generics: &ast::Generics,\n                 opt_self_ty: Option<ast::self_ty_>,\n                 vis: ast::visibility) {\n     head(s, ~\"\");\n     print_fn_header_info(s, opt_self_ty, purity, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n-    print_type_params(s, typarams);\n+    print_generics(s, generics);\n     print_fn_args_and_ret(s, decl, opt_self_ty);\n }\n \n-pub fn print_fn_args(s: @ps, decl: ast::fn_decl,\n+pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n                  opt_self_ty: Option<ast::self_ty_>) {\n     // It is unfortunate to duplicate the commasep logic, but we we want the\n     // self type and the args all in the same box.\n@@ -1744,7 +1748,7 @@ pub fn print_fn_args(s: @ps, decl: ast::fn_decl,\n     end(s);\n }\n \n-pub fn print_fn_args_and_ret(s: @ps, decl: ast::fn_decl,\n+pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n                              opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_self_ty);\n@@ -1761,7 +1765,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: @ps, decl: ast::fn_decl) {\n+pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     word(s.s, ~\"|\");\n     print_fn_args(s, decl, None);\n     word(s.s, ~\"|\");\n@@ -1792,34 +1796,53 @@ pub fn print_arg_mode(s: @ps, m: ast::mode) {\n     if ms != ~\"\" { word(s.s, ms); }\n }\n \n-pub fn print_bounds(s: @ps, bounds: @~[ast::ty_param_bound]) {\n+pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n         let mut first = true;\n-        for vec::each(*bounds) |&bound| {\n+        for bounds.each |bound| {\n             nbsp(s);\n             if first {\n                 first = false;\n             } else {\n                 word_space(s, ~\"+\");\n             }\n \n-            match bound {\n+            match *bound {\n                 TraitTyParamBound(ty) => print_type(s, ty),\n                 RegionTyParamBound => word(s.s, ~\"&static\"),\n             }\n         }\n     }\n }\n \n-pub fn print_type_params(s: @ps, &&params: ~[ast::ty_param]) {\n-    if vec::len(params) > 0u {\n+pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n+    word(s.s, ~\"'\");\n+    print_ident(s, lifetime.ident);\n+}\n+\n+pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n+    let total = generics.lifetimes.len() + generics.ty_params.len();\n+    if total > 0 {\n         word(s.s, ~\"<\");\n-        fn printParam(s: @ps, param: ast::ty_param) {\n-            print_ident(s, param.ident);\n-            print_bounds(s, param.bounds);\n+        fn print_item(s: @ps, generics: &ast::Generics, idx: uint) {\n+            if idx < generics.lifetimes.len() {\n+                let lifetime = generics.lifetimes.get(idx);\n+                print_lifetime(s, lifetime);\n+            } else {\n+                let param = generics.ty_params.get(idx);\n+                print_ident(s, param.ident);\n+                print_bounds(s, param.bounds);\n+            }\n         }\n-        commasep(s, inconsistent, params, printParam);\n+\n+        let mut ints = ~[];\n+        for uint::range(0, total) |i| {\n+            ints.push(i);\n+        }\n+\n+        commasep(s, inconsistent, ints,\n+                 |s, i| print_item(s, generics, i));\n         word(s.s, ~\">\");\n     }\n }\n@@ -1954,8 +1977,8 @@ pub fn print_ty_fn(s: @ps,\n                    opt_region: Option<@ast::region>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n-                   decl: ast::fn_decl, id: Option<ast::ident>,\n-                   tps: Option<~[ast::ty_param]>,\n+                   decl: &ast::fn_decl, id: Option<ast::ident>,\n+                   generics: Option<&ast::Generics>,\n                    opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n \n@@ -1969,7 +1992,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match /*bad*/ copy tps { Some(tps) => print_type_params(s, tps), _ => () }\n+    match /*bad*/ copy generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n@@ -2295,14 +2318,15 @@ pub mod test {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n         let abba_ident = mock_interner.intern(@~\"abba\");\n \n-        let decl: ast::fn_decl = ast::fn_decl {\n+        let decl = ast::fn_decl {\n             inputs: ~[],\n             output: @ast::Ty {id: 0,\n                               node: ast::ty_nil,\n                               span: codemap::dummy_sp()},\n             cf: ast::return_val\n         };\n-        check_equal (&fun_to_str(decl, abba_ident, ~[],mock_interner),\n+        let generics = ast_util::empty_generics();\n+        check_equal (&fun_to_str(&decl, abba_ident, &generics, mock_interner),\n                      &~\"fn abba()\");\n     }\n "}, {"sha": "9eb7507f3d0d71827c926da2e2b80ffac2ee8368", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -35,6 +35,7 @@ pub mod syntax {\n     pub use parse;\n }\n \n+pub mod opt_vec;\n pub mod attr;\n pub mod diagnostic;\n pub mod codemap;"}, {"sha": "eac16eac9b6efa6a680ca36663e8d27d5f7a0f94", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -15,6 +15,7 @@ use ast;\n use ast_util;\n use codemap::span;\n use parse;\n+use opt_vec;\n \n use core::option;\n use core::vec;\n@@ -30,17 +31,16 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, &[ty_param], purity), // fn foo()\n-    fk_method(ident, &[ty_param], &method), // fn foo(&self)\n+    fk_item_fn(ident, &Generics, purity),   // fn foo()\n+    fk_method(ident, &Generics, &method),   // fn foo(&self)\n     fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n     fk_fn_block,                            // |x, y| ...\n     fk_dtor( // class destructor\n-        &[ty_param],\n+        &Generics,\n         &[attribute],\n         node_id /* self id */,\n         def_id /* parent class id */\n     )\n-\n }\n \n pub fn name_of_fn(fk: &fn_kind) -> ident {\n@@ -53,11 +53,19 @@ pub fn name_of_fn(fk: &fn_kind) -> ident {\n     }\n }\n \n-pub fn tps_of_fn(fk: &fn_kind) -> ~[ty_param] {\n+pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n     match *fk {\n-        fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n-        fk_dtor(tps, _, _, _) => /* FIXME (#2543) */ vec::from_slice(tps),\n-        fk_anon(*) | fk_fn_block(*) => ~[]\n+        fk_item_fn(_, generics, _) |\n+        fk_method(_, generics, _) |\n+        fk_dtor(generics, _, _, _) => {\n+            copy *generics\n+        }\n+        fk_anon(*) | fk_fn_block(*) => {\n+            Generics {\n+                lifetimes: opt_vec::Empty,\n+                ty_params: opt_vec::Empty,\n+            }\n+        }\n     }\n }\n \n@@ -75,11 +83,11 @@ pub struct Visitor<E> {\n     visit_expr: fn@(@expr, E, vt<E>),\n     visit_expr_post: fn@(@expr, E, vt<E>),\n     visit_ty: fn@(@Ty, E, vt<E>),\n-    visit_ty_params: fn@(&[ty_param], E, vt<E>),\n+    visit_generics: fn@(&Generics, E, vt<E>),\n     visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id, E, vt<E>),\n     visit_ty_method: fn@(&ty_method, E, vt<E>),\n     visit_trait_method: fn@(&trait_method, E, vt<E>),\n-    visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id, E,\n+    visit_struct_def: fn@(@struct_def, ident, &Generics, node_id, E,\n                           vt<E>),\n     visit_struct_field: fn@(@struct_field, E, vt<E>),\n     visit_struct_method: fn@(@method, E, vt<E>)\n@@ -102,7 +110,7 @@ pub fn default_visitor<E>() -> visitor<E> {\n         visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n         visit_expr_post: |_a,_b,_c| (),\n         visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n-        visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n+        visit_generics: |a,b,c|visit_generics::<E>(a, b, c),\n         visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n         visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n         visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n@@ -139,11 +147,11 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             (v.visit_ty)(t, e, v);\n             (v.visit_expr)(ex, e, v);\n         }\n-        item_fn(ref decl, purity, ref tps, ref body) => {\n+        item_fn(ref decl, purity, ref generics, ref body) => {\n             (v.visit_fn)(\n                 &fk_item_fn(\n                     /* FIXME (#2543) */ copy i.ident,\n-                    *tps,\n+                    generics,\n                     purity\n                 ),\n                 decl,\n@@ -161,35 +169,35 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         }\n         item_ty(t, ref tps) => {\n             (v.visit_ty)(t, e, v);\n-            (v.visit_ty_params)(*tps, e, v);\n+            (v.visit_generics)(tps, e, v);\n         }\n         item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_ty_params)(*tps, e, v);\n+            (v.visit_generics)(tps, e, v);\n             visit_enum_def(\n                 *enum_definition,\n-                /* FIXME (#2543) */ copy *tps,\n+                tps,\n                 e,\n                 v\n             );\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n-            (v.visit_ty_params)(*tps, e, v);\n+            (v.visit_generics)(tps, e, v);\n             for traits.each |p| {\n                 visit_path(p.path, e, v);\n-            }\n+        }\n             (v.visit_ty)(ty, e, v);\n             for methods.each |m| {\n                 visit_method_helper(*m, e, v)\n             }\n         }\n-        item_struct(struct_def, ref tps) => {\n-            (v.visit_ty_params)(*tps, e, v);\n-            (v.visit_struct_def)(struct_def, i.ident, *tps, i.id, e, v);\n+        item_struct(struct_def, ref generics) => {\n+            (v.visit_generics)(generics, e, v);\n+            (v.visit_struct_def)(struct_def, i.ident, generics, i.id, e, v);\n         }\n-        item_trait(ref tps, ref traits, ref methods) => {\n-            (v.visit_ty_params)(*tps, e, v);\n+        item_trait(ref generics, ref traits, ref methods) => {\n+            (v.visit_generics)(generics, e, v);\n             for traits.each |p| { visit_path(p.path, e, v); }\n-            for (*methods).each |m| {\n+            for methods.each |m| {\n                 (v.visit_trait_method)(m, e, v);\n             }\n         }\n@@ -198,7 +206,7 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n }\n \n pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n-                         tps: &[ast::ty_param],\n+                         tps: &Generics,\n                          e: E,\n                          v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n@@ -305,27 +313,28 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n \n pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-        foreign_item_fn(ref fd, _, ref tps) => {\n-            (v.visit_ty_params)(*tps, e, v);\n+        foreign_item_fn(ref fd, _, ref generics) => {\n             visit_fn_decl(fd, e, v);\n+            (v.visit_generics)(generics, e, v);\n         }\n         foreign_item_const(t) => {\n             (v.visit_ty)(t, e, v);\n         }\n     }\n }\n \n-pub fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n-    for bounds.each |&bound| {\n-        match bound {\n+pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n+                                e: E, v: vt<E>) {\n+    for bounds.each |bound| {\n+        match *bound {\n             TraitTyParamBound(ty) => (v.visit_ty)(ty, e, v),\n             RegionTyParamBound => ()\n         }\n     }\n }\n \n-pub fn visit_ty_params<E>(tps: &[ty_param], e: E, v: vt<E>) {\n-    for tps.each |tp| {\n+pub fn visit_generics<E>(generics: &Generics, e: E, v: vt<E>) {\n+    for generics.ty_params.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n }\n@@ -346,7 +355,7 @@ pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n     (v.visit_fn)(\n         &fk_method(\n             /* FIXME (#2543) */ copy m.ident,\n-            m.tps,\n+            &m.generics,\n             m\n         ),\n         &m.decl,\n@@ -358,11 +367,11 @@ pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n     );\n }\n \n-pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: &[ty_param],\n+pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n                                    parent_id: def_id, e: E, v: vt<E>) {\n     (v.visit_fn)(\n         &fk_dtor(\n-            tps,\n+            generics,\n             dtor.node.attrs,\n             dtor.node.self_id,\n             parent_id\n@@ -380,13 +389,14 @@ pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: &[ty_param],\n pub fn visit_fn<E>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                    _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n-    (v.visit_ty_params)(tps_of_fn(fk), e, v);\n+    let generics = generics_of_fn(fk);\n+    (v.visit_generics)(&generics, e, v);\n     (v.visit_block)(body, e, v);\n }\n \n pub fn visit_ty_method<E>(m: &ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-    (v.visit_ty_params)(m.tps, e, v);\n+    (v.visit_generics)(&m.generics, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n@@ -397,13 +407,25 @@ pub fn visit_trait_method<E>(m: &trait_method, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: &[ty_param],\n-                           id: node_id, e: E, v: vt<E>) {\n+pub fn visit_struct_def<E>(\n+    sd: @struct_def,\n+    _nm: ast::ident,\n+    generics: &Generics,\n+    id: node_id,\n+    e: E,\n+    v: vt<E>\n+) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n     do sd.dtor.iter |dtor| {\n-        visit_struct_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n+        visit_struct_dtor_helper(\n+            *dtor,\n+            generics,\n+            ast_util::local_def(id),\n+            e,\n+            v\n+        )\n     };\n }\n \n@@ -593,11 +615,11 @@ pub struct SimpleVisitor {\n     visit_expr: fn@(@expr),\n     visit_expr_post: fn@(@expr),\n     visit_ty: fn@(@Ty),\n-    visit_ty_params: fn@(&[ty_param]),\n+    visit_generics: fn@(&Generics),\n     visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n     visit_ty_method: fn@(&ty_method),\n     visit_trait_method: fn@(&trait_method),\n-    visit_struct_def: fn@(@struct_def, ident, &[ty_param], node_id),\n+    visit_struct_def: fn@(@struct_def, ident, &Generics, node_id),\n     visit_struct_field: fn@(@struct_field),\n     visit_struct_method: fn@(@method)\n }\n@@ -621,13 +643,13 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n         visit_expr: |_e| { },\n         visit_expr_post: |_e| { },\n         visit_ty: simple_ignore_ty,\n-        visit_ty_params: fn@(_ps: &[ty_param]) { },\n+        visit_generics: fn@(_ps: &Generics) { },\n         visit_fn: fn@(_fk: &fn_kind, _d: &fn_decl, _b: &blk, _sp: span,\n                       _id: node_id) { },\n         visit_ty_method: fn@(_m: &ty_method) { },\n         visit_trait_method: fn@(_m: &trait_method) { },\n         visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n-                              _tps: &[ty_param], _id: node_id) { },\n+                              _generics: &Generics, _id: node_id) { },\n         visit_struct_field: fn@(_f: @struct_field) { },\n         visit_struct_method: fn@(_m: @method) { }\n     }\n@@ -702,18 +724,26 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m);\n         visit_trait_method(m, e, v);\n     }\n-    fn v_struct_def(f: fn@(@struct_def, ident, &[ty_param], node_id),\n-                    sd: @struct_def, nm: ident, tps: &[ty_param], id: node_id,\n-                    &&e: (), v: vt<()>) {\n-        f(sd, nm, tps, id);\n-        visit_struct_def(sd, nm, tps, id, e, v);\n+    fn v_struct_def(\n+        f: fn@(@struct_def, ident, &Generics, node_id),\n+        sd: @struct_def,\n+        nm: ident,\n+        generics: &Generics,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n+        f(sd, nm, generics, id);\n+        visit_struct_def(sd, nm, generics, id, e, v);\n     }\n-    fn v_ty_params(f: fn@(&[ty_param]),\n-                   ps: &[ty_param],\n-                   &&e: (),\n-                   v: vt<()>) {\n+    fn v_generics(\n+        f: fn@(&Generics),\n+        ps: &Generics,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(ps);\n-        visit_ty_params(ps, e, v);\n+        visit_generics(ps, e, v);\n     }\n     fn v_fn(\n         f: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n@@ -755,9 +785,12 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n                                              a, b, c),\n         visit_ty: visit_ty,\n-        visit_ty_params: |a,b,c| v_ty_params(v.visit_ty_params, a, b, c),\n-        visit_fn: |a,b,c,d,e,f,g| v_fn(v.visit_fn, a, b, c, d, e, f, g),\n-        visit_ty_method: |a,b,c| v_ty_method(v.visit_ty_method, a, b, c),\n+        visit_generics: |a,b,c|\n+            v_generics(v.visit_generics, a, b, c),\n+        visit_fn: |a,b,c,d,e,f,g|\n+            v_fn(v.visit_fn, a, b, c, d, e, f, g),\n+        visit_ty_method: |a,b,c|\n+            v_ty_method(v.visit_ty_method, a, b, c),\n         visit_trait_method: |a,b,c|\n             v_trait_method(v.visit_trait_method, a, b, c),\n         visit_struct_def: |a,b,c,d,e,f|"}, {"sha": "1243d8246034601bda4705701651cbccd4cec6e8", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -124,8 +124,7 @@ vec_reserve_shared_actual(type_desc* ty, rust_vec_box** vp,\n extern \"C\" CDECL void\n vec_reserve_shared(type_desc* ty, rust_vec_box** vp,\n                    size_t n_elts) {\n-    rust_task *task = rust_get_current_task();\n-    reserve_vec_exact(task, vp, n_elts * ty->size);\n+    reserve_vec_exact(vp, n_elts * ty->size);\n }\n \n extern \"C\" CDECL size_t\n@@ -445,9 +444,8 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n     out_tm->tm_nsec = nsec;\n \n     if (zone != NULL) {\n-        rust_task *task = rust_get_current_task();\n         size_t size = strlen(zone);\n-        reserve_vec_exact(task, &out_tm->tm_zone, size + 1);\n+        reserve_vec_exact(&out_tm->tm_zone, size + 1);\n         memcpy(out_tm->tm_zone->body.data, zone, size);\n         out_tm->tm_zone->body.fill = size + 1;\n         out_tm->tm_zone->body.data[size] = '\\0';"}, {"sha": "b0e13717b828952242bb83a22065431da5b106d4", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -118,7 +118,12 @@ extern \"C\" CDECL void\n upcall_fail(char const *expr,\n             char const *file,\n             size_t line) {\n-    rust_task *task = rust_get_current_task();\n+    rust_task *task = rust_try_get_current_task();\n+    if (task == NULL) {\n+        // NOTE: Need to think about what to do here\n+        printf(\"failure outside of a task\");\n+        abort();\n+    }\n     s_fail_args args = {task,expr,file,line};\n     UPCALL_SWITCH_STACK(task, &args, upcall_s_fail);\n }"}, {"sha": "fbedb9bc6efb2f0b6dcd739a851abbf487bbbb9f", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -67,11 +67,12 @@ inline void reserve_vec_exact_shared(rust_task* task, rust_vec_box** vpp,\n     }\n }\n \n-inline void reserve_vec_exact(rust_task* task, rust_vec_box** vpp,\n+inline void reserve_vec_exact(rust_vec_box** vpp,\n                               size_t size) {\n     if (size > (*vpp)->body.alloc) {\n-        *vpp = (rust_vec_box*)task->kernel\n-            ->realloc(*vpp, size + sizeof(rust_vec_box));\n+        rust_exchange_alloc exchange_alloc;\n+        *vpp = (rust_vec_box*)exchange_alloc\n+            .realloc(*vpp, size + sizeof(rust_vec_box));\n         (*vpp)->body.alloc = size;\n     }\n }"}, {"sha": "fed091e0fe681e3a4f3adaac575f1efa9a123c65", "filename": "src/test/run-pass/vec-to_str.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=3953bdd812d73a51f9a7be4a1c57c60d56c6aa1a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    assert (~[0, 1]).to_str() == ~\"[0, 1]\";\n+    assert (&[1, 2]).to_str() == ~\"[1, 2]\";\n+    assert (@[2, 3]).to_str() == ~\"[2, 3]\";\n+\n+    let foo = ~[3, 4];\n+    let bar = &[4, 5];\n+    let baz = @[5, 6];\n+\n+    assert foo.to_str() == ~\"[3, 4]\";\n+    assert bar.to_str() == ~\"[4, 5]\";\n+    assert baz.to_str() == ~\"[5, 6]\";\n+\n+}"}]}