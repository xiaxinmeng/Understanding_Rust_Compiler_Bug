{"sha": "3dc24194434ee918a2ee6e02065c1f11dfb10415", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYzI0MTk0NDM0ZWU5MThhMmVlNmUwMjA2NWMxZjExZGZiMTA0MTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T21:57:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:58:17Z"}, "message": "Convert rustc::syntax::codemap to istrs. Issue #855", "tree": {"sha": "90de2d29aff108b8dc4b84eae7304d83867a9e18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90de2d29aff108b8dc4b84eae7304d83867a9e18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dc24194434ee918a2ee6e02065c1f11dfb10415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dc24194434ee918a2ee6e02065c1f11dfb10415", "html_url": "https://github.com/rust-lang/rust/commit/3dc24194434ee918a2ee6e02065c1f11dfb10415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dc24194434ee918a2ee6e02065c1f11dfb10415/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fb085560d969eb654c0fe0f0e1501dfb3665280", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb085560d969eb654c0fe0f0e1501dfb3665280", "html_url": "https://github.com/rust-lang/rust/commit/9fb085560d969eb654c0fe0f0e1501dfb3665280"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "1d892ed5b52437ea76bcfbba575a4f2005caca08", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=3dc24194434ee918a2ee6e02065c1f11dfb10415", "patch": "@@ -10,6 +10,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import std::istr;\n import syntax::parse::parser::parse_sess;\n \n tag os { os_win32; os_macos; os_linux; }\n@@ -60,34 +61,38 @@ obj session(targ_cfg: @config,\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n     fn span_fatal(sp: span, msg: str) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_error(some(sp), msg, parse_sess.cm);\n+        codemap::emit_error(some(sp), istr::from_estr(msg), parse_sess.cm);\n         fail;\n     }\n     fn fatal(msg: str) -> ! {\n-        codemap::emit_error(none, msg, parse_sess.cm);\n+        codemap::emit_error(none, istr::from_estr(msg), parse_sess.cm);\n         fail;\n     }\n     fn span_err(sp: span, msg: str) {\n-        codemap::emit_error(some(sp), msg, parse_sess.cm);\n+        codemap::emit_error(some(sp), istr::from_estr(msg), parse_sess.cm);\n         err_count += 1u;\n     }\n     fn err(msg: str) {\n-        codemap::emit_error(none, msg, parse_sess.cm);\n+        codemap::emit_error(none, istr::from_estr(msg), parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n         if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n     }\n     fn span_warn(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_warning(some(sp), msg, parse_sess.cm);\n+        codemap::emit_warning(some(sp), istr::from_estr(msg), parse_sess.cm);\n+    }\n+    fn warn(msg: str) {\n+        codemap::emit_warning(none, istr::from_estr(msg), parse_sess.cm);\n     }\n-    fn warn(msg: str) { codemap::emit_warning(none, msg, parse_sess.cm); }\n     fn span_note(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        codemap::emit_note(some(sp), msg, parse_sess.cm);\n+        codemap::emit_note(some(sp), istr::from_estr(msg), parse_sess.cm);\n+    }\n+    fn note(msg: str) {\n+        codemap::emit_note(none, istr::from_estr(msg), parse_sess.cm);\n     }\n-    fn note(msg: str) { codemap::emit_note(none, msg, parse_sess.cm); }\n     fn span_bug(sp: span, msg: str) -> ! {\n         self.span_fatal(sp, #fmt[\"internal compiler error %s\", msg]);\n     }\n@@ -107,7 +112,7 @@ obj session(targ_cfg: @config,\n         ret syntax::parse::parser::next_node_id(parse_sess);\n     }\n     fn span_str(sp: span) -> str {\n-        ret codemap::span_to_str(sp, self.get_codemap());\n+        ret istr::to_estr(codemap::span_to_str(sp, self.get_codemap()));\n     }\n     fn set_main_id(d: node_id) { main_fn = some(d); }\n     fn get_main_id() -> option::t<node_id> { main_fn }"}, {"sha": "21ba2a98a773e68f4461dbc1ab8b81bea033995f", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=3dc24194434ee918a2ee6e02065c1f11dfb10415", "patch": "@@ -73,51 +73,52 @@ tag opt_span {\n }\n type span = {lo: uint, hi: uint, expanded_from: opt_span};\n \n-fn span_to_str(sp: &span, cm: &codemap) -> str {\n+fn span_to_str(sp: &span, cm: &codemap) -> istr {\n     let cur = sp;\n-    let res = \"\";\n+    let res = ~\"\";\n     let prev_file = none;\n     while true {\n         let lo = lookup_char_pos(cm, cur.lo);\n         let hi = lookup_char_pos(cm, cur.hi);\n-        res +=\n+        res += istr::from_estr(\n             #fmt[\"%s:%u:%u: %u:%u\",\n                  if some(lo.filename) == prev_file {\n                      \"-\"\n                  } else {\n                      istr::to_estr(lo.filename)\n-                 }, lo.line, lo.col, hi.line, hi.col];\n+                 }, lo.line, lo.col, hi.line, hi.col]);\n         alt cur.expanded_from {\n           os_none. { break; }\n           os_some(new_sp) {\n             cur = *new_sp;\n             prev_file = some(lo.filename);\n-            res += \"<<\";\n+            res += ~\"<<\";\n           }\n         }\n     }\n \n     ret res;\n }\n \n-fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n+fn emit_diagnostic(sp: &option::t<span>, msg: &istr, kind: &istr, color: u8,\n                    cm: &codemap) {\n-    let ss = \"\";\n+    let ss = ~\"\";\n     let maybe_lines: option::t<@file_lines> = none;\n     alt sp {\n       some(ssp) {\n-        ss = span_to_str(ssp, cm) + \" \";\n+        ss = span_to_str(ssp, cm) + ~\" \";\n         maybe_lines = some(span_to_lines(ssp, cm));\n       }\n       none. { }\n     }\n-    io::stdout().write_str(istr::from_estr(ss));\n+    io::stdout().write_str(ss);\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(istr::from_estr(#fmt[\"%s:\", kind]));\n+    io::stdout().write_str(istr::from_estr(#fmt[\"%s:\", istr::to_estr(kind)]));\n     if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n-    io::stdout().write_str(istr::from_estr(#fmt[\" %s\\n\", msg]));\n+    io::stdout().write_str(istr::from_estr(#fmt[\" %s\\n\",\n+                                                istr::to_estr(msg)]));\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -129,12 +130,11 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n       some(lines) {\n         // If we're not looking at a real file then we can't re-open it to\n         // pull out the lines\n-        if lines.name == \"-\" { ret; }\n+        if lines.name == ~\"-\" { ret; }\n \n         // FIXME: reading in the entire file is the worst possible way to\n         //        get access to the necessary lines.\n-        let file = istr::to_estr(\n-            io::read_whole_file_str(istr::from_estr(lines.name)));\n+        let file = io::read_whole_file_str(lines.name);\n         let fm = get_filemap(cm, lines.name);\n \n         // arbitrarily only print up to six lines of the error\n@@ -151,8 +151,8 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n                 istr::from_estr(#fmt[\"%s:%u \",\n                                      istr::to_estr(fm.name), line + 1u]));\n             let s = get_line(fm, line as int, file);\n-            if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n-            io::stdout().write_str(istr::from_estr(s));\n+            if !istr::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n+            io::stdout().write_str(s);\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n@@ -194,17 +194,17 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n     }\n }\n \n-fn emit_warning(sp: &option::t<span>, msg: &str, cm: &codemap) {\n-    emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n+fn emit_warning(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n+    emit_diagnostic(sp, msg, ~\"warning\", 11u8, cm);\n }\n-fn emit_error(sp: &option::t<span>, msg: &str, cm: &codemap) {\n-    emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n+fn emit_error(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n+    emit_diagnostic(sp, msg, ~\"error\", 9u8, cm);\n }\n-fn emit_note(sp: &option::t<span>, msg: &str, cm: &codemap) {\n-    emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n+fn emit_note(sp: &option::t<span>, msg: &istr, cm: &codemap) {\n+    emit_diagnostic(sp, msg, ~\"note\", 10u8, cm);\n }\n \n-type file_lines = {name: str, lines: [uint]};\n+type file_lines = {name: istr, lines: [uint]};\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n@@ -213,10 +213,10 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     for each i: uint in uint::range(lo.line - 1u, hi.line as uint) {\n         lines += [i];\n     }\n-    ret @{name: istr::to_estr(lo.filename), lines: lines};\n+    ret @{name: lo.filename, lines: lines};\n }\n \n-fn get_line(fm: filemap, line: int, file: &str) -> str {\n+fn get_line(fm: filemap, line: int, file: &istr) -> istr {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end: uint;\n     if line as uint < vec::len(fm.lines) - 1u {\n@@ -225,17 +225,17 @@ fn get_line(fm: filemap, line: int, file: &str) -> str {\n         // If we're not done parsing the file, we're at the limit of what's\n         // parsed. If we just slice the rest of the string, we'll print out\n         // the remainder of the file, which is undesirable.\n-        end = str::byte_len(file);\n-        let rest = str::slice(file, begin, end);\n-        let newline = str::index(rest, '\\n' as u8);\n+        end = istr::byte_len(file);\n+        let rest = istr::slice(file, begin, end);\n+        let newline = istr::index(rest, '\\n' as u8);\n         if newline != -1 { end = begin + (newline as uint); }\n     }\n-    ret str::slice(file, begin, end);\n+    ret istr::slice(file, begin, end);\n }\n \n-fn get_filemap(cm: codemap, filename: str) -> filemap {\n+fn get_filemap(cm: codemap, filename: istr) -> filemap {\n     for fm: filemap in cm.files {\n-        if fm.name == istr::from_estr(filename) { ret fm; }\n+        if fm.name == filename { ret fm; }\n     }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)"}, {"sha": "988c46b6b88a5d9ee4736e4cabcd39d5e37f2727", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=3dc24194434ee918a2ee6e02065c1f11dfb10415", "patch": "@@ -81,7 +81,7 @@ fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n         fn err(m: &istr) {\n             codemap::emit_error(\n                 some(ast_util::mk_sp(chpos, chpos)),\n-                istr::to_estr(m), cm);\n+                m, cm);\n         }\n     }\n     let strs: [istr] = [];"}, {"sha": "0c4b6eac7b9ab0717957a3b865727d887b56b296", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dc24194434ee918a2ee6e02065c1f11dfb10415/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=3dc24194434ee918a2ee6e02065c1f11dfb10415", "patch": "@@ -113,12 +113,12 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         }\n         fn fatal(m: &istr) -> ! {\n             codemap::emit_error(some(self.get_span()),\n-                                istr::to_estr(m), sess.cm);\n+                                m, sess.cm);\n             fail;\n         }\n         fn warn(m: &istr) {\n             codemap::emit_warning(some(self.get_span()),\n-                                  istr::to_estr(m), sess.cm);\n+                                  m, sess.cm);\n         }\n         fn restrict(r: restriction) { restr = r; }\n         fn get_restriction() -> restriction { ret restr; }\n@@ -2581,8 +2581,8 @@ fn parse_crate_from_file(input: &istr, cfg: &ast::crate_cfg,\n     } else if istr::ends_with(input, ~\".rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n-        codemap::emit_error(none, \"unknown input file type: \"\n-                            + istr::to_estr(input),\n+        codemap::emit_error(none, ~\"unknown input file type: \"\n+                            + input,\n                             sess.cm);\n         fail\n     }"}]}