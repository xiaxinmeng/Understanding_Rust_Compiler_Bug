{"sha": "ce9c0225c451c00c3eebe4e496185143a18814b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOWMwMjI1YzQ1MWMwMGMzZWViZTRlNDk2MTg1MTQzYTE4ODE0Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T18:18:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T18:18:43Z"}, "message": "auto merge of #6349 : thestinger/rust/explicit_copy, r=thestinger\n\nI removed some of the copies, but most are just made explicit. The usage in `libcore` was already fixed, but the attribute was only set to warn (not removed).", "tree": {"sha": "c7e9b5e57ad703323939c5f95947bb31cfa26e38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7e9b5e57ad703323939c5f95947bb31cfa26e38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce9c0225c451c00c3eebe4e496185143a18814b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9c0225c451c00c3eebe4e496185143a18814b9", "html_url": "https://github.com/rust-lang/rust/commit/ce9c0225c451c00c3eebe4e496185143a18814b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce9c0225c451c00c3eebe4e496185143a18814b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4c6e587d631c0316d51c9b4a50d406f38221cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4c6e587d631c0316d51c9b4a50d406f38221cd", "html_url": "https://github.com/rust-lang/rust/commit/7a4c6e587d631c0316d51c9b4a50d406f38221cd"}, {"sha": "2bc12635a24abf710304c06a91dbf3709cba8fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc12635a24abf710304c06a91dbf3709cba8fd4", "html_url": "https://github.com/rust-lang/rust/commit/2bc12635a24abf710304c06a91dbf3709cba8fd4"}], "stats": {"total": 211, "additions": 105, "deletions": 106}, "files": [{"sha": "31229967e934e603aed1d681e678dc418317cc59", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -60,7 +60,6 @@ they contained the following prologue:\n // Don't link to core. We are core.\n #[no_core];\n \n-#[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_mutable_fields)];\n "}, {"sha": "7af68f3321d4925e4fcf77031b078a5ea1221404", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -498,7 +498,7 @@ mod tests {\n \n             let arc_v = p.recv();\n \n-            let v = *arc::get::<~[int]>(&arc_v);\n+            let v = copy *arc::get::<~[int]>(&arc_v);\n             assert!(v[3] == 4);\n         };\n "}, {"sha": "b1b2fa2cd28e1137a63c4391438361165c57c336", "filename": "src/libstd/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -238,8 +238,8 @@ mod test {\n \n     #[test]\n     fn test_sendable_future() {\n-        let expected = ~\"schlorf\";\n-        let f = Cell(do spawn { copy expected });\n+        let expected = \"schlorf\";\n+        let f = Cell(do spawn { expected });\n         do task::spawn {\n             let mut f = f.take();\n             let actual = f.get();"}, {"sha": "bc61f156c62dd87242e3fc078b892f4094679a95", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -229,13 +229,13 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n-        let cur = args[i];\n+        let cur = copy args[i];\n         let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n         } else if cur == ~\"--\" {\n             let mut j = i + 1;\n-            while j < l { free.push(args[j]); j += 1; }\n+            while j < l { free.push(copy args[j]); j += 1; }\n             break;\n         } else {\n             let mut names;\n@@ -248,8 +248,8 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                     names = ~[Long(tail)];\n                 } else {\n                     names =\n-                        ~[Long(tail_eq[0])];\n-                    i_arg = Some(tail_eq[1]);\n+                        ~[Long(copy tail_eq[0])];\n+                    i_arg = Some(copy tail_eq[1]);\n                 }\n             } else {\n                 let mut j = 1;\n@@ -266,7 +266,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                        interpreted correctly\n                     */\n \n-                    match find_opt(opts, opt) {\n+                    match find_opt(opts, copy opt) {\n                       Some(id) => last_valid_opt_id = Some(id),\n                       None => {\n                         let arg_follows =\n@@ -292,7 +292,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut name_pos = 0;\n             for names.each() |nm| {\n                 name_pos += 1;\n-                let optid = match find_opt(opts, *nm) {\n+                let optid = match find_opt(opts, copy *nm) {\n                   Some(id) => id,\n                   None => return Err(UnrecognizedOption(name_str(nm)))\n                 };\n@@ -305,18 +305,18 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.get()));\n+                        vals[optid].push(Val((copy i_arg).get()));\n                     } else if name_pos < names.len() ||\n                                   i + 1 == l || is_arg(args[i + 1]) {\n                         vals[optid].push(Given);\n-                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(copy args[i])); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.get()));\n+                        vals[optid].push(Val((copy i_arg).get()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n-                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                    } else { i += 1; vals[optid].push(Val(copy args[i])); }\n                   }\n                 }\n             }\n@@ -346,15 +346,15 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n \n fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {\n     return match find_opt(mm.opts, mkname(nm)) {\n-      Some(id) => mm.vals[id],\n+      Some(id) => copy mm.vals[id],\n       None => {\n         error!(\"No option '%s' defined\", nm);\n         fail!()\n       }\n     };\n }\n \n-fn opt_val(mm: &Matches, nm: &str) -> Optval { return opt_vals(mm, nm)[0]; }\n+fn opt_val(mm: &Matches, nm: &str) -> Optval { copy opt_vals(mm, nm)[0] }\n \n /// Returns true if an option was matched\n pub fn opt_present(mm: &Matches, nm: &str) -> bool {\n@@ -547,25 +547,29 @@ pub mod groups {\n     // translate OptGroup into Opt\n     // (both short and long names correspond to different Opts)\n     pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n-        match ((*lopt).short_name.len(),\n-               (*lopt).long_name.len()) {\n+        let OptGroup{short_name: short_name,\n+                     long_name: long_name,\n+                     hasarg: hasarg,\n+                     occur: occur,\n+                     _} = copy *lopt;\n \n+        match (short_name.len(), long_name.len()) {\n            (0,0) => fail!(~\"this long-format option was given no name\"),\n \n-           (0,_) => ~[Opt {name:   Long(((*lopt).long_name)),\n-                           hasarg: (*lopt).hasarg,\n-                           occur:  (*lopt).occur}],\n+           (0,_) => ~[Opt {name: Long((long_name)),\n+                           hasarg: hasarg,\n+                           occur: occur}],\n \n-           (1,0) => ~[Opt {name: Short(str::char_at((*lopt).short_name, 0)),\n-                           hasarg: (*lopt).hasarg,\n-                           occur:  (*lopt).occur}],\n+           (1,0) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+                           hasarg: hasarg,\n+                           occur: occur}],\n \n-           (1,_) => ~[Opt {name: Short(str::char_at((*lopt).short_name, 0)),\n-                           hasarg: (*lopt).hasarg,\n-                           occur:  (*lopt).occur},\n-                      Opt {name:   Long(((*lopt).long_name)),\n-                           hasarg: (*lopt).hasarg,\n-                           occur:  (*lopt).occur}],\n+           (1,_) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+                           hasarg: hasarg,\n+                           occur:  occur},\n+                      Opt {name:   Long((long_name)),\n+                           hasarg: hasarg,\n+                           occur:  occur}],\n \n            (_,_) => fail!(~\"something is wrong with the long-form opt\")\n         }\n@@ -586,11 +590,12 @@ pub mod groups {\n         let desc_sep = ~\"\\n\" + str::repeat(~\" \", 24);\n \n         let rows = vec::map(opts, |optref| {\n-            let short_name = (*optref).short_name;\n-            let long_name = (*optref).long_name;\n-            let hint = (*optref).hint;\n-            let desc = (*optref).desc;\n-            let hasarg = (*optref).hasarg;\n+            let OptGroup{short_name: short_name,\n+                         long_name: long_name,\n+                         hint: hint,\n+                         desc: desc,\n+                         hasarg: hasarg,\n+                         _} = copy *optref;\n \n             let mut row = str::repeat(~\" \", 4);\n \n@@ -620,7 +625,7 @@ pub mod groups {\n             row += if rowlen < 24 {\n                 str::repeat(~\" \", 24 - rowlen)\n             } else {\n-                desc_sep\n+                copy desc_sep\n             };\n \n             // Normalize desc to contain words separated by one space character\n@@ -892,7 +897,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => {\n-            error!(fail_str(f));\n+            error!(fail_str(copy f));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n           _ => fail!()"}, {"sha": "758e7a5e6cadad2c9bb43b90b853e6bce56d3d4c", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -175,7 +175,7 @@ pub mod v4 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(ref err_data) => fail!(err_data.err_msg)\n+          result::Err(ref err_data) => fail!(copy err_data.err_msg)\n         }\n     }\n     // the simple, old style numberic representation of\n@@ -272,7 +272,7 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => addr,\n-          result::Err(copy err_data) => fail!(err_data.err_msg)\n+          result::Err(copy err_data) => fail!(copy err_data.err_msg)\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {"}, {"sha": "7e47106977fe33fdba4346d8c0c93d73dfccd835", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -277,8 +277,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                                     as *libc::c_void);\n                 let tcp_conn_err = match err_data.err_name {\n                     ~\"ECONNREFUSED\" => ConnectionRefused,\n-                    _ => GenericConnectErr(err_data.err_name,\n-                                           err_data.err_msg)\n+                    _ => GenericConnectErr(copy err_data.err_name,\n+                                           copy err_data.err_msg)\n                 };\n                 result::Err(tcp_conn_err)\n             }\n@@ -769,8 +769,8 @@ fn listen_common(host_ip: ip::IpAddr,\n                     debug!(\"Got '%s' '%s' libuv error\",\n                                     err_data.err_name, err_data.err_msg);\n                     result::Err(\n-                        GenericListenErr(err_data.err_name,\n-                                         err_data.err_msg))\n+                        GenericListenErr(copy err_data.err_name,\n+                                         copy err_data.err_msg))\n                 }\n             }\n         }\n@@ -790,8 +790,8 @@ fn listen_common(host_ip: ip::IpAddr,\n             match kill_result {\n                 // some failure post bind/listen\n                 Some(ref err_data) => result::Err(GenericListenErr(\n-                    err_data.err_name,\n-                    err_data.err_msg)),\n+                    copy err_data.err_name,\n+                    copy err_data.err_msg)),\n                 // clean exit\n                 None => result::Ok(())\n             }\n@@ -1275,7 +1275,7 @@ trait ToTcpErr {\n \n impl ToTcpErr for uv::ll::uv_err_data {\n     fn to_tcp_err(&self) -> TcpErrData {\n-        TcpErrData { err_name: self.err_name, err_msg: self.err_msg }\n+        TcpErrData { err_name: copy self.err_name, err_msg: copy self.err_msg }\n     }\n }\n \n@@ -1447,12 +1447,8 @@ mod test {\n     use uv::iotask::IoTask;\n     use uv;\n \n-    use core::io;\n+    use core::cell::Cell;\n     use core::comm::{stream, SharedChan};\n-    use core::result;\n-    use core::str;\n-    use core::task;\n-    use core::vec;\n \n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1467,7 +1463,6 @@ mod test {\n             #[test]\n             fn test_gl_tcp_server_and_client_ipv4() {\n                 unsafe {\n-                    use net::tcp::test::tcp_ipv4_server_and_client_test::*;\n                     impl_gl_tcp_ipv4_server_and_client();\n                 }\n             }\n@@ -1558,10 +1553,10 @@ mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_server_and_client() {\n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 8888u;\n         let expected_req = ~\"ping\";\n-        let expected_resp = ~\"pong\";\n+        let expected_resp = \"pong\";\n \n         let (server_result_po, server_result_ch) = stream::<~str>();\n \n@@ -1574,7 +1569,7 @@ mod test {\n             let actual_req = run_tcp_test_server(\n                 server_ip,\n                 server_port,\n-                expected_resp,\n+                expected_resp.to_str(),\n                 cont_ch.clone(),\n                 &hl_loop_clone);\n             server_result_ch.send(actual_req);\n@@ -1599,9 +1594,9 @@ mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 8887u;\n-        let expected_resp = ~\"pong\";\n+        let expected_resp = \"pong\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n         let cont_ch = SharedChan::new(cont_ch);\n@@ -1612,7 +1607,7 @@ mod test {\n             run_tcp_test_server(\n                 server_ip,\n                 server_port,\n-                expected_resp,\n+                expected_resp.to_str(),\n                 cont_ch.clone(),\n                 &hl_loop_clone);\n         };\n@@ -1641,7 +1636,7 @@ mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 8889u;\n         let expected_req = ~\"ping\";\n         // client\n@@ -1658,10 +1653,10 @@ mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_server_address_in_use() {\n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 8890u;\n         let expected_req = ~\"ping\";\n-        let expected_resp = ~\"pong\";\n+        let expected_resp = \"pong\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n         let cont_ch = SharedChan::new(cont_ch);\n@@ -1672,7 +1667,7 @@ mod test {\n             run_tcp_test_server(\n                 server_ip,\n                 server_port,\n-                expected_resp,\n+                expected_resp.to_str(),\n                 cont_ch.clone(),\n                 &hl_loop_clone);\n         }\n@@ -1701,7 +1696,7 @@ mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_server_access_denied() {\n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 80u;\n         // this one should fail..\n         let listen_err = run_tcp_test_server_fail(\n@@ -1721,10 +1716,10 @@ mod test {\n     pub fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n \n         let iotask = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 8891u;\n         let expected_req = ~\"ping\";\n-        let expected_resp = ~\"pong\";\n+        let expected_resp = \"pong\";\n \n         let (server_result_po, server_result_ch) = stream::<~str>();\n \n@@ -1737,7 +1732,7 @@ mod test {\n             let actual_req = run_tcp_test_server(\n                 server_ip,\n                 server_port,\n-                expected_resp,\n+                expected_resp.to_str(),\n                 cont_ch.clone(),\n                 &iotask_clone);\n             server_result_ch.send(actual_req);\n@@ -1753,7 +1748,7 @@ mod test {\n         buf_write(sock_buf, expected_req);\n \n         // so contrived!\n-        let actual_resp = do str::as_bytes(&expected_resp) |resp_buf| {\n+        let actual_resp = do str::as_bytes(&expected_resp.to_str()) |resp_buf| {\n             buf_read(sock_buf, resp_buf.len())\n         };\n \n@@ -1770,10 +1765,10 @@ mod test {\n         use core::io::{Reader,ReaderUtil};\n \n         let hl_loop = &uv::global_loop::get();\n-        let server_ip = ~\"127.0.0.1\";\n+        let server_ip = \"127.0.0.1\";\n         let server_port = 10041u;\n         let expected_req = ~\"GET /\";\n-        let expected_resp = ~\"A string\\nwith multiple lines\\n\";\n+        let expected_resp = \"A string\\nwith multiple lines\\n\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n         let cont_ch = SharedChan::new(cont_ch);\n@@ -1784,7 +1779,7 @@ mod test {\n             run_tcp_test_server(\n                 server_ip,\n                 server_port,\n-                expected_resp,\n+                expected_resp.to_str(),\n                 cont_ch.clone(),\n                 &hl_loop_clone);\n         };\n@@ -1827,6 +1822,7 @@ mod test {\n         let (server_po, server_ch) = stream::<~str>();\n         let server_ch = SharedChan::new(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n+        let resp_cell = Cell(resp);\n         let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1838,6 +1834,7 @@ mod test {\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n+                let resp_cell2 = Cell(resp_cell.take());\n                 debug!(\"SERVER: new connection!\");\n                 let (cont_po, cont_ch) = stream();\n                 let server_ch = server_ch.clone();\n@@ -1872,7 +1869,7 @@ mod test {\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             debug!(\"SERVER: before write\");\n-                            tcp_write_single(&sock, str::to_bytes(resp));\n+                            tcp_write_single(&sock, str::to_bytes(resp_cell2.take()));\n                             debug!(\"SERVER: after write.. die\");\n                             kill_ch.send(None);\n                           }"}, {"sha": "5762d8639353ff5a87274fd11f95697bcff9fafb", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -16,7 +16,6 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n-#[deny(vecs_implicitly_copyable)];\n #[deny(deprecated_mutable_fields)];\n \n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};"}, {"sha": "248650452defa207da29963293f636d18464dd69", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -270,8 +270,8 @@ mod tests {\n     }\n \n     fn check_to_vec(data: ~[int]) {\n-        let heap = from_vec(data);\n-        assert!(merge_sort(heap.to_vec(), le) == merge_sort(data, le));\n+        let heap = from_vec(copy data);\n+        assert!(merge_sort((copy heap).to_vec(), le) == merge_sort(data, le));\n         assert!(heap.to_sorted_vec() == merge_sort(data, le));\n     }\n "}, {"sha": "2fa12809db6f8af3fc44046fe9970e0054cecc58", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -822,7 +822,7 @@ pub mod node {\n                   None => break,\n                   Some(x) => {\n                     //FIXME (#2744): Replace with memcpy or something similar\n-                    let local_buf: ~[u8] = cast::transmute(*x.content);\n+                    let local_buf: ~[u8] = cast::transmute(copy *x.content);\n                     let mut i = x.byte_offset;\n                     while i < x.byte_len {\n                         buf[offset] = local_buf[i];\n@@ -1299,12 +1299,12 @@ mod tests {\n         let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n         while i < 10 {\n-            let a = *buf;\n-            let b = *buf;\n+            let a = copy *buf;\n+            let b = copy *buf;\n             *buf = a + b;\n             i+=1;\n         }\n-        let sample = @*buf;\n+        let sample = @copy *buf;\n         let r      = of_str(sample);\n         assert!(char_len(r) == str::char_len(*sample));\n         assert!(rope_to_string(r) == *sample);\n@@ -1335,12 +1335,12 @@ mod tests {\n         let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n         while i < 10 {\n-            let a = *buf;\n-            let b = *buf;\n+            let a = copy *buf;\n+            let b = copy *buf;\n             *buf = a + b;\n             i+=1;\n         }\n-        let sample = @*buf;\n+        let sample = @copy *buf;\n         let r      = of_str(sample);\n \n         let mut len = 0u;\n@@ -1358,15 +1358,15 @@ mod tests {\n     #[test]\n     fn bal1() {\n         let init = @~\"1234567890\";\n-        let buf  = @mut * init;\n+        let buf  = @mut copy *init;\n         let mut i = 0;\n         while i < 8 {\n-            let a = *buf;\n-            let b = *buf;\n+            let a = copy *buf;\n+            let b = copy *buf;\n             *buf = a + b;\n             i+=1;\n         }\n-        let sample = @*buf;\n+        let sample = @copy *buf;\n         let r1     = of_str(sample);\n         let mut r2 = of_str(init);\n         i = 0;"}, {"sha": "4b410ebfdd2fc42951d8dada99cad5ee4854dee5", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -177,7 +177,7 @@ pub fn sha1() -> @Sha1 {\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;\n             let d = (hpart & 0xFFu32) as u8;\n-            rs = vec::append(rs, ~[a, b, c, d]);\n+            rs = vec::append(copy rs, ~[a, b, c, d]);\n         }\n         return rs;\n     }\n@@ -381,7 +381,7 @@ mod tests {\n         for tests.each |t| {\n             sh.input_str(t.input);\n             let out = sh.result();\n-            check_vec_eq(t.output, out);\n+            check_vec_eq(copy t.output, out);\n \n             let out_str = sh.result_str();\n             assert!((out_str.len() == 40));\n@@ -402,7 +402,7 @@ mod tests {\n                 left = left - take;\n             }\n             let out = sh.result();\n-            check_vec_eq(t.output, out);\n+            check_vec_eq(copy t.output, out);\n \n             let out_str = sh.result_str();\n             assert!((out_str.len() == 40));"}, {"sha": "7d013a20c67d7dcafc6d1e6af95176c75c8750e2", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -26,7 +26,6 @@ not required in or otherwise suitable for the core library.\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n \n // Allow mutable fields only in stage0."}, {"sha": "c320bcea77c3b06fd0a3be067706b75fa392763f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -42,9 +42,9 @@ pub enum TestName {\n }\n impl ToStr for TestName {\n     fn to_str(&self) -> ~str {\n-        match self {\n-            &StaticTestName(s) => s.to_str(),\n-            &DynTestName(s) => s.to_str()\n+        match copy *self {\n+            StaticTestName(s) => s.to_str(),\n+            DynTestName(s) => s.to_str()\n         }\n     }\n }\n@@ -145,7 +145,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n \n     let filter =\n         if vec::len(matches.free) > 0 {\n-            option::Some(matches.free[0])\n+            option::Some(copy (matches).free[0])\n         } else { option::None };\n \n     let run_ignored = getopts::opt_present(&matches, ~\"ignored\");\n@@ -203,7 +203,7 @@ pub fn run_tests_console(opts: &TestOpts,\n \n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n-        match *event {\n+        match copy *event {\n           TeFiltered(ref filtered_tests) => {\n             st.total = filtered_tests.len();\n             let noun = if st.total != 1 { ~\"tests\" } else { ~\"test\" };\n@@ -213,7 +213,7 @@ pub fn run_tests_console(opts: &TestOpts,\n               fmt!(\"test %s ... \", test.name.to_str())),\n           TeResult(copy test, result) => {\n             match st.log_out {\n-                Some(f) => write_log(f, result, &test),\n+                Some(f) => write_log(f, copy result, &test),\n                 None => ()\n             }\n             match result {\n@@ -412,7 +412,7 @@ fn run_tests(opts: &TestOpts,\n              callback: @fn(e: TestEvent)) {\n     let mut filtered_tests = filter_tests(opts, tests);\n \n-    let filtered_descs = filtered_tests.map(|t| t.desc);\n+    let filtered_descs = filtered_tests.map(|t| copy t.desc);\n     callback(TeFiltered(filtered_descs));\n \n     let (filtered_tests, filtered_benchs) =\n@@ -442,15 +442,15 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(test.desc));\n+                callback(TeWait(copy test.desc));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(desc));\n+            callback(TeWait(copy desc));\n         }\n         callback(TeResult(desc, result));\n         pending -= 1;\n@@ -565,7 +565,7 @@ pub fn run_test(force_ignore: bool,\n             let task_result = result_future.unwrap().recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n-            monitor_ch.send((desc, test_result));\n+            monitor_ch.send((copy desc, test_result));\n         }\n     }\n \n@@ -850,7 +850,7 @@ mod tests {\n           either::Left(copy o) => o,\n           _ => fail!(~\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(~\"filter\" == opts.filter.get());\n+        assert!(\"filter\" == (copy opts.filter).get());\n     }\n \n     #[test]\n@@ -931,7 +931,7 @@ mod tests {\n             for names.each |name| {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n-                        name: DynTestName(*name),\n+                        name: DynTestName(copy *name),\n                         ignore: false,\n                         should_fail: false\n                     },"}, {"sha": "234982a12bca1480aa535b4075758640a4823189", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -175,9 +175,9 @@ extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n \n #[cfg(test)]\n mod test {\n-\n     use timer::*;\n     use uv;\n+    use core::cell::Cell;\n     use core::rand::RngUtil;\n     use core::pipes::{stream, SharedChan};\n \n@@ -277,11 +277,11 @@ mod test {\n \n         for old_iter::repeat(times as uint) {\n             let mut rng = rand::rng();\n-            let expected = rng.gen_str(16u);\n+            let expected = Cell(rng.gen_str(16u));\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {\n-                delayed_send(&hl_loop_clone, 50u, &test_ch, expected);\n+                delayed_send(&hl_loop_clone, 50u, &test_ch, expected.take());\n             };\n \n             match recv_timeout(&hl_loop, 1u, &test_po) {"}, {"sha": "dc9204f62f4fb22fd34558dfee4304dd674bcb38", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9c0225c451c00c3eebe4e496185143a18814b9/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=ce9c0225c451c00c3eebe4e496185143a18814b9", "patch": "@@ -339,7 +339,7 @@ impl TPrep for Prep {\n                               &self.declared_inputs) &&\n             self.all_fresh(\"discovered input\", disc_in) &&\n             self.all_fresh(\"discovered output\", disc_out) => {\n-                Work::new(@mut *self, Left(json_decode(*res)))\n+                Work::new(@mut copy *self, Left(json_decode(*res)))\n             }\n \n             _ => {\n@@ -358,7 +358,7 @@ impl TPrep for Prep {\n                     let v = blk(&exe);\n                     send_one(chan, (exe, v));\n                 }\n-                Work::new(@mut *self, Right(port))\n+                Work::new(@mut copy *self, Right(port))\n             }\n         }\n     }"}]}