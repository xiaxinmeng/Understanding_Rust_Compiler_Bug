{"sha": "0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNGQwZjM3Y2E5N2JiMGI2OWY1ZjllNzY4MjY5ZGRlNGFjZWRhZTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T02:53:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T04:30:17Z"}, "message": "librustc: Enforce that `extern mod` directives come first, then `use` directives, then items.\n\nResolve them in this order as well.", "tree": {"sha": "75872ca3bdd242b58a2cd1d939f87604f32fc818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75872ca3bdd242b58a2cd1d939f87604f32fc818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "html_url": "https://github.com/rust-lang/rust/commit/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b56a8380b6cca384f4ade7aa1a07b0c5eb77d60", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b56a8380b6cca384f4ade7aa1a07b0c5eb77d60", "html_url": "https://github.com/rust-lang/rust/commit/8b56a8380b6cca384f4ade7aa1a07b0c5eb77d60"}], "stats": {"total": 663, "additions": 330, "deletions": 333}, "files": [{"sha": "e213f4fc6da34f1135cb165b56c6b9c3cd8b44db", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -22,12 +22,6 @@ extern mod std(vers = \"0.6\");\n \n use core::*;\n \n-pub mod procsrv;\n-pub mod util;\n-pub mod header;\n-pub mod runtest;\n-pub mod common;\n-pub mod errors;\n \n use std::getopts;\n use std::test;\n@@ -43,6 +37,13 @@ use common::mode_debug_info;\n use common::mode;\n use util::logv;\n \n+pub mod procsrv;\n+pub mod util;\n+pub mod header;\n+pub mod runtest;\n+pub mod common;\n+pub mod errors;\n+\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);"}, {"sha": "4d91e8f2993db994d47de3902d4b27c6605600b2", "filename": "src/libcore/core.rc", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -65,6 +65,45 @@ they contained the following prologue:\n #[allow(deprecated_mutable_fields)];\n #[allow(deprecated_drop)];\n \n+// Make core testable by not duplicating lang items. See #2912\n+#[cfg(test)] extern mod realcore(name = \"core\", vers = \"0.6\");\n+#[cfg(test)] pub use kinds = realcore::kinds;\n+#[cfg(test)] pub use ops = realcore::ops;\n+#[cfg(test)] pub use cmp = realcore::cmp;\n+\n+/* Reexported core operators */\n+\n+pub use kinds::{Const, Copy, Owned, Durable};\n+pub use ops::{Drop};\n+pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n+pub use ops::{BitAnd, BitOr, BitXor};\n+pub use ops::{Shl, Shr, Index};\n+\n+\n+/* Reexported types and traits */\n+\n+pub use option::{Option, Some, None};\n+pub use result::{Result, Ok, Err};\n+\n+pub use path::Path;\n+pub use path::GenericPath;\n+pub use path::WindowsPath;\n+pub use path::PosixPath;\n+\n+pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use str::{StrSlice};\n+pub use container::{Container, Mutable};\n+pub use vec::{CopyableVector, ImmutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector};\n+pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+\n+pub use num::NumCast;\n+pub use ptr::Ptr;\n+pub use to_str::ToStr;\n+pub use clone::Clone;\n+\n // On Linux, link to the runtime with -lrt.\n #[cfg(target_os = \"linux\")]\n #[doc(hidden)]\n@@ -130,12 +169,6 @@ pub mod managed;\n #[cfg(notest)] pub mod ops;\n #[cfg(notest)] pub mod cmp;\n \n-// Make core testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern mod realcore(name = \"core\", vers = \"0.6\");\n-#[cfg(test)] pub use kinds = realcore::kinds;\n-#[cfg(test)] pub use ops = realcore::ops;\n-#[cfg(test)] pub use cmp = realcore::cmp;\n-\n \n /* Common traits */\n \n@@ -189,39 +222,6 @@ pub mod condition;\n pub mod logging;\n pub mod util;\n \n-/* Reexported core operators */\n-\n-pub use kinds::{Const, Copy, Owned, Durable};\n-pub use ops::{Drop};\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n-pub use ops::{BitAnd, BitOr, BitXor};\n-pub use ops::{Shl, Shr, Index};\n-\n-\n-/* Reexported types and traits */\n-\n-pub use option::{Option, Some, None};\n-pub use result::{Result, Ok, Err};\n-\n-pub use path::Path;\n-pub use path::GenericPath;\n-pub use path::WindowsPath;\n-pub use path::PosixPath;\n-\n-pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use str::{StrSlice};\n-pub use container::{Container, Mutable};\n-pub use vec::{CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector};\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-\n-pub use num::NumCast;\n-pub use ptr::Ptr;\n-pub use to_str::ToStr;\n-pub use clone::Clone;\n-\n \n /* Unsupported interfaces */\n \n@@ -241,7 +241,7 @@ pub mod rt;\n // 'core' so that macro-expanded references to core::error and such\n // can be resolved within libcore.\n #[doc(hidden)]\n-pub mod core {\n+mod core {\n     pub use clone;\n     pub use cmp;\n     pub use condition;"}, {"sha": "4de9f32e7320e3eaf519510af3b67bed729a324d", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -15,13 +15,12 @@ use ptr;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n pub mod raw {\n+    use intrinsic::TyDesc;\n \n     pub static RC_EXCHANGE_UNIQUE : uint = (-1) as uint;\n     pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n     pub static RC_IMMORTAL : uint = 0x77777777;\n \n-    use intrinsic::TyDesc;\n-\n     pub struct BoxHeaderRepr {\n         ref_count: uint,\n         type_desc: *TyDesc,"}, {"sha": "b2e3606eff9de57217613f1857efec0d81de7a5d", "filename": "src/libcore/os.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -1167,14 +1167,6 @@ pub mod consts {\n     #[cfg(windows)]\n     pub use os::consts::windows::*;\n \n-    pub mod unix {\n-        pub static FAMILY: &'static str = \"unix\";\n-    }\n-\n-    pub mod windows {\n-        pub static FAMILY: &'static str = \"windows\";\n-    }\n-\n     #[cfg(target_os = \"macos\")]\n     pub use os::consts::macos::*;\n \n@@ -1190,6 +1182,26 @@ pub mod consts {\n     #[cfg(target_os = \"win32\")]\n     pub use os::consts::win32::*;\n \n+    #[cfg(target_arch = \"x86\")]\n+    pub use os::consts::x86::*;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub use os::consts::x86_64::*;\n+\n+    #[cfg(target_arch = \"arm\")]\n+    pub use os::consts::arm::*;\n+\n+    #[cfg(target_arch = \"mips\")]\n+    use os::consts::mips::*;\n+\n+    pub mod unix {\n+        pub static FAMILY: &'static str = \"unix\";\n+    }\n+\n+    pub mod windows {\n+        pub static FAMILY: &'static str = \"windows\";\n+    }\n+\n     pub mod macos {\n         pub static SYSNAME: &'static str = \"macos\";\n         pub static DLL_PREFIX: &'static str = \"lib\";\n@@ -1226,18 +1238,6 @@ pub mod consts {\n     }\n \n \n-    #[cfg(target_arch = \"x86\")]\n-    pub use os::consts::x86::*;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub use os::consts::x86_64::*;\n-\n-    #[cfg(target_arch = \"arm\")]\n-    pub use os::consts::arm::*;\n-\n-    #[cfg(target_arch = \"mips\")]\n-    use os::consts::mips::*;\n-\n     pub mod x86 {\n         pub static ARCH: &'static str = \"x86\";\n     }"}, {"sha": "afc2c9f3352d34c997b1dbaf64b946bdd7a8a3aa", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 141, "deletions": 203, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -127,6 +127,7 @@ pub enum PatternBindingMode {\n     ArgumentIrrefutableMode(mode)\n }\n \n+#[deriving(Eq)]\n pub enum Namespace {\n     TypeNS,\n     ValueNS\n@@ -161,7 +162,6 @@ pub enum NameDefinition {\n     NoNameDefinition,           //< The name was unbound.\n     ChildNameDefinition(def),   //< The name identifies an immediate child.\n     ImportNameDefinition(def)   //< The name identifies an import.\n-\n }\n \n #[deriving(Eq)]\n@@ -177,15 +177,9 @@ pub enum SelfBinding {\n \n pub type ResolveVisitor = vt<()>;\n \n-#[deriving(Eq)]\n-pub enum ImportDirectiveNS {\n-    TypeNSOnly,\n-    AnyNS\n-}\n-\n /// Contains data for specific types of import directives.\n pub enum ImportDirectiveSubclass {\n-    SingleImport(ident /* target */, ident /* source */, ImportDirectiveNS),\n+    SingleImport(ident /* target */, ident /* source */),\n     GlobImport\n }\n \n@@ -210,9 +204,9 @@ pub impl<T> ResolveResult<T> {\n }\n \n pub enum TypeParameters<'self> {\n-    NoTypeParameters,                  //< No type parameters.\n+    NoTypeParameters,                   //< No type parameters.\n     HasTypeParameters(&'self Generics,  //< Type parameters.\n-                      node_id,         //< ID of the enclosing item\n+                      node_id,          //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n                       // This is zero if this is the outermost set of type\n@@ -458,6 +452,10 @@ pub struct Module {\n     children: @mut LinearMap<ident, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n+    // The external module children of this node that were declared with\n+    // `extern mod`.\n+    external_module_children: @mut LinearMap<ident, @mut Module>,\n+\n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n     // blocks.\n@@ -495,6 +493,7 @@ pub fn Module(parent_link: ParentLink,\n         kind: kind,\n         children: @mut LinearMap::new(),\n         imports: @mut ~[],\n+        external_module_children: @mut LinearMap::new(),\n         anonymous_children: @mut LinearMap::new(),\n         import_resolutions: @mut LinearMap::new(),\n         glob_count: 0,\n@@ -968,17 +967,23 @@ pub impl Resolver {\n                 return (child, new_parent);\n             }\n             Some(child) => {\n-                // Enforce the duplicate checking mode. If we're requesting\n-                // duplicate module checking, check that there isn't a module\n-                // in the module with the same name. If we're requesting\n-                // duplicate type checking, check that there isn't a type in\n-                // the module with the same name. If we're requesting\n-                // duplicate value checking, check that there isn't a value in\n-                // the module with the same name. If we're requesting\n-                // duplicate type checking and duplicate value checking, check\n-                // that there isn't a duplicate type and a duplicate value\n-                // with the same name. If no duplicate checking was requested\n-                // at all, do nothing.\n+                // Enforce the duplicate checking mode:\n+                //\n+                // * If we're requesting duplicate module checking, check that\n+                //   there isn't a module in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking, check that\n+                //   there isn't a type in the module with the same name.\n+                //\n+                // * If we're requesting duplicate value checking, check that\n+                //   there isn't a value in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking and duplicate\n+                //   value checking, check that there isn't a duplicate type\n+                //   and a duplicate value with the same name.\n+                //\n+                // * If no duplicate checking was requested at all, do\n+                //   nothing.\n \n                 let mut is_duplicate = false;\n                 match duplicate_checking_mode {\n@@ -1432,16 +1437,10 @@ pub impl Resolver {\n                     let module_ = self.get_module_from_parent(parent);\n                     let state = @mut ImportState();\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, ns, _) => {\n-                            let ns = match ns {\n-                                module_ns => TypeNSOnly,\n-                                type_value_ns => AnyNS\n-                            };\n-\n+                        view_path_simple(binding, full_path, _, _) => {\n                             let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n-                                                         source_ident,\n-                                                         ns);\n+                                                         source_ident);\n                             self.build_import_directive(privacy,\n                                                         module_,\n                                                         module_path,\n@@ -1452,9 +1451,7 @@ pub impl Resolver {\n                         view_path_list(_, ref source_idents, _) => {\n                             for (*source_idents).each |source_ident| {\n                                 let name = source_ident.node.name;\n-                                let subclass = @SingleImport(name,\n-                                                             name,\n-                                                             AnyNS);\n+                                let subclass = @SingleImport(name, name);\n                                 self.build_import_directive(privacy,\n                                                             module_,\n                                                             copy module_path,\n@@ -1479,25 +1476,21 @@ pub impl Resolver {\n                 match find_extern_mod_stmt_cnum(self.session.cstore,\n                                                 node_id) {\n                     Some(crate_id) => {\n-                        let (child_name_bindings, new_parent) =\n-                            self.add_child(name, parent, ForbidDuplicateTypes,\n-                                           view_item.span);\n-\n                         let def_id = def_id { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n-                            (self.get_module_from_parent(new_parent), name);\n-\n-                        child_name_bindings.define_module(Public,\n-                                                          parent_link,\n+                            (self.get_module_from_parent(parent), name);\n+                        let external_module = @mut Module(parent_link,\n                                                           Some(def_id),\n-                                                          NormalModuleKind,\n-                                                          view_item.span);\n-                        self.build_reduced_graph_for_external_crate\n-                            (child_name_bindings.get_module());\n-                    }\n-                    None => {\n-                        /* Ignore. */\n+                                                          NormalModuleKind);\n+\n+                        parent.external_module_children.insert(\n+                            name,\n+                            external_module);\n+\n+                        self.build_reduced_graph_for_external_crate(\n+                            external_module);\n                     }\n+                    None => {}  // Ignore.\n                 }\n             }\n         }\n@@ -1869,7 +1862,7 @@ pub impl Resolver {\n         // the appropriate flag.\n \n         match *subclass {\n-            SingleImport(target, _, _) => {\n+            SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: privacy %? %s::%s\",\n                        privacy,\n@@ -2020,7 +2013,7 @@ pub impl Resolver {\n                                         subclass: ImportDirectiveSubclass)\n                                      -> @~str {\n         match subclass {\n-            SingleImport(_target, source, _ns) => self.session.str_of(source),\n+            SingleImport(_target, source) => self.session.str_of(source),\n             GlobImport => @~\"*\"\n         }\n     }\n@@ -2080,21 +2073,13 @@ pub impl Resolver {\n                 // within. Attempt to resolve the import within it.\n \n                 match *import_directive.subclass {\n-                    SingleImport(target, source, AnyNS) => {\n+                    SingleImport(target, source) => {\n                         resolution_result =\n                             self.resolve_single_import(module_,\n                                                        containing_module,\n                                                        target,\n                                                        source);\n                     }\n-                    SingleImport(target, source, TypeNSOnly) => {\n-                        resolution_result =\n-                            self.resolve_single_module_import(\n-                                module_,\n-                                containing_module,\n-                                target,\n-                                source);\n-                    }\n                     GlobImport => {\n                         let span = import_directive.span;\n                         let privacy = import_directive.privacy;\n@@ -2139,6 +2124,19 @@ pub impl Resolver {\n         return resolution_result;\n     }\n \n+    fn create_name_bindings_from_module(module: @mut Module) -> NameBindings {\n+        NameBindings {\n+            type_def: Some(TypeNsDef {\n+                privacy: Public,\n+                module_def: Some(module),\n+                type_def: None,\n+            }),\n+            value_def: None,\n+            type_span: None,\n+            value_span: None,\n+        }\n+    }\n+\n     fn resolve_single_import(@mut self,\n                              module_: @mut Module,\n                              containing_module: @mut Module,\n@@ -2261,6 +2259,25 @@ pub impl Resolver {\n             }\n         }\n \n+        // If we didn't find a result in the type namespace, search the\n+        // external modules.\n+        match type_result {\n+            BoundResult(*) => {}\n+            _ => {\n+                match containing_module.external_module_children\n+                                       .find(&source) {\n+                    None => {} // Continue.\n+                    Some(module) => {\n+                        let name_bindings =\n+                            @mut Resolver::create_name_bindings_from_module(\n+                                *module);\n+                        type_result = BoundResult(containing_module,\n+                                                  name_bindings);\n+                    }\n+                }\n+            }\n+        }\n+\n         // We've successfully resolved the import. Write the results in.\n         fail_unless!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n@@ -2332,135 +2349,9 @@ pub impl Resolver {\n         return Success(());\n     }\n \n-    fn resolve_single_module_import(@mut self,\n-                                    module_: @mut Module,\n-                                    containing_module: @mut Module,\n-                                    target: ident,\n-                                    source: ident)\n-                                 -> ResolveResult<()> {\n-        debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n-                from `%s`\",\n-               *self.session.str_of(target),\n-               self.module_to_str(containing_module),\n-               *self.session.str_of(source),\n-               self.module_to_str(module_));\n-\n-        // We need to resolve the module namespace for this to succeed.\n-        let mut module_result = UnknownResult;\n-\n-        // Search for direct children of the containing module.\n-        match containing_module.children.find(&source) {\n-            None => {\n-                // Continue.\n-            }\n-            Some(child_name_bindings) => {\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n-                    module_result = BoundResult(containing_module,\n-                                                *child_name_bindings);\n-                }\n-            }\n-        }\n-\n-        // Unless we managed to find a result, search imports as well.\n-        match module_result {\n-            BoundResult(*) => {\n-                // Continue.\n-            }\n-            _ => {\n-                // If there is an unresolved glob at this point in the\n-                // containing module, bail out. We don't know enough to be\n-                // able to resolve this import.\n-\n-                if containing_module.glob_count > 0 {\n-                    debug!(\"(resolving single module import) unresolved \\\n-                            glob; bailing out\");\n-                    return Indeterminate;\n-                }\n-\n-                // Now search the exported imports within the containing\n-                // module.\n-                match containing_module.import_resolutions.find(&source) {\n-                    None => {\n-                        // The containing module definitely doesn't have an\n-                        // exported import with the name in question. We can\n-                        // therefore accurately report that the names are\n-                        // unbound.\n-\n-                        if module_result.is_unknown() {\n-                            module_result = UnboundResult;\n-                        }\n-                    }\n-                    Some(import_resolution)\n-                            if import_resolution.outstanding_references\n-                                == 0 => {\n-                        // The name is an import which has been fully\n-                        // resolved. We can, therefore, just follow it.\n-\n-                        if module_result.is_unknown() {\n-                            match (*import_resolution).target_for_namespace(\n-                                    TypeNS) {\n-                                None => {\n-                                    module_result = UnboundResult;\n-                                }\n-                                Some(target) => {\n-                                    import_resolution.state.used = true;\n-                                    module_result = BoundResult\n-                                        (target.target_module,\n-                                         target.bindings);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    Some(_) => {\n-                        // The import is unresolved. Bail out.\n-                        debug!(\"(resolving single module import) unresolved \\\n-                                import; bailing out\");\n-                        return Indeterminate;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // We've successfully resolved the import. Write the results in.\n-        fail_unless!(module_.import_resolutions.contains_key(&target));\n-        let import_resolution = module_.import_resolutions.get(&target);\n-\n-        match module_result {\n-            BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found module binding\");\n-                import_resolution.type_target =\n-                    Some(Target(target_module, name_bindings));\n-            }\n-            UnboundResult => {\n-                debug!(\"(resolving single import) didn't find module \\\n-                        binding\");\n-            }\n-            UnknownResult => {\n-                fail!(~\"module result should be known at this point\");\n-            }\n-        }\n-\n-        let i = import_resolution;\n-        if i.type_target.is_none() {\n-          // If this name wasn't found in the type namespace, it's\n-          // definitely unresolved.\n-          return Failed;\n-        }\n-\n-        fail_unless!(import_resolution.outstanding_references >= 1);\n-        import_resolution.outstanding_references -= 1;\n-\n-        debug!(\"(resolving single module import) successfully resolved \\\n-               import\");\n-        return Success(());\n-    }\n-\n-\n-    /**\n-     * Resolves a glob import. Note that this function cannot fail; it either\n-     * succeeds or bails out (as importing * from an empty module or a module\n-     * that exports nothing is valid).\n-     */\n+    // Resolves a glob import. Note that this function cannot fail; it either\n+    // succeeds or bails out (as importing * from an empty module or a module\n+    // that exports nothing is valid).\n     fn resolve_glob_import(@mut self,\n                            privacy: Privacy,\n                            module_: @mut Module,\n@@ -2535,8 +2426,8 @@ pub impl Resolver {\n             }\n         }\n \n-        // Add all children from the containing module.\n-        for containing_module.children.each |&(ident, name_bindings)| {\n+        let merge_import_resolution = |ident,\n+                                       name_bindings: @mut NameBindings| {\n             let mut dest_import_resolution;\n             match module_.import_resolutions.find(ident) {\n                 None => {\n@@ -2563,13 +2454,26 @@ pub impl Resolver {\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n                 debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n-                    Some(Target(containing_module, *name_bindings));\n+                    Some(Target(containing_module, name_bindings));\n             }\n             if name_bindings.defined_in_public_namespace(TypeNS) {\n                 debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n-                    Some(Target(containing_module, *name_bindings));\n+                    Some(Target(containing_module, name_bindings));\n             }\n+        };\n+\n+        // Add all children from the containing module.\n+        for containing_module.children.each |&(ident, name_bindings)| {\n+            merge_import_resolution(ident, *name_bindings);\n+        }\n+\n+        // Add external module children from the containing module.\n+        for containing_module.external_module_children.each\n+                |&(ident, module)| {\n+            let name_bindings =\n+                @mut Resolver::create_name_bindings_from_module(*module);\n+            merge_import_resolution(ident, name_bindings);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -2759,7 +2663,6 @@ pub impl Resolver {\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n-\n         match module_.children.find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n@@ -2772,7 +2675,6 @@ pub impl Resolver {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-\n         match module_.import_resolutions.find(&name) {\n             None => {\n                 // Not found; continue.\n@@ -2795,6 +2697,19 @@ pub impl Resolver {\n             }\n         }\n \n+        // Search for external modules.\n+        if namespace == TypeNS {\n+            match module_.external_module_children.find(&name) {\n+                None => {}\n+                Some(module) => {\n+                    let name_bindings =\n+                        @mut Resolver::create_name_bindings_from_module(\n+                            *module);\n+                    return Success(Target(module_, name_bindings));\n+                }\n+            }\n+        }\n+\n         // Finally, proceed up the scope chain looking for parent modules.\n         let mut search_module = module_;\n         loop {\n@@ -3027,7 +2942,8 @@ pub impl Resolver {\n         // Check the list of resolved imports.\n         match module_.import_resolutions.find(&name) {\n             Some(import_resolution) => {\n-                if import_resolution.outstanding_references != 0 {\n+                if import_resolution.privacy == Public &&\n+                        import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import \\\n                             unresolved; bailing out\");\n                     return Indeterminate;\n@@ -3054,8 +2970,19 @@ pub impl Resolver {\n                     }\n                 }\n             }\n-            None => {\n-                // Continue.\n+            None => {} // Continue.\n+        }\n+\n+        // Finally, search through external children.\n+        if namespace == TypeNS {\n+            match module_.external_module_children.find(&name) {\n+                None => {}\n+                Some(module) => {\n+                    let name_bindings =\n+                        @mut Resolver::create_name_bindings_from_module(\n+                            *module);\n+                    return Success(Target(module_, name_bindings));\n+                }\n             }\n         }\n \n@@ -4541,20 +4468,31 @@ pub impl Resolver {\n                             (Some(_), _) | (None, _) => {\n                                 // This can happen with external impls, due to\n                                 // the imperfect way we read the metadata.\n-\n-                                return NoNameDefinition;\n                             }\n                         }\n                     }\n-                    None => {\n-                        return NoNameDefinition;\n-                    }\n+                    None => {}\n                 }\n             }\n-            Some(_) | None => {\n-                return NoNameDefinition;\n+            Some(_) | None => {}    // Continue.\n+        }\n+\n+        // Finally, search through external children.\n+        if namespace == TypeNS {\n+            match containing_module.external_module_children.find(&name) {\n+                None => {}\n+                Some(module) => {\n+                    match module.def_id {\n+                        None => {} // Continue.\n+                        Some(def_id) => {\n+                            return ChildNameDefinition(def_mod(def_id));\n+                        }\n+                    }\n+                }\n             }\n         }\n+\n+        return NoNameDefinition;\n     }\n \n     fn intern_module_part_of_path(@mut self, path: @path) -> ~[ident] {"}, {"sha": "e3df3b692fb87c2618ee95b204791ec0090406f7", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -28,11 +28,26 @@\n #[no_core];\n \n extern mod core(vers = \"0.6\");\n-use core::*;\n-\n extern mod std(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n+use core::prelude::*;\n+\n+use driver::driver::{host_triple, optgroups, early_error};\n+use driver::driver::{str_input, file_input, build_session_options};\n+use driver::driver::{build_session, build_configuration, parse_pretty};\n+use driver::driver::{pp_mode, pretty_print_input, list_metadata};\n+use driver::driver::{compile_input};\n+use driver::session;\n+use middle::lint;\n+\n+use core::io::ReaderUtil;\n+use core::result::{Ok, Err};\n+use std::getopts::{groups, opt_present};\n+use std::getopts;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+\n pub mod middle {\n     pub mod trans {\n         pub mod macros;\n@@ -123,23 +138,6 @@ pub mod lib {\n     pub mod llvm;\n }\n \n-use core::prelude::*;\n-\n-use driver::driver::{host_triple, optgroups, early_error};\n-use driver::driver::{str_input, file_input, build_session_options};\n-use driver::driver::{build_session, build_configuration, parse_pretty};\n-use driver::driver::{pp_mode, pretty_print_input, list_metadata};\n-use driver::driver::{compile_input};\n-use driver::session;\n-use middle::lint;\n-\n-use core::io::ReaderUtil;\n-use core::result::{Ok, Err};\n-use std::getopts::{groups, opt_present};\n-use std::getopts;\n-use syntax::codemap;\n-use syntax::diagnostic;\n-\n pub fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n@@ -202,7 +200,7 @@ pub fn describe_debug_flags() {\n \n pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n-    logging::console_off();\n+    ::core::logging::console_off();\n \n     let mut args = /*bad*/copy *args;\n     let binary = args.shift();"}, {"sha": "9b19063a90866bcdcdfab4bce731c02b09aaa177", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -28,6 +28,10 @@ extern mod std(vers = \"0.6\");\n extern mod rustc(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n+use config::Config;\n+use doc::Item;\n+use doc::ItemUtils;\n+\n use core::*;\n \n pub mod pass;\n@@ -59,10 +63,6 @@ pub mod escape_pass;\n pub mod prune_private_pass;\n pub mod util;\n \n-use doc::ItemUtils;\n-use doc::Item;\n-use config::Config;\n-\n pub fn main() {\n     let args = os::args();\n "}, {"sha": "50414bf2d1cd7e4e96e4960d36094784a0ed34a0", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -27,6 +27,7 @@ extern mod rustc(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n use core::*;\n+use core::container::Map;\n use core::hashmap::linear::LinearMap;\n use core::io::{ReaderUtil, WriterUtil};\n use rustc::driver::{driver, session};\n@@ -35,13 +36,12 @@ use std::net::url;\n use std::{json, semver, getopts};\n use syntax::codemap::spanned;\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n-use core::container::Map;\n+\n+use util::Package;\n \n mod usage;\n mod util;\n \n-use util::Package;\n-\n struct PackageScript {\n     id: ~str,\n     name: ~str,"}, {"sha": "a0ab714de05f86a3ab8b4ae0f77d18419602d855", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -33,7 +33,7 @@ not required in or otherwise suitable for the core library.\n #[no_core];\n \n extern mod core(vers = \"0.6\");\n-use core::*;\n+use core::prelude::*;\n \n pub mod uv_ll;\n "}, {"sha": "93170668c130d131d9bcddb7b7ec18639d6dc87e", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -563,7 +563,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: ~fn()) {\n-        let testfn_cell = ::cell::Cell(testfn);\n+        let testfn_cell = ::core::cell::Cell(testfn);\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n             task::task().unlinked().future_result(|+r| {"}, {"sha": "53d618e3340a5394a4443c9309da0fa3e703b3d6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -120,6 +120,7 @@ pub enum item_or_view_item {\n     iovi_view_item(@view_item)\n }\n \n+#[deriving(Eq)]\n enum view_item_parse_mode {\n     VIEW_ITEMS_AND_ITEMS_ALLOWED,\n     FOREIGN_ITEMS_ALLOWED,\n@@ -4324,48 +4325,91 @@ pub impl Parser {\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => true,\n             FOREIGN_ITEMS_ALLOWED => false\n         };\n-\n-        let restricted_to_imports = match mode {\n-            IMPORTS_AND_ITEMS_ALLOWED => true,\n-            VIEW_ITEMS_AND_ITEMS_ALLOWED |\n-            FOREIGN_ITEMS_ALLOWED => false\n-        };\n-\n         let foreign_items_allowed = match mode {\n             FOREIGN_ITEMS_ALLOWED => true,\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => false\n         };\n \n+        // First, parse view items.\n         let mut (view_items, items, foreign_items) = (~[], ~[], ~[]);\n-        loop {\n-            match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                               items_allowed,\n-                                               foreign_items_allowed,\n-                                               macros_allowed) {\n-                iovi_none =>\n-                    break,\n-                iovi_view_item(view_item) => {\n-                    if restricted_to_imports {\n-                            match view_item.node {\n-                                view_item_use(*) => {}\n-                                view_item_extern_mod(*) =>\n-                                    self.fatal(~\"\\\"extern mod\\\" \\\n-                                                 declarations are not \\\n-                                                 allowed here\")\n+        let mut done = false;\n+        if mode != FOREIGN_ITEMS_ALLOWED {\n+            let mut extern_mod_allowed = match mode {\n+                VIEW_ITEMS_AND_ITEMS_ALLOWED => true,\n+                IMPORTS_AND_ITEMS_ALLOWED => false,\n+                FOREIGN_ITEMS_ALLOWED => {\n+                    self.bug(~\"couldn't get here with FOREIGN_ITEMS_ALLOWED\")\n+                }\n+            };\n+\n+            loop {\n+                match self.parse_item_or_view_item(/*bad*/ copy attrs,\n+                                                   items_allowed,\n+                                                   foreign_items_allowed,\n+                                                   macros_allowed) {\n+                    iovi_none => {\n+                        done = true;\n+                        break;\n+                    }\n+                    iovi_view_item(view_item) => {\n+                        match view_item.node {\n+                            view_item_use(*) => {\n+                                // `extern mod` must precede `use`.\n+                                extern_mod_allowed = false;\n+                            }\n+                            view_item_extern_mod(*)\n+                                    if !extern_mod_allowed => {\n+                                self.span_err(view_item.span,\n+                                              ~\"\\\"extern mod\\\" \\\n+                                                declarations are not \\\n+                                                allowed here\");\n                             }\n+                            view_item_extern_mod(*) => {}\n+                        }\n+                        view_items.push(view_item);\n+                    }\n+                    iovi_item(item) => {\n+                        fail_unless!(items_allowed);\n+                        items.push(item);\n+                        attrs = self.parse_outer_attributes();\n+                        break;\n+                    }\n+                    iovi_foreign_item(foreign_item) => {\n+                        fail_unless!(foreign_items_allowed);\n+                        foreign_items.push(foreign_item);\n+                        attrs = self.parse_outer_attributes();\n+                        break;\n                     }\n-                    view_items.push(view_item);\n-                }\n-                iovi_item(item) => {\n-                    fail_unless!(items_allowed);\n-                    items.push(item)\n                 }\n-                iovi_foreign_item(foreign_item) => {\n-                    fail_unless!(foreign_items_allowed);\n-                    foreign_items.push(foreign_item);\n+                attrs = self.parse_outer_attributes();\n+            }\n+        }\n+\n+        // Next, parse items.\n+        if !done {\n+            loop {\n+                match self.parse_item_or_view_item(/*bad*/ copy attrs,\n+                                                   items_allowed,\n+                                                   foreign_items_allowed,\n+                                                   macros_allowed) {\n+                    iovi_none => break,\n+                    iovi_view_item(view_item) => {\n+                        self.span_err(view_item.span,\n+                                      ~\"`use` and `extern mod` declarations \\\n+                                        must precede items\");\n+                        view_items.push(view_item);\n+                    }\n+                    iovi_item(item) => {\n+                        fail_unless!(items_allowed);\n+                        items.push(item)\n+                    }\n+                    iovi_foreign_item(foreign_item) => {\n+                        fail_unless!(foreign_items_allowed);\n+                        foreign_items.push(foreign_item);\n+                    }\n                 }\n+                attrs = self.parse_outer_attributes();\n             }\n-            attrs = self.parse_outer_attributes();\n         }\n \n         ParsedItemsAndViewItems {"}, {"sha": "feff4b0616a449e3bc859e2a708ffb16f4b066e5", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -26,10 +26,10 @@\n #[no_core];\n \n extern mod core(vers = \"0.6\");\n-use core::*;\n-\n extern mod std(vers = \"0.6\");\n \n+use core::*;\n+\n pub mod syntax {\n     pub use ext;\n     pub use parse;"}, {"sha": "8276cea465fd58d90e4cbfd612e68ad51f55a675", "filename": "src/test/auxiliary/extern_mod_ordering_lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Ftest%2Fauxiliary%2Fextern_mod_ordering_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Ftest%2Fauxiliary%2Fextern_mod_ordering_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern_mod_ordering_lib.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -0,0 +1,6 @@\n+#[crate_type=\"lib\"];\n+\n+pub mod extern_mod_ordering_lib {\n+    pub fn f() {}\n+}\n+"}, {"sha": "b60302277b3265e73f25afe294f5938c910a0954", "filename": "src/test/run-pass/extern-mod-ordering-exe.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-ordering-exe.rs?ref=0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:extern_mod_ordering_lib.rs\n+// xfail-fast\n+\n+extern mod extern_mod_ordering_lib;\n+\n+use extern_mod_ordering_lib::extern_mod_ordering_lib;\n+\n+fn main() {\n+    extern_mod_ordering_lib::f();\n+}\n+"}]}